{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%                   EEEEE  X   X  PPPP    OOO   RRRR   TTTTT                  %\n%                   E       X X   P   P  O   O  R   R    T                    %\n%                   EEE      X    PPPP   O   O  RRRR     T                    %\n%                   E       X X   P      O   O  R R      T                    %\n%                   EEEEE  X   X  P       OOO   R  R     T                    %\n%                                                                             %\n%                 MagickCore Methods to Export Quantum Pixels                 %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E x p o r t Q u a n t u m P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExportQuantumPixels() transfers one or more pixel components from the image\n%  pixel cache to a user supplied buffer.  The pixels are returned in network\n%  byte order.  MagickTrue is returned if the pixels are successfully\n%  transferred, otherwise MagickFalse.\n%\n%  The format of the ExportQuantumPixels method is:\n%\n%      size_t ExportQuantumPixels(const Image *image,CacheView *image_view,\n%        QuantumInfo *quantum_info,const QuantumType quantum_type,\n%        unsigned char *magick_restrict pixels,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o image_view: the image cache view.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (RGB, RGBA,\n%      etc).\n%\n%    o pixels:  The components are transferred to this buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char *PopDoublePixel(QuantumInfo *quantum_info,\n  const double pixel,unsigned char *magick_restrict pixels)\n{\n  double\n    *p;\n\n  unsigned char\n    quantum[8];\n\n  (void) memset(quantum,0,sizeof(quantum));\n  p=(double *) quantum;\n  *p=(double) (pixel*quantum_info->state.inverse_scale+quantum_info->minimum);\n  if (quantum_info->endian == LSBEndian)\n    {\n      *pixels++=quantum[0];\n      *pixels++=quantum[1];\n      *pixels++=quantum[2];\n      *pixels++=quantum[3];\n      *pixels++=quantum[4];\n      *pixels++=quantum[5];\n      *pixels++=quantum[6];\n      *pixels++=quantum[7];\n      return(pixels);\n    }\n  *pixels++=quantum[7];\n  *pixels++=quantum[6];\n  *pixels++=quantum[5];\n  *pixels++=quantum[4];\n  *pixels++=quantum[3];\n  *pixels++=quantum[2];\n  *pixels++=quantum[1];\n  *pixels++=quantum[0];\n  return(pixels);\n}\n\nstatic inline unsigned char *PopFloatPixel(QuantumInfo *quantum_info,\n  const float pixel,unsigned char *magick_restrict pixels)\n{\n  float\n    *p;\n\n  unsigned char\n    quantum[4];\n\n  (void) memset(quantum,0,sizeof(quantum));\n  p=(float *) quantum;\n  *p=(float) ((double) pixel*quantum_info->state.inverse_scale+\n    quantum_info->minimum);\n  if (quantum_info->endian == LSBEndian)\n    {\n      *pixels++=quantum[0];\n      *pixels++=quantum[1];\n      *pixels++=quantum[2];\n      *pixels++=quantum[3];\n      return(pixels);\n    }\n  *pixels++=quantum[3];\n  *pixels++=quantum[2];\n  *pixels++=quantum[1];\n  *pixels++=quantum[0];\n  return(pixels);\n}\n\nstatic inline unsigned char *PopQuantumPixel(QuantumInfo *quantum_info,\n  const QuantumAny pixel,unsigned char *magick_restrict pixels)\n{\n  ssize_t\n    i;\n\n  size_t\n    quantum_bits;\n\n  if (quantum_info->state.bits == 0UL)\n    quantum_info->state.bits=8U;\n  for (i=(ssize_t) quantum_info->depth; i > 0L; )\n  {\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    i-=(ssize_t) quantum_bits;\n    if (i < 0)\n      i=0;\n    if (quantum_info->state.bits == 8UL)\n      *pixels='\\0';\n    quantum_info->state.bits-=quantum_bits;\n    *pixels|=(((pixel >> i) &~ ((~0UL) << quantum_bits)) <<\n      quantum_info->state.bits);\n    if (quantum_info->state.bits == 0UL)\n      {\n        pixels++;\n        quantum_info->state.bits=8UL;\n      }\n  }\n  return(pixels);\n}\n\nstatic inline unsigned char *PopQuantumLongPixel(QuantumInfo *quantum_info,\n  const size_t pixel,unsigned char *magick_restrict pixels)\n{\n  ssize_t\n    i;\n\n  size_t\n    quantum_bits;\n\n  if (quantum_info->state.bits == 0U)\n    quantum_info->state.bits=32UL;\n  for (i=(ssize_t) quantum_info->depth; i > 0; )\n  {\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    quantum_info->state.pixel|=(((pixel >> (quantum_info->depth-i)) &\n      quantum_info->state.mask[quantum_bits]) << (32U-\n        quantum_info->state.bits));\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n    if (quantum_info->state.bits == 0U)\n      {\n        pixels=PopLongPixel(quantum_info->endian,quantum_info->state.pixel,\n          pixels);\n        quantum_info->state.pixel=0U;\n        quantum_info->state.bits=32U;\n      }\n  }\n  return(pixels);\n}\n\nstatic void ExportAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  (void) exception;\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelAlpha(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelAlpha(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBGRQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  (void) exception;\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) (\n              ScaleQuantumToAny(GetPixelRed(image,p),range) << 22 |\n              ScaleQuantumToAny(GetPixelGreen(image,p),range) << 12 |\n              ScaleQuantumToAny(GetPixelBlue(image,p),range) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 12:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p+=GetPixelChannels(image);\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelAlpha(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelAlpha(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelAlpha(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBGROQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelOpacity(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelOpacity(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelOpacity(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelOpacity(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBlackQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBlueQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  Quantum\n    cbcr[4];\n\n  ssize_t\n    i,\n    x;\n\n  unsigned int\n    pixel;\n\n  size_t\n    quantum;\n\n  ssize_t\n    n;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  n=0;\n  quantum=0;\n  switch (quantum_info->depth)\n  {\n    case 10:\n    {\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x+=2)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  quantum=GetPixelRed(image,p);\n                  break;\n                }\n                case 1:\n                {\n                  quantum=GetPixelGreen(image,p);\n                  break;\n                }\n                case 2:\n                {\n                  quantum=GetPixelBlue(image,p);\n                  break;\n                }\n              }\n              cbcr[i]=(Quantum) quantum;\n              n++;\n            }\n            pixel=(unsigned int) ((size_t) (cbcr[1]) << 22 | (size_t)\n              (cbcr[0]) << 12 | (size_t) (cbcr[2]) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            pixel=(unsigned int) ((size_t) (cbcr[3]) << 22 | (size_t)\n              (cbcr[0]) << 12 | (size_t) (cbcr[2]) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      break;\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      for (x=0; x < (ssize_t) number_pixels; x+=2)\n      {\n        for (i=0; i < 4; i++)\n        {\n          switch (n % 3)\n          {\n            case 0:\n            {\n              quantum=GetPixelRed(image,p);\n              break;\n            }\n            case 1:\n            {\n              quantum=GetPixelGreen(image,p);\n              break;\n            }\n            case 2:\n            {\n              quantum=GetPixelBlue(image,p);\n              break;\n            }\n          }\n          cbcr[i]=(Quantum) quantum;\n          n++;\n        }\n        range=GetQuantumRange(quantum_info->depth);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[1],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[0],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[2],range),q);\n        p+=GetPixelChannels(image);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[3],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[0],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[2],range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCMYKAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            float_pixel=(float) (GetPixelAlpha(image,p));\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            pixel=(double) (GetPixelAlpha(image,p));\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCMYKOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            float_pixel=(float) (GetPixelOpacity(image,p));\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            pixel=(double) (GetPixelOpacity(image,p));\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelOpacity(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      double\n        threshold;\n\n      unsigned char\n        black,\n        white;\n\n      ssize_t\n        bit;\n\n      black=0x00;\n      white=0x01;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=0x01;\n          white=0x00;\n        }\n      threshold=QuantumRange/2.0;\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        *q='\\0';\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 7;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 6;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 5;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 4;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 3;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 2;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 1;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 0;\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            *q|=(GetPixelLuma(image,p) < threshold ? black : white) << bit;\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        *q=(((pixel >> 4) & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        *q|=pixel >> 4;\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n          *q=(((pixel >> 4) & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned int\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            pixel=(unsigned int) (ScaleQuantumToAny(ClampToQuantum(\n              GetPixelLuma(image,p+2*GetPixelChannels(image))),range) << 22 |\n              ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p+\n              GetPixelChannels(image))),range) << 12 | ScaleQuantumToAny(\n              ClampToQuantum(GetPixelLuma(image,p)),range) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=3*GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          if (x < (ssize_t) number_pixels)\n            {\n              pixel=0U;\n              if (x++ < (ssize_t) (number_pixels-1))\n                pixel|=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p+\n                  GetPixelChannels(image))),range) << 12;\n              if (x++ < (ssize_t) number_pixels)\n                pixel|=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                  range) << 2;\n              q=PopLongPixel(quantum_info->endian,pixel,q);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 12:\n    {\n      unsigned short\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,p)));\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel >> 4),\n              q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelLuma(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            float_pixel=(float) GetPixelLuma(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            double\n              pixel;\n\n            pixel=GetPixelLuma(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportGrayAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      double\n        threshold;\n\n      unsigned char\n        black,\n        pixel,\n        white;\n\n      ssize_t\n        bit;\n\n      black=0x00;\n      white=0x01;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=0x01;\n          white=0x00;\n        }\n      threshold=QuantumRange/2.0;\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        *q='\\0';\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 7;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 6);\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 5;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 4);\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 3;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 2);\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 1;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=0; bit <= (ssize_t) (number_pixels % 4); bit+=2)\n          {\n            *q|=(GetPixelLuma(image,p) > threshold ? black : white) <<\n              (7-bit);\n            pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n              0x00 : 0x01);\n            *q|=(((int) pixel != 0 ? 0x00 : 0x01) << (unsigned char)\n              (7-bit-1));\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        *q=(((pixel >> 4) & 0xf) << 4);\n        pixel=(unsigned char) (16*QuantumScale*GetPixelAlpha(image,p)+0.5);\n        *q|=pixel & 0xf;\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelLuma(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            float_pixel=(float) GetPixelLuma(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            float_pixel=(float) (GetPixelAlpha(image,p));\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            double\n              pixel;\n\n            pixel=GetPixelLuma(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            pixel=(double) (GetPixelAlpha(image,p));\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportGreenQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0x01) << 7);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 5);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 3);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 1);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) GetPixelIndex(image,p);\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) GetPixelIndex(image,p);\n          *q=((pixel & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(\n              QuantumScale*GetPixelIndex(image,p)),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportIndexAlphaQuantum(const Image *image,\n  QuantumInfo *quantum_info,const MagickSizeType number_pixels,\n  const Quantum *magick_restrict p,unsigned char *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n          {\n            pixel=(unsigned char) GetPixelIndex(image,p);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n            pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n              TransparentAlpha ? 1 : 0);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) (16*QuantumScale*GetPixelAlpha(image,p)+0.5);\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,(unsigned short)\n              GetPixelIndex(image,p),q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n              GetPixelIndex(image,p),q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            float_pixel=(float)  GetPixelAlpha(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            double\n              pixel;\n\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            pixel=(double) GetPixelAlpha(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelOpacity(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelOpacity(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(\n          GetPixelOpacity(image,p),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRedQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRGBQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) (\n              ScaleQuantumToAny(GetPixelRed(image,p),range) << 22 |\n              ScaleQuantumToAny(GetPixelGreen(image,p),range) << 12 |\n              ScaleQuantumToAny(GetPixelBlue(image,p),range) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 12:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p+=GetPixelChannels(image);\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelAlpha(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelAlpha(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelAlpha(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRGBOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelOpacity(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelOpacity(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelOpacity(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelOpacity(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nMagickExport size_t ExportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  const Quantum\n    *magick_restrict p;\n\n  ssize_t\n    x;\n\n  unsigned char\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (unsigned char *) NULL)\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      p=GetVirtualPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_view);\n      p=GetCacheViewVirtualPixelQueue(image_view);\n    }\n  if (quantum_info->alpha_type == AssociatedQuantumAlpha)\n    {\n      double\n        Sa;\n\n      Quantum\n        *magick_restrict q;\n\n      /*\n        Associate alpha.\n      */\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      else\n        q=GetAuthenticPixelQueue(image);\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        ssize_t\n          i;\n\n        Sa=QuantumScale*GetPixelAlpha(image,q);\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel = GetPixelChannelChannel(image,i);\n          PixelTrait traits = GetPixelChannelTraits(image,channel);\n          if ((traits & UpdatePixelTrait) == 0)\n            continue;\n          q[i]=ClampToQuantum(Sa*q[i]);\n        }\n        q+=GetPixelChannels(image);\n      }\n    }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      Quantum\n        *magick_restrict q;\n\n      if (image_view != (CacheView *) NULL)\n        q=GetAuthenticPixelQueue(image);\n      else\n        q=GetAuthenticPixelQueue(image);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  q=pixels;\n  ResetQuantumState(quantum_info);\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  switch (quantum_type)\n  {\n    case AlphaQuantum:\n    {\n      ExportAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRQuantum:\n    {\n      ExportBGRQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRAQuantum:\n    {\n      ExportBGRAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGROQuantum:\n    {\n      ExportBGROQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlackQuantum:\n    {\n      ExportBlackQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlueQuantum:\n    case YellowQuantum:\n    {\n      ExportBlueQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKQuantum:\n    {\n      ExportCMYKQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKAQuantum:\n    {\n      ExportCMYKAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKOQuantum:\n    {\n      ExportCMYKOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CbYCrYQuantum:\n    {\n      ExportCbYCrYQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayQuantum:\n    {\n      ExportGrayQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayAlphaQuantum:\n    {\n      ExportGrayAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GreenQuantum:\n    case MagentaQuantum:\n    {\n      ExportGreenQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexQuantum:\n    {\n      ExportIndexQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexAlphaQuantum:\n    {\n      ExportIndexAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RedQuantum:\n    case CyanQuantum:\n    {\n      ExportRedQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case OpacityQuantum:\n    {\n      ExportOpacityQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBQuantum:\n    case CbYCrQuantum:\n    {\n      ExportRGBQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBAQuantum:\n    case CbYCrAQuantum:\n    {\n      ExportRGBAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBOQuantum:\n    {\n      ExportRGBOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    default:\n      break;\n  }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      Quantum\n        *magick_restrict q;\n\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      else\n        q=GetAuthenticPixelQueue(image);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  return(extent);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%                   EEEEE  X   X  PPPP    OOO   RRRR   TTTTT                  %\n%                   E       X X   P   P  O   O  R   R    T                    %\n%                   EEE      X    PPPP   O   O  RRRR     T                    %\n%                   E       X X   P      O   O  R R      T                    %\n%                   EEEEE  X   X  P       OOO   R  R     T                    %\n%                                                                             %\n%                 MagickCore Methods to Export Quantum Pixels                 %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   E x p o r t Q u a n t u m P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExportQuantumPixels() transfers one or more pixel components from the image\n%  pixel cache to a user supplied buffer.  The pixels are returned in network\n%  byte order.  MagickTrue is returned if the pixels are successfully\n%  transferred, otherwise MagickFalse.\n%\n%  The format of the ExportQuantumPixels method is:\n%\n%      size_t ExportQuantumPixels(const Image *image,CacheView *image_view,\n%        QuantumInfo *quantum_info,const QuantumType quantum_type,\n%        unsigned char *magick_restrict pixels,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o image_view: the image cache view.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (RGB, RGBA,\n%      etc).\n%\n%    o pixels:  The components are transferred to this buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char *PopDoublePixel(QuantumInfo *quantum_info,\n  const double pixel,unsigned char *magick_restrict pixels)\n{\n  double\n    *p;\n\n  unsigned char\n    quantum[8];\n\n  (void) memset(quantum,0,sizeof(quantum));\n  p=(double *) quantum;\n  *p=(double) (pixel*quantum_info->state.inverse_scale+quantum_info->minimum);\n  if (quantum_info->endian == LSBEndian)\n    {\n      *pixels++=quantum[0];\n      *pixels++=quantum[1];\n      *pixels++=quantum[2];\n      *pixels++=quantum[3];\n      *pixels++=quantum[4];\n      *pixels++=quantum[5];\n      *pixels++=quantum[6];\n      *pixels++=quantum[7];\n      return(pixels);\n    }\n  *pixels++=quantum[7];\n  *pixels++=quantum[6];\n  *pixels++=quantum[5];\n  *pixels++=quantum[4];\n  *pixels++=quantum[3];\n  *pixels++=quantum[2];\n  *pixels++=quantum[1];\n  *pixels++=quantum[0];\n  return(pixels);\n}\n\nstatic inline unsigned char *PopFloatPixel(QuantumInfo *quantum_info,\n  const float pixel,unsigned char *magick_restrict pixels)\n{\n  float\n    *p;\n\n  unsigned char\n    quantum[4];\n\n  (void) memset(quantum,0,sizeof(quantum));\n  p=(float *) quantum;\n  *p=(float) ((double) pixel*quantum_info->state.inverse_scale+\n    quantum_info->minimum);\n  if (quantum_info->endian == LSBEndian)\n    {\n      *pixels++=quantum[0];\n      *pixels++=quantum[1];\n      *pixels++=quantum[2];\n      *pixels++=quantum[3];\n      return(pixels);\n    }\n  *pixels++=quantum[3];\n  *pixels++=quantum[2];\n  *pixels++=quantum[1];\n  *pixels++=quantum[0];\n  return(pixels);\n}\n\nstatic inline unsigned char *PopQuantumPixel(QuantumInfo *quantum_info,\n  const QuantumAny pixel,unsigned char *magick_restrict pixels)\n{\n  ssize_t\n    i;\n\n  size_t\n    quantum_bits;\n\n  if (quantum_info->state.bits == 0UL)\n    quantum_info->state.bits=8U;\n  for (i=(ssize_t) quantum_info->depth; i > 0L; )\n  {\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    i-=(ssize_t) quantum_bits;\n    if (i < 0)\n      i=0;\n    if (quantum_info->state.bits == 8UL)\n      *pixels='\\0';\n    quantum_info->state.bits-=quantum_bits;\n    *pixels|=(((pixel >> i) &~ ((~0UL) << quantum_bits)) <<\n      quantum_info->state.bits);\n    if (quantum_info->state.bits == 0UL)\n      {\n        pixels++;\n        quantum_info->state.bits=8UL;\n      }\n  }\n  return(pixels);\n}\n\nstatic inline unsigned char *PopQuantumLongPixel(QuantumInfo *quantum_info,\n  const size_t pixel,unsigned char *magick_restrict pixels)\n{\n  ssize_t\n    i;\n\n  size_t\n    quantum_bits;\n\n  if (quantum_info->state.bits == 0U)\n    quantum_info->state.bits=32UL;\n  for (i=(ssize_t) quantum_info->depth; i > 0; )\n  {\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    quantum_info->state.pixel|=(((pixel >> (quantum_info->depth-i)) &\n      quantum_info->state.mask[quantum_bits]) << (32U-\n        quantum_info->state.bits));\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n    if (quantum_info->state.bits == 0U)\n      {\n        pixels=PopLongPixel(quantum_info->endian,quantum_info->state.pixel,\n          pixels);\n        quantum_info->state.pixel=0U;\n        quantum_info->state.bits=32U;\n      }\n  }\n  return(pixels);\n}\n\nstatic void ExportAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  (void) exception;\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelAlpha(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelAlpha(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBGRQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  (void) exception;\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) (\n              ScaleQuantumToAny(GetPixelRed(image,p),range) << 22 |\n              ScaleQuantumToAny(GetPixelGreen(image,p),range) << 12 |\n              ScaleQuantumToAny(GetPixelBlue(image,p),range) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 12:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p+=GetPixelChannels(image);\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelAlpha(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelAlpha(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelAlpha(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBGROQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelOpacity(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelOpacity(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelOpacity(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelOpacity(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBlackQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportBlueQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  Quantum\n    cbcr[4];\n\n  ssize_t\n    i,\n    x;\n\n  unsigned int\n    pixel;\n\n  size_t\n    quantum;\n\n  ssize_t\n    n;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  n=0;\n  quantum=0;\n  switch (quantum_info->depth)\n  {\n    case 10:\n    {\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x+=2)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  quantum=GetPixelRed(image,p);\n                  break;\n                }\n                case 1:\n                {\n                  quantum=GetPixelGreen(image,p);\n                  break;\n                }\n                case 2:\n                {\n                  quantum=GetPixelBlue(image,p);\n                  break;\n                }\n              }\n              cbcr[i]=(Quantum) quantum;\n              n++;\n            }\n            pixel=(unsigned int) ((size_t) (cbcr[1]) << 22 | (size_t)\n              (cbcr[0]) << 12 | (size_t) (cbcr[2]) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            pixel=(unsigned int) ((size_t) (cbcr[3]) << 22 | (size_t)\n              (cbcr[0]) << 12 | (size_t) (cbcr[2]) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      break;\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      for (x=0; x < (ssize_t) number_pixels; x+=2)\n      {\n        for (i=0; i < 4; i++)\n        {\n          switch (n % 3)\n          {\n            case 0:\n            {\n              quantum=GetPixelRed(image,p);\n              break;\n            }\n            case 1:\n            {\n              quantum=GetPixelGreen(image,p);\n              break;\n            }\n            case 2:\n            {\n              quantum=GetPixelBlue(image,p);\n              break;\n            }\n          }\n          cbcr[i]=(Quantum) quantum;\n          n++;\n        }\n        range=GetQuantumRange(quantum_info->depth);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[1],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[0],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[2],range),q);\n        p+=GetPixelChannels(image);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[3],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[0],range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(cbcr[2],range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCMYKAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            float_pixel=(float) (GetPixelAlpha(image,p));\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            pixel=(double) (GetPixelAlpha(image,p));\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportCMYKOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlack(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlack(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlack(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlack(image,p),q);\n            float_pixel=(float) (GetPixelOpacity(image,p));\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlack(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlack(image,p),q);\n            pixel=(double) (GetPixelOpacity(image,p));\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlack(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelOpacity(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      double\n        threshold;\n\n      unsigned char\n        black,\n        white;\n\n      ssize_t\n        bit;\n\n      black=0x00;\n      white=0x01;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=0x01;\n          white=0x00;\n        }\n      threshold=QuantumRange/2.0;\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        *q='\\0';\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 7;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 6;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 5;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 4;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 3;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 2;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 1;\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) < threshold ? black : white) << 0;\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            *q|=(GetPixelLuma(image,p) < threshold ? black : white) << bit;\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        *q=(((pixel >> 4) & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        *q|=pixel >> 4;\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n          *q=(((pixel >> 4) & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned int\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            pixel=(unsigned int) (ScaleQuantumToAny(ClampToQuantum(\n              GetPixelLuma(image,p+2*GetPixelChannels(image))),range) << 22 |\n              ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p+\n              GetPixelChannels(image))),range) << 12 | ScaleQuantumToAny(\n              ClampToQuantum(GetPixelLuma(image,p)),range) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=3*GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          if (x < (ssize_t) number_pixels)\n            {\n              pixel=0U;\n              if (x++ < (ssize_t) (number_pixels-1))\n                pixel|=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p+\n                  GetPixelChannels(image))),range) << 12;\n              if (x++ < (ssize_t) number_pixels)\n                pixel|=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                  range) << 2;\n              q=PopLongPixel(quantum_info->endian,pixel,q);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 12:\n    {\n      unsigned short\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,p)));\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel >> 4),\n              q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelLuma(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            float_pixel=(float) GetPixelLuma(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            double\n              pixel;\n\n            pixel=GetPixelLuma(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportGrayAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      double\n        threshold;\n\n      unsigned char\n        black,\n        pixel,\n        white;\n\n      ssize_t\n        bit;\n\n      black=0x00;\n      white=0x01;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=0x01;\n          white=0x00;\n        }\n      threshold=QuantumRange/2.0;\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        *q='\\0';\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 7;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 6);\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 5;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 4);\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 3;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 2);\n        p+=GetPixelChannels(image);\n        *q|=(GetPixelLuma(image,p) > threshold ? black : white) << 1;\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n          0x00 : 0x01);\n        *q|=(((int) pixel != 0 ? 0x00 : 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=0; bit <= (ssize_t) (number_pixels % 4); bit+=2)\n          {\n            *q|=(GetPixelLuma(image,p) > threshold ? black : white) <<\n              (7-bit);\n            pixel=(unsigned char) (GetPixelAlpha(image,p) == OpaqueAlpha ?\n              0x00 : 0x01);\n            *q|=(((int) pixel != 0 ? 0x00 : 0x01) << (unsigned char)\n              (7-bit-1));\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        *q=(((pixel >> 4) & 0xf) << 4);\n        pixel=(unsigned char) (16*QuantumScale*GetPixelAlpha(image,p)+0.5);\n        *q|=pixel & 0xf;\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelLuma(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            float_pixel=(float) GetPixelLuma(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            float_pixel=(float) (GetPixelAlpha(image,p));\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(ClampToQuantum(GetPixelLuma(image,p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            double\n              pixel;\n\n            pixel=GetPixelLuma(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            pixel=(double) (GetPixelAlpha(image,p));\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(ClampToQuantum(\n          GetPixelLuma(image,p)),range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportGreenQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q=((pixel & 0x01) << 7);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 5);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 3);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 1);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q=((pixel & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n          *q=((pixel & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(\n              QuantumScale*GetPixelIndex(image,p)),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportIndexAlphaQuantum(const Image *image,\n  QuantumInfo *quantum_info,const MagickSizeType number_pixels,\n  const Quantum *magick_restrict p,unsigned char *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n          TransparentAlpha ? 1 : 0);\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n          {\n            pixel=(unsigned char) GetPixelIndex(image,p);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n            pixel=(unsigned char) (GetPixelAlpha(image,p) == (Quantum)\n              TransparentAlpha ? 1 : 0);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) (16*QuantumScale*GetPixelAlpha(image,p)+0.5);\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,(unsigned short)\n              GetPixelIndex(image,p),q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n              GetPixelIndex(image,p),q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            float_pixel=(float)  GetPixelAlpha(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            double\n              pixel;\n\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            pixel=(double) GetPixelAlpha(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelOpacity(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelOpacity(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(\n          GetPixelOpacity(image,p),range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRedQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRGBQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(image,p)),q);\n        q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) (\n              ScaleQuantumToAny(GetPixelRed(image,p),range) << 22 |\n              ScaleQuantumToAny(GetPixelGreen(image,p),range) << 12 |\n              ScaleQuantumToAny(GetPixelBlue(image,p),range) << 2);\n            q=PopLongPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 12:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),\n                  range);\n                break;\n              }\n              case 1:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n                  range);\n                break;\n              }\n              case 2:\n              {\n                pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),\n                  range);\n                p+=GetPixelChannels(image);\n                break;\n              }\n            }\n            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n              q);\n            q+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p+=GetPixelChannels(image);\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelAlpha(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelAlpha(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelAlpha(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelAlpha(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelAlpha(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelAlpha(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelAlpha(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelAlpha(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ExportRGBOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelGreen(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelBlue(image,p));\n        q=PopCharPixel(pixel,q);\n        pixel=ScaleQuantumToChar(GetPixelOpacity(image,p));\n        q=PopCharPixel(pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 10:\n    {\n      unsigned int\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          pixel=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (i)\n              {\n                case 0: quantum=GetPixelRed(image,p); break;\n                case 1: quantum=GetPixelGreen(image,p); break;\n                case 2: quantum=GetPixelBlue(image,p); break;\n                case 3: quantum=GetPixelOpacity(image,p); break;\n              }\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 22);\n                  break;\n                }\n                case 1:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 12);\n                  break;\n                }\n                case 2:\n                {\n                  pixel|=(size_t) (ScaleQuantumToAny((Quantum) quantum,\n                    range) << 2);\n                  q=PopLongPixel(quantum_info->endian,pixel,q);\n                  pixel=0;\n                  break;\n                }\n              }\n              n++;\n            }\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32UL)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),\n              range);\n            q=PopQuantumLongPixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        pixel=(unsigned int) ScaleQuantumToAny(GetPixelOpacity(image,p),range);\n        q=PopQuantumPixel(quantum_info,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelOpacity(image,p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelGreen(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelBlue(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToShort(GetPixelOpacity(image,p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            float\n              float_pixel;\n\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelGreen(image,p),q);\n            q=PopFloatPixel(quantum_info,(float) GetPixelBlue(image,p),q);\n            float_pixel=(float) GetPixelOpacity(image,p);\n            q=PopFloatPixel(quantum_info,float_pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelGreen(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelBlue(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        pixel=ScaleQuantumToLong(GetPixelOpacity(image,p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelGreen(image,p),q);\n            q=PopDoublePixel(quantum_info,(double) GetPixelBlue(image,p),q);\n            pixel=(double) GetPixelOpacity(image,p);\n            q=PopDoublePixel(quantum_info,pixel,q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelGreen(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelBlue(image,p),\n          range),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelOpacity(image,p),\n          range),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}\n\nMagickExport size_t ExportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  const Quantum\n    *magick_restrict p;\n\n  ssize_t\n    x;\n\n  unsigned char\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (unsigned char *) NULL)\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      p=GetVirtualPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_view);\n      p=GetCacheViewVirtualPixelQueue(image_view);\n    }\n  if (quantum_info->alpha_type == AssociatedQuantumAlpha)\n    {\n      double\n        Sa;\n\n      Quantum\n        *magick_restrict q;\n\n      /*\n        Associate alpha.\n      */\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      else\n        q=GetAuthenticPixelQueue(image);\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        ssize_t\n          i;\n\n        Sa=QuantumScale*GetPixelAlpha(image,q);\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel = GetPixelChannelChannel(image,i);\n          PixelTrait traits = GetPixelChannelTraits(image,channel);\n          if ((traits & UpdatePixelTrait) == 0)\n            continue;\n          q[i]=ClampToQuantum(Sa*q[i]);\n        }\n        q+=GetPixelChannels(image);\n      }\n    }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      Quantum\n        *magick_restrict q;\n\n      if (image_view != (CacheView *) NULL)\n        q=GetAuthenticPixelQueue(image);\n      else\n        q=GetAuthenticPixelQueue(image);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  q=pixels;\n  ResetQuantumState(quantum_info);\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  switch (quantum_type)\n  {\n    case AlphaQuantum:\n    {\n      ExportAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRQuantum:\n    {\n      ExportBGRQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRAQuantum:\n    {\n      ExportBGRAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGROQuantum:\n    {\n      ExportBGROQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlackQuantum:\n    {\n      ExportBlackQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlueQuantum:\n    case YellowQuantum:\n    {\n      ExportBlueQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKQuantum:\n    {\n      ExportCMYKQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKAQuantum:\n    {\n      ExportCMYKAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKOQuantum:\n    {\n      ExportCMYKOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CbYCrYQuantum:\n    {\n      ExportCbYCrYQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayQuantum:\n    {\n      ExportGrayQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayAlphaQuantum:\n    {\n      ExportGrayAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GreenQuantum:\n    case MagentaQuantum:\n    {\n      ExportGreenQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexQuantum:\n    {\n      ExportIndexQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexAlphaQuantum:\n    {\n      ExportIndexAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RedQuantum:\n    case CyanQuantum:\n    {\n      ExportRedQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case OpacityQuantum:\n    {\n      ExportOpacityQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBQuantum:\n    case CbYCrQuantum:\n    {\n      ExportRGBQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBAQuantum:\n    case CbYCrAQuantum:\n    {\n      ExportRGBAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBOQuantum:\n    {\n      ExportRGBOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    default:\n      break;\n  }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      Quantum\n        *magick_restrict q;\n\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      else\n        q=GetAuthenticPixelQueue(image);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  return(extent);\n}\n"], "filenames": ["MagickCore/quantum-export.c"], "buggy_code_start_loc": [2535], "buggy_code_end_loc": [2603], "fixing_code_start_loc": [2535], "fixing_code_end_loc": [2603], "type": "CWE-190", "message": "An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.", "other": {"cve": {"id": "CVE-2021-20224", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-25T20:15:08.873", "lastModified": "2023-03-11T23:15:17.240", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash."}, {"lang": "es", "value": "Se ha detectado un problema de desbordamiento de enteros en la funci\u00f3n ExportIndexQuantum() de ImageMagick en el archivo MagickCore/quantum-export.c. Las llamadas a la funci\u00f3n GetPixelIndex() podr\u00edan resultar en valores fuera del rango representable para el \"unsigned char\". Cuando ImageMagick procesa un archivo pdf dise\u00f1ado, esto podr\u00eda conllevar a un comportamiento no definido o un bloqueo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.11-57", "matchCriteriaId": "7C873805-B51C-4D74-86D1-78B609ADFE21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.10-57", "matchCriteriaId": "4CE77734-7D7E-4D73-9B49-F99157A5794B"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/5af1dffa4b6ab984b5f13d1e91c95760d75f12a6", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/pull/3083", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/553054c1cb1e4e05ec86237afef76a32cd7c464d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00008.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/5af1dffa4b6ab984b5f13d1e91c95760d75f12a6"}}