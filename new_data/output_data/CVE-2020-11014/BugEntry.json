{"buggy_code": ["import copy\nimport datetime\nfrom functools import partial\nimport json\nimport threading\nimport sys\nimport traceback\nimport math\n\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nfrom electroncash.address import Address, PublicKey\nfrom electroncash.bitcoin import base_encode, TYPE_ADDRESS\nfrom electroncash.i18n import _\nfrom electroncash.plugins import run_hook\n\nfrom .util import *\n\nfrom electroncash.util import bfh, format_satoshis_nofloat, format_satoshis_plain_nofloat, NotEnoughFunds, ExcessiveFee, PrintError, finalization_print_error\nfrom electroncash.transaction import Transaction\nfrom electroncash.slp import SlpMessage, SlpNoMintingBatonFound, SlpUnsupportedSlpTokenType, SlpInvalidOutputMessage, buildMintOpReturnOutput_V1\n\nfrom .amountedit import SLPAmountEdit\nfrom .transaction_dialog import show_transaction\n\nfrom electroncash import networks\n\ndialogs = []  # Otherwise python randomly garbage collects the dialogs...\n\nclass SlpCreateTokenMintDialog(QDialog, MessageBoxMixin, PrintError):\n\n    def __init__(self, main_window, token_id_hex):\n        # We want to be a top-level window\n        QDialog.__init__(self, parent=None)\n        from .main_window import ElectrumWindow\n\n        assert isinstance(main_window, ElectrumWindow)\n        main_window._slp_dialogs.add(self)\n        finalization_print_error(self)  # Track object lifecycle\n\n        self.main_window = main_window\n        self.wallet = main_window.wallet\n        self.network = main_window.network\n        self.app = main_window.app\n\n        if self.main_window.gui_object.warn_if_no_network(self.main_window):\n            return\n\n        self.setWindowTitle(_(\"Mint Additional Tokens\"))\n\n        vbox = QVBoxLayout()\n        self.setLayout(vbox)\n\n        grid = QGridLayout()\n        grid.setColumnStretch(1, 1)\n        vbox.addLayout(grid)\n        row = 0\n\n        msg = _('Unique identifier for the token.')\n        grid.addWidget(HelpLabel(_('Token ID:'), msg), row, 0)\n\n        self.token_id_e = QLineEdit()\n        self.token_id_e.setFixedWidth(490)\n        self.token_id_e.setText(token_id_hex)\n        self.token_id_e.setDisabled(True)\n        grid.addWidget(self.token_id_e, row, 1)\n        row += 1\n\n        msg = _('The number of decimal places used in the token quantity.')\n        grid.addWidget(HelpLabel(_('Decimals:'), msg), row, 0)\n        self.token_dec = QDoubleSpinBox()\n        decimals = self.main_window.wallet.token_types.get(token_id_hex)['decimals']\n        self.token_dec.setRange(0, 9)\n        self.token_dec.setValue(decimals)\n        self.token_dec.setDecimals(0)\n        self.token_dec.setFixedWidth(50)\n        self.token_dec.setDisabled(True)\n        grid.addWidget(self.token_dec, row, 1)\n        row += 1\n\n        msg = _('The number of tokens created during token minting transaction, send to the receiver address provided below.')\n        grid.addWidget(HelpLabel(_('Additional Token Quantity:'), msg), row, 0)\n        name = self.main_window.wallet.token_types.get(token_id_hex)['name']\n        self.token_qty_e = SLPAmountEdit(name, int(decimals))\n        self.token_qty_e.setFixedWidth(200)\n        self.token_qty_e.textChanged.connect(self.check_token_qty)\n        grid.addWidget(self.token_qty_e, row, 1)\n        row += 1\n\n        msg = _('The simpleledger formatted bitcoin address for the genesis receiver of all genesis tokens.')\n        grid.addWidget(HelpLabel(_('Token Receiver Address:'), msg), row, 0)\n        self.token_pay_to_e = ButtonsLineEdit()\n        self.token_pay_to_e.setFixedWidth(490)\n        grid.addWidget(self.token_pay_to_e, row, 1)\n        row += 1\n\n        msg = _('The simpleledger formatted bitcoin address for the genesis baton receiver.')\n        self.token_baton_label = HelpLabel(_('Mint Baton Address:'), msg)\n        grid.addWidget(self.token_baton_label, row, 0)\n        self.token_baton_to_e = ButtonsLineEdit()\n        self.token_baton_to_e.setFixedWidth(490)\n        grid.addWidget(self.token_baton_to_e, row, 1)\n        row += 1\n\n        try:\n            slpAddr = self.wallet.get_unused_address().to_slpaddr()\n            self.token_pay_to_e.setText(Address.prefix_from_address_string(slpAddr) + \":\" + slpAddr)\n            self.token_baton_to_e.setText(Address.prefix_from_address_string(slpAddr) + \":\" + slpAddr)\n        except Exception as e:\n            pass\n\n        self.token_fixed_supply_cb = cb = QCheckBox(_('Permanently end issuance'))\n        self.token_fixed_supply_cb.setChecked(False)\n        grid.addWidget(self.token_fixed_supply_cb, row, 0)\n        cb.clicked.connect(self.show_mint_baton_address)\n        row += 1\n\n        hbox = QHBoxLayout()\n        vbox.addLayout(hbox)\n\n        self.cancel_button = b = QPushButton(_(\"Cancel\"))\n        self.cancel_button.setAutoDefault(False)\n        self.cancel_button.setDefault(False)\n        b.clicked.connect(self.close)\n        b.setDefault(True)\n        hbox.addWidget(self.cancel_button)\n\n        hbox.addStretch(1)\n\n        self.preview_button = EnterButton(_(\"Preview\"), self.do_preview)\n        self.mint_button = b = QPushButton(_(\"Create Additional Tokens\"))\n        b.clicked.connect(self.mint_token)\n        self.mint_button.setAutoDefault(True)\n        self.mint_button.setDefault(True)\n        hbox.addWidget(self.preview_button)\n        hbox.addWidget(self.mint_button)\n\n        dialogs.append(self)\n        self.show()\n        self.token_qty_e.setFocus()\n\n    def do_preview(self):\n        self.mint_token(preview = True)\n\n    def show_mint_baton_address(self):\n        self.token_baton_to_e.setHidden(self.token_fixed_supply_cb.isChecked())\n        self.token_baton_label.setHidden(self.token_fixed_supply_cb.isChecked())\n\n    def parse_address(self, address):\n        if networks.net.SLPADDR_PREFIX not in address:\n            address = networks.net.SLPADDR_PREFIX + \":\" + address\n        return Address.from_string(address)\n\n    def mint_token(self, preview=False):\n        decimals = int(self.token_dec.value())\n        mint_baton_vout = 2 if self.token_baton_to_e.text() != '' and not self.token_fixed_supply_cb.isChecked() else None\n        init_mint_qty = self.token_qty_e.get_amount()\n        if init_mint_qty is None:\n            self.show_message(_(\"Invalid token quantity entered.\"))\n            return\n        if init_mint_qty > (2 ** 64) - 1:\n            maxqty = format_satoshis_plain_nofloat((2 ** 64) - 1, decimals)\n            self.show_message(_(\"Token output quantity is too large. Maximum %s.\")%(maxqty,))\n            return\n\n        outputs = []\n        try:\n            token_id_hex = self.token_id_e.text()\n            token_type = self.wallet.token_types[token_id_hex]['class']\n            slp_op_return_msg = buildMintOpReturnOutput_V1(token_id_hex, mint_baton_vout, init_mint_qty, token_type)\n            outputs.append(slp_op_return_msg)\n        except OPReturnTooLarge:\n            self.show_message(_(\"Optional string text causiing OP_RETURN greater than 223 bytes.\"))\n            return\n        except Exception as e:\n            traceback.print_exc(file=sys.stdout)\n            self.show_message(str(e))\n            return\n\n        try:\n            addr = self.parse_address(self.token_pay_to_e.text())\n            outputs.append((TYPE_ADDRESS, addr, 546))\n        except:\n            self.show_message(_(\"Enter a Mint Receiver Address in SLP address format.\"))\n            return\n\n        if not self.token_fixed_supply_cb.isChecked():\n            try:\n                addr = self.parse_address(self.token_baton_to_e.text())\n                outputs.append((TYPE_ADDRESS, addr, 546))\n            except:\n                self.show_message(_(\"Enter a Baton Address in SLP address format.\"))\n                return\n\n        # IMPORTANT: set wallet.sedn_slpTokenId to None to guard tokens during this transaction\n        self.main_window.token_type_combo.setCurrentIndex(0)\n        assert self.main_window.slp_token_id == None\n\n        coins = self.main_window.get_coins()\n        fee = None\n\n        try:\n            baton_input = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())\n        except SlpNoMintingBatonFound as e:\n            self.show_message(_(\"No baton exists for this token.\"))\n            return\n\n        desired_fee_rate = 1.0  # sats/B, just init this value for paranoia\n        try:\n            tx = self.main_window.wallet.make_unsigned_transaction(coins, outputs, self.main_window.config, fee, None)\n            desired_fee_rate = tx.get_fee() / tx.estimated_size()  # remember the fee coin chooser & wallet gave us as a fee rate so we may use it below after adding baton to adjust fee downward to this rate.\n        except NotEnoughFunds:\n            self.show_message(_(\"Insufficient funds\"))\n            return\n        except ExcessiveFee:\n            self.show_message(_(\"Your fee is too high.  Max is 50 sat/byte.\"))\n            return\n        except BaseException as e:\n            traceback.print_exc(file=sys.stdout)\n            self.show_message(str(e))\n            return\n\n        # Find & Add baton to tx inputs\n        try:\n            baton_utxo = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())\n        except SlpNoMintingBatonFound:\n            self.show_message(_(\"There is no minting baton found for this token.\"))\n            return\n\n        tx.add_inputs([baton_utxo])\n        for txin in tx._inputs:\n            self.main_window.wallet.add_input_info(txin)\n\n        def tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate):\n            ''' adjust change amount (based on amount added from baton) '''\n            if len(tx._outputs) not in (3,4):\n                # no change, or a tx shape we don't know about\n                self.print_error(f\"Unkown tx shape, not adjusting fee!\")\n                return\n            chg = tx._outputs[-1]  # change is always the last output due to BIP_LI01 sorting\n            assert len(chg) == 3, \"Expected tx output to be of length 3\"\n            if not self.main_window.wallet.is_mine(chg[1]):\n                self.print_error(f\"Unkown change address {chg[1]}, not adjusting fee!\")\n                return\n            chg_amt = chg[2]\n            if chg_amt <= 546:\n                # if change is 546, then the BIP_LI01 sorting doesn't guarantee\n                # change output is at the end.. so we don't know which was\n                # changed based on the heuristics this code relies on.. so..\n                # Abort! Abort!\n                self.print_error(\"Could not determine change output, not adjusting fee!\")\n                return\n            curr_fee, curr_size = tx.get_fee(), tx.estimated_size()\n            fee_rate = curr_fee / curr_size\n            diff = math.ceil((fee_rate - desired_fee_rate) * curr_size)\n            if diff > 0:\n                tx._outputs[-1] = (chg[0], chg[1], chg[2] + diff)  # adjust the output\n                self.print_error(f\"Added {diff} sats to change to maintain fee rate of {desired_fee_rate:0.2f}, new fee: {tx.get_fee()}\")\n\n        tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate)\n\n        if preview:\n            show_transaction(tx, self.main_window, None, False, self)\n            return\n\n        msg = []\n\n        if self.main_window.wallet.has_password():\n            msg.append(\"\")\n            msg.append(_(\"Enter your password to proceed\"))\n            password = self.main_window.password_dialog('\\n'.join(msg))\n            if not password:\n                return\n        else:\n            password = None\n\n        tx_desc = None\n\n        def sign_done(success):\n            if success:\n                if not tx.is_complete():\n                    show_transaction(tx, self.main_window, None, False, self)\n                    self.main_window.do_clear()\n                else:\n                    self.main_window.broadcast_transaction(tx, tx_desc)\n\n        self.main_window.sign_tx_with_password(tx, sign_done, password)\n\n        self.mint_button.setDisabled(True)\n        self.close()\n\n    def closeEvent(self, event):\n        super().closeEvent(event)\n        event.accept()\n        def remove_self():\n            try: dialogs.remove(self)\n            except ValueError: pass  # wasn't in list.\n        QTimer.singleShot(0, remove_self)  # need to do this some time later. Doing it from within this function causes crashes. See #35\n\n    def update(self):\n        return\n\n    def check_token_qty(self):\n        try:\n            if self.token_qty_e.get_amount() > (10 ** 19):\n                self.show_warning(_('If you issue this much, users will may find it awkward to transfer large amounts as each transaction output may only take up to ~2 x 10^(19-decimals) tokens, thus requiring multiple outputs for very large amounts.'))\n        except:\n            pass\n"], "fixing_code": ["import copy\nimport datetime\nfrom functools import partial\nimport json\nimport threading\nimport sys\nimport traceback\nimport math\n\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nfrom electroncash.address import Address, PublicKey\nfrom electroncash.bitcoin import base_encode, TYPE_ADDRESS\nfrom electroncash.i18n import _\nfrom electroncash.plugins import run_hook\n\nfrom .util import *\n\nfrom electroncash.util import bfh, format_satoshis_nofloat, format_satoshis_plain_nofloat, NotEnoughFunds, ExcessiveFee, PrintError, finalization_print_error\nfrom electroncash.transaction import Transaction\nfrom electroncash.slp import SlpMessage, SlpNoMintingBatonFound, SlpUnsupportedSlpTokenType, SlpInvalidOutputMessage, buildMintOpReturnOutput_V1\n\nfrom .amountedit import SLPAmountEdit\nfrom .transaction_dialog import show_transaction\n\nfrom electroncash import networks\n\ndialogs = []  # Otherwise python randomly garbage collects the dialogs...\n\nclass SlpCreateTokenMintDialog(QDialog, MessageBoxMixin, PrintError):\n\n    def __init__(self, main_window, token_id_hex):\n        # We want to be a top-level window\n        QDialog.__init__(self, parent=None)\n        from .main_window import ElectrumWindow\n\n        assert isinstance(main_window, ElectrumWindow)\n        main_window._slp_dialogs.add(self)\n        finalization_print_error(self)  # Track object lifecycle\n\n        self.main_window = main_window\n        self.wallet = main_window.wallet\n        self.network = main_window.network\n        self.app = main_window.app\n\n        if self.main_window.gui_object.warn_if_no_network(self.main_window):\n            return\n\n        self.setWindowTitle(_(\"Mint Additional Tokens\"))\n\n        vbox = QVBoxLayout()\n        self.setLayout(vbox)\n\n        grid = QGridLayout()\n        grid.setColumnStretch(1, 1)\n        vbox.addLayout(grid)\n        row = 0\n\n        msg = _('Unique identifier for the token.')\n        grid.addWidget(HelpLabel(_('Token ID:'), msg), row, 0)\n\n        self.token_id_e = QLineEdit()\n        self.token_id_e.setFixedWidth(490)\n        self.token_id_e.setText(token_id_hex)\n        self.token_id_e.setDisabled(True)\n        grid.addWidget(self.token_id_e, row, 1)\n        row += 1\n\n        msg = _('The number of decimal places used in the token quantity.')\n        grid.addWidget(HelpLabel(_('Decimals:'), msg), row, 0)\n        self.token_dec = QDoubleSpinBox()\n        decimals = self.main_window.wallet.token_types.get(token_id_hex)['decimals']\n        self.token_dec.setRange(0, 9)\n        self.token_dec.setValue(decimals)\n        self.token_dec.setDecimals(0)\n        self.token_dec.setFixedWidth(50)\n        self.token_dec.setDisabled(True)\n        grid.addWidget(self.token_dec, row, 1)\n        row += 1\n\n        msg = _('The number of tokens created during token minting transaction, send to the receiver address provided below.')\n        grid.addWidget(HelpLabel(_('Additional Token Quantity:'), msg), row, 0)\n        name = self.main_window.wallet.token_types.get(token_id_hex)['name']\n        self.token_qty_e = SLPAmountEdit(name, int(decimals))\n        self.token_qty_e.setFixedWidth(200)\n        self.token_qty_e.textChanged.connect(self.check_token_qty)\n        grid.addWidget(self.token_qty_e, row, 1)\n        row += 1\n\n        msg = _('The simpleledger formatted bitcoin address for the genesis receiver of all genesis tokens.')\n        grid.addWidget(HelpLabel(_('Token Receiver Address:'), msg), row, 0)\n        self.token_pay_to_e = ButtonsLineEdit()\n        self.token_pay_to_e.setFixedWidth(490)\n        grid.addWidget(self.token_pay_to_e, row, 1)\n        row += 1\n\n        msg = _('The simpleledger formatted bitcoin address for the genesis baton receiver.')\n        self.token_baton_label = HelpLabel(_('Mint Baton Address:'), msg)\n        grid.addWidget(self.token_baton_label, row, 0)\n        self.token_baton_to_e = ButtonsLineEdit()\n        self.token_baton_to_e.setFixedWidth(490)\n        grid.addWidget(self.token_baton_to_e, row, 1)\n        row += 1\n\n        try:\n            slpAddr = self.wallet.get_unused_address().to_slpaddr()\n            self.token_pay_to_e.setText(Address.prefix_from_address_string(slpAddr) + \":\" + slpAddr)\n            self.token_baton_to_e.setText(Address.prefix_from_address_string(slpAddr) + \":\" + slpAddr)\n        except Exception as e:\n            pass\n\n        self.token_fixed_supply_cb = cb = QCheckBox(_('Permanently end issuance'))\n        self.token_fixed_supply_cb.setChecked(False)\n        grid.addWidget(self.token_fixed_supply_cb, row, 0)\n        cb.clicked.connect(self.show_mint_baton_address)\n        row += 1\n\n        hbox = QHBoxLayout()\n        vbox.addLayout(hbox)\n\n        self.cancel_button = b = QPushButton(_(\"Cancel\"))\n        self.cancel_button.setAutoDefault(False)\n        self.cancel_button.setDefault(False)\n        b.clicked.connect(self.close)\n        b.setDefault(True)\n        hbox.addWidget(self.cancel_button)\n\n        hbox.addStretch(1)\n\n        self.preview_button = EnterButton(_(\"Preview\"), self.do_preview)\n        self.mint_button = b = QPushButton(_(\"Create Additional Tokens\"))\n        b.clicked.connect(self.mint_token)\n        self.mint_button.setAutoDefault(True)\n        self.mint_button.setDefault(True)\n        hbox.addWidget(self.preview_button)\n        hbox.addWidget(self.mint_button)\n\n        dialogs.append(self)\n        self.show()\n        self.token_qty_e.setFocus()\n\n    def do_preview(self):\n        self.mint_token(preview = True)\n\n    def show_mint_baton_address(self):\n        self.token_baton_to_e.setHidden(self.token_fixed_supply_cb.isChecked())\n        self.token_baton_label.setHidden(self.token_fixed_supply_cb.isChecked())\n\n    def parse_address(self, address):\n        if networks.net.SLPADDR_PREFIX not in address:\n            address = networks.net.SLPADDR_PREFIX + \":\" + address\n        return Address.from_string(address)\n\n    def mint_token(self, preview=False):\n        decimals = int(self.token_dec.value())\n        mint_baton_vout = 2 if self.token_baton_to_e.text() != '' and not self.token_fixed_supply_cb.isChecked() else None\n        init_mint_qty = self.token_qty_e.get_amount()\n        if init_mint_qty is None:\n            self.show_message(_(\"Invalid token quantity entered.\"))\n            return\n        if init_mint_qty > (2 ** 64) - 1:\n            maxqty = format_satoshis_plain_nofloat((2 ** 64) - 1, decimals)\n            self.show_message(_(\"Token output quantity is too large. Maximum %s.\")%(maxqty,))\n            return\n\n        outputs = []\n        try:\n            token_id_hex = self.token_id_e.text()\n            token_type = self.wallet.token_types[token_id_hex]['class']\n            slp_op_return_msg = buildMintOpReturnOutput_V1(token_id_hex, mint_baton_vout, init_mint_qty, token_type)\n            outputs.append(slp_op_return_msg)\n        except OPReturnTooLarge:\n            self.show_message(_(\"Optional string text causiing OP_RETURN greater than 223 bytes.\"))\n            return\n        except Exception as e:\n            traceback.print_exc(file=sys.stdout)\n            self.show_message(str(e))\n            return\n\n        try:\n            addr = self.parse_address(self.token_pay_to_e.text())\n            outputs.append((TYPE_ADDRESS, addr, 546))\n        except:\n            self.show_message(_(\"Enter a Mint Receiver Address in SLP address format.\"))\n            return\n\n        if not self.token_fixed_supply_cb.isChecked():\n            try:\n                addr = self.parse_address(self.token_baton_to_e.text())\n                outputs.append((TYPE_ADDRESS, addr, 546))\n            except:\n                self.show_message(_(\"Enter a Baton Address in SLP address format.\"))\n                return\n\n        # IMPORTANT: set wallet.sedn_slpTokenId to None to guard tokens during this transaction\n        self.main_window.token_type_combo.setCurrentIndex(0)\n        assert self.main_window.slp_token_id == None\n\n        coins = self.main_window.get_coins()\n        fee = None\n\n        try:\n            baton_input = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())\n        except SlpNoMintingBatonFound as e:\n            self.show_message(_(\"No baton exists for this token.\"))\n            return\n\n        desired_fee_rate = 1.0  # sats/B, just init this value for paranoia\n        try:\n            tx = self.main_window.wallet.make_unsigned_transaction(coins, outputs, self.main_window.config, fee, None, mandatory_coins=[baton_input])\n            desired_fee_rate = tx.get_fee() / tx.estimated_size()  # remember the fee coin chooser & wallet gave us as a fee rate so we may use it below after adding baton to adjust fee downward to this rate.\n        except NotEnoughFunds:\n            self.show_message(_(\"Insufficient funds\"))\n            return\n        except ExcessiveFee:\n            self.show_message(_(\"Your fee is too high.  Max is 50 sat/byte.\"))\n            return\n        except BaseException as e:\n            traceback.print_exc(file=sys.stdout)\n            self.show_message(str(e))\n            return\n\n\n        def tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate):\n            ''' adjust change amount (based on amount added from baton) '''\n            if len(tx._outputs) not in (3,4):\n                # no change, or a tx shape we don't know about\n                self.print_error(f\"Unkown tx shape, not adjusting fee!\")\n                return\n            chg = tx._outputs[-1]  # change is always the last output due to BIP_LI01 sorting\n            assert len(chg) == 3, \"Expected tx output to be of length 3\"\n            if not self.main_window.wallet.is_mine(chg[1]):\n                self.print_error(f\"Unkown change address {chg[1]}, not adjusting fee!\")\n                return\n            chg_amt = chg[2]\n            if chg_amt <= 546:\n                # if change is 546, then the BIP_LI01 sorting doesn't guarantee\n                # change output is at the end.. so we don't know which was\n                # changed based on the heuristics this code relies on.. so..\n                # Abort! Abort!\n                self.print_error(\"Could not determine change output, not adjusting fee!\")\n                return\n            curr_fee, curr_size = tx.get_fee(), tx.estimated_size()\n            fee_rate = curr_fee / curr_size\n            diff = math.ceil((fee_rate - desired_fee_rate) * curr_size)\n            if diff > 0:\n                tx._outputs[-1] = (chg[0], chg[1], chg[2] + diff)  # adjust the output\n                self.print_error(f\"Added {diff} sats to change to maintain fee rate of {desired_fee_rate:0.2f}, new fee: {tx.get_fee()}\")\n\n        tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate)\n\n        if preview:\n            show_transaction(tx, self.main_window, None, False, self)\n            return\n\n        msg = []\n\n        if self.main_window.wallet.has_password():\n            msg.append(\"\")\n            msg.append(_(\"Enter your password to proceed\"))\n            password = self.main_window.password_dialog('\\n'.join(msg))\n            if not password:\n                return\n        else:\n            password = None\n\n        tx_desc = None\n\n        def sign_done(success):\n            if success:\n                if not tx.is_complete():\n                    show_transaction(tx, self.main_window, None, False, self)\n                    self.main_window.do_clear()\n                else:\n                    self.main_window.broadcast_transaction(tx, tx_desc)\n\n        self.main_window.sign_tx_with_password(tx, sign_done, password)\n\n        self.mint_button.setDisabled(True)\n        self.close()\n\n    def closeEvent(self, event):\n        super().closeEvent(event)\n        event.accept()\n        def remove_self():\n            try: dialogs.remove(self)\n            except ValueError: pass  # wasn't in list.\n        QTimer.singleShot(0, remove_self)  # need to do this some time later. Doing it from within this function causes crashes. See #35\n\n    def update(self):\n        return\n\n    def check_token_qty(self):\n        try:\n            if self.token_qty_e.get_amount() > (10 ** 19):\n                self.show_warning(_('If you issue this much, users will may find it awkward to transfer large amounts as each transaction output may only take up to ~2 x 10^(19-decimals) tokens, thus requiring multiple outputs for very large amounts.'))\n        except:\n            pass\n"], "filenames": ["gui/qt/slp_create_token_mint_dialog.py"], "buggy_code_start_loc": [212], "buggy_code_end_loc": [235], "fixing_code_start_loc": [212], "fixing_code_end_loc": [224], "type": "NVD-CWE-noinfo", "message": "Electron-Cash-SLP before version 3.6.2 has a vulnerability. All token creators that use the \"Mint Tool\" feature of the Electron Cash SLP Edition are at risk of sending the minting authority baton to the wrong SLP address. Sending the mint baton to the wrong address will give another party the ability to issue new tokens or permanently destroy future minting capability. This is fixed version 3.6.2.", "other": {"cve": {"id": "CVE-2020-11014", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-28T20:15:12.593", "lastModified": "2020-05-06T18:22:42.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Electron-Cash-SLP before version 3.6.2 has a vulnerability. All token creators that use the \"Mint Tool\" feature of the Electron Cash SLP Edition are at risk of sending the minting authority baton to the wrong SLP address. Sending the mint baton to the wrong address will give another party the ability to issue new tokens or permanently destroy future minting capability. This is fixed version 3.6.2."}, {"lang": "es", "value": "Electron-Cash-SLP versiones anteriores a 3.6.2, tiene una vulnerabilidad. Todos los creadores de tokens que usan la funci\u00f3n \"Mint Tool\" de Electron Cash SLP Edition corren el riesgo de enviar el testigo de la autoridad de acu\u00f1aci\u00f3n a la direcci\u00f3n SLP incorrecta. Enviar el testigo de acu\u00f1aci\u00f3n a la direcci\u00f3n incorrecta le dar\u00e1 a la otra parte la capacidad de emitir nuevos tokens o destruir permanentemente la capacidad de acu\u00f1ar en el futuro. Esto se corrigi\u00f3 en la versi\u00f3n 3.6.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simpleledger:electron-cash-slp:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.2", "matchCriteriaId": "16287AEE-3F39-410A-A712-D8006C6FAE57"}]}]}], "references": [{"url": "https://github.com/kristovatlas/rfc/blob/master/bips/bip-li01.mediawiki", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/simpleledger/Electron-Cash-SLP/commit/ea3912c3d508ba81b280ef7d78648464f7f76fb8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/simpleledger/Electron-Cash-SLP/issues/126", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/simpleledger/Electron-Cash-SLP/security/advisories/GHSA-cchm-grx2-g873", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/simpleledger/Electron-Cash-SLP/commit/ea3912c3d508ba81b280ef7d78648464f7f76fb8"}}