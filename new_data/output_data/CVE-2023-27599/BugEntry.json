{"buggy_code": ["/*\n * Copyright (C) 2001-2003 Fhg Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * ---------\n * 2003-04-26 ZSW (jiri)\n * 2006-05-29 removed the NO_PINGTEL_TAG_HACK - it's conflicting the RFC 3261;\n *            TAG parameter must have value; other parameters are accepted\n *            without value (bogdan)\n */\n\n\n#include \"parse_to.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"../dprint.h\"\n#include \"msg_parser.h\"\n#include \"parse_uri.h\"\n#include \"../ut.h\"\n#include \"../mem/mem.h\"\n#include \"../errinfo.h\"\n\n\nenum {\n\tSTART_TO, DISPLAY_QUOTED, E_DISPLAY_QUOTED, DISPLAY_TOKEN, DISPLAY_TOKEN2,\n\tS_URI_ENCLOSED, URI_ENCLOSED, E_URI_ENCLOSED,\n\tURI_OR_TOKEN, MAYBE_URI_END, END, F_CR, F_LF, F_CRLF\n};\n\n\nenum {\n\tS_PARA_NAME=20, PARA_NAME, S_EQUAL, S_PARA_VALUE, TAG1, TAG2,\n\tTAG3, PARA_VALUE_TOKEN , PARA_VALUE_QUOTED, E_PARA_VALUE\n};\n\n\n\n#define add_param( _param , _body ) \\\n\tdo{\\\n\t\tLM_DBG(\"%.*s=%.*s\\n\",param->name.len,ZSW(param->name.s),\\\n\t\t\tparam->value.len,ZSW(param->value.s));\\\n\t\tif (!(_body)->param_lst)  (_body)->param_lst=(_param);\\\n\t\telse (_body)->last_param->next=(_param);\\\n\t\t(_body)->last_param =(_param);\\\n\t\tif ((_param)->type==TAG_PARAM)\\\n\t\t\tmemcpy(&((_body)->tag_value),&((_param)->value),sizeof(str));\\\n\t\t(_param) = 0;\\\n\t}while(0);\n\n\n\nvoid free_to_params(struct to_body* tb)\n{\n\tstruct to_param *tp=tb->param_lst;\n\tstruct to_param *foo;\n\twhile (tp){\n\t\tfoo = tp->next;\n\t\tpkg_free(tp);\n\t\ttp=foo;\n\t}\n\n\ttb->param_lst = tb->last_param = NULL;\n}\n\n\nvoid free_to(struct to_body* tb)\n{\n\tif (tb) {\n\t\tfree_to( tb->next );\n\t\tfree_to_params(tb);\n\t\tpkg_free(tb);\n\t}\n}\n\n\nstatic inline char* parse_to_param(char *buffer, char *end,\n\t\t\t\t\tstruct to_body *to_b,\n\t\t\t\t\tint *returned_status,\n\t\t\t\t\tint multi)\n{\n\tstruct to_param *param;\n\tint status;\n\tint saved_status;\n\tchar  *tmp;\n\n\tparam=0;\n\tstatus=E_PARA_VALUE;\n\tsaved_status=E_PARA_VALUE;\n\tfor( tmp=buffer; tmp<end; tmp++)\n\t{\n\t\tswitch(*tmp)\n\t\t{\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tstatus = S_EQUAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now =' '*/\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tsaved_status = S_EQUAL;\n\t\t\t\t\t\tstatus = F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\t\t\t\tstatus = F_LF;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\tstatus=F_CRLF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tsaved_status = S_EQUAL;\n\t\t\t\t\t\tstatus = F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\t\t\t\tstatus = F_CR;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase  0:\n\t\t\tcase ',':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status = status;\n\t\t\t\t\t\tif ( !multi && *tmp==',')\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tswitch (*(tmp+1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase '\\r':\n\t\t\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp+1;\n\t\t\t\t\t\tstatus = PARA_VALUE_QUOTED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tparam->value.len=tmp-param->value.s ;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ';' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len=tmp-param->value.s;\n\t\t\t\t\t\tadd_param(param,to_b);\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tparam = (struct to_param*)\n\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_param));\n\t\t\t\t\t\tif (!param){\n\t\t\t\t\t\t\tLM_ERR(\"out of pkg memory\\n\" );\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemset(param,0,sizeof(struct to_param));\n\t\t\t\t\t\tparam->type=GENERAL_PARAM;\n\t\t\t\t\t\tstatus = S_PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\tcase 't' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = TAG1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\tcase 'a' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\t\tstatus = TAG2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\tcase 'g' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tstatus = TAG3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '=':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tstatus = S_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\t\tstatus = S_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tLM_ERR(\"spitting out [%c] in status %d\\n\",*tmp,status );\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t}/*switch*/\n\t}/*for*/\n\n\nendofheader:\n\tif (param) {\n\t\tif (saved_status==S_EQUAL||saved_status==S_PARA_VALUE) {\n\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\tparam->value.s= 0;\n\t\t\tparam->value.len=0;\n\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\tgoto parse_error;\n\t\t\tadd_param(param, to_b);\n\t\t} else {\n\t\t\tpkg_free(param);\n\t\t}\n\t}\n\t*returned_status=saved_status;\n\treturn tmp;\n\nparse_error:\n\tLM_ERR(\"unexpected char [%c] in status %d: <<%.*s>> .\\n\",\n\t\t*tmp,status, (int)(tmp-buffer), ZSW(buffer));\nerror:\n\tif (param) pkg_free(param);\n\tfree_to_params(to_b);\n\tto_b->error=PARSE_ERROR;\n\t*returned_status = status;\n\treturn tmp;\n}\n\n\n\n\nstatic inline char* _parse_to(char* buffer, char *end, struct to_body *to_b,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint multi)\n{\n\tint status;\n\tint saved_status;\n\tchar  *tmp;\n\tchar  *end_mark;\n\tstruct to_body *first_b = to_b;\n\n\tstatus=START_TO;\n\tsaved_status=START_TO;\n\tmemset(to_b, 0, sizeof(struct to_body));\n\tto_b->error=PARSE_OK;\n\tend_mark=0;\n\n\tfor( tmp=buffer; tmp<end; tmp++)\n\t{\n\t\tswitch(*tmp)\n\t\t{\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now =' '*/\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\tstatus = E_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tstatus = MAYBE_URI_END;\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tstatus = DISPLAY_TOKEN2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tstatus = MAYBE_URI_END;\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\tcase E_DISPLAY_QUOTED:\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\tstatus=F_CRLF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tstatus = MAYBE_URI_END;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\tcase E_DISPLAY_QUOTED:\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tsaved_status = status = END;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\t/* the next transition cannot be determined here. The\n\t\t\t\t\t\t * ',' maybe part of the username inside URI, or \n\t\t\t\t\t\t * it can be separator between 2 hdr parts. As this\n\t\t\t\t\t\t * parsed is not URI aware (we do not actually parse\n\t\t\t\t\t\t * the URI, but we simply skip it), we have no idea\n\t\t\t\t\t\t * in which care we are..... For the moment, if the\n\t\t\t\t\t\t * header is marked as single part, at least let's\n\t\t\t\t\t\t * consider the ',' as part of the URI */\n\t\t\t\t\t\tif (multi==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tif (multi==0)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tto_b->next = (struct to_body*)\n\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_body));\n\t\t\t\t\t\tif (to_b->next==NULL) {\n\t\t\t\t\t\t\tLM_ERR(\"failed to allocate new TO body\\n\");\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_b = to_b->next;\n\t\t\t\t\t\tmemset(to_b, 0, sizeof(struct to_body));\n\t\t\t\t\t\tto_b->error = PARSE_OK;\n\t\t\t\t\t\tsaved_status = status = START_TO;\n\t\t\t\t\t\tend_mark=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\ttmp++; /* jump over next char */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase START_TO:\n\t\t\t\t\t\tto_b->body.s=tmp;\n\t\t\t\t\t\tstatus = S_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase E_DISPLAY_QUOTED:\n\t\t\t\t\t\tstatus = S_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->display.len=end_mark-to_b->display.s;\n\t\t\t\t\t\tstatus = S_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase E_URI_ENCLOSED:\n\t\t\t\t\t\tstatus = END;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase START_TO:\n\t\t\t\t\t\tto_b->body.s = tmp;\n\t\t\t\t\t\tto_b->display.s = tmp;\n\t\t\t\t\t\tstatus = DISPLAY_QUOTED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\tstatus = E_DISPLAY_QUOTED;\n\t\t\t\t\t\tto_b->display.len = tmp-to_b->display.s+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ';' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->uri.len = end_mark - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tto_b->body.len = tmp-to_b->body.s;\n\t\t\t\t\t\ttmp = parse_to_param(tmp,end,to_b,&saved_status,multi);\n\t\t\t\t\t\tif (to_b->error!=PARSE_ERROR && multi && *tmp==',') {\n\t\t\t\t\t\t\t/* continue with a new body instance */\n\t\t\t\t\t\t\tto_b->next = (struct to_body*)\n\t\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_body));\n\t\t\t\t\t\t\tif (to_b->next==NULL) {\n\t\t\t\t\t\t\t\tLM_ERR(\"failed to allocate new TO body\\n\");\n\t\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tto_b = to_b->next;\n\t\t\t\t\t\t\tmemset(to_b, 0, sizeof(struct to_body));\n\t\t\t\t\t\t\tto_b->error=PARSE_OK;\n\t\t\t\t\t\t\tsaved_status = status = START_TO;\n\t\t\t\t\t\t\tend_mark=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase START_TO:\n\t\t\t\t\t\tto_b->uri.s = to_b->body.s = tmp;\n\t\t\t\t\t\tstatus = URI_OR_TOKEN;\n\t\t\t\t\t\tto_b->display.s=tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_URI_ENCLOSED:\n\t\t\t\t\t\tto_b->uri.s=tmp;\n\t\t\t\t\t\tstatus=URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\t\tstatus = DISPLAY_TOKEN;\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tLM_DBG(\"spitting out [%c] in status %d\\n\",\n\t\t\t\t\t\t*tmp,status );\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t}/*char switch*/\n\t}/*for*/\n\nendofheader:\n\tif (to_b->display.len==0) to_b->display.s=0;\n\tstatus=saved_status;\n\tLM_DBG(\"end of header reached, state=%d\\n\", status);\n\t/* check if error*/\n\tswitch(status){\n\t\tcase MAYBE_URI_END:\n\t\t\tto_b->uri.len = end_mark - to_b->uri.s;\n\t\tcase END:\n\t\t\tto_b->body.len = tmp - to_b->body.s;\n\t\tcase E_PARA_VALUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"unexpected end of header in state %d\\n\", status);\n\t\t\tgoto error;\n\t}\n\n\tLM_DBG(\"display={%.*s}, ruri={%.*s}\\n\",\n\t\tto_b->display.len, ZSW(to_b->display.s),\n\t\tto_b->uri.len, ZSW(to_b->uri.s));\n\treturn tmp;\n\nparse_error:\n\tLM_ERR(\"unexpected char [%c] in status %d: <<%.*s>> .\\n\",\n\t\t*tmp,status, (int)(tmp-buffer), buffer);\nerror:\n\tfirst_b->error=PARSE_ERROR;\n\tfree_to_params(first_b);\n\tfree_to(first_b->next);\n\treturn tmp;\n\n}\n\n\nchar* parse_to(char* buffer, char *end, struct to_body *to_b)\n{\n\treturn _parse_to( buffer, end, to_b, 0/*multi*/);\n}\n\n\nchar* parse_multi_to(char* buffer, char *end, struct to_body *to_b)\n{\n\treturn _parse_to( buffer, end, to_b, 1/*multi*/);\n}\n\n\n/**\n *\n */\nstruct sip_uri *parse_to_uri(struct sip_msg *msg)\n{\n\tstruct to_body *tb = NULL;\n\tif(msg==NULL || msg->to==NULL || msg->to->parsed==NULL)\n\t\treturn NULL;\n\n\ttb = get_to(msg);\n\n\tif(tb->parsed_uri.user.s!=NULL || tb->parsed_uri.host.s!=NULL)\n\t\treturn &tb->parsed_uri;\n\n\tif (parse_uri(tb->uri.s, tb->uri.len , &tb->parsed_uri)<0)\n\t{\n\t\tLM_ERR(\"failed to parse To uri\\n\");\n\t\tmemset(&tb->parsed_uri, 0, sizeof(struct sip_uri));\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM, \"error parsing To uri\");\n\t\tset_err_reply(400, \"bad To uri\");\n\t\treturn NULL;\n\t}\n\n\treturn &tb->parsed_uri;\n}\n\nint parse_to_header( struct sip_msg *msg)\n{\n\tstruct to_body* to_b;\n\n\tif ( !msg->to && ( parse_headers(msg,HDR_TO_F,0)==-1 || !msg->to)) {\n\t\tLM_ERR(\"bad msg or missing To header\\n\");\n\t\tgoto error;\n\t}\n\n\t/* maybe the header is already parsed! */\n\tif (msg->to->parsed)\n\t\treturn 0;\n\n\t/* bad luck! :-( - we have to parse it */\n\t/* first, get some memory */\n\tto_b = pkg_malloc(sizeof(struct to_body));\n\tif (to_b == 0) {\n\t\tLM_ERR(\"out of pkg_memory\\n\");\n\t\tgoto error;\n\t}\n\n\t/* now parse it!! */\n\tmemset(to_b, 0, sizeof(struct to_body));\n\tparse_to(msg->to->body.s,msg->to->body.s+msg->to->body.len+1,to_b);\n\tif (to_b->error == PARSE_ERROR) {\n\t\tLM_ERR(\"bad to header\\n\");\n\t\tpkg_free(to_b);\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\t\"error parsing too header\");\n\t\tset_err_reply(400, \"bad header\");\n\t\tgoto error;\n\t}\n\n\tmsg->to->parsed = to_b;\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2001-2003 Fhg Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * ---------\n * 2003-04-26 ZSW (jiri)\n * 2006-05-29 removed the NO_PINGTEL_TAG_HACK - it's conflicting the RFC 3261;\n *            TAG parameter must have value; other parameters are accepted\n *            without value (bogdan)\n */\n\n\n#include \"parse_to.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"../dprint.h\"\n#include \"msg_parser.h\"\n#include \"parse_uri.h\"\n#include \"../ut.h\"\n#include \"../mem/mem.h\"\n#include \"../errinfo.h\"\n\n\nenum {\n\tSTART_TO, DISPLAY_QUOTED, E_DISPLAY_QUOTED, DISPLAY_TOKEN, DISPLAY_TOKEN2,\n\tS_URI_ENCLOSED, URI_ENCLOSED, E_URI_ENCLOSED,\n\tURI_OR_TOKEN, MAYBE_URI_END, END, F_CR, F_LF, F_CRLF\n};\n\n\nenum {\n\tS_PARA_NAME=20, PARA_NAME, S_EQUAL, S_PARA_VALUE, TAG1, TAG2,\n\tTAG3, PARA_VALUE_TOKEN , PARA_VALUE_QUOTED, E_PARA_VALUE\n};\n\n\n\n#define add_param( _param , _body ) \\\n\tdo{\\\n\t\tLM_DBG(\"%.*s=%.*s\\n\",param->name.len,ZSW(param->name.s),\\\n\t\t\tparam->value.len,ZSW(param->value.s));\\\n\t\tif (!(_body)->param_lst)  (_body)->param_lst=(_param);\\\n\t\telse (_body)->last_param->next=(_param);\\\n\t\t(_body)->last_param =(_param);\\\n\t\tif ((_param)->type==TAG_PARAM)\\\n\t\t\tmemcpy(&((_body)->tag_value),&((_param)->value),sizeof(str));\\\n\t\t(_param) = 0;\\\n\t}while(0);\n\n\n\nvoid free_to_params(struct to_body* tb)\n{\n\tstruct to_param *tp=tb->param_lst;\n\tstruct to_param *foo;\n\twhile (tp){\n\t\tfoo = tp->next;\n\t\tpkg_free(tp);\n\t\ttp=foo;\n\t}\n\n\ttb->param_lst = tb->last_param = NULL;\n}\n\n\nvoid free_to(struct to_body* tb)\n{\n\tif (tb) {\n\t\tfree_to( tb->next );\n\t\tfree_to_params(tb);\n\t\tpkg_free(tb);\n\t}\n}\n\n\nstatic inline char* parse_to_param(char *buffer, char *end,\n\t\t\t\t\tstruct to_body *to_b,\n\t\t\t\t\tint *returned_status,\n\t\t\t\t\tint multi)\n{\n\tstruct to_param *param;\n\tint status;\n\tint saved_status;\n\tchar  *tmp;\n\n\tparam=0;\n\tstatus=E_PARA_VALUE;\n\tsaved_status=E_PARA_VALUE;\n\tfor( tmp=buffer; tmp<end; tmp++)\n\t{\n\t\tswitch(*tmp)\n\t\t{\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tstatus = S_EQUAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now =' '*/\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tsaved_status = S_EQUAL;\n\t\t\t\t\t\tstatus = F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\t\t\t\tstatus = F_LF;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\tstatus=F_CRLF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tsaved_status = S_EQUAL;\n\t\t\t\t\t\tstatus = F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\t\t\t\tstatus = F_CR;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase  0:\n\t\t\tcase ',':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status = status;\n\t\t\t\t\t\tif ( !multi && *tmp==',')\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tif (tmp+1==end)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tswitch (*(tmp+1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase '\\r':\n\t\t\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp+1;\n\t\t\t\t\t\tstatus = PARA_VALUE_QUOTED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tparam->value.len=tmp-param->value.s ;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ';' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len=tmp-param->value.s;\n\t\t\t\t\t\tadd_param(param,to_b);\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tparam = (struct to_param*)\n\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_param));\n\t\t\t\t\t\tif (!param){\n\t\t\t\t\t\t\tLM_ERR(\"out of pkg memory\\n\" );\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemset(param,0,sizeof(struct to_param));\n\t\t\t\t\t\tparam->type=GENERAL_PARAM;\n\t\t\t\t\t\tstatus = S_PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\tcase 't' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = TAG1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\tcase 'a' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\t\tstatus = TAG2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\tcase 'g' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tstatus = TAG3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '=':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tstatus = S_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\t\tstatus = S_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tLM_ERR(\"spitting out [%c] in status %d\\n\",*tmp,status );\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t}/*switch*/\n\t}/*for*/\n\n\tif (status==PARA_VALUE_QUOTED) {\n\t\t\tLM_ERR(\"unexpected end of header in state %d\\n\", status);\n\t\t\tgoto parse_error;\n\t}\n\nendofheader:\n\tLM_DBG(\"end of header reached, state=%d\\n\", status);\n\tif (param) {\n\t\tif (saved_status==S_EQUAL||saved_status==S_PARA_VALUE) {\n\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\tparam->value.s= 0;\n\t\t\tparam->value.len=0;\n\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\tgoto parse_error;\n\t\t\tadd_param(param, to_b);\n\t\t} else {\n\t\t\tpkg_free(param);\n\t\t}\n\t}\n\t*returned_status=saved_status;\n\treturn tmp;\n\nparse_error:\n\tLM_ERR(\"unexpected char [%c] in status %d: <<%.*s>> .\\n\",\n\t\t*tmp,status, (int)(tmp-buffer), ZSW(buffer));\nerror:\n\tif (param) pkg_free(param);\n\tfree_to_params(to_b);\n\tto_b->error=PARSE_ERROR;\n\t*returned_status = status;\n\treturn tmp;\n}\n\n\n\n\nstatic inline char* _parse_to(char* buffer, char *end, struct to_body *to_b,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint multi)\n{\n\tint status;\n\tint saved_status;\n\tchar  *tmp;\n\tchar  *end_mark;\n\tstruct to_body *first_b = to_b;\n\n\tstatus=START_TO;\n\tsaved_status=START_TO;\n\tmemset(to_b, 0, sizeof(struct to_body));\n\tto_b->error=PARSE_OK;\n\tend_mark=0;\n\n\tfor( tmp=buffer; tmp<end; tmp++)\n\t{\n\t\tswitch(*tmp)\n\t\t{\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now =' '*/\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\tstatus = E_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tstatus = MAYBE_URI_END;\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tstatus = DISPLAY_TOKEN2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tstatus = MAYBE_URI_END;\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\tcase E_DISPLAY_QUOTED:\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\tstatus=F_CRLF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\tstatus = MAYBE_URI_END;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\tcase E_DISPLAY_QUOTED:\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tsaved_status = status = END;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\t/* the next transition cannot be determined here. The\n\t\t\t\t\t\t * ',' maybe part of the username inside URI, or \n\t\t\t\t\t\t * it can be separator between 2 hdr parts. As this\n\t\t\t\t\t\t * parsed is not URI aware (we do not actually parse\n\t\t\t\t\t\t * the URI, but we simply skip it), we have no idea\n\t\t\t\t\t\t * in which care we are..... For the moment, if the\n\t\t\t\t\t\t * header is marked as single part, at least let's\n\t\t\t\t\t\t * consider the ',' as part of the URI */\n\t\t\t\t\t\tif (multi==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tif (multi==0)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tto_b->next = (struct to_body*)\n\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_body));\n\t\t\t\t\t\tif (to_b->next==NULL) {\n\t\t\t\t\t\t\tLM_ERR(\"failed to allocate new TO body\\n\");\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_b = to_b->next;\n\t\t\t\t\t\tmemset(to_b, 0, sizeof(struct to_body));\n\t\t\t\t\t\tto_b->error = PARSE_OK;\n\t\t\t\t\t\tsaved_status = status = START_TO;\n\t\t\t\t\t\tend_mark=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\ttmp++; /* jump over next char */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase START_TO:\n\t\t\t\t\t\tto_b->body.s=tmp;\n\t\t\t\t\t\tstatus = S_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase E_DISPLAY_QUOTED:\n\t\t\t\t\t\tstatus = S_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->display.len=end_mark-to_b->display.s;\n\t\t\t\t\t\tstatus = S_URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tto_b->uri.len = tmp - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase E_URI_ENCLOSED:\n\t\t\t\t\t\tstatus = END;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase START_TO:\n\t\t\t\t\t\tto_b->body.s = tmp;\n\t\t\t\t\t\tto_b->display.s = tmp;\n\t\t\t\t\t\tstatus = DISPLAY_QUOTED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\t\tstatus = E_DISPLAY_QUOTED;\n\t\t\t\t\t\tto_b->display.len = tmp-to_b->display.s+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ';' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tend_mark = tmp;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\t\tto_b->uri.len = end_mark - to_b->uri.s;\n\t\t\t\t\t\t/* fall through */\n\t\t\t\t\tcase END:\n\t\t\t\t\t\tto_b->body.len = tmp-to_b->body.s;\n\t\t\t\t\t\ttmp = parse_to_param(tmp,end,to_b,&saved_status,multi);\n\t\t\t\t\t\tif (to_b->error!=PARSE_ERROR && multi && *tmp==',') {\n\t\t\t\t\t\t\t/* continue with a new body instance */\n\t\t\t\t\t\t\tto_b->next = (struct to_body*)\n\t\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_body));\n\t\t\t\t\t\t\tif (to_b->next==NULL) {\n\t\t\t\t\t\t\t\tLM_ERR(\"failed to allocate new TO body\\n\");\n\t\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tto_b = to_b->next;\n\t\t\t\t\t\t\tmemset(to_b, 0, sizeof(struct to_body));\n\t\t\t\t\t\t\tto_b->error=PARSE_OK;\n\t\t\t\t\t\t\tsaved_status = status = START_TO;\n\t\t\t\t\t\t\tend_mark=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase START_TO:\n\t\t\t\t\t\tto_b->uri.s = to_b->body.s = tmp;\n\t\t\t\t\t\tstatus = URI_OR_TOKEN;\n\t\t\t\t\t\tto_b->display.s=tmp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_URI_ENCLOSED:\n\t\t\t\t\t\tto_b->uri.s=tmp;\n\t\t\t\t\t\tstatus=URI_ENCLOSED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAYBE_URI_END:\n\t\t\t\t\tcase DISPLAY_TOKEN2:\n\t\t\t\t\t\tstatus = DISPLAY_TOKEN;\n\t\t\t\t\tcase DISPLAY_QUOTED:\n\t\t\t\t\tcase DISPLAY_TOKEN:\n\t\t\t\t\tcase URI_ENCLOSED:\n\t\t\t\t\tcase URI_OR_TOKEN:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tLM_DBG(\"spitting out [%c] in status %d\\n\",\n\t\t\t\t\t\t*tmp,status );\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t}/*char switch*/\n\t}/*for*/\n\nendofheader:\n\tif (to_b->display.len==0) to_b->display.s=0;\n\tstatus=saved_status;\n\tLM_DBG(\"end of header reached, state=%d\\n\", status);\n\t/* check if error*/\n\tswitch(status){\n\t\tcase MAYBE_URI_END:\n\t\t\tto_b->uri.len = end_mark - to_b->uri.s;\n\t\tcase END:\n\t\t\tto_b->body.len = tmp - to_b->body.s;\n\t\tcase E_PARA_VALUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"unexpected end of header in state %d\\n\", status);\n\t\t\tgoto error;\n\t}\n\n\tLM_DBG(\"display={%.*s}, ruri={%.*s}\\n\",\n\t\tto_b->display.len, ZSW(to_b->display.s),\n\t\tto_b->uri.len, ZSW(to_b->uri.s));\n\treturn tmp;\n\nparse_error:\n\tLM_ERR(\"unexpected char [%c] in status %d: <<%.*s>> .\\n\",\n\t\t*tmp,status, (int)(tmp-buffer), buffer);\nerror:\n\tfirst_b->error=PARSE_ERROR;\n\tfree_to_params(first_b);\n\tfree_to(first_b->next);\n\treturn tmp;\n\n}\n\n\nchar* parse_to(char* buffer, char *end, struct to_body *to_b)\n{\n\treturn _parse_to( buffer, end, to_b, 0/*multi*/);\n}\n\n\nchar* parse_multi_to(char* buffer, char *end, struct to_body *to_b)\n{\n\treturn _parse_to( buffer, end, to_b, 1/*multi*/);\n}\n\n\n/**\n *\n */\nstruct sip_uri *parse_to_uri(struct sip_msg *msg)\n{\n\tstruct to_body *tb = NULL;\n\tif(msg==NULL || msg->to==NULL || msg->to->parsed==NULL)\n\t\treturn NULL;\n\n\ttb = get_to(msg);\n\n\tif(tb->parsed_uri.user.s!=NULL || tb->parsed_uri.host.s!=NULL)\n\t\treturn &tb->parsed_uri;\n\n\tif (parse_uri(tb->uri.s, tb->uri.len , &tb->parsed_uri)<0)\n\t{\n\t\tLM_ERR(\"failed to parse To uri\\n\");\n\t\tmemset(&tb->parsed_uri, 0, sizeof(struct sip_uri));\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM, \"error parsing To uri\");\n\t\tset_err_reply(400, \"bad To uri\");\n\t\treturn NULL;\n\t}\n\n\treturn &tb->parsed_uri;\n}\n\nint parse_to_header( struct sip_msg *msg)\n{\n\tstruct to_body* to_b;\n\n\tif ( !msg->to && ( parse_headers(msg,HDR_TO_F,0)==-1 || !msg->to)) {\n\t\tLM_ERR(\"bad msg or missing To header\\n\");\n\t\tgoto error;\n\t}\n\n\t/* maybe the header is already parsed! */\n\tif (msg->to->parsed)\n\t\treturn 0;\n\n\t/* bad luck! :-( - we have to parse it */\n\t/* first, get some memory */\n\tto_b = pkg_malloc(sizeof(struct to_body));\n\tif (to_b == 0) {\n\t\tLM_ERR(\"out of pkg_memory\\n\");\n\t\tgoto error;\n\t}\n\n\t/* now parse it!! */\n\tmemset(to_b, 0, sizeof(struct to_body));\n\tparse_to(msg->to->body.s,msg->to->body.s+msg->to->body.len+1,to_b);\n\tif (to_b->error == PARSE_ERROR) {\n\t\tLM_ERR(\"bad to header\\n\");\n\t\tpkg_free(to_b);\n\t\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\t\"error parsing too header\");\n\t\tset_err_reply(400, \"bad header\");\n\t\tgoto error;\n\t}\n\n\tmsg->to->parsed = to_b;\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n"], "filenames": ["parser/parse_to.c"], "buggy_code_start_loc": [234], "buggy_code_end_loc": [457], "fixing_code_start_loc": [235], "fixing_code_end_loc": [465], "type": "NVD-CWE-noinfo", "message": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, when the function `append_hf` handles a SIP message with a malformed To header, a call to the function `abort()` is performed, resulting in a crash. This is due to the following check in `data_lump.c:399` in the function `anchor_lump`. An attacker abusing this vulnerability will crash OpenSIPS leading to Denial of Service. It affects configurations containing functions that make use of the affected code, such as the function `append_hf`. This issue has been fixed in versions 3.1.7 and 3.2.4.", "other": {"cve": {"id": "CVE-2023-27599", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-15T21:15:09.247", "lastModified": "2023-03-21T19:13:17.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, when the function `append_hf` handles a SIP message with a malformed To header, a call to the function `abort()` is performed, resulting in a crash. This is due to the following check in `data_lump.c:399` in the function `anchor_lump`. An attacker abusing this vulnerability will crash OpenSIPS leading to Denial of Service. It affects configurations containing functions that make use of the affected code, such as the function `append_hf`. This issue has been fixed in versions 3.1.7 and 3.2.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.7", "matchCriteriaId": "8EF642AA-D786-40DF-801D-515888AF89BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.4", "matchCriteriaId": "34713A76-CAED-43CF-A77C-73F1C36208AA"}]}]}], "references": [{"url": "https://github.com/OpenSIPS/opensips/commit/cb56694d290530ac308f44b453c18120b1c1109d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-qvj2-vqrg-f5jx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSIPS/opensips/commit/cb56694d290530ac308f44b453c18120b1c1109d"}}