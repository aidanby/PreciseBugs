{"buggy_code": ["/**\n * rgb2hex\n *\n * @author Christian Bromann <mail@christian-bromann.com>\n * @description converts rgba color to HEX\n *\n * @param  {String} color  rgb or rgba color\n * @return {Object}        object with hex and alpha value\n */\n\nvar rgb2hex = module.exports = function rgb2hex(color) {\n    if(typeof color !== 'string') {\n        // throw error of input isn't typeof string\n        throw new Error('color has to be type of `string`');\n    } else if (color.substr(0, 1) === '#') {\n        // or return if already rgb color\n        return {\n            hex: color,\n            alpha: 1\n        };\n    }\n\n    /**\n     * strip spaces\n     */\n    var strippedColor = color.replace(/\\s+/g,'');\n\n    /**\n     * parse input\n     */\n    var digits = /rgba?\\((\\d+),(\\d+),(\\d+)(,(\\d+)?\\.?(\\d+))?\\);?/.exec(strippedColor);\n\n    if(!digits) {\n        // or throw error if input isn't a valid rgb(a) color\n        throw new Error('given color (' + color + ') isn\\'t a valid rgb or rgba color');\n    }\n\n    var red = parseInt(digits[1], 10);\n    var green = parseInt(digits[2], 10);\n    var blue = parseInt(digits[3], 10);\n    var alpha = digits[4] ? /([0-9\\.]+)/.exec(digits[4])[0] : '1';\n    var rgb = ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1);\n\n    // parse alpha value into float\n    if(alpha.substr(0,1) === '.') {\n        alpha = parseFloat('0' + alpha);\n    }\n\n    // limit alpha value to 1\n    if(alpha > 1) {\n        alpha = 1;\n    }\n\n    // cut alpha value after 2 digits after comma\n    alpha = parseFloat(Math.round(alpha * 100)) / 100;\n\n    return {\n        hex: '#' + rgb.toString(16),\n        alpha: alpha\n    };\n};\n", ";(function(window) {\n\n    var rgb2hex = function(color) {\n\n        if(typeof color !== 'string') {\n            // throw error of input isn't typeof string\n            throw new Error('color has to be type of `string`');\n        } else if (color.substr(0, 1) === '#') {\n            // or return if already rgb color\n            return {\n                hex: color,\n                alpha: 1\n            };\n        }\n\n        /**\n         * strip spaces\n         */\n        var strippedColor = color.replace(/\\s+/g,'');\n\n        /**\n         * parse input\n         */\n        var digits = /rgba?\\((\\d+),(\\d+),(\\d+)(,(\\d+)?\\.?(\\d+))?\\);?/.exec(strippedColor);\n\n        if(!digits) {\n            // or throw error if input isn't a valid rgb(a) color\n            throw new Error('given color (' + color + ') isn\\'t a valid rgb or rgba color');\n        }\n\n        var red = parseInt(digits[1], 10);\n        var green = parseInt(digits[2], 10);\n        var blue = parseInt(digits[3], 10);\n        var alpha = digits[4] ? /([0-9\\.]+)/.exec(digits[4])[0] : '1';\n        var rgb = ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1);\n\n        // parse alpha value into float\n        if(alpha.substr(0,1) === '.') {\n            alpha = parseFloat('0' + alpha);\n        }\n\n        // limit alpha value to 1\n        if(alpha > 1) {\n            alpha = 1;\n        }\n\n        // cut alpha value after 2 digits after comma\n        alpha = parseFloat(Math.round(alpha * 100)) / 100;\n\n        return {\n            hex: '#' + rgb.toString(16),\n            alpha: alpha\n        };\n\n    };\n\n    if(typeof define === 'function' && define.amd) {\n        define('rgb2hex', function () {\n            return rgb2hex;\n        });\n    } else {\n        window.rgb2hex = rgb2hex;\n    }\n\n}(window));", "!function(r){var e=function(r){if(\"string\"!=typeof r)throw new Error(\"color has to be type of `string`\");if(\"#\"===r.substr(0,1))return{hex:r,alpha:1};var e=r.replace(/\\s+/g,\"\"),t=/rgba?\\((\\d+),(\\d+),(\\d+)(,(\\d+)?\\.?(\\d+))?\\);?/.exec(e);if(!t)throw new Error(\"given color (\"+r+\") isn't a valid rgb or rgba color\");var n=parseInt(t[1],10),o=parseInt(t[2],10),a=parseInt(t[3],10),i=t[4]?/([0-9\\.]+)/.exec(t[4])[0]:\"1\",s=(a|o<<8|n<<16|1<<24).toString(16).slice(1);return\".\"===i.substr(0,1)&&(i=parseFloat(\"0\"+i)),1<i&&(i=1),i=parseFloat(Math.round(100*i))/100,{hex:\"#\"+s.toString(16),alpha:i}};\"function\"==typeof define&&define.amd?define(\"rgb2hex\",function(){return e}):r.rgb2hex=e}(window);", "const rgb2hex = require('../index')\nconst typeofErrorMessage = 'color has to be type of `string`'\nconst invalidErrorMessage = (input) => 'given color (' + input + ') isn\\'t a valid rgb or rgba color'\n\ndescribe('rgb2hex should', () => {\n    describe('throw an error if input is not typeof string', () => {\n        it('[Object] {color: \\'something\\'}', () => {\n            var input = {color: 'something'}\n            expect(() => rgb2hex(input)).toThrow(typeofErrorMessage)\n        })\n\n        it('[Function] function(){}', () => {\n            var input = function(){}\n            expect(() => rgb2hex(input)).toThrow(typeofErrorMessage)\n        })\n\n        it('[Number] 231', () => {\n            var input = 231\n            expect(() => rgb2hex(input)).toThrow(typeofErrorMessage)\n        })\n    })\n\n    describe('throw an error if input is invalid', () => {\n        it('notacolor', () => {\n            var input = 'notacolor'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n\n        it('rgba(100, 100)', () => {\n            var input = 'rgb(100, 100)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n\n        it('rgba(100, 10a0, 200, 300)', () => {\n            var input = 'rgba(100, 10a0, 200, 300)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n\n        it('rgba(23, 54, 4, -.33)', () => {\n            var input = 'rgba(23, 54, 4, -.33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n    })\n\n    it('return input if it is already a hex color', () => {\n        const input = '#ffffff'\n        const parsedValue = rgb2hex(input)\n\n        expect(parsedValue).toHaveProperty('hex')\n        expect(parsedValue).toHaveProperty('alpha')\n        expect(typeof parsedValue.hex).toEqual('string')\n        expect(parsedValue.hex).toEqual('#ffffff')\n        expect(typeof parsedValue.alpha).toEqual('number')\n        expect(parsedValue.alpha).toEqual(1)\n    })\n\n    describe('parse input properly', () => {\n        it('converting rgb(210,43,255)', () => {\n            const input = 'rgb(210,43,255)'\n            const parsedValue = rgb2hex(input)\n\n            expect(parsedValue).toHaveProperty('hex')\n            expect(parsedValue).toHaveProperty('alpha')\n            expect(typeof parsedValue.hex).toEqual('string')\n            expect(parsedValue.hex).toEqual('#d22bff')\n            expect(typeof parsedValue.alpha).toEqual('number')\n            expect(parsedValue.alpha).toEqual(1)\n        })\n\n        it('converting rgba(12,173,22,.67)', () => {\n            const input = 'rgba(12,173,22,.67)'\n            const parsedValue = rgb2hex(input)\n\n            expect(parsedValue).toHaveProperty('hex')\n            expect(parsedValue).toHaveProperty('alpha')\n            expect(typeof parsedValue.hex).toEqual('string')\n            expect(parsedValue.hex).toEqual('#0cad16')\n            expect(typeof parsedValue.alpha).toEqual('number')\n            expect(parsedValue.alpha).toEqual(0.67)\n        })\n\n        it('by limiting alpha value to 1', () => {\n            var input = 'rgba(12,173,22,12312.67)'\n            expect(rgb2hex(input).alpha).not.toBeGreaterThan(1)\n        })\n\n    })\n\n    describe('not care about', () => {\n        it('rgb or rgba prefix', () => {\n            const rgb = 'rgb(0, 0, 0)'\n            const rgba = 'rgba(0, 0, 0)'\n\n            expect(rgb2hex(rgb).hex).toEqual(rgb2hex(rgba).hex)\n        })\n\n        it('spaces between color numbers', () => {\n            const rgbWithSpaces = 'rgb(0, 0, 0)'\n            const rgbaWithoutSpaces = 'rgba(0,0,0)'\n\n            expect(rgb2hex(rgbWithSpaces).hex).toEqual(rgb2hex(rgbaWithoutSpaces).hex)\n        })\n\n        it('if alpha value starts with `.` or with `0`', () => {\n            const rgbaAlphaStartsWithDot = 'rgba(213,12,4,.45)'\n            const rgbaAlphaStartsWithZero = 'rgba(213,12,4,0.45)'\n\n            expect(rgb2hex(rgbaAlphaStartsWithDot).alpha).toEqual(rgb2hex(rgbaAlphaStartsWithZero).alpha)\n        })\n\n        it('optional terminating semicolon', () => {\n            const rgbWithTerminatingSemicolon = 'rgb(0,0,0);'\n            const rgbWithoutTerminatingSemicolon = 'rgb(0,0,0)'\n\n            expect(rgb2hex(rgbWithTerminatingSemicolon).hex).toEqual(rgb2hex(rgbWithoutTerminatingSemicolon).hex)\n        })\n\n        it('stuff that is appended', () => {\n            expect(rgb2hex('rgb(0,0,0)0px0px8px').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n            expect(rgb2hex('rgb(0,0,0)solid2px').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n        })\n\n        it('stuff that is prepended', () => {\n            expect(rgb2hex('0px0px8pxrgb(0,0,0)').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n            expect(rgb2hex('solid2pxrgb(0,0,0)').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n        })\n\n        it('stuff that is prepended and appended', () => {\n            const url = 'https://foo.bar.com/123.abc.456'\n            const values = `url(\"${url}\")no-repeatscroll0%0%/100%padding-boxborder-box`\n            expect(rgb2hex(`${values}rgb(226,230,233)${values}`).hex)\n            expect(rgb2hex(`${values}rgba(226,230,233,0.4)${values}`).hex)\n        })\n    })\n})\n"], "fixing_code": ["/**\n * rgb2hex\n *\n * @author Christian Bromann <mail@christian-bromann.com>\n * @description converts rgba color to HEX\n *\n * @param  {String} color  rgb or rgba color\n * @return {Object}        object with hex and alpha value\n */\n\nvar rgb2hex = module.exports = function rgb2hex(color) {\n    if(typeof color !== 'string') {\n        // throw error of input isn't typeof string\n        throw new Error('color has to be type of `string`');\n    } else if (color.substr(0, 1) === '#') {\n        // or return if already rgb color\n        return {\n            hex: color,\n            alpha: 1\n        };\n    }\n\n    /**\n     * strip spaces\n     */\n    var strippedColor = color.replace(/\\s+/g,'');\n\n    /**\n     * parse input\n     */\n    var digits = /(.*?)rgb(a)??\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})(,[01]??\\.([0-9]{0,3}))??\\)/.exec(strippedColor);\n\n    if(!digits) {\n        // or throw error if input isn't a valid rgb(a) color\n        throw new Error('given color (' + color + ') isn\\'t a valid rgb or rgba color');\n    }\n\n    var red = parseInt(digits[3], 10);\n    var green = parseInt(digits[4], 10);\n    var blue = parseInt(digits[5], 10);\n    var alpha = digits[6] ? /([0-9\\.]+)/.exec(digits[6])[0] : '1';\n    var rgb = ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1);\n\n    // parse alpha value into float\n    if(alpha.substr(0,2) === ',.') {\n        alpha = parseFloat('0' + alpha);\n    }\n\n    // limit alpha value to 1\n    if(alpha > 1) {\n        alpha = 1;\n    }\n\n    // cut alpha value after 2 digits after comma\n    alpha = parseFloat(Math.round(alpha * 100)) / 100;\n\n    return {\n        hex: '#' + rgb.toString(16),\n        alpha: alpha\n    };\n};", ";(function(window) {\n\n    var rgb2hex = function(color) {\n\n        if(typeof color !== 'string') {\n            // throw error of input isn't typeof string\n            throw new Error('color has to be type of `string`');\n        } else if (color.substr(0, 1) === '#') {\n            // or return if already rgb color\n            return {\n                hex: color,\n                alpha: 1\n            };\n        }\n\n        /**\n         * strip spaces\n         */\n        var strippedColor = color.replace(/\\s+/g,'');\n\n        /**\n         * parse input\n         */\n        var digits = /(.*?)rgb(a)??\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})(,[01]??\\.([0-9]{0,3}))??\\)/.exec(strippedColor);\n\n        if(!digits) {\n            // or throw error if input isn't a valid rgb(a) color\n            throw new Error('given color (' + color + ') isn\\'t a valid rgb or rgba color');\n        }\n\n        var red = parseInt(digits[3], 10);\n        var green = parseInt(digits[4], 10);\n        var blue = parseInt(digits[5], 10);\n        var alpha = digits[6] ? /([0-9\\.]+)/.exec(digits[6])[0] : '1';\n        var rgb = ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1);\n\n        // parse alpha value into float\n        if(alpha.substr(0,2) === ',.') {\n            alpha = parseFloat('0' + alpha);\n        }\n\n        // limit alpha value to 1\n        if(alpha > 1) {\n            alpha = 1;\n        }\n\n        // cut alpha value after 2 digits after comma\n        alpha = parseFloat(Math.round(alpha * 100)) / 100;\n\n        return {\n            hex: '#' + rgb.toString(16),\n            alpha: alpha\n        };\n\n    };\n\n    if(typeof define === 'function' && define.amd) {\n        define('rgb2hex', function () {\n            return rgb2hex;\n        });\n    } else {\n        window.rgb2hex = rgb2hex;\n    }\n\n}(window));", "!function(r){var e=function(r){if(\"string\"!=typeof r)throw new Error(\"color has to be type of `string`\");if(\"#\"===r.substr(0,1))return{hex:r,alpha:1};var e=r.replace(/\\s+/g,\"\"),t=/(.*?)rgb(a)??\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})(,[01]??\\.([0-9]{0,3}))??\\)/.exec(e);if(!t)throw new Error(\"given color (\"+r+\") isn't a valid rgb or rgba color\");var n=parseInt(t[3],10),o=parseInt(t[4],10),a=parseInt(t[5],10),i=t[6]?/([0-9\\.]+)/.exec(t[6])[0]:\"1\",s=(a|o<<8|n<<16|1<<24).toString(16).slice(1);return\",.\"===i.substr(0,2)&&(i=parseFloat(\"0\"+i)),1<i&&(i=1),i=parseFloat(Math.round(100*i))/100,{hex:\"#\"+s.toString(16),alpha:i}};\"function\"==typeof define&&define.amd?define(\"rgb2hex\",function(){return e}):r.rgb2hex=e}(window);", "const rgb2hex = require('../index')\nconst typeofErrorMessage = 'color has to be type of `string`'\nconst invalidErrorMessage = (input) => 'given color (' + input + ') isn\\'t a valid rgb or rgba color'\n\ndescribe('rgb2hex should', () => {\n    describe('throw an error if input is not typeof string', () => {\n        it('[Object] {color: \\'something\\'}', () => {\n            var input = {color: 'something'}\n            expect(() => rgb2hex(input)).toThrow(typeofErrorMessage)\n        })\n\n        it('[Function] function(){}', () => {\n            var input = function(){}\n            expect(() => rgb2hex(input)).toThrow(typeofErrorMessage)\n        })\n\n        it('[Number] 231', () => {\n            var input = 231\n            expect(() => rgb2hex(input)).toThrow(typeofErrorMessage)\n        })\n    })\n\n    describe('throw an error if input is invalid', () => {\n        it('notacolor', () => {\n            var input = 'notacolor'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n\n        it('rgba(100, 100)', () => {\n            var input = 'rgb(100, 100)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n\n        it('rgba(100, 10a0, 200, 300)', () => {\n            var input = 'rgba(100, 10a0, 200, 300)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n\n        it('rgba(23, 54, 4, -.33)', () => {\n            var input = 'rgba(23, 54, 4, -.33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n    })\n\n    it('return input if it is already a hex color', () => {\n        const input = '#ffffff'\n        const parsedValue = rgb2hex(input)\n\n        expect(parsedValue).toHaveProperty('hex')\n        expect(parsedValue).toHaveProperty('alpha')\n        expect(typeof parsedValue.hex).toEqual('string')\n        expect(parsedValue.hex).toEqual('#ffffff')\n        expect(typeof parsedValue.alpha).toEqual('number')\n        expect(parsedValue.alpha).toEqual(1)\n    })\n\n    describe('parse input properly', () => {\n        it('converting rgb(210,43,255)', () => {\n            const input = 'rgb(210,43,255)'\n            const parsedValue = rgb2hex(input)\n\n            expect(parsedValue).toHaveProperty('hex')\n            expect(parsedValue).toHaveProperty('alpha')\n            expect(typeof parsedValue.hex).toEqual('string')\n            expect(parsedValue.hex).toEqual('#d22bff')\n            expect(typeof parsedValue.alpha).toEqual('number')\n            expect(parsedValue.alpha).toEqual(1)\n        })\n\n        it('converting rgba(12,173,22,.67)', () => {\n            const input = 'rgba(12,173,22,.67)'\n            const parsedValue = rgb2hex(input)\n\n            expect(parsedValue).toHaveProperty('hex')\n            expect(parsedValue).toHaveProperty('alpha')\n            expect(typeof parsedValue.hex).toEqual('string')\n            expect(parsedValue.hex).toEqual('#0cad16')\n            expect(typeof parsedValue.alpha).toEqual('number')\n            expect(parsedValue.alpha).toEqual(0.67)\n        })\n\n        it('by limiting alpha value to 1', () => {\n            var input = 'rgba(12,173,22,1.67)'\n            expect(rgb2hex(input).alpha).not.toBeGreaterThan(1)\n        })\n\n        it('by not accepting to big values', () => {\n            var input = 'rgba(1123, 54, 4, 0.33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n            input = 'rgba(113, 1154, 4, 0.33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n            input = 'rgba(113, 154, 1114, 0.33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n            input = 'rgba(113, 54, 4, 2.33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n            input = 'rgbaaaaaa(113, 54, 4, .33)'\n            expect(() => rgb2hex(input)).toThrow(invalidErrorMessage(input))\n        })\n    })\n\n    describe('not care about', () => {\n        it('rgb or rgba prefix', () => {\n            const rgb = 'rgb(0, 0, 0)'\n            const rgba = 'rgba(0, 0, 0)'\n\n            expect(rgb2hex(rgb).hex).toEqual(rgb2hex(rgba).hex)\n        })\n\n        it('spaces between color numbers', () => {\n            const rgbWithSpaces = 'rgb(0, 0, 0)'\n            const rgbaWithoutSpaces = 'rgba(0,0,0)'\n\n            expect(rgb2hex(rgbWithSpaces).hex).toEqual(rgb2hex(rgbaWithoutSpaces).hex)\n        })\n\n        it('if alpha value starts with `.` or with `0`', () => {\n            const rgbaAlphaStartsWithDot = 'rgba(213,12,4,.45)'\n            const rgbaAlphaStartsWithZero = 'rgba(213,12,4,0.45)'\n\n            expect(rgb2hex(rgbaAlphaStartsWithDot).alpha).toEqual(rgb2hex(rgbaAlphaStartsWithZero).alpha)\n        })\n\n        it('optional terminating semicolon', () => {\n            const rgbWithTerminatingSemicolon = 'rgb(0,0,0);'\n            const rgbWithoutTerminatingSemicolon = 'rgb(0,0,0)'\n\n            expect(rgb2hex(rgbWithTerminatingSemicolon).hex).toEqual(rgb2hex(rgbWithoutTerminatingSemicolon).hex)\n        })\n\n        it('stuff that is appended', () => {\n            expect(rgb2hex('rgb(0,0,0)0px0px8px').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n            expect(rgb2hex('rgb(0,0,0)solid2px').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n        })\n\n        it('stuff that is prepended', () => {\n            expect(rgb2hex('0px0px8pxrgb(0,0,0)').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n            expect(rgb2hex('solid2pxrgb(0,0,0)').hex).toEqual(rgb2hex('rgb(0,0,0)').hex)\n        })\n\n        it('stuff that is prepended and appended', () => {\n            const url = 'https://foo.bar.com/123.abc.456'\n            const values = `url(\"${url}\")no-repeatscroll0%0%/100%padding-boxborder-box`\n            expect(rgb2hex(`${values}rgb(226,230,233)${values}`).hex)\n            expect(rgb2hex(`${values}rgba(226,230,233,0.4)${values}`).hex)\n        })\n    })\n})"], "filenames": ["index.js", "rgb2hex.js", "rgb2hex.min.js", "test/rgb2hex.test.js"], "buggy_code_start_loc": [31, 24, 1, 83], "buggy_code_end_loc": [62, 39, 2, 136], "fixing_code_start_loc": [31, 24, 1, 83], "fixing_code_end_loc": [62, 39, 2, 148], "type": "CWE-1333", "message": "A vulnerability was found in rgb2hex up to 0.1.5. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to inefficient regular expression complexity. The attack may be initiated remotely. Upgrading to version 0.1.6 is able to address this issue. The name of the patch is 9e0c38594432edfa64136fdf7bb651835e17c34f. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217151.", "other": {"cve": {"id": "CVE-2018-25061", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-31T20:15:08.817", "lastModified": "2023-01-09T15:14:24.423", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in rgb2hex up to 0.1.5. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to inefficient regular expression complexity. The attack may be initiated remotely. Upgrading to version 0.1.6 is able to address this issue. The name of the patch is 9e0c38594432edfa64136fdf7bb651835e17c34f. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217151."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rgb2hex_project:rgb2hex:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.6", "matchCriteriaId": "C2378D4E-B233-4571-9142-EFC56606341E"}]}]}], "references": [{"url": "https://github.com/christian-bromann/rgb2hex/commit/9e0c38594432edfa64136fdf7bb651835e17c34f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/christian-bromann/rgb2hex/releases/tag/v0.1.6", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217151", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217151", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/christian-bromann/rgb2hex/commit/9e0c38594432edfa64136fdf7bb651835e17c34f"}}