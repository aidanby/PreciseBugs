{"buggy_code": ["Change Log for PCRE2 - see also the Git log\n-------------------------------------------\n\n\nVersion 10.41 xx-xxx-2022\n-------------------------\n\n1. Add fflush() before and after a fork callout in pcre2grep to get its output\nto be the same on all systems. (THere were previously ordering differences in\nAlpine Linux).\n\n2. Merged patch from @carenas (GitHub #110) for pthreads support in CMake.\n\n3. SSF scorecards grumbled about possible overflow in an expression in\npcre2test. It never would have overflowed in practice, but some casts have been\nadded and at the some time there's been some tidying of fprints that output\nsize_t values.\n\n4. PR #94 showed up an unused enum in pcre2_convert.c, which is now removed.\n\n5. Minor code re-arrangement to remove gcc warning about realloc() in\npcre2test.\n\n6. Change a number of int variables that hold buffer and line lengths in\npcre2grep to PCRE2_SIZE (aka size_t).\n\n7. Added an #ifdef to cut out a call to PRIV(jit_free) when JIT is not\nsupported (even though that function would do nothing in that case) at the\nrequest of a user who doesn't even want to link with pcre_jit_compile.o. Also\ntidied up an untidy #ifdef arrangement in pcre2test.\n\n8. Fixed an issue in the backtracking optimization of character repeats in\nJIT. Furthermore optimize star repetitions, not just plus repetitions.\n\n9. Removed the use of an initial backtracking frames vector on the system stack \nin pcre2_match() so that it now always uses the heap. (In a multi-thread \nenvironment with very small stacks there had been an issue.) This also is \ntidier for JIT matching, which didn't need that vector. The heap vector is now \nremembered in the match data block and re-used if that block itself is re-used. \nIt is freed with the match data block.\n\n10. Adjusted the find_limits code in pcre2test to work with change 9 above.\n\n11. Added find_limits_noheap to pcre2test, because the heap limits are now \ndifferent in different environments and so cannot be included in the standard \ntests.\n\n12. Created a test for pcre2_match() heap processing that is not part of the \ntests run by 'make check', but can be run manually. The current output is from \na 64-bit system.\n\n13. Implemented -Z aka --null in pcre2grep.\n\n14. A minor change to pcre2test and the addition of several new pcre2grep tests\nhave improved LCOV coverage statistics. At the same time, code in pcre2grep and \nelsewhere that can never be obeyed in normal testing has been excluded from\ncoverage.\n\n15. Fixed a bug in pcre2grep that could cause an extra newline to be written\nafter output generaed by --output.\n\n16. If a file has a .bz2 extension but is not in fact compressed, pcre2grep \nshould process it as a plain text file. A bug stopped this happening; now fixed \nand added to the tests.\n\n17. When pcre2grep was running not in UTF mode, if a string specified by\n--output or obtained from a callout in a pattern contained a character (byte)\ngreater than 127, it was incorrectly output in UTF-8 format.\n\n18. Added some casts after warnings from Clang sanitize.\n\n19. Merged patch from cbouc (GitHub #139): 4 function prototypes were missing\nPCRE2_CALL_CONVENTION in src/pcre2posix.h. All function prototypes returning\npointers had out of place PCRE2_CALL_CONVENTION in src/pcre2.h.*. These\nproduced errors when building for Windows with #define PCRE2_CALL_CONVENTION\n__stdcall.\n\n\nVersion 10.40 15-April-2022\n---------------------------\n\n1. Merged patch from @carenas (GitHub #35, 7db87842) to fix pcre2grep incorrect\nhandling of multiple passes.\n\n2. Merged patch from @carenas (GitHub #36, dae47509) to fix portability issue\nin pcre2grep with buffered fseek(stdin).\n\n3. Merged patch from @carenas (GitHub #37, acc520924) to fix tests when -S is\nnot supported.\n\n4. Revert an unintended change in JIT repeat detection.\n\n5. Merged patch from @carenas (GitHub #52, b037bfa1) to fix build on GNU Hurd.\n\n6. Merged documentation and comments patches from @carenas (GitHub #47).\n\n7. Merged patch from @carenas (GitHub #49) to remove obsolete JFriedl test code\nfrom pcre2grep.\n\n8. Merged patch from @carenas (GitHub #48) to fix CMake install issue #46.\n\n9. Merged patch from @carenas (GitHub #53) fixing NULL checks in matching and\nsubstituting.\n\n10. Add null_subject and null_replacement modifiers to pcre2test.\n\n11. Add check for NULL subject to POSIX regexec() function.\n\n12. Add check for NULL replacement to pcre2_substitute().\n\n13. For the subject arguments of pcre2_match(), pcre2_dfa_match(), and\npcre2_substitute(), and the replacement argument of the latter, if the pointer\nis NULL and the length is zero, treat as an empty string. Apparently a number\nof applications treat NULL/0 in this way.\n\n14. Added support for Bidi_Class and a number of binary Unicode properties,\nincluding Bidi_Control.\n\n15. Fix some minor issues raised by clang sanitize.\n\n16. Very minor code speed up for maximizing character property matches.\n\n17. A number of changes to script matching for \\p and \\P:\n\n    (a) Script extensions for a character are now coded as a bitmap instead of\n        a list of script numbers, which should be faster and does not need a\n        loop.\n\n    (b) Added the syntax \\p{script:xxx} and \\p{script_extensions:xxx} (synonyms\n        sc and scx).\n\n    (c) Changed \\p{scriptname} from being the same as \\p{sc:scriptname} to being\n        the same as \\p{scx:scriptname} because this change happened in Perl at\n        release 5.26.\n\n    (d) The standard Unicode 4-letter abbreviations for script names are now\n        recognized.\n\n    (e) In accordance with Unicode and Perl's \"loose matching\" rules, spaces,\n        hyphens, and underscores are ignored in property names, which are then\n        matched independent of case.\n\n18. The Python scripts in the maint directory have been refactored. There are\nnow three scripts that generate pcre2_ucd.c, pcre2_ucp.h, and pcre2_ucptables.c\n(which is #included by pcre2_tables.c). The data lists that used to be\nduplicated are now held in a single common Python module.\n\n19. On CHERI, and thus Arm's Morello prototype, pointers are represented as\nhardware capabilities, which consist of both an integer address and additional\nmetadata, meaning they are twice the size of the platform's size_t type, i.e.\n16 bytes on a 64-bit system. The ovector member of heapframe happens to only be\n8 byte aligned, and so computing frame_size ended up with a multiple of 8 but\nnot 16. Whilst the first frame was always suitably aligned, this then\nmisaligned the frame that follows, resulting in an alignment fault when storing\na pointer to Fecode at the start of match. Patch to fix this issue by Jessica\nClarke PR#72.\n\n20. Added -LP and -LS listing options to pcre2test.\n\n21. A user discovered that the library names in CMakeLists.txt for MSVC\ndebugger (PDB) files were incorrect - perhaps never tried for PCRE2?\n\n22. An item such as [Aa] is optimized into a caseless single character match.\nWhen this was quantified (e.g. [Aa]{2}) and was also the last literal item in a\npattern, the optimizing \"must be present for a match\" character check was not\nbeing flagged as caseless, causing some matches that should have succeeded to\nfail.\n\n23. Fixed a unicode property matching issue in JIT. The character was not\nfully read in caseless matching.\n\n24. Fixed an issue affecting recursions in JIT caused by duplicated data\ntransfers.\n\n25. Merged patch from @carenas (GitHub #96) which fixes some problems with\npcre2test and readline/readedit:\n\n  * Use the right header for libedit in FreeBSD with autoconf\n  * Really allow libedit with cmake\n  * Avoid using readline headers with libedit\n\n\nVersion 10.39 29-October-2021\n-----------------------------\n\n1. Fix incorrect detection of alternatives in first character search in JIT.\n\n2. Merged patch from @carenas (GitHub #28):\n\n  Visual Studio 2013 includes support for %zu and %td, so let newer\n  versions of it avoid the fallback, and while at it, make sure that\n  the first check is for DISABLE_PERCENT_ZT so it will be always\n  honoured if chosen.\n\n  prtdiff_t is signed, so use a signed type instead, and make sure\n  that an appropriate width is chosen if pointers are 64bit wide and\n  long is not (ex: Windows 64bit).\n\n  IMHO removing the cast (and therefore the possibilty of truncation)\n  make the code cleaner and the fallback is likely portable enough\n  with all 64-bit POSIX systems doing LP64 except for Windows.\n\n3. Merged patch from @carenas (GitHub #29) to update to Unicode 14.0.0.\n\n4. Merged patch from @carenas (GitHub #30):\n\n  * Cleanup: remove references to no longer used stdint.h\n\n  Since 19c50b9d (Unconditionally use inttypes.h instead of trying for stdint.h\n  (simplification) and remove the now unnecessary inclusion in\n  pcre2_internal.h., 2018-11-14), stdint.h is no longer used.\n\n  Remove checks for it in autotools and CMake and document better the expected\n  build failures for systems that might have stdint.h (C99) and not inttypes.h\n  (from POSIX), like old Windows.\n\n  * Cleanup: remove detection for inttypes.h which is a hard dependency\n\n  CMake checks for standard headers are not meant to be used for hard\n  dependencies, so will prevent a possible fallback to work.\n\n  Alternatively, the header could be checked to make the configuration fail\n  instead of breaking the build, but that was punted, as it was missing anyway\n  from autotools.\n\n5. Merged patch from @carenas (GitHub #32):\n\n  * jit: allow building with ancient MSVC versions\n\n  Visual Studio older than 2013 fails to build with JIT enabled, because it is\n  unable to parse non C89 compatible syntax, with mixed declarations and code.\n  While most recent compilers wouldn't even report this as a warning since it\n  is valid C99, it could be also made visible by adding to gcc/clang the\n  -Wdeclaration-after-statement flag at build time.\n\n  Move the code below the affected definitions.\n\n  * pcre2grep: avoid mixing declarations with code\n\n  Since d5a61ee8 (Patch to detect (and ignore) symlink loops in pcre2grep,\n  2021-08-28), code will fail to build in a strict C89 compiler.\n\n  Reformat slightly to make it C89 compatible again.\n\n\nVersion 10.38 01-October-2021\n-----------------------------\n\n1. Fix invalid single character repetition issues in JIT when the repetition\nis inside a capturing bracket and the bracket is preceded by character\nliterals.\n\n2. Installed revised CMake configuration files provided by Jan-Willem Blokland.\nThis extends the CMake build system to build both static and shared libraries\nin one go, builds the static library with PIC, and exposes PCRE2 libraries\nusing the CMake config files. JWB provided these notes:\n\n- Introduced CMake variable BUILD_STATIC_LIBS to build the static library.\n\n- Make a small modification to config-cmake.h.in by removing the PCRE2_STATIC\n  variable. Added PCRE2_STATIC variable to the static build using the\n  target_compile_definitions() function.\n\n- Extended the CMake config files.\n\n  - Introduced CMake variable PCRE2_USE_STATIC_LIBS to easily switch between\n    the static and shared libraries.\n\n  - Added the PCRE_STATIC variable to the target compile definitions for the\n    import of the static library.\n\nBuilding static and shared libraries using MSVC results in a name clash of\nthe libraries. Both static and shared library builds create, for example, the\nfile pcre2-8.lib. Therefore, I decided to change the static library names by\nadding \"-static\". For example, pcre2-8.lib has become pcre2-8-static.lib.\n[Comment by PH: this is MSVC-specific. It doesn't happen on Linux.]\n\n3. Increased the minimum release number for CMake to 3.0.0 because older than\n2.8.12 is deprecated (it was set to 2.8.5) and causes warnings. Even 3.0.0 is\nquite old; it was released in 2014.\n\n4. Implemented a modified version of Thomas Tempelmann's pcre2grep patch for\ndetecting symlink loops. This is dependent on the availability of realpath(),\nwhich is now tested for in ./configure and CMakeLists.txt.\n\n5. Implemented a modified version of Thomas Tempelmann's patch for faster\ncase-independent \"first code unit\" searches for unanchored patterns in 8-bit\nmode in the interpreters. Instead of just remembering whether one case matched\nor not, it remembers the position of a previous match so as to avoid\nunnecessary repeated searching.\n\n6. Perl now locks out \\K in lookarounds, so PCRE2 now does the same by default.\nHowever, just in case anybody was relying on the old behaviour, there is an\noption called PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK that enables the old behaviour.\nAn option has also been added to pcre2grep to enable this.\n\n7. Re-enable a JIT optimization which was unintentionally disabled in 10.35.\n\n8. There is a loop counter to catch excessively crazy patterns when checking\nthe lengths of lookbehinds at compile time. This was incorrectly getting reset\nwhenever a lookahead was processed, leading to some fuzzer-generated patterns\ntaking a very long time to compile when (?|) was present in the pattern,\nbecause (?|) disables caching of group lengths.\n\n\nVersion 10.37 26-May-2021\n-------------------------\n\n1. Change RunGrepTest to use tr instead of sed when testing with binary\nzero bytes, because sed varies a lot from system to system and has problems\nwith binary zeros. This is from Bugzilla #2681. Patch from Jeremie\nCourreges-Anglas via Nam Nguyen. This fixes RunGrepTest for OpenBSD. Later:\nit broke it for at least one version of Solaris, where tr can't handle binary\nzeros. However, that system had /usr/xpg4/bin/tr installed, which works OK, so\nRunGrepTest now checks for that command and uses it if found.\n\n2. Compiling with gcc 10.2's -fanalyzer option showed up a hypothetical problem\nwith a NULL dereference. I don't think this case could ever occur in practice,\nbut I have put in a check in order to get rid of the compiler error.\n\n3. An alternative patch for CMakeLists.txt because 10.36 #4 breaks CMake on\nWindows. Patch from email@cs-ware.de fixes bugzilla #2688.\n\n4. Two bugs related to over-large numbers have been fixed so the behaviour is\nnow the same as Perl.\n\n  (a) A pattern such as /\\214748364/ gave an overflow error instead of being\n  treated as the octal number \\214 followed by literal digits.\n\n  (b) A sequence such as {65536 that has no terminating } so is not a\n  quantifier was nevertheless complaining that a quantifier number was too big.\n\n5. A run of autoconf suggested that configure.ac was out-of-date with respect\nto the lastest autoconf. Running autoupdate made some valid changes, some valid\nsuggestions, and also some invalid changes, which were fixed by hand. Autoconf\nnow runs clean and the resulting \"configure\" seems to work, so I hope nothing\nis broken. Later: the requirement for autoconf 2.70 broke some automatic test\nrobots. It doesn't seem to be necessary: trying a reduction to 2.60.\n\n6. The pattern /a\\K.(?0)*/ when matched against \"abac\" by the interpreter gave\nthe answer \"bac\", whereas Perl and JIT both yield \"c\". This was because the\neffect of \\K was not propagating back from the full pattern recursion. Other\nrecursions such as /(a\\K.(?1)*)/ did not have this problem.\n\n7. Restore single character repetition optimization in JIT. Currently fewer\ncharacter repetitions are optimized than in 10.34.\n\n8. When the names of the functions in the POSIX wrapper were changed to\npcre2_regcomp() etc. (see change 10.33 #4 below), functions with the original\nnames were left in the library so that pre-compiled programs would still work.\nHowever, this has proved troublesome when programs link with several libraries,\nsome of which use PCRE2 via the POSIX interface while others use a native POSIX\nlibrary. For this reason, the POSIX function names are removed in this release.\nThe macros in pcre2posix.h should ensure that re-compiling fixes any programs\nthat haven't been compiled since before 10.33.\n\n\nVersion 10.36 04-December-2020\n------------------------------\n\n1. Add CET_CFLAGS so that when Intel CET is enabled, pass -mshstk to\ncompiler. This fixes https://bugs.exim.org/show_bug.cgi?id=2578. Patch for\nMakefile.am and configure.ac by H.J. Lu. Equivalent patch for CMakeLists.txt\ninvented by PH.\n\n2. Fix inifinite loop when a single byte newline is searched in JIT when\ninvalid utf8 mode is enabled.\n\n3. Updated CMakeLists.txt with patch from Wolfgang St\u00f6ggl (Bugzilla #2584):\n\n  - Include GNUInstallDirs and use ${CMAKE_INSTALL_LIBDIR} instead of hardcoded\n    lib. This allows differentiation between lib and lib64.\n    CMAKE_INSTALL_LIBDIR is used for installation of libraries and also for\n    pkgconfig file generation.\n\n  - Add the version of PCRE2 to the configuration summary like ./configure\n    does.\n\n  - Fix typo: MACTHED_STRING->MATCHED_STRING\n\n4. Updated CMakeLists.txt with another patch from Wolfgang St\u00f6ggl (Bugzilla\n#2588):\n\n  - Add escaped double quotes around include directory in CMakeLists.txt to\n    allow spaces in directory names.\n\n  - This fixes a cmake error, if the path of the pcre2 source contains a space.\n\n5. Updated CMakeLists.txt with a patch from B. Scott Michel: CMake's\ndocumentation suggests using CHECK_SYMBOL_EXISTS over CHECK_FUNCTION_EXIST.\nMoreover, these functions come from specific header files, which need to be\nspecified (and, thankfully, are the same on both the Linux and WinXX\nplatforms.)\n\n6. Added a (uint32_t) cast to prevent a compiler warning in pcre2_compile.c.\n\n7. Applied a patch from Wolfgang St\u00f6ggl (Bugzilla #2600) to fix postfix for\ndebug Windows builds using CMake. This also updated configure so that it\ngenerates *.pc files and pcre2-config with the same content, as in the past.\n\n8. If a pattern ended with (?(VERSION=n.d where n is any number but d is just a\nsingle digit, the code unit beyond d was being read (i.e. there was a read\nbuffer overflow). Fixes ClusterFuzz 23779.\n\n9. After the rework in r1235, certain character ranges were incorrectly\nhandled by an optimization in JIT. Furthermore a wrong offset was used to\nread a value from a buffer which could lead to memory overread.\n\n10. Unnoticed for many years was the fact that delimiters other than / in the\ntestinput1 and testinput4 files could cause incorrect behaviour when these\nfiles were processed by perltest.sh. There were several tests that used quotes\nas delimiters, and it was just luck that they didn't go wrong with perltest.sh.\nAll the patterns in testinput1 and testinput4 now use / as their delimiter.\nThis fixes Bugzilla #2641.\n\n11. Perl has started to give an error for \\K within lookarounds (though there\nare cases where it doesn't). PCRE2 still allows this, so the tests that include\nthis case have been moved from test 1 to test 2.\n\n12. Further to 10 above, pcre2test has been updated to detect and grumble if a\ndelimiter other than / is used after #perltest.\n\n13. Fixed a bug with PCRE2_MATCH_INVALID_UTF in 8-bit mode when PCRE2_CASELESS\nwas set and PCRE2_NO_START_OPTIMIZE was not set. The optimization for finding\nthe start of a match was not resetting correctly after a failed match on the\nfirst valid fragment of the subject, possibly causing incorrect \"no match\"\nreturns on subsequent fragments. For example, the pattern /A/ failed to match\nthe subject \\xe5A. Fixes Bugzilla #2642.\n\n14. Fixed a bug in character set matching when JIT is enabled and both unicode\nscripts and unicode classes are present at the same time.\n\n15. Added GNU grep's -m (aka --max-count) option to pcre2grep.\n\n16. Refactored substitution processing in pcre2grep strings, both for the -O\noption and when dealing with callouts. There is now a single function that\nhandles $ expansion in all cases (instead of multiple copies of almost\nidentical code). This means that the same escape sequences are available\neverywhere, which was not previously the case. At the same time, the escape\nsequences $x{...} and $o{...} have been introduced, to allow for characters\nwhose code points are greater than 255 in Unicode mode.\n\n17. Applied the patch from Bugzilla #2628 to RunGrepTest. This does an explicit\ntest for a version of sed that can handle binary zero, instead of assuming that\nany Linux version will work. Later: replaced $(...) by `...` because not all\nshells recognize the former.\n\n18. Fixed a word boundary check bug in JIT when partial matching is enabled.\n\n19. Fix ARM64 compilation warning in JIT. Patch by Carlo.\n\n20. A bug in the RunTest script meant that if the first part of test 2 failed,\nthe failure was not reported.\n\n21. Test 2 was failing when run from a directory other than the source\ndirectory. This failure was previously missed in RunTest because of 20 above.\nFixes added to both RunTest and RunTest.bat.\n\n22. Patch to CMakeLists.txt from Daniel to fix problem with testing under\nWindows.\n\n\nVersion 10.35 09-May-2020\n---------------------------\n\n1. Use PCRE2_MATCH_EMPTY flag to detect empty matches in JIT.\n\n2. Fix ARMv5 JIT improper handling of labels right after a constant pool.\n\n3. A JIT bug is fixed which allowed to read the fields of the compiled\npattern before its existence is checked.\n\n4. Back in the PCRE1 day, capturing groups that contained recursive back\nreferences to themselves were made atomic (version 8.01, change 18) because\nafter the end a repeated group, the captured substrings had their values from\nthe final repetition, not from an earlier repetition that might be the\ndestination of a backtrack. This feature was documented, and was carried over\ninto PCRE2. However, it has now been realized that the major refactoring that\nwas done for 10.30 has made this atomicizing unnecessary, and it is confusing\nwhen users are unaware of it, making some patterns appear not to be working as\nexpected. Capture values of recursive back references in repeated groups are\nnow correctly backtracked, so this unnecessary restriction has been removed.\n\n5. Added PCRE2_SUBSTITUTE_LITERAL.\n\n6. Avoid some VS compiler warnings.\n\n7. Added PCRE2_SUBSTITUTE_MATCHED.\n\n8. Added (?* and (?<* as synonyms for (*napla: and (*naplb: to match another\nregex engine. The Perl regex folks are aware of this usage and have made a note\nabout it.\n\n9. When an assertion is repeated, PCRE2 used to limit the maximum repetition to\n1, believing that repeating an assertion is pointless. However, if a positive\nassertion contains capturing groups, repetition can be useful. In any case, an\nassertion could always be wrapped in a repeated group. The only restriction\nthat is now imposed is that an unlimited maximum is changed to one more than\nthe minimum.\n\n10. Fix *THEN verbs in lookahead assertions in JIT.\n\n11. Added PCRE2_SUBSTITUTE_REPLACEMENT_ONLY.\n\n12. The JIT stack should be freed when the low-level stack allocation fails.\n\n13. In pcre2grep, if the final line in a scanned file is output but does not\nend with a newline sequence, add a newline according to the --newline setting.\n\n14. (?(DEFINE)...) groups were not being handled correctly when checking for\nthe fixed length of a lookbehind assertion. Such a group within a lookbehind\nshould be skipped, as it does not contribute to the length of the group.\nInstead, the (DEFINE) group was being processed, and if at the end of the\nlookbehind, that end was not correctly recognized. Errors such as \"lookbehind\nassertion is not fixed length\" and also \"internal error: bad code value in\nparsed_skip()\" could result.\n\n15. Put a limit of 1000 on recursive calls in pcre2_study() when searching\nnested groups for starting code units, in order to avoid stack overflow issues.\nIf the limit is reached, it just gives up trying for this optimization.\n\n16. The control verb chain list must always be restored when exiting from a\nrecurse function in JIT.\n\n17. Fix a crash which occurs when the character type of an invalid UTF\ncharacter is decoded in JIT.\n\n18. Changes in many areas of the code so that when Unicode is supported and\nPCRE2_UCP is set without PCRE2_UTF, Unicode character properties are used for\nupper/lower case computations on characters whose code points are greater than\n127.\n\n19. The function for checking UTF-16 validity was returning an incorrect offset\nfor the start of the error when a high surrogate was not followed by a valid\nlow surrogate. This caused incorrect behaviour, for example when\nPCRE2_MATCH_INVALID_UTF was set and a match started immediately following the\ninvalid high surrogate, such as /aa/ matching \"\\x{d800}aa\".\n\n20. If a DEFINE group immediately preceded a lookbehind assertion, the pattern\ncould be mis-compiled and therefore not match correctly. This is the example\nthat found this: /(?(DEFINE)(?<foo>bar))(?<![-a-z0-9])word/ which failed to\nmatch \"word\" because the \"move back\" value was set to zero.\n\n21. Following a request from a user, some extensions and tidies to the\ncharacter tables handling have been done:\n\n  (a) The dftables auxiliary program is renamed pcre2_dftables, but it is still\n  not installed for public use.\n\n  (b) There is now a -b option for pcre2_dftables, which causes the tables to\n  be written in binary. There is also a -help option.\n\n  (c) PCRE2_CONFIG_TABLES_LENGTH is added to pcre2_config() so that an\n  application that wants to save tables in binary knows how long they are.\n\n22. Changed setting of CMAKE_MODULE_PATH in CMakeLists.txt from SET to\nLIST(APPEND...) to allow a setting from the command line to be included.\n\n23. Updated to Unicode 13.0.0.\n\n24. CMake build now checks for secure_getenv() and strerror(). Patch by Carlo.\n\n25. Avoid using [-1] as a suffix in pcre2test because it can provoke a compiler\nwarning.\n\n26. Added tests for __attribute__((uninitialized)) to both the configure and\nCMake build files, and then applied this attribute to the variable called\nstack_frames_vector[] in pcre2_match(). When implemented, this disables\nautomatic initialization (a facility in clang), which can take time on big\nvariables.\n\n27. Updated CMakeLists.txt (patches by Uwe Korn) to add support for\npcre2-config, the libpcre*.pc files, SOVERSION, VERSION and the\nMACHO_*_VERSIONS settings for CMake builds.\n\n28. Another patch to CMakeLists.txt to check for mkostemp (configure already\ndoes). Patch by Carlo Marcelo Arenas Belon.\n\n29. Check for the existence of memfd_create in both CMake and configure\nconfigurations. Patch by Carlo Marcelo Arenas Belon.\n\n30. Restrict the configuration setting for the SELinux compatible execmem\nallocator (change 10.30/44) to Linux and NetBSD.\n\n\nVersion 10.34 21-November-2019\n------------------------------\n\n1. The maximum number of capturing subpatterns is 65535 (documented), but no\ncheck on this was ever implemented. This omission has been rectified; it fixes\nClusterFuzz 14376.\n\n2. Improved the invalid utf32 support of the JIT compiler. Now it correctly\ndetects invalid characters in the 0xd800-0xdfff range.\n\n3. Fix minor typo bug in JIT compile when \\X is used in a non-UTF string.\n\n4. Add support for matching in invalid UTF strings to the pcre2_match()\ninterpreter, and integrate with the existing JIT support via the new\nPCRE2_MATCH_INVALID_UTF compile-time option.\n\n5. Give more error detail for invalid UTF-8 when detected in pcre2grep.\n\n6. Add support for invalid UTF-8 to pcre2grep.\n\n7. Adjust the limit for \"must have\" code unit searching, in particular,\nincrease it substantially for non-anchored patterns.\n\n8. Allow (*ACCEPT) to be quantified, because an ungreedy quantifier with a zero\nminimum is potentially useful.\n\n9. Some changes to the way the minimum subject length is handled:\n\n   * When PCRE2_NO_START_OPTIMIZE is set, no minimum length is computed;\n     pcre2test now omits this item instead of showing a value of zero.\n\n   * An incorrect minimum length could be calculated for a pattern that\n     contained (*ACCEPT) inside a qualified group whose minimum repetition was\n     zero, for example /A(?:(*ACCEPT))?B/, which incorrectly computed a minimum\n     of 2. The minimum length scan no longer happens for a pattern that\n     contains (*ACCEPT).\n\n   * When no minimum length is set by the normal scan, but a first and/or last\n     code unit is recorded, set the minimum to 1 or 2 as appropriate.\n\n   * When a pattern contains multiple groups with the same number, a back\n     reference cannot know which one to scan for a minimum length. This used to\n     cause the minimum length finder to give up with no result. Now it treats\n     such references as not adding to the minimum length (which it should have\n     done all along).\n\n   * Furthermore, the above action now happens only if the back reference is to\n     a group that exists more than once in a pattern instead of any back\n     reference in a pattern with duplicate numbers.\n\n10. A (*MARK) value inside a successful condition was not being returned by the\ninterpretive matcher (it was returned by JIT). This bug has been mended.\n\n11. A bug in pcre2grep meant that -o without an argument (or -o0) didn't work\nif the pattern had more than 32 capturing parentheses. This is fixed. In\naddition (a) the default limit for groups requested by -o<n> has been raised to\n50, (b) the new --om-capture option changes the limit, (c) an error is raised\nif -o asks for a group that is above the limit.\n\n12. The quantifier {1} was always being ignored, but this is incorrect when it\nis made possessive and applied to an item in parentheses, because a\nparenthesized item may contain multiple branches or other backtracking points,\nfor example /(a|ab){1}+c/ or /(a+){1}+a/.\n\n13. For partial matches, pcre2test was always showing the maximum lookbehind\ncharacters, flagged with \"<\", which is misleading when the lookbehind didn't\nactually look behind the start (because it was later in the pattern). Showing\nall consulted preceding characters for partial matches is now controlled by the\nexisting \"allusedtext\" modifier and, as for complete matches, this facility is\navailable only for non-JIT matching, because JIT does not maintain the first\nand last consulted characters.\n\n14. DFA matching (using pcre2_dfa_match()) was not recognising a partial match\nif the end of the subject was encountered in a lookahead (conditional or\notherwise), an atomic group, or a recursion.\n\n15. Give error if pcre2test -t, -T, -tm or -TM is given an argument of zero.\n\n16. Check for integer overflow when computing lookbehind lengths. Fixes\nClusterfuzz issue 15636.\n\n17. Implemented non-atomic positive lookaround assertions.\n\n18. If a lookbehind contained a lookahead that contained another lookbehind\nwithin it, the nested lookbehind was not correctly processed. For example, if\n/(?<=(?=(?<=a)))b/ was matched to \"ab\" it gave no match instead of matching\n\"b\".\n\n19. Implemented pcre2_get_match_data_size().\n\n20. Two alterations to partial matching:\n\n    (a) The definition of a partial match is slightly changed: if a pattern\n    contains any lookbehinds, an empty partial match may be given, because this\n    is another situation where adding characters to the current subject can\n    lead to a full match. Example: /c*+(?<=[bc])/ with subject \"ab\".\n\n    (b) Similarly, if a pattern could match an empty string, an empty partial\n    match may be given. Example: /(?![ab]).*/ with subject \"ab\". This case\n    applies only to PCRE2_PARTIAL_HARD.\n\n    (c) An empty string partial hard match can be returned for \\z and \\Z as it\n    is documented that they shouldn't match.\n\n21. A branch that started with (*ACCEPT) was not being recognized as one that\ncould match an empty string.\n\n22. Corrected pcre2_set_character_tables() tables data type: was const unsigned\nchar * instead of const uint8_t *, as generated by pcre2_maketables().\n\n23. Upgraded to Unicode 12.1.0.\n\n24. Add -jitfast command line option to pcre2test (to make all the jit options\navailable directly).\n\n25. Make pcre2test -C show if libreadline or libedit is supported.\n\n26. If the length of one branch of a group exceeded 65535 (the maximum value\nthat is remembered as a minimum length), the whole group's length was\nincorrectly recorded as 65535, leading to incorrect \"no match\" when start-up\noptimizations were in force.\n\n27. The \"rightmost consulted character\" value was not always correct; in\nparticular, if a pattern ended with a negative lookahead, characters that were\ninspected in that lookahead were not included.\n\n28. Add the pcre2_maketables_free() function.\n\n29. The start-up optimization that looks for a unique initial matching\ncode unit in the interpretive engines uses memchr() in 8-bit mode. When the\nsearch is caseless, it was doing so inefficiently, which ended up slowing down\nthe match drastically when the subject was very long. The revised code (a)\nremembers if one case is not found, so it never repeats the search for that\ncase after a bumpalong and (b) when one case has been found, it searches only\nup to that position for an earlier occurrence of the other case. This fix\napplies to both interpretive pcre2_match() and to pcre2_dfa_match().\n\n30. While scanning to find the minimum length of a group, if any branch has\nminimum length zero, there is no need to scan any subsequent branches (a small\ncompile-time performance improvement).\n\n31. Installed a .gitignore file on a user's suggestion. When using the svn\nrepository with git (through git svn) this helps keep it tidy.\n\n32. Add underflow check in JIT which may occur when the value of subject\nstring pointer is close to 0.\n\n33. Arrange for classes such as [Aa] which contain just the two cases of the\nsame character, to be treated as a single caseless character. This causes the\nfirst and required code unit optimizations to kick in where relevant.\n\n34. Improve the bitmap of starting bytes for positive classes that include wide\ncharacters, but no property types, in UTF-8 mode. Previously, on encountering\nsuch a class, the bits for all bytes greater than \\xc4 were set, thus\nspecifying any character with codepoint >= 0x100. Now the only bits that are\nset are for the relevant bytes that start the wide characters. This can give a\nnoticeable performance improvement.\n\n35. If the bitmap of starting code units contains only 1 or 2 bits, replace it\nwith a single starting code unit (1 bit) or a caseless single starting code\nunit if the two relevant characters are case-partners. This is particularly\nrelevant to the 8-bit library, though it applies to all. It can give a\nperformance boost for patterns such as [Ww]ord and (word|WORD). However, this\noptimization doesn't happen if there is a \"required\" code unit of the same\nvalue (because the search for a \"required\" code unit starts at the match start\nfor non-unique first code unit patterns, but after a unique first code unit,\nand patterns such as a*a need the former action).\n\n36. Small patch to pcre2posix.c to set the erroroffset field to -1 immediately\nafter a successful compile, instead of at the start of matching to avoid a\nsanitizer complaint (regexec is supposed to be thread safe).\n\n37. Add NEON vectorization to JIT to speed up matching of first character and\npairs of characters on ARM64 CPUs.\n\n38. If a non-ASCII character was the first in a starting assertion in a\ncaseless match, the \"first code unit\" optimization did not get the casing\nright, and the assertion failed to match a character in the other case if it\ndid not start with the same code unit.\n\n39. Fixed the incorrect computation of jump sizes on x86 CPUs in JIT. A masking\noperation was incorrectly removed in r1136. Reported by Ralf Junker.\n\n\nVersion 10.33 16-April-2019\n---------------------------\n\n1. Added \"allvector\" to pcre2test to make it easy to check the part of the\novector that shouldn't be changed, in particular after substitute and failed or\npartial matches.\n\n2. Fix subject buffer overread in JIT when UTF is disabled and \\X or \\R has\na greater than 1 fixed quantifier. This issue was found by Yunho Kim.\n\n3. Added support for callouts from pcre2_substitute(). After 10.33-RC1, but\nprior to release, fixed a bug that caused a crash if pcre2_substitute() was\ncalled with a NULL match context.\n\n4. The POSIX functions are now all called pcre2_regcomp() etc., with wrapper\nfunctions that use the standard POSIX names. However, in pcre2posix.h the POSIX\nnames are defined as macros. This should help avoid linking with the wrong\nlibrary in some environments while still exporting the POSIX names for\npre-existing programs that use them. (The Debian alternative names are also\ndefined as macros, but not documented.)\n\n5. Fix an xclass matching issue in JIT.\n\n6. Implement PCRE2_EXTRA_ESCAPED_CR_IS_LF (see Bugzilla 2315).\n\n7. Implement the Perl 5.28 experimental alphabetic names for atomic groups and\nlookaround assertions, for example, (*pla:...) and (*atomic:...). These are\ncharacterized by a lower case letter following (* and to simplify coding for\nthis, the character tables created by pcre2_maketables() were updated to add a\nnew \"is lower case letter\" bit. At the same time, the now unused \"is\nhexadecimal digit\" bit was removed. The default tables in\nsrc/pcre2_chartables.c.dist are updated.\n\n8. Implement the new Perl \"script run\" features (*script_run:...) and\n(*atomic_script_run:...) aka (*sr:...) and (*asr:...).\n\n9. Fixed two typos in change 22 for 10.21, which added special handling for\nranges such as a-z in EBCDIC environments. The original code probably never\nworked, though there were no bug reports.\n\n10. Implement PCRE2_COPY_MATCHED_SUBJECT for pcre2_match() (including JIT via\npcre2_match()) and pcre2_dfa_match(), but *not* the pcre2_jit_match() fast\npath. Also, when a match fails, set the subject field in the match data to NULL\nfor tidiness - none of the substring extractors should reference this after\nmatch failure.\n\n11. If a pattern started with a subroutine call that had a quantifier with a\nminimum of zero, an incorrect \"match must start with this character\" could be\nrecorded. Example: /(?&xxx)*ABC(?<xxx>XYZ)/ would (incorrectly) expect 'A' to\nbe the first character of a match.\n\n12. The heap limit checking code in pcre2_dfa_match() could suffer from\noverflow if the heap limit was set very large. This could cause incorrect \"heap\nlimit exceeded\" errors.\n\n13. Add \"kibibytes\" to the heap limit output from pcre2test -C to make the\nunits clear.\n\n14. Add a call to pcre2_jit_free_unused_memory() in pcre2grep, for tidiness.\n\n15. Updated the VMS-specific code in pcre2test on the advice of a VMS user.\n\n16. Removed the unnecessary inclusion of stdint.h (or inttypes.h) from\npcre2_internal.h as it is now included by pcre2.h. Also, change 17 for 10.32\nbelow was unnecessarily complicated, as inttypes.h is a Standard C header,\nwhich is defined to be a superset of stdint.h. Instead of conditionally\nincluding stdint.h or inttypes.h, pcre2.h now unconditionally includes\ninttypes.h. This supports environments that do not have stdint.h but do have\ninttypes.h, which are known to exist. A note in the autotools documentation\nsays (November 2018) that there are none known that are the other way round.\n\n17. Added --disable-percent-zt to \"configure\" (and equivalent to CMake) to\nforcibly disable the use of %zu and %td in formatting strings because there is\nat least one version of VMS that claims to be C99 but does not support these\nmodifiers.\n\n18. Added --disable-pcre2grep-callout-fork, which restricts the callout support\nin pcre2grep to the inbuilt echo facility. This may be useful in environments\nthat do not support fork().\n\n19. Fix two instances of <= 0 being applied to unsigned integers (the VMS\ncompiler complains).\n\n20. Added \"fork\" support for VMS to pcre2grep, for running an external program\nvia a string callout.\n\n21. Improve MAP_JIT flag usage on MacOS. Patch by Rich Siegel.\n\n22. If a pattern started with (*MARK), (*COMMIT), (*PRUNE), (*SKIP), or (*THEN)\nfollowed by ^ it was not recognized as anchored.\n\n23. The RunGrepTest script used to cut out the test of NUL characters for\nSolaris and MacOS as printf and sed can't handle them. It seems that the *BSD\nsystems can't either. I've inverted the test so that only those OS that are\nknown to work (currently only Linux) try to run this test.\n\n24. Some tests in RunGrepTest appended to testtrygrep from two different file\ndescriptors instead of redirecting stderr to stdout. This worked on Linux, but\nit was reported not to on other systems, causing the tests to fail.\n\n25. In the RunTest script, make the test for stack setting use the same value\nfor the stack as it needs for -bigstack.\n\n26. Insert a cast in pcre2_dfa_match.c to suppress a compiler warning.\n\n26. With PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL set, escape sequences such as \\s\nwhich are valid in character classes, but not as the end of ranges, were being\ntreated as literals. An example is [_-\\s] (but not [\\s-_] because that gave an\nerror at the *start* of a range). Now an \"invalid range\" error is given\nindependently of PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n27. Related to 26 above, PCRE2_BAD_ESCAPE_IS_LITERAL was affecting known escape\nsequences such as \\eX when they appeared invalidly in a character class. Now\nthe option applies only to unrecognized or malformed escape sequences.\n\n28. Fix word boundary in JIT compiler. Patch by Mike Munday.\n\n29. The pcre2_dfa_match() function was incorrectly handling conditional version\ntests such as (?(VERSION>=0)...) when the version test was true. Incorrect\nprocessing or a crash could result.\n\n30. When PCRE2_UTF is set, allow non-ASCII letters and decimal digits in group\nnames, as Perl does. There was a small bug in this new code, found by\nClusterFuzz 12950, fixed before release.\n\n31. Implemented PCRE2_EXTRA_ALT_BSUX to support ECMAScript 6's \\u{hhh}\nconstruct.\n\n32. Compile \\p{Any} to be the same as . in DOTALL mode, so that it benefits\nfrom auto-anchoring if \\p{Any}* starts a pattern.\n\n33. Compile invalid UTF check in JIT test when only pcre32 is enabled.\n\n34. For some time now, CMake has been warning about the setting of policy\nCMP0026 to \"OLD\" in CmakeLists.txt, and hinting that the feature might be\nremoved in a future version. A request for CMake expertise on the list produced\nno result, so I have now hacked CMakeLists.txt along the lines of some changes\nI found on the Internet. The new code no longer needs the policy setting, and\nit appears to work fine on Linux.\n\n35. Setting --enable-jit=auto for an out-of-tree build failed because the\nsource directory wasn't in the search path for AC_TRY_COMPILE always. Patch\nfrom Ross Burton.\n\n36. Disable SSE2 JIT optimizations in x86 CPUs when SSE2 is not available.\nPatch by Guillem Jover.\n\n37. Changed expressions such as 1<<10 to 1u<<10 in many places because compiler\nwarnings were reported.\n\n38. Using the clang compiler with sanitizing options causes runtime complaints\nabout truncation for statements such as x = ~x when x is an 8-bit value; it\nseems to compute ~x as a 32-bit value. Changing such statements to x = 255 ^ x\ngets rid of the warnings. There were also two missing casts in pcre2test.\n\n\nVersion 10.32 10-September-2018\n-------------------------------\n\n1. When matching using the the REG_STARTEND feature of the POSIX API with a\nnon-zero starting offset, unset capturing groups with lower numbers than a\ngroup that did capture something were not being correctly returned as \"unset\"\n(that is, with offset values of -1).\n\n2. When matching using the POSIX API, pcre2test used to omit listing unset\ngroups altogether. Now it shows those that come before any actual captures as\n\"<unset>\", as happens for non-POSIX matching.\n\n3. Running \"pcre2test -C\" always stated \"\\R matches CR, LF, or CRLF only\",\nwhatever the build configuration was. It now correctly says \"\\R matches all\nUnicode newlines\" in the default case when --enable-bsr-anycrlf has not been\nspecified. Similarly, running \"pcre2test -C bsr\" never produced the result\nANY.\n\n4. Matching the pattern /(*UTF)\\C[^\\v]+\\x80/ against an 8-bit string containing\nmulti-code-unit characters caused bad behaviour and possibly a crash. This\nissue was fixed for other kinds of repeat in release 10.20 by change 19, but\nrepeating character classes were overlooked.\n\n5. pcre2grep now supports the inclusion of binary zeros in patterns that are\nread from files via the -f option.\n\n6. A small fix to pcre2grep to avoid compiler warnings for -Wformat-overflow=2.\n\n7. Added --enable-jit=auto support to configure.ac.\n\n8. Added some dummy variables to the heapframe structure in 16-bit and 32-bit\nmodes for the benefit of m68k, where pointers can be 16-bit aligned. The\ndummies force 32-bit alignment and this ensures that the structure is a\nmultiple of PCRE2_SIZE, a requirement that is tested at compile time. In other\narchitectures, alignment requirements take care of this automatically.\n\n9. When returning an error from pcre2_pattern_convert(), ensure the error\noffset is set zero for early errors.\n\n10. A number of patches for Windows support from Daniel Richard G:\n\n  (a) List of error numbers in Runtest.bat corrected (it was not the same as in\n      Runtest).\n\n  (b) pcre2grep snprintf() workaround as used elsewhere in the tree.\n\n  (c) Support for non-C99 snprintf() that returns -1 in the overflow case.\n\n11. Minor tidy of pcre2_dfa_match() code.\n\n12. Refactored pcre2_dfa_match() so that the internal recursive calls no longer\nuse the stack for local workspace and local ovectors. Instead, an initial block\nof stack is reserved, but if this is insufficient, heap memory is used. The\nheap limit parameter now applies to pcre2_dfa_match().\n\n13. If a \"find limits\" test of DFA matching in pcre2test resulted in too many\nmatches for the ovector, no matches were displayed.\n\n14. Removed an occurrence of ctrl/Z from test 6 because Windows treats it as\nEOF. The test looks to have come from a fuzzer.\n\n15. If PCRE2 was built with a default match limit a lot greater than the\ndefault default of 10 000 000, some JIT tests of the match limit no longer\nfailed. All such tests now set 10 000 000 as the upper limit.\n\n16. Another Windows related patch for pcregrep to ensure that WIN32 is\nundefined under Cygwin.\n\n17. Test for the presence of stdint.h and inttypes.h in configure and CMake and\ninclude whichever exists (stdint preferred) instead of unconditionally\nincluding stdint. This makes life easier for old and non-standard systems.\n\n18. Further changes to improve portability, especially to old and or non-\nstandard systems:\n\n  (a) Put all printf arguments in RunGrepTest into single, not double, quotes,\n      and use \\0 not \\x00 for binary zero.\n\n  (b) Avoid the use of C++ (i.e. BCPL) // comments.\n\n  (c) Parameterize the use of %zu in pcre2test to make it like %td. For both of\n      these now, if using MSVC or a standard C before C99, %lu is used with a\n      cast if necessary.\n\n19. Applied a contributed patch to CMakeLists.txt to increase the stack size\nwhen linking pcre2test with MSVC. This gets rid of a stack overflow error in\nthe standard set of tests.\n\n20. Output a warning in pcre2test when ignoring the \"altglobal\" modifier when\nit is given with the \"replace\" modifier.\n\n21. In both pcre2test and pcre2_substitute(), with global matching, a pattern\nthat matched an empty string, but never at the starting match offset, was not\nhandled in a Perl-compatible way. The pattern /(<?=\\G.)/ is an example of such\na pattern. Because \\G is in a lookbehind assertion, there has to be a\n\"bumpalong\" before there can be a match. The automatic \"advance by one\ncharacter after an empty string match\" rule is therefore inappropriate. A more\ncomplicated algorithm has now been implemented.\n\n22. When checking to see if a lookbehind is of fixed length, lookaheads were\ncorrectly ignored, but qualifiers on lookaheads were not being ignored, leading\nto an incorrect \"lookbehind assertion is not fixed length\" error.\n\n23. The VERSION condition test was reading fractional PCRE2 version numbers\nsuch as the 04 in 10.04 incorrectly and hence giving wrong results.\n\n24. Updated to Unicode version 11.0.0. As well as the usual addition of new\nscripts and characters, this involved re-jigging the grapheme break property\nalgorithm because Unicode has changed the way emojis are handled.\n\n25. Fixed an obscure bug that struck when there were two atomic groups not\nseparated by something with a backtracking point. There could be an incorrect\nbacktrack into the first of the atomic groups. A complicated example is\n/(?>a(*:1))(?>b)(*SKIP:1)x|.*/ matched against \"abc\", where the *SKIP\nshouldn't find a MARK (because is in an atomic group), but it did.\n\n26. Upgraded the perltest.sh script: (1) #pattern lines can now be used to set\na list of modifiers for all subsequent patterns - only those that the script\nrecognizes are meaningful; (2) #subject lines can be used to set or unset a\ndefault \"mark\" modifier; (3) Unsupported #command lines give a warning when\nthey are ignored; (4) Mark data is output only if the \"mark\" modifier is\npresent.\n\n27. (*ACCEPT:ARG), (*FAIL:ARG), and (*COMMIT:ARG) are now supported.\n\n28. A (*MARK) name was not being passed back for positive assertions that were\nterminated by (*ACCEPT).\n\n29. Add support for \\N{U+dddd}, but only in Unicode mode.\n\n30. Add support for (?^) for unsetting all imnsx options.\n\n31. The PCRE2_EXTENDED (/x) option only ever discarded space characters whose\ncode point was less than 256 and that were recognized by the lookup table\ngenerated by pcre2_maketables(), which uses isspace() to identify white space.\nNow, when Unicode support is compiled, PCRE2_EXTENDED also discards U+0085,\nU+200E, U+200F, U+2028, and U+2029, which are additional characters defined by\nUnicode as \"Pattern White Space\". This makes PCRE2 compatible with Perl.\n\n32. In certain circumstances, option settings within patterns were not being\ncorrectly processed. For example, the pattern /((?i)A)(?m)B/ incorrectly\nmatched \"ab\". (The (?m) setting lost the fact that (?i) should be reset at the\nend of its group during the parse process, but without another setting such as\n(?m) the compile phase got it right.) This bug was introduced by the\nrefactoring in release 10.23.\n\n33. PCRE2 uses bcopy() if available when memmove() is not, and it used just to\ndefine memmove() as function call to bcopy(). This hasn't been tested for a\nlong time because in pcre2test the result of memmove() was being used, whereas\nbcopy() doesn't return a result. This feature is now refactored always to call\nan emulation function when there is no memmove(). The emulation makes use of\nbcopy() when available.\n\n34. When serializing a pattern, set the memctl, executable_jit, and tables\nfields (that is, all the fields that contain pointers) to zeros so that the\nresult of serializing is always the same. These fields are re-set when the\npattern is deserialized.\n\n35. In a pattern such as /[^\\x{100}-\\x{ffff}]*[\\x80-\\xff]/ which has a repeated\nnegative class with no characters less than 0x100 followed by a positive class\nwith only characters less than 0x100, the first class was incorrectly being\nauto-possessified, causing incorrect match failures.\n\n36. Removed the character type bit ctype_meta, which dates from PCRE1 and is\nnot used in PCRE2.\n\n37. Tidied up unnecessarily complicated macros used in the escapes table.\n\n38. Since 10.21, the new testoutput8-16-4 file has accidentally been omitted\nfrom distribution tarballs, owing to a typo in Makefile.am which had\ntestoutput8-16-3 twice. Now fixed.\n\n39. If the only branch in a conditional subpattern was anchored, the whole\nsubpattern was treated as anchored, when it should not have been, since the\nassumed empty second branch cannot be anchored. Demonstrated by test patterns\nsuch as /(?(1)^())b/ or /(?(?=^))b/.\n\n40. A repeated conditional subpattern that could match an empty string was\nalways assumed to be unanchored. Now it it checked just like any other\nrepeated conditional subpattern, and can be found to be anchored if the minimum\nquantifier is one or more. I can't see much use for a repeated anchored\npattern, but the behaviour is now consistent.\n\n41. Minor addition to pcre2_jit_compile.c to avoid static analyzer complaint\n(for an event that could never occur but you had to have external information\nto know that).\n\n42. If before the first match in a file that was being searched by pcre2grep\nthere was a line that was sufficiently long to cause the input buffer to be\nexpanded, the variable holding the location of the end of the previous match\nwas being adjusted incorrectly, and could cause an overflow warning from a code\nsanitizer. However, as the value is used only to print pending \"after\" lines\nwhen the next match is reached (and there are no such lines in this case) this\nbug could do no damage.\n\n\nVersion 10.31 12-February-2018\n------------------------------\n\n1. Fix typo (missing ]) in VMS code in pcre2test.c.\n\n2. Replace the replicated code for matching extended Unicode grapheme sequences\n(which got a lot more complicated by change 10.30/49) by a single subroutine\nthat is called by both pcre2_match() and pcre2_dfa_match().\n\n3. Add idempotent guard to pcre2_internal.h.\n\n4. Add new pcre2_config() options: PCRE2_CONFIG_NEVER_BACKSLASH_C and\nPCRE2_CONFIG_COMPILED_WIDTHS.\n\n5. Cut out \\C tests in the JIT regression tests when NEVER_BACKSLASH_C is\ndefined (e.g. by --enable-never-backslash-C).\n\n6. Defined public names for all the pcre2_compile() error numbers, and used\nthe public names in pcre2_convert.c.\n\n7. Fixed a small memory leak in pcre2test (convert contexts).\n\n8. Added two casts to compile.c and one to match.c to avoid compiler warnings.\n\n9. Added code to pcre2grep when compiled under VMS to set the symbol\nPCRE2GREP_RC to the exit status, because VMS does not distinguish between\nexit(0) and exit(1).\n\n10. Added the -LM (list modifiers) option to pcre2test. Also made -C complain\nabout a bad option only if the following argument item does not start with a\nhyphen.\n\n11. pcre2grep was truncating components of file names to 128 characters when\nprocessing files with the -r option, and also (some very odd code) truncating\npath names to 512 characters. There is now a check on the absolute length of\nfull path file names, which may be up to 2047 characters long.\n\n12. When an assertion contained (*ACCEPT) it caused all open capturing groups\nto be closed (as for a non-assertion ACCEPT), which was wrong and could lead to\nmisbehaviour for subsequent references to groups that started outside the\nassertion. ACCEPT in an assertion now closes only those groups that were\nstarted within that assertion. Fixes oss-fuzz issues 3852 and 3891.\n\n13. Multiline matching in pcre2grep was misbehaving if the pattern matched\nwithin a line, and then matched again at the end of the line and over into\nsubsequent lines. Behaviour was different with and without colouring, and\nsometimes context lines were incorrectly printed and/or line endings were lost.\nAll these issues should now be fixed.\n\n14. If --line-buffered was specified for pcre2grep when input was from a\ncompressed file (.gz or .bz2) a segfault occurred. (Line buffering should be\nignored for compressed files.)\n\n15. Although pcre2_jit_match checks whether the pattern is compiled\nin a given mode, it was also expected that at least one mode is available.\nThis is fixed and pcre2_jit_match returns with PCRE2_ERROR_JIT_BADOPTION\nwhen the pattern is not optimized by JIT at all.\n\n16. The line number and related variables such as match counts in pcre2grep\nwere all int variables, causing overflow when files with more than 2147483647\nlines were processed (assuming 32-bit ints). They have all been changed to\nunsigned long ints.\n\n17. If a backreference with a minimum repeat count of zero was first in a\npattern, apart from assertions, an incorrect first matching character could be\nrecorded. For example, for the pattern /(?=(a))\\1?b/, \"b\" was incorrectly set\nas the first character of a match.\n\n18. Characters in a leading positive assertion are considered for recording a\nfirst character of a match when the rest of the pattern does not provide one.\nHowever, a character in a non-assertive group within a leading assertion such\nas in the pattern /(?=(a))\\1?b/ caused this process to fail. This was an\ninfelicity rather than an outright bug, because it did not affect the result of\na match, just its speed. (In fact, in this case, the starting 'a' was\nsubsequently picked up in the study.)\n\n19. A minor tidy in pcre2_match(): making all PCRE2_ERROR_ returns use \"return\"\ninstead of \"RRETURN\" saves unwinding the backtracks in these cases (only one\ndidn't).\n\n20. Allocate a single callout block on the stack at the start of pcre2_match()\nand set its never-changing fields once only. Do the same for pcre2_dfa_match().\n\n21. Save the extra compile options (set in the compile context) with the\ncompiled pattern (they were not previously saved), add PCRE2_INFO_EXTRAOPTIONS\nto retrieve them, and update pcre2test to show them.\n\n22. Added PCRE2_CALLOUT_STARTMATCH and PCRE2_CALLOUT_BACKTRACK bits to a new\nfield callout_flags in callout blocks. The bits are set by pcre2_match(), but\nnot by JIT or pcre2_dfa_match(). Their settings are shown in pcre2test callouts\nif the callout_extra subject modifier is set. These bits are provided to help\nwith tracking how a backtracking match is proceeding.\n\n23. Updated the pcre2demo.c demonstration program, which was missing the extra\ncode for -g that handles the case when \\K in an assertion causes the match to\nend at the original start point. Also arranged for it to detect when \\K causes\nthe end of a match to be before its start.\n\n24. Similar to 23 above, strange things (including loops) could happen in\npcre2grep when \\K was used in an assertion when --colour was used or in\nmultiline mode. The \"end at original start point\" bug is fixed, and if the end\npoint is found to be before the start point, they are swapped.\n\n25. When PCRE2_FIRSTLINE without PCRE2_NO_START_OPTIMIZE was used in non-JIT\nmatching (both pcre2_match() and pcre2_dfa_match()) and the matched string\nstarted with the first code unit of a newline sequence, matching failed because\nit was not tried at the newline.\n\n26. Code for giving up a non-partial match after failing to find a starting\ncode unit anywhere in the subject was missing when searching for one of a\nnumber of code units (the bitmap case) in both pcre2_match() and\npcre2_dfa_match(). This was a missing optimization rather than a bug.\n\n27. Tidied up the ACROSSCHAR macro to be like FORWARDCHAR and BACKCHAR, using a\npointer argument rather than a code unit value. This should not have affected\nthe generated code.\n\n28. The JIT compiler has been updated.\n\n29. Avoid pointer overflow for unset captures in pcre2_substring_list_get().\nThis could not actually cause a crash because it was always used in a memcpy()\ncall with zero length.\n\n30. Some internal structures have a variable-length ovector[] as their last\nelement. Their actual memory is obtained dynamically, giving an ovector of\nappropriate length. However, they are defined in the structure as\novector[NUMBER], where NUMBER is large so that array bound checkers don't\ngrumble. The value of NUMBER was 10000, but a fuzzer exceeded 5000 capturing\ngroups, making the ovector larger than this. The number has been increased to\n131072, which allows for the maximum number of captures (65535) plus the\noverall match. This fixes oss-fuzz issue 5415.\n\n31. Auto-possessification at the end of a capturing group was dependent on what\nfollows the group (e.g. /(a+)b/ would auto-possessify the a+) but this caused\nincorrect behaviour when the group was called recursively from elsewhere in the\npattern where something different might follow. This bug is an unforseen\nconsequence of change #1 for 10.30 - the implementation of backtracking into\nrecursions. Iterators at the ends of capturing groups are no longer considered\nfor auto-possessification if the pattern contains any recursions. Fixes\nBugzilla #2232.\n\n\nVersion 10.30 14-August-2017\n----------------------------\n\n1. The main interpreter, pcre2_match(), has been refactored into a new version\nthat does not use recursive function calls (and therefore the stack) for\nremembering backtracking positions. This makes --disable-stack-for-recursion a\nNOOP. The new implementation allows backtracking into recursive group calls in\npatterns, making it more compatible with Perl, and also fixes some other\nhard-to-do issues such as #1887 in Bugzilla. The code is also cleaner because\nthe old code had a number of fudges to try to reduce stack usage. It seems to\nrun no slower than the old code.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. These\nbugs were never in fully released code, but are noted here for the record.\n\n  (a) If a pattern had fewer capturing parentheses than the ovector supplied in\n      the match data block, a memory error (detectable by ASAN) occurred after\n      a match, because the external block was being set from non-existent\n      internal ovector fields. Fixes oss-fuzz issue 781.\n\n  (b) A pattern with very many capturing parentheses (when the internal frame\n      size was greater than the initial frame vector on the stack) caused a\n      crash. A vector on the heap is now set up at the start of matching if the\n      vector on the stack is not big enough to handle at least 10 frames.\n      Fixes oss-fuzz issue 783.\n\n  (c) Handling of (*VERB)s in recursions was wrong in some cases.\n\n  (d) Captures in negative assertions that were used as conditions were not\n      happening if the assertion matched via (*ACCEPT).\n\n  (e) Mark values were not being passed out of recursions.\n\n  (f) Refactor some code in do_callout() to avoid picky compiler warnings about\n      negative indices. Fixes oss-fuzz issue 1454.\n\n  (g) Similarly refactor the way the variable length ovector is addressed for\n      similar reasons. Fixes oss-fuzz issue 1465.\n\n2. Now that pcre2_match() no longer uses recursive function calls (see above),\nthe \"match limit recursion\" value seems misnamed. It still exists, and limits\nthe depth of tree that is searched. To avoid future confusion, it has been\nrenamed as \"depth limit\" in all relevant places (--with-depth-limit,\n(*LIMIT_DEPTH), pcre2_set_depth_limit(), etc) but the old names are still\navailable for backwards compatibility.\n\n3. Hardened pcre2test so as to reduce the number of bugs reported by fuzzers:\n\n  (a) Check for malloc failures when getting memory for the ovector (POSIX) or\n      the match data block (non-POSIX).\n\n4. In the 32-bit library in non-UTF mode, an attempt to find a Unicode property\nfor a character with a code point greater than 0x10ffff (the Unicode maximum)\ncaused a crash.\n\n5. If a lookbehind assertion that contained a back reference to a group\nappearing later in the pattern was compiled with the PCRE2_ANCHORED option,\nundefined actions (often a segmentation fault) could occur, depending on what\nother options were set. An example assertion is (?<!\\1(abc)) where the\nreference \\1 precedes the group (abc). This fixes oss-fuzz issue 865.\n\n6. Added the PCRE2_INFO_FRAMESIZE item to pcre2_pattern_info() and arranged for\npcre2test to use it to output the frame size when the \"framesize\" modifier is\ngiven.\n\n7. Reworked the recursive pattern matching in the JIT compiler to follow the\ninterpreter changes.\n\n8. When the zero_terminate modifier was specified on a pcre2test subject line\nfor global matching, unpredictable things could happen. For example, in UTF-8\nmode, the pattern //g,zero_terminate read random memory when matched against an\nempty string with zero_terminate. This was a bug in pcre2test, not the library.\n\n9. Moved some Windows-specific code in pcre2grep (introduced in 10.23/13) out\nof the section that is compiled when Unix-style directory scanning is\navailable, and into a new section that is always compiled for Windows.\n\n10. In pcre2test, explicitly close the file after an error during serialization\nor deserialization (the \"load\" or \"save\" commands).\n\n11. Fix memory leak in pcre2_serialize_decode() when the input is invalid.\n\n12. Fix potential NULL dereference in pcre2_callout_enumerate() if called with\na NULL pattern pointer when Unicode support is available.\n\n13. When the 32-bit library was being tested by pcre2test, error messages that\nwere longer than 64 code units could cause a buffer overflow. This was a bug in\npcre2test.\n\n14. The alternative matching function, pcre2_dfa_match() misbehaved if it\nencountered a character class with a possessive repeat, for example [a-f]{3}+.\n\n15. The depth (formerly recursion) limit now applies to DFA matching (as\nof 10.23/36); pcre2test has been upgraded so that \\=find_limits works with DFA\nmatching to find the minimum value for this limit.\n\n16. Since 10.21, if pcre2_match() was called with a null context, default\nmemory allocation functions were used instead of whatever was used when the\npattern was compiled.\n\n17. Changes to the pcre2test \"memory\" modifier on a subject line. These apply\nonly to pcre2_match():\n\n  (a) Warn if null_context is set on both pattern and subject, because the\n      memory details cannot then be shown.\n\n  (b) Remember (up to a certain number of) memory allocations and their\n      lengths, and list only the lengths, so as to be system-independent.\n      (In practice, the new interpreter never has more than 2 blocks allocated\n      simultaneously.)\n\n18. Make pcre2test detect an error return from pcre2_get_error_message(), give\na message, and abandon the run (this would have detected #13 above).\n\n19. Implemented PCRE2_ENDANCHORED.\n\n20. Applied Jason Hood's patches (slightly modified) to pcre2grep, to implement\nthe --output=text (-O) option and the inbuilt callout echo.\n\n21. Extend auto-anchoring etc. to ignore groups with a zero qualifier and\nsingle-branch conditions with a false condition (e.g. DEFINE) at the start of a\nbranch. For example, /(?(DEFINE)...)^A/ and /(...){0}^B/ are now flagged as\nanchored.\n\n22. Added an explicit limit on the amount of heap used by pcre2_match(), set by\npcre2_set_heap_limit() or (*LIMIT_HEAP=xxx). Upgraded pcre2test to show the\nheap limit along with other pattern information, and to find the minimum when\nthe find_limits modifier is set.\n\n23. Write to the last 8 bytes of the pcre2_real_code structure when a compiled\npattern is set up so as to initialize any padding the compiler might have\nincluded. This avoids valgrind warnings when a compiled pattern is copied, in\nparticular when it is serialized.\n\n24. Remove a redundant line of code left in accidentally a long time ago.\n\n25. Remove a duplication typo in pcre2_tables.c\n\n26. Correct an incorrect cast in pcre2_valid_utf.c\n\n27. Update pcre2test, remove some unused code in pcre2_match(), and upgrade the\ntests to improve coverage.\n\n28. Some fixes/tidies as a result of looking at Coverity Scan output:\n\n    (a) Typo: \">\" should be \">=\" in opcode check in pcre2_auto_possess.c.\n    (b) Added some casts to avoid \"suspicious implicit sign extension\".\n    (c) Resource leaks in pcre2test in rare error cases.\n    (d) Avoid warning for never-use case OP_TABLE_LENGTH which is just a fudge\n        for checking at compile time that tables are the right size.\n    (e) Add missing \"fall through\" comment.\n\n29. Implemented PCRE2_EXTENDED_MORE and related /xx and (?xx) features.\n\n30. Implement (?n: for PCRE2_NO_AUTO_CAPTURE, because Perl now has this.\n\n31. If more than one of \"push\", \"pushcopy\", or \"pushtablescopy\" were set in\npcre2test, a crash could occur.\n\n32. Make -bigstack in RunTest allocate a 64MiB stack (instead of 16MiB) so\nthat all the tests can run with clang's sanitizing options.\n\n33. Implement extra compile options in the compile context and add the first\none: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES.\n\n34. Implement newline type PCRE2_NEWLINE_NUL.\n\n35. A lookbehind assertion that had a zero-length branch caused undefined\nbehaviour when processed by pcre2_dfa_match(). This is oss-fuzz issue 1859.\n\n36. The match limit value now also applies to pcre2_dfa_match() as there are\npatterns that can use up a lot of resources without necessarily recursing very\ndeeply. (Compare item 10.23/36.) This should fix oss-fuzz #1761.\n\n37. Implement PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n38. Fix returned offsets from regexec() when REG_STARTEND is used with a\nstarting offset greater than zero.\n\n39. Implement REG_PEND (GNU extension) for the POSIX wrapper.\n\n40. Implement the subject_literal modifier in pcre2test, and allow jitstack on\npattern lines.\n\n41. Implement PCRE2_LITERAL and use it to support REG_NOSPEC.\n\n42. Implement PCRE2_EXTRA_MATCH_LINE and PCRE2_EXTRA_MATCH_WORD for the benefit\nof pcre2grep.\n\n43. Re-implement pcre2grep's -F, -w, and -x options using PCRE2_LITERAL,\nPCRE2_EXTRA_MATCH_WORD, and PCRE2_EXTRA_MATCH_LINE. This fixes two bugs:\n\n    (a) The -F option did not work for fixed strings containing \\E.\n    (b) The -w option did not work for patterns with multiple branches.\n\n44. Added configuration options for the SELinux compatible execmem allocator in\nJIT.\n\n45. Increased the limit for searching for a \"must be present\" code unit in\nsubjects from 1000 to 2000 for 8-bit searches, since they use memchr() and are\nmuch faster.\n\n46. Arrange for anchored patterns to record and use \"first code unit\" data,\nbecause this can give a fast \"no match\" without searching for a \"required code\nunit\". Previously only non-anchored patterns did this.\n\n47. Upgraded the Unicode tables from Unicode 8.0.0 to Unicode 10.0.0.\n\n48. Add the callout_no_where modifier to pcre2test.\n\n49. Update extended grapheme breaking rules to the latest set that are in\nUnicode Standard Annex #29.\n\n50. Added experimental foreign pattern conversion facilities\n(pcre2_pattern_convert() and friends).\n\n51. Change the macro FWRITE, used in pcre2grep, to FWRITE_IGNORE because FWRITE\nis defined in a system header in cygwin. Also modified some of the #ifdefs in\npcre2grep related to Windows and Cygwin support.\n\n52. Change 3(g) for 10.23 was a bit too zealous. If a hyphen that follows a\ncharacter class is the last character in the class, Perl does not give a\nwarning. PCRE2 now also treats this as a literal.\n\n53. Related to 52, though PCRE2 was throwing an error for [[:digit:]-X] it was\nnot doing so for [\\d-X] (and similar escapes), as is documented.\n\n54. Fixed a MIPS issue in the JIT compiler reported by Joshua Kinard.\n\n55. Fixed a \"maybe uninitialized\" warning for class_uchardata in \\p handling in\npcre2_compile() which could never actually trigger (code should have been cut\nout when Unicode support is disabled).\n\n\nVersion 10.23 14-February-2017\n------------------------------\n\n1. Extended pcre2test with the utf8_input modifier so that it is able to\ngenerate all possible 16-bit and 32-bit code unit values in non-UTF modes.\n\n2. In any wide-character mode (8-bit UTF or any 16-bit or 32-bit mode), without\nPCRE2_UCP set, a negative character type such as \\D in a positive class should\ncause all characters greater than 255 to match, whatever else is in the class.\nThere was a bug that caused this not to happen if a Unicode property item was\nadded to such a class, for example [\\D\\P{Nd}] or [\\W\\pL].\n\n3. There has been a major re-factoring of the pcre2_compile.c file. Most syntax\nchecking is now done in the pre-pass that identifies capturing groups. This has\nreduced the amount of duplication and made the code tidier. While doing this,\nsome minor bugs and Perl incompatibilities were fixed, including:\n\n  (a) \\Q\\E in the middle of a quantifier such as A+\\Q\\E+ is now ignored instead\n      of giving an invalid quantifier error.\n\n  (b) {0} can now be used after a group in a lookbehind assertion; previously\n      this caused an \"assertion is not fixed length\" error.\n\n  (c) Perl always treats (?(DEFINE) as a \"define\" group, even if a group with\n      the name \"DEFINE\" exists. PCRE2 now does likewise.\n\n  (d) A recursion condition test such as (?(R2)...) must now refer to an\n      existing subpattern.\n\n  (e) A conditional recursion test such as (?(R)...) misbehaved if there was a\n      group whose name began with \"R\".\n\n  (f) When testing zero-terminated patterns under valgrind, the terminating\n      zero is now marked \"no access\". This catches bugs that would otherwise\n      show up only with non-zero-terminated patterns.\n\n  (g) A hyphen appearing immediately after a POSIX character class (for example\n      /[[:ascii:]-z]/) now generates an error. Perl does accept this as a\n      literal, but gives a warning, so it seems best to fail it in PCRE.\n\n  (h) An empty \\Q\\E sequence may appear after a callout that precedes an\n      assertion condition (it is, of course, ignored).\n\nOne effect of the refactoring is that some error numbers and messages have\nchanged, and the pattern offset given for compiling errors is not always the\nright-most character that has been read. In particular, for a variable-length\nlookbehind assertion it now points to the start of the assertion. Another\nchange is that when a callout appears before a group, the \"length of next\npattern item\" that is passed now just gives the length of the opening\nparenthesis item, not the length of the whole group. A length of zero is now\ngiven only for a callout at the end of the pattern. Automatic callouts are no\nlonger inserted before and after explicit callouts in the pattern.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. Many\nof the bugs were discovered by fuzzing testing. Several of them were related to\nthe change from assuming a zero-terminated pattern (which previously had\nrequired non-zero terminated strings to be copied). These bugs were never in\nfully released code, but are noted here for the record.\n\n  (a) An overall recursion such as (?0) inside a lookbehind assertion was not\n      being diagnosed as an error.\n\n  (b) In utf mode, the length of a *MARK (or other verb) name was being checked\n      in characters instead of code units, which could lead to bad code being\n      compiled, leading to unpredictable behaviour.\n\n  (c) In extended /x mode, characters whose code was greater than 255 caused\n      a lookup outside one of the global tables. A similar bug existed for wide\n      characters in *VERB names.\n\n  (d) The amount of memory needed for a compiled pattern was miscalculated if a\n      lookbehind contained more than one toplevel branch and the first branch\n      was of length zero.\n\n  (e) In UTF-8 or UTF-16 modes with PCRE2_EXTENDED (/x) set and a non-zero-\n      terminated pattern, if a # comment ran on to the end of the pattern, one\n      or more code units past the end were being read.\n\n  (f) An unterminated repeat at the end of a non-zero-terminated pattern (e.g.\n      \"{2,2\") could cause reading beyond the pattern.\n\n  (g) When reading a callout string, if the end delimiter was at the end of the\n      pattern one further code unit was read.\n\n  (h) An unterminated number after \\g' could cause reading beyond the pattern.\n\n  (i) An insufficient memory size was being computed for compiling with\n      PCRE2_AUTO_CALLOUT.\n\n  (j) A conditional group with an assertion condition used more memory than was\n      allowed for it during parsing, so too many of them could therefore\n      overrun a buffer.\n\n  (k) If parsing a pattern exactly filled the buffer, the internal test for\n      overrun did not check when the final META_END item was added.\n\n  (l) If a lookbehind contained a subroutine call, and the called group\n      contained an option setting such as (?s), and the PCRE2_ANCHORED option\n      was set, unpredictable behaviour could occur. The underlying bug was\n      incorrect code and insufficient checking while searching for the end of\n      the called subroutine in the parsed pattern.\n\n  (m) Quantifiers following (*VERB)s were not being diagnosed as errors.\n\n  (n) The use of \\Q...\\E in a (*VERB) name when PCRE2_ALT_VERBNAMES and\n      PCRE2_AUTO_CALLOUT were both specified caused undetermined behaviour.\n\n  (o) If \\Q was preceded by a quantified item, and the following \\E was\n      followed by '?' or '+', and there was at least one literal character\n      between them, an internal error \"unexpected repeat\" occurred (example:\n      /.+\\QX\\E+/).\n\n  (p) A buffer overflow could occur while sorting the names in the group name\n      list (depending on the order in which the names were seen).\n\n  (q) A conditional group that started with a callout was not doing the right\n      check for a following assertion, leading to compiling bad code. Example:\n      /(?(C'XX))?!XX/\n\n  (r) If a character whose code point was greater than 0xffff appeared within\n      a lookbehind that was within another lookbehind, the calculation of the\n      lookbehind length went wrong and could provoke an internal error.\n\n  (t) The sequence \\E- or \\Q\\E- after a POSIX class in a character class caused\n      an internal error. Now the hyphen is treated as a literal.\n\n4. Back references are now permitted in lookbehind assertions when there are\nno duplicated group numbers (that is, (?| has not been used), and, if the\nreference is by name, there is only one group of that name. The referenced\ngroup must, of course be of fixed length.\n\n5. pcre2test has been upgraded so that, when run under valgrind with valgrind\nsupport enabled, reading past the end of the pattern is detected, both when\ncompiling and during callout processing.\n\n6. \\g{+<number>} (e.g. \\g{+2} ) is now supported. It is a \"forward back\nreference\" and can be useful in repetitions (compare \\g{-<number>} ). Perl does\nnot recognize this syntax.\n\n7. Automatic callouts are no longer generated before and after callouts in the\npattern.\n\n8. When pcre2test was outputing information from a callout, the caret indicator\nfor the current position in the subject line was incorrect if it was after an\nescape sequence for a character whose code point was greater than \\x{ff}.\n\n9. Change 19 for 10.22 had a typo (PCRE_STATIC_RUNTIME should be\nPCRE2_STATIC_RUNTIME). Fix from David Gaussmann.\n\n10. Added --max-buffer-size to pcre2grep, to allow for automatic buffer\nexpansion when long lines are encountered. Original patch by Dmitry\nCherniachenko.\n\n11. If pcre2grep was compiled with JIT support, but the library was compiled\nwithout it (something that neither ./configure nor CMake allow, but it can be\ndone by editing config.h), pcre2grep was giving a JIT error. Now it detects\nthis situation and does not try to use JIT.\n\n12. Added some \"const\" qualifiers to variables in pcre2grep.\n\n13. Added Dmitry Cherniachenko's patch for colouring output in Windows\n(untested by me). Also, look for GREP_COLOUR or GREP_COLOR if the environment\nvariables PCRE2GREP_COLOUR and PCRE2GREP_COLOR are not found.\n\n14. Add the -t (grand total) option to pcre2grep.\n\n15. A number of bugs have been mended relating to match start-up optimizations\nwhen the first thing in a pattern is a positive lookahead. These all applied\nonly when PCRE2_NO_START_OPTIMIZE was *not* set:\n\n    (a) A pattern such as (?=.*X)X$ was incorrectly optimized as if it needed\n        both an initial 'X' and a following 'X'.\n    (b) Some patterns starting with an assertion that started with .* were\n        incorrectly optimized as having to match at the start of the subject or\n        after a newline. There are cases where this is not true, for example,\n        (?=.*[A-Z])(?=.{8,16})(?!.*[\\s]) matches after the start in lines that\n        start with spaces. Starting .* in an assertion is no longer taken as an\n        indication of matching at the start (or after a newline).\n\n16. The \"offset\" modifier in pcre2test was not being ignored (as documented)\nwhen the POSIX API was in use.\n\n17. Added --enable-fuzz-support to \"configure\", causing an non-installed\nlibrary containing a test function that can be called by fuzzers to be\ncompiled. A non-installed  binary to run the test function locally, called\npcre2fuzzcheck is also compiled.\n\n18. A pattern with PCRE2_DOTALL (/s) set but not PCRE2_NO_DOTSTAR_ANCHOR, and\nwhich started with .* inside a positive lookahead was incorrectly being\ncompiled as implicitly anchored.\n\n19. Removed all instances of \"register\" declarations, as they are considered\nobsolete these days and in any case had become very haphazard.\n\n20. Add strerror() to pcre2test for failed file opening.\n\n21. Make pcre2test -C list valgrind support when it is enabled.\n\n22. Add the use_length modifier to pcre2test.\n\n23. Fix an off-by-one bug in pcre2test for the list of names for 'get' and\n'copy' modifiers.\n\n24. Add PCRE2_CALL_CONVENTION into the prototype declarations in pcre2.h as it\nis apparently needed there as well as in the function definitions. (Why did\nnobody ask for this in PCRE1?)\n\n25. Change the _PCRE2_H and _PCRE2_UCP_H guard macros in the header files to\nPCRE2_H_IDEMPOTENT_GUARD and PCRE2_UCP_H_IDEMPOTENT_GUARD to be more standard\ncompliant and unique.\n\n26. pcre2-config --libs-posix was listing -lpcre2posix instead of\n-lpcre2-posix. Also, the CMake build process was building the library with the\nwrong name.\n\n27. In pcre2test, give some offset information for errors in hex patterns.\nThis uses the C99 formatting sequence %td, except for MSVC which doesn't\nsupport it - %lu is used instead.\n\n28. Implemented pcre2_code_copy_with_tables(), and added pushtablescopy to\npcre2test for testing it.\n\n29. Fix small memory leak in pcre2test.\n\n30. Fix out-of-bounds read for partial matching of /./ against an empty string\nwhen the newline type is CRLF.\n\n31. Fix a bug in pcre2test that caused a crash when a locale was set either in\nthe current pattern or a previous one and a wide character was matched.\n\n32. The appearance of \\p, \\P, or \\X in a substitution string when\nPCRE2_SUBSTITUTE_EXTENDED was set caused a segmentation fault (NULL\ndereference).\n\n33. If the starting offset was specified as greater than the subject length in\na call to pcre2_substitute() an out-of-bounds memory reference could occur.\n\n34. When PCRE2 was compiled to use the heap instead of the stack for recursive\ncalls to match(), a repeated minimizing caseless back reference, or a\nmaximizing one where the two cases had different numbers of code units,\nfollowed by a caseful back reference, could lose the caselessness of the first\nrepeated back reference (example: /(Z)(a)\\2{1,2}?(?-i)\\1X/i should match ZaAAZX\nbut didn't).\n\n35. When a pattern is too complicated, PCRE2 gives up trying to find a minimum\nmatching length and just records zero. Typically this happens when there are\ntoo many nested or recursive back references. If the limit was reached in\ncertain recursive cases it failed to be triggered and an internal error could\nbe the result.\n\n36. The pcre2_dfa_match() function now takes note of the recursion limit for\nthe internal recursive calls that are used for lookrounds and recursions within\nthe pattern.\n\n37. More refactoring has got rid of the internal could_be_empty_branch()\nfunction (around 400 lines of code, including comments) by keeping track of\ncould-be-emptiness as the pattern is compiled instead of scanning compiled\ngroups. (This would have been much harder before the refactoring of #3 above.)\nThis lifts a restriction on the number of branches in a group (more than about\n1100 would give \"pattern is too complicated\").\n\n38. Add the \"-ac\" command line option to pcre2test as a synonym for \"-pattern\nauto_callout\".\n\n39. In a library with Unicode support, incorrect data was compiled for a\npattern with PCRE2_UCP set without PCRE2_UTF if a class required all wide\ncharacters to match (for example, /[\\s[:^ascii:]]/).\n\n40. The callout_error modifier has been added to pcre2test to make it possible\nto return PCRE2_ERROR_CALLOUT from a callout.\n\n41. A minor change to pcre2grep: colour reset is now \"<esc>[0m\" instead of\n\"<esc>[00m\".\n\n42. The limit in the auto-possessification code that was intended to catch\noverly-complicated patterns and not spend too much time auto-possessifying was\nbeing reset too often, resulting in very long compile times for some patterns.\nNow such patterns are no longer completely auto-possessified.\n\n43. Applied Jason Hood's revised patch for RunTest.bat.\n\n44. Added a new Windows script RunGrepTest.bat, courtesy of Jason Hood.\n\n45. Minor cosmetic fix to pcre2test: move a variable that is not used under\nWindows into the \"not Windows\" code.\n\n46. Applied Jason Hood's patches to upgrade pcre2grep under Windows and tidy\nsome of the code:\n\n  * normalised the Windows condition by ensuring WIN32 is defined;\n  * enables the callout feature under Windows;\n  * adds globbing (Microsoft's implementation expands quoted args),\n    using a tweaked opendirectory;\n  * implements the is_*_tty functions for Windows;\n  * --color=always will write the ANSI sequences to file;\n  * add sequences 4 (underline works on Win10) and 5 (blink as bright\n    background, relatively standard on DOS/Win);\n  * remove the (char *) casts for the now-const strings;\n  * remove GREP_COLOUR (grep's command line allowed the 'u', but not\n    the environment), parsing GREP_COLORS instead;\n  * uses the current colour if not set, rather than black;\n  * add print_match for the undefined case;\n  * fixes a typo.\n\nIn addition, colour settings containing anything other than digits and\nsemicolon are ignored, and the colour controls are no longer output for empty\nstrings.\n\n47. Detecting patterns that are too large inside the length-measuring loop\nsaves processing ridiculously long patterns to their end.\n\n48. Ignore PCRE2_CASELESS when processing \\h, \\H, \\v, and \\V in classes as it\njust wastes time. In the UTF case it can also produce redundant entries in\nXCLASS lists caused by characters with multiple other cases and pairs of\ncharacters in the same \"not-x\" sublists.\n\n49. A pattern such as /(?=(a\\K))/ can report the end of the match being before\nits start; pcre2test was not handling this correctly when using the POSIX\ninterface (it was OK with the native interface).\n\n50. In pcre2grep, ignore all JIT compile errors. This means that pcre2grep will\ncontinue to work, falling back to interpretation if anything goes wrong with\nJIT.\n\n51. Applied patches from Christian Persch to configure.ac to make use of the\nAC_USE_SYSTEM_EXTENSIONS macro and to test for functions used by the JIT\nmodules.\n\n52. Minor fixes to pcre2grep from Jason Hood:\n    * fixed some spacing;\n    * Windows doesn't usually use single quotes, so I've added a define\n      to use appropriate quotes [in an example];\n    * LC_ALL was displayed as \"LCC_ALL\";\n    * numbers 11, 12 & 13 should end in \"th\";\n    * use double quotes in usage message.\n\n53. When autopossessifying, skip empty branches without recursion, to reduce\nstack usage for the benefit of clang with -fsanitize-address, which uses huge\nstack frames. Example pattern: /X?(R||){3335}/. Fixes oss-fuzz issue 553.\n\n54. A pattern with very many explicit back references to a group that is a long\nway from the start of the pattern could take a long time to compile because\nsearching for the referenced group in order to find the minimum length was\nbeing done repeatedly. Now up to 128 group minimum lengths are cached and the\nattempt to find a minimum length is abandoned if there is a back reference to a\ngroup whose number is greater than 128. (In that case, the pattern is so\ncomplicated that this optimization probably isn't worth it.) This fixes\noss-fuzz issue 557.\n\n55. Issue 32 for 10.22 below was not correctly fixed. If pcre2grep in multiline\nmode with --only-matching matched several lines, it restarted scanning at the\nnext line instead of moving on to the end of the matched string, which can be\nseveral lines after the start.\n\n56. Applied Jason Hood's new patch for RunGrepTest.bat that updates it in line\nwith updates to the non-Windows version.\n\n\n\nVersion 10.22 29-July-2016\n--------------------------\n\n1. Applied Jason Hood's patches to RunTest.bat and testdata/wintestoutput3\nto fix problems with running the tests under Windows.\n\n2. Implemented a facility for quoting literal characters within hexadecimal\npatterns in pcre2test, to make it easier to create patterns with just a few\nnon-printing characters.\n\n3. Binary zeros are not supported in pcre2test input files. It now detects them\nand gives an error.\n\n4. Updated the valgrind parameters in RunTest: (a) changed smc-check=all to\nsmc-check=all-non-file; (b) changed obj:* in the suppression file to obj:??? so\nthat it matches only unknown objects.\n\n5. Updated the maintenance script maint/ManyConfigTests to make it easier to\nselect individual groups of tests.\n\n6. When the POSIX wrapper function regcomp() is called, the REG_NOSUB option\nused to set PCRE2_NO_AUTO_CAPTURE when calling pcre2_compile(). However, this\ndisables the use of back references (and subroutine calls), which are supported\nby other implementations of regcomp() with RE_NOSUB. Therefore, REG_NOSUB no\nlonger causes PCRE2_NO_AUTO_CAPTURE to be set, though it still ignores nmatch\nand pmatch when regexec() is called.\n\n7. Because of 6 above, pcre2test has been modified with a new modifier called\nposix_nosub, to call regcomp() with REG_NOSUB. Previously the no_auto_capture\nmodifier had this effect. That option is now ignored when the POSIX API is in\nuse.\n\n8. Minor tidies to the pcre2demo.c sample program, including more comments\nabout its 8-bit-ness.\n\n9. Detect unmatched closing parentheses and give the error in the pre-scan\ninstead of later. Previously the pre-scan carried on and could give a\nmisleading incorrect error message. For example, /(?J)(?'a'))(?'a')/ gave a\nmessage about invalid duplicate group names.\n\n10. It has happened that pcre2test was accidentally linked with another POSIX\nregex library instead of libpcre2-posix. In this situation, a call to regcomp()\n(in the other library) may succeed, returning zero, but of course putting its\nown data into the regex_t block. In one example the re_pcre2_code field was\nleft as NULL, which made pcre2test think it had not got a compiled POSIX regex,\nso it treated the next line as another pattern line, resulting in a confusing\nerror message. A check has been added to pcre2test to see if the data returned\nfrom a successful call of regcomp() are valid for PCRE2's regcomp(). If they\nare not, an error message is output and the pcre2test run is abandoned. The\nmessage points out the possibility of a mis-linking. Hopefully this will avoid\nsome head-scratching the next time this happens.\n\n11. A pattern such as /(?<=((?C)0))/, which has a callout inside a lookbehind\nassertion, caused pcre2test to output a very large number of spaces when the\ncallout was taken, making the program appearing to loop.\n\n12. A pattern that included (*ACCEPT) in the middle of a sufficiently deeply\nnested set of parentheses of sufficient size caused an overflow of the\ncompiling workspace (which was diagnosed, but of course is not desirable).\n\n13. Detect missing closing parentheses during the pre-pass for group\nidentification.\n\n14. Changed some integer variable types and put in a number of casts, following\na report of compiler warnings from Visual Studio 2013 and a few tests with\ngcc's -Wconversion (which still throws up a lot).\n\n15. Implemented pcre2_code_copy(), and added pushcopy and #popcopy to pcre2test\nfor testing it.\n\n16. Change 66 for 10.21 introduced the use of snprintf() in PCRE2's version of\nregerror(). When the error buffer is too small, my version of snprintf() puts a\nbinary zero in the final byte. Bug #1801 seems to show that other versions do\nnot do this, leading to bad output from pcre2test when it was checking for\nbuffer overflow. It no longer assumes a binary zero at the end of a too-small\nregerror() buffer.\n\n17. Fixed typo (\"&&\" for \"&\") in pcre2_study(). Fortunately, this could not\nactually affect anything, by sheer luck.\n\n18. Two minor fixes for MSVC compilation: (a) removal of apparently incorrect\n\"const\" qualifiers in pcre2test and (b) defining snprintf as _snprintf for\nolder MSVC compilers. This has been done both in src/pcre2_internal.h for most\nof the library, and also in src/pcre2posix.c, which no longer includes\npcre2_internal.h (see 24 below).\n\n19. Applied Chris Wilson's patch (Bugzilla #1681) to CMakeLists.txt for MSVC\nstatic compilation. Subsequently applied Chris Wilson's second patch, putting\nthe first patch under a new option instead of being unconditional when\nPCRE_STATIC is set.\n\n20. Updated pcre2grep to set stdout as binary when run under Windows, so as not\nto convert \\r\\n at the ends of reflected lines into \\r\\r\\n. This required\nensuring that other output that is written to stdout (e.g. file names) uses the\nappropriate line terminator: \\r\\n for Windows, \\n otherwise.\n\n21. When a line is too long for pcre2grep's internal buffer, show the maximum\nlength in the error message.\n\n22. Added support for string callouts to pcre2grep (Zoltan's patch with PH\nadditions).\n\n23. RunTest.bat was missing a \"set type\" line for test 22.\n\n24. The pcre2posix.c file was including pcre2_internal.h, and using some\n\"private\" knowledge of the data structures. This is unnecessary; the code has\nbeen re-factored and no longer includes pcre2_internal.h.\n\n25. A racing condition is fixed in JIT reported by Mozilla.\n\n26. Minor code refactor to avoid \"array subscript is below array bounds\"\ncompiler warning.\n\n27. Minor code refactor to avoid \"left shift of negative number\" warning.\n\n28. Add a bit more sanity checking to pcre2_serialize_decode() and document\nthat it expects trusted data.\n\n29. Fix typo in pcre2_jit_test.c\n\n30. Due to an oversight, pcre2grep was not making use of JIT when available.\nThis is now fixed.\n\n31. The RunGrepTest script is updated to use the valgrind suppressions file\nwhen testing with JIT under valgrind (compare 10.21/51 below). The suppressions\nfile is updated so that is now the same as for PCRE1: it suppresses the\nMemcheck warnings Addr16 and Cond in unknown objects (that is, JIT-compiled\ncode). Also changed smc-check=all to smc-check=all-non-file as was done for\nRunTest (see 4 above).\n\n32. Implemented the PCRE2_NO_JIT option for pcre2_match().\n\n33. Fix typo that gave a compiler error when JIT not supported.\n\n34. Fix comment describing the returns from find_fixedlength().\n\n35. Fix potential negative index in pcre2test.\n\n36. Calls to pcre2_get_error_message() with error numbers that are never\nreturned by PCRE2 functions were returning empty strings. Now the error code\nPCRE2_ERROR_BADDATA is returned. A facility has been added to pcre2test to\nshow the texts for given error numbers (i.e. to call pcre2_get_error_message()\nand display what it returns) and a few representative error codes are now\nchecked in RunTest.\n\n37. Added \"&& !defined(__INTEL_COMPILER)\" to the test for __GNUC__ in\npcre2_match.c, in anticipation that this is needed for the same reason it was\nrecently added to pcrecpp.cc in PCRE1.\n\n38. Using -o with -M in pcre2grep could cause unnecessary repeated output when\nthe match extended over a line boundary, as it tried to find more matches \"on\nthe same line\" - but it was already over the end.\n\n39. Allow \\C in lookbehinds and DFA matching in UTF-32 mode (by converting it\nto the same code as '.' when PCRE2_DOTALL is set).\n\n40. Fix two clang compiler warnings in pcre2test when only one code unit width\nis supported.\n\n41. Upgrade RunTest to automatically re-run test 2 with a large (64MiB) stack\nif it fails when running the interpreter with a 16MiB stack (and if changing\nthe stack size via pcre2test is possible). This avoids having to manually set a\nlarge stack size when testing with clang.\n\n42. Fix register overwite in JIT when SSE2 acceleration is enabled.\n\n43. Detect integer overflow in pcre2test pattern and data repetition counts.\n\n44. In pcre2test, ignore \"allcaptures\" after DFA matching.\n\n45. Fix unaligned accesses on x86. Patch by Marc Mutz.\n\n46. Fix some more clang compiler warnings.\n\n\nVersion 10.21 12-January-2016\n-----------------------------\n\n1. Improve matching speed of patterns starting with + or * in JIT.\n\n2. Use memchr() to find the first character in an unanchored match in 8-bit\nmode in the interpreter. This gives a significant speed improvement.\n\n3. Removed a redundant copy of the opcode_possessify table in the\npcre2_auto_possessify.c source.\n\n4. Fix typos in dftables.c for z/OS.\n\n5. Change 36 for 10.20 broke the handling of [[:>:]] and [[:<:]] in that\nprocessing them could involve a buffer overflow if the following character was\nan opening parenthesis.\n\n6. Change 36 for 10.20 also introduced a bug in processing this pattern:\n/((?x)(*:0))#(?'/. Specifically: if a setting of (?x) was followed by a (*MARK)\nsetting (which (*:0) is), then (?x) did not get unset at the end of its group\nduring the scan for named groups, and hence the external # was incorrectly\ntreated as a comment and the invalid (?' at the end of the pattern was not\ndiagnosed. This caused a buffer overflow during the real compile. This bug was\ndiscovered by Karl Skomski with the LLVM fuzzer.\n\n7. Moved the pcre2_find_bracket() function from src/pcre2_compile.c into its\nown source module to avoid a circular dependency between src/pcre2_compile.c\nand src/pcre2_study.c\n\n8. A callout with a string argument containing an opening square bracket, for\nexample /(?C$[$)(?<]/, was incorrectly processed and could provoke a buffer\noverflow. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n9. The handling of callouts during the pre-pass for named group identification\nhas been tightened up.\n\n10. The quantifier {1} can be ignored, whether greedy, non-greedy, or\npossessive. This is a very minor optimization.\n\n11. A possessively repeated conditional group that could match an empty string,\nfor example, /(?(R))*+/, was incorrectly compiled.\n\n12. The Unicode tables have been updated to Unicode 8.0.0 (thanks to Christian\nPersch).\n\n13. An empty comment (?#) in a pattern was incorrectly processed and could\nprovoke a buffer overflow. This bug was discovered by Karl Skomski with the\nLLVM fuzzer.\n\n14. Fix infinite recursion in the JIT compiler when certain patterns such as\n/(?:|a|){100}x/ are analysed.\n\n15. Some patterns with character classes involving [: and \\\\ were incorrectly\ncompiled and could cause reading from uninitialized memory or an incorrect\nerror diagnosis. Examples are: /[[:\\\\](?<[::]/ and /[[:\\\\](?'abc')[a:]. The\nfirst of these bugs was discovered by Karl Skomski with the LLVM fuzzer.\n\n16. Pathological patterns containing many nested occurrences of [: caused\npcre2_compile() to run for a very long time. This bug was found by the LLVM\nfuzzer.\n\n17. A missing closing parenthesis for a callout with a string argument was not\nbeing diagnosed, possibly leading to a buffer overflow. This bug was found by\nthe LLVM fuzzer.\n\n18. A conditional group with only one branch has an implicit empty alternative\nbranch and must therefore be treated as potentially matching an empty string.\n\n19. If (?R was followed by - or + incorrect behaviour happened instead of a\ndiagnostic. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n20. Another bug that was introduced by change 36 for 10.20: conditional groups\nwhose condition was an assertion preceded by an explicit callout with a string\nargument might be incorrectly processed, especially if the string contained \\Q.\nThis bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n21. Compiling PCRE2 with the sanitize options of clang showed up a number of\nvery pedantic coding infelicities and a buffer overflow while checking a UTF-8\nstring if the final multi-byte UTF-8 character was truncated.\n\n22. For Perl compatibility in EBCDIC environments, ranges such as a-z in a\nclass, where both values are literal letters in the same case, omit the\nnon-letter EBCDIC code points within the range.\n\n23. Finding the minimum matching length of complex patterns with back\nreferences and/or recursions can take a long time. There is now a cut-off that\ngives up trying to find a minimum length when things get too complex.\n\n24. An optimization has been added that speeds up finding the minimum matching\nlength for patterns containing repeated capturing groups or recursions.\n\n25. If a pattern contained a back reference to a group whose number was\nduplicated as a result of appearing in a (?|...) group, the computation of the\nminimum matching length gave a wrong result, which could cause incorrect \"no\nmatch\" errors. For such patterns, a minimum matching length cannot at present\nbe computed.\n\n26. Added a check for integer overflow in conditions (?(<digits>) and\n(?(R<digits>). This omission was discovered by Karl Skomski with the LLVM\nfuzzer.\n\n27. Fixed an issue when \\p{Any} inside an xclass did not read the current\ncharacter.\n\n28. If pcre2grep was given the -q option with -c or -l, or when handling a\nbinary file, it incorrectly wrote output to stdout.\n\n29. The JIT compiler did not restore the control verb head in case of *THEN\ncontrol verbs. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n30. The way recursive references such as (?3) are compiled has been re-written\nbecause the old way was the cause of many issues. Now, conversion of the group\nnumber into a pattern offset does not happen until the pattern has been\ncompletely compiled. This does mean that detection of all infinitely looping\nrecursions is postponed till match time. In the past, some easy ones were\ndetected at compile time. This re-writing was done in response to yet another\nbug found by the LLVM fuzzer.\n\n31. A test for a back reference to a non-existent group was missing for items\nsuch as \\987. This caused incorrect code to be compiled. This issue was found\nby Karl Skomski with a custom LLVM fuzzer.\n\n32. Error messages for syntax errors following \\g and \\k were giving inaccurate\noffsets in the pattern.\n\n33. Improve the performance of starting single character repetitions in JIT.\n\n34. (*LIMIT_MATCH=) now gives an error instead of setting the value to 0.\n\n35. Error messages for syntax errors in *LIMIT_MATCH and *LIMIT_RECURSION now\ngive the right offset instead of zero.\n\n36. The JIT compiler should not check repeats after a {0,1} repeat byte code.\nThis issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n37. The JIT compiler should restore the control chain for empty possessive\nrepeats. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n38. A bug which was introduced by the single character repetition optimization\nwas fixed.\n\n39. Match limit check added to recursion. This issue was found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n40. Arrange for the UTF check in pcre2_match() and pcre2_dfa_match() to look\nonly at the part of the subject that is relevant when the starting offset is\nnon-zero.\n\n41. Improve first character match in JIT with SSE2 on x86.\n\n42. Fix two assertion fails in JIT. These issues were found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n43. Correct the setting of CMAKE_C_FLAGS in CMakeLists.txt (patch from Roy Ivy\nIII).\n\n44. Fix bug in RunTest.bat for new test 14, and adjust the script for the added\ntest (there are now 20 in total).\n\n45. Fixed a corner case of range optimization in JIT.\n\n46. Add the ${*MARK} facility to pcre2_substitute().\n\n47. Modifier lists in pcre2test were splitting at spaces without the required\ncommas.\n\n48. Implemented PCRE2_ALT_VERBNAMES.\n\n49. Fixed two issues in JIT. These were found by Karl Skomski with a custom\nLLVM fuzzer.\n\n50. The pcre2test program has been extended by adding the #newline_default\ncommand. This has made it possible to run the standard tests when PCRE2 is\ncompiled with either CR or CRLF as the default newline convention. As part of\nthis work, the new command was added to several test files and the testing\nscripts were modified. The pcre2grep tests can now also be run when there is no\nLF in the default newline convention.\n\n51. The RunTest script has been modified so that, when JIT is used and valgrind\nis specified, a valgrind suppressions file is set up to ignore \"Invalid read of\nsize 16\" errors because these are false positives when the hardware supports\nthe SSE2 instruction set.\n\n52. It is now possible to have comment lines amid the subject strings in\npcre2test (and perltest.sh) input.\n\n53. Implemented PCRE2_USE_OFFSET_LIMIT and pcre2_set_offset_limit().\n\n54. Add the null_context modifier to pcre2test so that calling pcre2_compile()\nand the matching functions with NULL contexts can be tested.\n\n55. Implemented PCRE2_SUBSTITUTE_EXTENDED.\n\n56. In a character class such as [\\W\\p{Any}] where both a negative-type escape\n(\"not a word character\") and a property escape were present, the property\nescape was being ignored.\n\n57. Fixed integer overflow for patterns whose minimum matching length is very,\nvery large.\n\n58. Implemented --never-backslash-C.\n\n59. Change 55 above introduced a bug by which certain patterns provoked the\nerroneous error \"\\ at end of pattern\".\n\n60. The special sequences [[:<:]] and [[:>:]] gave rise to incorrect compiling\nerrors or other strange effects if compiled in UCP mode. Found with libFuzzer\nand AddressSanitizer.\n\n61. Whitespace at the end of a pcre2test pattern line caused a spurious error\nmessage if there were only single-character modifiers. It should be ignored.\n\n62. The use of PCRE2_NO_AUTO_CAPTURE could cause incorrect compilation results\nor segmentation errors for some patterns. Found with libFuzzer and\nAddressSanitizer.\n\n63. Very long names in (*MARK) or (*THEN) etc. items could provoke a buffer\noverflow.\n\n64. Improve error message for overly-complicated patterns.\n\n65. Implemented an optional replication feature for patterns in pcre2test, to\nmake it easier to test long repetitive patterns. The tests for 63 above are\nconverted to use the new feature.\n\n66. In the POSIX wrapper, if regerror() was given too small a buffer, it could\nmisbehave.\n\n67. In pcre2_substitute() in UTF mode, the UTF validity check on the\nreplacement string was happening before the length setting when the replacement\nstring was zero-terminated.\n\n68. In pcre2_substitute() in UTF mode, PCRE2_NO_UTF_CHECK can be set for the\nsecond and subsequent calls to pcre2_match().\n\n69. There was no check for integer overflow for a replacement group number in\npcre2_substitute(). An added check for a number greater than the largest group\nnumber in the pattern means this is not now needed.\n\n70. The PCRE2-specific VERSION condition didn't work correctly if only one\ndigit was given after the decimal point, or if more than two digits were given.\nIt now works with one or two digits, and gives a compile time error if more are\ngiven.\n\n71. In pcre2_substitute() there was the possibility of reading one code unit\nbeyond the end of the replacement string.\n\n72. The code for checking a subject's UTF-32 validity for a pattern with a\nlookbehind involved an out-of-bounds pointer, which could potentially cause\ntrouble in some environments.\n\n73. The maximum lookbehind length was incorrectly calculated for patterns such\nas /(?<=(a)(?-1))x/ which have a recursion within a backreference.\n\n74. Give an error if a lookbehind assertion is longer than 65535 code units.\n\n75. Give an error in pcre2_substitute() if a match ends before it starts (as a\nresult of the use of \\K).\n\n76. Check the length of subpattern names and the names in (*MARK:xx) etc.\ndynamically to avoid the possibility of integer overflow.\n\n77. Implement pcre2_set_max_pattern_length() so that programs can restrict the\nsize of patterns that they are prepared to handle.\n\n78. (*NO_AUTO_POSSESS) was not working.\n\n79. Adding group information caching improves the speed of compiling when\nchecking whether a group has a fixed length and/or could match an empty string,\nespecially when recursion or subroutine calls are involved. However, this\ncannot be used when (?| is present in the pattern because the same number may\nbe used for groups of different sizes. To catch runaway patterns in this\nsituation, counts have been introduced to the functions that scan for empty\nbranches or compute fixed lengths.\n\n80. Allow for the possibility of the size of the nest_save structure not being\na factor of the size of the compiling workspace (it currently is).\n\n81. Check for integer overflow in minimum length calculation and cap it at\n65535.\n\n82. Small optimizations in code for finding the minimum matching length.\n\n83. Lock out configuring for EBCDIC with non-8-bit libraries.\n\n84. Test for error code <= 0 in regerror().\n\n85. Check for too many replacements (more than INT_MAX) in pcre2_substitute().\n\n86. Avoid the possibility of computing with an out-of-bounds pointer (though\nnot dereferencing it) while handling lookbehind assertions.\n\n87. Failure to get memory for the match data in regcomp() is now given as a\nregcomp() error instead of waiting for regexec() to pick it up.\n\n88. In pcre2_substitute(), ensure that CRLF is not split when it is a valid\nnewline sequence.\n\n89. Paranoid check in regcomp() for bad error code from pcre2_compile().\n\n90. Run test 8 (internal offsets and code sizes) for link sizes 3 and 4 as well\nas for link size 2.\n\n91. Document that JIT has a limit on pattern size, and give more information\nabout JIT compile failures in pcre2test.\n\n92. Implement PCRE2_INFO_HASBACKSLASHC.\n\n93. Re-arrange valgrind support code in pcre2test to avoid spurious reports\nwith JIT (possibly caused by SSE2?).\n\n94. Support offset_limit in JIT.\n\n95. A sequence such as [[:punct:]b] that is, a POSIX character class followed\nby a single ASCII character in a class item, was incorrectly compiled in UCP\nmode. The POSIX class got lost, but only if the single character followed it.\n\n96. [:punct:] in UCP mode was matching some characters in the range 128-255\nthat should not have been matched.\n\n97. If [:^ascii:] or [:^xdigit:] are present in a non-negated class, all\ncharacters with code points greater than 255 are in the class. When a Unicode\nproperty was also in the class (if PCRE2_UCP is set, escapes such as \\w are\nturned into Unicode properties), wide characters were not correctly handled,\nand could fail to match.\n\n98. In pcre2test, make the \"startoffset\" modifier a synonym of \"offset\",\nbecause it sets the \"startoffset\" parameter for pcre2_match().\n\n99. If PCRE2_AUTO_CALLOUT was set on a pattern that had a (?# comment between\nan item and its qualifier (for example, A(?#comment)?B) pcre2_compile()\nmisbehaved. This bug was found by the LLVM fuzzer.\n\n100. The error for an invalid UTF pattern string always gave the code unit\noffset as zero instead of where the invalidity was found.\n\n101. Further to 97 above, negated classes such as [^[:^ascii:]\\d] were also not\nworking correctly in UCP mode.\n\n102. Similar to 99 above, if an isolated \\E was present between an item and its\nqualifier when PCRE2_AUTO_CALLOUT was set, pcre2_compile() misbehaved. This bug\nwas found by the LLVM fuzzer.\n\n103. The POSIX wrapper function regexec() crashed if the option REG_STARTEND\nwas set when the pmatch argument was NULL. It now returns REG_INVARG.\n\n104. Allow for up to 32-bit numbers in the ordin() function in pcre2grep.\n\n105. An empty \\Q\\E sequence between an item and its qualifier caused\npcre2_compile() to misbehave when auto callouts were enabled. This bug\nwas found by the LLVM fuzzer.\n\n106. If both PCRE2_ALT_VERBNAMES and PCRE2_EXTENDED were set, and a (*MARK) or\nother verb \"name\" ended with whitespace immediately before the closing\nparenthesis, pcre2_compile() misbehaved. Example: /(*:abc )/, but only when\nboth those options were set.\n\n107. In a number of places pcre2_compile() was not handling NULL characters\ncorrectly, and pcre2test with the \"bincode\" modifier was not always correctly\ndisplaying fields containing NULLS:\n\n   (a) Within /x extended #-comments\n   (b) Within the \"name\" part of (*MARK) and other *verbs\n   (c) Within the text argument of a callout\n\n108. If a pattern that was compiled with PCRE2_EXTENDED started with white\nspace or a #-type comment that was followed by (?-x), which turns off\nPCRE2_EXTENDED, and there was no subsequent (?x) to turn it on again,\npcre2_compile() assumed that (?-x) applied to the whole pattern and\nconsequently mis-compiled it. This bug was found by the LLVM fuzzer. The fix\nfor this bug means that a setting of any of the (?imsxJU) options at the start\nof a pattern is no longer transferred to the options that are returned by\nPCRE2_INFO_ALLOPTIONS. In fact, this was an anachronism that should have\nchanged when the effects of those options were all moved to compile time.\n\n109. An escaped closing parenthesis in the \"name\" part of a (*verb) when\nPCRE2_ALT_VERBNAMES was set caused pcre2_compile() to malfunction. This bug\nwas found by the LLVM fuzzer.\n\n110. Implemented PCRE2_SUBSTITUTE_UNSET_EMPTY, and updated pcre2test to make it\npossible to test it.\n\n111. \"Harden\" pcre2test against ridiculously large values in modifiers and\ncommand line arguments.\n\n112. Implemented PCRE2_SUBSTITUTE_UNKNOWN_UNSET and PCRE2_SUBSTITUTE_OVERFLOW_\nLENGTH.\n\n113. Fix printing of *MARK names that contain binary zeroes in pcre2test.\n\n\nVersion 10.20 30-June-2015\n--------------------------\n\n1. Callouts with string arguments have been added.\n\n2. Assertion code generator in JIT has been optimized.\n\n3. The invalid pattern (?(?C) has a missing assertion condition at the end. The\npcre2_compile() function read past the end of the input before diagnosing an\nerror. This bug was discovered by the LLVM fuzzer.\n\n4. Implemented pcre2_callout_enumerate().\n\n5. Fix JIT compilation of conditional blocks whose assertion is converted to\n(*FAIL). E.g: /(?(?!))/.\n\n6. The pattern /(?(?!)^)/ caused references to random memory. This bug was\ndiscovered by the LLVM fuzzer.\n\n7. The assertion (?!) is optimized to (*FAIL). This was not handled correctly\nwhen this assertion was used as a condition, for example (?(?!)a|b). In\npcre2_match() it worked by luck; in pcre2_dfa_match() it gave an incorrect\nerror about an unsupported item.\n\n8. For some types of pattern, for example /Z*(|d*){216}/, the auto-\npossessification code could take exponential time to complete. A recursion\ndepth limit of 1000 has been imposed to limit the resources used by this\noptimization. This infelicity was discovered by the LLVM fuzzer.\n\n9. A pattern such as /(*UTF)[\\S\\V\\H]/, which contains a negated special class\nsuch as \\S in non-UCP mode, explicit wide characters (> 255) can be ignored\nbecause \\S ensures they are all in the class. The code for doing this was\ninteracting badly with the code for computing the amount of space needed to\ncompile the pattern, leading to a buffer overflow. This bug was discovered by\nthe LLVM fuzzer.\n\n10. A pattern such as /((?2)+)((?1))/ which has mutual recursion nested inside\nother kinds of group caused stack overflow at compile time. This bug was\ndiscovered by the LLVM fuzzer.\n\n11. A pattern such as /(?1)(?#?'){8}(a)/ which had a parenthesized comment\nbetween a subroutine call and its quantifier was incorrectly compiled, leading\nto buffer overflow or other errors. This bug was discovered by the LLVM fuzzer.\n\n12. The illegal pattern /(?(?<E>.*!.*)?)/ was not being diagnosed as missing an\nassertion after (?(. The code was failing to check the character after (?(?<\nfor the ! or = that would indicate a lookbehind assertion. This bug was\ndiscovered by the LLVM fuzzer.\n\n13. A pattern such as /X((?2)()*+){2}+/ which has a possessive quantifier with\na fixed maximum following a group that contains a subroutine reference was\nincorrectly compiled and could trigger buffer overflow. This bug was discovered\nby the LLVM fuzzer.\n\n14. Negative relative recursive references such as (?-7) to non-existent\nsubpatterns were not being diagnosed and could lead to unpredictable behaviour.\nThis bug was discovered by the LLVM fuzzer.\n\n15. The bug fixed in 14 was due to an integer variable that was unsigned when\nit should have been signed. Some other \"int\" variables, having been checked,\nhave either been changed to uint32_t or commented as \"must be signed\".\n\n16. A mutual recursion within a lookbehind assertion such as (?<=((?2))((?1)))\ncaused a stack overflow instead of the diagnosis of a non-fixed length\nlookbehind assertion. This bug was discovered by the LLVM fuzzer.\n\n17. The use of \\K in a positive lookbehind assertion in a non-anchored pattern\n(e.g. /(?<=\\Ka)/) could make pcre2grep loop.\n\n18. There was a similar problem to 17 in pcre2test for global matches, though\nthe code there did catch the loop.\n\n19. If a greedy quantified \\X was preceded by \\C in UTF mode (e.g. \\C\\X*),\nand a subsequent item in the pattern caused a non-match, backtracking over the\nrepeated \\X did not stop, but carried on past the start of the subject, causing\nreference to random memory and/or a segfault. There were also some other cases\nwhere backtracking after \\C could crash. This set of bugs was discovered by the\nLLVM fuzzer.\n\n20. The function for finding the minimum length of a matching string could take\na very long time if mutual recursion was present many times in a pattern, for\nexample, /((?2){73}(?2))((?1))/. A better mutual recursion detection method has\nbeen implemented. This infelicity was discovered by the LLVM fuzzer.\n\n21. Implemented PCRE2_NEVER_BACKSLASH_C.\n\n22. The feature for string replication in pcre2test could read from freed\nmemory if the replication required a buffer to be extended, and it was not\nworking properly in 16-bit and 32-bit modes. This issue was discovered by a\nfuzzer: see http://lcamtuf.coredump.cx/afl/.\n\n23. Added the PCRE2_ALT_CIRCUMFLEX option.\n\n24. Adjust the treatment of \\8 and \\9 to be the same as the current Perl\nbehaviour.\n\n25. Static linking against the PCRE2 library using the pkg-config module was\nfailing on missing pthread symbols.\n\n26. If a group that contained a recursive back reference also contained a\nforward reference subroutine call followed by a non-forward-reference\nsubroutine call, for example /.((?2)(?R)\\1)()/, pcre2_compile() failed to\ncompile correct code, leading to undefined behaviour or an internally detected\nerror. This bug was discovered by the LLVM fuzzer.\n\n27. Quantification of certain items (e.g. atomic back references) could cause\nincorrect code to be compiled when recursive forward references were involved.\nFor example, in this pattern: /(?1)()((((((\\1++))\\x85)+)|))/. This bug was\ndiscovered by the LLVM fuzzer.\n\n28. A repeated conditional group whose condition was a reference by name caused\na buffer overflow if there was more than one group with the given name. This\nbug was discovered by the LLVM fuzzer.\n\n29. A recursive back reference by name within a group that had the same name as\nanother group caused a buffer overflow. For example: /(?J)(?'d'(?'d'\\g{d}))/.\nThis bug was discovered by the LLVM fuzzer.\n\n30. A forward reference by name to a group whose number is the same as the\ncurrent group, for example in this pattern: /(?|(\\k'Pm')|(?'Pm'))/, caused a\nbuffer overflow at compile time. This bug was discovered by the LLVM fuzzer.\n\n31. Fix -fsanitize=undefined warnings for left shifts of 1 by 31 (it treats 1\nas an int; fixed by writing it as 1u).\n\n32. Fix pcre2grep compile when -std=c99 is used with gcc, though it still gives\na warning for \"fileno\" unless -std=gnu99 us used.\n\n33. A lookbehind assertion within a set of mutually recursive subpatterns could\nprovoke a buffer overflow. This bug was discovered by the LLVM fuzzer.\n\n34. Give an error for an empty subpattern name such as (?'').\n\n35. Make pcre2test give an error if a pattern that follows #forbud_utf contains\n\\P, \\p, or \\X.\n\n36. The way named subpatterns are handled has been refactored. There is now a\npre-pass over the regex which does nothing other than identify named\nsubpatterns and count the total captures. This means that information about\nnamed patterns is known before the rest of the compile. In particular, it means\nthat forward references can be checked as they are encountered. Previously, the\ncode for handling forward references was contorted and led to several errors in\ncomputing the memory requirements for some patterns, leading to buffer\noverflows.\n\n37. There was no check for integer overflow in subroutine calls such as (?123).\n\n38. The table entry for \\l in EBCDIC environments was incorrect, leading to its\nbeing treated as a literal 'l' instead of causing an error.\n\n39. If a non-capturing group containing a conditional group that could match\nan empty string was repeated, it was not identified as matching an empty string\nitself. For example: /^(?:(?(1)x|)+)+$()/.\n\n40. In an EBCDIC environment, pcretest was mishandling the escape sequences\n\\a and \\e in test subject lines.\n\n41. In an EBCDIC environment, \\a in a pattern was converted to the ASCII\ninstead of the EBCDIC value.\n\n42. The handling of \\c in an EBCDIC environment has been revised so that it is\nnow compatible with the specification in Perl's perlebcdic page.\n\n43. Single character repetition in JIT has been improved. 20-30% speedup\nwas achieved on certain patterns.\n\n44. The EBCDIC character 0x41 is a non-breaking space, equivalent to 0xa0 in\nASCII/Unicode. This has now been added to the list of characters that are\nrecognized as white space in EBCDIC.\n\n45. When PCRE2 was compiled without Unicode support, the use of \\p and \\P gave\nan error (correctly) when used outside a class, but did not give an error\nwithin a class.\n\n46. \\h within a class was incorrectly compiled in EBCDIC environments.\n\n47. JIT should return with error when the compiled pattern requires\nmore stack space than the maximum.\n\n48. Fixed a memory leak in pcre2grep when a locale is set.\n\n\nVersion 10.10 06-March-2015\n---------------------------\n\n1. When a pattern is compiled, it remembers the highest back reference so that\nwhen matching, if the ovector is too small, extra memory can be obtained to\nuse instead. A conditional subpattern whose condition is a check on a capture\nhaving happened, such as, for example in the pattern /^(?:(a)|b)(?(1)A|B)/, is\nanother kind of back reference, but it was not setting the highest\nbackreference number. This mattered only if pcre2_match() was called with an\novector that was too small to hold the capture, and there was no other kind of\nback reference (a situation which is probably quite rare). The effect of the\nbug was that the condition was always treated as FALSE when the capture could\nnot be consulted, leading to a incorrect behaviour by pcre2_match(). This bug\nhas been fixed.\n\n2. Functions for serialization and deserialization of sets of compiled patterns\nhave been added.\n\n3. The value that is returned by PCRE2_INFO_SIZE has been corrected to remove\nexcess code units at the end of the data block that may occasionally occur if\nthe code for calculating the size over-estimates. This change stops the\nserialization code copying uninitialized data, to which valgrind objects. The\ndocumentation of PCRE2_INFO_SIZE was incorrect in stating that the size did not\ninclude the general overhead. This has been corrected.\n\n4. All code units in every slot in the table of group names are now set, again\nin order to avoid accessing uninitialized data when serializing.\n\n5. The (*NO_JIT) feature is implemented.\n\n6. If a bug that caused pcre2_compile() to use more memory than allocated was\ntriggered when using valgrind, the code in (3) above passed a stupidly large\nvalue to valgrind. This caused a crash instead of an \"internal error\" return.\n\n7. A reference to a duplicated named group (either a back reference or a test\nfor being set in a conditional) that occurred in a part of the pattern where\nPCRE2_DUPNAMES was not set caused the amount of memory needed for the pattern\nto be incorrectly calculated, leading to overwriting.\n\n8. A mutually recursive set of back references such as (\\2)(\\1) caused a\nsegfault at compile time (while trying to find the minimum matching length).\nThe infinite loop is now broken (with the minimum length unset, that is, zero).\n\n9. If an assertion that was used as a condition was quantified with a minimum\nof zero, matching went wrong. In particular, if the whole group had unlimited\nrepetition and could match an empty string, a segfault was likely. The pattern\n(?(?=0)?)+ is an example that caused this. Perl allows assertions to be\nquantified, but not if they are being used as conditions, so the above pattern\nis faulted by Perl. PCRE2 has now been changed so that it also rejects such\npatterns.\n\n10. The error message for an invalid quantifier has been changed from \"nothing\nto repeat\" to \"quantifier does not follow a repeatable item\".\n\n11. If a bad UTF string is compiled with NO_UTF_CHECK, it may succeed, but\nscanning the compiled pattern in subsequent auto-possessification can get out\nof step and lead to an unknown opcode. Previously this could have caused an\ninfinite loop. Now it generates an \"internal error\" error. This is a tidyup,\nnot a bug fix; passing bad UTF with NO_UTF_CHECK is documented as having an\nundefined outcome.\n\n12. A UTF pattern containing a \"not\" match of a non-ASCII character and a\nsubroutine reference could loop at compile time. Example: /[^\\xff]((?1))/.\n\n13. The locale test (RunTest 3) has been upgraded. It now checks that a locale\nthat is found in the output of \"locale -a\" can actually be set by pcre2test\nbefore it is accepted. Previously, in an environment where a locale was listed\nbut would not set (an example does exist), the test would \"pass\" without\nactually doing anything. Also the fr_CA locale has been added to the list of\nlocales that can be used.\n\n14. Fixed a bug in pcre2_substitute(). If a replacement string ended in a\ncapturing group number without parentheses, the last character was incorrectly\nliterally included at the end of the replacement string.\n\n15. A possessive capturing group such as (a)*+ with a minimum repeat of zero\nfailed to allow the zero-repeat case if pcre2_match() was called with an\novector too small to capture the group.\n\n16. Improved error message in pcre2test when setting the stack size (-S) fails.\n\n17. Fixed two bugs in CMakeLists.txt: (1) Some lines had got lost in the\ntransfer from PCRE1, meaning that CMake configuration failed if \"build tests\"\nwas selected. (2) The file src/pcre2_serialize.c had not been added to the list\nof PCRE2 sources, which caused a failure to build pcre2test.\n\n18. Fixed typo in pcre2_serialize.c (DECL instead of DEFN) that causes problems\nonly on Windows.\n\n19. Use binary input when reading back saved serialized patterns in pcre2test.\n\n20. Added RunTest.bat for running the tests under Windows.\n\n21. \"make distclean\" was not removing config.h, a file that may be created for\nuse with CMake.\n\n22. A pattern such as \"((?2){0,1999}())?\", which has a group containing a\nforward reference repeated a large (but limited) number of times within a\nrepeated outer group that has a zero minimum quantifier, caused incorrect code\nto be compiled, leading to the error \"internal error: previously-checked\nreferenced subpattern not found\" when an incorrect memory address was read.\nThis bug was reported as \"heap overflow\", discovered by Kai Lu of Fortinet's\nFortiGuard Labs. (Added 24-March-2015: CVE-2015-2325 was given to this.)\n\n23. A pattern such as \"((?+1)(\\1))/\" containing a forward reference subroutine\ncall within a group that also contained a recursive back reference caused\nincorrect code to be compiled. This bug was reported as \"heap overflow\",\ndiscovered by Kai Lu of Fortinet's FortiGuard Labs. (Added 24-March-2015:\nCVE-2015-2326 was given to this.)\n\n24. Computing the size of the JIT read-only data in advance has been a source\nof various issues, and new ones are still appear unfortunately. To fix\nexisting and future issues, size computation is eliminated from the code,\nand replaced by on-demand memory allocation.\n\n25. A pattern such as /(?i)[A-`]/, where characters in the other case are\nadjacent to the end of the range, and the range contained characters with more\nthan one other case, caused incorrect behaviour when compiled in UTF mode. In\nthat example, the range a-j was left out of the class.\n\n\nVersion 10.00 05-January-2015\n-----------------------------\n\nVersion 10.00 is the first release of PCRE2, a revised API for the PCRE\nlibrary. Changes prior to 10.00 are logged in the ChangeLog file for the old\nAPI, up to item 20 for release 8.36.\n\nThe code of the library was heavily revised as part of the new API\nimplementation. Details of each and every modification were not individually\nlogged. In addition to the API changes, the following changes were made. They\nare either new functionality, or bug fixes and other noticeable changes of\nbehaviour that were implemented after the code had been forked.\n\n1. Including Unicode support at build time is now enabled by default, but it\ncan optionally be disabled. It is not enabled by default at run time (no\nchange).\n\n2. The test program, now called pcre2test, was re-specified and almost\ncompletely re-written. Its input is not compatible with input for pcretest.\n\n3. Patterns may start with (*NOTEMPTY) or (*NOTEMPTY_ATSTART) to set the\nPCRE2_NOTEMPTY or PCRE2_NOTEMPTY_ATSTART options for every subject line that is\nmatched by that pattern.\n\n4. For the benefit of those who use PCRE2 via some other application, that is,\nnot writing the function calls themselves, it is possible to check the PCRE2\nversion by matching a pattern such as /(?(VERSION>=10)yes|no)/ against a\nstring such as \"yesno\".\n\n5. There are case-equivalent Unicode characters whose encodings use different\nnumbers of code units in UTF-8. U+023A and U+2C65 are one example. (It is\ntheoretically possible for this to happen in UTF-16 too.) If a backreference to\na group containing one of these characters was greedily repeated, and during\nthe match a backtrack occurred, the subject might be backtracked by the wrong\nnumber of code units. For example, if /^(\\x{23a})\\1*(.)/ is matched caselessly\n(and in UTF-8 mode) against \"\\x{23a}\\x{2c65}\\x{2c65}\\x{2c65}\", group 2 should\ncapture the final character, which is the three bytes E2, B1, and A5 in UTF-8.\nIncorrect backtracking meant that group 2 captured only the last two bytes.\nThis bug has been fixed; the new code is slower, but it is used only when the\nstrings matched by the repetition are not all the same length.\n\n6. A pattern such as /()a/ was not setting the \"first character must be 'a'\"\ninformation. This applied to any pattern with a group that matched no\ncharacters, for example: /(?:(?=.)|(?<!x))a/.\n\n7. When an (*ACCEPT) is triggered inside capturing parentheses, it arranges for\nthose parentheses to be closed with whatever has been captured so far. However,\nit was failing to mark any other groups between the highest capture so far and\nthe currrent group as \"unset\". Thus, the ovector for those groups contained\nwhatever was previously there. An example is the pattern /(x)|((*ACCEPT))/ when\nmatched against \"abcd\".\n\n8. The pcre2_substitute() function has been implemented.\n\n9. If an assertion used as a condition was quantified with a minimum of zero\n(an odd thing to do, but it happened), SIGSEGV or other misbehaviour could\noccur.\n\n10. The PCRE2_NO_DOTSTAR_ANCHOR option has been implemented.\n\n****\n", "/*************************************************\n*             PCRE2 testing program              *\n*************************************************/\n\n/* PCRE2 is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language. In 2014\nthe API was completely revised and '2' was added to the name, because the old\nAPI, which had lasted for 16 years, could not accommodate new requirements. At\nthe same time, this testing program was re-designed because its original\nhacked-up (non-) design had also run out of steam.\n\n                       Written by Philip Hazel\n     Original code Copyright (c) 1997-2012 University of Cambridge\n    Rewritten code Copyright (c) 2016-2022 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This program supports testing of the 8-bit, 16-bit, and 32-bit PCRE2\nlibraries in a single program, though its input and output are always 8-bit.\nIt is different from modules such as pcre2_compile.c in the library itself,\nwhich are compiled separately for each code unit width. If two widths are\nenabled, for example, pcre2_compile.c is compiled twice. In contrast,\npcre2test.c is compiled only once, and linked with all the enabled libraries.\nTherefore, it must not make use of any of the macros from pcre2.h or\npcre2_internal.h that depend on PCRE2_CODE_UNIT_WIDTH. It does, however, make\nuse of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16, and SUPPORT_PCRE2_32, to ensure that\nit references only the enabled library functions. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <locale.h>\n#include <errno.h>\n\n#if defined NATIVE_ZOS\n#include \"pcrzoscs.h\"\n/* That header is not included in the main PCRE2 distribution because other\napparatus is needed to compile pcre2test for z/OS. The header can be found in\nthe special z/OS distribution, which is available from www.zaconsultants.net or\nfrom www.cbttape.org. */\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n/* Debugging code enabler */\n\n/* #define DEBUG_SHOW_MALLOC_ADDRESSES */\n\n/* Both libreadline and libedit are optionally supported */\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\n#if defined(SUPPORT_LIBREADLINE)\n#include <readline/readline.h>\n#include <readline/history.h>\n#else\n#if defined(HAVE_EDITLINE_READLINE_H)\n#include <editline/readline.h>\n#elif defined(HAVE_EDIT_READLINE_READLINE_H)\n#include <edit/readline/readline.h>\n#else\n#include <readline.h>\n/* GNU readline defines this macro but libedit doesn't, if that ever changes\nthis needs to be updated or the build could break */\n#ifdef RL_VERSION_MAJOR\n#include <history.h>\n#endif\n#endif\n#endif\n#endif\n\n/* Put the test for interactive input into a macro so that it can be changed if\nrequired for different environments. */\n\n#define INTERACTIVE(f) isatty(fileno(f))\n\n\n/* ---------------------- System-specific definitions ---------------------- */\n\n/* A number of things vary for Windows builds. Originally, pcretest opened its\ninput and output without \"b\"; then I was told that \"b\" was needed in some\nenvironments, so it was added for release 5.0 to both the input and output. (It\nmakes no difference on Unix-like systems.) Later I was told that it is wrong\nfor the input on Windows. I've now abstracted the modes into macros that are\nset here, to make it easier to fiddle with them, and removed \"b\" from the input\nmode under Windows. The BINARY versions are used when saving/restoring compiled\npatterns. */\n\n#if defined(_WIN32) || defined(WIN32)\n#include <io.h>                /* For _setmode() */\n#include <fcntl.h>             /* For _O_BINARY */\n#define INPUT_MODE          \"r\"\n#define OUTPUT_MODE         \"wb\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n\n#ifndef isatty\n#define isatty _isatty         /* This is what Windows calls them, I'm told, */\n#endif                         /* though in some environments they seem to   */\n                               /* be already defined, hence the #ifndefs.    */\n#ifndef fileno\n#define fileno _fileno\n#endif\n\n/* A user sent this fix for Borland Builder 5 under Windows. */\n\n#ifdef __BORLANDC__\n#define _setmode(handle, mode) setmode(handle, mode)\n#endif\n\n/* Not Windows */\n\n#else\n#include <sys/time.h>          /* These two includes are needed */\n#include <sys/resource.h>      /* for setrlimit(). */\n#if defined NATIVE_ZOS         /* z/OS uses non-binary I/O */\n#define INPUT_MODE   \"r\"\n#define OUTPUT_MODE  \"w\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n#else\n#define INPUT_MODE          \"rb\"\n#define OUTPUT_MODE         \"wb\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n#endif\n#endif\n\n/* VMS-specific code was included as suggested by a VMS user [1]. Another VMS\nuser [2] provided alternative code which worked better for him. I have\ncommented out the original, but kept it around just in case. */\n\n#ifdef __VMS\n#include <ssdef.h>\n/* These two includes came from [2]. */\n#include descrip\n#include lib$routines\n/* void vms_setsymbol( char *, char *, int ); Original code from [1]. */\n#endif\n\n/* old VC and older compilers don't support %td or %zu, and even some that\nclaim to be C99 don't support it (hence DISABLE_PERCENT_ZT). */\n\n#if defined(DISABLE_PERCENT_ZT) || (defined(_MSC_VER) && (_MSC_VER < 1800)) || \\\n  (!defined(_MSC_VER) && (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L)))\n#ifdef _WIN64\n#define PTR_FORM \"lld\"\n#define SIZ_FORM \"llu\"\n#else\n#define PTR_FORM \"ld\"\n#define SIZ_FORM \"lu\"\n#endif\n#else\n#define PTR_FORM \"td\"\n#define SIZ_FORM \"zu\"\n#endif\n\n/* ------------------End of system-specific definitions -------------------- */\n\n/* Glueing macros that are used in several places below. */\n\n#define glue(a,b) a##b\n#define G(a,b) glue(a,b)\n\n/* Miscellaneous parameters and manifests */\n\n#ifndef CLOCKS_PER_SEC\n#ifdef CLK_TCK\n#define CLOCKS_PER_SEC CLK_TCK\n#else\n#define CLOCKS_PER_SEC 100\n#endif\n#endif\n\n#define CFORE_UNSET UINT32_MAX    /* Unset value for startend/cfail/cerror fields */\n#define CONVERT_UNSET UINT32_MAX  /* Unset value for convert_type field */\n#define DFA_WS_DIMENSION 1000     /* Size of DFA workspace */\n#define DEFAULT_OVECCOUNT 15      /* Default ovector count */\n#define JUNK_OFFSET 0xdeadbeef    /* For initializing ovector */\n#define LOCALESIZE 32             /* Size of locale name */\n#define LOOPREPEAT 500000         /* Default loop count for timing */\n#define MALLOCLISTSIZE 20         /* For remembering mallocs */\n#define PARENS_NEST_DEFAULT 220   /* Default parentheses nest limit */\n#define PATSTACKSIZE 20           /* Pattern stack for save/restore testing */\n#define REPLACE_MODSIZE 100       /* Field for reading 8-bit replacement */\n#define VERSION_SIZE 64           /* Size of buffer for the version strings */\n\n/* Default JIT compile options */\n\n#define JIT_DEFAULT (PCRE2_JIT_COMPLETE|\\\n                     PCRE2_JIT_PARTIAL_SOFT|\\\n                     PCRE2_JIT_PARTIAL_HARD)\n\n/* Make sure the buffer into which replacement strings are copied is big enough\nto hold them as 32-bit code units. */\n\n#define REPLACE_BUFFSIZE 1024   /* This is a byte value */\n\n/* Execution modes */\n\n#define PCRE8_MODE   8\n#define PCRE16_MODE 16\n#define PCRE32_MODE 32\n\n/* Processing returns */\n\nenum { PR_OK, PR_SKIP, PR_ABEND };\n\n/* The macro PRINTABLE determines whether to print an output character as-is or\nas a hex value when showing compiled patterns. is We use it in cases when the\nlocale has not been explicitly changed, so as to get consistent output from\nsystems that differ in their output from isprint() even in the \"C\" locale. */\n\n#ifdef EBCDIC\n#define PRINTABLE(c) ((c) >= 64 && (c) < 255)\n#else\n#define PRINTABLE(c) ((c) >= 32 && (c) < 127)\n#endif\n\n#define PRINTOK(c) ((use_tables != NULL && c < 256)? isprint(c) : PRINTABLE(c))\n\n/* We have to include some of the library source files because we need\nto use some of the macros, internal structure definitions, and other internal\nvalues - pcre2test has \"inside information\" compared to an application program\nthat strictly follows the PCRE2 API.\n\nBefore including pcre2_internal.h we define PRIV so that it does not get\ndefined therein. This ensures that PRIV names in the included files do not\nclash with those in the libraries. Also, although pcre2_internal.h does itself\ninclude pcre2.h, we explicitly include it beforehand, along with pcre2posix.h,\nso that the PCRE2_EXP_xxx macros get set appropriately for an application, not\nfor building the library. */\n\n#define PRIV(name) name\n#define PCRE2_CODE_UNIT_WIDTH 0\n#include \"pcre2.h\"\n#include \"pcre2posix.h\"\n#include \"pcre2_internal.h\"\n\n/* We need access to some of the data tables that PCRE2 uses. Defining\nPCRE2_PCRETEST makes some minor changes in the files. The previous definition\nof PRIV avoids name clashes. */\n\n#define PCRE2_PCRE2TEST\n#include \"pcre2_tables.c\"\n#include \"pcre2_ucd.c\"\n\n/* 32-bit integer values in the input are read by strtoul() or strtol(). The\ncheck needed for overflow depends on whether long ints are in fact longer than\nints. They are defined not to be shorter. */\n\n#if ULONG_MAX > UINT32_MAX\n#define U32OVERFLOW(x) (x > UINT32_MAX)\n#else\n#define U32OVERFLOW(x) (x == UINT32_MAX)\n#endif\n\n#if LONG_MAX > INT32_MAX\n#define S32OVERFLOW(x) (x > INT32_MAX || x < INT32_MIN)\n#else\n#define S32OVERFLOW(x) (x == INT32_MAX || x == INT32_MIN)\n#endif\n\n/* When PCRE2_CODE_UNIT_WIDTH is zero, pcre2_internal.h does not include\npcre2_intmodedep.h, which is where mode-dependent macros and structures are\ndefined. We can now include it for each supported code unit width. Because\nPCRE2_CODE_UNIT_WIDTH was defined as zero before including pcre2.h, it will\nhave left PCRE2_SUFFIX defined as a no-op. We must re-define it appropriately\nwhile including these files, and then restore it to a no-op. Because LINK_SIZE\nmay be changed in 16-bit mode and forced to 1 in 32-bit mode, the order of\nthese inclusions should not be changed. */\n\n#undef PCRE2_SUFFIX\n#undef PCRE2_CODE_UNIT_WIDTH\n\n#ifdef   SUPPORT_PCRE2_8\n#define  PCRE2_CODE_UNIT_WIDTH 8\n#define  PCRE2_SUFFIX(a) G(a,8)\n#include \"pcre2_intmodedep.h\"\n#include \"pcre2_printint.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_8 */\n\n#ifdef   SUPPORT_PCRE2_16\n#define  PCRE2_CODE_UNIT_WIDTH 16\n#define  PCRE2_SUFFIX(a) G(a,16)\n#include \"pcre2_intmodedep.h\"\n#include \"pcre2_printint.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_16 */\n\n#ifdef   SUPPORT_PCRE2_32\n#define  PCRE2_CODE_UNIT_WIDTH 32\n#define  PCRE2_SUFFIX(a) G(a,32)\n#include \"pcre2_intmodedep.h\"\n#include \"pcre2_printint.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_32 */\n\n#define PCRE2_SUFFIX(a) a\n\n/* We need to be able to check input text for UTF-8 validity, whatever code\nwidths are actually available, because the input to pcre2test is always in\n8-bit code units. So we include the UTF validity checking function for 8-bit\ncode units. */\n\nextern int valid_utf(PCRE2_SPTR8, PCRE2_SIZE, PCRE2_SIZE *);\n\n#define  PCRE2_CODE_UNIT_WIDTH 8\n#undef   PCRE2_SPTR\n#define  PCRE2_SPTR PCRE2_SPTR8\n#include \"pcre2_valid_utf.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SPTR\n\n/* If we have 8-bit support, default to it; if there is also 16-or 32-bit\nsupport, it can be selected by a command-line option. If there is no 8-bit\nsupport, there must be 16-bit or 32-bit support, so default to one of them. The\nconfig function, JIT stack, contexts, and version string are the same in all\nmodes, so use the form of the first that is available. */\n\n#if defined SUPPORT_PCRE2_8\n#define DEFAULT_TEST_MODE PCRE8_MODE\n#define VERSION_TYPE PCRE2_UCHAR8\n#define PCRE2_CONFIG pcre2_config_8\n#define PCRE2_JIT_STACK pcre2_jit_stack_8\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_8\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_8\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_8\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_8\n\n#elif defined SUPPORT_PCRE2_16\n#define DEFAULT_TEST_MODE PCRE16_MODE\n#define VERSION_TYPE PCRE2_UCHAR16\n#define PCRE2_CONFIG pcre2_config_16\n#define PCRE2_JIT_STACK pcre2_jit_stack_16\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_16\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_16\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_16\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_16\n\n#elif defined SUPPORT_PCRE2_32\n#define DEFAULT_TEST_MODE PCRE32_MODE\n#define VERSION_TYPE PCRE2_UCHAR32\n#define PCRE2_CONFIG pcre2_config_32\n#define PCRE2_JIT_STACK pcre2_jit_stack_32\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_32\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_32\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_32\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_32\n#endif\n\n/* ------------- Structure and table for handling #-commands ------------- */\n\ntypedef struct cmdstruct {\n  const char *name;\n  int  value;\n} cmdstruct;\n\nenum { CMD_FORBID_UTF, CMD_LOAD, CMD_LOADTABLES, CMD_NEWLINE_DEFAULT,\n  CMD_PATTERN, CMD_PERLTEST, CMD_POP, CMD_POPCOPY, CMD_SAVE, CMD_SUBJECT,\n  CMD_UNKNOWN };\n\nstatic cmdstruct cmdlist[] = {\n  { \"forbid_utf\",      CMD_FORBID_UTF },\n  { \"load\",            CMD_LOAD },\n  { \"loadtables\",      CMD_LOADTABLES },\n  { \"newline_default\", CMD_NEWLINE_DEFAULT },\n  { \"pattern\",         CMD_PATTERN },\n  { \"perltest\",        CMD_PERLTEST },\n  { \"pop\",             CMD_POP },\n  { \"popcopy\",         CMD_POPCOPY },\n  { \"save\",            CMD_SAVE },\n  { \"subject\",         CMD_SUBJECT }};\n\n#define cmdlistcount (sizeof(cmdlist)/sizeof(cmdstruct))\n\n/* ------------- Structures and tables for handling modifiers -------------- */\n\n/* Table of names for newline types. Must be kept in step with the definitions\nof PCRE2_NEWLINE_xx in pcre2.h. */\n\nstatic const char *newlines[] = {\n  \"DEFAULT\", \"CR\", \"LF\", \"CRLF\", \"ANY\", \"ANYCRLF\", \"NUL\" };\n\n/* Structure and table for handling pattern conversion types. */\n\ntypedef struct convertstruct {\n  const char *name;\n  uint32_t option;\n} convertstruct;\n\nstatic convertstruct convertlist[] = {\n  { \"glob\",                   PCRE2_CONVERT_GLOB },\n  { \"glob_no_starstar\",       PCRE2_CONVERT_GLOB_NO_STARSTAR },\n  { \"glob_no_wild_separator\", PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR },\n  { \"posix_basic\",            PCRE2_CONVERT_POSIX_BASIC },\n  { \"posix_extended\",         PCRE2_CONVERT_POSIX_EXTENDED },\n  { \"unset\",                  CONVERT_UNSET }};\n\n#define convertlistcount (sizeof(convertlist)/sizeof(convertstruct))\n\n/* Modifier types and applicability */\n\nenum { MOD_CTC,    /* Applies to a compile context */\n       MOD_CTM,    /* Applies to a match context */\n       MOD_PAT,    /* Applies to a pattern */\n       MOD_PATP,   /* Ditto, OK for Perl test */\n       MOD_DAT,    /* Applies to a data line */\n       MOD_DATP,   /* Ditto, OK for Perl test */\n       MOD_PD,     /* Applies to a pattern or a data line */\n       MOD_PDP,    /* As MOD_PD, OK for Perl test */\n       MOD_PND,    /* As MOD_PD, but not for a default pattern */\n       MOD_PNDP,   /* As MOD_PND, OK for Perl test */\n       MOD_CHR,    /* Is a single character */\n       MOD_CON,    /* Is a \"convert\" type/options list */\n       MOD_CTL,    /* Is a control bit */\n       MOD_BSR,    /* Is a BSR value */\n       MOD_IN2,    /* Is one or two unsigned integers */\n       MOD_INS,    /* Is a signed integer */\n       MOD_INT,    /* Is an unsigned integer */\n       MOD_IND,    /* Is an unsigned integer, but no value => default */\n       MOD_NL,     /* Is a newline value */\n       MOD_NN,     /* Is a number or a name; more than one may occur */\n       MOD_OPT,    /* Is an option bit */\n       MOD_SIZ,    /* Is a PCRE2_SIZE value */\n       MOD_STR };  /* Is a string */\n\n/* Control bits. Some apply to compiling, some to matching, but some can be set\neither on a pattern or a data line, so they must all be distinct. There are now\nso many of them that they are split into two fields. */\n\n#define CTL_AFTERTEXT                    0x00000001u\n#define CTL_ALLAFTERTEXT                 0x00000002u\n#define CTL_ALLCAPTURES                  0x00000004u\n#define CTL_ALLUSEDTEXT                  0x00000008u\n#define CTL_ALTGLOBAL                    0x00000010u\n#define CTL_BINCODE                      0x00000020u\n#define CTL_CALLOUT_CAPTURE              0x00000040u\n#define CTL_CALLOUT_INFO                 0x00000080u\n#define CTL_CALLOUT_NONE                 0x00000100u\n#define CTL_DFA                          0x00000200u\n#define CTL_EXPAND                       0x00000400u\n#define CTL_FINDLIMITS                   0x00000800u\n#define CTL_FINDLIMITS_NOHEAP            0x00001000u\n#define CTL_FULLBINCODE                  0x00002000u\n#define CTL_GETALL                       0x00004000u\n#define CTL_GLOBAL                       0x00008000u\n#define CTL_HEXPAT                       0x00010000u  /* Same word as USE_LENGTH */\n#define CTL_INFO                         0x00020000u\n#define CTL_JITFAST                      0x00040000u\n#define CTL_JITVERIFY                    0x00080000u\n#define CTL_MARK                         0x00100000u\n#define CTL_MEMORY                       0x00200000u\n#define CTL_NULLCONTEXT                  0x00400000u\n#define CTL_POSIX                        0x00800000u\n#define CTL_POSIX_NOSUB                  0x01000000u\n#define CTL_PUSH                         0x02000000u  /* These three must be */\n#define CTL_PUSHCOPY                     0x04000000u  /*   all in the same */\n#define CTL_PUSHTABLESCOPY               0x08000000u  /*     word. */\n#define CTL_STARTCHAR                    0x10000000u\n#define CTL_USE_LENGTH                   0x20000000u  /* Same word as HEXPAT */\n#define CTL_UTF8_INPUT                   0x40000000u\n#define CTL_ZERO_TERMINATE               0x80000000u\n\n/* Combinations */\n\n#define CTL_DEBUG            (CTL_FULLBINCODE|CTL_INFO)  /* For setting */\n#define CTL_ANYINFO          (CTL_DEBUG|CTL_BINCODE|CTL_CALLOUT_INFO)\n#define CTL_ANYGLOB          (CTL_ALTGLOBAL|CTL_GLOBAL)\n\n/* Second control word */\n\n#define CTL2_SUBSTITUTE_CALLOUT          0x00000001u\n#define CTL2_SUBSTITUTE_EXTENDED         0x00000002u\n#define CTL2_SUBSTITUTE_LITERAL          0x00000004u\n#define CTL2_SUBSTITUTE_MATCHED          0x00000008u\n#define CTL2_SUBSTITUTE_OVERFLOW_LENGTH  0x00000010u\n#define CTL2_SUBSTITUTE_REPLACEMENT_ONLY 0x00000020u\n#define CTL2_SUBSTITUTE_UNKNOWN_UNSET    0x00000040u\n#define CTL2_SUBSTITUTE_UNSET_EMPTY      0x00000080u\n#define CTL2_SUBJECT_LITERAL             0x00000100u\n#define CTL2_CALLOUT_NO_WHERE            0x00000200u\n#define CTL2_CALLOUT_EXTRA               0x00000400u\n#define CTL2_ALLVECTOR                   0x00000800u\n#define CTL2_NULL_SUBJECT                0x00001000u\n#define CTL2_NULL_REPLACEMENT            0x00002000u\n#define CTL2_FRAMESIZE                   0x00004000u\n\n#define CTL2_NL_SET                      0x40000000u  /* Informational */\n#define CTL2_BSR_SET                     0x80000000u  /* Informational */\n\n/* These are the matching controls that may be set either on a pattern or on a\ndata line. They are copied from the pattern controls as initial settings for\ndata line controls. Note that CTL_MEMORY is not included here, because it does\ndifferent things in the two cases. */\n\n#define CTL_ALLPD  (CTL_AFTERTEXT|\\\n                    CTL_ALLAFTERTEXT|\\\n                    CTL_ALLCAPTURES|\\\n                    CTL_ALLUSEDTEXT|\\\n                    CTL_ALTGLOBAL|\\\n                    CTL_GLOBAL|\\\n                    CTL_MARK|\\\n                    CTL_STARTCHAR|\\\n                    CTL_UTF8_INPUT)\n\n#define CTL2_ALLPD (CTL2_SUBSTITUTE_CALLOUT|\\\n                    CTL2_SUBSTITUTE_EXTENDED|\\\n                    CTL2_SUBSTITUTE_LITERAL|\\\n                    CTL2_SUBSTITUTE_MATCHED|\\\n                    CTL2_SUBSTITUTE_OVERFLOW_LENGTH|\\\n                    CTL2_SUBSTITUTE_REPLACEMENT_ONLY|\\\n                    CTL2_SUBSTITUTE_UNKNOWN_UNSET|\\\n                    CTL2_SUBSTITUTE_UNSET_EMPTY|\\\n                    CTL2_ALLVECTOR)\n\n/* Structures for holding modifier information for patterns and subject strings\n(data). Fields containing modifiers that can be set either for a pattern or a\nsubject must be at the start and in the same order in both cases so that the\nsame offset in the big table below works for both. */\n\ntypedef struct patctl {       /* Structure for pattern modifiers. */\n  uint32_t  options;          /* Must be in same position as datctl */\n  uint32_t  control;          /* Must be in same position as datctl */\n  uint32_t  control2;         /* Must be in same position as datctl */\n  uint32_t  jitstack;         /* Must be in same position as datctl */\n   uint8_t  replacement[REPLACE_MODSIZE];  /* So must this */\n  uint32_t  substitute_skip;  /* Must be in same position as patctl */\n  uint32_t  substitute_stop;  /* Must be in same position as patctl */\n  uint32_t  jit;\n  uint32_t  stackguard_test;\n  uint32_t  tables_id;\n  uint32_t  convert_type;\n  uint32_t  convert_length;\n  uint32_t  convert_glob_escape;\n  uint32_t  convert_glob_separator;\n  uint32_t  regerror_buffsize;\n   uint8_t  locale[LOCALESIZE];\n} patctl;\n\n#define MAXCPYGET 10\n#define LENCPYGET 64\n\ntypedef struct datctl {       /* Structure for data line modifiers. */\n  uint32_t  options;          /* Must be in same position as patctl */\n  uint32_t  control;          /* Must be in same position as patctl */\n  uint32_t  control2;         /* Must be in same position as patctl */\n  uint32_t  jitstack;         /* Must be in same position as patctl */\n   uint8_t  replacement[REPLACE_MODSIZE];  /* So must this */\n  uint32_t  substitute_skip;  /* Must be in same position as patctl */\n  uint32_t  substitute_stop;  /* Must be in same position as patctl */\n  uint32_t  startend[2];\n  uint32_t  cerror[2];\n  uint32_t  cfail[2];\n   int32_t  callout_data;\n   int32_t  copy_numbers[MAXCPYGET];\n   int32_t  get_numbers[MAXCPYGET];\n  uint32_t  oveccount;\n  uint32_t  offset;\n  uint8_t   copy_names[LENCPYGET];\n  uint8_t   get_names[LENCPYGET];\n} datctl;\n\n/* Ids for which context to modify. */\n\nenum { CTX_PAT,            /* Active pattern context */\n       CTX_POPPAT,         /* Ditto, for a popped pattern */\n       CTX_DEFPAT,         /* Default pattern context */\n       CTX_DAT,            /* Active data (match) context */\n       CTX_DEFDAT };       /* Default data (match) context */\n\n/* Macros to simplify the big table below. */\n\n#define CO(name) offsetof(PCRE2_REAL_COMPILE_CONTEXT, name)\n#define MO(name) offsetof(PCRE2_REAL_MATCH_CONTEXT, name)\n#define PO(name) offsetof(patctl, name)\n#define PD(name) PO(name)\n#define DO(name) offsetof(datctl, name)\n\n/* Table of all long-form modifiers. Must be in collating sequence of modifier\nname because it is searched by binary chop. */\n\ntypedef struct modstruct {\n  const char   *name;\n  uint16_t      which;\n  uint16_t      type;\n  uint32_t      value;\n  PCRE2_SIZE    offset;\n} modstruct;\n\nstatic modstruct modlist[] = {\n  { \"aftertext\",                   MOD_PNDP, MOD_CTL, CTL_AFTERTEXT,              PO(control) },\n  { \"allaftertext\",                MOD_PNDP, MOD_CTL, CTL_ALLAFTERTEXT,           PO(control) },\n  { \"allcaptures\",                 MOD_PND,  MOD_CTL, CTL_ALLCAPTURES,            PO(control) },\n  { \"allow_empty_class\",           MOD_PAT,  MOD_OPT, PCRE2_ALLOW_EMPTY_CLASS,    PO(options) },\n  { \"allow_lookaround_bsk\",        MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK, CO(extra_options) },\n  { \"allow_surrogate_escapes\",     MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES, CO(extra_options) },\n  { \"allusedtext\",                 MOD_PNDP, MOD_CTL, CTL_ALLUSEDTEXT,            PO(control) },\n  { \"allvector\",                   MOD_PND,  MOD_CTL, CTL2_ALLVECTOR,             PO(control2) },\n  { \"alt_bsux\",                    MOD_PAT,  MOD_OPT, PCRE2_ALT_BSUX,             PO(options) },\n  { \"alt_circumflex\",              MOD_PAT,  MOD_OPT, PCRE2_ALT_CIRCUMFLEX,       PO(options) },\n  { \"alt_verbnames\",               MOD_PAT,  MOD_OPT, PCRE2_ALT_VERBNAMES,        PO(options) },\n  { \"altglobal\",                   MOD_PND,  MOD_CTL, CTL_ALTGLOBAL,              PO(control) },\n  { \"anchored\",                    MOD_PD,   MOD_OPT, PCRE2_ANCHORED,             PD(options) },\n  { \"auto_callout\",                MOD_PAT,  MOD_OPT, PCRE2_AUTO_CALLOUT,         PO(options) },\n  { \"bad_escape_is_literal\",       MOD_CTC,  MOD_OPT, PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL, CO(extra_options) },\n  { \"bincode\",                     MOD_PAT,  MOD_CTL, CTL_BINCODE,                PO(control) },\n  { \"bsr\",                         MOD_CTC,  MOD_BSR, 0,                          CO(bsr_convention) },\n  { \"callout_capture\",             MOD_DAT,  MOD_CTL, CTL_CALLOUT_CAPTURE,        DO(control) },\n  { \"callout_data\",                MOD_DAT,  MOD_INS, 0,                          DO(callout_data) },\n  { \"callout_error\",               MOD_DAT,  MOD_IN2, 0,                          DO(cerror) },\n  { \"callout_extra\",               MOD_DAT,  MOD_CTL, CTL2_CALLOUT_EXTRA,         DO(control2) },\n  { \"callout_fail\",                MOD_DAT,  MOD_IN2, 0,                          DO(cfail) },\n  { \"callout_info\",                MOD_PAT,  MOD_CTL, CTL_CALLOUT_INFO,           PO(control) },\n  { \"callout_no_where\",            MOD_DAT,  MOD_CTL, CTL2_CALLOUT_NO_WHERE,      DO(control2) },\n  { \"callout_none\",                MOD_DAT,  MOD_CTL, CTL_CALLOUT_NONE,           DO(control) },\n  { \"caseless\",                    MOD_PATP, MOD_OPT, PCRE2_CASELESS,             PO(options) },\n  { \"convert\",                     MOD_PAT,  MOD_CON, 0,                          PO(convert_type) },\n  { \"convert_glob_escape\",         MOD_PAT,  MOD_CHR, 0,                          PO(convert_glob_escape) },\n  { \"convert_glob_separator\",      MOD_PAT,  MOD_CHR, 0,                          PO(convert_glob_separator) },\n  { \"convert_length\",              MOD_PAT,  MOD_INT, 0,                          PO(convert_length) },\n  { \"copy\",                        MOD_DAT,  MOD_NN,  DO(copy_numbers),           DO(copy_names) },\n  { \"copy_matched_subject\",        MOD_DAT,  MOD_OPT, PCRE2_COPY_MATCHED_SUBJECT, DO(options) },\n  { \"debug\",                       MOD_PAT,  MOD_CTL, CTL_DEBUG,                  PO(control) },\n  { \"depth_limit\",                 MOD_CTM,  MOD_INT, 0,                          MO(depth_limit) },\n  { \"dfa\",                         MOD_DAT,  MOD_CTL, CTL_DFA,                    DO(control) },\n  { \"dfa_restart\",                 MOD_DAT,  MOD_OPT, PCRE2_DFA_RESTART,          DO(options) },\n  { \"dfa_shortest\",                MOD_DAT,  MOD_OPT, PCRE2_DFA_SHORTEST,         DO(options) },\n  { \"dollar_endonly\",              MOD_PAT,  MOD_OPT, PCRE2_DOLLAR_ENDONLY,       PO(options) },\n  { \"dotall\",                      MOD_PATP, MOD_OPT, PCRE2_DOTALL,               PO(options) },\n  { \"dupnames\",                    MOD_PATP, MOD_OPT, PCRE2_DUPNAMES,             PO(options) },\n  { \"endanchored\",                 MOD_PD,   MOD_OPT, PCRE2_ENDANCHORED,          PD(options) },\n  { \"escaped_cr_is_lf\",            MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ESCAPED_CR_IS_LF, CO(extra_options) },\n  { \"expand\",                      MOD_PAT,  MOD_CTL, CTL_EXPAND,                 PO(control) },\n  { \"extended\",                    MOD_PATP, MOD_OPT, PCRE2_EXTENDED,             PO(options) },\n  { \"extended_more\",               MOD_PATP, MOD_OPT, PCRE2_EXTENDED_MORE,        PO(options) },\n  { \"extra_alt_bsux\",              MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALT_BSUX,       CO(extra_options) },\n  { \"find_limits\",                 MOD_DAT,  MOD_CTL, CTL_FINDLIMITS,             DO(control) },\n  { \"find_limits_noheap\",          MOD_DAT,  MOD_CTL, CTL_FINDLIMITS_NOHEAP,      DO(control) },\n  { \"firstline\",                   MOD_PAT,  MOD_OPT, PCRE2_FIRSTLINE,            PO(options) },\n  { \"framesize\",                   MOD_PAT,  MOD_CTL, CTL2_FRAMESIZE,             PO(control2) },\n  { \"fullbincode\",                 MOD_PAT,  MOD_CTL, CTL_FULLBINCODE,            PO(control) },\n  { \"get\",                         MOD_DAT,  MOD_NN,  DO(get_numbers),            DO(get_names) },\n  { \"getall\",                      MOD_DAT,  MOD_CTL, CTL_GETALL,                 DO(control) },\n  { \"global\",                      MOD_PNDP, MOD_CTL, CTL_GLOBAL,                 PO(control) },\n  { \"heap_limit\",                  MOD_CTM,  MOD_INT, 0,                          MO(heap_limit) },\n  { \"hex\",                         MOD_PAT,  MOD_CTL, CTL_HEXPAT,                 PO(control) },\n  { \"info\",                        MOD_PAT,  MOD_CTL, CTL_INFO,                   PO(control) },\n  { \"jit\",                         MOD_PAT,  MOD_IND, 7,                          PO(jit) },\n  { \"jitfast\",                     MOD_PAT,  MOD_CTL, CTL_JITFAST,                PO(control) },\n  { \"jitstack\",                    MOD_PNDP, MOD_INT, 0,                          PO(jitstack) },\n  { \"jitverify\",                   MOD_PAT,  MOD_CTL, CTL_JITVERIFY,              PO(control) },\n  { \"literal\",                     MOD_PAT,  MOD_OPT, PCRE2_LITERAL,              PO(options) },\n  { \"locale\",                      MOD_PAT,  MOD_STR, LOCALESIZE,                 PO(locale) },\n  { \"mark\",                        MOD_PNDP, MOD_CTL, CTL_MARK,                   PO(control) },\n  { \"match_invalid_utf\",           MOD_PAT,  MOD_OPT, PCRE2_MATCH_INVALID_UTF,    PO(options) },\n  { \"match_limit\",                 MOD_CTM,  MOD_INT, 0,                          MO(match_limit) },\n  { \"match_line\",                  MOD_CTC,  MOD_OPT, PCRE2_EXTRA_MATCH_LINE,     CO(extra_options) },\n  { \"match_unset_backref\",         MOD_PAT,  MOD_OPT, PCRE2_MATCH_UNSET_BACKREF,  PO(options) },\n  { \"match_word\",                  MOD_CTC,  MOD_OPT, PCRE2_EXTRA_MATCH_WORD,     CO(extra_options) },\n  { \"max_pattern_length\",          MOD_CTC,  MOD_SIZ, 0,                          CO(max_pattern_length) },\n  { \"memory\",                      MOD_PD,   MOD_CTL, CTL_MEMORY,                 PD(control) },\n  { \"multiline\",                   MOD_PATP, MOD_OPT, PCRE2_MULTILINE,            PO(options) },\n  { \"never_backslash_c\",           MOD_PAT,  MOD_OPT, PCRE2_NEVER_BACKSLASH_C,    PO(options) },\n  { \"never_ucp\",                   MOD_PAT,  MOD_OPT, PCRE2_NEVER_UCP,            PO(options) },\n  { \"never_utf\",                   MOD_PAT,  MOD_OPT, PCRE2_NEVER_UTF,            PO(options) },\n  { \"newline\",                     MOD_CTC,  MOD_NL,  0,                          CO(newline_convention) },\n  { \"no_auto_capture\",             MOD_PAT,  MOD_OPT, PCRE2_NO_AUTO_CAPTURE,      PO(options) },\n  { \"no_auto_possess\",             MOD_PATP, MOD_OPT, PCRE2_NO_AUTO_POSSESS,      PO(options) },\n  { \"no_dotstar_anchor\",           MOD_PAT,  MOD_OPT, PCRE2_NO_DOTSTAR_ANCHOR,    PO(options) },\n  { \"no_jit\",                      MOD_DATP, MOD_OPT, PCRE2_NO_JIT,               DO(options) },\n  { \"no_start_optimize\",           MOD_PATP, MOD_OPT, PCRE2_NO_START_OPTIMIZE,    PO(options) },\n  { \"no_utf_check\",                MOD_PD,   MOD_OPT, PCRE2_NO_UTF_CHECK,         PD(options) },\n  { \"notbol\",                      MOD_DAT,  MOD_OPT, PCRE2_NOTBOL,               DO(options) },\n  { \"notempty\",                    MOD_DAT,  MOD_OPT, PCRE2_NOTEMPTY,             DO(options) },\n  { \"notempty_atstart\",            MOD_DAT,  MOD_OPT, PCRE2_NOTEMPTY_ATSTART,     DO(options) },\n  { \"noteol\",                      MOD_DAT,  MOD_OPT, PCRE2_NOTEOL,               DO(options) },\n  { \"null_context\",                MOD_PD,   MOD_CTL, CTL_NULLCONTEXT,            PO(control) },\n  { \"null_replacement\",            MOD_DAT,  MOD_CTL, CTL2_NULL_REPLACEMENT,      DO(control2) },\n  { \"null_subject\",                MOD_DAT,  MOD_CTL, CTL2_NULL_SUBJECT,          DO(control2) },\n  { \"offset\",                      MOD_DAT,  MOD_INT, 0,                          DO(offset) },\n  { \"offset_limit\",                MOD_CTM,  MOD_SIZ, 0,                          MO(offset_limit)},\n  { \"ovector\",                     MOD_DAT,  MOD_INT, 0,                          DO(oveccount) },\n  { \"parens_nest_limit\",           MOD_CTC,  MOD_INT, 0,                          CO(parens_nest_limit) },\n  { \"partial_hard\",                MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_HARD,         DO(options) },\n  { \"partial_soft\",                MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_SOFT,         DO(options) },\n  { \"ph\",                          MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_HARD,         DO(options) },\n  { \"posix\",                       MOD_PAT,  MOD_CTL, CTL_POSIX,                  PO(control) },\n  { \"posix_nosub\",                 MOD_PAT,  MOD_CTL, CTL_POSIX|CTL_POSIX_NOSUB,  PO(control) },\n  { \"posix_startend\",              MOD_DAT,  MOD_IN2, 0,                          DO(startend) },\n  { \"ps\",                          MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_SOFT,         DO(options) },\n  { \"push\",                        MOD_PAT,  MOD_CTL, CTL_PUSH,                   PO(control) },\n  { \"pushcopy\",                    MOD_PAT,  MOD_CTL, CTL_PUSHCOPY,               PO(control) },\n  { \"pushtablescopy\",              MOD_PAT,  MOD_CTL, CTL_PUSHTABLESCOPY,         PO(control) },\n  { \"recursion_limit\",             MOD_CTM,  MOD_INT, 0,                          MO(depth_limit) },  /* Obsolete synonym */\n  { \"regerror_buffsize\",           MOD_PAT,  MOD_INT, 0,                          PO(regerror_buffsize) },\n  { \"replace\",                     MOD_PND,  MOD_STR, REPLACE_MODSIZE,            PO(replacement) },\n  { \"stackguard\",                  MOD_PAT,  MOD_INT, 0,                          PO(stackguard_test) },\n  { \"startchar\",                   MOD_PND,  MOD_CTL, CTL_STARTCHAR,              PO(control) },\n  { \"startoffset\",                 MOD_DAT,  MOD_INT, 0,                          DO(offset) },\n  { \"subject_literal\",             MOD_PATP, MOD_CTL, CTL2_SUBJECT_LITERAL,       PO(control2) },\n  { \"substitute_callout\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_CALLOUT,    PO(control2) },\n  { \"substitute_extended\",         MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_EXTENDED,   PO(control2) },\n  { \"substitute_literal\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_LITERAL,    PO(control2) },\n  { \"substitute_matched\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_MATCHED,    PO(control2) },\n  { \"substitute_overflow_length\",  MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_OVERFLOW_LENGTH, PO(control2) },\n  { \"substitute_replacement_only\", MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_REPLACEMENT_ONLY, PO(control2) },\n  { \"substitute_skip\",             MOD_PND,  MOD_INT, 0,                          PO(substitute_skip) },\n  { \"substitute_stop\",             MOD_PND,  MOD_INT, 0,                          PO(substitute_stop) },\n  { \"substitute_unknown_unset\",    MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_UNKNOWN_UNSET, PO(control2) },\n  { \"substitute_unset_empty\",      MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_UNSET_EMPTY, PO(control2) },\n  { \"tables\",                      MOD_PAT,  MOD_INT, 0,                          PO(tables_id) },\n  { \"ucp\",                         MOD_PATP, MOD_OPT, PCRE2_UCP,                  PO(options) },\n  { \"ungreedy\",                    MOD_PAT,  MOD_OPT, PCRE2_UNGREEDY,             PO(options) },\n  { \"use_length\",                  MOD_PAT,  MOD_CTL, CTL_USE_LENGTH,             PO(control) },\n  { \"use_offset_limit\",            MOD_PAT,  MOD_OPT, PCRE2_USE_OFFSET_LIMIT,     PO(options) },\n  { \"utf\",                         MOD_PATP, MOD_OPT, PCRE2_UTF,                  PO(options) },\n  { \"utf8_input\",                  MOD_PAT,  MOD_CTL, CTL_UTF8_INPUT,             PO(control) },\n  { \"zero_terminate\",              MOD_DAT,  MOD_CTL, CTL_ZERO_TERMINATE,         DO(control) }\n};\n\n#define MODLISTCOUNT sizeof(modlist)/sizeof(modstruct)\n\n/* Controls and options that are supported for use with the POSIX interface. */\n\n#define POSIX_SUPPORTED_COMPILE_OPTIONS ( \\\n  PCRE2_CASELESS|PCRE2_DOTALL|PCRE2_LITERAL|PCRE2_MULTILINE|PCRE2_UCP| \\\n  PCRE2_UTF|PCRE2_UNGREEDY)\n\n#define POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS (0)\n\n#define POSIX_SUPPORTED_COMPILE_CONTROLS ( \\\n  CTL_AFTERTEXT|CTL_ALLAFTERTEXT|CTL_EXPAND|CTL_HEXPAT|CTL_POSIX| \\\n  CTL_POSIX_NOSUB|CTL_USE_LENGTH)\n\n#define POSIX_SUPPORTED_COMPILE_CONTROLS2 (0)\n\n#define POSIX_SUPPORTED_MATCH_OPTIONS ( \\\n  PCRE2_NOTBOL|PCRE2_NOTEMPTY|PCRE2_NOTEOL)\n\n#define POSIX_SUPPORTED_MATCH_CONTROLS  (CTL_AFTERTEXT|CTL_ALLAFTERTEXT)\n#define POSIX_SUPPORTED_MATCH_CONTROLS2 (CTL2_NULL_SUBJECT)\n\n/* Control bits that are not ignored with 'push'. */\n\n#define PUSH_SUPPORTED_COMPILE_CONTROLS ( \\\n  CTL_BINCODE|CTL_CALLOUT_INFO|CTL_FULLBINCODE|CTL_HEXPAT|CTL_INFO| \\\n  CTL_JITVERIFY|CTL_MEMORY|CTL_PUSH|CTL_PUSHCOPY| \\\n  CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)\n\n#define PUSH_SUPPORTED_COMPILE_CONTROLS2 (CTL2_BSR_SET|CTL2_FRAMESIZE| \\\n  CTL2_NL_SET)\n\n/* Controls that apply only at compile time with 'push'. */\n\n#define PUSH_COMPILE_ONLY_CONTROLS   CTL_JITVERIFY\n#define PUSH_COMPILE_ONLY_CONTROLS2  (0)\n\n/* Controls that are forbidden with #pop or #popcopy. */\n\n#define NOTPOP_CONTROLS (CTL_HEXPAT|CTL_POSIX|CTL_POSIX_NOSUB|CTL_PUSH| \\\n  CTL_PUSHCOPY|CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)\n\n/* Pattern controls that are mutually exclusive. At present these are all in\nthe first control word. Note that CTL_POSIX_NOSUB is always accompanied by\nCTL_POSIX, so it doesn't need its own entries. */\n\nstatic uint32_t exclusive_pat_controls[] = {\n  CTL_POSIX    | CTL_PUSH,\n  CTL_POSIX    | CTL_PUSHCOPY,\n  CTL_POSIX    | CTL_PUSHTABLESCOPY,\n  CTL_PUSH     | CTL_PUSHCOPY,\n  CTL_PUSH     | CTL_PUSHTABLESCOPY,\n  CTL_PUSHCOPY | CTL_PUSHTABLESCOPY,\n  CTL_EXPAND   | CTL_HEXPAT };\n\n/* Data controls that are mutually exclusive. At present these are all in the\nfirst control word. */\n\nstatic uint32_t exclusive_dat_controls[] = {\n  CTL_ALLUSEDTEXT        | CTL_STARTCHAR,\n  CTL_FINDLIMITS         | CTL_NULLCONTEXT,\n  CTL_FINDLIMITS_NOHEAP  | CTL_NULLCONTEXT };\n\n/* Table of single-character abbreviated modifiers. The index field is\ninitialized to -1, but the first time the modifier is encountered, it is filled\nin with the index of the full entry in modlist, to save repeated searching when\nprocessing multiple test items. This short list is searched serially, so its\norder does not matter. */\n\ntypedef struct c1modstruct {\n  const char *fullname;\n  uint32_t    onechar;\n  int         index;\n} c1modstruct;\n\nstatic c1modstruct c1modlist[] = {\n  { \"bincode\",         'B',           -1 },\n  { \"info\",            'I',           -1 },\n  { \"global\",          'g',           -1 },\n  { \"caseless\",        'i',           -1 },\n  { \"multiline\",       'm',           -1 },\n  { \"no_auto_capture\", 'n',           -1 },\n  { \"dotall\",          's',           -1 },\n  { \"extended\",        'x',           -1 }\n};\n\n#define C1MODLISTCOUNT sizeof(c1modlist)/sizeof(c1modstruct)\n\n/* Table of arguments for the -C command line option. Use macros to make the\ntable itself easier to read. */\n\n#if defined SUPPORT_PCRE2_8\n#define SUPPORT_8 1\n#endif\n#if defined SUPPORT_PCRE2_16\n#define SUPPORT_16 1\n#endif\n#if defined SUPPORT_PCRE2_32\n#define SUPPORT_32 1\n#endif\n\n#ifndef SUPPORT_8\n#define SUPPORT_8 0\n#endif\n#ifndef SUPPORT_16\n#define SUPPORT_16 0\n#endif\n#ifndef SUPPORT_32\n#define SUPPORT_32 0\n#endif\n\n#ifdef EBCDIC\n#define SUPPORT_EBCDIC 1\n#define EBCDIC_NL CHAR_LF\n#else\n#define SUPPORT_EBCDIC 0\n#define EBCDIC_NL 0\n#endif\n\n#ifdef NEVER_BACKSLASH_C\n#define BACKSLASH_C 0\n#else\n#define BACKSLASH_C 1\n#endif\n\ntypedef struct coptstruct {\n  const char *name;\n  uint32_t    type;\n  uint32_t    value;\n} coptstruct;\n\nenum { CONF_BSR,\n       CONF_FIX,\n       CONF_FIZ,\n       CONF_INT,\n       CONF_NL\n};\n\nstatic coptstruct coptlist[] = {\n  { \"backslash-C\", CONF_FIX, BACKSLASH_C },\n  { \"bsr\",         CONF_BSR, PCRE2_CONFIG_BSR },\n  { \"ebcdic\",      CONF_FIX, SUPPORT_EBCDIC },\n  { \"ebcdic-nl\",   CONF_FIZ, EBCDIC_NL },\n  { \"jit\",         CONF_INT, PCRE2_CONFIG_JIT },\n  { \"linksize\",    CONF_INT, PCRE2_CONFIG_LINKSIZE },\n  { \"newline\",     CONF_NL,  PCRE2_CONFIG_NEWLINE },\n  { \"pcre2-16\",    CONF_FIX, SUPPORT_16 },\n  { \"pcre2-32\",    CONF_FIX, SUPPORT_32 },\n  { \"pcre2-8\",     CONF_FIX, SUPPORT_8 },\n  { \"unicode\",     CONF_INT, PCRE2_CONFIG_UNICODE }\n};\n\n#define COPTLISTCOUNT sizeof(coptlist)/sizeof(coptstruct)\n\n#undef SUPPORT_8\n#undef SUPPORT_16\n#undef SUPPORT_32\n#undef SUPPORT_EBCDIC\n\n\n/* ----------------------- Static variables ------------------------ */\n\nstatic FILE *infile;\nstatic FILE *outfile;\n\nstatic const void *last_callout_mark;\nstatic PCRE2_JIT_STACK *jit_stack = NULL;\nstatic size_t jit_stack_size = 0;\n\nstatic BOOL first_callout;\nstatic BOOL jit_was_used;\nstatic BOOL restrict_for_perl_test = FALSE;\nstatic BOOL show_memory = FALSE;\n\nstatic int jitrc;                             /* Return from JIT compile */\nstatic int test_mode = DEFAULT_TEST_MODE;\nstatic int timeit = 0;\nstatic int timeitm = 0;\n\nclock_t total_compile_time = 0;\nclock_t total_jit_compile_time = 0;\nclock_t total_match_time = 0;\n\nstatic uint32_t code_unit_size;               /* Bytes */\nstatic uint32_t dfa_matched;\nstatic uint32_t forbid_utf = 0;\nstatic uint32_t maxlookbehind;\nstatic uint32_t max_oveccount;\nstatic uint32_t callout_count;\nstatic uint32_t maxcapcount;\n\nstatic uint16_t local_newline_default = 0;\n\nstatic VERSION_TYPE jittarget[VERSION_SIZE];\nstatic VERSION_TYPE version[VERSION_SIZE];\nstatic VERSION_TYPE uversion[VERSION_SIZE];\n\nstatic patctl def_patctl;\nstatic patctl pat_patctl;\nstatic datctl def_datctl;\nstatic datctl dat_datctl;\n\nstatic void *patstack[PATSTACKSIZE];\nstatic int patstacknext = 0;\n\nstatic void *malloclist[MALLOCLISTSIZE];\nstatic PCRE2_SIZE malloclistlength[MALLOCLISTSIZE];\nstatic uint32_t malloclistptr = 0;\n\n#ifdef SUPPORT_PCRE2_8\nstatic regex_t preg = { NULL, NULL, 0, 0, 0, 0 };\n#endif\n\nstatic int *dfa_workspace = NULL;\nstatic const uint8_t *locale_tables = NULL;\nstatic const uint8_t *use_tables = NULL;\nstatic uint8_t locale_name[32];\nstatic uint8_t *tables3 = NULL;         /* For binary-loaded tables */\nstatic uint32_t loadtables_length = 0;\n\n/* We need buffers for building 16/32-bit strings; 8-bit strings don't need\nrebuilding, but set up the same naming scheme for use in macros. The \"buffer\"\nbuffer is where all input lines are read. Its size is the same as pbuffer8.\nPattern lines are always copied to pbuffer8 for use in callouts, even if they\nare actually compiled from pbuffer16 or pbuffer32. */\n\nstatic size_t    pbuffer8_size  = 50000;        /* Initial size, bytes */\nstatic uint8_t  *pbuffer8 = NULL;\nstatic uint8_t  *buffer = NULL;\n\n/* The dbuffer is where all processed data lines are put. In non-8-bit modes it\nis cast as needed. For long data lines it grows as necessary. */\n\nstatic size_t dbuffer_size = 1u << 14;    /* Initial size, bytes */\nstatic uint8_t *dbuffer = NULL;\n\n\n/* ---------------- Mode-dependent variables -------------------*/\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_code_8             *compiled_code8;\nstatic pcre2_general_context_8  *general_context8, *general_context_copy8;\nstatic pcre2_compile_context_8  *pat_context8, *default_pat_context8;\nstatic pcre2_convert_context_8  *con_context8, *default_con_context8;\nstatic pcre2_match_context_8    *dat_context8, *default_dat_context8;\nstatic pcre2_match_data_8       *match_data8;\n#endif\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_code_16            *compiled_code16;\nstatic pcre2_general_context_16 *general_context16, *general_context_copy16;\nstatic pcre2_compile_context_16 *pat_context16, *default_pat_context16;\nstatic pcre2_convert_context_16 *con_context16, *default_con_context16;\nstatic pcre2_match_context_16   *dat_context16, *default_dat_context16;\nstatic pcre2_match_data_16      *match_data16;\nstatic PCRE2_SIZE pbuffer16_size = 0;   /* Set only when needed */\nstatic uint16_t *pbuffer16 = NULL;\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_code_32            *compiled_code32;\nstatic pcre2_general_context_32 *general_context32, *general_context_copy32;\nstatic pcre2_compile_context_32 *pat_context32, *default_pat_context32;\nstatic pcre2_convert_context_32 *con_context32, *default_con_context32;\nstatic pcre2_match_context_32   *dat_context32, *default_dat_context32;\nstatic pcre2_match_data_32      *match_data32;\nstatic PCRE2_SIZE pbuffer32_size = 0;   /* Set only when needed */\nstatic uint32_t *pbuffer32 = NULL;\n#endif\n\n\n/* ---------------- Macros that work in all modes ----------------- */\n\n#define CAST8VAR(x) CASTVAR(uint8_t *, x)\n#define SET(x,y) SETOP(x,y,=)\n#define SETPLUS(x,y) SETOP(x,y,+=)\n#define strlen8(x) strlen((char *)x)\n\n\n/* ---------------- Mode-dependent, runtime-testing macros ------------------*/\n\n/* Define macros for variables and functions that must be selected dynamically\ndepending on the mode setting (8, 16, 32). These are dependent on which modes\nare supported. */\n\n#if (defined (SUPPORT_PCRE2_8) + defined (SUPPORT_PCRE2_16) + \\\n     defined (SUPPORT_PCRE2_32)) >= 2\n\n/* ----- All three modes supported ----- */\n\n#if defined(SUPPORT_PCRE2_8) && defined(SUPPORT_PCRE2_16) && defined(SUPPORT_PCRE2_32)\n\n#define CASTFLD(t,a,b) ((test_mode == PCRE8_MODE)? (t)(G(a,8)->b) : \\\n  (test_mode == PCRE16_MODE)? (t)(G(a,16)->b) : (t)(G(a,32)->b))\n\n#define CASTVAR(t,x) ( \\\n  (test_mode == PCRE8_MODE)? (t)G(x,8) : \\\n  (test_mode == PCRE16_MODE)? (t)G(x,16) : (t)G(x,32))\n\n#define CODE_UNIT(a,b) ( \\\n  (test_mode == PCRE8_MODE)? (uint32_t)(((PCRE2_SPTR8)(a))[b]) : \\\n  (test_mode == PCRE16_MODE)? (uint32_t)(((PCRE2_SPTR16)(a))[b]) : \\\n  (uint32_t)(((PCRE2_SPTR32)(a))[b]))\n\n#define CONCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))\n\n#define CONVERT_COPY(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),(char *)b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),(char *)b,(c)*2); \\\n  else if (test_mode == PCRE32_MODE) \\\n    memcpy(G(a,32),(char *)b,(c)*4)\n\n#define DATCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))\n\n#define FLD(a,b) ((test_mode == PCRE8_MODE)? G(a,8)->b : \\\n  (test_mode == PCRE16_MODE)? G(a,16)->b : G(a,32)->b)\n\n#define PATCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))\n\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  if (test_mode == PCRE32_MODE) \\\n    lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \\\n  else if (test_mode == PCRE16_MODE) \\\n    lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \\\n  else \\\n    lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n\n#define PCHARSV(p, offset, len, utf, f) \\\n  if (test_mode == PCRE32_MODE) \\\n    (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \\\n  else if (test_mode == PCRE16_MODE) \\\n    (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \\\n  else \\\n    (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n     a = pcre2_callout_enumerate_8(compiled_code8, \\\n       (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n     a = pcre2_callout_enumerate_16(compiled_code16, \\\n       (int(*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c); \\\n  else \\\n     a = pcre2_callout_enumerate_32(compiled_code32, \\\n       (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)\n\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_code_copy_8(b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_code_copy_16(b); \\\n  else \\\n    G(a,32) = pcre2_code_copy_32(b)\n\n#define PCRE2_CODE_COPY_TO_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (void *)pcre2_code_copy_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (void *)pcre2_code_copy_16(G(b,16)); \\\n  else \\\n    a = (void *)pcre2_code_copy_32(G(b,32))\n\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (void *)pcre2_code_copy_with_tables_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (void *)pcre2_code_copy_with_tables_16(G(b,16)); \\\n  else \\\n    a = (void *)pcre2_code_copy_with_tables_32(G(b,32))\n\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g); \\\n  else \\\n    G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)\n\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a); \\\n  else pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)\n\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j); \\\n  else \\\n    a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)\n\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2)); \\\n  else \\\n    r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))\n\n#define PCRE2_GET_OVECTOR_COUNT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_get_ovector_count_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_get_ovector_count_16(G(b,16)); \\\n  else \\\n    a = pcre2_get_ovector_count_32(G(b,32))\n\n#define PCRE2_GET_STARTCHAR(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_get_startchar_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_get_startchar_16(G(b,16)); \\\n  else \\\n    a = pcre2_get_startchar_32(G(b,32))\n\n#define PCRE2_JIT_COMPILE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) r = pcre2_jit_compile_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) r = pcre2_jit_compile_16(G(a,16),b); \\\n  else r = pcre2_jit_compile_32(G(a,32),b)\n\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_jit_free_unused_memory_8(G(a,8)); \\\n  else if (test_mode == PCRE16_MODE) pcre2_jit_free_unused_memory_16(G(a,16)); \\\n  else pcre2_jit_free_unused_memory_32(G(a,32))\n\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \\\n  else \\\n    a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d); \\\n  else \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);\n\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c); \\\n  else \\\n    pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);\n\n#define PCRE2_JIT_STACK_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a); \\\n  else \\\n    pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);\n\n#define PCRE2_MAKETABLES(a,c) \\\n  if (test_mode == PCRE8_MODE) a = pcre2_maketables_8(G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) a = pcre2_maketables_16(G(c,16)); \\\n  else a = pcre2_maketables_32(G(c,32))\n\n#define PCRE2_MAKETABLES_FREE(c,a) \\\n  if (test_mode == PCRE8_MODE) pcre2_maketables_free_8(G(c,8),a); \\\n  else if (test_mode == PCRE16_MODE) pcre2_maketables_free_16(G(c,16),a); \\\n  else pcre2_maketables_free_32(G(c,32),a)\n\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \\\n  else \\\n    a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_match_data_create_8(b,G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_match_data_create_16(b,G(c,16)); \\\n  else \\\n    G(a,32) = pcre2_match_data_create_32(b,G(c,32))\n\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),G(c,16)); \\\n  else \\\n    G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),G(c,32))\n\n#define PCRE2_MATCH_DATA_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_match_data_free_8(G(a,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_match_data_free_16(G(a,16)); \\\n  else \\\n    pcre2_match_data_free_32(G(a,32))\n\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16)); \\\n  else \\\n    a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))\n\n#define PCRE2_PATTERN_INFO(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_pattern_info_8(G(b,8),c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_pattern_info_16(G(b,16),c,d); \\\n  else \\\n    a = pcre2_pattern_info_32(G(b,32),c,d)\n\n#define PCRE2_PRINTINT(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_printint_8(compiled_code8,outfile,a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_printint_16(compiled_code16,outfile,a); \\\n  else \\\n    pcre2_printint_32(compiled_code32,outfile,a)\n\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16)); \\\n  else \\\n    r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))\n\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16)); \\\n  else \\\n    r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))\n\n#define PCRE2_SERIALIZE_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_serialize_free_8(a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_serialize_free_16(a); \\\n  else \\\n    pcre2_serialize_free_32(a)\n\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_get_number_of_codes_8(a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_get_number_of_codes_16(a); \\\n  else \\\n    r = pcre2_serialize_get_number_of_codes_32(a); \\\n\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c); \\\n  else \\\n    pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c);\n\n#define PCRE2_SET_CHARACTER_TABLES(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_character_tables_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_character_tables_16(G(a,16),b); \\\n  else \\\n    pcre2_set_character_tables_32(G(a,32),b)\n\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_compile_recursion_guard_8(G(a,8),b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_compile_recursion_guard_16(G(a,16),b,c); \\\n  else \\\n    pcre2_set_compile_recursion_guard_32(G(a,32),b,c)\n\n#define PCRE2_SET_DEPTH_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_depth_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_depth_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_depth_limit_32(G(a,32),b)\n\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_set_glob_separator_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_set_glob_separator_16(G(a,16),b); \\\n  else \\\n    r = pcre2_set_glob_separator_32(G(a,32),b)\n\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_set_glob_escape_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_set_glob_escape_16(G(a,16),b); \\\n  else \\\n    r = pcre2_set_glob_escape_32(G(a,32),b)\n\n#define PCRE2_SET_HEAP_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_heap_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_heap_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_heap_limit_32(G(a,32),b)\n\n#define PCRE2_SET_MATCH_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_match_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_match_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_match_limit_32(G(a,32),b)\n\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_max_pattern_length_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_max_pattern_length_16(G(a,16),b); \\\n  else \\\n    pcre2_set_max_pattern_length_32(G(a,32),b)\n\n#define PCRE2_SET_OFFSET_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_offset_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_offset_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_offset_limit_32(G(a,32),b)\n\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_parens_nest_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_parens_nest_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_parens_nest_limit_32(G(a,32),b)\n\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_substitute_callout_8(G(a,8), \\\n      (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_substitute_callout_16(G(a,16), \\\n      (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c); \\\n  else \\\n    pcre2_set_substitute_callout_32(G(a,32), \\\n      (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)\n\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \\\n      (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \\\n      (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l); \\\n  else \\\n    a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \\\n      (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)\n\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e); \\\n  else \\\n    a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)\n\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e); \\\n  else \\\n    a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e)\n\n#define PCRE2_SUBSTRING_FREE(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_substring_free_8((PCRE2_UCHAR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_substring_free_16((PCRE2_UCHAR16 *)a); \\\n  else pcre2_substring_free_32((PCRE2_UCHAR32 *)a)\n\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e); \\\n  else \\\n    a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)\n\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e); \\\n  else \\\n    a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d); \\\n  else \\\n    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_length_bynumber_8(G(b,8),c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_length_bynumber_16(G(b,16),c,d); \\\n  else \\\n    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)\n\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d); \\\n  else \\\n    a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)\n\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_substring_list_free_8((PCRE2_SPTR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_substring_list_free_16((PCRE2_SPTR16 *)a); \\\n  else \\\n    pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)\n\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_number_from_name_8(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_number_from_name_16(G(b,16),G(c,16)); \\\n  else \\\n    a = pcre2_substring_number_from_name_32(G(b,32),G(c,32))\n\n#define PTR(x) ( \\\n  (test_mode == PCRE8_MODE)? (void *)G(x,8) : \\\n  (test_mode == PCRE16_MODE)? (void *)G(x,16) : \\\n  (void *)G(x,32))\n\n#define SETFLD(x,y,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8)->y = z; \\\n  else if (test_mode == PCRE16_MODE) G(x,16)->y = z; \\\n  else G(x,32)->y = z\n\n#define SETFLDVEC(x,y,v,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8)->y[v] = z; \\\n  else if (test_mode == PCRE16_MODE) G(x,16)->y[v] = z; \\\n  else G(x,32)->y[v] = z\n\n#define SETOP(x,y,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8) z y; \\\n  else if (test_mode == PCRE16_MODE) G(x,16) z y; \\\n  else G(x,32) z y\n\n#define SETCASTPTR(x,y) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(x,8) = (uint8_t *)(y); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(x,16) = (uint16_t *)(y); \\\n  else \\\n    G(x,32) = (uint32_t *)(y)\n\n#define STRLEN(p) ((test_mode == PCRE8_MODE)? ((int)strlen((char *)p)) : \\\n  (test_mode == PCRE16_MODE)? ((int)strlen16((PCRE2_SPTR16)p)) : \\\n  ((int)strlen32((PCRE2_SPTR32)p)))\n\n#define SUB1(a,b) \\\n  if (test_mode == PCRE8_MODE) G(a,8)(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16)); \\\n  else G(a,32)(G(b,32))\n\n#define SUB2(a,b,c) \\\n  if (test_mode == PCRE8_MODE) G(a,8)(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16),G(c,16)); \\\n  else G(a,32)(G(b,32),G(c,32))\n\n#define TEST(x,r,y) ( \\\n  (test_mode == PCRE8_MODE && G(x,8) r (y)) || \\\n  (test_mode == PCRE16_MODE && G(x,16) r (y)) || \\\n  (test_mode == PCRE32_MODE && G(x,32) r (y)))\n\n#define TESTFLD(x,f,r,y) ( \\\n  (test_mode == PCRE8_MODE && G(x,8)->f r (y)) || \\\n  (test_mode == PCRE16_MODE && G(x,16)->f r (y)) || \\\n  (test_mode == PCRE32_MODE && G(x,32)->f r (y)))\n\n\n/* ----- Two out of three modes are supported ----- */\n\n#else\n\n/* We can use some macro trickery to make a single set of definitions work in\nthe three different cases. */\n\n/* ----- 32-bit and 16-bit but not 8-bit supported ----- */\n\n#if defined(SUPPORT_PCRE2_32) && defined(SUPPORT_PCRE2_16)\n#define BITONE 32\n#define BITTWO 16\n\n/* ----- 32-bit and 8-bit but not 16-bit supported ----- */\n\n#elif defined(SUPPORT_PCRE2_32) && defined(SUPPORT_PCRE2_8)\n#define BITONE 32\n#define BITTWO 8\n\n/* ----- 16-bit and 8-bit but not 32-bit supported ----- */\n\n#else\n#define BITONE 16\n#define BITTWO 8\n#endif\n\n\n/* ----- Common macros for two-mode cases ----- */\n\n#define BYTEONE (BITONE/8)\n#define BYTETWO (BITTWO/8)\n\n#define CASTFLD(t,a,b) \\\n  ((test_mode == G(G(PCRE,BITONE),_MODE))? (t)(G(a,BITONE)->b) : \\\n    (t)(G(a,BITTWO)->b))\n\n#define CASTVAR(t,x) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n    (t)G(x,BITONE) : (t)G(x,BITTWO))\n\n#define CODE_UNIT(a,b) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  (uint32_t)(((G(PCRE2_SPTR,BITONE))(a))[b]) : \\\n  (uint32_t)(((G(PCRE2_SPTR,BITTWO))(a))[b]))\n\n#define CONCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_convert_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_convert_context_,BITTWO)))\n\n#define CONVERT_COPY(a,b,c) \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  memcpy(G(a,BITONE),(char *)b,(c)*BYTEONE) : \\\n  memcpy(G(a,BITTWO),(char *)b,(c)*BYTETWO)\n\n#define DATCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_match_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_match_context_,BITTWO)))\n\n#define FLD(a,b) \\\n  ((test_mode == G(G(PCRE,BITONE),_MODE))? G(a,BITONE)->b : G(a,BITTWO)->b)\n\n#define PATCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_compile_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_compile_context_,BITTWO)))\n\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    lv = G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \\\n  else \\\n    lv = G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)\n\n#define PCHARSV(p, offset, len, utf, f) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    (void)G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \\\n  else \\\n    (void)G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)\n\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n     a = G(pcre2_callout_enumerate,BITONE)(G(compiled_code,BITONE), \\\n       (int (*)(struct G(pcre2_callout_enumerate_block_,BITONE) *, void *))b,c); \\\n  else \\\n     a = G(pcre2_callout_enumerate,BITTWO)(G(compiled_code,BITTWO), \\\n       (int (*)(struct G(pcre2_callout_enumerate_block_,BITTWO) *, void *))b,c)\n\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_code_copy_,BITONE)(b); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_code_copy_,BITTWO)(b)\n\n#define PCRE2_CODE_COPY_TO_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (void *)G(pcre2_code_copy_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = (void *)G(pcre2_code_copy_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (void *)G(pcre2_code_copy_with_tables_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = (void *)G(pcre2_code_copy_with_tables_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_compile_,BITONE)(G(b,BITONE),c,d,e,f,g); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_compile_,BITTWO)(G(b,BITTWO),c,d,e,f,g)\n\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_converted_pattern_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \\\n  else \\\n    G(pcre2_converted_pattern_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)\n\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_dfa_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h,i,j); \\\n  else \\\n    a = G(pcre2_dfa_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h,i,j)\n\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_get_error_message_,BITONE)(a,G(b,BITONE),G(G(b,BITONE),_size/BYTEONE)); \\\n  else \\\n    r = G(pcre2_get_error_message_,BITTWO)(a,G(b,BITTWO),G(G(b,BITTWO),_size/BYTETWO))\n\n#define PCRE2_GET_OVECTOR_COUNT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_get_ovector_count_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = G(pcre2_get_ovector_count_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_GET_STARTCHAR(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_get_startchar_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = G(pcre2_get_startchar_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_JIT_COMPILE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_jit_compile_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_jit_compile_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_free_unused_memory_,BITONE)(G(a,BITONE)); \\\n  else \\\n    G(pcre2_jit_free_unused_memory_,BITTWO)(G(a,BITTWO))\n\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_jit_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h); \\\n  else \\\n    a = G(pcre2_jit_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h)\n\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITONE)(b,c,d); \\\n  else \\\n    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITTWO)(b,c,d); \\\n\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_stack_assign_,BITONE)(G(a,BITONE),(G(pcre2_jit_callback_,BITONE))b,c); \\\n  else \\\n    G(pcre2_jit_stack_assign_,BITTWO)(G(a,BITTWO),(G(pcre2_jit_callback_,BITTWO))b,c);\n\n#define PCRE2_JIT_STACK_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_stack_free_,BITONE)((G(pcre2_jit_stack_,BITONE) *)a); \\\n  else \\\n    G(pcre2_jit_stack_free_,BITTWO)((G(pcre2_jit_stack_,BITTWO) *)a);\n\n#define PCRE2_MAKETABLES(a,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_maketables_,BITONE)(G(c,BITONE)); \\\n  else \\\n    a = G(pcre2_maketables_,BITTWO)(G(c,BITTWO))\n\n#define PCRE2_MAKETABLES_FREE(c,a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_maketables_free_,BITONE)(G(c,BITONE),a); \\\n  else \\\n    G(pcre2_maketables_free_,BITTWO)(G(c,BITTWO),a)\n\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h); \\\n  else \\\n    a = G(pcre2_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h)\n\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_match_data_create_,BITONE)(b,G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_match_data_create_,BITTWO)(b,G(c,BITTWO))\n\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_match_data_create_from_pattern_,BITONE)(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_match_data_create_from_pattern_,BITTWO)(G(b,BITTWO),G(c,BITTWO))\n\n#define PCRE2_MATCH_DATA_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_match_data_free_,BITONE)(G(a,BITONE)); \\\n  else \\\n    G(pcre2_match_data_free_,BITTWO)(G(a,BITTWO))\n\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_pattern_convert_,BITONE)(G(b,BITONE),c,d,(G(PCRE2_UCHAR,BITONE) **)e,f,G(g,BITONE)); \\\n  else \\\n    a = G(pcre2_pattern_convert_,BITTWO)(G(b,BITTWO),c,d,(G(PCRE2_UCHAR,BITTWO) **)e,f,G(g,BITTWO))\n\n#define PCRE2_PATTERN_INFO(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_pattern_info_,BITONE)(G(b,BITONE),c,d); \\\n  else \\\n    a = G(pcre2_pattern_info_,BITTWO)(G(b,BITTWO),c,d)\n\n#define PCRE2_PRINTINT(a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_printint_,BITONE)(G(compiled_code,BITONE),outfile,a); \\\n  else \\\n    G(pcre2_printint_,BITTWO)(G(compiled_code,BITTWO),outfile,a)\n\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_decode_,BITONE)((G(pcre2_code_,BITONE) **)a,b,c,G(d,BITONE)); \\\n  else \\\n    r = G(pcre2_serialize_decode_,BITTWO)((G(pcre2_code_,BITTWO) **)a,b,c,G(d,BITTWO))\n\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_encode_,BITONE)((G(const pcre2_code_,BITONE) **)a,b,c,d,G(e,BITONE)); \\\n  else \\\n    r = G(pcre2_serialize_encode_,BITTWO)((G(const pcre2_code_,BITTWO) **)a,b,c,d,G(e,BITTWO))\n\n#define PCRE2_SERIALIZE_FREE(a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_serialize_free_,BITONE)(a); \\\n  else \\\n    G(pcre2_serialize_free_,BITTWO)(a)\n\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_get_number_of_codes_,BITONE)(a); \\\n  else \\\n    r = G(pcre2_serialize_get_number_of_codes_,BITTWO)(a)\n\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_callout_,BITONE)(G(a,BITONE), \\\n      (int (*)(G(pcre2_callout_block_,BITONE) *, void *))b,c); \\\n  else \\\n    G(pcre2_set_callout_,BITTWO)(G(a,BITTWO), \\\n      (int (*)(G(pcre2_callout_block_,BITTWO) *, void *))b,c);\n\n#define PCRE2_SET_CHARACTER_TABLES(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_character_tables_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_character_tables_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_compile_recursion_guard_,BITONE)(G(a,BITONE),b,c); \\\n  else \\\n    G(pcre2_set_compile_recursion_guard_,BITTWO)(G(a,BITTWO),b,c)\n\n#define PCRE2_SET_DEPTH_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_depth_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_depth_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_set_glob_escape_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_set_glob_escape_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_set_glob_separator_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_set_glob_separator_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_HEAP_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_heap_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_heap_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_MATCH_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_match_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_match_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_max_pattern_length_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_max_pattern_length_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_OFFSET_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_offset_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_offset_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_parens_nest_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_parens_nest_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_substitute_callout_,BITONE)(G(a,BITONE), \\\n      (int (*)(G(pcre2_substitute_callout_block_,BITONE) *, void *))b,c); \\\n  else \\\n    G(pcre2_set_substitute_callout_,BITTWO)(G(a,BITTWO), \\\n      (int (*)(G(pcre2_substitute_callout_block_,BITTWO) *, void *))b,c)\n\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substitute_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h,(G(PCRE2_SPTR,BITONE))i,j, \\\n      (G(PCRE2_UCHAR,BITONE) *)k,l); \\\n  else \\\n    a = G(pcre2_substitute_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h,(G(PCRE2_SPTR,BITTWO))i,j, \\\n      (G(PCRE2_UCHAR,BITTWO) *)k,l)\n\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_copy_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\\\n      (G(PCRE2_UCHAR,BITONE) *)d,e); \\\n  else \\\n    a = G(pcre2_substring_copy_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\\\n      (G(PCRE2_UCHAR,BITTWO) *)d,e)\n\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_copy_bynumber_,BITONE)(G(b,BITONE),c,\\\n      (G(PCRE2_UCHAR,BITONE) *)d,e); \\\n  else \\\n    a = G(pcre2_substring_copy_bynumber_,BITTWO)(G(b,BITTWO),c,\\\n      (G(PCRE2_UCHAR,BITTWO) *)d,e)\n\n#define PCRE2_SUBSTRING_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_substring_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \\\n  else G(pcre2_substring_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)\n\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_get_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\\\n      (G(PCRE2_UCHAR,BITONE) **)d,e); \\\n  else \\\n    a = G(pcre2_substring_get_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\\\n      (G(PCRE2_UCHAR,BITTWO) **)d,e)\n\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_get_bynumber_,BITONE)(G(b,BITONE),c,\\\n      (G(PCRE2_UCHAR,BITONE) **)d,e); \\\n  else \\\n    a = G(pcre2_substring_get_bynumber_,BITTWO)(G(b,BITTWO),c,\\\n      (G(PCRE2_UCHAR,BITTWO) **)d,e)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_length_byname_,BITONE)(G(b,BITONE),G(c,BITONE),d); \\\n  else \\\n    a = G(pcre2_substring_length_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),d)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_length_bynumber_,BITONE)(G(b,BITONE),c,d); \\\n  else \\\n    a = G(pcre2_substring_length_bynumber_,BITTWO)(G(b,BITTWO),c,d)\n\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_list_get_,BITONE)(G(b,BITONE), \\\n      (G(PCRE2_UCHAR,BITONE) ***)c,d); \\\n  else \\\n    a = G(pcre2_substring_list_get_,BITTWO)(G(b,BITTWO), \\\n      (G(PCRE2_UCHAR,BITTWO) ***)c,d)\n\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_substring_list_free_,BITONE)((G(PCRE2_SPTR,BITONE) *)a); \\\n  else \\\n    G(pcre2_substring_list_free_,BITTWO)((G(PCRE2_SPTR,BITTWO) *)a)\n\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_number_from_name_,BITONE)(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    a = G(pcre2_substring_number_from_name_,BITTWO)(G(b,BITTWO),G(c,BITTWO))\n\n#define PTR(x) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? (void *)G(x,BITONE) : \\\n  (void *)G(x,BITTWO))\n\n#define SETFLD(x,y,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)->y = z; \\\n  else G(x,BITTWO)->y = z\n\n#define SETFLDVEC(x,y,v,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)->y[v] = z; \\\n  else G(x,BITTWO)->y[v] = z\n\n#define SETOP(x,y,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE) z y; \\\n  else G(x,BITTWO) z y\n\n#define SETCASTPTR(x,y) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(x,BITONE) = (G(G(uint,BITONE),_t) *)(y); \\\n  else \\\n    G(x,BITTWO) = (G(G(uint,BITTWO),_t) *)(y)\n\n#define STRLEN(p) ((test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  G(strlen,BITONE)((G(PCRE2_SPTR,BITONE))p) : \\\n  G(strlen,BITTWO)((G(PCRE2_SPTR,BITTWO))p))\n\n#define SUB1(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE)(G(b,BITONE)); \\\n  else \\\n    G(a,BITTWO)(G(b,BITTWO))\n\n#define SUB2(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE))(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO))(G(b,BITTWO),G(c,BITTWO))\n\n#define TEST(x,r,y) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE) && G(x,BITONE) r (y)) || \\\n  (test_mode == G(G(PCRE,BITTWO),_MODE) && G(x,BITTWO) r (y)))\n\n#define TESTFLD(x,f,r,y) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE) && G(x,BITONE)->f r (y)) || \\\n  (test_mode == G(G(PCRE,BITTWO),_MODE) && G(x,BITTWO)->f r (y)))\n\n\n#endif  /* Two out of three modes */\n\n/* ----- End of cases where more than one mode is supported ----- */\n\n\n/* ----- Only 8-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_8\n#define CASTFLD(t,a,b) (t)(G(a,8)->b)\n#define CASTVAR(t,x) (t)G(x,8)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR8)(a))[b])\n#define CONCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,8),(char *)b, c)\n#define DATCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8))\n#define FLD(a,b) G(a,8)->b\n#define PATCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_8(compiled_code8, \\\n     (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,8) = pcre2_code_copy_8(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_8(G(b,8))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_8(G(b,8))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_8(G(b,8))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_8(G(b,8))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_8(G(a,8),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_8(G(a,8))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a);\n#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_8(G(c,8))\n#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_8(G(c,8),a)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,8) = pcre2_match_data_create_8(b,G(c,8))\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),G(c,8))\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_8(G(a,8))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_8(G(b,8),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_8(compiled_code8,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_8(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_8(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c)\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_8(G(a,8),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_8(G(a,8),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_8(G(a,8),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_8(G(a,8),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_8(G(a,8),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_8(G(a,8),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_8(G(a,8),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_8(G(a,8),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_8(G(a,8),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_8(G(a,8),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_8(G(a,8), \\\n    (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \\\n    (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e)\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_8((PCRE2_UCHAR8 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_8(G(b,8),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_8((PCRE2_SPTR8 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_8(G(b,8),G(c,8));\n#define PTR(x) (void *)G(x,8)\n#define SETFLD(x,y,z) G(x,8)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,8)->y[v] = z\n#define SETOP(x,y,z) G(x,8) z y\n#define SETCASTPTR(x,y) G(x,8) = (uint8_t *)(y)\n#define STRLEN(p) (int)strlen((char *)p)\n#define SUB1(a,b) G(a,8)(G(b,8))\n#define SUB2(a,b,c) G(a,8)(G(b,8),G(c,8))\n#define TEST(x,r,y) (G(x,8) r (y))\n#define TESTFLD(x,f,r,y) (G(x,8)->f r (y))\n\n\n/* ----- Only 16-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_16\n#define CASTFLD(t,a,b) (t)(G(a,16)->b)\n#define CASTVAR(t,x) (t)G(x,16)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR16)(a))[b])\n#define CONCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,16),(char *)b, (c)*2)\n#define DATCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16))\n#define FLD(a,b) G(a,16)->b\n#define PATCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_16(compiled_code16, \\\n     (int (*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,16) = pcre2_code_copy_16(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_16(G(b,16))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_16(G(b,16))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_16(G(b,16))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_16(G(b,16))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_16(G(a,16),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_16(G(a,16))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a);\n#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_16(G(c,16))\n#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_16(G(c,16),a)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,16) = pcre2_match_data_create_16(b,G(c,16))\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),G(c,16))\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_16(G(a,16))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_16(G(b,16),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_16(compiled_code16,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_16(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_16(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c);\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_16(G(a,16),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_16(G(a,16),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_16(G(a,16),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_16(G(a,16),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_16(G(a,16),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_16(G(a,16),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_16(G(a,16),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_16(G(a,16),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_16(G(a,16),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_16(G(a,16),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_16(G(a,16), \\\n    (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \\\n    (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e)\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_16((PCRE2_UCHAR16 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_16(G(b,16),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_16((PCRE2_SPTR16 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_16(G(b,16),G(c,16));\n#define PTR(x) (void *)G(x,16)\n#define SETFLD(x,y,z) G(x,16)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,16)->y[v] = z\n#define SETOP(x,y,z) G(x,16) z y\n#define SETCASTPTR(x,y) G(x,16) = (uint16_t *)(y)\n#define STRLEN(p) (int)strlen16((PCRE2_SPTR16)p)\n#define SUB1(a,b) G(a,16)(G(b,16))\n#define SUB2(a,b,c) G(a,16)(G(b,16),G(c,16))\n#define TEST(x,r,y) (G(x,16) r (y))\n#define TESTFLD(x,f,r,y) (G(x,16)->f r (y))\n\n\n/* ----- Only 32-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_32\n#define CASTFLD(t,a,b) (t)(G(a,32)->b)\n#define CASTVAR(t,x) (t)G(x,32)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR32)(a))[b])\n#define CONCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,32),(char *)b, (c)*4)\n#define DATCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))\n#define FLD(a,b) G(a,32)->b\n#define PATCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_32(compiled_code32, \\\n     (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,32) = pcre2_code_copy_32(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_32(G(b,32))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_32(G(b,32))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_32(G(b,32))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_32(G(b,32))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_32(G(a,32),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_32(G(a,32))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);\n#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_32(G(c,32))\n#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_32(G(c,32),a)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,32) = pcre2_match_data_create_32(b,G(c,32))\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),G(c,32))\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_32(G(a,32))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_32(G(b,32),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_32(compiled_code32,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_32(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_32(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c)\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_32(G(a,32),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_32(G(a,32),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_32(G(a,32),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_32(G(a,32),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_32(G(a,32),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_32(G(a,32),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_32(G(a,32),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_32(G(a,32),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_32(G(a,32),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_32(G(a,32),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_32(G(a,32), \\\n    (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \\\n    (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e);\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_32((PCRE2_UCHAR32 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_32(G(b,32),G(c,32));\n#define PTR(x) (void *)G(x,32)\n#define SETFLD(x,y,z) G(x,32)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,32)->y[v] = z\n#define SETOP(x,y,z) G(x,32) z y\n#define SETCASTPTR(x,y) G(x,32) = (uint32_t *)(y)\n#define STRLEN(p) (int)strlen32((PCRE2_SPTR32)p)\n#define SUB1(a,b) G(a,32)(G(b,32))\n#define SUB2(a,b,c) G(a,32)(G(b,32),G(c,32))\n#define TEST(x,r,y) (G(x,32) r (y))\n#define TESTFLD(x,f,r,y) (G(x,32)->f r (y))\n\n#endif\n\n/* ----- End of mode-specific function call macros ----- */\n\n\n\n\n/*************************************************\n*         Alternate character tables             *\n*************************************************/\n\n/* By default, the \"tables\" pointer in the compile context when calling\npcre2_compile() is not set (= NULL), thereby using the default tables of the\nlibrary. However, the tables modifier can be used to select alternate sets of\ntables, for different kinds of testing. Note that the locale modifier also\nadjusts the tables. */\n\n/* This is the set of tables distributed as default with PCRE2. It recognizes\nonly ASCII characters. */\n\nstatic const uint8_t tables1[] = {\n\n/* This table is a lower casing table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122, 91, 92, 93, 94, 95,\n   96, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,\n  200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,\n  216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,\n  232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table is a case flipping table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122, 91, 92, 93, 94, 95,\n   96, 65, 66, 67, 68, 69, 70, 71,\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,\n  200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,\n  216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,\n  232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table contains bit maps for various character classes. Each map is 32\nbytes long and the bits run from the least significant end of each byte. The\nclasses that have their own maps are: space, xdigit, digit, upper, lower, word,\ngraph, print, punct, and cntrl. Other classes are built from combinations. */\n\n  0x00,0x3e,0x00,0x00,0x01,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0x7e,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0xfe,0xff,0xff,0x07,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x07,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0xfe,0xff,0xff,0x87,0xfe,0xff,0xff,0x07,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xfe,0xff,0x00,0xfc,\n  0x01,0x00,0x00,0xf8,0x01,0x00,0x00,0x78,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n/* This table identifies various classes of character by individual bits:\n  0x01   white space character\n  0x02   letter\n  0x04   decimal digit\n  0x08   hexadecimal digit\n  0x10   alphanumeric or '_'\n  0x80   regular expression metacharacter or binary zero\n*/\n\n  0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*   0-  7 */\n  0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00, /*   8- 15 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  16- 23 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  24- 31 */\n  0x01,0x00,0x00,0x00,0x80,0x00,0x00,0x00, /*    - '  */\n  0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x00, /*  ( - /  */\n  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c, /*  0 - 7  */\n  0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x80, /*  8 - ?  */\n  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  @ - G  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  H - O  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  P - W  */\n  0x12,0x12,0x12,0x80,0x80,0x00,0x80,0x10, /*  X - _  */\n  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  ` - g  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  h - o  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  p - w  */\n  0x12,0x12,0x12,0x80,0x80,0x00,0x00,0x00, /*  x -127 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 128-135 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 136-143 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 144-151 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 152-159 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 160-167 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 168-175 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 176-183 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 184-191 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 192-199 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 200-207 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 208-215 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 216-223 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 224-231 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 232-239 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 240-247 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/* 248-255 */\n\n/* This is a set of tables that came originally from a Windows user. It seems\nto be at least an approximation of ISO 8859. In particular, there are\ncharacters greater than 128 that are marked as spaces, letters, etc. */\n\nstatic const uint8_t tables2[] = {\n0,1,2,3,4,5,6,7,\n8,9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,25,26,27,28,29,30,31,\n32,33,34,35,36,37,38,39,\n40,41,42,43,44,45,46,47,\n48,49,50,51,52,53,54,55,\n56,57,58,59,60,61,62,63,\n64,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,91,92,93,94,95,\n96,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,123,124,125,126,127,\n128,129,130,131,132,133,134,135,\n136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,\n152,153,154,155,156,157,158,159,\n160,161,162,163,164,165,166,167,\n168,169,170,171,172,173,174,175,\n176,177,178,179,180,181,182,183,\n184,185,186,187,188,189,190,191,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,215,\n248,249,250,251,252,253,254,223,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,247,\n248,249,250,251,252,253,254,255,\n0,1,2,3,4,5,6,7,\n8,9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,25,26,27,28,29,30,31,\n32,33,34,35,36,37,38,39,\n40,41,42,43,44,45,46,47,\n48,49,50,51,52,53,54,55,\n56,57,58,59,60,61,62,63,\n64,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,91,92,93,94,95,\n96,65,66,67,68,69,70,71,\n72,73,74,75,76,77,78,79,\n80,81,82,83,84,85,86,87,\n88,89,90,123,124,125,126,127,\n128,129,130,131,132,133,134,135,\n136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,\n152,153,154,155,156,157,158,159,\n160,161,162,163,164,165,166,167,\n168,169,170,171,172,173,174,175,\n176,177,178,179,180,181,182,183,\n184,185,186,187,188,189,190,191,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,215,\n248,249,250,251,252,253,254,223,\n192,193,194,195,196,197,198,199,\n200,201,202,203,204,205,206,207,\n208,209,210,211,212,213,214,247,\n216,217,218,219,220,221,222,255,\n0,62,0,0,1,0,0,0,\n0,0,0,0,0,0,0,0,\n32,0,0,0,1,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,255,3,\n126,0,0,0,126,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,255,3,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,12,2,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n254,255,255,7,0,0,0,0,\n0,0,0,0,0,0,0,0,\n255,255,127,127,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,254,255,255,7,\n0,0,0,0,0,4,32,4,\n0,0,0,128,255,255,127,255,\n0,0,0,0,0,0,255,3,\n254,255,255,135,254,255,255,7,\n0,0,0,0,0,4,44,6,\n255,255,127,255,255,255,127,255,\n0,0,0,0,254,255,255,255,\n255,255,255,255,255,255,255,127,\n0,0,0,0,254,255,255,255,\n255,255,255,255,255,255,255,255,\n0,2,0,0,255,255,255,255,\n255,255,255,255,255,255,255,127,\n0,0,0,0,255,255,255,255,\n255,255,255,255,255,255,255,255,\n0,0,0,0,254,255,0,252,\n1,0,0,248,1,0,0,120,\n0,0,0,0,254,255,255,255,\n0,0,128,0,0,0,128,0,\n255,255,255,255,0,0,0,0,\n0,0,0,0,0,0,0,128,\n255,255,255,255,0,0,0,0,\n0,0,0,0,0,0,0,0,\n128,0,0,0,0,0,0,0,\n0,1,1,0,1,1,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n1,0,0,0,128,0,0,0,\n128,128,128,128,0,0,128,0,\n28,28,28,28,28,28,28,28,\n28,28,0,0,0,0,0,128,\n0,26,26,26,26,26,26,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,128,128,0,128,16,\n0,26,26,26,26,26,26,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,128,128,0,0,0,\n0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n1,0,0,0,0,0,0,0,\n0,0,18,0,0,0,0,0,\n0,0,20,20,0,18,0,0,\n0,20,18,0,0,0,0,0,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,0,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,0,\n18,18,18,18,18,18,18,18\n};\n\n\n\n#if !defined(VPCOMPAT) && !defined(HAVE_MEMMOVE)\n/*************************************************\n*    Emulated memmove() for systems without it   *\n*************************************************/\n\n/* This function can make use of bcopy() if it is available. Otherwise do it by\nsteam, as there are some non-Unix environments that lack both memmove() and\nbcopy(). */\n\nstatic void *\nemulated_memmove(void *d, const void *s, size_t n)\n{\n#ifdef HAVE_BCOPY\nbcopy(s, d, n);\nreturn d;\n#else\nsize_t i;\nunsigned char *dest = (unsigned char *)d;\nconst unsigned char *src = (const unsigned char *)s;\nif (dest > src)\n  {\n  dest += n;\n  src += n;\n  for (i = 0; i < n; ++i) *(--dest) = *(--src);\n  return (void *)dest;\n  }\nelse\n  {\n  for (i = 0; i < n; ++i) *dest++ = *src++;\n  return (void *)(dest - n);\n  }\n#endif   /* not HAVE_BCOPY */\n}\n#undef memmove\n#define memmove(d,s,n) emulated_memmove(d,s,n)\n#endif   /* not VPCOMPAT && not HAVE_MEMMOVE */\n\n\n\n#ifndef HAVE_STRERROR\n/*************************************************\n*     Provide strerror() for non-ANSI libraries  *\n*************************************************/\n\n/* Some old-fashioned systems (e.g. SunOS4) didn't have strerror() in their\nlibraries. They may no longer be around, but just in case, we can try to\nprovide the same facility by this simple alternative function. */\n\nextern int   sys_nerr;\nextern char *sys_errlist[];\n\nchar *\nstrerror(int n)\n{\nif (n < 0 || n >= sys_nerr) return \"unknown error number\";\nreturn sys_errlist[n];\n}\n#endif /* HAVE_STRERROR */\n\n\n\n/*************************************************\n*            Local memory functions              *\n*************************************************/\n\n/* Alternative memory functions, to test functionality. */\n\nstatic void *my_malloc(PCRE2_SIZE size, void *data)\n{\nvoid *block = malloc(size);\n(void)data;\nif (show_memory)\n  {\n  if (block == NULL)\n    {\n    fprintf(outfile, \"** malloc() failed for %\" SIZ_FORM \"\\n\", size);\n    }\n  else\n    {\n    fprintf(outfile, \"malloc  %5\" SIZ_FORM, size);\n#ifdef DEBUG_SHOW_MALLOC_ADDRESSES\n    fprintf(outfile, \" %p\", block);   /* Not portable */\n#endif\n    if (malloclistptr < MALLOCLISTSIZE)\n      {\n      malloclist[malloclistptr] = block;\n      malloclistlength[malloclistptr++] = size;\n      }\n    else\n      fprintf(outfile, \" (not remembered)\");\n    fprintf(outfile, \"\\n\");\n    }\n  }\nreturn block;\n}\n\nstatic void my_free(void *block, void *data)\n{\n(void)data;\nif (show_memory && block != NULL)\n  {\n  uint32_t i, j;\n  BOOL found = FALSE;\n\n  fprintf(outfile, \"free\");\n  for (i = 0; i < malloclistptr; i++)\n    {\n    if (block == malloclist[i])\n      {\n      fprintf(outfile, \"    %5\" SIZ_FORM, malloclistlength[i]);\n      malloclistptr--;\n      for (j = i; j < malloclistptr; j++)\n        {\n        malloclist[j] = malloclist[j+1];\n        malloclistlength[j] = malloclistlength[j+1];\n        }\n      found = TRUE;\n      break;\n      }\n    }\n  if (!found) fprintf(outfile, \" unremembered block\");\n#ifdef DEBUG_SHOW_MALLOC_ADDRESSES\n  fprintf(outfile, \" %p\", block);  /* Not portable */\n#endif\n  fprintf(outfile, \"\\n\");\n  }\nfree(block);\n}\n\n\n\n/*************************************************\n*       Callback function for stack guard        *\n*************************************************/\n\n/* This is set up to be called from pcre2_compile() when the stackguard=n\nmodifier sets a value greater than zero. The test we do is whether the\nparenthesis nesting depth is greater than the value set by the modifier.\n\nArgument:  the current parenthesis nesting depth\nReturns:   non-zero to kill the compilation\n*/\n\nstatic int\nstack_guard(uint32_t depth, void *user_data)\n{\n(void)user_data;\nreturn depth > pat_patctl.stackguard_test;\n}\n\n\n/*************************************************\n*         JIT memory callback                    *\n*************************************************/\n\nstatic PCRE2_JIT_STACK*\njit_callback(void *arg)\n{\njit_was_used = TRUE;\nreturn (PCRE2_JIT_STACK *)arg;\n}\n\n\n/*************************************************\n*      Convert UTF-8 character to code point     *\n*************************************************/\n\n/* This function reads one or more bytes that represent a UTF-8 character,\nand returns the codepoint of that character. Note that the function supports\nthe original UTF-8 definition of RFC 2279, allowing for values in the range 0\nto 0x7fffffff, up to 6 bytes long. This makes it possible to generate\ncodepoints greater than 0x10ffff which are useful for testing PCRE2's error\nchecking, and also for generating 32-bit non-UTF data values above the UTF\nlimit.\n\nArgument:\n  utf8bytes   a pointer to the byte vector\n  vptr        a pointer to an int to receive the value\n\nReturns:      >  0 => the number of bytes consumed\n              -6 to 0 => malformed UTF-8 character at offset = (-return)\n*/\n\nstatic int\nutf82ord(PCRE2_SPTR8 utf8bytes, uint32_t *vptr)\n{\nuint32_t c = *utf8bytes++;\nuint32_t d = c;\nint i, j, s;\n\nfor (i = -1; i < 6; i++)               /* i is number of additional bytes */\n  {\n  if ((d & 0x80) == 0) break;\n  d <<= 1;\n  }\n\nif (i == -1) { *vptr = c; return 1; }  /* ascii character */\nif (i == 0 || i == 6) return 0;        /* invalid UTF-8 */\n\n/* i now has a value in the range 1-5 */\n\ns = 6*i;\nd = (c & utf8_table3[i]) << s;\n\nfor (j = 0; j < i; j++)\n  {\n  c = *utf8bytes++;\n  if ((c & 0xc0) != 0x80) return -(j+1);\n  s -= 6;\n  d |= (c & 0x3f) << s;\n  }\n\n/* Check that encoding was the correct unique one */\n\nfor (j = 0; j < utf8_table1_size; j++)\n  if (d <= (uint32_t)utf8_table1[j]) break;\nif (j != i) return -(i+1);\n\n/* Valid value */\n\n*vptr = d;\nreturn i+1;\n}\n\n\n\n/*************************************************\n*             Print one character                *\n*************************************************/\n\n/* Print a single character either literally, or as a hex escape, and count how\nmany printed characters are used.\n\nArguments:\n  c            the character\n  utf          TRUE in UTF mode\n  f            the FILE to print to, or NULL just to count characters\n\nReturns:       number of characters written\n*/\n\nstatic int\npchar(uint32_t c, BOOL utf, FILE *f)\n{\nint n = 0;\nchar tempbuffer[16];\n\nif (PRINTOK(c))\n  {\n  if (f != NULL) fprintf(f, \"%c\", c);\n  return 1;\n  }\n\nif (c < 0x100)\n  {\n  if (utf)\n    {\n    if (f != NULL) fprintf(f, \"\\\\x{%02x}\", c);\n    return 6;\n    }\n  else\n    {\n    if (f != NULL) fprintf(f, \"\\\\x%02x\", c);\n    return 4;\n    }\n  }\n\nif (f != NULL) n = fprintf(f, \"\\\\x{%02x}\", c);\n  else n = sprintf(tempbuffer, \"\\\\x{%02x}\", c);\n\nreturn n >= 0 ? n : 0;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*    Find length of 0-terminated 16-bit string   *\n*************************************************/\n\nstatic size_t strlen16(PCRE2_SPTR16 p)\n{\nPCRE2_SPTR16 pp = p;\nwhile (*pp != 0) pp++;\nreturn (int)(pp - p);\n}\n#endif  /* SUPPORT_PCRE2_16 */\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*    Find length of 0-terminated 32-bit string   *\n*************************************************/\n\nstatic size_t strlen32(PCRE2_SPTR32 p)\n{\nPCRE2_SPTR32 pp = p;\nwhile (*pp != 0) pp++;\nreturn (int)(pp - p);\n}\n#endif  /* SUPPORT_PCRE2_32 */\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*         Print 8-bit character string           *\n*************************************************/\n\n/* Must handle UTF-8 strings in utf8 mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, this function just\ncounts chars without printing (because pchar() does that). */\n\nstatic int pchars8(PCRE2_SPTR8 p, int length, BOOL utf, FILE *f)\n{\nuint32_t c = 0;\nint yield = 0;\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  if (utf)\n    {\n    int rc = utf82ord(p, &c);\n    if (rc > 0 && rc <= length + 1)   /* Mustn't run over the end */\n      {\n      length -= rc - 1;\n      p += rc;\n      yield += pchar(c, utf, f);\n      continue;\n      }\n    }\n  c = *p++;\n  yield += pchar(c, utf, f);\n  }\n\nreturn yield;\n}\n#endif\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*           Print 16-bit character string        *\n*************************************************/\n\n/* Must handle UTF-16 strings in utf mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, just counts chars\nwithout printing. */\n\nstatic int pchars16(PCRE2_SPTR16 p, int length, BOOL utf, FILE *f)\n{\nint yield = 0;\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  uint32_t c = *p++ & 0xffff;\n  if (utf && c >= 0xD800 && c < 0xDC00 && length > 0)\n    {\n    int d = *p & 0xffff;\n    if (d >= 0xDC00 && d <= 0xDFFF)\n      {\n      c = ((c & 0x3ff) << 10) + (d & 0x3ff) + 0x10000;\n      length--;\n      p++;\n      }\n    }\n  yield += pchar(c, utf, f);\n  }\nreturn yield;\n}\n#endif  /* SUPPORT_PCRE2_16 */\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*           Print 32-bit character string        *\n*************************************************/\n\n/* Must handle UTF-32 strings in utf mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, just counts chars\nwithout printing. */\n\nstatic int pchars32(PCRE2_SPTR32 p, int length, BOOL utf, FILE *f)\n{\nint yield = 0;\n(void)(utf);  /* Avoid compiler warning */\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  uint32_t c = *p++;\n  yield += pchar(c, utf, f);\n  }\nreturn yield;\n}\n#endif  /* SUPPORT_PCRE2_32 */\n\n\n\n\n/*************************************************\n*       Convert character value to UTF-8         *\n*************************************************/\n\n/* This function takes an integer value in the range 0 - 0x7fffffff\nand encodes it as a UTF-8 character in 0 to 6 bytes. It is needed even when the\n8-bit library is not supported, to generate UTF-8 output for non-ASCII\ncharacters.\n\nArguments:\n  cvalue     the character value\n  utf8bytes  pointer to buffer for result - at least 6 bytes long\n\nReturns:     number of characters placed in the buffer\n*/\n\nstatic int\nord2utf8(uint32_t cvalue, uint8_t *utf8bytes)\n{\nint i, j;\nif (cvalue > 0x7fffffffu)\n  return -1;\nfor (i = 0; i < utf8_table1_size; i++)\n  if (cvalue <= (uint32_t)utf8_table1[i]) break;\nutf8bytes += i;\nfor (j = i; j > 0; j--)\n {\n *utf8bytes-- = 0x80 | (cvalue & 0x3f);\n cvalue >>= 6;\n }\n*utf8bytes = utf8_table2[i] | cvalue;\nreturn i + 1;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*           Convert string to 16-bit             *\n*************************************************/\n\n/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using\nthe original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and\ncode values from 0 to 0x7fffffff. However, values greater than the later UTF\nlimit of 0x10ffff cause an error. In non-UTF mode the input is interpreted as\nUTF-8 if the utf8_input modifier is set, but an error is generated for values\ngreater than 0xffff.\n\nIf all the input bytes are ASCII, the space needed for a 16-bit string is\nexactly double the 8-bit size. Otherwise, the size needed for a 16-bit string\nis no more than double, because up to 0xffff uses no more than 3 bytes in UTF-8\nbut possibly 4 in UTF-16. Higher values use 4 bytes in UTF-8 and up to 4 bytes\nin UTF-16. The result is always left in pbuffer16. Impose a minimum size to\nsave repeated re-sizing.\n\nNote that this function does not object to surrogate values. This is\ndeliberate; it makes it possible to construct UTF-16 strings that are invalid,\nfor the purpose of testing that they are correctly faulted.\n\nArguments:\n  p          points to a byte string\n  utf        true in UTF mode\n  lenptr     points to number of bytes in the string (excluding trailing zero)\n\nReturns:     0 on success, with the length updated to the number of 16-bit\n               data items used (excluding the trailing zero)\n             OR -1 if a UTF-8 string is malformed\n             OR -2 if a value > 0x10ffff is encountered in UTF mode\n             OR -3 if a value > 0xffff is encountered when not in UTF mode\n*/\n\nstatic int\nto16(uint8_t *p, int utf, PCRE2_SIZE *lenptr)\n{\nuint16_t *pp;\nPCRE2_SIZE len = *lenptr;\n\nif (pbuffer16_size < 2*len + 2)\n  {\n  if (pbuffer16 != NULL) free(pbuffer16);\n  pbuffer16_size = 2*len + 2;\n  if (pbuffer16_size < 4096) pbuffer16_size = 4096;\n  pbuffer16 = (uint16_t *)malloc(pbuffer16_size);\n  if (pbuffer16 == NULL)\n    {\n    fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer16\\n\",\n      pbuffer16_size);\n    exit(1);\n    }\n  }\n\npp = pbuffer16;\nif (!utf && (pat_patctl.control & CTL_UTF8_INPUT) == 0)\n  {\n  for (; len > 0; len--) *pp++ = *p++;\n  }\nelse while (len > 0)\n  {\n  uint32_t c;\n  int chlen = utf82ord(p, &c);\n  if (chlen <= 0) return -1;\n  if (!utf && c > 0xffff) return -3;\n  if (c > 0x10ffff) return -2;\n  p += chlen;\n  len -= chlen;\n  if (c < 0x10000) *pp++ = c; else\n    {\n    c -= 0x10000;\n    *pp++ = 0xD800 | (c >> 10);\n    *pp++ = 0xDC00 | (c & 0x3ff);\n    }\n  }\n\n*pp = 0;\n*lenptr = pp - pbuffer16;\nreturn 0;\n}\n#endif\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*           Convert string to 32-bit             *\n*************************************************/\n\n/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using\nthe original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and\ncode values from 0 to 0x7fffffff. However, values greater than the later UTF\nlimit of 0x10ffff cause an error.\n\nIn non-UTF mode the input is interpreted as UTF-8 if the utf8_input modifier\nis set, and no limit is imposed. There is special interpretation of the 0xff\nbyte (which is illegal in UTF-8) in this case: it causes the top bit of the\nnext character to be set. This provides a way of generating 32-bit characters\ngreater than 0x7fffffff.\n\nIf all the input bytes are ASCII, the space needed for a 32-bit string is\nexactly four times the 8-bit size. Otherwise, the size needed for a 32-bit\nstring is no more than four times, because the number of characters must be\nless than the number of bytes. The result is always left in pbuffer32. Impose a\nminimum size to save repeated re-sizing.\n\nNote that this function does not object to surrogate values. This is\ndeliberate; it makes it possible to construct UTF-32 strings that are invalid,\nfor the purpose of testing that they are correctly faulted.\n\nArguments:\n  p          points to a byte string\n  utf        true in UTF mode\n  lenptr     points to number of bytes in the string (excluding trailing zero)\n\nReturns:     0 on success, with the length updated to the number of 32-bit\n               data items used (excluding the trailing zero)\n             OR -1 if a UTF-8 string is malformed\n             OR -2 if a value > 0x10ffff is encountered in UTF mode\n*/\n\nstatic int\nto32(uint8_t *p, int utf, PCRE2_SIZE *lenptr)\n{\nuint32_t *pp;\nPCRE2_SIZE len = *lenptr;\n\nif (pbuffer32_size < 4*len + 4)\n  {\n  if (pbuffer32 != NULL) free(pbuffer32);\n  pbuffer32_size = 4*len + 4;\n  if (pbuffer32_size < 8192) pbuffer32_size = 8192;\n  pbuffer32 = (uint32_t *)malloc(pbuffer32_size);\n  if (pbuffer32 == NULL)\n    {\n    fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer32\\n\",\n      pbuffer32_size);\n    exit(1);\n    }\n  }\n\npp = pbuffer32;\n\nif (!utf && (pat_patctl.control & CTL_UTF8_INPUT) == 0)\n  {\n  for (; len > 0; len--) *pp++ = *p++;\n  }\n\nelse while (len > 0)\n  {\n  int chlen;\n  uint32_t c;\n  uint32_t topbit = 0;\n  if (!utf && *p == 0xff && len > 1)\n    {\n    topbit = 0x80000000u;\n    p++;\n    len--;\n    }\n  chlen = utf82ord(p, &c);\n  if (chlen <= 0) return -1;\n  if (utf && c > 0x10ffff) return -2;\n  p += chlen;\n  len -= chlen;\n  *pp++ = c | topbit;\n  }\n\n*pp = 0;\n*lenptr = pp - pbuffer32;\nreturn 0;\n}\n#endif /* SUPPORT_PCRE2_32 */\n\n\n\n/* This function is no longer used. Keep it around for a while, just in case it\nneeds to be re-instated. */\n\n#ifdef NEVERNEVERNEVER\n\n/*************************************************\n*         Move back by so many characters        *\n*************************************************/\n\n/* Given a code unit offset in a subject string, move backwards by a number of\ncharacters, and return the resulting offset.\n\nArguments:\n  subject   pointer to the string\n  offset    start offset\n  count     count to move back by\n  utf       TRUE if in UTF mode\n\nReturns:   a possibly changed offset\n*/\n\nstatic PCRE2_SIZE\nbackchars(uint8_t *subject, PCRE2_SIZE offset, uint32_t count, BOOL utf)\n{\nif (!utf || test_mode == PCRE32_MODE)\n  return (count >= offset)? 0 : (offset - count);\n\nelse if (test_mode == PCRE8_MODE)\n  {\n  PCRE2_SPTR8 pp = (PCRE2_SPTR8)subject + offset;\n  for (; count > 0 && pp > (PCRE2_SPTR8)subject; count--)\n    {\n    pp--;\n    while ((*pp & 0xc0) == 0x80) pp--;\n    }\n  return pp - (PCRE2_SPTR8)subject;\n  }\n\nelse  /* 16-bit mode */\n  {\n  PCRE2_SPTR16 pp = (PCRE2_SPTR16)subject + offset;\n  for (; count > 0 && pp > (PCRE2_SPTR16)subject; count--)\n    {\n    pp--;\n    if ((*pp & 0xfc00) == 0xdc00) pp--;\n    }\n  return pp - (PCRE2_SPTR16)subject;\n  }\n}\n#endif  /* NEVERNEVERNEVER */\n\n\n\n/*************************************************\n*           Expand input buffers                 *\n*************************************************/\n\n/* This function doubles the size of the input buffer and the buffer for\nkeeping an 8-bit copy of patterns (pbuffer8), and copies the current buffers to\nthe new ones.\n\nArguments: none\nReturns:   nothing (aborts if malloc() fails)\n*/\n\nstatic void\nexpand_input_buffers(void)\n{\nint new_pbuffer8_size = 2*pbuffer8_size;\nuint8_t *new_buffer = (uint8_t *)malloc(new_pbuffer8_size);\nuint8_t *new_pbuffer8 = (uint8_t *)malloc(new_pbuffer8_size);\n\nif (new_buffer == NULL || new_pbuffer8 == NULL)\n  {\n  fprintf(stderr, \"pcre2test: malloc(%d) failed\\n\", new_pbuffer8_size);\n  exit(1);\n  }\n\nmemcpy(new_buffer, buffer, pbuffer8_size);\nmemcpy(new_pbuffer8, pbuffer8, pbuffer8_size);\n\npbuffer8_size = new_pbuffer8_size;\n\nfree(buffer);\nfree(pbuffer8);\n\nbuffer = new_buffer;\npbuffer8 = new_pbuffer8;\n}\n\n\n\n/*************************************************\n*        Read or extend an input line            *\n*************************************************/\n\n/* Input lines are read into buffer, but both patterns and data lines can be\ncontinued over multiple input lines. In addition, if the buffer fills up, we\nwant to automatically expand it so as to be able to handle extremely large\nlines that are needed for certain stress tests, although this is less likely\nnow that there are repetition features for both patterns and data. When the\ninput buffer is expanded, the other two buffers must also be expanded likewise,\nand the contents of pbuffer, which are a copy of the input for callouts, must\nbe preserved (for when expansion happens for a data line). This is not the most\noptimal way of handling this, but hey, this is just a test program!\n\nArguments:\n  f            the file to read\n  start        where in buffer to start (this *must* be within buffer)\n  prompt       for stdin or readline()\n\nReturns:       pointer to the start of new data\n               could be a copy of start, or could be moved\n               NULL if no data read and EOF reached\n*/\n\nstatic uint8_t *\nextend_inputline(FILE *f, uint8_t *start, const char *prompt)\n{\nuint8_t *here = start;\n\nfor (;;)\n  {\n  size_t rlen = (size_t)(pbuffer8_size - (here - buffer));\n\n  if (rlen > 1000)\n    {\n    size_t dlen;\n\n    /* If libreadline or libedit support is required, use readline() to read a\n    line if the input is a terminal. Note that readline() removes the trailing\n    newline, so we must put it back again, to be compatible with fgets(). */\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\n    if (INTERACTIVE(f))\n      {\n      size_t len;\n      char *s = readline(prompt);\n      if (s == NULL) return (here == start)? NULL : start;\n      len = strlen(s);\n      if (len > 0) add_history(s);\n      if (len > rlen - 1) len = rlen - 1;\n      memcpy(here, s, len);\n      here[len] = '\\n';\n      here[len+1] = 0;\n      free(s);\n      }\n    else\n#endif\n\n    /* Read the next line by normal means, prompting if the file is a tty. */\n\n      {\n      if (INTERACTIVE(f)) printf(\"%s\", prompt);\n      if (fgets((char *)here, rlen,  f) == NULL)\n        return (here == start)? NULL : start;\n      }\n\n    dlen = strlen((char *)here);\n    here += dlen;\n\n    /* Check for end of line reached. Take care not to read data from before\n    start (dlen will be zero for a file starting with a binary zero). */\n\n    if (here > start && here[-1] == '\\n') return start;\n\n    /* If we have not read a newline when reading a file, we have either filled\n    the buffer or reached the end of the file. We can detect the former by\n    checking that the string fills the buffer, and the latter by feof(). If\n    neither of these is true, it means we read a binary zero which has caused\n    strlen() to give a short length. This is a hard error because pcre2test\n    expects to work with C strings. */\n\n    if (!INTERACTIVE(f) && dlen < rlen - 1 && !feof(f))\n      {\n      fprintf(outfile, \"** Binary zero encountered in input\\n\");\n      fprintf(outfile, \"** pcre2test run abandoned\\n\");\n      exit(1);\n      }\n    }\n\n  else\n    {\n    size_t start_offset = start - buffer;\n    size_t here_offset = here - buffer;\n    expand_input_buffers();\n    start = buffer + start_offset;\n    here = buffer + here_offset;\n    }\n  }\n\n/* Control never gets here */\n}\n\n\n\n/*************************************************\n*         Case-independent strncmp() function    *\n*************************************************/\n\n/*\nArguments:\n  s         first string\n  t         second string\n  n         number of characters to compare\n\nReturns:    < 0, = 0, or > 0, according to the comparison\n*/\n\nstatic int\nstrncmpic(const uint8_t *s, const uint8_t *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c != 0) return c;\n  }\nreturn 0;\n}\n\n\n\n/*************************************************\n*          Scan the main modifier list           *\n*************************************************/\n\n/* This function searches the modifier list for a long modifier name.\n\nArgument:\n  p         start of the name\n  lenp      length of the name\n\nReturns:    an index in the modifier list, or -1 on failure\n*/\n\nstatic int\nscan_modifiers(const uint8_t *p, unsigned int len)\n{\nint bot = 0;\nint top = MODLISTCOUNT;\n\nwhile (top > bot)\n  {\n  int mid = (bot + top)/2;\n  unsigned int mlen = strlen(modlist[mid].name);\n  int c = strncmp((char *)p, modlist[mid].name, (len < mlen)? len : mlen);\n  if (c == 0)\n    {\n    if (len == mlen) return mid;\n    c = (int)len - (int)mlen;\n    }\n  if (c > 0) bot = mid + 1; else top = mid;\n  }\n\nreturn -1;\n\n}\n\n\n\n/*************************************************\n*        Check a modifer and find its field      *\n*************************************************/\n\n/* This function is called when a modifier has been identified. We check that\nit is allowed here and find the field that is to be changed.\n\nArguments:\n  m          the modifier list entry\n  ctx        CTX_PAT     => pattern context\n             CTX_POPPAT  => pattern context for popped pattern\n             CTX_DEFPAT  => default pattern context\n             CTX_DAT     => data context\n             CTX_DEFDAT  => default data context\n  pctl       point to pattern control block\n  dctl       point to data control block\n  c          a single character or 0\n\nReturns:     a field pointer or NULL\n*/\n\nstatic void *\ncheck_modifier(modstruct *m, int ctx, patctl *pctl, datctl *dctl, uint32_t c)\n{\nvoid *field = NULL;\nPCRE2_SIZE offset = m->offset;\n\nif (restrict_for_perl_test) switch(m->which)\n  {\n  case MOD_PNDP:\n  case MOD_PATP:\n  case MOD_DATP:\n  case MOD_PDP:\n  break;\n\n  default:\n  fprintf(outfile, \"** '%s' is not allowed in a Perl-compatible test\\n\",\n    m->name);\n  return NULL;\n  }\n\nswitch (m->which)\n  {\n  case MOD_CTC:  /* Compile context modifier */\n  if (ctx == CTX_DEFPAT) field = PTR(default_pat_context);\n    else if (ctx == CTX_PAT) field = PTR(pat_context);\n  break;\n\n  case MOD_CTM:  /* Match context modifier */\n  if (ctx == CTX_DEFDAT) field = PTR(default_dat_context);\n    else if (ctx == CTX_DAT) field = PTR(dat_context);\n  break;\n\n  case MOD_DAT:    /* Data line modifier */\n  case MOD_DATP:   /* Allowed for Perl test */\n  if (dctl != NULL) field = dctl;\n  break;\n\n  case MOD_PAT:    /* Pattern modifier */\n  case MOD_PATP:   /* Allowed for Perl test */\n  if (pctl != NULL) field = pctl;\n  break;\n\n  case MOD_PD:   /* Pattern or data line modifier */\n  case MOD_PDP:  /* Ditto, allowed for Perl test */\n  case MOD_PND:  /* Ditto, but not default pattern */\n  case MOD_PNDP: /* Ditto, allowed for Perl test */\n  if (dctl != NULL) field = dctl;\n    else if (pctl != NULL && (m->which == MOD_PD || m->which == MOD_PDP ||\n             ctx != CTX_DEFPAT))\n      field = pctl;\n  break;\n  }\n\nif (field == NULL)\n  {\n  if (c == 0)\n    fprintf(outfile, \"** '%s' is not valid here\\n\", m->name);\n  else\n    fprintf(outfile, \"** /%c is not valid here\\n\", c);\n  return NULL;\n  }\n\nreturn (char *)field + offset;\n}\n\n\n\n/*************************************************\n*            Decode a modifier list              *\n*************************************************/\n\n/* A pointer to a control block is NULL when called in cases when that block is\nnot relevant. They are never all relevant in one call. At least one of patctl\nand datctl is NULL. The second argument specifies which context to use for\nmodifiers that apply to contexts.\n\nArguments:\n  p          point to modifier string\n  ctx        CTX_PAT     => pattern context\n             CTX_POPPAT  => pattern context for popped pattern\n             CTX_DEFPAT  => default pattern context\n             CTX_DAT     => data context\n             CTX_DEFDAT  => default data context\n  pctl       point to pattern control block\n  dctl       point to data control block\n\nReturns: TRUE if successful decode, FALSE otherwise\n*/\n\nstatic BOOL\ndecode_modifiers(uint8_t *p, int ctx, patctl *pctl, datctl *dctl)\n{\nuint8_t *ep, *pp;\nlong li;\nunsigned long uli;\nBOOL first = TRUE;\n\nfor (;;)\n  {\n  void *field;\n  modstruct *m;\n  BOOL off = FALSE;\n  unsigned int i, len;\n  int index;\n  char *endptr;\n\n  /* Skip white space and commas. */\n\n  while (isspace(*p) || *p == ',') p++;\n  if (*p == 0) break;\n\n  /* Find the end of the item; lose trailing whitespace at end of line. */\n\n  for (ep = p; *ep != 0 && *ep != ','; ep++);\n  if (*ep == 0)\n    {\n    while (ep > p && isspace(ep[-1])) ep--;\n    *ep = 0;\n    }\n\n  /* Remember if the first character is '-'. */\n\n  if (*p == '-')\n    {\n    off = TRUE;\n    p++;\n    }\n\n  /* Find the length of a full-length modifier name, and scan for it. */\n\n  pp = p;\n  while (pp < ep && *pp != '=') pp++;\n  index = scan_modifiers(p, pp - p);\n\n  /* If the first modifier is unrecognized, try to interpret it as a sequence\n  of single-character abbreviated modifiers. None of these modifiers have any\n  associated data. They just set options or control bits. */\n\n  if (index < 0)\n    {\n    uint32_t cc;\n    uint8_t *mp = p;\n\n    if (!first)\n      {\n      fprintf(outfile, \"** Unrecognized modifier '%.*s'\\n\", (int)(ep-p), p);\n      if (ep - p == 1)\n        fprintf(outfile, \"** Single-character modifiers must come first\\n\");\n      return FALSE;\n      }\n\n    for (cc = *p; cc != ',' && cc != '\\n' && cc != 0; cc = *(++p))\n      {\n      for (i = 0; i < C1MODLISTCOUNT; i++)\n        if (cc == c1modlist[i].onechar) break;\n\n      if (i >= C1MODLISTCOUNT)\n        {\n        fprintf(outfile, \"** Unrecognized modifier '%c' in '%.*s'\\n\",\n          *p, (int)(ep-mp), mp);\n        return FALSE;\n        }\n\n      if (c1modlist[i].index >= 0)\n        {\n        index = c1modlist[i].index;\n        }\n\n      else\n        {\n        index = scan_modifiers((uint8_t *)(c1modlist[i].fullname),\n          strlen(c1modlist[i].fullname));\n        if (index < 0)\n          {\n          fprintf(outfile, \"** Internal error: single-character equivalent \"\n            \"modifier '%s' not found\\n\", c1modlist[i].fullname);\n          return FALSE;\n          }\n        c1modlist[i].index = index;     /* Cache for next time */\n        }\n\n      field = check_modifier(modlist + index, ctx, pctl, dctl, *p);\n      if (field == NULL) return FALSE;\n\n      /* /x is a special case; a second appearance changes PCRE2_EXTENDED to\n      PCRE2_EXTENDED_MORE. */\n\n      if (cc == 'x' && (*((uint32_t *)field) & PCRE2_EXTENDED) != 0)\n        {\n        *((uint32_t *)field) &= ~PCRE2_EXTENDED;\n        *((uint32_t *)field) |= PCRE2_EXTENDED_MORE;\n        }\n      else\n        *((uint32_t *)field) |= modlist[index].value;\n      }\n\n    continue;    /* With tne next (fullname) modifier */\n    }\n\n  /* We have a match on a full-name modifier. Check for the existence of data\n  when needed. */\n\n  m = modlist + index;      /* Save typing */\n  if (m->type != MOD_CTL && m->type != MOD_OPT &&\n      (m->type != MOD_IND || *pp == '='))\n    {\n    if (*pp++ != '=')\n      {\n      fprintf(outfile, \"** '=' expected after '%s'\\n\", m->name);\n      return FALSE;\n      }\n    if (off)\n      {\n      fprintf(outfile, \"** '-' is not valid for '%s'\\n\", m->name);\n      return FALSE;\n      }\n    }\n\n  /* These on/off types have no data. */\n\n  else if (*pp != ',' && *pp != '\\n' && *pp != ' ' && *pp != 0)\n    {\n    fprintf(outfile, \"** Unrecognized modifier '%.*s'\\n\", (int)(ep-p), p);\n    return FALSE;\n    }\n\n  /* Set the data length for those types that have data. Then find the field\n  that is to be set. If check_modifier() returns NULL, it has already output an\n  error message. */\n\n  len = ep - pp;\n  field = check_modifier(m, ctx, pctl, dctl, 0);\n  if (field == NULL) return FALSE;\n\n  /* Process according to data type. */\n\n  switch (m->type)\n    {\n    case MOD_CTL:\n    case MOD_OPT:\n    if (off) *((uint32_t *)field) &= ~m->value;\n      else *((uint32_t *)field) |= m->value;\n    break;\n\n    case MOD_BSR:\n    if (len == 7 && strncmpic(pp, (const uint8_t *)\"default\", 7) == 0)\n      {\n#ifdef BSR_ANYCRLF\n      *((uint16_t *)field) = PCRE2_BSR_ANYCRLF;\n#else\n      *((uint16_t *)field) = PCRE2_BSR_UNICODE;\n#endif\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 &= ~CTL2_BSR_SET;\n        else dctl->control2 &= ~CTL2_BSR_SET;\n      }\n    else\n      {\n      if (len == 7 && strncmpic(pp, (const uint8_t *)\"anycrlf\", 7) == 0)\n        *((uint16_t *)field) = PCRE2_BSR_ANYCRLF;\n      else if (len == 7 && strncmpic(pp, (const uint8_t *)\"unicode\", 7) == 0)\n        *((uint16_t *)field) = PCRE2_BSR_UNICODE;\n      else goto INVALID_VALUE;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 |= CTL2_BSR_SET;\n        else dctl->control2 |= CTL2_BSR_SET;\n      }\n    pp = ep;\n    break;\n\n    case MOD_CHR:  /* A single character */\n    *((uint32_t *)field) = *pp++;\n    break;\n\n    case MOD_CON:  /* A convert type/options list */\n    for (;; pp++)\n      {\n      uint8_t *colon = (uint8_t *)strchr((const char *)pp, ':');\n      len = ((colon != NULL && colon < ep)? colon:ep) - pp;\n      for (i = 0; i < convertlistcount; i++)\n        {\n        if (strncmpic(pp, (const uint8_t *)convertlist[i].name, len) == 0)\n          {\n          if (*((uint32_t *)field) == CONVERT_UNSET)\n            *((uint32_t *)field) = convertlist[i].option;\n          else\n            *((uint32_t *)field) |= convertlist[i].option;\n          break;\n          }\n        }\n      if (i >= convertlistcount) goto INVALID_VALUE;\n      pp += len;\n      if (*pp != ':') break;\n      }\n    break;\n\n    case MOD_IN2:    /* One or two unsigned integers */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n    ((uint32_t *)field)[0] = (uint32_t)uli;\n    if (*endptr == ':')\n      {\n      uli = strtoul((const char *)endptr+1, &endptr, 10);\n      if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n      ((uint32_t *)field)[1] = (uint32_t)uli;\n      }\n    else ((uint32_t *)field)[1] = 0;\n    pp = (uint8_t *)endptr;\n    break;\n\n    /* PCRE2_SIZE_MAX is usually SIZE_MAX, which may be greater, equal to, or\n    less than ULONG_MAX. So first test for overflowing the long int, and then\n    test for overflowing PCRE2_SIZE_MAX if it is smaller than ULONG_MAX. */\n\n    case MOD_SIZ:    /* PCRE2_SIZE value */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (uli == ULONG_MAX) goto INVALID_VALUE;\n#if ULONG_MAX > PCRE2_SIZE_MAX\n    if (uli > PCRE2_SIZE_MAX) goto INVALID_VALUE;\n#endif\n    *((PCRE2_SIZE *)field) = (PCRE2_SIZE)uli;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_IND:    /* Unsigned integer with default */\n    if (len == 0)\n      {\n      *((uint32_t *)field) = (uint32_t)(m->value);\n      break;\n      }\n    /* Fall through */\n\n    case MOD_INT:    /* Unsigned integer */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n    *((uint32_t *)field) = (uint32_t)uli;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_INS:   /* Signed integer */\n    if (!isdigit(*pp) && *pp != '-') goto INVALID_VALUE;\n    li = strtol((const char *)pp, &endptr, 10);\n    if (S32OVERFLOW(li)) goto INVALID_VALUE;\n    *((int32_t *)field) = (int32_t)li;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_NL:\n    for (i = 0; i < sizeof(newlines)/sizeof(char *); i++)\n      if (len == strlen(newlines[i]) &&\n        strncmpic(pp, (const uint8_t *)newlines[i], len) == 0) break;\n    if (i >= sizeof(newlines)/sizeof(char *)) goto INVALID_VALUE;\n    if (i == 0)\n      {\n      *((uint16_t *)field) = NEWLINE_DEFAULT;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 &= ~CTL2_NL_SET;\n        else dctl->control2 &= ~CTL2_NL_SET;\n      }\n    else\n      {\n      *((uint16_t *)field) = i;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 |= CTL2_NL_SET;\n        else dctl->control2 |= CTL2_NL_SET;\n      }\n    pp = ep;\n    break;\n\n    case MOD_NN:              /* Name or (signed) number; may be several */\n    if (isdigit(*pp) || *pp == '-')\n      {\n      int ct = MAXCPYGET - 1;\n      int32_t value;\n      li = strtol((const char *)pp, &endptr, 10);\n      if (S32OVERFLOW(li)) goto INVALID_VALUE;\n      value = (int32_t)li;\n      field = (char *)field - m->offset + m->value;      /* Adjust field ptr */\n      if (value >= 0)                                    /* Add new number */\n        {\n        while (*((int32_t *)field) >= 0 && ct-- > 0)   /* Skip previous */\n          field = (char *)field + sizeof(int32_t);\n        if (ct <= 0)\n          {\n          fprintf(outfile, \"** Too many numeric '%s' modifiers\\n\", m->name);\n          return FALSE;\n          }\n        }\n      *((int32_t *)field) = value;\n      if (ct > 0) ((int32_t *)field)[1] = -1;\n      pp = (uint8_t *)endptr;\n      }\n\n    /* Multiple strings are put end to end. */\n\n    else\n      {\n      char *nn = (char *)field;\n      if (len > 0)                    /* Add new name */\n        {\n        if (len > MAX_NAME_SIZE)\n          {\n          fprintf(outfile, \"** Group name in '%s' is too long\\n\", m->name);\n          return FALSE;\n          }\n        while (*nn != 0) nn += strlen(nn) + 1;\n        if (nn + len + 2 - (char *)field > LENCPYGET)\n          {\n          fprintf(outfile, \"** Too many characters in named '%s' modifiers\\n\",\n            m->name);\n          return FALSE;\n          }\n        memcpy(nn, pp, len);\n        }\n      nn[len] = 0 ;\n      nn[len+1] = 0;\n      pp = ep;\n      }\n    break;\n\n    case MOD_STR:\n    if (len + 1 > m->value)\n      {\n      fprintf(outfile, \"** Overlong value for '%s' (max %d code units)\\n\",\n        m->name, m->value - 1);\n      return FALSE;\n      }\n    memcpy(field, pp, len);\n    ((uint8_t *)field)[len] = 0;\n    pp = ep;\n    break;\n    }\n\n  if (*pp != ',' && *pp != '\\n' && *pp != ' ' && *pp != 0)\n    {\n    fprintf(outfile, \"** Comma expected after modifier item '%s'\\n\", m->name);\n    return FALSE;\n    }\n\n  p = pp;\n  first = FALSE;\n\n  if (ctx == CTX_POPPAT &&\n     (pctl->options != 0 ||\n      pctl->tables_id != 0 ||\n      pctl->locale[0] != 0 ||\n      (pctl->control & NOTPOP_CONTROLS) != 0))\n    {\n    fprintf(outfile, \"** '%s' is not valid here\\n\", m->name);\n    return FALSE;\n    }\n  }\n\nreturn TRUE;\n\nINVALID_VALUE:\nfprintf(outfile, \"** Invalid value in '%.*s'\\n\", (int)(ep-p), p);\nreturn FALSE;\n}\n\n\n/*************************************************\n*             Get info from a pattern            *\n*************************************************/\n\n/* A wrapped call to pcre2_pattern_info(), applied to the current compiled\npattern.\n\nArguments:\n  what        code for the required information\n  where       where to put the answer\n  unsetok     PCRE2_ERROR_UNSET is an \"expected\" result\n\nReturns:      the return from pcre2_pattern_info()\n*/\n\nstatic int\npattern_info(int what, void *where, BOOL unsetok)\n{\nint rc;\nPCRE2_PATTERN_INFO(rc, compiled_code, what, NULL);  /* Exercise the code */\nPCRE2_PATTERN_INFO(rc, compiled_code, what, where);\nif (rc >= 0) return 0;\nif (rc != PCRE2_ERROR_UNSET || !unsetok)\n  {\n  fprintf(outfile, \"Error %d from pcre2_pattern_info_%d(%d)\\n\", rc, test_mode,\n    what);\n  if (rc == PCRE2_ERROR_BADMODE)\n    fprintf(outfile, \"Running in %d-bit mode but pattern was compiled in \"\n      \"%d-bit mode\\n\", test_mode,\n      8 * (FLD(compiled_code, flags) & PCRE2_MODE_MASK));\n  }\nreturn rc;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*             Show something in a list           *\n*************************************************/\n\n/* This function just helps to keep the code that uses it tidier. It's used for\nvarious lists of things where there needs to be introductory text before the\nfirst item. As these calls are all in the POSIX-support code, they happen only\nwhen 8-bit mode is supported. */\n\nstatic void\nprmsg(const char **msg, const char *s)\n{\nfprintf(outfile, \"%s %s\", *msg, s);\n*msg = \"\";\n}\n#endif  /* SUPPORT_PCRE2_8 */\n\n\n\n/*************************************************\n*                Show control bits               *\n*************************************************/\n\n/* Called for mutually exclusive controls and for unsupported POSIX controls.\nBecause the bits are unique, this can be used for both pattern and data control\nwords.\n\nArguments:\n  controls    control bits\n  controls2   more control bits\n  before      text to print before\n\nReturns:      nothing\n*/\n\nstatic void\nshow_controls(uint32_t controls, uint32_t controls2, const char *before)\n{\nfprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  before,\n  ((controls & CTL_AFTERTEXT) != 0)? \" aftertext\" : \"\",\n  ((controls & CTL_ALLAFTERTEXT) != 0)? \" allaftertext\" : \"\",\n  ((controls & CTL_ALLCAPTURES) != 0)? \" allcaptures\" : \"\",\n  ((controls & CTL_ALLUSEDTEXT) != 0)? \" allusedtext\" : \"\",\n  ((controls2 & CTL2_ALLVECTOR) != 0)? \" allvector\" : \"\",\n  ((controls & CTL_ALTGLOBAL) != 0)? \" altglobal\" : \"\",\n  ((controls & CTL_BINCODE) != 0)? \" bincode\" : \"\",\n  ((controls2 & CTL2_BSR_SET) != 0)? \" bsr\" : \"\",\n  ((controls & CTL_CALLOUT_CAPTURE) != 0)? \" callout_capture\" : \"\",\n  ((controls2 & CTL2_CALLOUT_EXTRA) != 0)? \" callout_extra\" : \"\",\n  ((controls & CTL_CALLOUT_INFO) != 0)? \" callout_info\" : \"\",\n  ((controls & CTL_CALLOUT_NONE) != 0)? \" callout_none\" : \"\",\n  ((controls2 & CTL2_CALLOUT_NO_WHERE) != 0)? \" callout_no_where\" : \"\",\n  ((controls & CTL_DFA) != 0)? \" dfa\" : \"\",\n  ((controls & CTL_EXPAND) != 0)? \" expand\" : \"\",\n  ((controls & CTL_FINDLIMITS) != 0)? \" find_limits\" : \"\",\n  ((controls & CTL_FINDLIMITS_NOHEAP) != 0)? \" find_limits_noheap\" : \"\",\n  ((controls2 & CTL2_FRAMESIZE) != 0)? \" framesize\" : \"\",\n  ((controls & CTL_FULLBINCODE) != 0)? \" fullbincode\" : \"\",\n  ((controls & CTL_GETALL) != 0)? \" getall\" : \"\",\n  ((controls & CTL_GLOBAL) != 0)? \" global\" : \"\",\n  ((controls & CTL_HEXPAT) != 0)? \" hex\" : \"\",\n  ((controls & CTL_INFO) != 0)? \" info\" : \"\",\n  ((controls & CTL_JITFAST) != 0)? \" jitfast\" : \"\",\n  ((controls & CTL_JITVERIFY) != 0)? \" jitverify\" : \"\",\n  ((controls & CTL_MARK) != 0)? \" mark\" : \"\",\n  ((controls & CTL_MEMORY) != 0)? \" memory\" : \"\",\n  ((controls2 & CTL2_NL_SET) != 0)? \" newline\" : \"\",\n  ((controls & CTL_NULLCONTEXT) != 0)? \" null_context\" : \"\",\n  ((controls2 & CTL2_NULL_REPLACEMENT) != 0)? \" null_replacement\" : \"\",\n  ((controls2 & CTL2_NULL_SUBJECT) != 0)? \" null_subject\" : \"\",\n  ((controls & CTL_POSIX) != 0)? \" posix\" : \"\",\n  ((controls & CTL_POSIX_NOSUB) != 0)? \" posix_nosub\" : \"\",\n  ((controls & CTL_PUSH) != 0)? \" push\" : \"\",\n  ((controls & CTL_PUSHCOPY) != 0)? \" pushcopy\" : \"\",\n  ((controls & CTL_PUSHTABLESCOPY) != 0)? \" pushtablescopy\" : \"\",\n  ((controls & CTL_STARTCHAR) != 0)? \" startchar\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_CALLOUT) != 0)? \" substitute_callout\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_EXTENDED) != 0)? \" substitute_extended\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_LITERAL) != 0)? \" substitute_literal\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_MATCHED) != 0)? \" substitute_matched\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)? \" substitute_overflow_length\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) != 0)? \" substitute_replacement_only\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) != 0)? \" substitute_unknown_unset\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_UNSET_EMPTY) != 0)? \" substitute_unset_empty\" : \"\",\n  ((controls & CTL_USE_LENGTH) != 0)? \" use_length\" : \"\",\n  ((controls & CTL_UTF8_INPUT) != 0)? \" utf8_input\" : \"\",\n  ((controls & CTL_ZERO_TERMINATE) != 0)? \" zero_terminate\" : \"\");\n}\n\n\n\n/*************************************************\n*                Show compile options            *\n*************************************************/\n\n/* Called from show_pattern_info() and for unsupported POSIX options.\n\nArguments:\n  options     an options word\n  before      text to print before\n  after       text to print after\n\nReturns:      nothing\n*/\n\nstatic void\nshow_compile_options(uint32_t options, const char *before, const char *after)\n{\nif (options == 0) fprintf(outfile, \"%s <none>%s\", before, after);\nelse fprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  before,\n  ((options & PCRE2_ALT_BSUX) != 0)? \" alt_bsux\" : \"\",\n  ((options & PCRE2_ALT_CIRCUMFLEX) != 0)? \" alt_circumflex\" : \"\",\n  ((options & PCRE2_ALT_VERBNAMES) != 0)? \" alt_verbnames\" : \"\",\n  ((options & PCRE2_ALLOW_EMPTY_CLASS) != 0)? \" allow_empty_class\" : \"\",\n  ((options & PCRE2_ANCHORED) != 0)? \" anchored\" : \"\",\n  ((options & PCRE2_AUTO_CALLOUT) != 0)? \" auto_callout\" : \"\",\n  ((options & PCRE2_CASELESS) != 0)? \" caseless\" : \"\",\n  ((options & PCRE2_DOLLAR_ENDONLY) != 0)? \" dollar_endonly\" : \"\",\n  ((options & PCRE2_DOTALL) != 0)? \" dotall\" : \"\",\n  ((options & PCRE2_DUPNAMES) != 0)? \" dupnames\" : \"\",\n  ((options & PCRE2_ENDANCHORED) != 0)? \" endanchored\" : \"\",\n  ((options & PCRE2_EXTENDED) != 0)? \" extended\" : \"\",\n  ((options & PCRE2_EXTENDED_MORE) != 0)? \" extended_more\" : \"\",\n  ((options & PCRE2_FIRSTLINE) != 0)? \" firstline\" : \"\",\n  ((options & PCRE2_LITERAL) != 0)? \" literal\" : \"\",\n  ((options & PCRE2_MATCH_INVALID_UTF) != 0)? \" match_invalid_utf\" : \"\",\n  ((options & PCRE2_MATCH_UNSET_BACKREF) != 0)? \" match_unset_backref\" : \"\",\n  ((options & PCRE2_MULTILINE) != 0)? \" multiline\" : \"\",\n  ((options & PCRE2_NEVER_BACKSLASH_C) != 0)? \" never_backslash_c\" : \"\",\n  ((options & PCRE2_NEVER_UCP) != 0)? \" never_ucp\" : \"\",\n  ((options & PCRE2_NEVER_UTF) != 0)? \" never_utf\" : \"\",\n  ((options & PCRE2_NO_AUTO_CAPTURE) != 0)? \" no_auto_capture\" : \"\",\n  ((options & PCRE2_NO_AUTO_POSSESS) != 0)? \" no_auto_possess\" : \"\",\n  ((options & PCRE2_NO_DOTSTAR_ANCHOR) != 0)? \" no_dotstar_anchor\" : \"\",\n  ((options & PCRE2_NO_UTF_CHECK) != 0)? \" no_utf_check\" : \"\",\n  ((options & PCRE2_NO_START_OPTIMIZE) != 0)? \" no_start_optimize\" : \"\",\n  ((options & PCRE2_UCP) != 0)? \" ucp\" : \"\",\n  ((options & PCRE2_UNGREEDY) != 0)? \" ungreedy\" : \"\",\n  ((options & PCRE2_USE_OFFSET_LIMIT) != 0)? \" use_offset_limit\" : \"\",\n  ((options & PCRE2_UTF) != 0)? \" utf\" : \"\",\n  after);\n}\n\n\n/*************************************************\n*           Show compile extra options           *\n*************************************************/\n\n/* Called from show_pattern_info() and for unsupported POSIX options.\n\nArguments:\n  options     an options word\n  before      text to print before\n  after       text to print after\n\nReturns:      nothing\n*/\n\nstatic void\nshow_compile_extra_options(uint32_t options, const char *before,\n  const char *after)\n{\nif (options == 0) fprintf(outfile, \"%s <none>%s\", before, after);\nelse fprintf(outfile, \"%s%s%s%s%s%s%s%s\",\n  before,\n  ((options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) != 0)? \" allow_surrogate_escapes\" : \"\",\n  ((options & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) != 0)? \" bad_escape_is_literal\" : \"\",\n  ((options & PCRE2_EXTRA_ALT_BSUX) != 0)? \" extra_alt_bsux\" : \"\",\n  ((options & PCRE2_EXTRA_MATCH_WORD) != 0)? \" match_word\" : \"\",\n  ((options & PCRE2_EXTRA_MATCH_LINE) != 0)? \" match_line\" : \"\",\n  ((options & PCRE2_EXTRA_ESCAPED_CR_IS_LF) != 0)? \" escaped_cr_is_lf\" : \"\",\n  after);\n}\n\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*                Show match options              *\n*************************************************/\n\n/* Called for unsupported POSIX options. */\n\nstatic void\nshow_match_options(uint32_t options)\n{\nfprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  ((options & PCRE2_ANCHORED) != 0)? \" anchored\" : \"\",\n  ((options & PCRE2_COPY_MATCHED_SUBJECT) != 0)? \" copy_matched_subject\" : \"\",\n  ((options & PCRE2_DFA_RESTART) != 0)? \" dfa_restart\" : \"\",\n  ((options & PCRE2_DFA_SHORTEST) != 0)? \" dfa_shortest\" : \"\",\n  ((options & PCRE2_ENDANCHORED) != 0)? \" endanchored\" : \"\",\n  ((options & PCRE2_NO_JIT) != 0)? \" no_jit\" : \"\",\n  ((options & PCRE2_NO_UTF_CHECK) != 0)? \" no_utf_check\" : \"\",\n  ((options & PCRE2_NOTBOL) != 0)? \" notbol\" : \"\",\n  ((options & PCRE2_NOTEMPTY) != 0)? \" notempty\" : \"\",\n  ((options & PCRE2_NOTEMPTY_ATSTART) != 0)? \" notempty_atstart\" : \"\",\n  ((options & PCRE2_NOTEOL) != 0)? \" noteol\" : \"\",\n  ((options & PCRE2_PARTIAL_HARD) != 0)? \" partial_hard\" : \"\",\n  ((options & PCRE2_PARTIAL_SOFT) != 0)? \" partial_soft\" : \"\");\n}\n#endif  /* SUPPORT_PCRE2_8 */\n\n\n\n/*************************************************\n*      Show memory usage info for a pattern      *\n*************************************************/\n\nstatic void\nshow_memory_info(void)\n{\nuint32_t name_count, name_entry_size;\nsize_t size, cblock_size;\n\n/* One of the test_mode values will always be true, but to stop a compiler\nwarning we must initialize cblock_size. */\n\ncblock_size = 0;\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE) cblock_size = sizeof(pcre2_real_code_8);\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE) cblock_size = sizeof(pcre2_real_code_16);\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE) cblock_size = sizeof(pcre2_real_code_32);\n#endif\n\n(void)pattern_info(PCRE2_INFO_SIZE, &size, FALSE);\n(void)pattern_info(PCRE2_INFO_NAMECOUNT, &name_count, FALSE);\n(void)pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &name_entry_size, FALSE);\n\n/* The uint32_t variables are cast before multiplying to stop code analyzers\ngrumbling about potential overflow. */\n\nfprintf(outfile, \"Memory allocation (code space): %\" SIZ_FORM \"\\n\", size -\n  (size_t)name_count * (size_t)name_entry_size * (size_t)code_unit_size -\n  cblock_size);\n\nif (pat_patctl.jit != 0)\n  {\n  (void)pattern_info(PCRE2_INFO_JITSIZE, &size, FALSE);\n  fprintf(outfile, \"Memory allocation (JIT code): %\" SIZ_FORM \"\\n\", size);\n  }\n}\n\n\n\n/*************************************************\n*       Show frame size info for a pattern       *\n*************************************************/\n\nstatic void\nshow_framesize(void)\n{\nsize_t frame_size;\n(void)pattern_info(PCRE2_INFO_FRAMESIZE, &frame_size, FALSE);\nfprintf(outfile, \"Frame size for pcre2_match(): %\" SIZ_FORM \"\\n\", frame_size);\n}\n\n\n\n/*************************************************\n*         Get and output an error message        *\n*************************************************/\n\nstatic BOOL\nprint_error_message(int errorcode, const char *before, const char *after)\n{\nint len;\nPCRE2_GET_ERROR_MESSAGE(len, errorcode, pbuffer);\nif (len < 0)\n  {\n  fprintf(outfile, \"\\n** pcre2test internal error: cannot interpret error \"\n    \"number\\n** Unexpected return (%d) from pcre2_get_error_message()\\n\", len);\n  }\nelse\n  {\n  fprintf(outfile, \"%s\", before);\n  PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, outfile);\n  fprintf(outfile, \"%s\", after);\n  }\nreturn len >= 0;\n}\n\n\n/*************************************************\n*     Callback function for callout enumeration  *\n*************************************************/\n\n/* The only differences in the callout emumeration block for different code\nunit widths are that the pointers to the subject, the most recent MARK, and a\ncallout argument string point to strings of the appropriate width. Casts can be\nused to deal with this.\n\nArgument:\n  cb            pointer to enumerate block\n  callout_data  user data\n\nReturns:    0\n*/\n\nstatic int callout_callback(pcre2_callout_enumerate_block_8 *cb,\n  void *callout_data)\n{\nuint32_t i;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n\n(void)callout_data;  /* Not currently displayed */\n\nfprintf(outfile, \"Callout \");\nif (cb->callout_string != NULL)\n  {\n  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);\n  fprintf(outfile, \"%c\", delimiter);\n  PCHARSV(cb->callout_string, 0,\n    cb->callout_string_length, utf, outfile);\n  for (i = 0; callout_start_delims[i] != 0; i++)\n    if (delimiter == callout_start_delims[i])\n      {\n      delimiter = callout_end_delims[i];\n      break;\n      }\n  fprintf(outfile, \"%c  \", delimiter);\n  }\nelse fprintf(outfile, \"%d  \", cb->callout_number);\n\nfprintf(outfile, \"%.*s\\n\",\n  (int)((cb->next_item_length == 0)? 1 : cb->next_item_length),\n  pbuffer8 + cb->pattern_position);\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*        Show information about a pattern        *\n*************************************************/\n\n/* This function is called after a pattern has been compiled if any of the\ninformation-requesting controls have been set.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nshow_pattern_info(void)\n{\nuint32_t compile_options, overall_options, extra_options;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n\nif ((pat_patctl.control & (CTL_BINCODE|CTL_FULLBINCODE)) != 0)\n  {\n  fprintf(outfile, \"------------------------------------------------------------------\\n\");\n  PCRE2_PRINTINT((pat_patctl.control & CTL_FULLBINCODE) != 0);\n  }\n\nif ((pat_patctl.control & CTL_INFO) != 0)\n  {\n  int rc;\n  void *nametable;\n  uint8_t *start_bits;\n  BOOL heap_limit_set, match_limit_set, depth_limit_set;\n  uint32_t backrefmax, bsr_convention, capture_count, first_ctype, first_cunit,\n    hasbackslashc, hascrorlf, jchanged, last_ctype, last_cunit, match_empty,\n    depth_limit, heap_limit, match_limit, minlength, nameentrysize, namecount,\n    newline_convention;\n\n  /* Exercise the error route. */\n\n  PCRE2_PATTERN_INFO(rc, compiled_code, 999, NULL);\n  (void)rc;\n\n  /* These info requests may return PCRE2_ERROR_UNSET. */\n\n  switch(pattern_info(PCRE2_INFO_HEAPLIMIT, &heap_limit, TRUE))\n    {\n    case 0:\n    heap_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    heap_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  switch(pattern_info(PCRE2_INFO_MATCHLIMIT, &match_limit, TRUE))\n    {\n    case 0:\n    match_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    match_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  switch(pattern_info(PCRE2_INFO_DEPTHLIMIT, &depth_limit, TRUE))\n    {\n    case 0:\n    depth_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    depth_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  /* These info requests should always succeed. */\n\n  if (pattern_info(PCRE2_INFO_BACKREFMAX, &backrefmax, FALSE) +\n      pattern_info(PCRE2_INFO_BSR, &bsr_convention, FALSE) +\n      pattern_info(PCRE2_INFO_CAPTURECOUNT, &capture_count, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTBITMAP, &start_bits, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTCODEUNIT, &first_cunit, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTCODETYPE, &first_ctype, FALSE) +\n      pattern_info(PCRE2_INFO_HASBACKSLASHC, &hasbackslashc, FALSE) +\n      pattern_info(PCRE2_INFO_HASCRORLF, &hascrorlf, FALSE) +\n      pattern_info(PCRE2_INFO_JCHANGED, &jchanged, FALSE) +\n      pattern_info(PCRE2_INFO_LASTCODEUNIT, &last_cunit, FALSE) +\n      pattern_info(PCRE2_INFO_LASTCODETYPE, &last_ctype, FALSE) +\n      pattern_info(PCRE2_INFO_MATCHEMPTY, &match_empty, FALSE) +\n      pattern_info(PCRE2_INFO_MINLENGTH, &minlength, FALSE) +\n      pattern_info(PCRE2_INFO_NAMECOUNT, &namecount, FALSE) +\n      pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &nameentrysize, FALSE) +\n      pattern_info(PCRE2_INFO_NAMETABLE, &nametable, FALSE) +\n      pattern_info(PCRE2_INFO_NEWLINE, &newline_convention, FALSE)\n      != 0)\n    return PR_ABEND;\n\n  fprintf(outfile, \"Capture group count = %d\\n\", capture_count);\n\n  if (backrefmax > 0)\n    fprintf(outfile, \"Max back reference = %d\\n\", backrefmax);\n\n  if (maxlookbehind > 0)\n    fprintf(outfile, \"Max lookbehind = %d\\n\", maxlookbehind);\n\n  if (heap_limit_set)\n    fprintf(outfile, \"Heap limit = %u\\n\", heap_limit);\n\n  if (match_limit_set)\n    fprintf(outfile, \"Match limit = %u\\n\", match_limit);\n\n  if (depth_limit_set)\n    fprintf(outfile, \"Depth limit = %u\\n\", depth_limit);\n\n  if (namecount > 0)\n    {\n    fprintf(outfile, \"Named capture groups:\\n\");\n    for (; namecount > 0; namecount--)\n      {\n      int imm2_size = test_mode == PCRE8_MODE ? 2 : 1;\n      uint32_t length = (uint32_t)STRLEN(nametable + imm2_size);\n      fprintf(outfile, \"  \");\n\n      /* In UTF mode the name may be a UTF string containing non-ASCII\n      letters and digits. We must output it as a UTF-8 string. In non-UTF mode,\n      use the normal string printing functions, which use escapes for all\n      non-ASCII characters. */\n\n      if (utf)\n        {\n#ifdef SUPPORT_PCRE2_32\n        if (test_mode == PCRE32_MODE)\n          {\n          PCRE2_SPTR32 nameptr = (PCRE2_SPTR32)nametable + imm2_size;\n          while (*nameptr != 0)\n            {\n            uint8_t u8buff[6];\n            int len = ord2utf8(*nameptr++, u8buff);\n            fprintf(outfile, \"%.*s\", len, u8buff);\n            }\n          }\n#endif\n#ifdef SUPPORT_PCRE2_16\n        if (test_mode == PCRE16_MODE)\n          {\n          PCRE2_SPTR16 nameptr = (PCRE2_SPTR16)nametable + imm2_size;\n          while (*nameptr != 0)\n            {\n            int len;\n            uint8_t u8buff[6];\n            uint32_t c = *nameptr++ & 0xffff;\n            if (c >= 0xD800 && c < 0xDC00)\n              c = ((c & 0x3ff) << 10) + (*nameptr++ & 0x3ff) + 0x10000;\n            len = ord2utf8(c, u8buff);\n            fprintf(outfile, \"%.*s\", len, u8buff);\n            }\n          }\n#endif\n#ifdef SUPPORT_PCRE2_8\n        if (test_mode == PCRE8_MODE)\n          fprintf(outfile, \"%s\", (PCRE2_SPTR8)nametable + imm2_size);\n#endif\n        }\n      else  /* Not UTF mode */\n        {\n        PCHARSV(nametable, imm2_size, length, FALSE, outfile);\n        }\n\n      while (length++ < nameentrysize - imm2_size) putc(' ', outfile);\n\n#ifdef SUPPORT_PCRE2_32\n      if (test_mode == PCRE32_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(((PCRE2_SPTR32)nametable)[0]));\n#endif\n#ifdef SUPPORT_PCRE2_16\n      if (test_mode == PCRE16_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(((PCRE2_SPTR16)nametable)[0]));\n#endif\n#ifdef SUPPORT_PCRE2_8\n      if (test_mode == PCRE8_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(\n        ((((PCRE2_SPTR8)nametable)[0]) << 8) | ((PCRE2_SPTR8)nametable)[1]));\n#endif\n\n      nametable = (void*)((PCRE2_SPTR8)nametable + nameentrysize * code_unit_size);\n      }\n    }\n\n  if (hascrorlf)     fprintf(outfile, \"Contains explicit CR or LF match\\n\");\n  if (hasbackslashc) fprintf(outfile, \"Contains \\\\C\\n\");\n  if (match_empty)   fprintf(outfile, \"May match empty string\\n\");\n\n  pattern_info(PCRE2_INFO_ARGOPTIONS, &compile_options, FALSE);\n  pattern_info(PCRE2_INFO_ALLOPTIONS, &overall_options, FALSE);\n  pattern_info(PCRE2_INFO_EXTRAOPTIONS, &extra_options, FALSE);\n\n  /* Remove UTF/UCP if they were there only because of forbid_utf. This saves\n  cluttering up the verification output of non-UTF test files. */\n\n  if ((pat_patctl.options & PCRE2_NEVER_UTF) == 0)\n    {\n    compile_options &= ~PCRE2_NEVER_UTF;\n    overall_options &= ~PCRE2_NEVER_UTF;\n    }\n\n  if ((pat_patctl.options & PCRE2_NEVER_UCP) == 0)\n    {\n    compile_options &= ~PCRE2_NEVER_UCP;\n    overall_options &= ~PCRE2_NEVER_UCP;\n    }\n\n  if ((compile_options|overall_options) != 0)\n    {\n    if (compile_options == overall_options)\n      show_compile_options(compile_options, \"Options:\", \"\\n\");\n    else\n      {\n      show_compile_options(compile_options, \"Compile options:\", \"\\n\");\n      show_compile_options(overall_options, \"Overall options:\", \"\\n\");\n      }\n    }\n\n  if (extra_options != 0)\n    show_compile_extra_options(extra_options, \"Extra options:\", \"\\n\");\n\n  if (jchanged) fprintf(outfile, \"Duplicate name status changes\\n\");\n\n  if ((pat_patctl.control2 & CTL2_BSR_SET) != 0 ||\n      (FLD(compiled_code, flags) & PCRE2_BSR_SET) != 0)\n    fprintf(outfile, \"\\\\R matches %s\\n\", (bsr_convention == PCRE2_BSR_UNICODE)?\n      \"any Unicode newline\" : \"CR, LF, or CRLF\");\n\n  if ((FLD(compiled_code, flags) & PCRE2_NL_SET) != 0)\n    {\n    switch (newline_convention)\n      {\n      case PCRE2_NEWLINE_CR:\n      fprintf(outfile, \"Forced newline is CR\\n\");\n      break;\n\n      case PCRE2_NEWLINE_LF:\n      fprintf(outfile, \"Forced newline is LF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_CRLF:\n      fprintf(outfile, \"Forced newline is CRLF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_ANYCRLF:\n      fprintf(outfile, \"Forced newline is CR, LF, or CRLF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_ANY:\n      fprintf(outfile, \"Forced newline is any Unicode newline\\n\");\n      break;\n\n      case PCRE2_NEWLINE_NUL:\n      fprintf(outfile, \"Forced newline is NUL\\n\");\n      break;\n\n      default:\n      break;\n      }\n    }\n\n  if (first_ctype == 2)\n    {\n    fprintf(outfile, \"First code unit at start or follows newline\\n\");\n    }\n  else if (first_ctype == 1)\n    {\n    const char *caseless =\n      ((FLD(compiled_code, flags) & PCRE2_FIRSTCASELESS) == 0)?\n      \"\" : \" (caseless)\";\n    if (PRINTOK(first_cunit))\n      fprintf(outfile, \"First code unit = \\'%c\\'%s\\n\", first_cunit, caseless);\n    else\n      {\n      fprintf(outfile, \"First code unit = \");\n      pchar(first_cunit, FALSE, outfile);\n      fprintf(outfile, \"%s\\n\", caseless);\n      }\n    }\n  else if (start_bits != NULL)\n    {\n    int i;\n    int c = 24;\n    fprintf(outfile, \"Starting code units: \");\n    for (i = 0; i < 256; i++)\n      {\n      if ((start_bits[i/8] & (1u << (i&7))) != 0)\n        {\n        if (c > 75)\n          {\n          fprintf(outfile, \"\\n  \");\n          c = 2;\n          }\n        if (PRINTOK(i) && i != ' ')\n          {\n          fprintf(outfile, \"%c \", i);\n          c += 2;\n          }\n        else\n          {\n          fprintf(outfile, \"\\\\x%02x \", i);\n          c += 5;\n          }\n        }\n      }\n    fprintf(outfile, \"\\n\");\n    }\n\n  if (last_ctype != 0)\n    {\n    const char *caseless =\n      ((FLD(compiled_code, flags) & PCRE2_LASTCASELESS) == 0)?\n      \"\" : \" (caseless)\";\n    if (PRINTOK(last_cunit))\n      fprintf(outfile, \"Last code unit = \\'%c\\'%s\\n\", last_cunit, caseless);\n    else\n      {\n      fprintf(outfile, \"Last code unit = \");\n      pchar(last_cunit, FALSE, outfile);\n      fprintf(outfile, \"%s\\n\", caseless);\n      }\n    }\n\n  if ((FLD(compiled_code, overall_options) & PCRE2_NO_START_OPTIMIZE) == 0)\n    fprintf(outfile, \"Subject length lower bound = %d\\n\", minlength);\n\n  if (pat_patctl.jit != 0 && (pat_patctl.control & CTL_JITVERIFY) != 0)\n    {\n#ifdef SUPPORT_JIT\n    if (FLD(compiled_code, executable_jit) != NULL)\n      fprintf(outfile, \"JIT compilation was successful\\n\");\n    else\n      {\n      fprintf(outfile, \"JIT compilation was not successful\");\n      if (jitrc != 0 && !print_error_message(jitrc, \" (\", \")\"))\n        return PR_ABEND;\n      fprintf(outfile, \"\\n\");\n      }\n#else\n      fprintf(outfile, \"JIT support is not available in this version of PCRE2\\n\");\n#endif\n    }\n  }\n\nif ((pat_patctl.control & CTL_CALLOUT_INFO) != 0)\n  {\n  int errorcode;\n  PCRE2_CALLOUT_ENUMERATE(errorcode, callout_callback, 0);\n  if (errorcode != 0)\n    {\n    fprintf(outfile, \"Callout enumerate failed: error %d: \", errorcode);\n    if (errorcode < 0 && !print_error_message(errorcode, \"\", \"\\n\"))\n      return PR_ABEND;\n    return PR_SKIP;\n    }\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*              Handle serialization error        *\n*************************************************/\n\n/* Print an error message after a serialization failure.\n\nArguments:\n  rc         the error code\n  msg        an initial message for what failed\n\nReturns:     FALSE if print_error_message() fails\n*/\n\nstatic BOOL\nserial_error(int rc, const char *msg)\n{\nfprintf(outfile, \"%s failed: error %d: \", msg, rc);\nreturn print_error_message(rc, \"\", \"\\n\");\n}\n\n\n\n/*************************************************\n*        Open file for save/load commands        *\n*************************************************/\n\n/* This function decodes the file name and opens the file.\n\nArguments:\n  buffptr     point after the #command\n  mode        open mode\n  fptr        points to the FILE variable\n  name        name of # command\n\nReturns:      PR_OK or PR_ABEND\n*/\n\nstatic int\nopen_file(uint8_t *buffptr, const char *mode, FILE **fptr, const char *name)\n{\nchar *endf;\nchar *filename = (char *)buffptr;\nwhile (isspace(*filename)) filename++;\nendf = filename + strlen8(filename);\nwhile (endf > filename && isspace(endf[-1])) endf--;\n\nif (endf == filename)\n  {\n  fprintf(outfile, \"** File name expected after %s\\n\", name);\n  return PR_ABEND;\n  }\n\n*endf = 0;\n*fptr = fopen((const char *)filename, mode);\nif (*fptr == NULL)\n  {\n  fprintf(outfile, \"** Failed to open '%s': %s\\n\", filename, strerror(errno));\n  return PR_ABEND;\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*               Process command line             *\n*************************************************/\n\n/* This function is called for lines beginning with # and a character that is\nnot ! or whitespace, when encountered between tests, which means that there is\nno compiled pattern (compiled_code is NULL). The line is in buffer.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_command(void)\n{\nFILE *f;\nPCRE2_SIZE serial_size;\nsize_t i;\nint rc, cmd, cmdlen, yield;\nuint16_t first_listed_newline;\nconst char *cmdname;\nuint8_t *argptr, *serial;\n\nyield = PR_OK;\ncmd = CMD_UNKNOWN;\ncmdlen = 0;\n\nfor (i = 0; i < cmdlistcount; i++)\n  {\n  cmdname = cmdlist[i].name;\n  cmdlen = strlen(cmdname);\n  if (strncmp((char *)(buffer+1), cmdname, cmdlen) == 0 &&\n      isspace(buffer[cmdlen+1]))\n    {\n    cmd = cmdlist[i].value;\n    break;\n    }\n  }\n\nargptr = buffer + cmdlen + 1;\n\nif (restrict_for_perl_test && cmd != CMD_PATTERN && cmd != CMD_SUBJECT)\n  {\n  fprintf(outfile, \"** #%s is not allowed after #perltest\\n\", cmdname);\n  return PR_ABEND;\n  }\n\nswitch(cmd)\n  {\n  case CMD_UNKNOWN:\n  fprintf(outfile, \"** Unknown command: %s\", buffer);\n  break;\n\n  case CMD_FORBID_UTF:\n  forbid_utf = PCRE2_NEVER_UTF|PCRE2_NEVER_UCP;\n  break;\n\n  case CMD_PERLTEST:\n  restrict_for_perl_test = TRUE;\n  break;\n\n  /* Set default pattern modifiers */\n\n  case CMD_PATTERN:\n  (void)decode_modifiers(argptr, CTX_DEFPAT, &def_patctl, NULL);\n  if (def_patctl.jit == 0 && (def_patctl.control & CTL_JITVERIFY) != 0)\n    def_patctl.jit = JIT_DEFAULT;\n  break;\n\n  /* Set default subject modifiers */\n\n  case CMD_SUBJECT:\n  (void)decode_modifiers(argptr, CTX_DEFDAT, NULL, &def_datctl);\n  break;\n\n  /* Check the default newline, and if not one of those listed, set up the\n  first one to be forced. An empty list unsets. */\n\n  case CMD_NEWLINE_DEFAULT:\n  local_newline_default = 0;   /* Unset */\n  first_listed_newline = 0;\n  for (;;)\n    {\n    while (isspace(*argptr)) argptr++;\n    if (*argptr == 0) break;\n    for (i = 1; i < sizeof(newlines)/sizeof(char *); i++)\n      {\n      size_t nlen = strlen(newlines[i]);\n      if (strncmpic(argptr, (const uint8_t *)newlines[i], nlen) == 0 &&\n          isspace(argptr[nlen]))\n        {\n        if (i == NEWLINE_DEFAULT) return PR_OK;  /* Default is valid */\n        if (first_listed_newline == 0) first_listed_newline = i;\n        }\n      }\n    while (*argptr != 0 && !isspace(*argptr)) argptr++;\n    }\n  local_newline_default = first_listed_newline;\n  break;\n\n  /* Pop or copy a compiled pattern off the stack. Modifiers that do not affect\n  the compiled pattern (e.g. to give information) are permitted. The default\n  pattern modifiers are ignored. */\n\n  case CMD_POP:\n  case CMD_POPCOPY:\n  if (patstacknext <= 0)\n    {\n    fprintf(outfile, \"** Can't pop off an empty stack\\n\");\n    return PR_SKIP;\n    }\n  memset(&pat_patctl, 0, sizeof(patctl));   /* Completely unset */\n  if (!decode_modifiers(argptr, CTX_POPPAT, &pat_patctl, NULL))\n    return PR_SKIP;\n\n  if (cmd == CMD_POP)\n    {\n    SET(compiled_code, patstack[--patstacknext]);\n    }\n  else\n    {\n    PCRE2_CODE_COPY_FROM_VOID(compiled_code, patstack[patstacknext - 1]);\n    }\n\n  if (pat_patctl.jit != 0)\n    {\n    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n    }\n  if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();\n  if ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();\n  if ((pat_patctl.control & CTL_ANYINFO) != 0)\n    {\n    rc = show_pattern_info();\n    if (rc != PR_OK) return rc;\n    }\n  break;\n\n  /* Save the stack of compiled patterns to a file, then empty the stack. */\n\n  case CMD_SAVE:\n  if (patstacknext <= 0)\n    {\n    fprintf(outfile, \"** No stacked patterns to save\\n\");\n    return PR_OK;\n    }\n\n  rc = open_file(argptr+1, BINARY_OUTPUT_MODE, &f, \"#save\");\n  if (rc != PR_OK) return rc;\n\n  PCRE2_SERIALIZE_ENCODE(rc, patstack, patstacknext, &serial, &serial_size,\n    general_context);\n  if (rc < 0)\n    {\n    fclose(f);\n    if (!serial_error(rc, \"Serialization\")) return PR_ABEND;\n    break;\n    }\n\n  /* Write the length at the start of the file to make it straightforward to\n  get the right memory when re-loading. This saves having to read the file size\n  in different operating systems. To allow for different endianness (even\n  though reloading with the opposite endianness does not work), write the\n  length byte-by-byte. */\n\n  for (i = 0; i < 4; i++) fputc((serial_size >> (i*8)) & 255, f);\n  if (fwrite(serial, 1, serial_size, f) != serial_size)\n    {\n    fprintf(outfile, \"** Wrong return from fwrite()\\n\");\n    fclose(f);\n    return PR_ABEND;\n    }\n\n  fclose(f);\n  PCRE2_SERIALIZE_FREE(serial);\n  while(patstacknext > 0)\n    {\n    SET(compiled_code, patstack[--patstacknext]);\n    SUB1(pcre2_code_free, compiled_code);\n    }\n  SET(compiled_code, NULL);\n  break;\n\n  /* Load a set of compiled patterns from a file onto the stack */\n\n  case CMD_LOAD:\n  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, \"#load\");\n  if (rc != PR_OK) return rc;\n\n  serial_size = 0;\n  for (i = 0; i < 4; i++) serial_size |= fgetc(f) << (i*8);\n\n  serial = malloc(serial_size);\n  if (serial == NULL)\n    {\n    fprintf(outfile, \"** Failed to get memory (size %\" SIZ_FORM \") for #load\\n\",\n      serial_size);\n    fclose(f);\n    return PR_ABEND;\n    }\n\n  i = fread(serial, 1, serial_size, f);\n  fclose(f);\n\n  if (i != serial_size)\n    {\n    fprintf(outfile, \"** Wrong return from fread()\\n\");\n    yield = PR_ABEND;\n    }\n  else\n    {\n    PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(rc, serial);\n    if (rc < 0)\n      {\n      if (!serial_error(rc, \"Get number of codes\")) yield = PR_ABEND;\n      }\n    else\n      {\n      if (rc + patstacknext > PATSTACKSIZE)\n        {\n        fprintf(outfile, \"** Not enough space on pattern stack for %d pattern%s\\n\",\n          rc, (rc == 1)? \"\" : \"s\");\n        rc = PATSTACKSIZE - patstacknext;\n        fprintf(outfile, \"** Decoding %d pattern%s\\n\", rc,\n          (rc == 1)? \"\" : \"s\");\n        }\n      PCRE2_SERIALIZE_DECODE(rc, patstack + patstacknext, rc, serial,\n        general_context);\n      if (rc < 0)\n        {\n        if (!serial_error(rc, \"Deserialization\")) yield = PR_ABEND;\n        }\n      else patstacknext += rc;\n      }\n    }\n\n  free(serial);\n  break;\n\n  /* Load a set of binary tables into tables3. */\n\n  case CMD_LOADTABLES:\n  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, \"#loadtables\");\n  if (rc != PR_OK) return rc;\n\n  if (tables3 == NULL)\n    {\n    (void)PCRE2_CONFIG(PCRE2_CONFIG_TABLES_LENGTH, &loadtables_length);\n    tables3 = malloc(loadtables_length);\n    }\n\n  if (tables3 == NULL)\n    {\n    fprintf(outfile, \"** Failed: malloc failed for #loadtables\\n\");\n    yield = PR_ABEND;\n    }\n  else if (fread(tables3, 1, loadtables_length, f) != loadtables_length)\n    {\n    fprintf(outfile, \"** Wrong return from fread()\\n\");\n    yield = PR_ABEND;\n    }\n\n  fclose(f);\n  break;\n  }\n\nreturn yield;\n}\n\n\n\n/*************************************************\n*               Process pattern line             *\n*************************************************/\n\n/* This function is called when the input buffer contains the start of a\npattern. The first character is known to be a valid delimiter. The pattern is\nread, modifiers are interpreted, and a suitable local context is set up for\nthis test. The pattern is then compiled.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_pattern(void)\n{\nBOOL utf;\nuint32_t k;\nuint8_t *p = buffer;\nunsigned int delimiter = *p++;\nint errorcode;\nvoid *use_pat_context;\nuint32_t use_forbid_utf = forbid_utf;\nPCRE2_SIZE patlen;\nPCRE2_SIZE valgrind_access_length;\nPCRE2_SIZE erroroffset;\n\n/* The perltest.sh script supports only / as a delimiter. */\n\nif (restrict_for_perl_test && delimiter != '/')\n  {\n  fprintf(outfile, \"** The only allowed delimiter after #perltest is '/'\\n\");\n  return PR_ABEND;\n  }\n\n/* Initialize the context and pattern/data controls for this test from the\ndefaults. */\n\nPATCTXCPY(pat_context, default_pat_context);\nmemcpy(&pat_patctl, &def_patctl, sizeof(patctl));\n\n/* Find the end of the pattern, reading more lines if necessary. */\n\nfor(;;)\n  {\n  while (*p != 0)\n    {\n    if (*p == '\\\\' && p[1] != 0) p++;\n      else if (*p == delimiter) break;\n    p++;\n    }\n  if (*p != 0) break;\n  if ((p = extend_inputline(infile, p, \"    > \")) == NULL)\n    {\n    fprintf(outfile, \"** Unexpected EOF\\n\");\n    return PR_ABEND;\n    }\n  if (!INTERACTIVE(infile)) fprintf(outfile, \"%s\", (char *)p);\n  }\n\n/* If the first character after the delimiter is backslash, make the pattern\nend with backslash. This is purely to provide a way of testing for the error\nmessage when a pattern ends with backslash. */\n\nif (p[1] == '\\\\') *p++ = '\\\\';\n\n/* Terminate the pattern at the delimiter, and compute the length. */\n\n*p++ = 0;\npatlen = p - buffer - 2;\n\n/* Look for modifiers and options after the final delimiter. */\n\nif (!decode_modifiers(p, CTX_PAT, &pat_patctl, NULL)) return PR_SKIP;\n\n/* Note that the match_invalid_utf option also sets utf when passed to\npcre2_compile(). */\n\nutf = (pat_patctl.options & (PCRE2_UTF|PCRE2_MATCH_INVALID_UTF)) != 0;\n\n/* The utf8_input modifier is not allowed in 8-bit mode, and is mutually\nexclusive with the utf modifier. */\n\nif ((pat_patctl.control & CTL_UTF8_INPUT) != 0)\n  {\n  if (test_mode == PCRE8_MODE)\n    {\n    fprintf(outfile, \"** The utf8_input modifier is not allowed in 8-bit mode\\n\");\n    return PR_SKIP;\n    }\n  if (utf)\n    {\n    fprintf(outfile, \"** The utf and utf8_input modifiers are mutually exclusive\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* The convert and posix modifiers are mutually exclusive. */\n\nif (pat_patctl.convert_type != CONVERT_UNSET &&\n    (pat_patctl.control & CTL_POSIX) != 0)\n  {\n  fprintf(outfile, \"** The convert and posix modifiers are mutually exclusive\\n\");\n  return PR_SKIP;\n  }\n\n/* Check for mutually exclusive control modifiers. At present, these are all in\nthe first control word. */\n\nfor (k = 0; k < sizeof(exclusive_pat_controls)/sizeof(uint32_t); k++)\n  {\n  uint32_t c = pat_patctl.control & exclusive_pat_controls[k];\n  if (c != 0 && c != (c & (~c+1)))\n    {\n    show_controls(c, 0, \"** Not allowed together:\");\n    fprintf(outfile, \"\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* Assume full JIT compile for jitverify and/or jitfast if nothing else was\nspecified. */\n\nif (pat_patctl.jit == 0 &&\n    (pat_patctl.control & (CTL_JITVERIFY|CTL_JITFAST)) != 0)\n  pat_patctl.jit = JIT_DEFAULT;\n\n/* Now copy the pattern to pbuffer8 for use in 8-bit testing and for reflecting\nin callouts. Convert from hex if requested (literal strings in quotes may be\npresent within the hexadecimal pairs). The result must necessarily be fewer\ncharacters so will always fit in pbuffer8. */\n\nif ((pat_patctl.control & CTL_HEXPAT) != 0)\n  {\n  uint8_t *pp, *pt;\n  uint32_t c, d;\n\n  pt = pbuffer8;\n  for (pp = buffer + 1; *pp != 0; pp++)\n    {\n    if (isspace(*pp)) continue;\n    c = *pp++;\n\n    /* Handle a literal substring */\n\n    if (c == '\\'' || c == '\"')\n      {\n      uint8_t *pq = pp;\n      for (;; pp++)\n        {\n        d = *pp;\n        if (d == 0)\n          {\n          fprintf(outfile, \"** Missing closing quote in hex pattern: \"\n            \"opening quote is at offset %\" PTR_FORM \".\\n\", pq - buffer - 2);\n          return PR_SKIP;\n          }\n        if (d == c) break;\n        *pt++ = d;\n        }\n      }\n\n    /* Expect a hex pair */\n\n    else\n      {\n      if (!isxdigit(c))\n        {\n        fprintf(outfile, \"** Unexpected non-hex-digit '%c' at offset %\"\n          PTR_FORM \" in hex pattern: quote missing?\\n\", c, pp - buffer - 2);\n        return PR_SKIP;\n        }\n      if (*pp == 0)\n        {\n        fprintf(outfile, \"** Odd number of digits in hex pattern\\n\");\n        return PR_SKIP;\n        }\n      d = *pp;\n      if (!isxdigit(d))\n        {\n        fprintf(outfile, \"** Unexpected non-hex-digit '%c' at offset %\"\n          PTR_FORM \" in hex pattern: quote missing?\\n\", d, pp - buffer - 1);\n        return PR_SKIP;\n        }\n      c = toupper(c);\n      d = toupper(d);\n      *pt++ = ((isdigit(c)? (c - '0') : (c - 'A' + 10)) << 4) +\n               (isdigit(d)? (d - '0') : (d - 'A' + 10));\n      }\n    }\n  *pt = 0;\n  patlen = pt - pbuffer8;\n  }\n\n/* If not a hex string, process for repetition expansion if requested. */\n\nelse if ((pat_patctl.control & CTL_EXPAND) != 0)\n  {\n  uint8_t *pp, *pt;\n\n  pt = pbuffer8;\n  for (pp = buffer + 1; *pp != 0; pp++)\n    {\n    uint8_t *pc = pp;\n    uint32_t count = 1;\n    size_t length = 1;\n\n    /* Check for replication syntax; if not found, the defaults just set will\n    prevail and one character will be copied. */\n\n    if (pp[0] == '\\\\' && pp[1] == '[')\n      {\n      uint8_t *pe;\n      for (pe = pp + 2; *pe != 0; pe++)\n        {\n        if (pe[0] == ']' && pe[1] == '{')\n          {\n          uint32_t clen = pe - pc - 2;\n          uint32_t i = 0;\n          unsigned long uli;\n          char *endptr;\n\n          pe += 2;\n          uli = strtoul((const char *)pe, &endptr, 10);\n          if (U32OVERFLOW(uli))\n            {\n            fprintf(outfile, \"** Pattern repeat count too large\\n\");\n            return PR_SKIP;\n            }\n\n          i = (uint32_t)uli;\n          pe = (uint8_t *)endptr;\n          if (*pe == '}')\n            {\n            if (i == 0)\n              {\n              fprintf(outfile, \"** Zero repeat not allowed\\n\");\n              return PR_SKIP;\n              }\n            pc += 2;\n            count = i;\n            length = clen;\n            pp = pe;\n            break;\n            }\n          }\n        }\n      }\n\n    /* Add to output. If the buffer is too small expand it. The function for\n    expanding buffers always keeps buffer and pbuffer8 in step as far as their\n    size goes. */\n\n    while (pt + count * length > pbuffer8 + pbuffer8_size)\n      {\n      size_t pc_offset = pc - buffer;\n      size_t pp_offset = pp - buffer;\n      size_t pt_offset = pt - pbuffer8;\n      expand_input_buffers();\n      pc = buffer + pc_offset;\n      pp = buffer + pp_offset;\n      pt = pbuffer8 + pt_offset;\n      }\n\n    for (; count > 0; count--)\n      {\n      memcpy(pt, pc, length);\n      pt += length;\n      }\n    }\n\n  *pt = 0;\n  patlen = pt - pbuffer8;\n\n  if ((pat_patctl.control & CTL_INFO) != 0)\n    fprintf(outfile, \"Expanded: %s\\n\", pbuffer8);\n  }\n\n/* Neither hex nor expanded, just copy the input verbatim. */\n\nelse\n  {\n  strncpy((char *)pbuffer8, (char *)(buffer+1), patlen + 1);\n  }\n\n/* Sort out character tables */\n\nif (pat_patctl.locale[0] != 0)\n  {\n  if (pat_patctl.tables_id != 0)\n    {\n    fprintf(outfile, \"** 'Locale' and 'tables' must not both be set\\n\");\n    return PR_SKIP;\n    }\n  if (setlocale(LC_CTYPE, (const char *)pat_patctl.locale) == NULL)\n    {\n    fprintf(outfile, \"** Failed to set locale '%s'\\n\", pat_patctl.locale);\n    return PR_SKIP;\n    }\n  if (strcmp((const char *)pat_patctl.locale, (const char *)locale_name) != 0)\n    {\n    strcpy((char *)locale_name, (char *)pat_patctl.locale);\n    if (locale_tables != NULL)\n      { \n      PCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);\n      } \n    PCRE2_MAKETABLES(locale_tables, general_context);\n    }\n  use_tables = locale_tables;\n  }\n\nelse switch (pat_patctl.tables_id)\n  {\n  case 0: use_tables = NULL; break;\n  case 1: use_tables = tables1; break;\n  case 2: use_tables = tables2; break;\n\n  case 3:\n  if (tables3 == NULL)\n    {\n    fprintf(outfile, \"** 'Tables = 3' is invalid: binary tables have not \"\n      \"been loaded\\n\");\n    return PR_SKIP;\n    }\n  use_tables = tables3;\n  break;\n\n  default:\n  fprintf(outfile, \"** 'Tables' must specify 0, 1, 2, or 3.\\n\");\n  return PR_SKIP;\n  }\n\nPCRE2_SET_CHARACTER_TABLES(pat_context, use_tables);\n\n/* Set up for the stackguard test. */\n\nif (pat_patctl.stackguard_test != 0)\n  {\n  PCRE2_SET_COMPILE_RECURSION_GUARD(pat_context, stack_guard, NULL);\n  }\n\n/* Handle compiling via the POSIX interface, which doesn't support the\ntiming, showing, or debugging options, nor the ability to pass over\nlocal character tables. Neither does it have 16-bit or 32-bit support. */\n\nif ((pat_patctl.control & CTL_POSIX) != 0)\n  {\n#ifdef SUPPORT_PCRE2_8\n  int rc;\n  int cflags = 0;\n  const char *msg = \"** Ignored with POSIX interface:\";\n#endif\n\n  if (test_mode != PCRE8_MODE)\n    {\n    fprintf(outfile, \"** The POSIX interface is available only in 8-bit mode\\n\");\n    return PR_SKIP;\n    }\n\n#ifdef SUPPORT_PCRE2_8\n  /* Check for features that the POSIX interface does not support. */\n\n  if (pat_patctl.locale[0] != 0) prmsg(&msg, \"locale\");\n  if (pat_patctl.replacement[0] != 0) prmsg(&msg, \"replace\");\n  if (pat_patctl.tables_id != 0) prmsg(&msg, \"tables\");\n  if (pat_patctl.stackguard_test != 0) prmsg(&msg, \"stackguard\");\n  if (timeit > 0) prmsg(&msg, \"timing\");\n  if (pat_patctl.jit != 0) prmsg(&msg, \"JIT\");\n\n  if ((pat_patctl.options & ~POSIX_SUPPORTED_COMPILE_OPTIONS) != 0)\n    {\n    show_compile_options(\n      pat_patctl.options & (uint32_t)(~POSIX_SUPPORTED_COMPILE_OPTIONS),\n        msg, \"\");\n    msg = \"\";\n    }\n\n  if ((FLD(pat_context, extra_options) &\n       (uint32_t)(~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS)) != 0)\n    {\n    show_compile_extra_options(\n      FLD(pat_context, extra_options) &\n        (uint32_t)(~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS), msg, \"\");\n    msg = \"\";\n    }\n\n  if ((pat_patctl.control & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS)) != 0 ||\n      (pat_patctl.control2 & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS2)) != 0)\n    {\n    show_controls(\n      pat_patctl.control & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS),\n      pat_patctl.control2 & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS2),\n      msg);\n    msg = \"\";\n    }\n\n  if (local_newline_default != 0) prmsg(&msg, \"#newline_default\");\n  if (FLD(pat_context, max_pattern_length) != PCRE2_UNSET)\n    prmsg(&msg, \"max_pattern_length\");\n  if (FLD(pat_context, parens_nest_limit) != PARENS_NEST_DEFAULT)\n    prmsg(&msg, \"parens_nest_limit\");\n\n  if (msg[0] == 0) fprintf(outfile, \"\\n\");\n\n  /* Translate PCRE2 options to POSIX options and then compile. */\n\n  if (utf) cflags |= REG_UTF;\n  if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0) cflags |= REG_NOSUB;\n  if ((pat_patctl.options & PCRE2_UCP) != 0) cflags |= REG_UCP;\n  if ((pat_patctl.options & PCRE2_CASELESS) != 0) cflags |= REG_ICASE;\n  if ((pat_patctl.options & PCRE2_LITERAL) != 0) cflags |= REG_NOSPEC;\n  if ((pat_patctl.options & PCRE2_MULTILINE) != 0) cflags |= REG_NEWLINE;\n  if ((pat_patctl.options & PCRE2_DOTALL) != 0) cflags |= REG_DOTALL;\n  if ((pat_patctl.options & PCRE2_UNGREEDY) != 0) cflags |= REG_UNGREEDY;\n\n  if ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) != 0)\n    {\n    preg.re_endp = (char *)pbuffer8 + patlen;\n    cflags |= REG_PEND;\n    }\n\n  rc = regcomp(&preg, (char *)pbuffer8, cflags);\n\n  /* Compiling failed */\n\n  if (rc != 0)\n    {\n    size_t bsize, usize;\n    int psize;\n\n    preg.re_pcre2_code = NULL;     /* In case something was left in there */\n    preg.re_match_data = NULL;\n\n    bsize = (pat_patctl.regerror_buffsize != 0)?\n      pat_patctl.regerror_buffsize : pbuffer8_size;\n    if (bsize + 8 < pbuffer8_size)\n      memcpy(pbuffer8 + bsize, \"DEADBEEF\", 8);\n    usize = regerror(rc, &preg, (char *)pbuffer8, bsize);\n\n    /* Inside regerror(), snprintf() is used. If the buffer is too small, some\n    versions of snprintf() put a zero byte at the end, but others do not.\n    Therefore, we print a maximum of one less than the size of the buffer. */\n\n    psize = (int)bsize - 1;\n    fprintf(outfile, \"Failed: POSIX code %d: %.*s\\n\", rc, psize, pbuffer8);\n    if (usize > bsize)\n      {\n      fprintf(outfile, \"** regerror() message truncated\\n\");\n      if (memcmp(pbuffer8 + bsize, \"DEADBEEF\", 8) != 0)\n        fprintf(outfile, \"** regerror() buffer overflow\\n\");\n      }\n    return PR_SKIP;\n    }\n\n  /* Compiling succeeded. Check that the values in the preg block are sensible.\n  It can happen that pcre2test is accidentally linked with a different POSIX\n  library which succeeds, but of course puts different things into preg. In\n  this situation, calling regfree() may cause a segfault (or invalid free() in\n  valgrind), so ensure that preg.re_pcre2_code is NULL, which suppresses the\n  calling of regfree() on exit. */\n\n  if (preg.re_pcre2_code == NULL ||\n      ((pcre2_real_code_8 *)preg.re_pcre2_code)->magic_number != MAGIC_NUMBER ||\n      ((pcre2_real_code_8 *)preg.re_pcre2_code)->top_bracket != preg.re_nsub ||\n      preg.re_match_data == NULL ||\n      preg.re_cflags != cflags)\n    {\n    fprintf(outfile,\n      \"** The regcomp() function returned zero (success), but the values set\\n\"\n      \"** in the preg block are not valid for PCRE2. Check that pcre2test is\\n\"\n      \"** linked with PCRE2's pcre2posix module (-lpcre2-posix) and not with\\n\"\n      \"** some other POSIX regex library.\\n**\\n\");\n    preg.re_pcre2_code = NULL;\n    return PR_ABEND;\n    }\n\n  return PR_OK;\n#endif  /* SUPPORT_PCRE2_8 */\n  }\n\n/* Handle compiling via the native interface. Controls that act later are\nignored with \"push\". Replacements are locked out. */\n\nif ((pat_patctl.control & (CTL_PUSH|CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)\n  {\n  if (pat_patctl.replacement[0] != 0)\n    {\n    fprintf(outfile, \"** Replacement text is not supported with 'push'.\\n\");\n    return PR_OK;\n    }\n  if ((pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS) != 0 ||\n      (pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS,\n                  pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2,\n      \"** Ignored when compiled pattern is stacked with 'push':\");\n    fprintf(outfile, \"\\n\");\n    }\n  if ((pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS) != 0 ||\n      (pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS,\n                  pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2,\n      \"** Applies only to compile when pattern is stacked with 'push':\");\n    fprintf(outfile, \"\\n\");\n    }\n  }\n\n/* Convert the input in non-8-bit modes. */\n\nerrorcode = 0;\n\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE) errorcode = to16(pbuffer8, utf, &patlen);\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE) errorcode = to32(pbuffer8, utf, &patlen);\n#endif\n\nswitch(errorcode)\n  {\n  case -1:\n  fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be \"\n    \"converted to %d-bit string\\n\", (test_mode == PCRE16_MODE)? 16:32);\n  return PR_SKIP;\n\n  case -2:\n  fprintf(outfile, \"** Failed: character value greater than 0x10ffff \"\n    \"cannot be converted to UTF\\n\");\n  return PR_SKIP;\n\n  case -3:\n  fprintf(outfile, \"** Failed: character value greater than 0xffff \"\n    \"cannot be converted to 16-bit in non-UTF mode\\n\");\n  return PR_SKIP;\n\n  default:\n  break;\n  }\n\n/* The pattern is now in pbuffer[8|16|32], with the length in code units in\npatlen. If it is to be converted, copy the result back afterwards so that it\nends up back in the usual place. */\n\nif (pat_patctl.convert_type != CONVERT_UNSET)\n  {\n  int rc;\n  int convert_return = PR_OK;\n  uint32_t convert_options = pat_patctl.convert_type;\n  void *converted_pattern;\n  PCRE2_SIZE converted_length;\n\n  if (pat_patctl.convert_length != 0)\n    {\n    converted_length = pat_patctl.convert_length;\n    converted_pattern = malloc(converted_length * code_unit_size);\n    if (converted_pattern == NULL)\n      {\n      fprintf(outfile, \"** Failed: malloc failed for converted pattern\\n\");\n      return PR_SKIP;\n      }\n    }\n  else converted_pattern = NULL;  /* Let the library allocate */\n\n  if (utf) convert_options |= PCRE2_CONVERT_UTF;\n  if ((pat_patctl.options & PCRE2_NO_UTF_CHECK) != 0)\n    convert_options |= PCRE2_CONVERT_NO_UTF_CHECK;\n\n  CONCTXCPY(con_context, default_con_context);\n\n  if (pat_patctl.convert_glob_escape != 0)\n    {\n    uint32_t escape = (pat_patctl.convert_glob_escape == '0')? 0 :\n      pat_patctl.convert_glob_escape;\n    PCRE2_SET_GLOB_ESCAPE(rc, con_context, escape);\n    if (rc != 0)\n      {\n      fprintf(outfile, \"** Invalid glob escape '%c'\\n\",\n        pat_patctl.convert_glob_escape);\n      convert_return = PR_SKIP;\n      goto CONVERT_FINISH;\n      }\n    }\n\n  if (pat_patctl.convert_glob_separator != 0)\n    {\n    PCRE2_SET_GLOB_SEPARATOR(rc, con_context, pat_patctl.convert_glob_separator);\n    if (rc != 0)\n      {\n      fprintf(outfile, \"** Invalid glob separator '%c'\\n\",\n        pat_patctl.convert_glob_separator);\n      convert_return = PR_SKIP;\n      goto CONVERT_FINISH;\n      }\n    }\n\n  PCRE2_PATTERN_CONVERT(rc, pbuffer, patlen, convert_options,\n    &converted_pattern, &converted_length, con_context);\n\n  if (rc != 0)\n    {\n    fprintf(outfile, \"** Pattern conversion error at offset %\" SIZ_FORM \": \",\n      converted_length);\n    convert_return = print_error_message(rc, \"\", \"\\n\")? PR_SKIP:PR_ABEND;\n    }\n\n  /* Output the converted pattern, then copy it. */\n\n  else\n    {\n    PCHARSV(converted_pattern, 0, converted_length, utf, outfile);\n    fprintf(outfile, \"\\n\");\n    patlen = converted_length;\n    CONVERT_COPY(pbuffer, converted_pattern, converted_length + 1);\n    }\n\n  /* Free the converted pattern. */\n\n  CONVERT_FINISH:\n  if (pat_patctl.convert_length != 0)\n    free(converted_pattern);\n  else\n    PCRE2_CONVERTED_PATTERN_FREE(converted_pattern);\n\n  /* Return if conversion was unsuccessful. */\n\n  if (convert_return != PR_OK) return convert_return;\n  }\n\n/* By default we pass a zero-terminated pattern, but a length is passed if\n\"use_length\" was specified or this is a hex pattern (which might contain binary\nzeros). When valgrind is supported, arrange for the unused part of the buffer\nto be marked as no access. */\n\nvalgrind_access_length = patlen;\nif ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) == 0)\n  {\n  patlen = PCRE2_ZERO_TERMINATED;\n  valgrind_access_length += 1;  /* For the terminating zero */\n  }\n\n#ifdef SUPPORT_VALGRIND\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE && pbuffer8 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer8 + valgrind_access_length,\n    pbuffer8_size - valgrind_access_length);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE && pbuffer16 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer16 + valgrind_access_length,\n    pbuffer16_size - valgrind_access_length*sizeof(uint16_t));\n  }\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE && pbuffer32 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer32 + valgrind_access_length,\n    pbuffer32_size - valgrind_access_length*sizeof(uint32_t));\n  }\n#endif\n#else  /* Valgrind not supported */\n(void)valgrind_access_length;  /* Avoid compiler warning */\n#endif\n\n/* If #newline_default has been used and the library was not compiled with an\nappropriate default newline setting, local_newline_default will be non-zero. We\nuse this if there is no explicit newline modifier. */\n\nif ((pat_patctl.control2 & CTL2_NL_SET) == 0 && local_newline_default != 0)\n  {\n  SETFLD(pat_context, newline_convention, local_newline_default);\n  }\n\n/* The null_context modifier is used to test calling pcre2_compile() with a\nNULL context. */\n\nuse_pat_context = ((pat_patctl.control & CTL_NULLCONTEXT) != 0)?\n  NULL : PTR(pat_context);\n\n/* If PCRE2_LITERAL is set, set use_forbid_utf zero because PCRE2_NEVER_UTF\nand PCRE2_NEVER_UCP are invalid with it. */\n\nif ((pat_patctl.options & PCRE2_LITERAL) != 0) use_forbid_utf = 0;\n\n/* Compile many times when timing. */\n\nif (timeit > 0)\n  {\n  int i;\n  clock_t time_taken = 0;\n  for (i = 0; i < timeit; i++)\n    {\n    clock_t start_time = clock();\n    PCRE2_COMPILE(compiled_code, pbuffer, patlen,\n      pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,\n        use_pat_context);\n    time_taken += clock() - start_time;\n    if (TEST(compiled_code, !=, NULL))\n      { SUB1(pcre2_code_free, compiled_code); }\n    }\n  total_compile_time += time_taken;\n  fprintf(outfile, \"Compile time %.4f milliseconds\\n\",\n    (((double)time_taken * 1000.0) / (double)timeit) /\n      (double)CLOCKS_PER_SEC);\n  }\n\n/* A final compile that is used \"for real\". */\n\nPCRE2_COMPILE(compiled_code, pbuffer, patlen, pat_patctl.options|use_forbid_utf,\n  &errorcode, &erroroffset, use_pat_context);\n\n/* Call the JIT compiler if requested. When timing, we must free and recompile\nthe pattern each time because that is the only way to free the JIT compiled\ncode. We know that compilation will always succeed. */\n\nif (TEST(compiled_code, !=, NULL) && pat_patctl.jit != 0)\n  {\n  if (timeit > 0)\n    {\n    int i;\n    clock_t time_taken = 0;\n\n    for (i = 0; i < timeit; i++)\n      {\n      clock_t start_time;\n      SUB1(pcre2_code_free, compiled_code);\n      PCRE2_COMPILE(compiled_code, pbuffer, patlen,\n        pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,\n        use_pat_context);\n      start_time = clock();\n      PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n      time_taken += clock() - start_time;\n      }\n    total_jit_compile_time += time_taken;\n    fprintf(outfile, \"JIT compile  %.4f milliseconds\\n\",\n      (((double)time_taken * 1000.0) / (double)timeit) /\n        (double)CLOCKS_PER_SEC);\n    }\n  else\n    {\n    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n    }\n  }\n\n/* If valgrind is supported, mark the pbuffer as accessible again. The 16-bit\nand 32-bit buffers can be marked completely undefined, but we must leave the\npattern in the 8-bit buffer defined because it may be read from a callout\nduring matching. */\n\n#ifdef SUPPORT_VALGRIND\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer8 + valgrind_access_length,\n    pbuffer8_size - valgrind_access_length);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer16, pbuffer16_size);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer32, pbuffer32_size);\n  }\n#endif\n#endif\n\n/* Compilation failed; go back for another re, skipping to blank line\nif non-interactive. */\n\nif (TEST(compiled_code, ==, NULL))\n  {\n  fprintf(outfile, \"Failed: error %d at offset %d: \", errorcode,\n    (int)erroroffset);\n  if (!print_error_message(errorcode, \"\", \"\\n\")) return PR_ABEND;\n  return PR_SKIP;\n  }\n\n/* If forbid_utf is non-zero, we are running a non-UTF test. UTF and UCP are\nlocked out at compile time, but we must also check for occurrences of \\P, \\p,\nand \\X, which are only supported when Unicode is supported. */\n\nif (forbid_utf != 0)\n  {\n  if ((FLD(compiled_code, flags) & PCRE2_HASBKPORX) != 0)\n    {\n    fprintf(outfile, \"** \\\\P, \\\\p, and \\\\X are not allowed after the \"\n      \"#forbid_utf command\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* Remember the maximum lookbehind, for partial matching. */\n\nif (pattern_info(PCRE2_INFO_MAXLOOKBEHIND, &maxlookbehind, FALSE) != 0)\n  return PR_ABEND;\n\n/* Remember the number of captures. */\n\nif (pattern_info(PCRE2_INFO_CAPTURECOUNT, &maxcapcount, FALSE) < 0)\n  return PR_ABEND;\n\n/* If an explicit newline modifier was given, set the information flag in the\npattern so that it is preserved over push/pop. */\n\nif ((pat_patctl.control2 & CTL2_NL_SET) != 0)\n  {\n  SETFLD(compiled_code, flags, FLD(compiled_code, flags) | PCRE2_NL_SET);\n  }\n\n/* Output code size and other information if requested. */\n\nif ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();\nif ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();\nif ((pat_patctl.control & CTL_ANYINFO) != 0)\n  {\n  int rc = show_pattern_info();\n  if (rc != PR_OK) return rc;\n  }\n\n/* The \"push\" control requests that the compiled pattern be remembered on a\nstack. This is mainly for testing the serialization functionality. */\n\nif ((pat_patctl.control & CTL_PUSH) != 0)\n  {\n  if (patstacknext >= PATSTACKSIZE)\n    {\n    fprintf(outfile, \"** Too many pushed patterns (max %d)\\n\", PATSTACKSIZE);\n    return PR_ABEND;\n    }\n  patstack[patstacknext++] = PTR(compiled_code);\n  SET(compiled_code, NULL);\n  }\n\n/* The \"pushcopy\" and \"pushtablescopy\" controls are similar, but push a\ncopy of the pattern, the latter with a copy of its character tables. This tests\nthe pcre2_code_copy() and pcre2_code_copy_with_tables() functions. */\n\nif ((pat_patctl.control & (CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)\n  {\n  if (patstacknext >= PATSTACKSIZE)\n    {\n    fprintf(outfile, \"** Too many pushed patterns (max %d)\\n\", PATSTACKSIZE);\n    return PR_ABEND;\n    }\n  if ((pat_patctl.control & CTL_PUSHCOPY) != 0)\n    {\n    PCRE2_CODE_COPY_TO_VOID(patstack[patstacknext++], compiled_code);\n    }\n  else\n    {\n    PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(patstack[patstacknext++],\n      compiled_code); }\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*          Check heap, match or depth limit      *\n*************************************************/\n\n/* This is used for DFA, normal, and JIT fast matching. For DFA matching it\nshould only be called with the third argument set to PCRE2_ERROR_DEPTHLIMIT.\n\nArguments:\n  pp        the subject string\n  ulen      length of subject or PCRE2_ZERO_TERMINATED\n  errnumber defines which limit to test\n  msg       string to include in final message\n\nReturns:    the return from the final match function call\n*/\n\nstatic int\ncheck_match_limit(uint8_t *pp, PCRE2_SIZE ulen, int errnumber, const char *msg)\n{\nint capcount;\nuint32_t min = 0;\nuint32_t mid = 64;\nuint32_t max = UINT32_MAX;\n\nPCRE2_SET_MATCH_LIMIT(dat_context, max);\nPCRE2_SET_DEPTH_LIMIT(dat_context, max);\nPCRE2_SET_HEAP_LIMIT(dat_context, max);\n\nfor (;;)\n  {\n  uint32_t stack_start = 0;\n\n  /* If we are checking the heap limit, free any frames vector that is cached\n  in the match_data so we always start without one. */\n\n  if (errnumber == PCRE2_ERROR_HEAPLIMIT)\n    {\n    PCRE2_SET_HEAP_LIMIT(dat_context, mid);\n\n#ifdef SUPPORT_PCRE2_8\n    if (code_unit_size == 1)\n      {\n      match_data8->memctl.free(match_data8->heapframes,\n        match_data8->memctl.memory_data);\n      match_data8->heapframes = NULL;\n      match_data8->heapframes_size = 0;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n    if (code_unit_size == 2)\n      {\n      match_data16->memctl.free(match_data16->heapframes,\n        match_data16->memctl.memory_data);\n      match_data16->heapframes = NULL;\n      match_data16->heapframes_size = 0;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n    if (code_unit_size == 4)\n      {\n      match_data32->memctl.free(match_data32->heapframes,\n        match_data32->memctl.memory_data);\n      match_data32->heapframes = NULL;\n      match_data32->heapframes_size = 0;\n      }\n#endif\n    }\n\n  /* No need to mess with the frames vector for match or depth limits. */\n\n  else if (errnumber == PCRE2_ERROR_MATCHLIMIT)\n    {\n    PCRE2_SET_MATCH_LIMIT(dat_context, mid);\n    }\n  else\n    {\n    PCRE2_SET_DEPTH_LIMIT(dat_context, mid);\n    }\n\n  /* Do the appropriate match */\n\n  if ((dat_datctl.control & CTL_DFA) != 0)\n    {\n    stack_start = DFA_START_RWS_SIZE/1024;\n    if (dfa_workspace == NULL)\n      dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n    if (dfa_matched++ == 0)\n      dfa_workspace[0] = -1;  /* To catch bad restart */\n    PCRE2_DFA_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data,\n      PTR(dat_context), dfa_workspace, DFA_WS_DIMENSION);\n    }\n\n  else if ((pat_patctl.control & CTL_JITFAST) != 0)\n    PCRE2_JIT_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, PTR(dat_context));\n\n  else\n    {\n    PCRE2_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, PTR(dat_context));\n    }\n\n  if (capcount == errnumber)\n    {\n    if ((mid & 0x80000000u) != 0)\n      {\n      fprintf(outfile, \"Can't find minimum %s limit: check pattern for \"\n        \"restriction\\n\", msg);\n      break;\n      }\n\n    min = mid;\n    mid = (mid == max - 1)? max : (max != UINT32_MAX)? (min + max)/2 : mid*2;\n    }\n  else if (capcount >= 0 ||\n           capcount == PCRE2_ERROR_NOMATCH ||\n           capcount == PCRE2_ERROR_PARTIAL)\n    {\n    /* If we've not hit the error with a heap limit less than the size of the\n    initial stack frame vector (for pcre2_match()) or the initial stack\n    workspace vector (for pcre2_dfa_match()), the heap is not being used, so\n    the minimum limit is zero; there's no need to go on. The other limits are\n    always greater than zero. */\n\n    if (errnumber == PCRE2_ERROR_HEAPLIMIT && mid < stack_start)\n      {\n      fprintf(outfile, \"Minimum %s limit = 0\\n\", msg);\n      break;\n      }\n    if (mid == min + 1)\n      {\n      fprintf(outfile, \"Minimum %s limit = %d\\n\", msg, mid);\n      break;\n      }\n    max = mid;\n    mid = (min + max)/2;\n    }\n  else break;    /* Some other error */\n  }\n\nreturn capcount;\n}\n\n\n\n/*************************************************\n*        Substitute callout function             *\n*************************************************/\n\n/* Called from pcre2_substitute() when the substitute_callout modifier is set.\nPrint out the data that is passed back. The substitute callout block is\nidentical for all code unit widths, so we just pick one.\n\nArguments:\n  scb         pointer to substitute callout block\n  data_ptr    callout data\n\nReturns:      nothing\n*/\n\nstatic int\nsubstitute_callout_function(pcre2_substitute_callout_block_8 *scb,\n  void *data_ptr)\n{\nint yield = 0;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n(void)data_ptr;   /* Not used */\n\nfprintf(outfile, \"%2d(%d) Old %\" SIZ_FORM \" %\" SIZ_FORM \" \\\"\",\n  scb->subscount, scb->oveccount,\n  scb->ovector[0], scb->ovector[1]);\n\nPCHARSV(scb->input, scb->ovector[0], scb->ovector[1] - scb->ovector[0],\n  utf, outfile);\n\nfprintf(outfile, \"\\\" New %\" SIZ_FORM \" %\" SIZ_FORM \" \\\"\",\n  scb->output_offsets[0], scb->output_offsets[1]);\n\nPCHARSV(scb->output, scb->output_offsets[0],\n  scb->output_offsets[1] - scb->output_offsets[0], utf, outfile);\n\nif (scb->subscount == dat_datctl.substitute_stop)\n  {\n  yield = -1;\n  fprintf(outfile, \" STOPPED\");\n  }\nelse if (scb->subscount == dat_datctl.substitute_skip)\n  {\n  yield = +1;\n  fprintf(outfile, \" SKIPPED\");\n  }\n\nfprintf(outfile, \"\\\"\\n\");\nreturn yield;\n}\n\n\n/*************************************************\n*              Callout function                  *\n*************************************************/\n\n/* Called from a PCRE2 library as a result of the (?C) item. We print out where\nwe are in the match (unless suppressed). Yield zero unless more callouts than\nthe fail count, or the callout data is not zero. The only differences in the\ncallout block for different code unit widths are that the pointers to the\nsubject, the most recent MARK, and a callout argument string point to strings\nof the appropriate width. Casts can be used to deal with this.\n\nArguments:\n  cb                a pointer to a callout block\n  callout_data_ptr  the provided callout data\n\nReturns:            0 or 1 or an error, as determined by settings\n*/\n\nstatic int\ncallout_function(pcre2_callout_block_8 *cb, void *callout_data_ptr)\n{\nFILE *f, *fdefault;\nuint32_t i, pre_start, post_start, subject_length;\nPCRE2_SIZE current_position;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\nBOOL callout_capture = (dat_datctl.control & CTL_CALLOUT_CAPTURE) != 0;\nBOOL callout_where = (dat_datctl.control2 & CTL2_CALLOUT_NO_WHERE) == 0;\n\n/* The FILE f is used for echoing the subject string if it is non-NULL. This\nhappens only once in simple cases, but we want to repeat after any additional\noutput caused by CALLOUT_EXTRA. */\n\nfdefault = (!first_callout && !callout_capture && cb->callout_string == NULL)?\n  NULL : outfile;\n\nif ((dat_datctl.control2 & CTL2_CALLOUT_EXTRA) != 0)\n  {\n  f = outfile;\n  switch (cb->callout_flags)\n    {\n    case PCRE2_CALLOUT_BACKTRACK:\n    fprintf(f, \"Backtrack\\n\");\n    break;\n\n    case PCRE2_CALLOUT_STARTMATCH|PCRE2_CALLOUT_BACKTRACK:\n    fprintf(f, \"Backtrack\\nNo other matching paths\\n\");\n    /* Fall through */\n\n    case PCRE2_CALLOUT_STARTMATCH:\n    fprintf(f, \"New match attempt\\n\");\n    break;\n\n    default:\n    f = fdefault;\n    break;\n    }\n  }\nelse f = fdefault;\n\n/* For a callout with a string argument, show the string first because there\nisn't a tidy way to fit it in the rest of the data. */\n\nif (cb->callout_string != NULL)\n  {\n  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);\n  fprintf(outfile, \"Callout (%\" SIZ_FORM \"): %c\",\n    cb->callout_string_offset, delimiter);\n  PCHARSV(cb->callout_string, 0,\n    cb->callout_string_length, utf, outfile);\n  for (i = 0; callout_start_delims[i] != 0; i++)\n    if (delimiter == callout_start_delims[i])\n      {\n      delimiter = callout_end_delims[i];\n      break;\n      }\n  fprintf(outfile, \"%c\", delimiter);\n  if (!callout_capture) fprintf(outfile, \"\\n\");\n  }\n\n/* Show captured strings if required */\n\nif (callout_capture)\n  {\n  if (cb->callout_string == NULL)\n    fprintf(outfile, \"Callout %d:\", cb->callout_number);\n  fprintf(outfile, \" last capture = %d\\n\", cb->capture_last);\n  for (i = 2; i < cb->capture_top * 2; i += 2)\n    {\n    fprintf(outfile, \"%2d: \", i/2);\n    if (cb->offset_vector[i] == PCRE2_UNSET)\n      fprintf(outfile, \"<unset>\");\n    else\n      {\n      PCHARSV(cb->subject, cb->offset_vector[i],\n        cb->offset_vector[i+1] - cb->offset_vector[i], utf, f);\n      }\n    fprintf(outfile, \"\\n\");\n    }\n  }\n\n/* Unless suppressed, re-print the subject in canonical form (with escapes for\nnon-printing characters), the first time, or if giving full details. On\nsubsequent calls in the same match, we use PCHARS() just to find the printed\nlengths of the substrings. */\n\nif (callout_where)\n  {\n  if (f != NULL) fprintf(f, \"--->\");\n\n  /* The subject before the match start. */\n\n  PCHARS(pre_start, cb->subject, 0, cb->start_match, utf, f);\n\n  /* If a lookbehind is involved, the current position may be earlier than the\n  match start. If so, use the match start instead. */\n\n  current_position = (cb->current_position >= cb->start_match)?\n    cb->current_position : cb->start_match;\n\n  /* The subject between the match start and the current position. */\n\n  PCHARS(post_start, cb->subject, cb->start_match,\n    current_position - cb->start_match, utf, f);\n\n  /* Print from the current position to the end. */\n\n  PCHARSV(cb->subject, current_position, cb->subject_length - current_position,\n    utf, f);\n\n  /* Calculate the total subject printed length (no print). */\n\n  PCHARS(subject_length, cb->subject, 0, cb->subject_length, utf, NULL);\n\n  if (f != NULL) fprintf(f, \"\\n\");\n\n  /* For automatic callouts, show the pattern offset. Otherwise, for a\n  numerical callout whose number has not already been shown with captured\n  strings, show the number here. A callout with a string argument has been\n  displayed above. */\n\n  if (cb->callout_number == 255)\n    {\n    fprintf(outfile, \"%+3d \", (int)cb->pattern_position);\n    if (cb->pattern_position > 99) fprintf(outfile, \"\\n    \");\n    }\n  else\n    {\n    if (callout_capture || cb->callout_string != NULL) fprintf(outfile, \"    \");\n      else fprintf(outfile, \"%3d \", cb->callout_number);\n    }\n\n  /* Now show position indicators */\n\n  for (i = 0; i < pre_start; i++) fprintf(outfile, \" \");\n  fprintf(outfile, \"^\");\n\n  if (post_start > 0)\n    {\n    for (i = 0; i < post_start - 1; i++) fprintf(outfile, \" \");\n    fprintf(outfile, \"^\");\n    }\n\n  for (i = 0; i < subject_length - pre_start - post_start + 4; i++)\n    fprintf(outfile, \" \");\n\n  if (cb->next_item_length != 0)\n    fprintf(outfile, \"%.*s\", (int)(cb->next_item_length),\n      pbuffer8 + cb->pattern_position);\n  else\n    fprintf(outfile, \"End of pattern\");\n\n  fprintf(outfile, \"\\n\");\n  }\n\nfirst_callout = FALSE;\n\n/* Show any mark info */\n\nif (cb->mark != last_callout_mark)\n  {\n  if (cb->mark == NULL)\n    fprintf(outfile, \"Latest Mark: <unset>\\n\");\n  else\n    {\n    fprintf(outfile, \"Latest Mark: \");\n    PCHARSV(cb->mark, -1, -1, utf, outfile);\n    putc('\\n', outfile);\n    }\n  last_callout_mark = cb->mark;\n  }\n\n/* Show callout data */\n\nif (callout_data_ptr != NULL)\n  {\n  int callout_data = *((int32_t *)callout_data_ptr);\n  if (callout_data != 0)\n    {\n    fprintf(outfile, \"Callout data = %d\\n\", callout_data);\n    return callout_data;\n    }\n  }\n\n/* Keep count and give the appropriate return code */\n\ncallout_count++;\n\nif (cb->callout_number == dat_datctl.cerror[0] &&\n    callout_count >= dat_datctl.cerror[1])\n  return PCRE2_ERROR_CALLOUT;\n\nif (cb->callout_number == dat_datctl.cfail[0] &&\n    callout_count >= dat_datctl.cfail[1])\n  return 1;\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*       Handle *MARK and copy/get tests          *\n*************************************************/\n\n/* This function is called after complete and partial matches. It runs the\ntests for substring extraction.\n\nArguments:\n  utf       TRUE for utf\n  capcount  return from pcre2_match()\n\nReturns:    FALSE if print_error_message() fails\n*/\n\nstatic BOOL\ncopy_and_get(BOOL utf, int capcount)\n{\nint i;\nuint8_t *nptr;\n\n/* Test copy strings by number */\n\nfor (i = 0; i < MAXCPYGET && dat_datctl.copy_numbers[i] >= 0; i++)\n  {\n  int rc;\n  PCRE2_SIZE length, length2;\n  uint32_t copybuffer[256];\n  uint32_t n = (uint32_t)(dat_datctl.copy_numbers[i]);\n  length = sizeof(copybuffer)/code_unit_size;\n  PCRE2_SUBSTRING_COPY_BYNUMBER(rc, match_data, n, copybuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Copy substring %d failed (%d): \", n, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    PCRE2_SUBSTRING_LENGTH_BYNUMBER(rc, match_data, n, &length2);\n    if (rc < 0)\n      {\n      fprintf(outfile, \"Get substring %d length failed (%d): \", n, rc);\n      if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n      }\n    else if (length2 != length)\n      {\n      fprintf(outfile, \"Mismatched substring lengths: %\"\n        SIZ_FORM \" %\" SIZ_FORM \"\\n\", length, length2);\n      }\n    fprintf(outfile, \"%2dC \", n);\n    PCHARSV(copybuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \")\\n\", length);\n    }\n  }\n\n/* Test copy strings by name */\n\nnptr = dat_datctl.copy_names;\nfor (;;)\n  {\n  int rc;\n  int groupnumber;\n  PCRE2_SIZE length, length2;\n  uint32_t copybuffer[256];\n  int namelen = strlen((const char *)nptr);\n#if defined SUPPORT_PCRE2_16 || defined SUPPORT_PCRE2_32\n  PCRE2_SIZE cnl = namelen;\n#endif\n  if (namelen == 0) break;\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE) strcpy((char *)pbuffer8, (char *)nptr);\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)(void)to16(nptr, utf, &cnl);\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)(void)to32(nptr, utf, &cnl);\n#endif\n\n  PCRE2_SUBSTRING_NUMBER_FROM_NAME(groupnumber, compiled_code, pbuffer);\n  if (groupnumber < 0 && groupnumber != PCRE2_ERROR_NOUNIQUESUBSTRING)\n    fprintf(outfile, \"Number not found for group '%s'\\n\", nptr);\n\n  length = sizeof(copybuffer)/code_unit_size;\n  PCRE2_SUBSTRING_COPY_BYNAME(rc, match_data, pbuffer, copybuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Copy substring '%s' failed (%d): \", nptr, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    PCRE2_SUBSTRING_LENGTH_BYNAME(rc, match_data, pbuffer, &length2);\n    if (rc < 0)\n      {\n      fprintf(outfile, \"Get substring '%s' length failed (%d): \", nptr, rc);\n      if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n      }\n    else if (length2 != length)\n      {\n      fprintf(outfile, \"Mismatched substring lengths: %\"\n        SIZ_FORM \" %\" SIZ_FORM \"\\n\", length, length2);\n      }\n    fprintf(outfile, \"  C \");\n    PCHARSV(copybuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \") %s\", length, nptr);\n    if (groupnumber >= 0) fprintf(outfile, \" (group %d)\\n\", groupnumber);\n      else fprintf(outfile, \" (non-unique)\\n\");\n    }\n  nptr += namelen + 1;\n  }\n\n/* Test get strings by number */\n\nfor (i = 0; i < MAXCPYGET && dat_datctl.get_numbers[i] >= 0; i++)\n  {\n  int rc;\n  PCRE2_SIZE length;\n  void *gotbuffer;\n  uint32_t n = (uint32_t)(dat_datctl.get_numbers[i]);\n  PCRE2_SUBSTRING_GET_BYNUMBER(rc, match_data, n, &gotbuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Get substring %d failed (%d): \", n, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    fprintf(outfile, \"%2dG \", n);\n    PCHARSV(gotbuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \")\\n\", length);\n    PCRE2_SUBSTRING_FREE(gotbuffer);\n    }\n  }\n\n/* Test get strings by name */\n\nnptr = dat_datctl.get_names;\nfor (;;)\n  {\n  PCRE2_SIZE length;\n  void *gotbuffer;\n  int rc;\n  int groupnumber;\n  int namelen = strlen((const char *)nptr);\n#if defined SUPPORT_PCRE2_16 || defined SUPPORT_PCRE2_32\n  PCRE2_SIZE cnl = namelen;\n#endif\n  if (namelen == 0) break;\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE) strcpy((char *)pbuffer8, (char *)nptr);\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)(void)to16(nptr, utf, &cnl);\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)(void)to32(nptr, utf, &cnl);\n#endif\n\n  PCRE2_SUBSTRING_NUMBER_FROM_NAME(groupnumber, compiled_code, pbuffer);\n  if (groupnumber < 0 && groupnumber != PCRE2_ERROR_NOUNIQUESUBSTRING)\n    fprintf(outfile, \"Number not found for group '%s'\\n\", nptr);\n\n  PCRE2_SUBSTRING_GET_BYNAME(rc, match_data, pbuffer, &gotbuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Get substring '%s' failed (%d): \", nptr, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    fprintf(outfile, \"  G \");\n    PCHARSV(gotbuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \") %s\", length, nptr);\n    if (groupnumber >= 0) fprintf(outfile, \" (group %d)\\n\", groupnumber);\n      else fprintf(outfile, \" (non-unique)\\n\");\n    PCRE2_SUBSTRING_FREE(gotbuffer);\n    }\n  nptr += namelen + 1;\n  }\n\n/* Test getting the complete list of captured strings. */\n\nif ((dat_datctl.control & CTL_GETALL) != 0)\n  {\n  int rc;\n  void **stringlist;\n  PCRE2_SIZE *lengths;\n  PCRE2_SUBSTRING_LIST_GET(rc, match_data, &stringlist, &lengths);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"get substring list failed (%d): \", rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    for (i = 0; i < capcount; i++)\n      {\n      fprintf(outfile, \"%2dL \", i);\n      PCHARSV(stringlist[i], 0, lengths[i], utf, outfile);\n      putc('\\n', outfile);\n      }\n    if (stringlist[i] != NULL)\n      fprintf(outfile, \"string list not terminated by NULL\\n\");\n    PCRE2_SUBSTRING_LIST_FREE(stringlist);\n    }\n  }\n\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*            Show an entire ovector              *\n*************************************************/\n\n/* This function is called after partial matching or match failure, when the\n\"allvector\" modifier is set. It is a means of checking the contents of the\nentire ovector, to ensure no modification of fields that should be unchanged.\n\nArguments:\n  ovector      points to the ovector\n  oveccount    number of pairs\n\nReturns:       nothing\n*/\n\nstatic void\nshow_ovector(PCRE2_SIZE *ovector, uint32_t oveccount)\n{\nuint32_t i;\nfor (i = 0; i < 2*oveccount; i += 2)\n  {\n  PCRE2_SIZE start = ovector[i];\n  PCRE2_SIZE end = ovector[i+1];\n\n  fprintf(outfile, \"%2d: \", i/2);\n  if (start == PCRE2_UNSET && end == PCRE2_UNSET)\n    fprintf(outfile, \"<unset>\\n\");\n  else if (start == JUNK_OFFSET && end == JUNK_OFFSET)\n    fprintf(outfile, \"<unchanged>\\n\");\n  else\n    fprintf(outfile, \"%ld %ld\\n\", (unsigned long int)start,\n      (unsigned long int)end);\n  }\n}\n\n\n/*************************************************\n*               Process a data line              *\n*************************************************/\n\n/* The line is in buffer; it will not be empty.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_data(void)\n{\nPCRE2_SIZE len, ulen, arg_ulen;\nuint32_t gmatched;\nuint32_t c, k;\nuint32_t g_notempty = 0;\nuint8_t *p, *pp, *start_rep;\nsize_t needlen;\nvoid *use_dat_context;\nBOOL utf;\nBOOL subject_literal;\n\nPCRE2_SIZE *ovector;\nPCRE2_SIZE ovecsave[3];\nuint32_t oveccount;\n\n#ifdef SUPPORT_PCRE2_8\nuint8_t *q8 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_16\nuint16_t *q16 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_32\nuint32_t *q32 = NULL;\n#endif\n\nsubject_literal = (pat_patctl.control2 & CTL2_SUBJECT_LITERAL) != 0;\n\n/* Copy the default context and data control blocks to the active ones. Then\ncopy from the pattern the controls that can be set in either the pattern or the\ndata. This allows them to be overridden in the data line. We do not do this for\noptions because those that are common apply separately to compiling and\nmatching. */\n\nDATCTXCPY(dat_context, default_dat_context);\nmemcpy(&dat_datctl, &def_datctl, sizeof(datctl));\ndat_datctl.control |= (pat_patctl.control & CTL_ALLPD);\ndat_datctl.control2 |= (pat_patctl.control2 & CTL2_ALLPD);\nstrcpy((char *)dat_datctl.replacement, (char *)pat_patctl.replacement);\nif (dat_datctl.jitstack == 0) dat_datctl.jitstack = pat_patctl.jitstack;\n\nif (dat_datctl.substitute_skip == 0)\n    dat_datctl.substitute_skip = pat_patctl.substitute_skip;\nif (dat_datctl.substitute_stop == 0)\n    dat_datctl.substitute_stop = pat_patctl.substitute_stop;\n\n/* Initialize for scanning the data line. */\n\n#ifdef SUPPORT_PCRE2_8\nutf = ((((pat_patctl.control & CTL_POSIX) != 0)?\n  ((pcre2_real_code_8 *)preg.re_pcre2_code)->overall_options :\n  FLD(compiled_code, overall_options)) & PCRE2_UTF) != 0;\n#else\nutf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n#endif\n\nstart_rep = NULL;\nlen = strlen((const char *)buffer);\nwhile (len > 0 && isspace(buffer[len-1])) len--;\nbuffer[len] = 0;\np = buffer;\nwhile (isspace(*p)) p++;\n\n/* Check that the data is well-formed UTF-8 if we're in UTF mode. To create\ninvalid input to pcre2_match(), you must use \\x?? or \\x{} sequences. */\n\nif (utf)\n  {\n  uint8_t *q;\n  uint32_t cc;\n  int n = 1;\n  for (q = p; n > 0 && *q; q += n) n = utf82ord(q, &cc);\n  if (n <= 0)\n    {\n    fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be used as input \"\n      \"in UTF mode\\n\");\n    return PR_OK;\n    }\n  }\n\n#ifdef SUPPORT_VALGRIND\n/* Mark the dbuffer as addressable but undefined again. */\nif (dbuffer != NULL)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(dbuffer, dbuffer_size);\n  }\n#endif\n\n/* Allocate a buffer to hold the data line; len+1 is an upper bound on\nthe number of code units that will be needed (though the buffer may have to be\nextended if replication is involved). */\n\nneedlen = (size_t)((len+1) * code_unit_size);\nif (dbuffer == NULL || needlen >= dbuffer_size)\n  {\n  while (needlen >= dbuffer_size) dbuffer_size *= 2;\n  dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);\n  if (dbuffer == NULL)\n    {\n    fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);\n    exit(1);\n    }\n  }\nSETCASTPTR(q, dbuffer);  /* Sets q8, q16, or q32, as appropriate. */\n\n/* Scan the data line, interpreting data escapes, and put the result into a\nbuffer of the appropriate width. In UTF mode, input is always UTF-8; otherwise,\nin 16- and 32-bit modes, it can be forced to UTF-8 by the utf8_input modifier.\n*/\n\nwhile ((c = *p++) != 0)\n  {\n  int32_t i = 0;\n  size_t replen;\n\n  /* ] may mark the end of a replicated sequence */\n\n  if (c == ']' && start_rep != NULL)\n    {\n    long li;\n    char *endptr;\n\n    if (*p++ != '{')\n      {\n      fprintf(outfile, \"** Expected '{' after \\\\[....]\\n\");\n      return PR_OK;\n      }\n\n    li = strtol((const char *)p, &endptr, 10);\n    if (S32OVERFLOW(li))\n      {\n      fprintf(outfile, \"** Repeat count too large\\n\");\n      return PR_OK;\n      }\n\n    p = (uint8_t *)endptr;\n    if (*p++ != '}')\n      {\n      fprintf(outfile, \"** Expected '}' after \\\\[...]{...\\n\");\n      return PR_OK;\n      }\n\n    i = (int32_t)li;\n    if (i-- == 0)\n      {\n      fprintf(outfile, \"** Zero repeat not allowed\\n\");\n      return PR_OK;\n      }\n\n    replen = CAST8VAR(q) - start_rep;\n    needlen += replen * i;\n\n    if (needlen >= dbuffer_size)\n      {\n      size_t qoffset = CAST8VAR(q) - dbuffer;\n      size_t rep_offset = start_rep - dbuffer;\n      while (needlen >= dbuffer_size) dbuffer_size *= 2;\n      dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);\n      if (dbuffer == NULL)\n        {\n        fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);\n        exit(1);\n        }\n      SETCASTPTR(q, dbuffer + qoffset);\n      start_rep = dbuffer + rep_offset;\n      }\n\n    while (i-- > 0)\n      {\n      memcpy(CAST8VAR(q), start_rep, replen);\n      SETPLUS(q, replen/code_unit_size);\n      }\n\n    start_rep = NULL;\n    continue;\n    }\n\n  /* Handle a non-escaped character. In non-UTF 32-bit mode with utf8_input\n  set, do the fudge for setting the top bit. */\n\n  if (c != '\\\\' || subject_literal)\n    {\n    uint32_t topbit = 0;\n    if (test_mode == PCRE32_MODE && c == 0xff && *p != 0)\n      {\n      topbit = 0x80000000;\n      c = *p++;\n      }\n    if ((utf || (pat_patctl.control & CTL_UTF8_INPUT) != 0) &&\n      HASUTF8EXTRALEN(c)) { GETUTF8INC(c, p); }\n    c |= topbit;\n    }\n\n  /* Handle backslash escapes */\n\n  else switch ((c = *p++))\n    {\n    case '\\\\': break;\n    case 'a': c = CHAR_BEL; break;\n    case 'b': c = '\\b'; break;\n    case 'e': c = CHAR_ESC; break;\n    case 'f': c = '\\f'; break;\n    case 'n': c = '\\n'; break;\n    case 'r': c = '\\r'; break;\n    case 't': c = '\\t'; break;\n    case 'v': c = '\\v'; break;\n\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n    c -= '0';\n    while (i++ < 2 && isdigit(*p) && *p != '8' && *p != '9')\n      c = c * 8 + *p++ - '0';\n    break;\n\n    case 'o':\n    if (*p == '{')\n      {\n      uint8_t *pt = p;\n      c = 0;\n      for (pt++; isdigit(*pt) && *pt != '8' && *pt != '9'; pt++)\n        {\n        if (++i == 12)\n          fprintf(outfile, \"** Too many octal digits in \\\\o{...} item; \"\n                           \"using only the first twelve.\\n\");\n        else c = c * 8 + *pt - '0';\n        }\n      if (*pt == '}') p = pt + 1;\n        else fprintf(outfile, \"** Missing } after \\\\o{ (assumed)\\n\");\n      }\n    break;\n\n    case 'x':\n    if (*p == '{')\n      {\n      uint8_t *pt = p;\n      c = 0;\n\n      /* We used to have \"while (isxdigit(*(++pt)))\" here, but it fails\n      when isxdigit() is a macro that refers to its argument more than\n      once. This is banned by the C Standard, but apparently happens in at\n      least one MacOS environment. */\n\n      for (pt++; isxdigit(*pt); pt++)\n        {\n        if (++i == 9)\n          fprintf(outfile, \"** Too many hex digits in \\\\x{...} item; \"\n                           \"using only the first eight.\\n\");\n        else c = c * 16 + tolower(*pt) - ((isdigit(*pt))? '0' : 'a' - 10);\n        }\n      if (*pt == '}')\n        {\n        p = pt + 1;\n        break;\n        }\n      /* Not correct form for \\x{...}; fall through */\n      }\n\n    /* \\x without {} always defines just one byte in 8-bit mode. This\n    allows UTF-8 characters to be constructed byte by byte, and also allows\n    invalid UTF-8 sequences to be made. Just copy the byte in UTF-8 mode.\n    Otherwise, pass it down as data. */\n\n    c = 0;\n    while (i++ < 2 && isxdigit(*p))\n      {\n      c = c * 16 + tolower(*p) - ((isdigit(*p))? '0' : 'a' - 10);\n      p++;\n      }\n#if defined SUPPORT_PCRE2_8\n    if (utf && (test_mode == PCRE8_MODE))\n      {\n      *q8++ = c;\n      continue;\n      }\n#endif\n    break;\n\n    case 0:     /* \\ followed by EOF allows for an empty line */\n    p--;\n    continue;\n\n    case '=':   /* \\= terminates the data, starts modifiers */\n    goto ENDSTRING;\n\n    case '[':   /* \\[ introduces a replicated character sequence */\n    if (start_rep != NULL)\n      {\n      fprintf(outfile, \"** Nested replication is not supported\\n\");\n      return PR_OK;\n      }\n    start_rep = CAST8VAR(q);\n    continue;\n\n    default:\n    if (isalnum(c))\n      {\n      fprintf(outfile, \"** Unrecognized escape sequence \\\"\\\\%c\\\"\\n\", c);\n      return PR_OK;\n      }\n    }\n\n  /* We now have a character value in c that may be greater than 255.\n  In 8-bit mode we convert to UTF-8 if we are in UTF mode. Values greater\n  than 127 in UTF mode must have come from \\x{...} or octal constructs\n  because values from \\x.. get this far only in non-UTF mode. */\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE)\n    {\n    if (utf)\n      {\n      if (c > 0x7fffffff)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 0x7fffffff \"\n          \"and so cannot be converted to UTF-8\\n\", c);\n        return PR_OK;\n        }\n      q8 += ord2utf8(c, q8);\n      }\n    else\n      {\n      if (c > 0xffu)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 255 \"\n          \"and UTF-8 mode is not enabled.\\n\", c);\n        fprintf(outfile, \"** Truncation will probably give the wrong \"\n          \"result.\\n\");\n        }\n      *q8++ = (uint8_t)c;\n      }\n    }\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)\n    {\n    if (utf)\n      {\n      if (c > 0x10ffffu)\n        {\n        fprintf(outfile, \"** Failed: character \\\\x{%x} is greater than \"\n          \"0x10ffff and so cannot be converted to UTF-16\\n\", c);\n        return PR_OK;\n        }\n      else if (c >= 0x10000u)\n        {\n        c-= 0x10000u;\n        *q16++ = 0xD800 | (c >> 10);\n        *q16++ = 0xDC00 | (c & 0x3ff);\n        }\n      else\n        *q16++ = c;\n      }\n    else\n      {\n      if (c > 0xffffu)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 0xffff \"\n          \"and UTF-16 mode is not enabled.\\n\", c);\n        fprintf(outfile, \"** Truncation will probably give the wrong \"\n          \"result.\\n\");\n        }\n\n      *q16++ = (uint16_t)c;\n      }\n    }\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)\n    {\n    *q32++ = c;\n    }\n#endif\n  }\n\nENDSTRING:\nSET(*q, 0);\nlen = CASTVAR(uint8_t *, q) - dbuffer;    /* Length in bytes */\nulen = len/code_unit_size;                /* Length in code units */\narg_ulen = ulen;                          /* Value to use in match arg */\n\n/* If the string was terminated by \\= we must now interpret modifiers. */\n\nif (p[-1] != 0 && !decode_modifiers(p, CTX_DAT, NULL, &dat_datctl))\n  return PR_OK;\n\n/* Setting substitute_{skip,fail} implies a substitute callout. */\n\nif (dat_datctl.substitute_skip != 0 || dat_datctl.substitute_stop != 0)\n  dat_datctl.control2 |= CTL2_SUBSTITUTE_CALLOUT;\n\n/* Check for mutually exclusive modifiers. At present, these are all in the\nfirst control word. */\n\nfor (k = 0; k < sizeof(exclusive_dat_controls)/sizeof(uint32_t); k++)\n  {\n  c = dat_datctl.control & exclusive_dat_controls[k];\n  if (c != 0 && c != (c & (~c+1)))\n    {\n    show_controls(c, 0, \"** Not allowed together:\");\n    fprintf(outfile, \"\\n\");\n    return PR_OK;\n    }\n  }\n\nif (pat_patctl.replacement[0] != 0)\n  {\n  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0 &&\n      (dat_datctl.control & CTL_NULLCONTEXT) != 0)\n    {\n    fprintf(outfile, \"** Replacement callouts are not supported with null_context.\\n\");\n    return PR_OK;\n    }\n\n  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)\n    fprintf(outfile, \"** Ignored with replacement text: allcaptures\\n\");\n  }\n\n/* Warn for modifiers that are ignored for DFA. */\n\nif ((dat_datctl.control & CTL_DFA) != 0)\n  {\n  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)\n    fprintf(outfile, \"** Ignored after DFA matching: allcaptures\\n\");\n  }\n\n/* We now have the subject in dbuffer, with len containing the byte length, and\nulen containing the code unit length, with a copy in arg_ulen for use in match\nfunction arguments (this gets changed to PCRE2_ZERO_TERMINATED when the\nzero_terminate modifier is present).\n\nMove the data to the end of the buffer so that a read over the end can be\ncaught by valgrind or other means. If we have explicit valgrind support, mark\nthe unused start of the buffer unaddressable. If we are using the POSIX\ninterface, or testing zero-termination, we must include the terminating zero in\nthe usable data. */\n\nc = code_unit_size * (((pat_patctl.control & CTL_POSIX) +\n                       (dat_datctl.control & CTL_ZERO_TERMINATE) != 0)? 1:0);\npp = memmove(dbuffer + dbuffer_size - len - c, dbuffer, len + c);\n#ifdef SUPPORT_VALGRIND\n  VALGRIND_MAKE_MEM_NOACCESS(dbuffer, dbuffer_size - (len + c));\n#endif\n\n/* Now pp points to the subject string, but if null_subject was specified, set\nit to NULL to test PCRE2's behaviour. */\n\nif ((dat_datctl.control2 & CTL2_NULL_SUBJECT) != 0) pp = NULL;\n\n/* POSIX matching is only possible in 8-bit mode, and it does not support\ntiming or other fancy features. Some were checked at compile time, but we need\nto check the match-time settings here. */\n\n#ifdef SUPPORT_PCRE2_8\nif ((pat_patctl.control & CTL_POSIX) != 0)\n  {\n  int rc;\n  int eflags = 0;\n  regmatch_t *pmatch = NULL;\n  const char *msg = \"** Ignored with POSIX interface:\";\n\n  if (dat_datctl.cerror[0] != CFORE_UNSET || dat_datctl.cerror[1] != CFORE_UNSET)\n    prmsg(&msg, \"callout_error\");\n  if (dat_datctl.cfail[0] != CFORE_UNSET || dat_datctl.cfail[1] != CFORE_UNSET)\n    prmsg(&msg, \"callout_fail\");\n  if (dat_datctl.copy_numbers[0] >= 0 || dat_datctl.copy_names[0] != 0)\n    prmsg(&msg, \"copy\");\n  if (dat_datctl.get_numbers[0] >= 0 || dat_datctl.get_names[0] != 0)\n    prmsg(&msg, \"get\");\n  if (dat_datctl.jitstack != 0) prmsg(&msg, \"jitstack\");\n  if (dat_datctl.offset != 0) prmsg(&msg, \"offset\");\n\n  if ((dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS) != 0)\n    {\n    fprintf(outfile, \"%s\", msg);\n    show_match_options(dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS);\n    msg = \"\";\n    }\n  if ((dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS) != 0 ||\n      (dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2) != 0)\n    {\n    show_controls(dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS,\n                  dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2, msg);\n    msg = \"\";\n    }\n\n  if (msg[0] == 0) fprintf(outfile, \"\\n\");\n\n  if (dat_datctl.oveccount > 0)\n    {\n    pmatch = (regmatch_t *)malloc(sizeof(regmatch_t) * dat_datctl.oveccount);\n    if (pmatch == NULL)\n      {\n      fprintf(outfile, \"** Failed to get memory for recording matching \"\n        \"information (size set = %du)\\n\", dat_datctl.oveccount);\n      return PR_OK;\n      }\n    }\n\n  if (dat_datctl.startend[0] != CFORE_UNSET)\n    {\n    pmatch[0].rm_so = dat_datctl.startend[0];\n    pmatch[0].rm_eo = (dat_datctl.startend[1] != 0)?\n      dat_datctl.startend[1] : len;\n    eflags |= REG_STARTEND;\n    }\n\n  if ((dat_datctl.options & PCRE2_NOTBOL) != 0) eflags |= REG_NOTBOL;\n  if ((dat_datctl.options & PCRE2_NOTEOL) != 0) eflags |= REG_NOTEOL;\n  if ((dat_datctl.options & PCRE2_NOTEMPTY) != 0) eflags |= REG_NOTEMPTY;\n\n  rc = regexec(&preg, (const char *)pp, dat_datctl.oveccount, pmatch, eflags);\n  if (rc != 0)\n    {\n    (void)regerror(rc, &preg, (char *)pbuffer8, pbuffer8_size);\n    fprintf(outfile, \"No match: POSIX code %d: %s\\n\", rc, pbuffer8);\n    }\n  else if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0)\n    fprintf(outfile, \"Matched with REG_NOSUB\\n\");\n  else if (dat_datctl.oveccount == 0)\n    fprintf(outfile, \"Matched without capture\\n\");\n  else\n    {\n    size_t i, j;\n    size_t last_printed = (size_t)dat_datctl.oveccount;\n    for (i = 0; i < (size_t)dat_datctl.oveccount; i++)\n      {\n      if (pmatch[i].rm_so >= 0)\n        {\n        PCRE2_SIZE start = pmatch[i].rm_so;\n        PCRE2_SIZE end = pmatch[i].rm_eo;\n        for (j = last_printed + 1; j < i; j++)\n          fprintf(outfile, \"%2d: <unset>\\n\", (int)j);\n        last_printed = i;\n        if (start > end)\n          {\n          start = pmatch[i].rm_eo;\n          end = pmatch[i].rm_so;\n          fprintf(outfile, \"Start of matched string is beyond its end - \"\n            \"displaying from end to start.\\n\");\n          }\n        fprintf(outfile, \"%2d: \", (int)i);\n        PCHARSV(pp, start, end - start, utf, outfile);\n        fprintf(outfile, \"\\n\");\n\n        if ((i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0) ||\n            (dat_datctl.control & CTL_ALLAFTERTEXT) != 0)\n          {\n          fprintf(outfile, \"%2d+ \", (int)i);\n          /* Note: don't use the start/end variables here because we want to\n          show the text from what is reported as the end. */\n          PCHARSV(pp, pmatch[i].rm_eo, len - pmatch[i].rm_eo, utf, outfile);\n          fprintf(outfile, \"\\n\"); }\n        }\n      }\n    }\n  free(pmatch);\n  return PR_OK;\n  }\n#endif  /* SUPPORT_PCRE2_8 */\n\n /* Handle matching via the native interface. Check for consistency of\nmodifiers. */\n\nif (dat_datctl.startend[0] != CFORE_UNSET)\n  fprintf(outfile, \"** \\\\=posix_startend ignored for non-POSIX matching\\n\");\n\n/* ALLUSEDTEXT is not supported with JIT, but JIT is not used with DFA\nmatching, even if the JIT compiler was used. */\n\nif ((dat_datctl.control & (CTL_ALLUSEDTEXT|CTL_DFA)) == CTL_ALLUSEDTEXT &&\n    FLD(compiled_code, executable_jit) != NULL)\n  {\n  fprintf(outfile, \"** Showing all consulted text is not supported by JIT: ignored\\n\");\n  dat_datctl.control &= ~CTL_ALLUSEDTEXT;\n  }\n\n/* Handle passing the subject as zero-terminated. */\n\nif ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)\n  arg_ulen = PCRE2_ZERO_TERMINATED;\n\n/* The nullcontext modifier is used to test calling pcre2_[jit_]match() with a\nNULL context. */\n\nuse_dat_context = ((dat_datctl.control & CTL_NULLCONTEXT) != 0)?\n  NULL : PTR(dat_context);\n\n/* Enable display of malloc/free if wanted. We can do this only if either the\npattern or the subject is processed with a context. */\n\nshow_memory = (dat_datctl.control & CTL_MEMORY) != 0;\n\nif (show_memory &&\n    (pat_patctl.control & dat_datctl.control & CTL_NULLCONTEXT) != 0)\n  fprintf(outfile, \"** \\\\=memory requires either a pattern or a subject \"\n    \"context: ignored\\n\");\n\n/* Create and assign a JIT stack if requested. */\n\nif (dat_datctl.jitstack != 0)\n  {\n  if (dat_datctl.jitstack != jit_stack_size)\n    {\n    PCRE2_JIT_STACK_FREE(jit_stack);\n    PCRE2_JIT_STACK_CREATE(jit_stack, 1, dat_datctl.jitstack * 1024, NULL);\n    jit_stack_size = dat_datctl.jitstack;\n    }\n  PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, jit_stack);\n  }\n\n/* Or de-assign */\n\nelse if (jit_stack != NULL)\n  {\n  PCRE2_JIT_STACK_ASSIGN(dat_context, NULL, NULL);\n  PCRE2_JIT_STACK_FREE(jit_stack);\n  jit_stack = NULL;\n  jit_stack_size = 0;\n  }\n\n/* When no JIT stack is assigned, we must ensure that there is a JIT callback\nif we want to verify that JIT was actually used. */\n\nif ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_stack == NULL)\n   {\n   PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, NULL);\n   }\n\n/* Adjust match_data according to size of offsets required. A size of zero\ncauses a new match data block to be obtained that exactly fits the pattern. */\n\nif (dat_datctl.oveccount == 0)\n  {\n  PCRE2_MATCH_DATA_FREE(match_data);\n  PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code,\n    general_context);\n  PCRE2_GET_OVECTOR_COUNT(max_oveccount, match_data);\n  }\nelse if (dat_datctl.oveccount <= max_oveccount)\n  {\n  SETFLD(match_data, oveccount, dat_datctl.oveccount);\n  }\nelse\n  {\n  max_oveccount = dat_datctl.oveccount;\n  PCRE2_MATCH_DATA_FREE(match_data);\n  PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, general_context);\n  }\n\nif (CASTVAR(void *, match_data) == NULL)\n  {\n  fprintf(outfile, \"** Failed to get memory for recording matching \"\n    \"information (size requested: %d)\\n\", dat_datctl.oveccount);\n  max_oveccount = 0;\n  return PR_OK;\n  }\n\novector = FLD(match_data, ovector);\nPCRE2_GET_OVECTOR_COUNT(oveccount, match_data);\n\n/* Replacement processing is ignored for DFA matching. */\n\nif (dat_datctl.replacement[0] != 0 && (dat_datctl.control & CTL_DFA) != 0)\n  {\n  fprintf(outfile, \"** Ignored for DFA matching: replace\\n\");\n  dat_datctl.replacement[0] = 0;\n  }\n\n/* If a replacement string is provided, call pcre2_substitute() instead of one\nof the matching functions. First we have to convert the replacement string to\nthe appropriate width. */\n\nif (dat_datctl.replacement[0] != 0)\n  {\n  int rc;\n  uint8_t *pr;\n  uint8_t rbuffer[REPLACE_BUFFSIZE];\n  uint8_t nbuffer[REPLACE_BUFFSIZE];\n  uint8_t *rbptr;\n  uint32_t xoptions;\n  uint32_t emoption;  /* External match option */\n  PCRE2_SIZE j, rlen, nsize, erroroffset;\n  BOOL badutf = FALSE;\n\n#ifdef SUPPORT_PCRE2_8\n  uint8_t *r8 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_16\n  uint16_t *r16 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_32\n  uint32_t *r32 = NULL;\n#endif\n\n  /* Fill the ovector with junk to detect elements that do not get set\n  when they should be (relevant only when \"allvector\" is specified). */\n\n  for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;\n\n  if (timeitm)\n    fprintf(outfile, \"** Timing is not supported with replace: ignored\\n\");\n\n  if ((dat_datctl.control & CTL_ALTGLOBAL) != 0)\n    fprintf(outfile, \"** Altglobal is not supported with replace: ignored\\n\");\n\n  /* Check for a test that does substitution after an initial external match.\n  If this is set, we run the external match, but leave the interpretation of\n  its output to pcre2_substitute(). */\n\n  emoption = ((dat_datctl.control2 & CTL2_SUBSTITUTE_MATCHED) == 0)? 0 :\n    PCRE2_SUBSTITUTE_MATCHED;\n\n  if (emoption != 0)\n    {\n    PCRE2_MATCH(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, use_dat_context);\n    }\n\n  xoptions = emoption |\n             (((dat_datctl.control & CTL_GLOBAL) == 0)? 0 :\n                PCRE2_SUBSTITUTE_GLOBAL) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_EXTENDED) == 0)? 0 :\n                PCRE2_SUBSTITUTE_EXTENDED) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_LITERAL) == 0)? 0 :\n                PCRE2_SUBSTITUTE_LITERAL) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) == 0)? 0 :\n                PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) == 0)? 0 :\n                PCRE2_SUBSTITUTE_REPLACEMENT_ONLY) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) == 0)? 0 :\n                PCRE2_SUBSTITUTE_UNKNOWN_UNSET) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNSET_EMPTY) == 0)? 0 :\n                PCRE2_SUBSTITUTE_UNSET_EMPTY);\n\n  SETCASTPTR(r, rbuffer);  /* Sets r8, r16, or r32, as appropriate. */\n  pr = dat_datctl.replacement;\n\n  /* If the replacement starts with '[<number>]' we interpret that as length\n  value for the replacement buffer. */\n\n  nsize = REPLACE_BUFFSIZE/code_unit_size;\n  if (*pr == '[')\n    {\n    PCRE2_SIZE n = 0;\n    while ((c = *(++pr)) >= CHAR_0 && c <= CHAR_9) n = n * 10 + c - CHAR_0;\n    if (*pr++ != ']')\n      {\n      fprintf(outfile, \"Bad buffer size in replacement string\\n\");\n      return PR_OK;\n      }\n    if (n > nsize)\n      {\n      fprintf(outfile, \"Replacement buffer setting (%\" SIZ_FORM \") is too \"\n        \"large (max %\" SIZ_FORM \")\\n\", n, nsize);\n      return PR_OK;\n      }\n    nsize = n;\n    }\n\n  /* Now copy the replacement string to a buffer of the appropriate width. No\n  escape processing is done for replacements. In UTF mode, check for an invalid\n  UTF-8 input string, and if it is invalid, just copy its code units without\n  UTF interpretation. This provides a means of checking that an invalid string\n  is detected. Otherwise, UTF-8 can be used to include wide characters in a\n  replacement. */\n\n  if (utf) badutf = valid_utf(pr, strlen((const char *)pr), &erroroffset);\n\n  /* Not UTF or invalid UTF-8: just copy the code units. */\n\n  if (!utf || badutf)\n    {\n    while ((c = *pr++) != 0)\n      {\n#ifdef SUPPORT_PCRE2_8\n      if (test_mode == PCRE8_MODE) *r8++ = c;\n#endif\n#ifdef SUPPORT_PCRE2_16\n      if (test_mode == PCRE16_MODE) *r16++ = c;\n#endif\n#ifdef SUPPORT_PCRE2_32\n      if (test_mode == PCRE32_MODE) *r32++ = c;\n#endif\n      }\n    }\n\n  /* Valid UTF-8 replacement string */\n\n  else while ((c = *pr++) != 0)\n    {\n    if (HASUTF8EXTRALEN(c)) { GETUTF8INC(c, pr); }\n\n#ifdef SUPPORT_PCRE2_8\n    if (test_mode == PCRE8_MODE) r8 += ord2utf8(c, r8);\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n    if (test_mode == PCRE16_MODE)\n      {\n      if (c >= 0x10000u)\n        {\n        c-= 0x10000u;\n        *r16++ = 0xD800 | (c >> 10);\n        *r16++ = 0xDC00 | (c & 0x3ff);\n        }\n      else *r16++ = c;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n    if (test_mode == PCRE32_MODE) *r32++ = c;\n#endif\n    }\n\n  SET(*r, 0);\n  if ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)\n    rlen = PCRE2_ZERO_TERMINATED;\n  else\n    rlen = (CASTVAR(uint8_t *, r) - rbuffer)/code_unit_size;\n\n  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0)\n    {\n    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, substitute_callout_function, NULL);\n    }\n  else\n    {\n    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, NULL, NULL);  /* No callout */\n    }\n\n  /* There is a special option to set the replacement to NULL in order to test\n  that case. */\n\n  rbptr = ((dat_datctl.control2 & CTL2_NULL_REPLACEMENT) == 0)? rbuffer : NULL;\n\n  PCRE2_SUBSTITUTE(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,\n    dat_datctl.options|xoptions, match_data, use_dat_context,\n    rbptr, rlen, nbuffer, &nsize);\n\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Failed: error %d\", rc);\n    if (rc != PCRE2_ERROR_NOMEMORY && nsize != PCRE2_UNSET)\n      fprintf(outfile, \" at offset %ld in replacement\", (long int)nsize);\n    fprintf(outfile, \": \");\n    if (!print_error_message(rc, \"\", \"\")) return PR_ABEND;\n    if (rc == PCRE2_ERROR_NOMEMORY &&\n        (xoptions & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)\n      fprintf(outfile, \": %ld code units are needed\", (long int)nsize);\n    }\n  else\n    {\n    fprintf(outfile, \"%2d: \", rc);\n    PCHARSV(nbuffer, 0, nsize, utf, outfile);\n    }\n\n  fprintf(outfile, \"\\n\");\n  show_memory = FALSE;\n\n  /* Show final ovector contents if requested. */\n\n  if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n    show_ovector(ovector, oveccount);\n\n  return PR_OK;\n  }   /* End of substitution handling */\n\n/* When a replacement string is not provided, run a loop for global matching\nwith one of the basic matching functions. For altglobal (or first time round\nthe loop), set an \"unset\" value for the previous match info. */\n\novecsave[0] = ovecsave[1] = ovecsave[2] = PCRE2_UNSET;\n\nfor (gmatched = 0;; gmatched++)\n  {\n  PCRE2_SIZE j;\n  int capcount;\n\n  /* Fill the ovector with junk to detect elements that do not get set\n  when they should be. */\n\n  for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;\n\n  /* When matching is via pcre2_match(), we will detect the use of JIT via the\n  stack callback function. */\n\n  jit_was_used = (pat_patctl.control & CTL_JITFAST) != 0;\n\n  /* Do timing if required. */\n\n  if (timeitm > 0)\n    {\n    int i;\n    clock_t start_time, time_taken;\n\n    if ((dat_datctl.control & CTL_DFA) != 0)\n      {\n      if ((dat_datctl.options & PCRE2_DFA_RESTART) != 0)\n        {\n        fprintf(outfile, \"Timing DFA restarts is not supported\\n\");\n        return PR_OK;\n        }\n      if (dfa_workspace == NULL)\n        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context, dfa_workspace, DFA_WS_DIMENSION);\n        }\n      }\n\n    else if ((pat_patctl.control & CTL_JITFAST) != 0)\n      {\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context);\n        }\n      }\n\n    else\n      {\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context);\n        }\n      }\n    total_match_time += (time_taken = clock() - start_time);\n    fprintf(outfile, \"Match time %.4f milliseconds\\n\",\n      (((double)time_taken * 1000.0) / (double)timeitm) /\n        (double)CLOCKS_PER_SEC);\n    }\n\n  /* Find the heap, match and depth limits if requested. The depth and heap\n  limits are not relevant for JIT. The return from check_match_limit() is the\n  return from the final call to pcre2_match() or pcre2_dfa_match(). */\n\n  if ((dat_datctl.control & (CTL_FINDLIMITS|CTL_FINDLIMITS_NOHEAP)) != 0)\n    {\n    capcount = 0;  /* This stops compiler warnings */\n\n    if ((dat_datctl.control & CTL_FINDLIMITS_NOHEAP) == 0 &&\n        (FLD(compiled_code, executable_jit) == NULL ||\n          (dat_datctl.options & PCRE2_NO_JIT) != 0))\n      {\n      (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, \"heap\");\n      }\n\n    capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,\n      \"match\");\n\n    if (FLD(compiled_code, executable_jit) == NULL ||\n        (dat_datctl.options & PCRE2_NO_JIT) != 0 ||\n        (dat_datctl.control & CTL_DFA) != 0)\n      {\n      capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_DEPTHLIMIT,\n        \"depth\");\n      }\n\n    if (capcount == 0)\n      {\n      fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");\n      capcount = dat_datctl.oveccount;\n      }\n    }\n\n  /* Otherwise just run a single match, setting up a callout if required (the\n  default). There is a copy of the pattern in pbuffer8 for use by callouts. */\n\n  else\n    {\n    if ((dat_datctl.control & CTL_CALLOUT_NONE) == 0)\n      {\n      PCRE2_SET_CALLOUT(dat_context, callout_function,\n        (void *)(&dat_datctl.callout_data));\n      first_callout = TRUE;\n      last_callout_mark = NULL;\n      callout_count = 0;\n      }\n    else\n      {\n      PCRE2_SET_CALLOUT(dat_context, NULL, NULL);  /* No callout */\n      }\n\n    /* Run a single DFA or NFA match. */\n\n    if ((dat_datctl.control & CTL_DFA) != 0)\n      {\n      if (dfa_workspace == NULL)\n        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n      if (dfa_matched++ == 0)\n        dfa_workspace[0] = -1;  /* To catch bad restart */\n      PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,\n        dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n        use_dat_context, dfa_workspace, DFA_WS_DIMENSION);\n      if (capcount == 0)\n        {\n        fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");\n        capcount = dat_datctl.oveccount;\n        }\n      }\n    else\n      {\n      if ((pat_patctl.control & CTL_JITFAST) != 0)\n        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,\n          dat_datctl.options | g_notempty, match_data, use_dat_context);\n      else\n        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,\n          dat_datctl.options | g_notempty, match_data, use_dat_context);\n      if (capcount == 0)\n        {\n        fprintf(outfile, \"Matched, but too many substrings\\n\");\n        capcount = dat_datctl.oveccount;\n        }\n      }\n    }\n\n  /* The result of the match is now in capcount. First handle a successful\n  match. If pp was forced to be NULL (to test NULL handling) it will have been\n  treated as an empty string if the length was zero. So re-create that for\n  outputting. */\n\n  if (capcount >= 0)\n    {\n    int i;\n\n    if (pp == NULL) pp = (uint8_t *)\"\";\n\n    if (capcount > (int)oveccount)   /* Check for lunatic return value */\n      {\n      fprintf(outfile,\n        \"** PCRE2 error: returned count %d is too big for ovector count %d\\n\",\n        capcount, oveccount);\n      capcount = oveccount;\n      if ((dat_datctl.control & CTL_ANYGLOB) != 0)\n        {\n        fprintf(outfile, \"** Global loop abandoned\\n\");\n        dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */\n        }\n      }\n\n    /* If PCRE2_COPY_MATCHED_SUBJECT was set, check that things are as they\n    should be, but not for fast JIT, where it isn't supported. */\n\n    if ((dat_datctl.options & PCRE2_COPY_MATCHED_SUBJECT) != 0 &&\n        (pat_patctl.control & CTL_JITFAST) == 0)\n      {\n      if ((FLD(match_data, flags) & PCRE2_MD_COPIED_SUBJECT) == 0)\n        fprintf(outfile,\n          \"** PCRE2 error: flag not set after copy_matched_subject\\n\");\n\n      if (CASTFLD(void *, match_data, subject) == pp)\n        fprintf(outfile,\n          \"** PCRE2 error: copy_matched_subject has not copied\\n\");\n\n      if (memcmp(CASTFLD(void *, match_data, subject), pp, ulen) != 0)\n        fprintf(outfile,\n          \"** PCRE2 error: copy_matched_subject mismatch\\n\");\n      }\n\n    /* If this is not the first time round a global loop, check that the\n    returned string has changed. If it has not, check for an empty string match\n    at different starting offset from the previous match. This is a failed test\n    retry for null-matching patterns that don't match at their starting offset,\n    for example /(?<=\\G.)/. A repeated match at the same point is not such a\n    pattern, and must be discarded, and we then proceed to seek a non-null\n    match at the current point. For any other repeated match, there is a bug\n    somewhere and we must break the loop because it will go on for ever. We\n    know that there are always at least two elements in the ovector. */\n\n    if (gmatched > 0 && ovecsave[0] == ovector[0] && ovecsave[1] == ovector[1])\n      {\n      if (ovector[0] == ovector[1] && ovecsave[2] != dat_datctl.offset)\n        {\n        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n        ovecsave[2] = dat_datctl.offset;\n        continue;    /* Back to the top of the loop */\n        }\n      fprintf(outfile,\n        \"** PCRE2 error: global repeat returned the same string as previous\\n\");\n      fprintf(outfile, \"** Global loop abandoned\\n\");\n      dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */\n      }\n\n    /* \"allcaptures\" requests showing of all captures in the pattern, to check\n    unset ones at the end. It may be set on the pattern or the data. Implement\n    by setting capcount to the maximum. This is not relevant for DFA matching,\n    so ignore it (warning given above). */\n\n    if ((dat_datctl.control & (CTL_ALLCAPTURES|CTL_DFA)) == CTL_ALLCAPTURES)\n      {\n      capcount = maxcapcount + 1;   /* Allow for full match */\n      if (capcount > (int)oveccount) capcount = oveccount;\n      }\n\n    /* \"allvector\" request showing the entire ovector. */\n\n    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0) capcount = oveccount;\n\n    /* Output the captured substrings. Note that, for the matched string,\n    the use of \\K in an assertion can make the start later than the end. */\n\n    for (i = 0; i < 2*capcount; i += 2)\n      {\n      PCRE2_SIZE lleft, lmiddle, lright;\n      PCRE2_SIZE start = ovector[i];\n      PCRE2_SIZE end = ovector[i+1];\n\n      if (start > end)\n        {\n        start = ovector[i+1];\n        end = ovector[i];\n        fprintf(outfile, \"Start of matched string is beyond its end - \"\n          \"displaying from end to start.\\n\");\n        }\n\n      fprintf(outfile, \"%2d: \", i/2);\n\n      /* Check for an unset group */\n\n      if (start == PCRE2_UNSET && end == PCRE2_UNSET)\n        {\n        fprintf(outfile, \"<unset>\\n\");\n        continue;\n        }\n\n      /* Check for silly offsets, in particular, values that have not been\n      set when they should have been. However, if we are past the end of the\n      captures for this pattern (\"allvector\" causes this), or if we are DFA\n      matching, it isn't an error if the entry is unchanged. */\n\n      if (start > ulen || end > ulen)\n        {\n        if (((dat_datctl.control & CTL_DFA) != 0 ||\n              i >= (int)(2*maxcapcount + 2)) &&\n            start == JUNK_OFFSET && end == JUNK_OFFSET)\n          fprintf(outfile, \"<unchanged>\\n\");\n        else\n          fprintf(outfile, \"ERROR: bad value(s) for offset(s): 0x%lx 0x%lx\\n\",\n            (unsigned long int)start, (unsigned long int)end);\n        continue;\n        }\n\n      /* When JIT is not being used, ALLUSEDTEXT may be set. (It if is set with\n      JIT, it is disabled above, with a comment.) When the match is done by the\n      interpreter, leftchar and rightchar are available, and if ALLUSEDTEXT is\n      set, and if the leftmost consulted character is before the start of the\n      match or the rightmost consulted character is past the end of the match,\n      we want to show all consulted characters for the main matched string, and\n      indicate which were lookarounds. */\n\n      if (i == 0)\n        {\n        BOOL showallused;\n        PCRE2_SIZE leftchar, rightchar;\n\n        if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)\n          {\n          leftchar = FLD(match_data, leftchar);\n          rightchar = FLD(match_data, rightchar);\n          showallused = i == 0 && (leftchar < start || rightchar > end);\n          }\n        else showallused = FALSE;\n\n        if (showallused)\n          {\n          PCHARS(lleft, pp, leftchar, start - leftchar, utf, outfile);\n          PCHARS(lmiddle, pp, start, end - start, utf, outfile);\n          PCHARS(lright, pp, end, rightchar - end, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          fprintf(outfile, \"\\n    \");\n          for (j = 0; j < lleft; j++) fprintf(outfile, \"<\");\n          for (j = 0; j < lmiddle; j++) fprintf(outfile, \" \");\n          for (j = 0; j < lright; j++) fprintf(outfile, \">\");\n          }\n\n        /* When a pattern contains \\K, the start of match position may be\n        different to the start of the matched string. When this is the case,\n        show it when requested. */\n\n        else if ((dat_datctl.control & CTL_STARTCHAR) != 0)\n          {\n          PCRE2_SIZE startchar;\n          PCRE2_GET_STARTCHAR(startchar, match_data);\n          PCHARS(lleft, pp, startchar, start - startchar, utf, outfile);\n          PCHARSV(pp, start, end - start, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          if (startchar != start)\n            {\n            fprintf(outfile, \"\\n    \");\n            for (j = 0; j < lleft; j++) fprintf(outfile, \"^\");\n            }\n          }\n\n        /* Otherwise, just show the matched string. */\n\n        else\n          {\n          PCHARSV(pp, start, end - start, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          }\n        }\n\n      /* Not the main matched string. Just show it unadorned. */\n\n      else\n        {\n        PCHARSV(pp, start, end - start, utf, outfile);\n        }\n\n      fprintf(outfile, \"\\n\");\n\n      /* Note: don't use the start/end variables here because we want to\n      show the text from what is reported as the end. */\n\n      if ((dat_datctl.control & CTL_ALLAFTERTEXT) != 0 ||\n          (i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0))\n        {\n        fprintf(outfile, \"%2d+ \", i/2);\n        PCHARSV(pp, ovector[i+1], ulen - ovector[i+1], utf, outfile);\n        fprintf(outfile, \"\\n\");\n        }\n      }\n\n    /* Output (*MARK) data if requested */\n\n    if ((dat_datctl.control & CTL_MARK) != 0 &&\n         TESTFLD(match_data, mark, !=, NULL))\n      {\n      fprintf(outfile, \"MK: \");\n      PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);\n      fprintf(outfile, \"\\n\");\n      }\n\n    /* Process copy/get strings */\n\n    if (!copy_and_get(utf, capcount)) return PR_ABEND;\n\n    }    /* End of handling a successful match */\n\n  /* There was a partial match. The value of ovector[0] is the bumpalong point,\n  that is, startchar, not any \\K point that might have been passed. When JIT is\n  not in use, \"allusedtext\" may be set, in which case we indicate the leftmost\n  consulted character. */\n\n  else if (capcount == PCRE2_ERROR_PARTIAL)\n    {\n    PCRE2_SIZE leftchar;\n    int backlength;\n    int rubriclength = 0;\n\n    if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)\n      {\n      leftchar = FLD(match_data, leftchar);\n      }\n    else leftchar = ovector[0];\n\n    fprintf(outfile, \"Partial match\");\n    if ((dat_datctl.control & CTL_MARK) != 0 &&\n         TESTFLD(match_data, mark, !=, NULL))\n      {\n      fprintf(outfile, \", mark=\");\n      PCHARS(rubriclength, CASTFLD(void *, match_data, mark), -1, -1, utf,\n        outfile);\n      rubriclength += 7;\n      }\n    fprintf(outfile, \": \");\n    rubriclength += 15;\n\n    PCHARS(backlength, pp, leftchar, ovector[0] - leftchar, utf, outfile);\n    PCHARSV(pp, ovector[0], ulen - ovector[0], utf, outfile);\n\n    if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n      fprintf(outfile, \" (JIT)\");\n    fprintf(outfile, \"\\n\");\n\n    if (backlength != 0)\n      {\n      int i;\n      for (i = 0; i < rubriclength; i++) fprintf(outfile, \" \");\n      for (i = 0; i < backlength; i++) fprintf(outfile, \"<\");\n      fprintf(outfile, \"\\n\");\n      }\n\n    if (ulen != ovector[1])\n      fprintf(outfile, \"** ovector[1] is not equal to the subject length: \"\n        \"%ld != %ld\\n\", (unsigned long int)ovector[1], (unsigned long int)ulen);\n\n    /* Process copy/get strings */\n\n    if (!copy_and_get(utf, 1)) return PR_ABEND;\n\n    /* \"allvector\" outputs the entire vector */\n\n    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n      show_ovector(ovector, oveccount);\n\n    break;  /* Out of the /g loop */\n    }       /* End of handling partial match */\n\n  /* Failed to match. If this is a /g or /G loop, we might previously have\n  set g_notempty (to PCRE2_NOTEMPTY_ATSTART|PCRE2_ANCHORED) after a null match.\n  If that is the case, this is not necessarily the end. We want to advance the\n  start offset, and continue. We won't be at the end of the string - that was\n  checked before setting g_notempty. We achieve the effect by pretending that a\n  single character was matched.\n\n  Complication arises in the case when the newline convention is \"any\", \"crlf\",\n  or \"anycrlf\". If the previous match was at the end of a line terminated by\n  CRLF, an advance of one character just passes the CR, whereas we should\n  prefer the longer newline sequence, as does the code in pcre2_match().\n\n  Otherwise, in the case of UTF-8 or UTF-16 matching, the advance must be one\n  character, not one byte. */\n\n  else if (g_notempty != 0)   /* There was a previous null match */\n    {\n    uint16_t nl = FLD(compiled_code, newline_convention);\n    PCRE2_SIZE start_offset = dat_datctl.offset;    /* Where the match was */\n    PCRE2_SIZE end_offset = start_offset + 1;\n\n    if ((nl == PCRE2_NEWLINE_CRLF || nl == PCRE2_NEWLINE_ANY ||\n         nl == PCRE2_NEWLINE_ANYCRLF) &&\n        start_offset < ulen - 1 &&\n        CODE_UNIT(pp, start_offset) == '\\r' &&\n        CODE_UNIT(pp, end_offset) == '\\n')\n      end_offset++;\n\n    else if (utf && test_mode != PCRE32_MODE)\n      {\n      if (test_mode == PCRE8_MODE)\n        {\n        for (; end_offset < ulen; end_offset++)\n          if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;\n        }\n      else  /* 16-bit mode */\n        {\n        for (; end_offset < ulen; end_offset++)\n          if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;\n        }\n      }\n\n    SETFLDVEC(match_data, ovector, 0, start_offset);\n    SETFLDVEC(match_data, ovector, 1, end_offset);\n    }  /* End of handling null match in a global loop */\n\n  /* A \"normal\" match failure. There will be a negative error number in\n  capcount. */\n\n  else\n    {\n    switch(capcount)\n      {\n      case PCRE2_ERROR_NOMATCH:\n      if (gmatched == 0)\n        {\n        fprintf(outfile, \"No match\");\n        if ((dat_datctl.control & CTL_MARK) != 0 &&\n             TESTFLD(match_data, mark, !=, NULL))\n          {\n          fprintf(outfile, \", mark = \");\n          PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);\n          }\n        if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n          fprintf(outfile, \" (JIT)\");\n        fprintf(outfile, \"\\n\");\n\n        /* \"allvector\" outputs the entire vector */\n\n        if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n          show_ovector(ovector, oveccount);\n        }\n      break;\n\n      case PCRE2_ERROR_BADUTFOFFSET:\n      fprintf(outfile, \"Error %d (bad UTF-%d offset)\\n\", capcount, test_mode);\n      break;\n\n      default:\n      fprintf(outfile, \"Failed: error %d: \", capcount);\n      if (!print_error_message(capcount, \"\", \"\")) return PR_ABEND;\n      if (capcount <= PCRE2_ERROR_UTF8_ERR1 &&\n          capcount >= PCRE2_ERROR_UTF32_ERR2)\n        {\n        PCRE2_SIZE startchar;\n        PCRE2_GET_STARTCHAR(startchar, match_data);\n        fprintf(outfile, \" at offset %\" SIZ_FORM, startchar);\n        }\n      fprintf(outfile, \"\\n\");\n      break;\n      }\n\n    break;  /* Out of the /g loop */\n    }       /* End of failed match handling */\n\n  /* Control reaches here in two circumstances: (a) after a match, and (b)\n  after a non-match that immediately followed a match on an empty string when\n  doing a global search. Such a match is done with PCRE2_NOTEMPTY_ATSTART and\n  PCRE2_ANCHORED set in g_notempty. The code above turns it into a fake match\n  of one character. So effectively we get here only after a match. If we\n  are not doing a global search, we are done. */\n\n  if ((dat_datctl.control & CTL_ANYGLOB) == 0) break; else\n    {\n    PCRE2_SIZE match_offset = FLD(match_data, ovector)[0];\n    PCRE2_SIZE end_offset = FLD(match_data, ovector)[1];\n\n    /* We must now set up for the next iteration of a global search. If we have\n    matched an empty string, first check to see if we are at the end of the\n    subject. If so, the loop is over. Otherwise, mimic what Perl's /g option\n    does. Set PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED and try the match again\n    at the same point. If this fails it will be picked up above, where a fake\n    match is set up so that at this point we advance to the next character.\n\n    However, in order to cope with patterns that never match at their starting\n    offset (e.g. /(?<=\\G.)/) we don't do this when the match offset is greater\n    than the starting offset. This means there will be a retry with the\n    starting offset at the match offset. If this returns the same match again,\n    it is picked up above and ignored, and the special action is then taken. */\n\n    if (match_offset == end_offset)\n      {\n      if (end_offset == ulen) break;           /* End of subject */\n      if (match_offset <= dat_datctl.offset)\n        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n      }\n\n    /* However, even after matching a non-empty string, there is still one\n    tricky case. If a pattern contains \\K within a lookbehind assertion at the\n    start, the end of the matched string can be at the offset where the match\n    started. In the case of a normal /g iteration without special action, this\n    leads to a loop that keeps on returning the same substring. The loop would\n    be caught above, but we really want to move on to the next match. */\n\n    else\n      {\n      g_notempty = 0;   /* Set for a \"normal\" repeat */\n      if ((dat_datctl.control & CTL_GLOBAL) != 0)\n        {\n        PCRE2_SIZE startchar;\n        PCRE2_GET_STARTCHAR(startchar, match_data);\n        if (end_offset <= startchar)\n          {\n          if (startchar >= ulen) break;       /* End of subject */\n          end_offset = startchar + 1;\n          if (utf && test_mode != PCRE32_MODE)\n            {\n            if (test_mode == PCRE8_MODE)\n              {\n              for (; end_offset < ulen; end_offset++)\n                if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;\n              }\n            else  /* 16-bit mode */\n              {\n              for (; end_offset < ulen; end_offset++)\n                if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;\n              }\n            }\n          }\n        }\n      }\n\n    /* For a normal global (/g) iteration, save the current ovector[0,1] and\n    the starting offset so that we can check that they do change each time.\n    Otherwise a matching bug that returns the same string causes an infinite\n    loop. It has happened! Then update the start offset, leaving other\n    parameters alone. */\n\n    if ((dat_datctl.control & CTL_GLOBAL) != 0)\n      {\n      ovecsave[0] = ovector[0];\n      ovecsave[1] = ovector[1];\n      ovecsave[2] = dat_datctl.offset;\n      dat_datctl.offset = end_offset;\n      }\n\n    /* For altglobal, just update the pointer and length. */\n\n    else\n      {\n      pp += end_offset * code_unit_size;\n      len -= end_offset * code_unit_size;\n      ulen -= end_offset;\n      if (arg_ulen != PCRE2_ZERO_TERMINATED) arg_ulen -= end_offset;\n      }\n    }\n  }  /* End of global loop */\n\nshow_memory = FALSE;\nreturn PR_OK;\n}\n\n\n\n\n/*************************************************\n*               Print PCRE2 version              *\n*************************************************/\n\nstatic void\nprint_version(FILE *f)\n{\nVERSION_TYPE *vp;\nfprintf(f, \"PCRE2 version \");\nfor (vp = version; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\nfprintf(f, \"\\n\");\n}\n\n\n\n/*************************************************\n*               Print Unicode version            *\n*************************************************/\n\nstatic void\nprint_unicode_version(FILE *f)\n{\nVERSION_TYPE *vp;\nfprintf(f, \"Unicode version \");\nfor (vp = uversion; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\n}\n\n\n\n/*************************************************\n*               Print JIT target                 *\n*************************************************/\n\nstatic void\nprint_jit_target(FILE *f)\n{\nVERSION_TYPE *vp;\nfor (vp = jittarget; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\n}\n\n\n\n/*************************************************\n*       Print newline configuration              *\n*************************************************/\n\n/* Output is always to stdout.\n\nArguments:\n  rc         the return code from PCRE2_CONFIG_NEWLINE\n  isc        TRUE if called from \"-C newline\"\nReturns:     nothing\n*/\n\nstatic void\nprint_newline_config(uint32_t optval, BOOL isc)\n{\nif (!isc) printf(\"  Default newline sequence is \");\nif (optval < sizeof(newlines)/sizeof(char *))\n  printf(\"%s\\n\", newlines[optval]);\nelse\n  printf(\"a non-standard value: %d\\n\", optval);\n}\n\n\n\n/*************************************************\n*             Usage function                     *\n*************************************************/\n\nstatic void\nusage(void)\n{\nprintf(\"Usage:     pcre2test [options] [<input file> [<output file>]]\\n\\n\");\nprintf(\"Input and output default to stdin and stdout.\\n\");\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nprintf(\"If input is a terminal, readline() is used to read from it.\\n\");\n#else\nprintf(\"This version of pcre2test is not linked with readline().\\n\");\n#endif\nprintf(\"\\nOptions:\\n\");\n#ifdef SUPPORT_PCRE2_8\nprintf(\"  -8            use the 8-bit library\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_16\nprintf(\"  -16           use the 16-bit library\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_32\nprintf(\"  -32           use the 32-bit library\\n\");\n#endif\nprintf(\"  -ac           set default pattern modifier PCRE2_AUTO_CALLOUT\\n\");\nprintf(\"  -AC           as -ac, but also set subject 'callout_extra' modifier\\n\");\nprintf(\"  -b            set default pattern modifier 'fullbincode'\\n\");\nprintf(\"  -C            show PCRE2 compile-time options and exit\\n\");\nprintf(\"  -C arg        show a specific compile-time option and exit with its\\n\");\nprintf(\"                  value if numeric (else 0). The arg can be:\\n\");\nprintf(\"     backslash-C    use of \\\\C is enabled [0, 1]\\n\");\nprintf(\"     bsr            \\\\R type [ANYCRLF, ANY]\\n\");\nprintf(\"     ebcdic         compiled for EBCDIC character code [0,1]\\n\");\nprintf(\"     ebcdic-nl      NL code if compiled for EBCDIC\\n\");\nprintf(\"     jit            just-in-time compiler supported [0, 1]\\n\");\nprintf(\"     linksize       internal link size [2, 3, 4]\\n\");\nprintf(\"     newline        newline type [CR, LF, CRLF, ANYCRLF, ANY, NUL]\\n\");\nprintf(\"     pcre2-8        8 bit library support enabled [0, 1]\\n\");\nprintf(\"     pcre2-16       16 bit library support enabled [0, 1]\\n\");\nprintf(\"     pcre2-32       32 bit library support enabled [0, 1]\\n\");\nprintf(\"     unicode        Unicode and UTF support enabled [0, 1]\\n\");\nprintf(\"  -d            set default pattern modifier 'debug'\\n\");\nprintf(\"  -dfa          set default subject modifier 'dfa'\\n\");\nprintf(\"  -error <n,m,..>  show messages for error numbers, then exit\\n\");\nprintf(\"  -help         show usage information\\n\");\nprintf(\"  -i            set default pattern modifier 'info'\\n\");\nprintf(\"  -jit          set default pattern modifier 'jit'\\n\");\nprintf(\"  -jitfast      set default pattern modifier 'jitfast'\\n\");\nprintf(\"  -jitverify    set default pattern modifier 'jitverify'\\n\");\nprintf(\"  -LM           list pattern and subject modifiers, then exit\\n\");\nprintf(\"  -LP           list non-script properties, then exit\\n\");\nprintf(\"  -LS           list supported scripts, then exit\\n\");\nprintf(\"  -q            quiet: do not output PCRE2 version number at start\\n\");\nprintf(\"  -pattern <s>  set default pattern modifier fields\\n\");\nprintf(\"  -subject <s>  set default subject modifier fields\\n\");\nprintf(\"  -S <n>        set stack size to <n> mebibytes\\n\");\nprintf(\"  -t [<n>]      time compilation and execution, repeating <n> times\\n\");\nprintf(\"  -tm [<n>]     time execution (matching) only, repeating <n> times\\n\");\nprintf(\"  -T            same as -t, but show total times at the end\\n\");\nprintf(\"  -TM           same as -tm, but show total time at the end\\n\");\nprintf(\"  -version      show PCRE2 version and exit\\n\");\n}\n\n\n\n/*************************************************\n*             Handle -C option                   *\n*************************************************/\n\n/* This option outputs configuration options and sets an appropriate return\ncode when asked for a single option. The code is abstracted into a separate\nfunction because of its size. Use whichever pcre2_config() function is\navailable.\n\nArgument:   an option name or NULL\nReturns:    the return code\n*/\n\nstatic int\nc_option(const char *arg)\n{\nuint32_t optval;\nunsigned int i = COPTLISTCOUNT;\nint yield = 0;\n\nif (arg != NULL && arg[0] != CHAR_MINUS)\n  {\n  for (i = 0; i < COPTLISTCOUNT; i++)\n    if (strcmp(arg, coptlist[i].name) == 0) break;\n\n  if (i >= COPTLISTCOUNT)\n    {\n    fprintf(stderr, \"** Unknown -C option '%s'\\n\", arg);\n    return 0;\n    }\n\n  switch (coptlist[i].type)\n    {\n    case CONF_BSR:\n    (void)PCRE2_CONFIG(coptlist[i].value, &optval);\n    printf(\"%s\\n\", (optval == PCRE2_BSR_ANYCRLF)? \"ANYCRLF\" : \"ANY\");\n    break;\n\n    case CONF_FIX:\n    yield = coptlist[i].value;\n    printf(\"%d\\n\", yield);\n    break;\n\n    case CONF_FIZ:\n    optval = coptlist[i].value;\n    printf(\"%d\\n\", optval);\n    break;\n\n    case CONF_INT:\n    (void)PCRE2_CONFIG(coptlist[i].value, &yield);\n    printf(\"%d\\n\", yield);\n    break;\n\n    case CONF_NL:\n    (void)PCRE2_CONFIG(coptlist[i].value, &optval);\n    print_newline_config(optval, TRUE);\n    break;\n    }\n\n/* For VMS, return the value by setting a symbol, for certain values only. This\nis contributed code which the PCRE2 developers have no means of testing. */\n\n#ifdef __VMS\n\n/* This is the original code provided by the first VMS contributor. */\n#ifdef NEVER\n  if (copytlist[i].type == CONF_FIX || coptlist[i].type == CONF_INT)\n    {\n    char ucname[16];\n    strcpy(ucname, coptlist[i].name);\n    for (i = 0; ucname[i] != 0; i++) ucname[i] = toupper[ucname[i]];\n    vms_setsymbol(ucname, 0, optval);\n    }\n#endif\n\n/* This is the new code, provided by a second VMS contributor. */\n\n  if (coptlist[i].type == CONF_FIX || coptlist[i].type == CONF_INT)\n    {\n    char nam_buf[22], val_buf[4];\n    $DESCRIPTOR(nam, nam_buf);\n    $DESCRIPTOR(val, val_buf);\n\n    strcpy(nam_buf, coptlist[i].name);\n    nam.dsc$w_length = strlen(nam_buf);\n    sprintf(val_buf, \"%d\", yield);\n    val.dsc$w_length = strlen(val_buf);\n    lib$set_symbol(&nam, &val);\n    }\n#endif  /* __VMS */\n\n  return yield;\n  }\n\n/* No argument for -C: output all configuration information. */\n\nprint_version(stdout);\nprintf(\"Compiled with\\n\");\n\n#ifdef EBCDIC\nprintf(\"  EBCDIC code support: LF is 0x%02x\\n\", CHAR_LF);\n#if defined NATIVE_ZOS\nprintf(\"  EBCDIC code page %s or similar\\n\", pcrz_cpversion());\n#endif\n#endif\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_COMPILED_WIDTHS, &optval);\nif (optval & 1) printf(\"  8-bit support\\n\");\nif (optval & 2) printf(\"  16-bit support\\n\");\nif (optval & 4) printf(\"  32-bit support\\n\");\n\n#ifdef SUPPORT_VALGRIND\nprintf(\"  Valgrind support\\n\");\n#endif\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, &optval);\nif (optval != 0)\n  {\n  printf(\"  UTF and UCP support (\");\n  print_unicode_version(stdout);\n  printf(\")\\n\");\n  }\nelse printf(\"  No Unicode support\\n\");\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_JIT, &optval);\nif (optval != 0)\n  {\n  printf(\"  Just-in-time compiler support: \");\n  print_jit_target(stdout);\n  printf(\"\\n\");\n  }\nelse\n  {\n  printf(\"  No just-in-time compiler support\\n\");\n  }\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_NEWLINE, &optval);\nprint_newline_config(optval, FALSE);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_BSR, &optval);\nprintf(\"  \\\\R matches %s\\n\",\n  (optval == PCRE2_BSR_ANYCRLF)? \"CR, LF, or CRLF only\" :\n                                 \"all Unicode newlines\");\n(void)PCRE2_CONFIG(PCRE2_CONFIG_NEVER_BACKSLASH_C, &optval);\nprintf(\"  \\\\C is %ssupported\\n\", optval? \"not \":\"\");\n(void)PCRE2_CONFIG(PCRE2_CONFIG_LINKSIZE, &optval);\nprintf(\"  Internal link size = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_PARENSLIMIT, &optval);\nprintf(\"  Parentheses nest limit = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_HEAPLIMIT, &optval);\nprintf(\"  Default heap limit = %d kibibytes\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, &optval);\nprintf(\"  Default match limit = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_DEPTHLIMIT, &optval);\nprintf(\"  Default depth limit = %d\\n\", optval);\n\n#if defined SUPPORT_LIBREADLINE\nprintf(\"  pcre2test has libreadline support\\n\");\n#elif defined SUPPORT_LIBEDIT\nprintf(\"  pcre2test has libedit support\\n\");\n#else\nprintf(\"  pcre2test has neither libreadline nor libedit support\\n\");\n#endif\n\nreturn 0;\n}\n\n\n/*************************************************\n*      Format one property/script list item      *\n*************************************************/\n\n#ifdef SUPPORT_UNICODE\nstatic void\nformat_list_item(int16_t *ff, char *buff, BOOL isscript)\n{\nint count;\nint maxi = 0;\nconst char *maxs = \"\";\nsize_t max = 0;\n\nfor (count = 0; ff[count] >= 0; count++) {}\n\n/* Find the name to put first. For scripts, any 3-character name is chosen.\nFor non-scripts, or if there is no 3-character name, take the longest. */\n\nfor (int i = 0; ff[i] >= 0; i++)\n  {\n  const char *s = PRIV(utt_names) + ff[i];\n  size_t len = strlen(s);\n  if (isscript && len == 3)\n    {\n    maxi = i;\n    max = len;\n    maxs = s;\n    break;\n    }\n  else if (len > max)\n    {\n    max = len;\n    maxi = i;\n    maxs = s;\n    }\n  }\n\nstrcpy(buff, maxs);\nbuff += max;\n\nif (count > 1)\n  {\n  const char *sep = \" (\";\n  for (int i = 0; i < count; i++)\n    {\n    if (i == maxi) continue;\n    buff += sprintf(buff, \"%s%s\", sep, PRIV(utt_names) + ff[i]);\n    sep = \", \";\n    }\n  (void)sprintf(buff, \")\");\n  }\n}\n#endif  /* SUPPORT_UNICODE */\n\n\n\n/*************************************************\n*        Display scripts or properties           *\n*************************************************/\n\n#define MAX_SYNONYMS 5\n\nstatic void\ndisplay_properties(BOOL wantscripts)\n{\n#ifndef SUPPORT_UNICODE\n(void)wantscripts;\nprintf(\"** This version of PCRE2 was compiled without Unicode support.\\n\");\n#else\n\nconst char *typename;\nuint16_t seentypes[1024];\nuint16_t seenvalues[1024];\nint seencount = 0;\nint16_t found[256][MAX_SYNONYMS + 1];\nint fc = 0;\nint colwidth = 40;\nint n;\n\nif (wantscripts)\n  {\n  n = ucp_Script_Count;\n  typename = \"SCRIPTS\";\n  }\nelse\n  {\n  n = ucp_Bprop_Count;\n  typename = \"PROPERTIES\";\n  }\n\nfor (size_t i = 0; i < PRIV(utt_size); i++)\n  {\n  int k;\n  int m = 0;\n  int16_t *fv;\n  const ucp_type_table *t = PRIV(utt) + i;\n  unsigned int value = t->value;\n\n  if (wantscripts)\n    {\n    if (t->type != PT_SC && t->type != PT_SCX) continue;\n    }\n  else\n    {\n    if (t->type != PT_BOOL) continue;\n    }\n\n  for (k = 0; k < seencount; k++)\n    {\n    if (t->type == seentypes[k] && t->value == seenvalues[k]) break;\n    }\n  if (k < seencount) continue;\n\n  seentypes[seencount] = t->type;\n  seenvalues[seencount++] = t->value;\n\n  fv = found[fc++];\n  fv[m++] = t->name_offset;\n\n  for (size_t j = i + 1; j < PRIV(utt_size); j++)\n    {\n    const ucp_type_table *tt = PRIV(utt) + j;\n    if (tt->type != t->type || tt->value != value) continue;\n    if (m >= MAX_SYNONYMS)\n      printf(\"** Too many synonyms: %s ignored\\n\",\n        PRIV(utt_names) + tt->name_offset);\n    else fv[m++] = tt->name_offset;\n    }\n\n  fv[m] = -1;\n  }\n\nprintf(\"-------------------------- SUPPORTED %s --------------------------\\n\\n\",\n  typename);\n\nif (!wantscripts) printf(\n\"This release of PCRE2 supports Unicode's general category properties such\\n\"\n\"as Lu (upper case letter), bi-directional properties such as Bidi_Class,\\n\"\n\"and the following binary (yes/no) properties:\\n\\n\");\n\n\nfor (int k = 0; k < (n+1)/2; k++)\n  {\n  int x;\n  char buff1[128];\n  char buff2[128];\n\n  format_list_item(found[k], buff1, wantscripts);\n  x = k + (n+1)/2;\n  if (x < n) format_list_item(found[x], buff2, wantscripts);\n    else buff2[0] = 0;\n\n  x = printf(\"%s\", buff1);\n  while (x++ < colwidth) printf(\" \");\n  printf(\"%s\\n\", buff2);\n  }\n\n#endif  /* SUPPORT_UNICODE */\n}\n\n\n\n/*************************************************\n*              Display one modifier              *\n*************************************************/\n\nstatic void\ndisplay_one_modifier(modstruct *m, BOOL for_pattern)\n{\nuint32_t c = (!for_pattern && (m->which == MOD_PND || m->which == MOD_PNDP))?\n  '*' : ' ';\nprintf(\"%c%s\", c, m->name);\nfor (size_t i = 0; i < C1MODLISTCOUNT; i++)\n  {\n  if (strcmp(m->name, c1modlist[i].fullname) == 0)\n    printf(\" (%c)\", c1modlist[i].onechar);\n  }\n}\n\n\n\n/*************************************************\n*       Display pattern or subject modifiers     *\n*************************************************/\n\n/* In order to print in two columns, first scan without printing to get a list\nof the modifiers that are required.\n\nArguments:\n  for_pattern   TRUE for pattern modifiers, FALSE for subject modifiers\n  title         string to be used in title\n\nReturns:        nothing\n*/\n\nstatic void\ndisplay_selected_modifiers(BOOL for_pattern, const char *title)\n{\nuint32_t i, j;\nuint32_t n = 0;\nuint32_t list[MODLISTCOUNT];\nuint32_t extra[MODLISTCOUNT];\n\nfor (i = 0; i < MODLISTCOUNT; i++)\n  {\n  BOOL is_pattern = TRUE;\n  modstruct *m = modlist + i;\n\n  switch (m->which)\n    {\n    case MOD_CTC:       /* Compile context */\n    case MOD_PAT:       /* Pattern */\n    case MOD_PATP:      /* Pattern, OK for Perl-compatible test */\n    break;\n\n    /* The MOD_PND and MOD_PNDP modifiers are precisely those that affect\n    subjects, but can be given with a pattern. We list them as subject\n    modifiers, but marked with an asterisk.*/\n\n    case MOD_CTM:       /* Match context */\n    case MOD_DAT:       /* Subject line */\n    case MOD_DATP:      /* Subject line, OK for Perl-compatible test */\n    case MOD_PND:       /* As PD, but not default pattern */\n    case MOD_PNDP:      /* As PND, OK for Perl-compatible test */\n    is_pattern = FALSE;\n    break;\n\n    default: printf(\"** Unknown type for modifier '%s'\\n\", m->name);\n    /* Fall through */\n    case MOD_PD:        /* Pattern or subject */\n    case MOD_PDP:       /* As PD, OK for Perl-compatible test */\n    is_pattern = for_pattern;\n    break;\n    }\n\n  if (for_pattern == is_pattern)\n    {\n    extra[n] = 0;\n    for (size_t k = 0; k < C1MODLISTCOUNT; k++)\n      {\n      if (strcmp(m->name, c1modlist[k].fullname) == 0)\n        {\n        extra[n] += 4;\n        break;\n        }\n      }\n    list[n++] = i;\n    }\n  }\n\n/* Now print from the list in two columns. */\n\nprintf(\"-------------- %s MODIFIERS --------------\\n\", title);\n\nfor (i = 0, j = (n+1)/2; i < (n+1)/2; i++, j++)\n  {\n  modstruct *m = modlist + list[i];\n  display_one_modifier(m, for_pattern);\n  if (j < n)\n    {\n    uint32_t k = 27 - strlen(m->name) - extra[i];\n    while (k-- > 0) printf(\" \");\n    display_one_modifier(modlist + list[j], for_pattern);\n    }\n  printf(\"\\n\");\n  }\n}\n\n\n\n/*************************************************\n*          Display the list of modifiers         *\n*************************************************/\n\nstatic void\ndisplay_modifiers(void)\n{\nprintf(\n  \"An asterisk on a subject modifier means that it may be given on a pattern\\n\"\n  \"line, in order to apply to all subjects matched by that pattern. Modifiers\\n\"\n  \"that are listed for both patterns and subjects have different effects in\\n\"\n  \"each case.\\n\\n\");\ndisplay_selected_modifiers(TRUE, \"PATTERN\");\nprintf(\"\\n\");\ndisplay_selected_modifiers(FALSE, \"SUBJECT\");\n}\n\n\n\n/*************************************************\n*                Main Program                    *\n*************************************************/\n\nint\nmain(int argc, char **argv)\n{\nuint32_t temp;\nuint32_t yield = 0;\nuint32_t op = 1;\nBOOL notdone = TRUE;\nBOOL quiet = FALSE;\nBOOL showtotaltimes = FALSE;\nBOOL skipping = FALSE;\nchar *arg_subject = NULL;\nchar *arg_pattern = NULL;\nchar *arg_error = NULL;\n\n/* The offsets to the options and control bits fields of the pattern and data\ncontrol blocks must be the same so that common options and controls such as\n\"anchored\" or \"memory\" can work for either of them from a single table entry.\nWe cannot test this till runtime because \"offsetof\" does not work in the\npreprocessor. */\n\nif (PO(options) != DO(options) || PO(control) != DO(control) ||\n    PO(control2) != DO(control2))\n  {\n  fprintf(stderr, \"** Coding error: \"\n    \"options and control offsets for pattern and data must be the same.\\n\");\n  return 1;\n  }\n\n/* Get the PCRE2 and Unicode version number and JIT target information, at the\nsame time checking that a request for the length gives the same answer. Also\ncheck lengths for non-string items. */\n\nif (PCRE2_CONFIG(PCRE2_CONFIG_VERSION, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_VERSION, version) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, uversion) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, jittarget) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, NULL) != sizeof(uint32_t) ||\n    PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, NULL) != sizeof(uint32_t))\n  {\n  fprintf(stderr, \"** Error in pcre2_config(): bad length\\n\");\n  return 1;\n  }\n\n/* Check that bad options are diagnosed. */\n\nif (PCRE2_CONFIG(999, NULL) != PCRE2_ERROR_BADOPTION ||\n    PCRE2_CONFIG(999, &temp) != PCRE2_ERROR_BADOPTION)\n  {\n  fprintf(stderr, \"** Error in pcre2_config(): bad option not diagnosed\\n\");\n  return 1;\n  }\n\n/* This configuration option is now obsolete, but running a quick check ensures\nthat its code is covered. */\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_STACKRECURSE, &temp);\n\n/* Get buffers from malloc() so that valgrind will check their misuse when\ndebugging. They grow automatically when very long lines are read. The 16-\nand 32-bit buffers (pbuffer16, pbuffer32) are obtained only if needed. */\n\nbuffer = (uint8_t *)malloc(pbuffer8_size);\npbuffer8 = (uint8_t *)malloc(pbuffer8_size);\n\n/* The following  _setmode() stuff is some Windows magic that tells its runtime\nlibrary to translate CRLF into a single LF character. At least, that's what\nI've been told: never having used Windows I take this all on trust. Originally\nit set 0x8000, but then I was advised that _O_BINARY was better. */\n\n#if defined(_WIN32) || defined(WIN32)\n_setmode( _fileno( stdout ), _O_BINARY );\n#endif\n\n/* Initialization that does not depend on the running mode. */\n\nlocale_name[0] = 0;\n\nmemset(&def_patctl, 0, sizeof(patctl));\ndef_patctl.convert_type = CONVERT_UNSET;\n\nmemset(&def_datctl, 0, sizeof(datctl));\ndef_datctl.oveccount = DEFAULT_OVECCOUNT;\ndef_datctl.copy_numbers[0] = -1;\ndef_datctl.get_numbers[0] = -1;\ndef_datctl.startend[0] = def_datctl.startend[1] = CFORE_UNSET;\ndef_datctl.cerror[0] = def_datctl.cerror[1] = CFORE_UNSET;\ndef_datctl.cfail[0] = def_datctl.cfail[1] = CFORE_UNSET;\n\n/* Scan command line options. */\n\nwhile (argc > 1 && argv[op][0] == '-' && argv[op][1] != 0)\n  {\n  char *endptr;\n  char *arg = argv[op];\n  unsigned long uli;\n\n  /* List modifiers and exit. */\n\n  if (strcmp(arg, \"-LM\") == 0)\n    {\n    display_modifiers();\n    goto EXIT;\n    }\n\n  /* List properties and exit */\n\n  if (strcmp(arg, \"-LP\") == 0)\n    {\n    display_properties(FALSE);\n    goto EXIT;\n    }\n\n  /* List scripts and exit */\n\n  if (strcmp(arg, \"-LS\") == 0)\n    {\n    display_properties(TRUE);\n    goto EXIT;\n    }\n\n  /* Display and/or set return code for configuration options. */\n\n  if (strcmp(arg, \"-C\") == 0)\n    {\n    yield = c_option(argv[op + 1]);\n    goto EXIT;\n    }\n\n  /* Select operating mode. Ensure that pcre2_config() is called in 16-bit\n  and 32-bit modes because that won't happen naturally when 8-bit is also\n  configured. Also call some other functions that are not otherwise used. This\n  means that a coverage report won't claim there are uncalled functions. */\n\n  if (strcmp(arg, \"-8\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_8\n    test_mode = PCRE8_MODE;\n    (void)pcre2_set_bsr_8(pat_context8, 999);\n    (void)pcre2_set_newline_8(pat_context8, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 8-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  else if (strcmp(arg, \"-16\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_16\n    test_mode = PCRE16_MODE;\n    (void)pcre2_config_16(PCRE2_CONFIG_VERSION, NULL);\n    (void)pcre2_set_bsr_16(pat_context16, 999);\n    (void)pcre2_set_newline_16(pat_context16, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 16-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  else if (strcmp(arg, \"-32\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_32\n    test_mode = PCRE32_MODE;\n    (void)pcre2_config_32(PCRE2_CONFIG_VERSION, NULL);\n    (void)pcre2_set_bsr_32(pat_context32, 999);\n    (void)pcre2_set_newline_32(pat_context32, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 32-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  /* Set quiet (no version verification) */\n\n  else if (strcmp(arg, \"-q\") == 0) quiet = TRUE;\n\n  /* Set system stack size */\n\n  else if (strcmp(arg, \"-S\") == 0 && argc > 2 &&\n      ((uli = strtoul(argv[op+1], &endptr, 10)), *endptr == 0))\n    {\n#if defined(_WIN32) || defined(WIN32) || defined(__HAIKU__) || defined(NATIVE_ZOS) || defined(__VMS)\n    fprintf(stderr, \"pcre2test: -S is not supported on this OS\\n\");\n    exit(1);\n#else\n    int rc;\n    uint32_t stack_size;\n    struct rlimit rlim;\n    if (U32OVERFLOW(uli))\n      {\n      fprintf(stderr, \"** Argument for -S is too big\\n\");\n      exit(1);\n      }\n    stack_size = (uint32_t)uli;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = stack_size * 1024 * 1024;\n    if (rlim.rlim_cur > rlim.rlim_max)\n      {\n      fprintf(stderr,\n        \"pcre2test: requested stack size %luMiB is greater than hard limit \"\n          \"%luMiB\\n\", (unsigned long int)stack_size,\n          (unsigned long int)(rlim.rlim_max));\n      exit(1);\n      }\n    rc = setrlimit(RLIMIT_STACK, &rlim);\n    if (rc != 0)\n      {\n      fprintf(stderr, \"pcre2test: setting stack size %luMiB failed: %s\\n\",\n        (unsigned long int)stack_size, strerror(errno));\n      exit(1);\n      }\n    op++;\n    argc--;\n#endif\n    }\n\n  /* Set some common pattern and subject controls */\n\n  else if (strcmp(arg, \"-AC\") == 0)\n    {\n    def_patctl.options |= PCRE2_AUTO_CALLOUT;\n    def_datctl.control2 |= CTL2_CALLOUT_EXTRA;\n    }\n  else if (strcmp(arg, \"-ac\") == 0)  def_patctl.options |= PCRE2_AUTO_CALLOUT;\n  else if (strcmp(arg, \"-b\") == 0)   def_patctl.control |= CTL_FULLBINCODE;\n  else if (strcmp(arg, \"-d\") == 0)   def_patctl.control |= CTL_DEBUG;\n  else if (strcmp(arg, \"-dfa\") == 0) def_datctl.control |= CTL_DFA;\n  else if (strcmp(arg, \"-i\") == 0)   def_patctl.control |= CTL_INFO;\n  else if (strcmp(arg, \"-jit\") == 0 || strcmp(arg, \"-jitverify\") == 0 ||\n           strcmp(arg, \"-jitfast\") == 0)\n    {\n    if (arg[4] == 'v') def_patctl.control |= CTL_JITVERIFY;\n      else if (arg[4] == 'f') def_patctl.control |= CTL_JITFAST;\n    def_patctl.jit = JIT_DEFAULT;  /* full & partial */\n#ifndef SUPPORT_JIT\n    fprintf(stderr, \"** Warning: JIT support is not available: \"\n                    \"-jit[fast|verify] calls functions that do nothing.\\n\");\n#endif\n    }\n\n  /* Set timing parameters */\n\n  else if (strcmp(arg, \"-t\") == 0 || strcmp(arg, \"-tm\") == 0 ||\n           strcmp(arg, \"-T\") == 0 || strcmp(arg, \"-TM\") == 0)\n    {\n    int both = arg[2] == 0;\n    showtotaltimes = arg[1] == 'T';\n    if (argc > 2 && (uli = strtoul(argv[op+1], &endptr, 10), *endptr == 0))\n      {\n      if (uli == 0)\n        {\n        fprintf(stderr, \"** Argument for %s must not be zero\\n\", arg);\n        exit(1);\n        }\n      if (U32OVERFLOW(uli))\n        {\n        fprintf(stderr, \"** Argument for %s is too big\\n\", arg);\n        exit(1);\n        }\n      timeitm = (int)uli;\n      op++;\n      argc--;\n      }\n    else timeitm = LOOPREPEAT;\n    if (both) timeit = timeitm;\n    }\n\n  /* Give help */\n\n  else if (strcmp(arg, \"-help\") == 0 ||\n           strcmp(arg, \"--help\") == 0)\n    {\n    usage();\n    goto EXIT;\n    }\n\n  /* Show version */\n\n  else if (strcmp(arg, \"-version\") == 0 ||\n           strcmp(arg, \"--version\") == 0)\n    {\n    print_version(stdout);\n    goto EXIT;\n    }\n\n  /* The following options save their data for processing once we know what\n  the running mode is. */\n\n  else if (strcmp(arg, \"-error\") == 0)\n    {\n    arg_error = argv[op+1];\n    goto CHECK_VALUE_EXISTS;\n    }\n\n  else if (strcmp(arg, \"-subject\") == 0)\n    {\n    arg_subject = argv[op+1];\n    goto CHECK_VALUE_EXISTS;\n    }\n\n  else if (strcmp(arg, \"-pattern\") == 0)\n    {\n    arg_pattern = argv[op+1];\n    CHECK_VALUE_EXISTS:\n    if (argc <= 2)\n      {\n      fprintf(stderr, \"** Missing value for %s\\n\", arg);\n      yield = 1;\n      goto EXIT;\n      }\n    op++;\n    argc--;\n    }\n\n  /* Unrecognized option */\n\n  else\n    {\n    fprintf(stderr, \"** Unknown or malformed option '%s'\\n\", arg);\n    usage();\n    yield = 1;\n    goto EXIT;\n    }\n  op++;\n  argc--;\n  }\n\n/* If -error was present, get the error numbers, show the messages, and exit.\nWe wait to do this until we know which mode we are in. */\n\nif (arg_error != NULL)\n  {\n  int len;\n  int errcode;\n  char *endptr;\n\n/* Ensure the relevant non-8-bit buffer is available. Ensure that it is at\nleast 128 code units, because it is used for retrieving error messages. */\n\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)\n    {\n    pbuffer16_size = 256;\n    pbuffer16 = (uint16_t *)malloc(pbuffer16_size);\n    if (pbuffer16 == NULL)\n      {\n      fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer16\\n\",\n        pbuffer16_size);\n      yield = 1;\n      goto EXIT;\n      }\n    }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)\n    {\n    pbuffer32_size = 512;\n    pbuffer32 = (uint32_t *)malloc(pbuffer32_size);\n    if (pbuffer32 == NULL)\n      {\n      fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer32\\n\",\n        pbuffer32_size);\n      yield = 1;\n      goto EXIT;\n      }\n    }\n#endif\n\n  /* Loop along a list of error numbers. */\n\n  for (;;)\n    {\n    errcode = strtol(arg_error, &endptr, 10);\n    if (*endptr != 0 && *endptr != CHAR_COMMA)\n      {\n      fprintf(stderr, \"** '%s' is not a valid error number list\\n\", arg_error);\n      yield = 1;\n      goto EXIT;\n      }\n    printf(\"Error %d: \", errcode);\n    PCRE2_GET_ERROR_MESSAGE(len, errcode, pbuffer);\n    if (len < 0)\n      {\n      switch (len)\n        {\n        case PCRE2_ERROR_BADDATA:\n        printf(\"PCRE2_ERROR_BADDATA (unknown error number)\");\n        break;\n\n        case PCRE2_ERROR_NOMEMORY:\n        printf(\"PCRE2_ERROR_NOMEMORY (buffer too small)\");\n        break;\n\n        default:\n        printf(\"Unexpected return (%d) from pcre2_get_error_message()\", len);\n        break;\n        }\n      }\n    else\n      {\n      PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, stdout);\n      }\n    printf(\"\\n\");\n    if (*endptr == 0) goto EXIT;\n    arg_error = endptr + 1;\n    }\n  /* Control never reaches here */\n  }  /* End of -error handling */\n\n/* Initialize things that cannot be done until we know which test mode we are\nrunning in. Exercise the general context copying and match data size functions,\nwhich are not otherwise used. */\n\ncode_unit_size = test_mode/8;\nmax_oveccount = DEFAULT_OVECCOUNT;\n\n/* Use macros to save a lot of duplication. */\n\n#define CREATECONTEXTS \\\n  G(general_context,BITS) = G(pcre2_general_context_create_,BITS)(&my_malloc, &my_free, NULL); \\\n  G(general_context_copy,BITS) = G(pcre2_general_context_copy_,BITS)(G(general_context,BITS)); \\\n  G(default_pat_context,BITS) = G(pcre2_compile_context_create_,BITS)(G(general_context,BITS)); \\\n  G(pat_context,BITS) = G(pcre2_compile_context_copy_,BITS)(G(default_pat_context,BITS)); \\\n  G(default_dat_context,BITS) = G(pcre2_match_context_create_,BITS)(G(general_context,BITS)); \\\n  G(dat_context,BITS) = G(pcre2_match_context_copy_,BITS)(G(default_dat_context,BITS)); \\\n  G(default_con_context,BITS) = G(pcre2_convert_context_create_,BITS)(G(general_context,BITS)); \\\n  G(con_context,BITS) = G(pcre2_convert_context_copy_,BITS)(G(default_con_context,BITS)); \\\n  G(match_data,BITS) = G(pcre2_match_data_create_,BITS)(max_oveccount, G(general_context,BITS))\n\n#define CONTEXTTESTS \\\n  (void)G(pcre2_set_compile_extra_options_,BITS)(G(pat_context,BITS), 0); \\\n  (void)G(pcre2_set_max_pattern_length_,BITS)(G(pat_context,BITS), 0); \\\n  (void)G(pcre2_set_offset_limit_,BITS)(G(dat_context,BITS), 0); \\\n  (void)G(pcre2_get_match_data_size_,BITS)(G(match_data,BITS))\n\n\n/* Call the appropriate functions for the current mode, and exercise some\nfunctions that are not otherwise called. */\n\n#ifdef SUPPORT_PCRE2_8\n#undef BITS\n#define BITS 8\nif (test_mode == PCRE8_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n#undef BITS\n#define BITS 16\nif (test_mode == PCRE16_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n#undef BITS\n#define BITS 32\nif (test_mode == PCRE32_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n/* Set a default parentheses nest limit that is large enough to run the\nstandard tests (this also exercises the function). */\n\nPCRE2_SET_PARENS_NEST_LIMIT(default_pat_context, PARENS_NEST_DEFAULT);\n\n/* Handle command line modifier settings, sending any error messages to\nstderr. We need to know the mode before modifying the context, and it is tidier\nto do them all in the same way. */\n\noutfile = stderr;\nif ((arg_pattern != NULL &&\n    !decode_modifiers((uint8_t *)arg_pattern, CTX_DEFPAT, &def_patctl, NULL)) ||\n    (arg_subject != NULL &&\n    !decode_modifiers((uint8_t *)arg_subject, CTX_DEFDAT, NULL, &def_datctl)))\n  {\n  yield = 1;\n  goto EXIT;\n  }\n\n/* Sort out the input and output files, defaulting to stdin/stdout. */\n\ninfile = stdin;\noutfile = stdout;\n\nif (argc > 1 && strcmp(argv[op], \"-\") != 0)\n  {\n  infile = fopen(argv[op], INPUT_MODE);\n  if (infile == NULL)\n    {\n    printf(\"** Failed to open '%s': %s\\n\", argv[op], strerror(errno));\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nif (INTERACTIVE(infile)) using_history();\n#endif\n\nif (argc > 2)\n  {\n  outfile = fopen(argv[op+1], OUTPUT_MODE);\n  if (outfile == NULL)\n    {\n    printf(\"** Failed to open '%s': %s\\n\", argv[op+1], strerror(errno));\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n/* Output a heading line unless quiet, then process input lines. */\n\nif (!quiet) print_version(outfile);\n\nSET(compiled_code, NULL);\n\n#ifdef SUPPORT_PCRE2_8\npreg.re_pcre2_code = NULL;\npreg.re_match_data = NULL;\n#endif\n\nwhile (notdone)\n  {\n  uint8_t *p;\n  int rc = PR_OK;\n  BOOL expectdata = TEST(compiled_code, !=, NULL);\n#ifdef SUPPORT_PCRE2_8\n  expectdata |= preg.re_pcre2_code != NULL;\n#endif\n\n  if (extend_inputline(infile, buffer, expectdata? \"data> \" : \"  re> \") == NULL)\n    break;\n  if (!INTERACTIVE(infile)) fprintf(outfile, \"%s\", (char *)buffer);\n  fflush(outfile);\n  p = buffer;\n\n  /* If we have a pattern set up for testing, or we are skipping after a\n  compile failure, a blank line terminates this test. */\n\n  if (expectdata || skipping)\n    {\n    while (isspace(*p)) p++;\n    if (*p == 0)\n      {\n#ifdef SUPPORT_PCRE2_8\n      if (preg.re_pcre2_code != NULL)\n        {\n        regfree(&preg);\n        preg.re_pcre2_code = NULL;\n        preg.re_match_data = NULL;\n        }\n#endif  /* SUPPORT_PCRE2_8 */\n      if (TEST(compiled_code, !=, NULL))\n        {\n        SUB1(pcre2_code_free, compiled_code);\n        SET(compiled_code, NULL);\n        }\n      skipping = FALSE;\n      setlocale(LC_CTYPE, \"C\");\n      }\n\n    /* Otherwise, if we are not skipping, and the line is not a data comment\n    line starting with \"\\=\", process a data line. */\n\n    else if (!skipping && !(p[0] == '\\\\' && p[1] == '=' && isspace(p[2])))\n      {\n      rc = process_data();\n      }\n    }\n\n  /* We do not have a pattern set up for testing. Lines starting with # are\n  either comments or special commands. Blank lines are ignored. Otherwise, the\n  line must start with a valid delimiter. It is then processed as a pattern\n  line. A copy of the pattern is left in pbuffer8 for use by callouts. Under\n  valgrind, make the unused part of the buffer undefined, to catch overruns. */\n\n  else if (*p == '#')\n    {\n    if (isspace(p[1]) || p[1] == '!' || p[1] == 0) continue;\n    rc = process_command();\n    }\n\n  else if (strchr(\"/!\\\"'`%&-=_:;,@~\", *p) != NULL)\n    {\n    rc = process_pattern();\n    dfa_matched = 0;\n    }\n\n  else\n    {\n    while (isspace(*p)) p++;\n    if (*p != 0)\n      {\n      fprintf(outfile, \"** Invalid pattern delimiter '%c' (x%x).\\n\", *buffer,\n        *buffer);\n      rc = PR_SKIP;\n      }\n    }\n\n  if (rc == PR_SKIP && !INTERACTIVE(infile)) skipping = TRUE;\n  else if (rc == PR_ABEND)\n    {\n    fprintf(outfile, \"** pcre2test run abandoned\\n\");\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n/* Finish off a normal run. */\n\nif (INTERACTIVE(infile)) fprintf(outfile, \"\\n\");\n\nif (showtotaltimes)\n  {\n  const char *pad = \"\";\n  fprintf(outfile, \"--------------------------------------\\n\");\n  if (timeit > 0)\n    {\n    fprintf(outfile, \"Total compile time %.4f milliseconds\\n\",\n      (((double)total_compile_time * 1000.0) / (double)timeit) /\n        (double)CLOCKS_PER_SEC);\n    if (total_jit_compile_time > 0)\n      fprintf(outfile, \"Total JIT compile  %.4f milliseconds\\n\",\n        (((double)total_jit_compile_time * 1000.0) / (double)timeit) /\n          (double)CLOCKS_PER_SEC);\n    pad = \"  \";\n    }\n  fprintf(outfile, \"Total match time %s%.4f milliseconds\\n\", pad,\n    (((double)total_match_time * 1000.0) / (double)timeitm) /\n      (double)CLOCKS_PER_SEC);\n  }\n\n\nEXIT:\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nif (infile != NULL && INTERACTIVE(infile)) clear_history();\n#endif\n\nif (infile != NULL && infile != stdin) fclose(infile);\nif (outfile != NULL && outfile != stdout) fclose(outfile);\n\nfree(buffer);\nfree(dbuffer);\nfree(pbuffer8);\nfree(dfa_workspace);\nfree(tables3);\nPCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);\nPCRE2_MATCH_DATA_FREE(match_data);\nSUB1(pcre2_code_free, compiled_code);\n\nwhile(patstacknext-- > 0)\n  {\n  SET(compiled_code, patstack[patstacknext]);\n  SUB1(pcre2_code_free, compiled_code);\n  }\n\nPCRE2_JIT_FREE_UNUSED_MEMORY(general_context);\nif (jit_stack != NULL)\n  {\n  PCRE2_JIT_STACK_FREE(jit_stack);\n  }\n\n#define FREECONTEXTS \\\n  G(pcre2_general_context_free_,BITS)(G(general_context,BITS)); \\\n  G(pcre2_general_context_free_,BITS)(G(general_context_copy,BITS)); \\\n  G(pcre2_compile_context_free_,BITS)(G(pat_context,BITS)); \\\n  G(pcre2_compile_context_free_,BITS)(G(default_pat_context,BITS)); \\\n  G(pcre2_match_context_free_,BITS)(G(dat_context,BITS)); \\\n  G(pcre2_match_context_free_,BITS)(G(default_dat_context,BITS)); \\\n  G(pcre2_convert_context_free_,BITS)(G(default_con_context,BITS)); \\\n  G(pcre2_convert_context_free_,BITS)(G(con_context,BITS));\n\n#ifdef SUPPORT_PCRE2_8\n#undef BITS\n#define BITS 8\nif (preg.re_pcre2_code != NULL) regfree(&preg);\nFREECONTEXTS;\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n#undef BITS\n#define BITS 16\nfree(pbuffer16);\nFREECONTEXTS;\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n#undef BITS\n#define BITS 32\nfree(pbuffer32);\nFREECONTEXTS;\n#endif\n\n#if defined(__VMS)\n  yield = SS$_NORMAL;  /* Return values via DCL symbols */\n#endif\n\nreturn yield;\n}\n\n/* End of pcre2test.c */\n", "# This set of tests is not Perl-compatible. It checks on special features\n# of PCRE2's API, error diagnostics, and the compiled code of some patterns.\n# It also checks the non-Perl syntax that PCRE2 supports (Python, .NET,\n# Oniguruma). There are also some tests where PCRE2 and Perl differ,\n# either because PCRE2 can't be compatible, or there is a possible Perl\n# bug.\n\n# NOTE: This is a non-UTF set of tests. When UTF support is needed, use\n# test 5.\n\n#forbid_utf\n#newline_default lf any anycrlf\n\n# Test binary zeroes in the pattern\n\n# /a\\0B/ where 0 is a binary zero\n/61 5c 00 62/B,hex\n    a\\x{0}b\n\n# /a0b/ where 0 is a binary zero\n/61 00 62/B,hex\n    a\\x{0}b\n\n# /(?#B0C)DE/ where 0 is a binary zero\n/28 3f 23 42 00 43 29 44 45/B,hex\n    DE\n\n/(a)b|/I\n\n/abc/I\n    abc\n    defabc\n    abc\\=anchored\n\\= Expect no match\n    defabc\\=anchored\n    ABC\n\n/^abc/I\n    abc\n    abc\\=anchored\n\\= Expect no match\n    defabc\n    defabc\\=anchored\n\n/a+bc/I\n\n/a*bc/I\n\n/a{3}bc/I\n\n/(abc|a+z)/I\n\n/^abc$/I\n    abc\n\\= Expect no match\n    def\\nabc\n\n/ab\\idef/\n\n/(?X)ab\\idef/\n\n/x{5,4}/\n\n/z{65536}/\n\n/[abcd/\n\n/[\\B]/B\n\n/[\\R]/B\n\n/[\\X]/B\n\n/[z-a]/\n\n/^*/\n\n/(abc/\n\n/(?# abc/\n\n/(?z)abc/\n\n/.*b/I\n\n/.*?b/I\n\n/cat|dog|elephant/I\n    this sentence eventually mentions a cat\n    this sentences rambles on and on for a while and then reaches elephant\n\n/cat|dog|elephant/I\n    this sentence eventually mentions a cat\n    this sentences rambles on and on for a while and then reaches elephant\n\n/cat|dog|elephant/Ii\n    this sentence eventually mentions a CAT cat\n    this sentences rambles on and on for a while to elephant ElePhant\n\n/a|[bcd]/I\n\n/(a|[^\\dZ])/I\n\n/(a|b)*[\\s]/I\n\n/(ab\\2)/\n\n/{4,5}abc/\n\n/(a)(b)(c)\\2/I\n    abcb\n    abcb\\=ovector=0\n    abcb\\=ovector=1\n    abcb\\=ovector=2\n    abcb\\=ovector=3\n    abcb\\=ovector=4\n\n/(a)bc|(a)(b)\\2/I\n    abc\n    abc\\=ovector=0\n    abc\\=ovector=1\n    abc\\=ovector=2\n    aba\n    aba\\=ovector=0\n    aba\\=ovector=1\n    aba\\=ovector=2\n    aba\\=ovector=3\n    aba\\=ovector=4\n\n/abc$/I,dollar_endonly\n    abc\n\\= Expect no match\n    abc\\n\n    abc\\ndef\n\n/(a)(b)(c)(d)(e)\\6/\n\n/the quick brown fox/I\n    the quick brown fox\n    this is a line with the quick brown fox\n\n/the quick brown fox/I,anchored\n    the quick brown fox\n\\= Expect no match\n    this is a line with the quick brown fox\n\n/ab(?z)cd/\n\n/^abc|def/I\n    abcdef\n    abcdef\\=notbol\n\n/.*((abc)$|(def))/I\n    defabc\n    defabc\\=noteol\n\n/)/\n\n/a[]b/\n\n/[^aeiou ]{3,}/I\n    co-processors, and for\n\n/<.*>/I\n    abc<def>ghi<klm>nop\n\n/<.*?>/I\n    abc<def>ghi<klm>nop\n\n/<.*>/I,ungreedy\n    abc<def>ghi<klm>nop\n\n/(?U)<.*>/I\n    abc<def>ghi<klm>nop\n\n/<.*?>/I,ungreedy\n    abc<def>ghi<klm>nop\n\n/={3,}/I,ungreedy\n    abc========def\n\n/(?U)={3,}?/I\n    abc========def\n\n/(?<!bar|cattle)foo/I\n    foo\n    catfoo\n\\= Expect no match\n    the barfoo\n    and cattlefoo\n\n/abc(?<=a+)b/\n\n/12345(?<=aaa|b{0,3})b/\n\n/(?<!(foo)a\\1)bar/\n\n/(?i)abc/I\n\n/(a|(?m)a)/I\n\n/(?i)^1234/I\n\n/(^b|(?i)^d)/I\n\n/(?s).*/I\n\n/[abcd]/I\n\n/(?i)[abcd]/I\n\n/(?m)[xy]|(b|c)/I\n\n/(^a|^b)/Im\n\n/(?i)(^a|^b)/Im\n\n/(a)(?(1)a|b|c)/\n\n/(?(?=a)a|b|c)/\n\n/(?(1a)/\n\n/(?(1a))/\n\n/(?(?i))/\n\n/(?(abc))/\n\n/(?(?<ab))/\n\n/((?s)blah)\\s+\\1/I\n\n/((?i)blah)\\s+\\1/I\n\n/((?i)b)/IB\n\n/(a*b|(?i:c*(?-i)d))/I\n\n/a$/I\n    a\n    a\\n\n\\= Expect no match\n    a\\=noteol\n    a\\n\\=noteol\n\n/a$/Im\n    a\n    a\\n\n    a\\n\\=noteol\n\\= Expect no match\n    a\\=noteol\n\n/\\Aabc/Im\n\n/^abc/Im\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/I\n  aaaaabbbbbcccccdef\n\n/(?<=foo)[ab]/I\n\n/(?<!foo)(alpha|omega)/I\n\n/(?!alphabet)[ab]/I\n\n/(?<=foo\\n)^bar/Im\n    foo\\nbarbar\n\\= Expect no match\n    rhubarb\n    barbell\n    abc\\nbarton\n\n/^(?<=foo\\n)bar/Im\n    foo\\nbarbar\n\\= Expect no match\n    rhubarb\n    barbell\n    abc\\nbarton\n\n/(?>^abc)/Im\n    abc\n    def\\nabc\n\\= Expect no match\n    defabc\n\n/(?<=ab(c+)d)ef/\n\n/(?<=ab(?<=c+)d)ef/\n\n/(?<=ab(c|de)f)g/\n\n/The next three are in testinput2 because they have variable length branches/\n\n/(?<=bullock|donkey)-cart/I\n    the bullock-cart\n    a donkey-cart race\n\\= Expect no match\n    cart\n    horse-and-cart\n\n/(?<=ab(?i)x|y|z)/I\n\n/(?>.*)(?<=(abcd)|(xyz))/I\n    alphabetabcd\n    endingxyz\n\n/(?<=ab(?i)x(?-i)y|(?i)z|b)ZZ/I\n    abxyZZ\n    abXyZZ\n    ZZZ\n    zZZ\n    bZZ\n    BZZ\n\\= Expect no match\n    ZZ\n    abXYZZ\n    zzz\n    bzz\n\n/(?<!(foo)a)bar/I\n    bar\n    foobbar\n\\= Expect no match\n    fooabar\n\n# Perl does not fail these two for the final subjects.\n\n/^(xa|=?\\1a){2}$/\n    xa=xaa\n\\= Expect no match\n    xa=xaaa\n\n/^(xa|=?\\1a)+$/\n    xa=xaa\n\\= Expect no match\n    xa=xaaa\n\n# These are syntax tests from Perl 5.005\n\n/a[b-a]/\n\n/a[]b/\n\n/a[/\n\n/*a/\n\n/(*)b/\n\n/abc)/\n\n/(abc/\n\n/a**/\n\n/)(/\n\n/\\1/\n\n/\\2/\n\n/(a)|\\2/\n\n/a[b-a]/Ii\n\n/a[]b/Ii\n\n/a[/Ii\n\n/*a/Ii\n\n/(*)b/Ii\n\n/abc)/Ii\n\n/(abc/Ii\n\n/a**/Ii\n\n/)(/Ii\n\n/:(?:/\n\n/(?<%)b/\n\n/a(?{)b/\n\n/a(?{{})b/\n\n/a(?{}})b/\n\n/a(?{\"{\"})b/\n\n/a(?{\"{\"}})b/\n\n/(?(1?)a|b)/\n\n/[a[:xyz:/\n\n/(?<=x+)y/\n\n/a{37,17}/\n\n/abc/\\\n\n/abc/\\i\n\n/(a)bc(d)/I\n    abcd\n    abcd\\=copy=2\n    abcd\\=copy=5\n\n/(.{20})/I\n    abcdefghijklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\\=copy=1\n    abcdefghijklmnopqrstuvwxyz\\=get=1\n\n/(.{15})/I\n    abcdefghijklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1\n\n/(.{16})/I\n    abcdefghijklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1,getall\n\n/^(a|(bc))de(f)/I\n    adef\\=get=1,get=2,get=3,get=4,getall\n    bcdef\\=get=1,get=2,get=3,get=4,getall\n    adefghijk\\=copy=0\n\n/^abc\\00def/I\n    abc\\00def\\=copy=0,getall\n\n/word ((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)?)?)?)?)?)?)?)?)?otherword/I\n\n/.*X/IB\n\n/.*X/IBs\n\n/(.*X|^B)/IB\n\n/(.*X|^B)/IBs\n\n/(?s)(.*X|^B)/IB\n\n/(?s:.*X|^B)/IB\n\n/\\Biss\\B/I,aftertext\n    Mississippi\n\n/iss/I,aftertext,altglobal\n    Mississippi\n\n/\\Biss\\B/I,aftertext,altglobal\n    Mississippi\n\n/\\Biss\\B/Ig,aftertext\n    Mississippi\n\\= Expect no match\n    Mississippi\\=anchored\n\n/(?<=[Ms])iss/Ig,aftertext\n    Mississippi\n\n/(?<=[Ms])iss/I,aftertext,altglobal\n    Mississippi\n\n/^iss/Ig,aftertext\n    ississippi\n\n/.*iss/Ig,aftertext\n    abciss\\nxyzisspqr\n\n/.i./Ig,aftertext\n    Mississippi\n    Mississippi\\=anchored\n    Missouri river\n    Missouri river\\=anchored\n\n/^.is/Ig,aftertext\n    Mississippi\n\n/^ab\\n/Ig,aftertext\n    ab\\nab\\ncd\n\n/^ab\\n/Igm,aftertext\n    ab\\nab\\ncd\n\n/^/gm,newline=any\n    a\\rb\\nc\\r\\nxyz\\=aftertext\n\n/abc/I\n\n/abc|bac/I\n\n/(abc|bac)/I\n\n/(abc|(c|dc))/I\n\n/(abc|(d|de)c)/I\n\n/a*/I\n\n/a+/I\n\n/(baa|a+)/I\n\n/a{0,3}/I\n\n/baa{3,}/I\n\n/\"([^\\\\\"]+|\\\\.)*\"/I\n\n/(abc|ab[cd])/I\n\n/(a|.)/I\n\n/a|ba|\\w/I\n\n/abc(?=pqr)/I\n\n/...(?<=abc)/I\n\n/abc(?!pqr)/I\n\n/ab./I\n\n/ab[xyz]/I\n\n/abc*/I\n\n/ab.c*/I\n\n/a.c*/I\n\n/.c*/I\n\n/ac*/I\n\n/(a.c*|b.c*)/I\n\n/a.c*|aba/I\n\n/.+a/I\n\n/(?=abcda)a.*/I\n\n/(?=a)a.*/I\n\n/a(b)*/I\n\n/a\\d*/I\n\n/ab\\d*/I\n\n/a(\\d)*/I\n\n/abcde{0,0}/I\n\n/ab\\d+/I\n\n/a(?(1)b)(.)/I\n\n/a(?(1)bag|big)(.)/I\n\n/a(?(1)bag|big)*(.)/I\n\n/a(?(1)bag|big)+(.)/I\n\n/a(?(1)b..|b..)(.)/I\n\n/ab\\d{0}e/I\n\n/a?b?/I\n    a\n    b\n    ab\n    \\\n\\= Expect no match\n    \\=notempty\n\n/|-/I\n    abcd\n    -abc\n    ab-c\\=notempty\n\\= Expect no match\n    abc\\=notempty\n\n/^.?abcd/I\n\n/\\(             # ( at start\n  (?:           # Non-capturing bracket\n  (?>[^()]+)    # Either a sequence of non-brackets (no backtracking)\n  |             # Or\n  (?R)          # Recurse - i.e. nested bracketed string\n  )*            # Zero or more contents\n  \\)            # Closing )\n  /Ix\n    (abcd)\n    (abcd)xyz\n    xyz(abcd)\n    (ab(xy)cd)pqr\n    (ab(xycd)pqr\n    () abc ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n\\= Expect no match\n    abcd\n    abcd)\n    (abcd\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Igx\n    (ab(xy)cd)pqr\n    1(abcd)(x(y)z)pqr\n\n/\\(  (?: (?>[^()]+) | (?R) ) \\) /Ix\n    (abcd)\n    (ab(xy)cd)\n    (a(b(c)d)e)\n    ((ab))\n\\= Expect no match\n    ()\n\n/\\(  (?: (?>[^()]+) | (?R) )? \\) /Ix\n    ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Ix\n    (ab(xy)cd)\n\n/\\( ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\n    (ab(xy)cd)\n\n/\\( (123)? ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\n    (ab(xy)cd)\n    (123ab(xy)cd)\n\n/\\( ( (123)? ( (?>[^()]+) | (?R) )* ) \\) /Ix\n    (ab(xy)cd)\n    (123ab(xy)cd)\n\n/\\( (((((((((( ( (?>[^()]+) | (?R) )* )))))))))) \\) /Ix\n    (ab(xy)cd)\n\n/\\( ( ( (?>[^()<>]+) | ((?>[^()]+)) | (?R) )* ) \\) /Ix\n    (abcd(xyz<p>qrs)123)\n\n/\\( ( ( (?>[^()]+) | ((?R)) )* ) \\) /Ix\n    (ab(cd)ef)\n    (ab(cd(ef)gh)ij)\n\n/^[[:alnum:]]/IB\n\n/^[[:^alnum:]]/IB\n\n/^[[:alpha:]]/IB\n\n/^[[:^alpha:]]/IB\n\n/[_[:alpha:]]/I\n\n/^[[:ascii:]]/IB\n\n/^[[:^ascii:]]/IB\n\n/^[[:blank:]]/IB\n\n/^[[:^blank:]]/IB\n\n/[\\n\\x0b\\x0c\\x0d[:blank:]]/I\n\n/^[[:cntrl:]]/IB\n\n/^[[:digit:]]/IB\n\n/^[[:graph:]]/IB\n\n/^[[:lower:]]/IB\n\n/^[[:print:]]/IB\n\n/^[[:punct:]]/IB\n\n/^[[:space:]]/IB\n\n/^[[:upper:]]/IB\n\n/^[[:xdigit:]]/IB\n\n/^[[:word:]]/IB\n\n/^[[:^cntrl:]]/IB\n\n/^[12[:^digit:]]/IB\n\n/^[[:^blank:]]/IB\n\n/[01[:alpha:]%]/IB\n\n/[[.ch.]]/I\n\n/[[=ch=]]/I\n\n/[[:rhubarb:]]/I\n\n/[[:upper:]]/Ii\n    A\n    a\n\n/[[:lower:]]/Ii\n    A\n    a\n\n/((?-i)[[:lower:]])[[:lower:]]/Ii\n    ab\n    aB\n\\= Expect no match\n    Ab\n    AB\n\n/[\\200-\\110]/I\n\n/^(?(0)f|b)oo/I\n\n# This one's here because of the large output vector needed\n\n/(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\w+)\\s+(\\270)/I\n     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\\=ovector=300\n\n# This one's here because Perl does this differently and PCRE2 can't at present\n\n/(main(O)?)+/I\n    mainmain\n    mainOmain\n\n# These are all cases where Perl does it differently (nested captures)\n\n/^(a(b)?)+$/I\n    aba\n\n/^(aa(bb)?)+$/I\n    aabbaa\n\n/^(aa|aa(bb))+$/I\n    aabbaa\n\n/^(aa(bb)??)+$/I\n    aabbaa\n\n/^(?:aa(bb)?)+$/I\n    aabbaa\n\n/^(aa(b(b))?)+$/I\n    aabbaa\n\n/^(?:aa(b(b))?)+$/I\n    aabbaa\n\n/^(?:aa(b(?:b))?)+$/I\n    aabbaa\n\n/^(?:aa(bb(?:b))?)+$/I\n    aabbbaa\n\n/^(?:aa(b(?:bb))?)+$/I\n    aabbbaa\n\n/^(?:aa(?:b(b))?)+$/I\n    aabbaa\n\n/^(?:aa(?:b(bb))?)+$/I\n    aabbbaa\n\n/^(aa(b(bb))?)+$/I\n    aabbbaa\n\n/^(aa(bb(bb))?)+$/I\n    aabbbbaa\n\n# ----------------\n\n/#/IBx\n\n/a#/IBx\n\n/[\\s]/IB\n\n/[\\S]/IB\n\n/a(?i)b/IB\n    ab\n    aB\n\\= Expect no match\n    AB\n\n/(a(?i)b)/IB\n    ab\n    aB\n\\= Expect no match\n    AB\n\n/   (?i)abc/IBx\n\n/#this is a comment\n  (?i)abc/IBx\n\n/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n\n/\\Q123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n\n/\\Q\\E/IB\n    \\\n\n/\\Q\\Ex/IB\n\n/ \\Q\\E/IB\n\n/a\\Q\\E/IB\n  abc\n  bca\n  bac\n\n/a\\Q\\Eb/IB\n  abc\n\n/\\Q\\Eabc/IB\n\n/x*+\\w/IB\n\\= Expect no match\n    xxxxx\n\n/x?+/IB\n\n/x++/IB\n\n/x{1,3}+/B,no_auto_possess\n\n/x{1,3}+/Bi,no_auto_possess\n\n/[^x]{1,3}+/B,no_auto_possess\n\n/[^x]{1,3}+/Bi,no_auto_possess\n\n/(x)*+/IB\n\n/^(\\w++|\\s++)*$/I\n    now is the time for all good men to come to the aid of the party\n\\= Expect no match\n    this is not a line with only words and spaces!\n\n/(\\d++)(\\w)/I\n    12345a\n\\= Expect no match\n    12345+\n\n/a++b/I\n    aaab\n\n/(a++b)/I\n    aaab\n\n/(a++)b/I\n    aaab\n\n/([^()]++|\\([^()]*\\))+/I\n    ((abc(ade)ufh()()x\n\n/\\(([^()]++|\\([^()]+\\))+\\)/I\n    (abc)\n    (abc(def)xyz)\n\\= Expect no match\n    ((()aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n/(abc){1,3}+/IB\n\n/a+?+/I\n\n/a{2,3}?+b/I\n\n/(?U)a+?+/I\n\n/a{2,3}?+b/I,ungreedy\n\n/x(?U)a++b/IB\n    xaaaab\n\n/(?U)xa++b/IB\n    xaaaab\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/IB\n\n/^x(?U)a+b/IB\n\n/^x(?U)(a+)b/IB\n\n/[.x.]/I\n\n/[=x=]/I\n\n/[:x:]/I\n\n/\\F/I\n\n/\\l/I\n\n/\\L/I\n\n/\\N{name}/I\n\n/\\u/I\n\n/\\U/I\n\n/a{1,3}b/ungreedy\n    ab\n\n/[/I\n\n/[a-/I\n\n/[[:space:]/I\n\n/[\\s]/IB\n\n/[[:space:]]/IB\n\n/[[:space:]abcde]/IB\n\n/< (?: (?(R) \\d++  | [^<>]*+) | (?R)) * >/Ix\n    <>\n    <abcd>\n    <abc <123> hij>\n    <abc <def> hij>\n    <abc<>def>\n    <abc<>\n\\= Expect no match\n    <abc\n\n/8J\\$WE\\<\\.rX\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n\n/\\$\\<\\.X\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n\n/(.*)\\d+\\1/I\n\n/(.*)\\d+/I\n\n/(.*)\\d+\\1/Is\n\n/(.*)\\d+/Is\n\n/(.*(xyz))\\d+\\2/I\n\n/((.*))\\d+\\1/I\n    abc123bc\n\n/a[b]/I\n\n/(?=a).*/I\n\n/(?=abc).xyz/Ii\n\n/(?=abc)(?i).xyz/I\n\n/(?=a)(?=b)/I\n\n/(?=.)a/I\n\n/((?=abcda)a)/I\n\n/((?=abcda)ab)/I\n\n/()a/I\n\n/(?:(?=.)|(?<!x))a/I\n\n/(?(1)ab|ac)(.)/I\n\n/(?(1)abz|acz)(.)/I\n\n/(?(1)abz)(.)/I\n\n/(?(1)abz)(1)23/I\n\n/(a)+/I\n\n/(a){2,3}/I\n\n/(a)*/I\n\n/[a]/I\n\n/[ab]/I\n\n/[ab]/I\n\n/[^a]/I\n\n/\\d456/I\n\n/\\d456/I\n\n/a^b/I\n\n/^a/Im\n  abcde\n  xy\\nabc\n\\= Expect no match\n  xyabc\n\n/c|abc/I\n\n/(?i)[ab]/I\n\n/[ab](?i)cd/I\n\n/abc(?C)def/I\n    abcdef\n    1234abcdef\n\\= Expect no match\n    abcxyz\n    abcxyzf\n\n/abc(?C)de(?C1)f/I\n    123abcdef\n\n/(?C1)\\dabc(?C2)def/I\n    1234abcdef\n\\= Expect no match\n    abcdef\n\n/(?C1)\\dabc(?C2)def/I\n    1234abcdef\n\\= Expect no match\n    abcdef\n\n/(?C255)ab/I\n\n/(?C256)ab/I\n\n/(?Cab)xx/I\n\n/(?C12vr)x/I\n\n/abc(?C)def/I\n    \\x83\\x0\\x61bcdef\n\n/(abc)(?C)de(?C1)f/I\n    123abcdef\n    123abcdef\\=callout_capture\n    123abcdefC-\\=callout_none\n\\= Expect no match\n    123abcdef\\=callout_fail=1\n\n/(?C0)(abc(?C1))*/I\n    abcabcabc\n    abcabc\\=callout_fail=1:4\n    abcabcabc\\=callout_fail=1:4\n\n/(\\d{3}(?C))*/I\n    123\\=callout_capture\n    123456\\=callout_capture\n    123456789\\=callout_capture\n\n/((xyz)(?C)p|(?C1)xyzabc)/I\n    xyzabc\\=callout_capture\n\n/(X)((xyz)(?C)p|(?C1)xyzabc)/I\n    Xxyzabc\\=callout_capture\n\n/(?=(abc))(?C)abcdef/I\n    abcdef\\=callout_capture\n\n/(?!(abc)(?C1)d)(?C2)abcxyz/I\n    abcxyz\\=callout_capture\n\n/(?<=(abc)(?C))xyz/I\n   abcxyz\\=callout_capture\n\n/a(b+)(c*)(?C1)/I\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n\n/a(b+?)(c*?)(?C1)/I\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n\n/(?C)abc/I\n\n/(?C)^abc/I\n\n/(?C)a|b/I\n\n/a|(b)(?C)/I\n    b\n\n/x(ab|(bc|(de|(?R))))/I\n    xab\n    xbc\n    xde\n    xxab\n    xxxab\n\\= Expect no match\n    xyab\n\n/^([^()]|\\((?1)*\\))*$/I\n    abc\n    a(b)c\n    a(b(c))d\n\\= Expect no match)\n    a(b(c)d\n\n/^>abc>([^()]|\\((?1)*\\))*<xyz<$/I\n   >abc>123<xyz<\n   >abc>1(2)3<xyz<\n   >abc>(1(2)3)<xyz<\n\n/(a(?1)b)/IB\n\n/(a(?1)+b)/IB\n\n/^(\\d+|\\((?1)([+*-])(?1)\\)|-(?1))$/I\n    12\n    (((2+2)*-3)-7)\n    -12\n\\= Expect no match\n    ((2+2)*-3)-7)\n\n/^(x(y|(?1){2})z)/I\n    xyz\n    xxyzxyzz\n\\= Expect no match\n    xxyzz\n    xxyzxyzxyzz\n\n/((< (?: (?(R) \\d++  | [^<>]*+) | (?2)) * >))/Ix\n    <>\n    <abcd>\n    <abc <123> hij>\n    <abc <def> hij>\n    <abc<>def>\n    <abc<>\n\\= Expect no match\n    <abc\n\n/(?1)/I\n\n/((?2)(abc)/I\n\n/^(abc)def(?1)/I\n    abcdefabc\n\n/^(a|b|c)=(?1)+/I\n    a=a\n    a=b\n    a=bc\n\n/^(a|b|c)=((?1))+/I\n    a=a\n    a=b\n    a=bc\n\n/a(?P<name1>b|c)d(?P<longername2>e)/IB\n    abde\n    acde\n\n/(?:a(?P<c>c(?P<d>d)))(?P<a>a)/IB\n\n/(?P<a>a)...(?P=a)bbb(?P>a)d/IB\n\n/^\\W*(?:(?P<one>(?P<two>.)\\W*(?P>one)\\W*(?P=two)|)|(?P<three>(?P<four>.)\\W*(?P>three)\\W*(?P=four)|\\W*.\\W*))\\W*$/Ii\n    1221\n    Satan, oscillate my metallic sonatas!\n    A man, a plan, a canal: Panama!\n    Able was I ere I saw Elba.\n\\= Expect no match\n    The quick brown fox\n\n/((?(R)a|b))\\1(?1)?/I\n  bb\n  bbaa\n\n/(.*)a/Is\n\n/(.*)a\\1/Is\n\n/(.*)a(b)\\2/Is\n\n/((.*)a|(.*)b)z/Is\n\n/((.*)a|(.*)b)z\\1/Is\n\n/((.*)a|(.*)b)z\\2/Is\n\n/((.*)a|(.*)b)z\\3/Is\n\n/((.*)a|^(.*)b)z\\3/Is\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a/Is\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\31/Is\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\32/Is\n\n/(a)(bc)/IB,no_auto_capture\n  abc\n\n/(?P<one>a)(bc)/IB,no_auto_capture\n  abc\n\n/(a)(?P<named>bc)/IB,no_auto_capture\n\n/(aaa(?C1)bbb|ab)/I\n   aaabbb\n   aaabbb\\=callout_data=0\n   aaabbb\\=callout_data=1\n\\= Expect no match\n   aaabbb\\=callout_data=-1\n\n/ab(?P<one>cd)ef(?P<two>gh)/I\n    abcdefgh\n    abcdefgh\\=copy=1,get=two\n    abcdefgh\\=copy=one,copy=two\n    abcdefgh\\=copy=three\n\n/(?P<Tes>)(?P<Test>)/IB\n\n/(?P<Test>)(?P<Tes>)/IB\n\n/(?P<Z>zz)(?P<A>aa)/I\n    zzaa\\=copy=Z\n    zzaa\\=copy=A\n\n/(?P<x>eks)(?P<x>eccs)/I\n\n/(?P<abc>abc(?P<def>def)(?P<abc>xyz))/I\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)\\]\"I\n    [10,20,30,5,5,4,4,2,43,23,4234]\n\\= Expect no match\n    []\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)?\\]\"I\n    [10,20,30,5,5,4,4,2,43,23,4234]\n    []\n\n/(a(b(?2)c))?/IB\n\n/(a(b(?2)c))*/IB\n\n/(a(b(?2)c)){0,2}/IB\n\n/[ab]{1}+/B\n\n/()(?1){1}/B\n\n/()(?1)/B\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/a*.*b/IB\n\n/(a|b)*.?c/IB\n\n/abc(?C255)de(?C)f/IB\n\n/abcde/IB,auto_callout\n  abcde\n\\= Expect no match\n  abcdfe\n\n/a*b/IB,auto_callout\n  ab\n  aaaab\n  aaaacb\n\n/a*b/IB,auto_callout\n  ab\n  aaaab\n  aaaacb\n\n/a+b/IB,auto_callout\n  ab\n  aaaab\n\\= Expect no match\n  aaaacb\n\n/(abc|def)x/IB,auto_callout\n  abcx\n  defx\n\\= Expect no match\n  abcdefzx\n\n/(abc|def)x/IB,auto_callout\n  abcx\n  defx\n\\= Expect no match\n  abcdefzx\n\n/(ab|cd){3,4}/I,auto_callout\n  ababab\n  abcdabcd\n  abcdcdcdcdcd\n\n/([ab]{,4}c|xy)/IB,auto_callout\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n\n/([ab]{,4}c|xy)/IB,auto_callout\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n\n/([ab]{1,4}c|xy){4,5}?123/IB,auto_callout\n    aacaacaacaacaac123\n\n/\\b.*/I\n  ab cd\\=offset=1\n\n/\\b.*/Is\n  ab cd\\=startoffset=1\n\n/(?!.bcd).*/I\n  Xbcd12345\n\n/abcde/I\n    ab\\=ps\n    abc\\=ps\n    abcd\\=ps\n    abcde\\=ps\n    the quick brown abc\\=ps\n\\= Expect no match\\=ps\n    the quick brown abxyz fox\\=ps\n\n\"^(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/(20)?\\d\\d$\"I\n    13/05/04\\=ps\n    13/5/2004\\=ps\n    02/05/09\\=ps\n    1\\=ps\n    1/2\\=ps\n    1/2/0\\=ps\n    1/2/04\\=ps\n    0\\=ps\n    02/\\=ps\n    02/0\\=ps\n    02/1\\=ps\n\\= Expect no match\\=ps\n    \\=ps\n    123\\=ps\n    33/4/04\\=ps\n    3/13/04\\=ps\n    0/1/2003\\=ps\n    0/\\=ps\n    02/0/\\=ps\n    02/13\\=ps\n\n/0{0,2}ABC/I\n\n/\\d{3,}ABC/I\n\n/\\d*ABC/I\n\n/[abc]+DE/I\n\n/[abc]?123/I\n    123\\=ps\n    a\\=ps\n    b\\=ps\n    c\\=ps\n    c12\\=ps\n    c123\\=ps\n\n/^(?:\\d){3,5}X/I\n    1\\=ps\n    123\\=ps\n    123X\n    1234\\=ps\n    1234X\n    12345\\=ps\n    12345X\n\\= Expect no match\n    1X\n    123456\\=ps\n\n\"<(\\w+)/?>(.)*</(\\1)>\"Igms\n    <!DOCTYPE seite SYSTEM \"http://www.lco.lineas.de/xmlCms.dtd\">\\n<seite>\\n<dokumenteninformation>\\n<seitentitel>Partner der LCO</seitentitel>\\n<sprache>de</sprache>\\n<seitenbeschreibung>Partner der LINEAS Consulting\\nGmbH</seitenbeschreibung>\\n<schluesselworte>LINEAS Consulting GmbH Hamburg\\nPartnerfirmen</schluesselworte>\\n<revisit>30 days</revisit>\\n<robots>index,follow</robots>\\n<menueinformation>\\n<aktiv>ja</aktiv>\\n<menueposition>3</menueposition>\\n<menuetext>Partner</menuetext>\\n</menueinformation>\\n<lastedited>\\n<autor>LCO</autor>\\n<firma>LINEAS Consulting</firma>\\n<datum>15.10.2003</datum>\\n</lastedited>\\n</dokumenteninformation>\\n<inhalt>\\n\\n<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\\nGmbH</absatzueberschrift>\\n\\n<absatz><link ziel=\"http://www.ca.com/\" zielfenster=\"_blank\">\\n<bild name=\"logo_ca.gif\" rahmen=\"no\"/></link> <link\\nziel=\"http://www.ey.com/\" zielfenster=\"_blank\"><bild\\nname=\"logo_euy.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.cisco.de/\" zielfenster=\"_blank\">\\n<bild name=\"logo_cisco.gif\" rahmen=\"ja\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.atelion.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_atelion.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.line-information.de/\"\\nzielfenster=\"_blank\">\\n<bild name=\"logo_line_information.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><bild name=\"logo_aw.gif\" rahmen=\"no\"/></absatz>\\n\\n<absatz><link ziel=\"http://www.incognis.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_incognis.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.addcraft.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_addcraft.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.comendo.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_comendo.gif\" rahmen=\"no\"/></link></absatz>\\n\\n</inhalt>\\n</seite>\\=jitstack=1024\n\n/line\\nbreak/I\n    this is a line\\nbreak\n    line one\\nthis is a line\\nbreak in the second line\n\n/line\\nbreak/I,firstline\n    this is a line\\nbreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\n\n/line\\nbreak/Im,firstline\n    this is a line\\nbreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\n\n/(?i)(?-i)AbCd/I\n    AbCd\n\\= Expect no match\n    abcd\n\n/a{11111111111111111111}/I\n\n/(){64294967295}/I\n\n/(){2,4294967295}/I\n\n\"(?i:a)(?i:b)(?i:c)(?i:d)(?i:e)(?i:f)(?i:g)(?i:h)(?i:i)(?i:j)(k)(?i:l)A\\1B\"I\n    abcdefghijklAkB\n\n\"(?P<n0>a)(?P<n1>b)(?P<n2>c)(?P<n3>d)(?P<n4>e)(?P<n5>f)(?P<n6>g)(?P<n7>h)(?P<n8>i)(?P<n9>j)(?P<n10>k)(?P<n11>l)A\\11B\"I\n    abcdefghijklAkB\n\n\"(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)A\\11B\"I\n    abcdefghijklAkB\n\n\"(?P<name0>a)(?P<name1>a)(?P<name2>a)(?P<name3>a)(?P<name4>a)(?P<name5>a)(?P<name6>a)(?P<name7>a)(?P<name8>a)(?P<name9>a)(?P<name10>a)(?P<name11>a)(?P<name12>a)(?P<name13>a)(?P<name14>a)(?P<name15>a)(?P<name16>a)(?P<name17>a)(?P<name18>a)(?P<name19>a)(?P<name20>a)(?P<name21>a)(?P<name22>a)(?P<name23>a)(?P<name24>a)(?P<name25>a)(?P<name26>a)(?P<name27>a)(?P<name28>a)(?P<name29>a)(?P<name30>a)(?P<name31>a)(?P<name32>a)(?P<name33>a)(?P<name34>a)(?P<name35>a)(?P<name36>a)(?P<name37>a)(?P<name38>a)(?P<name39>a)(?P<name40>a)(?P<name41>a)(?P<name42>a)(?P<name43>a)(?P<name44>a)(?P<name45>a)(?P<name46>a)(?P<name47>a)(?P<name48>a)(?P<name49>a)(?P<name50>a)(?P<name51>a)(?P<name52>a)(?P<name53>a)(?P<name54>a)(?P<name55>a)(?P<name56>a)(?P<name57>a)(?P<name58>a)(?P<name59>a)(?P<name60>a)(?P<name61>a)(?P<name62>a)(?P<name63>a)(?P<name64>a)(?P<name65>a)(?P<name66>a)(?P<name67>a)(?P<name68>a)(?P<name69>a)(?P<name70>a)(?P<name71>a)(?P<name72>a)(?P<name73>a)(?P<name74>a)(?P<name75>a)(?P<name76>a)(?P<name77>a)(?P<name78>a)(?P<name79>a)(?P<name80>a)(?P<name81>a)(?P<name82>a)(?P<name83>a)(?P<name84>a)(?P<name85>a)(?P<name86>a)(?P<name87>a)(?P<name88>a)(?P<name89>a)(?P<name90>a)(?P<name91>a)(?P<name92>a)(?P<name93>a)(?P<name94>a)(?P<name95>a)(?P<name96>a)(?P<name97>a)(?P<name98>a)(?P<name99>a)(?P<name100>a)\"I\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n\"(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)\"I\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n/[^()]*(?:\\((?R)\\)[^()]*)*/I\n    (this(and)that\n    (this(and)that)\n    (this(and)that)stuff\n\n/[^()]*(?:\\((?>(?R))\\)[^()]*)*/I\n    (this(and)that\n    (this(and)that)\n\n/[^()]*(?:\\((?R)\\))*[^()]*/I\n    (this(and)that\n    (this(and)that)\n\n/(?:\\((?R)\\))*[^()]*/I\n    (this(and)that\n    (this(and)that)\n    ((this))\n\n/(?:\\((?R)\\))|[^()]*/I\n    (this(and)that\n    (this(and)that)\n    (this)\n    ((this))\n\n/\\x{0000ff}/I\n\n/^((?P<A>a1)|(?P<A>a2)b)/I\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\n    a1b\\=copy=A\n    a2b\\=copy=A\n    a1b\\=copy=Z,copy=A\n\n/(?|(?<a>)(?<b>)(?<a>)|(?<a>)(?<b>)(?<a>))/I,dupnames\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\n    ab\\=copy=A\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\n    ab\\=copy=A\n    cd\\=copy=A\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\n    cdefgh\\=copy=A\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\n    a1b\\=get=A\n    a2b\\=get=A\n    a1b\\=get=Z,get=A\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\n    ab\\=get=A\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\n    ab\\=get=A\n    cd\\=get=A\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\n    cdefgh\\=get=A\n\n/(?J)^((?P<A>a1)|(?P<A>a2)b)/I\n    a1b\\=copy=A\n    a2b\\=copy=A\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<A>d)/I\n\n# In this next test, J is not set at the outer level; consequently it isn't set\n# in the pattern's options; consequently pcre2_substring_get_byname() produces\n# a random value.\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<C>d)/I\n    a bc d\\=copy=A,copy=B,copy=C\n\n/^(?P<A>a)?(?(A)a|b)/I\n    aabc\n    bc\n\\= Expect no match\n    abc\n\n/(?:(?(ZZ)a|b)(?P<ZZ>X))+/I\n    bXaX\n\n/(?:(?(2y)a|b)(X))+/I\n\n/(?:(?(ZA)a|b)(?P<ZZ>X))+/I\n\n/(?:(?(ZZ)a|b)(?(ZZ)a|b)(?P<ZZ>X))+/I\n    bbXaaX\n\n/(?:(?(ZZ)a|\\(b\\))\\\\(?P<ZZ>X))+/I\n    (b)\\\\Xa\\\\X\n\n/(?P<ABC/I\n\n/(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\n    bXXaYYaY\n    bXYaXXaX\n\n/()()()()()()()()()(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\n    bXXaYYaY\n\n/\\s*,\\s*/I\n    \\x0b,\\x0b\n    \\x0c,\\x0d\n\n/^abc/Im,newline=lf\n    xyz\\nabc\n    xyz\\r\\nabc\n\\= Expect no match\n    xyz\\rabc\n    xyzabc\\r\n    xyzabc\\rpqr\n    xyzabc\\r\\n\n    xyzabc\\r\\npqr\n\n/^abc/Im,newline=crlf\n    xyz\\r\\nabclf>\n\\= Expect no match\n    xyz\\nabclf\n    xyz\\rabclf\n\n/^abc/Im,newline=cr\n    xyz\\rabc\n\\= Expect no match\n    xyz\\nabc\n    xyz\\r\\nabc\n\n/^abc/Im,newline=bad\n\n/.*/I,newline=lf\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/.*/I,newline=cr\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/.*/I,newline=crlf\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/\\w+(.)(.)?def/Is\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/(?P<B>25[0-5]|2[0-4]\\d|[01]?\\d?\\d)(?:\\.(?P>B)){3}/I\n\n/()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n (.(.))/Ix\n    XY\\=ovector=133\n\n/(a*b|(?i:c*(?-i)d))/I\n\n/()[ab]xyz/I\n\n/(|)[ab]xyz/I\n\n/(|c)[ab]xyz/I\n\n/(|c?)[ab]xyz/I\n\n/(d?|c?)[ab]xyz/I\n\n/(d?|c)[ab]xyz/I\n\n/^a*b\\d/IB\n\n/^a*+b\\d/IB\n\n/^a*?b\\d/IB\n\n/^a+A\\d/IB\n    aaaA5\n\\= Expect no match\n    aaaa5\n\n/^a*A\\d/IBi\n    aaaA5\n    aaaa5\n    a5 \n\n/(a*|b*)[cd]/I\n\n/(a+|b*)[cd]/I\n\n/(a*|b+)[cd]/I\n\n/(a+|b+)[cd]/I\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n (((\n a\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n )))\n/Ix\n  large nest\n\n/a*\\d/B\n\n/a*\\D/B\n\n/0*\\d/B\n\n/0*\\D/B\n\n/a*\\s/B\n\n/a*\\S/B\n\n/ *\\s/B\n\n/ *\\S/B\n\n/a*\\w/B\n\n/a*\\W/B\n\n/=*\\w/B\n\n/=*\\W/B\n\n/\\d*a/B\n\n/\\d*2/B\n\n/\\d*\\d/B\n\n/\\d*\\D/B\n\n/\\d*\\s/B\n\n/\\d*\\S/B\n\n/\\d*\\w/B\n\n/\\d*\\W/B\n\n/\\D*a/B\n\n/\\D*2/B\n\n/\\D*\\d/B\n\n/\\D*\\D/B\n\n/\\D*\\s/B\n\n/\\D*\\S/B\n\n/\\D*\\w/B\n\n/\\D*\\W/B\n\n/\\s*a/B\n\n/\\s*2/B\n\n/\\s*\\d/B\n\n/\\s*\\D/B\n\n/\\s*\\s/B\n\n/\\s*\\S/B\n\n/\\s*\\w/B\n\n/\\s*\\W/B\n\n/\\S*a/B\n\n/\\S*2/B\n\n/\\S*\\d/B\n\n/\\S*\\D/B\n\n/\\S*\\s/B\n\n/\\S*\\S/B\n\n/\\S*\\w/B\n\n/\\S*\\W/B\n\n/\\w*a/B\n\n/\\w*2/B\n\n/\\w*\\d/B\n\n/\\w*\\D/B\n\n/\\w*\\s/B\n\n/\\w*\\S/B\n\n/\\w*\\w/B\n\n/\\w*\\W/B\n\n/\\W*a/B\n\n/\\W*2/B\n\n/\\W*\\d/B\n\n/\\W*\\D/B\n\n/\\W*\\s/B\n\n/\\W*\\S/B\n\n/\\W*\\w/B\n\n/\\W*\\W/B\n\n/[^a]+a/B\n\n/[^a]+a/Bi\n\n/[^a]+A/Bi\n\n/[^a]+b/B\n\n/[^a]+\\d/B\n\n/a*[^a]/B\n\n/(?P<abc>x)(?P<xyz>y)/I\n    xy\\=copy=abc,copy=xyz\n\n/(?<abc>x)(?'xyz'y)/I\n    xy\\=copy=abc,copy=xyz\n\n/(?<abc'x)(?'xyz'y)/I\n\n/(?<abc>x)(?'xyz>y)/I\n\n/(?P'abc'x)(?P<xyz>y)/I\n\n/^(?:(?(ZZ)a|b)(?<ZZ>X))+/\n    bXaX\n    bXbX\n\\= Expect no match\n    aXaX\n    aXbX\n\n/^(?P>abc)(?<abcd>xxx)/\n\n/^(?P>abc)(?<abc>x|y)/\n    xx\n    xy\n    yy\n    yx\n\n/^(?P>abc)(?P<abc>x|y)/\n    xx\n    xy\n    yy\n    yx\n\n/^((?(abc)a|b)(?<abc>x|y))+/\n    bxay\n    bxby\n\\= Expect no match\n    axby\n\n/^(((?P=abc)|X)(?<abc>x|y))+/\n    XxXxxx\n    XxXyyx\n    XxXyxx\n\\= Expect no match\n    x\n\n/^(?1)(abc)/\n    abcabc\n\n/^(?:(?:\\1|X)(a|b))+/\n    Xaaa\n    Xaba\n\n/^[\\E\\Qa\\E-\\Qz\\E]+/B\n\n/^[a\\Q]bc\\E]/B\n\n/^[a-\\Q\\E]/B\n\n/^(?P>abc)[()](?<abc>)/B\n\n/^((?(abc)y)[()](?P<abc>x))+/B\n    (xy)x\n\n/^(?P>abc)\\Q()\\E(?<abc>)/B\n\n/^(?P>abc)[a\\Q(]\\E(](?<abc>)/B\n\n/^(?P>abc) # this is (a comment)\n  (?<abc>)/Bx\n\n/^\\W*(?:(?<one>(?<two>.)\\W*(?&one)\\W*\\k<two>|)|(?<three>(?<four>.)\\W*(?&three)\\W*\\k'four'|\\W*.\\W*))\\W*$/Ii\n    1221\n    Satan, oscillate my metallic sonatas!\n    A man, a plan, a canal: Panama!\n    Able was I ere I saw Elba.\n\\= Expect no match\n    The quick brown fox\n\n/(?=(\\w+))\\1:/I\n    abcd:\n\n/(?=(?'abc'\\w+))\\k<abc>:/I\n    abcd:\n\n/(?'abc'a|b)(?<abc>d|e)\\k<abc>{2}/dupnames\n    adaa\n\\= Expect no match\n    addd\n    adbb\n\n/(?'abc'a|b)(?<abc>d|e)(?&abc){2}/dupnames\n    bdaa\n    bdab\n\\= Expect no match\n    bddd\n\n/(?(<bc))/\n\n/(?(''))/\n\n/(?('R')stuff)/\n\n/((abc (?(R) (?(R1)1) (?(R2)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n\n/(?<A> (?'B' abc (?(R) (?(R&A)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n\n/(?<A> (?'B' abc (?(R) (?(R&C)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\n\n/^(?(DEFINE) abc | xyz ) /x\n\n/(?(DEFINE) abc) xyz/Ix\n\n/(a|)*\\d/\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\\=ovector=0\n\\= Expect no match\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\=ovector=0\n\n/^a.b/newline=lf\n    a\\rb\n\\= Expect no match\n    a\\nb\n\n/^a.b/newline=cr\n    a\\nb\n\\= Expect no match\n    a\\rb\n\n/^a.b/newline=anycrlf\n    a\\x85b\n\\= Expect no match\n    a\\rb\n\n/^a.b/newline=any\n\\= Expect no match\n    a\\nb\n    a\\rb\n    a\\x85b\n\n/^abc./gmx,newline=any\n    abc1 \\x0aabc2 \\x0babc3xx \\x0cabc4 \\x0dabc5xx \\x0d\\x0aabc6 \\x85abc7 JUNK\n\n/abc.$/gmx,newline=any\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc7 abc9\n\n/^a\\Rb/bsr=unicode\n    a\\nb\n    a\\rb\n    a\\r\\nb\n    a\\x0bb\n    a\\x0cb\n    a\\x85b\n\\= Expect no match\n    a\\n\\rb\n\n/^a\\R*b/bsr=unicode\n    ab\n    a\\nb\n    a\\rb\n    a\\r\\nb\n    a\\x0bb\n    a\\x0cb\n    a\\x85b\n    a\\n\\rb\n    a\\n\\r\\x85\\x0cb\n\n/^a\\R+b/bsr=unicode\n    a\\nb\n    a\\rb\n    a\\r\\nb\n    a\\x0bb\n    a\\x0cb\n    a\\x85b\n    a\\n\\rb\n    a\\n\\r\\x85\\x0cb\n\\= Expect no match\n    ab\n\n/^a\\R{1,3}b/bsr=unicode\n    a\\nb\n    a\\n\\rb\n    a\\n\\r\\x85b\n    a\\r\\n\\r\\nb\n    a\\r\\n\\r\\n\\r\\nb\n    a\\n\\r\\n\\rb\n    a\\n\\n\\r\\nb\n\\= Expect no match\n    a\\n\\n\\n\\rb\n    a\\r\n\n/(?&abc)X(?<abc>P)/I\n    abcPXP123\n\n/(?1)X(?<abc>P)/I\n    abcPXP123\n\n/(?:a(?&abc)b)*(?<abc>x)/\n    123axbaxbaxbx456\n    123axbaxbaxb456\n\n/(?:a(?&abc)b){1,5}(?<abc>x)/\n    123axbaxbaxbx456\n\n/(?:a(?&abc)b){2,5}(?<abc>x)/\n    123axbaxbaxbx456\n\n/(?:a(?&abc)b){2,}(?<abc>x)/\n    123axbaxbaxbx456\n\n/(abc)(?i:(?1))/\n    defabcabcxyz\n\\= Expect no match\n    DEFabcABCXYZ\n\n/(abc)(?:(?i)(?1))/\n    defabcabcxyz\n\\= Expect no match\n    DEFabcABCXYZ\n\n/^(a)\\g-2/\n\n/^(a)\\g/\n\n/^(a)\\g{0}/\n\n/^(a)\\g{3/\n\n/^(a)\\g{aa}/\n\n/^a.b/newline=lf\n    a\\rb\n\\= Expect no match\n    a\\nb\n\n/.+foo/\n    afoo\n\\= Expect no match\n    \\r\\nfoo\n    \\nfoo\n\n/.+foo/newline=crlf\n    afoo\n    \\nfoo\n\\= Expect no match\n    \\r\\nfoo\n\n/.+foo/newline=any\n    afoo\n\\= Expect no match\n    \\nfoo\n    \\r\\nfoo\n\n/.+foo/s\n    afoo\n    \\r\\nfoo\n    \\nfoo\n\n/^$/gm,newline=any\n    abc\\r\\rxyz\n    abc\\n\\rxyz\n\\= Expect no match\n    abc\\r\\nxyz\n\n/(?m)^$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n\n/(?m)^$|^\\r\\n/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n\n/(?m)$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n\n/abc.$/gmx,newline=anycrlf\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc9\n\n/^X/m\n    XABC\n\\= Expect no match\n    XABC\\=notbol\n\n/(ab|c)(?-1)/B\n    abc\n\n/xy(?+1)(abc)/B\n    xyabcabc\n\\= Expect no match\n    xyabc\n\n/x(?-0)y/\n\n/x(?-1)y/\n\n/x(?+0)y/\n\n/x(?+1)y/\n\n/^(abc)?(?(-1)X|Y)/B\n    abcX\n    Y\n\\= Expect no match\n    abcY\n\n/^((?(+1)X|Y)(abc))+/B\n    YabcXabc\n    YabcXabcXabc\n\\= Expect no match\n    XabcXabc\n\n/(?(-1)a)/B\n\n/((?(-1)a))/B\n\n/((?(-2)a))/B\n\n/^(?(+1)X|Y)(.)/B\n    Y!\n\n/(?<A>tom|bon)-\\k{A}/\n    tom-tom\n    bon-bon\n\\= Expect no match\n    tom-bon\n\n/\\g{A/\n\n/(?|(abc)|(xyz))/B\n   >abc<\n   >xyz<\n\n/(x)(?|(abc)|(xyz))(x)/B\n    xabcx\n    xxyzx\n\n/(x)(?|(abc)(pqr)|(xyz))(x)/B\n    xabcpqrx\n    xxyzx\n\n/\\H++X/B\n\\= Expect no match\n    XXXX\n\n/\\H+\\hY/B\n    XXXX Y\n\n/\\H+ Y/B\n\n/\\h+A/B\n\n/\\v*B/B\n\n/\\V+\\x0a/B\n\n/A+\\h/B\n\n/ *\\H/B\n\n/A*\\v/B\n\n/\\x0b*\\V/B\n\n/\\d+\\h/B\n\n/\\d*\\v/B\n\n/S+\\h\\S+\\v/B\n\n/\\w{3,}\\h\\w+\\v/B\n\n/\\h+\\d\\h+\\w\\h+\\S\\h+\\H/B\n\n/\\v+\\d\\v+\\w\\v+\\S\\v+\\V/B\n\n/\\H+\\h\\H+\\d/B\n\n/\\V+\\v\\V+\\w/B\n\n/\\( (?: [^()]* | (?R) )* \\)/x\n(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\\=jitstack=1024\n\n/[\\E]AAA/\n\n/[\\Q\\E]AAA/\n\n/[^\\E]AAA/\n\n/[^\\Q\\E]AAA/\n\n/[\\E^]AAA/\n\n/[\\Q\\E^]AAA/\n\n/A(*PRUNE)B(*SKIP)C(*THEN)D(*COMMIT)E(*F)F(*FAIL)G(?!)H(*ACCEPT)I/B\n\n/^a+(*FAIL)/auto_callout\n\\= Expect no match\n    aaaaaa\n\n/a+b?c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a+b?(*PRUNE)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a+b?(*COMMIT)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a+b?(*SKIP)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabcccaaabccc\n\n/a+b?(*THEN)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a(*MARK)b/\n\n/\\g6666666666/\n\n/[\\g6666666666]/B\n\n/(?1)\\c[/\n\n/.+A/newline=crlf\n\\= Expect no match\n    \\r\\nA\n\n/\\nA/newline=crlf\n    \\r\\nA\n\n/[\\r\\n]A/newline=crlf\n    \\r\\nA\n\n/(\\r|\\n)A/newline=crlf\n    \\r\\nA\n\n/a(*CR)b/\n\n/(*CR)a.b/\n    a\\nb\n\\= Expect no match\n    a\\rb\n\n/(*CR)a.b/newline=lf\n    a\\nb\n\\= Expect no match\n    a\\rb\n\n/(*LF)a.b/newline=CRLF\n    a\\rb\n\\= Expect no match\n    a\\nb\n\n/(*CRLF)a.b/\n    a\\rb\n    a\\nb\n\\= Expect no match\n    a\\r\\nb\n\n/(*ANYCRLF)a.b/newline=CR\n\\= Expect no match\n    a\\rb\n    a\\nb\n    a\\r\\nb\n\n/(*ANY)a.b/newline=cr\n\\= Expect no match\n    a\\rb\n    a\\nb\n    a\\r\\nb\n    a\\x85b\n\n/(*ANY).*/g\n    abc\\r\\ndef\n\n/(*ANYCRLF).*/g\n    abc\\r\\ndef\n\n/(*CRLF).*/g\n    abc\\r\\ndef\n\n/(*NUL)^.*/\n    a\\nb\\x00ccc\n\n/(*NUL)^.*/s\n    a\\nb\\x00ccc\n\n/^x/m,newline=NUL\n    ab\\x00xy\n\n/'#comment' 0d 0a 00 '^x\\' 0a 'y'/x,newline=nul,hex\n    x\\nyz\n\n/(*NUL)^X\\NY/\n    X\\nY\n    X\\rY\n\\= Expect no match\n    X\\x00Y\n\n/a\\Rb/I,bsr=anycrlf\n    a\\rb\n    a\\nb\n    a\\r\\nb\n\\= Expect no match\n    a\\x85b\n    a\\x0bb\n\n/a\\Rb/I,bsr=unicode\n    a\\rb\n    a\\nb\n    a\\r\\nb\n    a\\x85b\n    a\\x0bb\n\n/a\\R?b/I,bsr=anycrlf\n    a\\rb\n    a\\nb\n    a\\r\\nb\n\\= Expect no match\n    a\\x85b\n    a\\x0bb\n\n/a\\R?b/I,bsr=unicode\n    a\\rb\n    a\\nb\n    a\\r\\nb\n    a\\x85b\n    a\\x0bb\n\n/a\\R{2,4}b/I,bsr=anycrlf\n    a\\r\\n\\nb\n    a\\n\\r\\rb\n    a\\r\\n\\r\\n\\r\\n\\r\\nb\n\\= Expect no match\n    a\\x85\\x85b\n    a\\x0b\\x0bb\n\n/a\\R{2,4}b/I,bsr=unicode\n    a\\r\\rb\n    a\\n\\n\\nb\n    a\\r\\n\\n\\r\\rb\n    a\\x85\\x85b\n    a\\x0b\\x0bb\n\\= Expect no match\n    a\\r\\r\\r\\r\\rb\n\n/(*BSR_ANYCRLF)a\\Rb/I\n    a\\nb\n    a\\rb\n\n/(*BSR_UNICODE)a\\Rb/I\n    a\\x85b\n\n/(*BSR_ANYCRLF)(*CRLF)a\\Rb/I\n    a\\nb\n    a\\rb\n\n/(*CRLF)(*BSR_UNICODE)a\\Rb/I\n    a\\x85b\n\n/(*CRLF)(*BSR_ANYCRLF)(*CR)ab/I\n\n/(?<a>)(?&)/\n\n/(?<abc>)(?&a)/\n\n/(?<a>)(?&aaaaaaaaaaaaaaaaaaaaaaa)/\n\n/(?+-a)/\n\n/(?-+a)/\n\n/(?(-1))/\n\n/(?(+10))/\n\n/(?(10))/\n\n/(?(+2))()()/\n\n/(?(2))()()/\n\n/\\k''/\n\n/\\k<>/\n\n/\\k{}/\n\n/\\k/\n\n/\\kabc/\n\n/(?P=)/\n\n/(?P>)/\n\n/[[:foo:]]/\n\n/[[:1234:]]/\n\n/[[:f\\oo:]]/\n\n/[[: :]]/\n\n/[[:...:]]/\n\n/[[:l\\ower:]]/\n\n/[[:abc\\:]]/\n\n/[abc[:x\\]pqr:]]/\n\n/[[:a\\dz:]]/\n\n/(^(a|b\\g<-1'c))/\n\n/^(?+1)(?<a>x|y){0}z/\n    xzxx\n    yzyy\n\\= Expect no match\n    xxz\n\n/(\\3)(\\1)(a)/\n\\= Expect no match\n    cat\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n\n/TA]/\n    The ACTA] comes\n\n/TA]/allow_empty_class,match_unset_backref,dupnames\n    The ACTA] comes\n\n/(?2)[]a()b](abc)/\n    abcbabc\n\n/(?2)[^]a()b](abc)/\n    abcbabc\n\n/(?1)[]a()b](abc)/\n    abcbabc\n\\= Expect no match\n    abcXabc\n\n/(?1)[^]a()b](abc)/\n    abcXabc\n\\= Expect no match\n    abcbabc\n\n/(?2)[]a()b](abc)(xyz)/\n    xyzbabcxyz\n\n/(?&N)[]a(?<N>)](?<M>abc)/\n   abc<abc\n\n/(?&N)[]a(?<N>)](abc)/\n   abc<abc\n\n/a[]b/\n\n/a[^]b/\n\n/a[]b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\n\n/a[]+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\n\n/a[]*+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\n\n/a[^]b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n    a\\nb\n\\= Expect no match\n    ab\n\n/a[^]+b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n    a\\nX\\nXb\n\\= Expect no match\n    ab\n\n/a(?!)b/B\n\n/(?!)?a/B\n    ab\n\n/a(*FAIL)+b/\n\n/(abc|pqr|123){0}[xyz]/I\n\n/(?(?=.*b)b|^)/I,auto_callout\n   adc\n   abc\n\n/(?(?=b).*b|^d)/I\n\n/(?(?=.*b).*b|^d)/I\n\n/xyz/auto_callout\n  xyz\n  abcxyz\n\\= Expect no match\n  abc\n  abcxypqr\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n\\= Expect no match\n  abc\n  abcxypqr\n\n/(*NO_START_OPT)xyz/auto_callout\n  abcxyz\n\n/(*NO_AUTO_POSSESS)a+b/B\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n\n/^\"((?(?=[a])[^\"])|b)*\"$/auto_callout\n    \"ab\"\n\n/^\"((?(?=[a])[^\"])|b)*\"$/\n    \"ab\"\n\n/^X(?5)(a)(?|(b)|(q))(c)(d)Y/\n    XYabcdY\n\n/^X(?&N)(a)(?|(b)|(q))(c)(d)(?<N>Y)/\n    XYabcdY\n\n/Xa{2,4}b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/Xa{2,4}?b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/Xa{2,4}+b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X\\d{2,4}b/\n    X\\=ps\n    X3\\=ps\n    X33\\=ps\n    X333\\=ps\n    X3333\\=ps\n\n/X\\d{2,4}?b/\n    X\\=ps\n    X3\\=ps\n    X33\\=ps\n    X333\\=ps\n    X3333\\=ps\n\n/X\\d{2,4}+b/\n    X\\=ps\n    X3\\=ps\n    X33\\=ps\n    X333\\=ps\n    X3333\\=ps\n\n/X\\D{2,4}b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X\\D{2,4}?b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X\\D{2,4}+b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[abc]{2,4}b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[abc]{2,4}?b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[abc]{2,4}+b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[^a]{2,4}b/\n    X\\=ps\n    Xz\\=ps\n    Xzz\\=ps\n    Xzzz\\=ps\n    Xzzzz\\=ps\n\n/X[^a]{2,4}?b/\n    X\\=ps\n    Xz\\=ps\n    Xzz\\=ps\n    Xzzz\\=ps\n    Xzzzz\\=ps\n\n/X[^a]{2,4}+b/\n    X\\=ps\n    Xz\\=ps\n    Xzz\\=ps\n    Xzzz\\=ps\n    Xzzzz\\=ps\n\n/(Y)X\\1{2,4}b/\n    YX\\=ps\n    YXY\\=ps\n    YXYY\\=ps\n    YXYYY\\=ps\n    YXYYYY\\=ps\n\n/(Y)X\\1{2,4}?b/\n    YX\\=ps\n    YXY\\=ps\n    YXYY\\=ps\n    YXYYY\\=ps\n    YXYYYY\\=ps\n\n/(Y)X\\1{2,4}+b/\n    YX\\=ps\n    YXY\\=ps\n    YXYY\\=ps\n    YXYYY\\=ps\n    YXYYYY\\=ps\n\n/\\++\\KZ|\\d+X|9+Y/startchar\n    ++++123999\\=ps\n    ++++123999Y\\=ps\n    ++++Z1234\\=ps\n\n/Z(*F)/\n\\= Expect no match\n    Z\\=ps\n    ZA\\=ps\n\n/Z(?!)/\n\\= Expect no match\n    Z\\=ps\n    ZA\\=ps\n\n/dog(sbody)?/\n    dogs\\=ps\n    dogs\\=ph\n\n/dog(sbody)??/\n    dogs\\=ps\n    dogs\\=ph\n\n/dog|dogsbody/\n    dogs\\=ps\n    dogs\\=ph\n\n/dogsbody|dog/\n    dogs\\=ps\n    dogs\\=ph\n\n/\\bthe cat\\b/\n    the cat\\=ps\n    the cat\\=ph\n\n/abc/\n   abc\\=ps\n   abc\\=ph\n\n/abc\\K123/startchar\n    xyzabc123pqr\n    xyzabc12\\=ps\n    xyzabc12\\=ph\n\n/(?<=abc)123/\n    xyzabc123pqr\n    xyzabc12\\=ps\n    xyzabc12\\=ph\n\n/\\babc\\b/\n    +++abc+++\n    +++ab\\=ps\n    +++ab\\=ph\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^m][^>]>[^<])(?<word>\\w*+))/B\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^\\d][^>]>[^<])(?<word>\\w*+))/B\n\n/(ab)(x(y)z(cd(*ACCEPT)))pq/B\n\n/abc\\K/aftertext,startchar\n    abcdef\n    abcdef\\=notempty_atstart\n    xyzabcdef\\=notempty_atstart\n\\= Expect no match\n    abcdef\\=notempty\n    xyzabcdef\\=notempty\n\n/^(?:(?=abc)|abc\\K)/aftertext,startchar\n    abcdef\n    abcdef\\=notempty_atstart\n\\= Expect no match\n    abcdef\\=notempty\n\n/a?b?/aftertext\n    xyz\n    xyzabc\n    xyzabc\\=notempty\n    xyzabc\\=notempty_atstart\n    xyz\\=notempty_atstart\n\\= Expect no match\n    xyz\\=notempty\n\n/^a?b?/aftertext\n    xyz\n    xyzabc\n\\= Expect no match\n    xyzabc\\=notempty\n    xyzabc\\=notempty_atstart\n    xyz\\=notempty_atstart\n    xyz\\=notempty\n\n/^(?<name>a|b\\g<name>c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(?<name>a|b\\g'name'c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(a|b\\g<1>c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(a|b\\g'1'c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(a|b\\g'-1'c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/(^(a|b\\g<-1>c))/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/(?-i:\\g<name>)(?i:(?<name>a))/\n    XaaX\n    XAAX\n\n/(?i:\\g<name>)(?-i:(?<name>a))/\n    XaaX\n\\= Expect no match\n    XAAX\n\n/(?-i:\\g<+1>)(?i:(a))/\n    XaaX\n    XAAX\n\n/(?=(?<regex>(?#simplesyntax)\\$(?<name>[a-zA-Z_\\x{7f}-\\x{ff}][a-zA-Z0-9_\\x{7f}-\\x{ff}]*)(?:\\[(?<index>[a-zA-Z0-9_\\x{7f}-\\x{ff}]+|\\$\\g<name>)\\]|->\\g<name>(\\(.*?\\))?)?|(?#simple syntax withbraces)\\$\\{(?:\\g<name>(?<indices>\\[(?:\\g<index>|'(?:\\\\.|[^'\\\\])*'|\"(?:\\g<regex>|\\\\.|[^\"\\\\])*\")\\])?|\\g<complex>|\\$\\{\\g<complex>\\})\\}|(?#complexsyntax)\\{(?<complex>\\$(?<segment>\\g<name>(\\g<indices>*|\\(.*?\\))?)(?:->\\g<segment>)*|\\$\\g<complex>|\\$\\{\\g<complex>\\})\\}))\\{/\n\n/(?<n>a|b|c)\\g<n>*/\n   abc\n   accccbbb\n\n/^X(?7)(a)(?|(b)|(q)(r)(s))(c)(d)(Y)/\n    XYabcdY\n\n/(?<=b(?1)|zzz)(a)/\n    xbaax\n    xzzzax\n\n/(a)(?<=b\\1)/\n\n/(a)(?<=b+(?1))/\n\n/(a+)(?<=b(?1))/\n\n/(a(?<=b(?1)))/\n\n/(?<=b(?1))xyz/\n\n/(?<=b(?1))xyz(b+)pqrstuvew/\n\n/(a|bc)\\1/I\n\n/(a|bc)\\1{2,3}/I\n\n/(a|bc)(?1)/I\n\n/(a|b\\1)(a|b\\1)/I\n\n/(a|b\\1){2}/I\n\n/(a|bbbb\\1)(a|bbbb\\1)/I\n\n/(a|bbbb\\1){2}/I\n\n/^From +([^ ]+) +[a-zA-Z][a-zA-Z][a-zA-Z] +[a-zA-Z][a-zA-Z][a-zA-Z] +[0-9]?[0-9] +[0-9][0-9]:[0-9][0-9]/I\n\n/<tr([\\w\\W\\s\\d][^<>]{0,})><TD([\\w\\W\\s\\d][^<>]{0,})>([\\d]{0,}\\.)(.*)((<BR>([\\w\\W\\s\\d][^<>]{0,})|[\\s]{0,}))<\\/a><\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><\\/TR>/Iis\n\n\"(?>.*/)foo\"I\n\n/(?(?=[^a-z]+[a-z])  \\d{2}-[a-z]{3}-\\d{2}  |  \\d{2}-\\d{2}-\\d{2} ) /Ix\n\n/(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))/Ii\n\n/(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))/I\n\n/<a[\\s]+href[\\s]*=[\\s]*          # find <a href=\n ([\\\"\\'])?                       # find single or double quote\n (?(1) (.*?)\\1 | ([^\\s]+))       # if quote found, match up to next matching\n                                 # quote, otherwise match up to next space\n/Iisx\n\n/^(?!:)                       # colon disallowed at start\n  (?:                         # start of item\n    (?: [0-9a-f]{1,4} |       # 1-4 hex digits or\n    (?(1)0 | () ) )           # if null previously matched, fail; else null\n    :                         # followed by colon\n  ){1,7}                      # end item; 1-7 of them required\n  [0-9a-f]{1,4} $             # final hex number at end of string\n  (?(1)|.)                    # check that there was an empty component\n  /Iix\n\n/(?|(?<a>A)|(?<a>B))/I\n    AB\\=copy=a\n    BA\\=copy=a\n\n/(?|(?<a>A)|(?<b>B))/\n\n/(?:a(?<quote> (?<apostrophe>')|(?<realquote>\")) |\n    b(?<quote> (?<apostrophe>')|(?<realquote>\")) )\n    (?('quote')[a-z]+|[0-9]+)/Ix,dupnames\n    a\"aaaaa\n    b\"aaaaa\n\\= Expect no match\n    b\"11111\n    a\"11111\n\n/^(?|(a)(b)(c)(?<D>d)|(?<D>e)) (?('D')X|Y)/IBx,dupnames\n    abcdX\n    eX\n\\= Expect no match\n    abcdY\n    ey\n\n/(?<A>a) (b)(c)  (?<A>d  (?(R&A)$ | (?4)) )/IBx,dupnames\n    abcdd\n\\= Expect no match\n    abcdde\n\n/abcd*/\n    xxxxabcd\\=ps\n    xxxxabcd\\=ph\n\n/abcd*/i\n    xxxxabcd\\=ps\n    xxxxabcd\\=ph\n    XXXXABCD\\=ps\n    XXXXABCD\\=ph\n\n/abc\\d*/\n    xxxxabc1\\=ps\n    xxxxabc1\\=ph\n\n/(a)bc\\1*/\n    xxxxabca\\=ps\n    xxxxabca\\=ph\n\n/abc[de]*/\n    xxxxabcde\\=ps\n    xxxxabcde\\=ph\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n\n/(\\3)(\\1)(a)/I,allow_empty_class,match_unset_backref,dupnames\n    cat\n\n/(\\3)(\\1)(a)/I\n\\= Expect no match\n    cat\n\n/i(?(DEFINE)(?<s>a))/I\n    i\n\n/()i(?(1)a)/I\n    ia\n\n/(?i)a(?-i)b|c/B\n    XabX\n    XAbX\n    CcC\n\\= Expect no match\n    XABX\n\n/(?i)a(?s)b|c/B\n\n/(?i)a(?s-i)b|c/B\n\n/^(ab(c\\1)d|x){2}$/B\n    xabcxd\n\n/^(?&t)*+(?(DEFINE)(?<t>.))$/B\n\n/^(?&t)*(?(DEFINE)(?<t>.))$/B\n\n# This one is here because Perl gives the match as \"b\" rather than \"ab\". I\n# believe this to be a Perl bug.\n\n/(?>a\\Kb)z|(ab)/\n    ab\\=startchar\n\n/(?P<L1>(?P<L2>0|)|(?P>L2)(?P>L1))/\n    abcd\n    0abc\n\n/abc(*MARK:)pqr/\n\n/abc(*:)pqr/\n\n/(*COMMIT:X)/B\n\n# This should, and does, fail. In Perl, it does not, which I think is a\n# bug because replacing the B in the pattern by (B|D) does make it fail.\n# Turning off Perl's optimization by inserting (??{\"\"}) also makes it fail.\n\n/A(*COMMIT)B/aftertext,mark\n\\= Expect no match\n    ACABX\n\n# These should be different, but in Perl they are not, which I think\n# is a bug in Perl.\n\n/A(*THEN)B|A(*THEN)C/mark\n    AC\n\n/A(*PRUNE)B|A(*PRUNE)C/mark\n\\= Expect no match\n    AC\n\n# Mark names can be duplicated. Perl doesn't give a mark for this one,\n# though PCRE2 does.\n\n/^A(*:A)B|^X(*:A)Y/mark\n\\= Expect no match\n    XAQQ\n\n# COMMIT at the start of a pattern should be the same as an anchor. Perl\n# optimizations defeat this. So does the PCRE2 optimization unless we disable\n# it.\n\n/(*COMMIT)ABC/\n    ABCDEFG\n\n/(*COMMIT)ABC/no_start_optimize\n\\= Expect no match\n    DEFGABC\n\n/^(ab (c+(*THEN)cd) | xyz)/x\n\\= Expect no match\n    abcccd\n\n/^(ab (c+(*PRUNE)cd) | xyz)/x\n\\= Expect no match\n    abcccd\n\n/^(ab (c+(*FAIL)cd) | xyz)/x\n\\= Expect no match\n    abcccd\n\n# Perl gets some of these wrong\n\n/(?>.(*ACCEPT))*?5/\n    abcde\n\n/(.(*ACCEPT))*?5/\n    abcde\n\n/(.(*ACCEPT))5/\n    abcde\n\n/(.(*ACCEPT))*5/\n    abcde\n\n/A\\NB./B\n    ACBD\n\\= Expect no match\n    A\\nB\n    ACB\\n\n\n/A\\NB./Bs\n    ACBD\n    ACB\\n\n\\= Expect no match\n    A\\nB\n\n/A\\NB/newline=crlf\n    A\\nB\n    A\\rB\n\\= Expect no match\n    A\\r\\nB\n\n/\\R+b/B\n\n/\\R+\\n/B\n\n/\\R+\\d/B\n\n/\\d*\\R/B\n\n/\\s*\\R/B\n    \\x20\\x0a\n    \\x20\\x0d\n    \\x20\\x0d\\x0a\n\n/\\S*\\R/B\n    a\\x0a\n\n/X\\h*\\R/B\n    X\\x20\\x0a\n\n/X\\H*\\R/B\n    X\\x0d\\x0a\n\n/X\\H+\\R/B\n    X\\x0d\\x0a\n\n/X\\H++\\R/B\n\\= Expect no match\n    X\\x0d\\x0a\n\n/(?<=abc)def/\n    abc\\=ph\n\n/abc$/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc$/m\n    abc\n    abc\\n\n    abc\\=ph\n    abc\\n\\=ph\n    abc\\=ps\n    abc\\n\\=ps\n\n/abc\\z/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc\\Z/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc\\b/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc\\B/\n    abc\\=ps\n    abc\\=ph\n\\= Expect no match\n    abc\n\n/.+/\n\\= Bad offsets\n    abc\\=offset=4\n    abc\\=offset=-4\n\\= Valid data\n    abc\\=offset=0\n    abc\\=offset=1\n    abc\\=offset=2\n\\= Expect no match\n    abc\\=offset=3\n\n/^\\c\u0123/\n\n/(?P<abn>(?P=abn)xxx)/B\n\n/(a\\1z)/B\n\n/(?P<abn>(?P=abn)(?<badstufxxx)/B\n\n/(?P<abn>(?P=axn)xxx)/B\n\n/(?P<abn>(?P=axn)xxx)(?<axn>yy)/B\n\n# These tests are here because Perl gets the first one wrong.\n\n/(\\R*)(.)/s\n    \\r\\n\n    \\r\\r\\n\\n\\r\n    \\r\\r\\n\\n\\r\\n\n\n/(\\R)*(.)/s\n    \\r\\n\n    \\r\\r\\n\\n\\r\n    \\r\\r\\n\\n\\r\\n\n\n/((?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)*)(.)/s\n    \\r\\n\n    \\r\\r\\n\\n\\r\n    \\r\\r\\n\\n\\r\\n\n\n# -------------\n\n/^abc$/B\n\n/^abc$/Bm\n\n/^(a)*+(\\w)/\n    aaaaX\n\\= Expect no match\n    aaaa\n\n/^(?:a)*+(\\w)/\n    aaaaX\n\\= Expect no match\n    aaaa\n\n/(a)++1234/IB\n\n/([abc])++1234/I\n\n/(?<=(abc)+)X/\n\n/(^ab)/I\n\n/(^ab)++/I\n\n/(^ab|^)+/I\n\n/(^ab|^)++/I\n\n/(?:^ab)/I\n\n/(?:^ab)++/I\n\n/(?:^ab|^)+/I\n\n/(?:^ab|^)++/I\n\n/(.*ab)/I\n\n/(.*ab)++/I\n\n/(.*ab|.*)+/I\n\n/(.*ab|.*)++/I\n\n/(?:.*ab)/I\n\n/(?:.*ab)++/I\n\n/(?:.*ab|.*)+/I\n\n/(?:.*ab|.*)++/I\n\n/(?=a)[bcd]/I\n\n/((?=a))[bcd]/I\n\n/((?=a))+[bcd]/I\n\n/((?=a))++[bcd]/I\n\n/(?=a+)[bcd]/Ii\n\n/(?=a+?)[bcd]/Ii\n\n/(?=a++)[bcd]/Ii\n\n/(?=a{3})[bcd]/Ii\n\n/(abc)\\1+/\n\n# Perl doesn't get these right IMO (the 3rd is PCRE2-specific)\n\n/(?1)(?:(b(*ACCEPT))){0}/\n    b\n\n/(?1)(?:(b(*ACCEPT))){0}c/\n    bc\n\\= Expect no match\n    b\n\n/(?1)(?:((*ACCEPT))){0}c/\n    c\n    c\\=notempty\n\n/^.*?(?(?=a)a|b(*THEN)c)/\n\\= Expect no match\n    ba\n\n/^.*?(?(?=a)a|bc)/\n    ba\n\n/^.*?(?(?=a)a(*THEN)b|c)/\n\\= Expect no match\n    ac\n\n/^.*?(?(?=a)a(*THEN)b)c/\n\\= Expect no match\n    ac\n\n/^.*?(a(*THEN)b)c/\n\\= Expect no match\n    aabc\n\n/^.*? (?1) c (?(DEFINE)(a(*THEN)b))/x\n    aabc\n\n/^.*?(a(*THEN)b|z)c/\n    aabc\n\n/^.*?(z|a(*THEN)b)c/\n    aabc\n\n# These are here because they are not Perl-compatible; the studying means the\n# mark is not seen.\n\n/(*MARK:A)(*SKIP:B)(C|X)/mark\n    C\n\\= Expect no match\n    D\n\n/(*:A)A+(*SKIP:A)(B|Z)/mark\n\\= Expect no match\n    AAAC\n\n# ----------------------------\n\n\"(?=a*(*ACCEPT)b)c\"\n    c\n    c\\=notempty\n\n/(?1)c(?(DEFINE)((*ACCEPT)b))/\n    c\n    c\\=notempty\n\n/(?>(*ACCEPT)b)c/\n    c\n\\= Expect no match\n    c\\=notempty\n\n/(?:(?>(a)))+a%/allaftertext\n    %aa%\n\n/(a)b|ac/allaftertext\n    ac\\=ovector=1\n\n/(a)(b)x|abc/allaftertext\n     abc\\=ovector=2\n\n/(a)bc|(a)(b)\\2/\n    abc\\=ovector=1\n    abc\\=ovector=2\n    aba\\=ovector=1\n    aba\\=ovector=2\n    aba\\=ovector=3\n    aba\\=ovector=4\n\n/(?(DEFINE)(a(?2)|b)(b(?1)|a))(?:(?1)|(?2))/I\n\n/(a(?2)|b)(b(?1)|a)(?:(?1)|(?2))/I\n\n/(a(?2)|b)(b(?1)|a)(?1)(?2)/I\n\n/(abc)(?1)/I\n\n/(?:(foo)|(bar)|(baz))X/allcaptures\n    bazfooX\n    foobazbarX\n    barfooX\n    bazX\n    foobarbazX\n    bazfooX\\=ovector=0\n    bazfooX\\=ovector=1\n    bazfooX\\=ovector=2\n    bazfooX\\=ovector=3\n\n/(?=abc){3}abc/B\n\n/(?=abc)+abc/B\n\n/(?=abc)++abc/B\n\n/(?=abc){0}xyz/B\n\n/(?=(a))?./B\n\n/(?=(a))??./B\n\n/^(?=(a)){0}b(?1)/B\n\n/(?(DEFINE)(a))?b(?1)/B\n\n/^(?=(?1))?[az]([abc])d/B\n\n/^(?!a){0}\\w+/B\n\n/(?<=(abc))?xyz/B\n\n/[:a[:abc]b:]/B\n\n/^(a(*:A)(d|e(*:B))z|aeq)/auto_callout\n    adz\n    aez\n    aeqwerty\n\n/.(*F)/\n\\= Expect no match\n    abc\\=ph\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b/I\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b|\\burl\\b\\W*?\\bshell:|<input\\b.*?\\btype\\b\\W*?\\bimage\\b|\\bonkeyup\\b\\W*?\\=/I\n\n/a(*SKIP)c|b(*ACCEPT)|/I,aftertext\n    a\n\n/a(*SKIP)c|b(*ACCEPT)cd(*ACCEPT)|x/I\n    ax\n\n'a*(*ACCEPT)b'aftertext\n    abc\\=notempty_atstart\n    bbb\\=notempty_atstart\n\\= Expect no match\n    \\=notempty_atstart\n\n/(*ACCEPT)a/I,aftertext\n    bax\n\n/z(*ACCEPT)a/I,aftertext\n    baxzbx\n\n/^(?>a+)(?>(z+))\\w/B\n    aaaazzzzb\n\\= Expect no match\n    aazz\n\n/(.)(\\1|a(?2))/\n    bab\n\n/\\1|(.)(?R)\\1/\n    cbbbc\n\n/(.)((?(1)c|a)|a(?2))/\n\\= Expect no match\n    baa\n\n/(?P<abn>(?P=abn)xxx)/B\n\n/(a\\1z)/B\n\n/^a\\x41z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\\= Expect no match\n    ax41z\n\n/^a[m\\x41]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\n/^a\\x1z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    ax1z\n\n/^a\\u0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\\= Expect no match\n    au0041z\n\n/^a[m\\u0041]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\n/^a\\u041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    au041z\n\\= Expect no match\n    aAz\n\n/^a\\U0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aU0041z\n\\= Expect no match\n    aAz\n    \n/^\\u{7a}/alt_bsux\n    u{7a}\n\\= Expect no match\n    zoo \n\n/^\\u{7a}/extra_alt_bsux\n    zoo \n\n/(?(?=c)c|d)++Y/B\n\n/(?(?=c)c|d)*+Y/B\n\n/a[\\NB]c/\n    aNc\n\n/a[B-\\Nc]/\n\n/a[B\\Nc]/\n\n/(a)(?2){0,1999}?(b)/\n\n/(a)(?(DEFINE)(b))(?2){0,1999}?(?2)/\n\n# This test, with something more complicated than individual letters, causes\n# different behaviour in Perl. Perhaps it disables some optimization; no tag is\n# passed back for the failures, whereas in PCRE2 there is a tag.\n\n/(A|P)(*:A)(B|P) | (X|P)(X|P)(*:B)(Y|P)/x,mark\n    AABC\n    XXYZ\n\\= Expect no match\n    XAQQ\n    XAQQXZZ\n    AXQQQ\n    AXXQQQ\n\n# Perl doesn't give marks for these, though it does if the alternatives are\n# replaced by single letters.\n\n/(b|q)(*:m)f|a(*:n)w/mark\n    aw\n\\= Expect no match\n    abc\n\n/(q|b)(*:m)f|a(*:n)w/mark\n    aw\n\\= Expect no match\n    abc\n\n# After a partial match, the behaviour is as for a failure.\n\n/^a(*:X)bcde/mark\n   abc\\=ps\n\n# These are here because Perl doesn't return a mark, except for the first.\n\n/(?=(*:x))(q|)/aftertext,mark\n    abc\n\n/(?=(*:x))((*:y)q|)/aftertext,mark\n    abc\n\n/(?=(*:x))(?:(*:y)q|)/aftertext,mark\n    abc\n\n/(?=(*:x))(?>(*:y)q|)/aftertext,mark\n    abc\n\n/(?=a(*:x))(?!a(*:y)c)/aftertext,mark\n    ab\n\n/(?=a(*:x))(?=a(*:y)c|)/aftertext,mark\n    ab\n\n/(..)\\1/\n    ab\\=ps\n    aba\\=ps\n    abab\\=ps\n\n/(..)\\1/i\n    ab\\=ps\n    abA\\=ps\n    aBAb\\=ps\n\n/(..)\\1{2,}/\n    ab\\=ps\n    aba\\=ps\n    abab\\=ps\n    ababa\\=ps\n    ababab\\=ps\n    ababab\\=ph\n    abababa\\=ps\n    abababa\\=ph\n\n/(..)\\1{2,}/i\n    ab\\=ps\n    aBa\\=ps\n    aBAb\\=ps\n    AbaBA\\=ps\n    abABAb\\=ps\n    aBAbaB\\=ph\n    abABabA\\=ps\n    abaBABa\\=ph\n\n/(..)\\1{2,}?x/i\n    ab\\=ps\n    abA\\=ps\n    aBAb\\=ps\n    abaBA\\=ps\n    abAbaB\\=ps\n    abaBabA\\=ps\n    abAbABaBx\\=ps\n\n/^(..)\\1/\n    aba\\=ps\n\n/^(..)\\1{2,3}x/\n    aba\\=ps\n    ababa\\=ps\n    ababa\\=ph\n    abababx\n    ababababx\n\n/^(..)\\1{2,3}?x/\n    aba\\=ps\n    ababa\\=ps\n    ababa\\=ph\n    abababx\n    ababababx\n\n/^(..)(\\1{2,3})ab/\n    abababab\n\n/^\\R/\n    \\r\\=ps\n    \\r\\=ph\n\n/^\\R{2,3}x/\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n    \\r\\rx\n    \\r\\r\\rx\n\n/^\\R{2,3}?x/\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n    \\r\\rx\n    \\r\\r\\rx\n\n/^\\R?x/\n    \\r\\=ps\n    \\r\\=ph\n    x\n    \\rx\n\n/^\\R+x/\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\n\\=ps\n    \\r\\n\\=ph\n    \\rx\n\n/^a$/newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/^a$/m,newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/^(a$|a\\r)/newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/^(a$|a\\r)/m,newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/./newline=crlf\n    \\r\\=ps\n    \\r\\=ph\n\n/.{2,3}/newline=crlf\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n\n/.{2,3}?/newline=crlf\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n\n\"AB(C(D))(E(F))?(?(?=\\2)(?=\\4))\"\n    ABCDGHI\\=ovector=01\n\n# These are all run as real matches in test 1; here we are just checking the\n# settings of the anchored and startline bits.\n\n/(?>.*?a)(?<=ba)/I\n\n/(?:.*?a)(?<=ba)/I\n\n/.*?a(*PRUNE)b/I\n\n/.*?a(*PRUNE)b/Is\n\n/^a(*PRUNE)b/Is\n\n/.*?a(*SKIP)b/I\n\n/(?>.*?a)b/Is\n\n/(?>.*?a)b/I\n\n/(?>^a)b/Is\n\n/(?>.*?)(?<=(abcd)|(wxyz))/I\n\n/(?>.*)(?<=(abcd)|(wxyz))/I\n\n\"(?>.*)foo\"I\n\n\"(?>.*?)foo\"I\n\n/(?>^abc)/Im\n\n/(?>.*abc)/Im\n\n/(?:.*abc)/Im\n\n/(?:(a)+(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\n\n/(?:(a)++(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\n\n/(?:(?>(a))(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\n\n/(?:(?1)(?C1)x|ab(?C2))((a)){0}/\n    aab\\=callout_capture\n\n/(?1)(?C1)((a)(?C2)){0}/\n    aab\\=callout_capture\n\n/(?:(a)+(?C1)bb|aa(?C2)b)++/\n    aab\\=callout_capture\n    aab\\=callout_capture,ovector=1\n\n/(ab)x|ab/\n    ab\\=ovector=0\n    ab\\=ovector=1\n\n/(?<=123)(*MARK:xx)abc/mark\n    xxxx123a\\=ph\n    xxxx123a\\=ps\n\n/123\\Kabc/startchar\n    xxxx123a\\=ph\n    xxxx123a\\=ps\n\n/^(?(?=a)aa|bb)/auto_callout\n    bb\n\n/(?C1)^(?C2)(?(?C99)(?=(?C3)a(?C4))(?C5)a(?C6)a(?C7)|(?C8)b(?C9)b(?C10))(?C11)/\n    bb\n\n# Perl seems to have a bug with this one.\n\n/aaaaa(*COMMIT)(*PRUNE)b|a+c/\n    aaaaaac\n\n# Here are some that Perl treats differently because of the way it handles\n# backtracking verbs.\n\n/(?!a(*COMMIT)b)ac|ad/\n     ac\n     ad\n\n/^(?!a(*THEN)b|ac)../\n     ad\n\\= Expect no match\n     ac\n\n/^(?=a(*THEN)b|ac)/\n    ac\n\n/\\A.*?(?:a|b(*THEN)c)/\n    ba\n\n/\\A.*?(?:a|b(*THEN)c)++/\n    ba\n\n/\\A.*?(?:a|b(*THEN)c|d)/\n    ba\n\n/(?:(a(*MARK:X)a+(*SKIP:X)b)){0}(?:(?1)|aac)/\n    aac\n\n/\\A.*?(a|b(*THEN)c)/\n    ba\n\n/^(A(*THEN)B|A(*THEN)D)/\n    AD\n\n/(?!b(*THEN)a)bn|bnn/\n    bnn\n\n/(?(?=b(*SKIP)a)bn|bnn)/\n    bnn\n\n/(?=b(*THEN)a|)bn|bnn/\n    bnn\n\n# This test causes a segfault with Perl 5.18.0\n\n/^(?=(a)){0}b(?1)/\n    backgammon\n\n/(?|(?<n>f)|(?<n>b))/I,dupnames\n\n/(?<a>abc)(?<a>z)\\k<a>()/IB,dupnames\n\n/a*[bcd]/B\n\n/[bcd]*a/B\n\n# A complete set of tests for auto-possessification of character types, but\n# omitting \\C because it might be disabled (it has its own tests).\n\n/\\D+\\D \\D+\\d \\D+\\S \\D+\\s \\D+\\W \\D+\\w \\D+. \\D+\\R \\D+\\H \\D+\\h \\D+\\V \\D+\\v \\D+\\Z \\D+\\z \\D+$/Bx\n\n/\\d+\\D \\d+\\d \\d+\\S \\d+\\s \\d+\\W \\d+\\w \\d+. \\d+\\R \\d+\\H \\d+\\h \\d+\\V \\d+\\v \\d+\\Z \\d+\\z \\d+$/Bx\n\n/\\S+\\D \\S+\\d \\S+\\S \\S+\\s \\S+\\W \\S+\\w \\S+. \\S+\\R \\S+\\H \\S+\\h \\S+\\V \\S+\\v \\S+\\Z \\S+\\z \\S+$/Bx\n\n/\\s+\\D \\s+\\d \\s+\\S \\s+\\s \\s+\\W \\s+\\w \\s+. \\s+\\R \\s+\\H \\s+\\h \\s+\\V \\s+\\v \\s+\\Z \\s+\\z \\s+$/Bx\n\n/\\W+\\D \\W+\\d \\W+\\S \\W+\\s \\W+\\W \\W+\\w \\W+. \\W+\\R \\W+\\H \\W+\\h \\W+\\V \\W+\\v \\W+\\Z \\W+\\z \\W+$/Bx\n\n/\\w+\\D \\w+\\d \\w+\\S \\w+\\s \\w+\\W \\w+\\w \\w+. \\w+\\R \\w+\\H \\w+\\h \\w+\\V \\w+\\v \\w+\\Z \\w+\\z \\w+$/Bx\n\n/\\R+\\D \\R+\\d \\R+\\S \\R+\\s \\R+\\W \\R+\\w \\R+. \\R+\\R \\R+\\H \\R+\\h \\R+\\V \\R+\\v \\R+\\Z \\R+\\z \\R+$/Bx\n\n/\\H+\\D \\H+\\d \\H+\\S \\H+\\s \\H+\\W \\H+\\w \\H+. \\H+\\R \\H+\\H \\H+\\h \\H+\\V \\H+\\v \\H+\\Z \\H+\\z \\H+$/Bx\n\n/\\h+\\D \\h+\\d \\h+\\S \\h+\\s \\h+\\W \\h+\\w \\h+. \\h+\\R \\h+\\H \\h+\\h \\h+\\V \\h+\\v \\h+\\Z \\h+\\z \\h+$/Bx\n\n/\\V+\\D \\V+\\d \\V+\\S \\V+\\s \\V+\\W \\V+\\w \\V+. \\V+\\R \\V+\\H \\V+\\h \\V+\\V \\V+\\v \\V+\\Z \\V+\\z \\V+$/Bx\n\n/\\v+\\D \\v+\\d \\v+\\S \\v+\\s \\v+\\W \\v+\\w \\v+. \\v+\\R \\v+\\H \\v+\\h \\v+\\V \\v+\\v \\v+\\Z \\v+\\z \\v+$/Bx\n\n/ a+\\D  a+\\d  a+\\S  a+\\s  a+\\W  a+\\w  a+.  a+\\R  a+\\H  a+\\h  a+\\V  a+\\v  a+\\Z  a+\\z  a+$/Bx\n\n/\\n+\\D \\n+\\d \\n+\\S \\n+\\s \\n+\\W \\n+\\w \\n+. \\n+\\R \\n+\\H \\n+\\h \\n+\\V \\n+\\v \\n+\\Z \\n+\\z \\n+$/Bx\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bx\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bsx\n\n/ \\D+$  \\d+$  \\S+$  \\s+$  \\W+$  \\w+$  \\R+$  \\H+$  \\h+$  \\V+$ \\v+$  a+$   \\n+$  .+$  .+$/Bmx\n\n/(?=a+)a(a+)++a/B\n\n/a+(bb|cc)a+(?:bb|cc)a+(?>bb|cc)a+(?:bb|cc)+a+(aa)a+(?:bb|aa)/B\n\n/a+(bb|cc)?#a+(?:bb|cc)??#a+(?:bb|cc)?+#a+(?:bb|cc)*#a+(bb|cc)?a#a+(?:aa)?/B\n\n/a+(?:bb)?a#a+(?:|||)#a+(?:|b)a#a+(?:|||)?a/B\n\n/[ab]*/B\n    aaaa\n\n/[ab]*?/B\n    aaaa\n\n/[ab]?/B\n    aaaa\n\n/[ab]??/B\n    aaaa\n\n/[ab]+/B\n    aaaa\n\n/[ab]+?/B\n    aaaa\n\n/[ab]{2,3}/B\n    aaaa\n\n/[ab]{2,3}?/B\n    aaaa\n\n/[ab]{2,}/B\n    aaaa\n\n/[ab]{2,}?/B\n    aaaa\n\n/\\d+\\s{0,5}=\\s*\\S?=\\w{0,4}\\W*/B\n\n/[a-d]{5,12}[e-z0-9]*#[^a-z]+[b-y]*a[2-7]?[^0-9a-z]+/B\n\n/[a-z]*\\s#[ \\t]?\\S#[a-c]*\\S#[C-G]+?\\d#[4-8]*\\D#[4-9,]*\\D#[!$]{0,5}\\w#[M-Xf-l]+\\W#[a-c,]?\\W/B\n\n/a+(aa|bb)*c#a*(bb|cc)*a#a?(bb|cc)*d#[a-f]*(g|hh)*f/B\n\n/[a-f]*(g|hh|i)*i#[a-x]{4,}(y{0,6})*y#[a-k]+(ll|mm)+n/B\n\n/[a-f]*(?>gg|hh)+#[a-f]*(?>gg|hh)?#[a-f]*(?>gg|hh)*a#[a-f]*(?>gg|hh)*h/B\n\n/[a-c]*d/IB\n\n/[a-c]+d/IB\n\n/[a-c]?d/IB\n\n/[a-c]{4,6}d/IB\n\n/[a-c]{0,6}d/IB\n\n# End of special auto-possessive tests\n\n/^A\\o{1239}B/\n    A\\123B\n\n/^A\\oB/\n\n/^A\\x{zz}B/\n\n/^A\\x{12Z/\n\n/^A\\x{/\n\n/[ab]++/B,no_auto_possess\n\n/[^ab]*+/B,no_auto_possess\n\n/a{4}+/B,no_auto_possess\n\n/a{4}+/Bi,no_auto_possess\n\n/[a-[:digit:]]+/\n\n/[A-[:digit:]]+/\n\n/[a-[.xxx.]]+/\n\n/[a-[=xxx=]]+/\n\n/[a-[!xxx!]]+/\n\n/[A-[!xxx!]]+/\n    A]]]\n\n/[a-\\d]+/\n\n/(?<0abc>xx)/\n\n/(?&1abc)xx(?<1abc>y)/\n\n/(?<ab-cd>xx)/\n\n/(?'0abc'xx)/\n\n/(?P<0abc>xx)/\n\n/\\k<5ghj>/\n\n/\\k'5ghj'/\n\n/\\k{2fgh}/\n\n/(?P=8yuki)/\n\n/\\g{4df}/\n\n/(?&1abc)xx(?<1abc>y)/\n\n/(?P>1abc)xx(?<1abc>y)/\n\n/\\g'3gh'/\n\n/\\g<5fg>/\n\n/(?(<4gh>)abc)/\n\n/(?('4gh')abc)/\n\n/(?(4gh)abc)/\n\n/(?(R&6yh)abc)/\n\n/(((a\\2)|(a*)\\g<-1>))*a?/B\n\n# Test the ugly \"start or end of word\" compatibility syntax.\n\n/[[:<:]]red[[:>:]]/B\n    little red riding hood\n    a /red/ thing\n    red is a colour\n    put it all on red\n\\= Expect no match\n    no reduction\n    Alfred Winifred\n\n/[a[:<:]] should give error/\n\n/(?=ab\\K)/aftertext,allow_lookaround_bsk\n    abcd\\=startchar\n\n/abcd/newline=lf,firstline\n\\= Expect no match\n    xx\\nxabcd\n\n# Test stack guard external calls.\n\n/(((a)))/stackguard=1\n\n/(((a)))/stackguard=2\n\n/(((a)))/stackguard=3\n\n/(((((a)))))/\n\n# End stack guard tests\n\n/^\\w+(?>\\s*)(?<=\\w)/B\n\n/\\othing/\n\n/\\o{}/\n\n/\\o{whatever}/\n\n/\\xthing/\n\n/\\x{}/\n\n/\\x{whatever}/\n\n/A\\8B/\n\n/A\\9B/\n\n# This one is here because Perl fails to match \"12\" for this pattern when the $\n# is present.\n\n/^(?(?=abc)\\w{3}:|\\d\\d)$/\n    abc:\n    12\n\\= Expect no match\n    123\n    xyz\n\n# Perl gets this one wrong, giving \"a\" as the after text for ca and failing to\n# match for cd.\n\n/(?(?=ab)ab)/aftertext\n    abxxx\n    ca\n    cd\n\n# This should test both paths for processing OP_RECURSE.\n\n/(?(R)a+|(?R)b)/\n    aaaabcde\n    aaaabcde\\=ovector=100\n\n/a*?b*?/\n    ab\n\n/(*NOTEMPTY)a*?b*?/\n    ab\n    ba\n    cb\n\n/(*NOTEMPTY_ATSTART)a*?b*?/aftertext\n    ab\n    cdab\n\n/(?(VERSION>=10.0)yes|no)/I\n    yesno\n\n/(?(VERSION>=10.04)yes|no)/\n    yesno\n\n/(?(VERSION=8)yes){3}/BI,aftertext\n    yesno\n\n/(?(VERSION=8)yes|no){3}/I\n    yesnononoyes\n\\= Expect no match\n    yesno\n\n/(?:(?<VERSION>abc)|xyz)(?(VERSION)yes|no)/I\n    abcyes\n    xyzno\n\\= Expect no match\n    abcno\n    xyzyes\n\n/(?(VERSION<10)yes|no)/\n\n/(?(VERSION>10)yes|no)/\n\n/(?(VERSION>=10.0.0)yes|no)/\n\n/(?(VERSION=10.101)yes|no)/\n\n/abcd/I\n\n/abcd/I,no_start_optimize\n\n/(|ab)*?d/I\n   abd\n   xyd\n\n/(|ab)*?d/I,no_start_optimize\n   abd\n   xyd\n\n/\\k<A>*(?<A>aa)(?<A>bb)/match_unset_backref,dupnames\n    aabb\n\n/(((((a)))))/parens_nest_limit=2\n\n/abc/replace=XYZ\n    123123\n    123abc123\n    123abc123abc123\n    123123\\=zero_terminate\n    123abc123\\=zero_terminate\n    123abc123abc123\\=zero_terminate\n\n/abc/g,replace=XYZ\n    123abc123\n    123abc123abc123\n\n/abc/replace=X$$Z\n    123abc123\n\n/abc/g,replace=X$$Z\n    123abc123abc123\n\n/a(b)c(d)e/replace=X$1Y${2}Z\n    \"abcde\"\n\n/a(b)c(d)e/replace=X$1Y${2}Z,global\n    \"abcde-abcde\"\n\n/a(?<ONE>b)c(?<TWO>d)e/replace=X$ONE+${TWO}Z\n    \"abcde\"\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z\n    \"abcde-abcde-\"\n\n/abc/replace=a$++\n    123abc\n\n/abc/replace=a$bad\n    123abc\n\n/abc/replace=a${A234567890123456789_123456789012}z\n    123abc\n\n/abc/replace=a${A23456789012345678901234567890123}z\n    123abc\n\n/abc/replace=a${bcd\n    123abc\n\n/abc/replace=a${b+d}z\n    123abc\n\n/abc/replace=[10]XYZ\n    123abc123\n\n/abc/replace=[9]XYZ\n    123abc123\n\n/abc/replace=xyz\n    1abc2\\=partial_hard\n\n/abc/replace=xyz\n    123abc456\n    123abc456\\=replace=pqr\n    123abc456abc789\n    123abc456abc789\\=g\n\n/(?<=abc)(|def)/g,replace=<$0>\n    123abcxyzabcdef789abcpqr\n\n/./replace=$0\n    a\n\n/(.)(.)/replace=$2+$1\n    abc\n\n/(?<A>.)(?<B>.)/replace=$B+$A\n    abc\n\n/(.)(.)/g,replace=$2$1\n    abcdefgh\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=${*MARK}\n    apple lemon blackberry\n    apple strudel\n    fruitless\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/replace=${*MARK} sauce,\n    apple lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARK>\n    apple lemon blackberry\n    apple strudel\n    fruitless\n\n/(*:pear)apple/g,replace=${*MARKING}\n    apple lemon blackberry\n\n/(*:pear)apple/g,replace=${*MARK-time\n    apple lemon blackberry\n\n/(*:pear)apple/g,replace=${*mark}\n    apple lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARKET>\n    apple lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[22]${*MARK}\n    apple lemon blackberry\n    apple lemon blackberry\\=substitute_overflow_length\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[23]${*MARK}\n    apple lemon blackberry\n\n/abc/\n    123abc123\\=replace=[9]XYZ\n    123abc123\\=substitute_overflow_length,replace=[9]XYZ\n    123abc123\\=substitute_overflow_length,replace=[6]XYZ\n    123abc123\\=substitute_overflow_length,replace=[1]XYZ\n    123abc123\\=substitute_overflow_length,replace=[0]XYZ\n\n/a(b)c/\n    123abc123\\=replace=[9]x$1z\n    123abc123\\=substitute_overflow_length,replace=[9]x$1z\n    123abc123\\=substitute_overflow_length,replace=[6]x$1z\n    123abc123\\=substitute_overflow_length,replace=[1]x$1z\n    123abc123\\=substitute_overflow_length,replace=[0]x$1z\n\n\"((?=(?(?=(?(?=(?(?=()))))))))\"\n    a\n\n\"(?(?=)==)(((((((((?=)))))))))\"\n\\= Expect no match\n    a\n\n/(a)(b)|(c)/\n    XcX\\=ovector=2,get=1,get=2,get=3,get=4,getall\n\n/x(?=ab\\K)/allow_lookaround_bsk\n    xab\\=get=0\n    xab\\=copy=0\n    xab\\=getall\n\n/(?<A>a)|(?<A>b)/dupnames\n    a\\=ovector=1,copy=A,get=A,get=2\n    a\\=ovector=2,copy=A,get=A,get=2\n    b\\=ovector=2,copy=A,get=A,get=2\n\n/a(b)c(d)/\n    abc\\=ph,copy=0,copy=1,getall\n\n/^abc/info\n\n/^abc/info,no_dotstar_anchor\n\n/.*\\d/info,auto_callout\n\\= Expect no match\n    aaa\n\n/.*\\d/info,no_dotstar_anchor,auto_callout\n\\= Expect no match\n    aaa\n\n/.*\\d/dotall,info\n\n/.*\\d/dotall,no_dotstar_anchor,info\n\n/(*NO_DOTSTAR_ANCHOR)(?s).*\\d/info\n\n'^(?:(a)|b)(?(1)A|B)'\n    aA123\\=ovector=1\n    aA123\\=ovector=2\n\n'^(?:(?<AA>a)|b)(?(<AA>)A|B)'\n    aA123\\=ovector=1\n    aA123\\=ovector=2\n\n'^(?<AA>)(?:(?<AA>a)|b)(?(<AA>)A|B)'dupnames\n    aA123\\=ovector=1\n    aA123\\=ovector=2\n    aA123\\=ovector=3\n\n'^(?:(?<AA>X)|)(?:(?<AA>a)|b)\\k{AA}'dupnames\n    aa123\\=ovector=1\n    aa123\\=ovector=2\n    aa123\\=ovector=3\n\n/(?<N111>(?J)(?<N111>1(111111)11|)1|1|)(?(<N111>)1)/\n\n/(?<N>(?J)(?<N>))(?-J)\\k<N>/\n\n# Quantifiers are not allowed on condition assertions, but are otherwise\n# OK in conditions.\n\n/(?(?=0)?)+/\n\n/(?(?=0)(?=00)?00765)/\n     00765\n\n/(?(?=0)(?=00)?00765|(?!3).56)/\n     00765\n     456\n\\= Expect no match\n     356\n\n'^(a)*+(\\w)'\n    g\n    g\\=ovector=1\n\n'^(?:a)*+(\\w)'\n    g\n    g\\=ovector=1\n\n# These two pattern showeds up compile-time bugs\n\n\"((?2){0,1999}())?\"\n\n/((?+1)(\\1))/B\n\n# Callouts with string arguments\n\n/a(?C\"/\n\n/a(?C\"a/\n\n/a(?C\"a\"/\n\n/a(?C\"a\"bcde(?C\"b\")xyz/\n\n/a(?C\"a)b\"\"c\")/B\n\n/ab(?C\" any text with spaces \")cde/B\n    abcde\n    12abcde\n\n/^a(b)c(?C1)def/\n      abcdef\n\n/^a(b)c(?C\"AB\")def/\n      abcdef\n\n/^a(b)c(?C1)def/\n      abcdef\\=callout_capture\n\n/^a(b)c(?C{AB})def/B\n      abcdef\\=callout_capture\n\n/(?C`a``b`)(?C'a''b')(?C\"a\"\"b\")(?C^a^^b^)(?C%a%%b%)(?C#a##b#)(?C$a$$b$)(?C{a}}b})/B,callout_info\n\n/(?:a(?C`code`)){3}/B\n\n/^(?(?C25)(?=abc)abcd|xyz)/B,callout_info\n    abcdefg\n    xyz123\n\n/^(?(?C$abc$)(?=abc)abcd|xyz)/B\n    abcdefg\n    xyz123\n\n/^ab(?C'first')cd(?C\"second\")ef/\n    abcdefg\n\n/(?:a(?C`code`)){3}X/\n    aaaXY\n\n# Binary zero in callout string\n#  a  (  ?  C  '  x     z  '  )  b\n/ 61 28 3f 43 27 78 00 7a 27 29 62/hex,callout_info\n    abcdefgh\n\n/(?(?!)^)/\n\n/(?(?!)a|b)/\n    bbb\n\\= Expect no match\n    aaa\n\n# JIT gives a different error message for the infinite recursion\n\n\"(*NO_JIT)((?2)+)((?1)){\"\n    abcd{\n\n# Perl fails to diagnose the absence of an assertion\n\n\"(?(?<E>.*!.*)?)\"\n\n\"X((?2)()*+){2}+\"B\n\n\"X((?2)()*+){2}\"B\n\n/(?<=\\bABQ(3(?-7)))/\n\n/(?<=\\bABQ(3(?+7)))/\n\n\";(?<=()((?3))((?2)))\"\n\n# Perl loops on this (PCRE2 used to!)\n\n/(?<=\\Ka)/g,aftertext,allow_lookaround_bsk\n    aaaaa\n\n/(?<=\\Ka)/altglobal,aftertext,allow_lookaround_bsk\n    aaaaa\n\n/((?2){73}(?2))((?1))/info\n\n/abc/\n\\= Expect no match\n    \\[9x!xxx(]{9999}\n\n/(abc)*/\n    \\[abc]{5}\n\n/^/gm\n    \\n\\n\\n\n\n/^/gm,alt_circumflex\n    \\n\\n\\n\n\n/((((((((x))))))))\\81/\n    xx1\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\\80/\n    xx\n\n/\\80/\n\n/A\\8B\\9C/\n    A8B9C\n\n/(?x:((?'a')) # comment (with parentheses) and | vertical\n(?-x:#not a comment (?'b')) # this is a comment ()\n(?'c')) # not a comment (?'d')/info\n\n/(?|(?'a')(2)(?'b')|(?'a')(?'a')(3))/I,dupnames\n    A23B\n    B32A\n\n# These are some patterns that used to cause buffer overflows or other errors\n# while compiling.\n\n/.((?2)(?R)|\\1|$)()/B\n\n/.((?3)(?R)()(?2)|\\1|$)()/B\n\n/(\\9*+(?2);\\3++()2|)++{/\n\n/\\V\\x85\\9*+((?2)\\3++()2)*:2/\n\n/(((?(R)){0,2}) (?'x'((?'R')((?'R')))))/dupnames\n\n/(((?(X)){0,2}) (?'x'((?'X')((?'X')))))/dupnames\n\n/(((?(R)){0,2}) (?'x'((?'X')((?'R')))))/\n\n\"(?J)(?'d'(?'d'\\g{d}))\"\n\n\"(?=!((?2)(?))({8(?<=(?1){29}8bbbb\\x16\\xd\\xc6^($(\\xa9H4){4}h}?1)B))\\x15')\"\n\n/A(?'')Z/\n\n\"(?J:(?|(?'R')(\\k'R')|((?'R'))))\"\n\n/(?<=|(\\,\\$(?73591620449005828816)\\xa8.{7}){6}\\x09)/\n\n/^(?:(?(1)x|)+)+$()/B\n\n/[[:>:]](?<)/\n\n/((?x)(*:0))#(?'/\n\n/(?C$[$)(?<]/\n\n/(?C$)$)(?<]/\n\n/(?(R))*+/B\n    abcd\n\n/((?x)(?#))#(?'/\n\n/((?x)(?#))#(?'abc')/I\n\n/[[:\\\\](?<[::]/\n\n/[[:\\\\](?'abc')[a:]/I\n\n\"[[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[:::::::::::::::::[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[[[:::E[[[:[:[[:[:::[[:::E[[[:[:[[:'[:::::E[[[:[::::::[[[:[[[[[[[::E[[[:[::::::[[[:[[[[[[[[:[[::[::::[[:::::::[[:[[[[[[[:[[::[:[[:[~\"\n\n/()(?(R)0)*+/B\n\n/(?R-:(?</\n\n/(?R-:(?<)/\n\n/(?(?C{\\Q})(?!(?'/\n\n/(?(?C{\\Q})(?!(?'abc')))/I\n\n/(?1){3918}(((((0(\\k'R'))))(?J)(?'R'(?'R'\\3){99})))/I\n\n/(?|(aaa)|(b))\\g{1}/I\n\n/(?|(aaa)|(b))(?1)/I\n\n/(?|(aaa)|(b))/I\n\n/(?|(?'a'aaa)|(?'a'b))\\k'a'/I\n\n/(?|(?'a'aaa)|(?'a'b))(?'a'cccc)\\k'a'/I,dupnames\n\n/ab{3cd/\n    ab{3cd\n\n/ab{3,cd/\n    ab{3,cd\n\n/ab{3,4a}cd/\n    ab{3,4a}cd\n\n/{4,5a}bc/\n    {4,5a}bc\n\n/\\x0{ab}/\n    \\0{ab}\n\n/^(a(b))\\1\\g1\\g{1}\\g-1\\g{-1}\\g{-02}Z/\n    ababababbbabZXXXX\n\n/.*?a(*PRUNE)b/\n    aab\n\n/.*?a(*PRUNE)b/s\n    aab\n\n/^a(*PRUNE)b/s\n\\= Expect no match\n    aab\n\n/.*?a(*SKIP)b/\n    aab\n\n/(?(8000000000/\n\n/((?(R8000000000)))/\n\n/0(?0)|(1)(*THEN)(*SKIP:0)(*FAIL)/\n\\= Expect no match\n    01\n\n/(?(1)()\\983040\\2)/\n\n/(*LIMIT_MATCH=)abc/\n\n/(*CRLF)(*LIMIT_MATCH=)abc/\n\n/(?:ab)?(?:ab)(?:ab)/\n    abab\n    ababab\n\\= Expect no match\n    aba\n\n/((*MARK:A))++a(*SKIP:B)b/\n\\= Expect no match\n    aacb\n\n/(*MARK:a\\zb)z/alt_verbnames\n\n/(*:ab\\t(d\\)c)xxx/\n\n/(*:ab\\t(d\\)c)xxx/alt_verbnames,mark\n    cxxxz\n\n/(*:A\\Qxx)x\\EB)x/alt_verbnames,mark\n    x\n\n/(*:A\\ExxxB)x/alt_verbnames,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/x,alt_verbnames,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/alt_verbnames,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/x,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/mark\n    x\n\n/(*:A\nB)x/alt_verbnames,mark\n    x\n\n/(*:abc\\Qpqr)/alt_verbnames\n\n/abc/use_offset_limit\n    1234abcde\\=offset_limit=100\n    1234abcde\\=offset_limit=9\n    1234abcde\\=offset_limit=4\n    1234abcde\\=offset_limit=4,offset=4\n\\= Expect no match\n    1234abcde\\=offset_limit=4,offset=5\n    1234abcde\\=offset_limit=3\n\n/(?<=abc)/use_offset_limit\n    1234abc\\=offset_limit=7\n\\= Expect no match\n    1234abc\\=offset_limit=6\n\n/A/g,replace=-,use_offset_limit\n    XAXAXAXAXA\\=offset_limit=4\n\n/abc/\n\\= Expect error\n    1234abcde\\=offset_limit=4\n\n/^\\w/m,use_offset_limit\n    \\n..\\naa\\=offset_limit=3\n    \\n..\\naa\\=offset_limit=4\n\n/abcd/null_context\n    abcd\\=null_context\n\\= Expect error - not allowed together\n    abcd\\=null_context,find_limits\n    abcd\\=allusedtext,startchar\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended\n    abcd\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended,substitute_literal\n    >>abcd<<\n    \n/abcd/g,replace=\\$1$2\\,substitute_literal\n    XabcdYabcdZ\n\n/a(bc)(DE)/replace=a\\u$1\\U$1\\E$1\\l$2\\L$2\\Eab\\Uab\\LYZ\\EDone,substitute_extended\n    abcDE\n\n/abcd/replace=xy\\kz,substitute_extended\n    abcd\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:+1:-1}X${2:+2:-2}\n    ab\n    ac\n    ab\\=replace=${1:+$1\\:$1:$2}\n    ac\\=replace=${1:+$1\\:$1:$2}\n    >>ac<<\\=replace=${1:+$1\\:$1:$2},substitute_literal\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:-1:-1}X${2:-2:-2}\n    ab\n    ac\n\n/(a)/substitute_extended,replace=>${1:+\\Q$1:{}$$\\E+\\U$1}<\n    a\n\n/X(b)Y/substitute_extended\n    XbY\\=replace=x${1:+$1\\U$1}y\n    XbY\\=replace=\\Ux${1:+$1$1}y\n\n/a/substitute_extended,replace=${*MARK:+a:b}\n    a\n\n/(abcd)/replace=${1:+xy\\kz},substitute_extended\n    abcd\n\n/(abcd)/\n    abcd\\=replace=${1:+xy\\kz},substitute_extended\n\n/abcd/substitute_extended,replace=>$1<\n    abcd\n\n/abcd/substitute_extended,replace=>xxx${xyz}<<<\n    abcd\n\n/(?J)(?:(?<A>a)|(?<A>b))/replace=<$A>\n    [a]\n    [b]\n\\= Expect error\n    (a)\\=ovector=1\n\n/(a)|(b)/replace=<$1>\n\\= Expect error\n    b\n\n/(aa)(BB)/substitute_extended,replace=\\U$1\\L$2\\E$1..\\U$1\\l$2$1\n    aaBB\n    \n/abcd/replace=wxyz,substitute_matched\n    abcd\n    pqrs \n\n/abcd/g\n    >abcd1234abcd5678<\\=replace=wxyz,substitute_matched\n\n/^(o(\\1{72}{\\\"{\\\\{00000059079}\\d*){74}}){19}/I\n\n/((p(?'K/\n\n/((p(?'K/no_auto_capture\n\n/abc/replace=A$3123456789Z\n    abc\n\n/(?<!a{65535}a{5})x/I\n\n/(?<!a{65535})x/I\n\n/(?=a\\K)/replace=z,allow_lookaround_bsk\n    BaCaD\n    \n/(?<=\\K.)/g,replace=-,allow_lookaround_bsk\n    ab\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEFG'toolong)/\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEF'justright)/\n\n# These two use zero-termination\n/abcd/max_pattern_length=3\n\n/abc/max_pattern_length=3\n\n# These two, being hex, pass the length\n/abcdefab/hex,max_pattern_length=3\n\n/abcdef/hex,max_pattern_length=3\n\n# These patterns used to take a long time to compile\n\n\"(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\n\n\"(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\n\n\"(?|()|())(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\n\n\"(?|()|())(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\n\n# Test the use of malloc for caching group information when there are more\n# groups than fit into the on-stack workspace.\n\n/\\[()]{1024}/I,expand\n\n# Test minlength capped at 65535\n\n/(A{65000})\\1{65000}/I\n\n# Test group scans when numbers are not unique\n\n/(?|()+|(a)+)/BI\n\n/(?|(a)+|()+)/BI\n\n/(?|()|(a))/BI\n\n/(?|(a)|())/BI\n\n# Test CRLF handling in empty string substitutions\n\n/^$/gm,newline=anycrlf,replace=-\n    X\\r\\n\\r\\nY\n\n/^$/gm,newline=crlf,replace=-\n    X\\r\\n\\r\\nY\n\n/^$/gm,newline=any,replace=-\n    X\\r\\n\\r\\nY\n\n\"(*ANYCRLF)(?m)^(.*[^0-9\\r\\n].*|)$\"g,replace=NaN\n    15\\r\\nfoo\\r\\n20\\r\\nbar\\r\\nbaz\\r\\n\\r\\n20\n\n/a[[:punct:]b]/bincode\n\n/a[b[:punct:]]/bincode\n\n/L(?#(|++<!(2)?/B\n\n/L(?#(|++<!(2)?/B,no_auto_possess\n\n/L(?#(|++<!(2)?/B,auto_callout\n\n/L(?#(|++<!(2)?/B,no_auto_possess,auto_callout\n\n/(A*)\\E+/B,auto_callout\n\n/()\\Q\\E*]/B,auto_callout\n    a[bc]d\n\n/\\x8a+f|;T?(*:;.'?`(\\xeap ){![^()!y*''C*(?';]{1;(\\x08)/B,alt_verbnames,dupnames,extended\n\n# Tests for NULL characters in comments and verb \"names\" and callouts\n\n# /A#B\\x00C\\x0aZ/\n/41 23 42 00 43 0a 5a/Bx,hex\n\n# /A+#B\\x00C\\x0a+/\n/41 2b 23 42 00 43 0a 2b/Bx,hex\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex,alt_verbnames\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex\n\n# /A(?C{X\\x00Y})B/\n/41 28 3f 43 7b 58 00 59 7d 29 42/B,hex\n\n# /A(?#X\\x00Y)B/\n/41 28 3f 23 7b 00 7d 29 42/B,hex\n\n# Tests for leading comment in extended patterns\n\n/ (?-x):?/extended\n\n/\u000b(?-x):?/extended\n\n/0b 28 3f 2d 78 29 3a/hex,extended\n\n/#comment\n(?-x):?/extended\n\n/(8(*:6^\\x09x\\xa6l\\)6!|\\xd0:[^:|)\\x09d\\Z\\d{85*m(?'(?<1!)*\\W[*\\xff]!!h\\w]*\\xbe;/alt_bsux,alt_verbnames,allow_empty_class,dollar_endonly,extended,multiline,never_utf,no_dotstar_anchor,no_start_optimize\n\n/a|(b)c/replace=>$1<,substitute_unset_empty\n    cat\n    xbcom\n\n/a|(b)c/\n    cat\\=replace=>$1<\n    cat\\=replace=>$1<,substitute_unset_empty\n    xbcom\\=replace=>$1<,substitute_unset_empty\n\n/a|(b)c/substitute_extended\n    cat\\=replace=>${2:-xx}<\n    cat\\=replace=>${2:-xx}<,substitute_unknown_unset\n    cat\\=replace=>${X:-xx}<,substitute_unknown_unset\n\n/a|(?'X'b)c/replace=>$X<,substitute_unset_empty\n    cat\n    xbcom\n\n/a|(?'X'b)c/replace=>$Y<,substitute_unset_empty\n    cat\n    cat\\=substitute_unknown_unset\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\n\n/a|(b)c/replace=>$2<,substitute_unset_empty\n    cat\n    cat\\=substitute_unknown_unset\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\n\n/()()()/use_offset_limit\n    \\=ovector=11000000000\n    \\=callout_fail=11000000000\n    \\=callout_fail=1:11000000000\n    \\=callout_data=11000000000\n    \\=callout_data=-11000000000\n    \\=offset_limit=1100000000000000000000\n    \\=copy=11000000000\n\n/(*MARK:A\\x00b)/mark\n    abc\n\n/(*MARK:A\\x00b)/mark,alt_verbnames\n    abc\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex\n    abc\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex,alt_verbnames\n    abc\n\n/efg/hex\n\n/eff/hex\n\n/effg/hex\n\n/(?J)(?'a'))(?'a')/\n\n/(?<=((?C)0))/\n    9010\n\\= Expect no match\n    abc\n\n/aaa/\n\\[abc]{10000000000000000000000000000}\n\\[a]{3}\n\n/\\[AB]{6000000000000000000000}/expand\n\n# Hex uses pattern length, not zero-terminated. This tests for overrunning\n# the given length of a pattern.\n\n/'(*U'/hex\n\n/'(*'/hex\n\n/'('/hex\n\n//hex\n\n# These tests are here because Perl never allows a back reference in a\n# lookbehind. PCRE2 supports some limited cases.\n\n/([ab])...(?<=\\1)z/\n    a11az\n    b11bz\n\\= Expect no match\n    b11az\n\n/(?|([ab]))...(?<=\\1)z/\n\n/([ab])(\\1)...(?<=\\2)z/\n    aa11az\n\n/(a\\2)(b\\1)(?<=\\2)/\n\n/(?<A>[ab])...(?<=\\k'A')z/\n    a11az\n    b11bz\n\\= Expect no match\n    b11az\n\n/(?<A>[ab])...(?<=\\k'A')(?<A>)z/dupnames\n\n# Perl does not support \\g+n\n\n/((\\g+1X)?([ab]))+/\n    aaXbbXa\n\n/ab(?C1)c/auto_callout\n    abc\n\n/'ab(?C1)c'/hex,auto_callout\n    abc\n\n# Perl accepts these, but gives a warning. We can't warn, so give an error.\n\n/[a-[:digit:]]+/\n    a-a9-a\n\n/[A-[:digit:]]+/\n    A-A9-A\n\n/[a-\\d]+/\n    a-a9-a\n\n/(?<RA>abc)(?(R)xyz)/B\n\n/(?<R>abc)(?(R)xyz)/B\n\n/(?=.*[A-Z])/I\n\n/()(?<=(?0))/\n\n/(?<!|!(?<!))/\n\n/(?<!|!|!||||||(?<!)||(?<!)!|!||(?<!)!|!(?<!)!|!|!|!||||!!|<!)!|!||||!|/\n\n/{2,2{2,2/use_length\n\n/.>*?\\g'0/use_length\n\n/.>*?\\g'0/\n\n/{\ufffd\u0344\ufffd\u0344\ufffd{'{22{2{{2{'{22{\u0012{22{2{'{22{2{{2{{222{{2{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{222{2\u0104\u0344\ufffd\u0344\ufffd{'{22{2{{2{'{22{\u0012{11{2{'{22{2{{2{{'{22{2{{2{'{22{\u0012{22{1{'{22{2{{2{{222{{2{'{22{2{22{2{'{/auto_callout\n\n//\n\\=get=i00000000000000000000000000000000\n\\=get=i2345678901234567890123456789012,get=i1245678901234567890123456789012\n\n\"(?(?C))\"\n\n/(?(?(?(?(?(?))))))/\n\n/(?<=(?1))((?s))/anchored\n\n/(*:ab)*/\n\n%(*:\u001e(:\u0011(\u001fsvvvvvvvvvv:]*[   Z!*;[]*[^[]*!^[\u0019+.+{{2,7}'      _\\\\\\\\\\\\\\\\\\\\\\\\\\)?.:..    *w////\\\\\\Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\T\\\\\\\\\\+/?/////'+\\\\\\EEE?/////'+/*+/[^K]?]//(w)%never_backslash_c,alt_verbnames,auto_callout\n\n/./newline=crlf\n    \\=ph\n\n/(\\x0e00\\000000\\xc)/replace=\\P,substitute_extended\n    \\x0e00\\000000\\xc\n\n//replace=0\n    \\=offset=7\n\n/(?<=\\G.)/g,replace=+\n    abc\n\n\".+\\QX\\E+\"B,no_auto_possess\n\n\".+\\QX\\E+\"B,auto_callout,no_auto_possess\n\n# This one is here because Perl gives an 'unmatched )' error which goes away\n# if one of the \\) sequences is removed - which is weird. PCRE finds it too\n# complicated to find a minimum matching length.\n\n\"()X|((((((((()))))))((((())))))\\2())((((((\\2\\2)))\\2)(\\22((((\\2\\2)2))\\2)))(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z+:)Z|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z((Z*(\\2(Z\\':))\\0)i|||||||||||||||loZ\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0nte!rnal errpr\\2\\\\21r(2\\ZZZ)+:)Z!|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZernZal ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\))\\ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)))\\2))))((((((\\2\\2))))))\"I\n\n# This checks that new code for handling groups that may match an empty string\n# works on a very large number of alternatives. This pattern used to provoke a\n# complaint that it was too complicated.\n\n/(?:\\[A|B|C|D|E|F|G|H|I|J|]{200}Z)/expand\n\n# This one used to compile rubbish instead of a compile error, and then\n# behave unpredictably at match time.\n\n/.+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X/\n    .+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X\n\n/[:[:alnum:]-[[a:lnum:]+/\n\n/((?(?C'')\\QX\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\n\n/((?(?C'')\\Q\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\n\n/abcd/auto_callout\n    abcd\\=callout_error=255:2\n\n/()(\\g+65534)/\n\n/()(\\g+65533)/\n\n/\ufffd\\x00\\x00\\x00\u0017\ufffd(\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\x00k\\d+\\x00\u200e\\x00\\x00\\x00\\x00\\x00\\2*\\x00\\x00\\1*.){36}int^\\x00\\x00\b\ufffd\ufffd\\x00\ufffd(\\1{50779}?)J\\w2/I\n\n/(a)(b)\\2\\1\\1\\1\\1/I\n\n/(?<a>a)(?<b>b)\\g{b}\\g{a}\\g{a}\\g{a}\\g{a}(?<a>xx)(?<b>zz)/I,dupnames\n\n//\n    \\=ovector=7777777777\n\n# This is here because Perl matches, even though a COMMIT is encountered\n# outside of the recursion.\n\n/(?1)(A(*COMMIT)|B)D/\n    BAXBAD\n\n\"(?1){2}(a)\"B\n\n\"(?1){2,4}(a)\"B\n\n# This test differs from Perl for the first subject. Perl ends up with\n# $1 set to 'B'; PCRE2 has it unset (which I think is right).\n\n/^(?:\n(?:A| (?:B|B(*ACCEPT)) (?<=(.)) D)\n(Z)\n)+$/x\n    AZB\n    AZBDZ\n\n# The first of these, when run by Perl, gives the mark 'aa', which is wrong.\n\n'(?>a(*:aa))b|ac' mark\n    ac\n\n'(?:a(*:aa))b|ac' mark\n    ac\n\n/(R?){65}/\n    (R?){65}\n\n/\\[(a)]{60}/expand\n    aaaa\n\n/(?<!\\1((?U)1((?U))))(*F)/never_backslash_c,alt_bsux,anchored,extended\n\n/\\g{3/\n\n/(a(?C1)(b)(c)d)+/\n  abcdabcd\\=callout_capture\n\n# Perl matches this one, but PCRE does not because (*ACCEPT) clears out any\n# pending backtracks in the recursion.\n\n/^ (?(DEFINE) (..(*ACCEPT)|...) ) (?1)$/x\n\\= Expect no match\n    abc\n\n# Perl gives no match for this one\n\n/(a(*MARK:m)(*ACCEPT)){0}(?1)/mark\n    abc\n\n/abc/endanchored\n    xyzabc\n\\= Expect no match\n    xyzabcdef\n\\= Expect error\n    xyzabc\\=ph\n\n/abc/\n    xyzabc\\=endanchored\n\\= Expect no match\n    xyzabcdef\\=endanchored\n\\= Expect error\n    xyzabc\\=ps,endanchored\n\n/abc(*ACCEPT)d/endanchored\n    xyzabc\n\\= Expect no match\n    xyzabcdef\n\n/abc|bcd/endanchored\n    xyzabcd\n\\= Expect no match\n    xyzabcdef\n\n/a(*ACCEPT)x|aa/endanchored\n    aaa\n\n# Check auto-anchoring when there is a group that is never obeyed at\n# the start of a branch.\n\n/(?(DEFINE)(a))^bc/I\n\n/(a){0}.*bc/sI\n\n# This should be anchored, as the condition is always false and there is\n# no alternative branch.\n\n/(?(VERSION>=999)yes)^bc/I\n\n# This should not be anchored.\n\n/(?(VERSION>=999)yes|no)^bc/I\n\n/(*LIMIT_HEAP=0)xxx/I\n\n/\\d{0,3}(*:abc)(?C1)xxx/callout_info\n\n# ----------------------------------------------------------------------\n\n# These are a whole pile of tests that touch lines of code that are not\n# used by any other tests (at least when these were created).\n\n/^a+?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aaa\n\n/^[^a]{3,}?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    bbb\n    cc\n\n/^X\\S/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\W/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\H/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\n\n/^X.+?/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\R+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\n\n/^X\\H+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\h+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\V+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    X\\n\n\n/^X\\D+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    X9\n\n/^X\\S+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    X\\n\n\n/^X\\W+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    XX\n\n/^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n\n/(*CRLF)^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\r\\=ps\n\n/^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\n    X\\n\\r\\n\n    X\\n\\rY\n    X\\n\\nY\n    X\\n\\x{0c}Y\n\n/(*BSR_ANYCRLF)^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\n    X\\n\\r\\n\n    X\\n\\rY\n    X\\n\\nY\n    X\\n\\x{0c}Y\n\n/^X\\H+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\t\n    XYY\n\n/^X\\h+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\n    X\\tY\n\n/^X\\V+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n    XYY\n\n/^X\\v+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\n    X\\nY\n\n/^X\\D+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY9\n    XYY\n\n/^X\\d+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X99\n    X9Y\n\n/^X\\S+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n    XYY\n\n/^X\\s+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\n    X\\nY\n\n/^X\\W+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X.A\n    X++\n\n/^X\\w+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.\n    Xaa\n\n/^X.{1,3}Z/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.bd\n\n/^X\\h+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\n    X\\tY\n\n/^X\\V+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n    XYY\n\n/^(X(*THEN)Y|AB){0}(?1)/\n    ABX\n\\= Expect no match\n    XAB\n\n/^(?!A(?C1)B)C/\n    ABC\\=callout_error=1,no_jit\n\n/^(?!A(?C1)B)C/no_start_optimize\n    ABC\\=callout_error=1\n\n/^(?(?!A(?C1)B)C)/\n    ABC\\=callout_error=1\n\n# ----------------------------------------------------------------------\n\n/[a b c]/BxxI\n\n/[a b c]/BxxxI\n\n/[a b c]/B,extended_more\n\n/[ a b c ]/B,extended_more\n\n/[a b](?xx: [ 12 ] (?-xx:[ 34 ]) )y z/B\n\n# Unsetting /x also unsets /xx\n\n/[a b](?xx: [ 12 ] (?-x:[ 34 ]) )y z/B\n\n/(a)(?-n:(b))(c)/nB\n\n# ----------------------------------------------------------------------\n# These test the dangerous PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL option.\n\n/\\j\\x{z}\\o{82}\\L\\uabcd\\u\\U\\g{\\g/B,\\bad_escape_is_literal\n\n/\\N{\\c/IB,bad_escape_is_literal\n\n/[\\j\\x{z}\\o\\gAb\\g]/B,bad_escape_is_literal\n\n/[Q-\\N]/B,bad_escape_is_literal\n\n/[\\s-_]/bad_escape_is_literal\n\n/[_-\\s]/bad_escape_is_literal\n\n/[\\B\\R\\X]/B\n\n/[\\B\\R\\X]/B,bad_escape_is_literal\n\n/[A-\\BP-\\RV-\\X]/B\n\n/[A-\\BP-\\RV-\\X]/B,bad_escape_is_literal\n\n# ----------------------------------------------------------------------\n\n/a\\b(c/literal\n    a\\\\b(c\n\n/a\\b(c/literal,caseless\n    a\\\\b(c\n    a\\\\B(c\n\n/a\\b(c/literal,firstline\n    XYYa\\\\b(c\n\\= Expect no match\n    X\\na\\\\b(c\n\n/a\\b?c/literal,use_offset_limit\n    XXXXa\\\\b?c\\=offset_limit=4\n\\= Expect no match\n    XXXXa\\\\b?c\\=offset_limit=3\n\n/a\\b(c/literal,anchored,endanchored\n    a\\\\b(c\n\\= Expect no match\n    Xa\\\\b(c\n    a\\\\b(cX\n    Xa\\\\b(cX\n\n//literal,extended\n\n/a\\b(c/literal,auto_callout,no_start_optimize\n    XXXXa\\\\b(c\n\n/a\\b(c/literal,auto_callout\n    XXXXa\\\\b(c\n\n/(*CR)abc/literal\n    (*CR)abc\n\n/cat|dog/I,match_word\n    the cat sat\n\\= Expect no match\n    caterpillar\n    snowcat\n    syndicate\n\n/(cat)|dog/I,match_line,literal\n    (cat)|dog\n\\= Expect no match\n    the cat sat\n    caterpillar\n    snowcat\n    syndicate\n\n/a whole line/match_line,multiline\n    Rhubarb \\na whole line\\n custard\n\\= Expect no match\n    Not a whole line\n\n# Perl gets this wrong, failing to capture 'b' in group 1.\n\n/^(b+|a){1,2}?bc/\n    bbc\n    \n# And again here, for the \"babc\" subject string. \n\n/^(b*|ba){1,2}?bc/\n    babc\n    bbabc\n    bababc\n\\= Expect no match\n    bababbc\n    babababc\n\n/[[:digit:]-a]/\n\n/[[:digit:]-[:print:]]/\n\n/[\\d-a]/\n\n/[\\H-z]/\n\n/[\\d-[:print:]]/\n\n# Perl gets the second of these wrong, giving no match.\n\n\"(?<=(a))\\1?b\"I\n    ab\n    aaab \n\n\"(?=(a))\\1?b\"I\n    ab\n    aaab\n    \n# JIT does not support callout_extra  \n    \n/(*NO_JIT)(a+)b/auto_callout,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \n    \n/(*NO_JIT)a+(?C'XXX')b/no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \n\n/\\n/firstline\n    xyz\\nabc\n\n/\\nabc/firstline\n    xyz\\nabc\n\n/\\x{0a}abc/firstline,newline=crlf\n\\= Expect no match\n    xyz\\r\\nabc\n\n/[abc]/firstline\n\\= Expect no match\n    \\na\n    \n# These tests are matched in test 1 as they are Perl compatible. Here we are\n# looking at what does and does not get auto-possessified. \n\n/(?(DEFINE)(?<optional_a>a?))^(?&optional_a)a$/B\n\n/(?(DEFINE)(?<optional_a>a?)X)^(?&optional_a)a$/B\n    \n/^(a?)b(?1)a/B\n\n/^(a?)+b(?1)a/B\n\n/^(a?)++b(?1)a/B\n\n/^(a?)+b/B\n\n/(?=a+)a(a+)++b/B\n\n/(?<=(?=.){4,5}x)/B\n\n# Perl behaves differently with these when optimization is turned off\n\n/a(*PRUNE:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\n\n/a(*THEN:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\n\n/(?^x-i)AB/ \n\n/(?^-i)AB/ \n\n/(?x-i-i)/\n\n/(?(?=^))b/I\n    abc\n\n/(?(?=^)|)b/I\n    abc\n\n/(?(?=^)|^)b/I\n    bbc\n\\= Expect no match\n    abc     \n\n/(?(1)^|^())/I\n\n/(?(1)^())b/I\n\n/(?(1)^())+b/I,aftertext\n    abc\n\n/(?(1)^()|^)+b/I,aftertext\n    bbc \n\\= Expect no match     \n    abc\n\n/(?(1)^()|^)*b/I,aftertext\n    bbc \n    abc\n    xbc \n\n/(?(1)^())+b/I,aftertext\n    abc\n\n/(?(1)^a()|^a)+b/I,aftertext\n    abc \n\\= Expect no match     \n    bbc\n\n/(?(1)^|^(a))+b/I,aftertext\n    abc \n\\= Expect no match     \n    bbc\n\n/(?(1)^a()|^a)*b/I,aftertext\n    abc \n    bbc\n    xbc \n\n/a(b)c|xyz/g,allvector,replace=<$0>\n    abcdefabcpqr\\=ovector=4\n    abxyz\\=ovector=4\n    abcdefxyz\\=ovector=4\n    \n/a(b)c|xyz/allvector\n    abcdef\\=ovector=4\n    abxyz\\=ovector=4\n\n/a(b)c|xyz/g,replace=<$0>,substitute_callout\n    abcdefabcpqr\n    abxyzpqrabcxyz\n    12abc34xyz99abc55\\=substitute_stop=2\n    12abc34xyz99abc55\\=substitute_skip=1\n    12abc34xyz99abc55\\=substitute_skip=2\n\n/a(b)c|xyz/g,replace=<$0>\n    abcdefabcpqr\n    abxyzpqrabcxyz\n    12abc34xyz\\=substitute_stop=2\n    12abc34xyz\\=substitute_skip=1\n\n/a(b)c|xyz/replace=<$0>\n    abcdefabcpqr\n    12abc34xyz\\=substitute_skip=1\n    12abc34xyz\\=substitute_stop=1\n\n/abc\\rdef/\n    abc\\ndef\n\n/abc\\rdef\\x{0d}xyz/escaped_cr_is_lf\n    abc\\ndef\\rxyz\n\\= Expect no match     \n    abc\\ndef\\nxyz\n\n/(?(*ACCEPT)xxx)/\n\n/(?(*atomic:xx)xxx)/\n\n/(?(*script_run:xxx)zzz)/\n\n/foobar/\n    the foobar thing\\=copy_matched_subject\n    the foobar thing\\=copy_matched_subject,zero_terminate\n\n/foobar/g\n    the foobar thing foobar again\\=copy_matched_subject\n\n/(*:XX)^abc/I\n\n/(*COMMIT:XX)^abc/I\n\n/(*ACCEPT:XX)^abc/I\n\n/abc/replace=xyz\n    abc\\=null_context\n\n/abc/replace=xyz,substitute_callout\n    abc \n\\= Expect error message\n    abc\\=null_context\n\n/\\[()]{65535}()/expand\n\n/\\[()]{65535}(?<A>)/expand\n\n/a(?:(*ACCEPT))??bc/\n    abc\n    axy\n\n/a(*ACCEPT)??bc/\n    abc\n    axy\n\n/a(*ACCEPT:XX)??bc/mark\n    abc\n    axy\n\n/(*:\\)?/\n\n/(*:\\Q \\E){5}/alt_verbnames\n\n/(?=abc)/I\n\n/(?|(X)|(XY))\\1abc/I\n\n/(?|(a)|(bcde))(c)\\2/I\n\n/(?|(a)|(bcde))(c)\\1/I\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'B'(?'A')/I,dupnames\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'A'(?'A')/I,dupnames\n\n/((a|)+)+Z/I\n\n/((?=a))[abcd]/I\n\n/A(?:(*ACCEPT))?B/info\n\n/(A(*ACCEPT)??B)C/\n    ABC\n    AXY \n\n/(?<=(?<=a)b)c.*/I\n    abc\\=ph\n\\= Expect no match\n    xbc\\=ph\n\n/(?<=ab)c.*/I\n    abc\\=ph\n\\= Expect no match\n    xbc\\=ph\n\n/(?<=a(?<=a|a)c)/I\n\n/(?<=a(?<=a|ba)c)/I\n\n/(?<=(?<=a)b)(?<!abcd)/I\n\n/(?<=(?<=a)b)(?<!abcd)(?<=(?<=a)bcde)/I\n\n# Addition overflow\n/( {32742} {42})(?<!\\1{65481})/\n\n# Multiplication overflow\n/(X{65535})(?<=\\1{32770})/\n\n# ---- Non-atomic assertion tests ----\n\n# Expect error: not allowed as a condition\n/(?(*napla:xx)bc)/\n\n/\\A(*pla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n\n/\\A(*napla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n\n/\\A(?*.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n\n/(*plb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n    abcda\\=offset=4 \n\n/(*naplb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n    abcda\\=offset=4 \n    \n/(?<*(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n    abcda\\=offset=4 \n    \n/(*non_atomic_positive_lookahead:ab)/B\n \n/(*non_atomic_positive_lookbehind:ab)/B \n\n/(*pla:ab+)/B\n\n/(*napla:ab+)/B\n\n/(*napla:)+/\n\n/(*naplb:)+/\n\n/(*napla:^x|^y)/I\n\n/(*napla:abc|abd)/I\n\n/(*napla:a|(.)(*ACCEPT)zz)\\1../\n    abcd\n    \n/(*napla:a(*ACCEPT)zz|(.))\\1../\n    abcd\n    \n/(*napla:a|(*COMMIT)(.))\\1\\1/\n    aabc\n\\= Expect no match     \n    abbc   \n\n/(*napla:a|(.))\\1\\1/\n    aabc\n    abbc   \n\n# ----\n\n# Expect error (recursion => not fixed length)\n/(\\2)((?=(?<=\\1)))/\n\n/c*+(?<=[bc])/\n    abc\\=ph\n    ab\\=ph\n    abc\\=ps\n    ab\\=ps\n\n/c++(?<=[bc])/\n    abc\\=ph\n    ab\\=ph\n\n/(?<=(?=.(?<=x)))/\n    abx\n    ab\\=ph\n    bxyz \n    xyz\n    \n/\\z/\n   abc\\=ph\n   abc\\=ps \n   \n/\\Z/\n   abc\\=ph\n   abc\\=ps \n   abc\\n\\=ph\n   abc\\n\\=ps\n\n/(?![ab]).*/\n    ab\\=ph\n\n/c*+/\n    ab\\=ph,offset=2\n\n/\\A\\s*(a|(?:[^`]{28500}){4})/I\n    a\n\n/\\A\\s*((?:[^`]{28500}){4})/I\n\n/\\A\\s*((?:[^`]{28500}){4}|a)/I\n    a\n\n/(?<A>a)(?(<A>)b)((?<=b).*)/B\n\n/(?(1)b)((?<=b).*)/B\n\n/(?(R1)b)((?<=b).*)/B\n\n/(?(DEFINE)b)((?<=b).*)/B\n\n/(?(VERSION=10.3)b)((?<=b).*)/B\n\n/[aA]b[cC]/IB\n\n/[cc]abcd/I\n\n/[Cc]abcd/I\n\n/[c]abcd/I\n\n/(?:c|C)abcd/I\n\n/(a)?a/I\n    manm\n\n/^(?|(\\*)(*napla:\\S*_(\\2?+.+))|(\\w)(?=\\S*_(\\2?+\\1)))+_\\2$/\n    *abc_12345abc\n\n/^(?|(\\*)(*napla:\\S*_(\\3?+.+))|(\\w)(?=\\S*_((\\2?+\\1))))+_\\2$/\n    *abc_12345abc\n\n/^((\\1+)(?C)|\\d)+133X$/\n    111133X\\=callout_capture\n\n/abc/replace=xyz,substitute_replacement_only\n    123abc456\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z,substitute_replacement_only\n    \"abcde-abcde-\"\n     \n/a(b)c|xyz/g,replace=<$0>,substitute_callout,substitute_replacement_only\n    abcdefabcpqr                \n    abxyzpqrabcxyz              \n    12abc34xyz99abc55\\=substitute_stop=2                          \n    12abc34xyz99abc55\\=substitute_skip=1\n    12abc34xyz99abc55\\=substitute_skip=2\n\n/a(..)d/replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\n\n/a(..)d/g,replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\n    xyzabcdxyzabcdxyz\\=ovector=1,substitute_unset_empty\n\n/55|a(..)d/g,replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n\\= Expect error     \n    xyz55abcdxyzabcdxyz\\=ovector=2\n\n/55|a(..)d/replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n\n/55|a(..)d/replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n\n/55|a(..)d/g,replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n    \n/abc/replace=,caseless\n    XabcY\n    XABCY \n\n/abc/replace=[4],caseless\n    XabcY\n    XABCY \n\n/abc/replace=*,caseless\n    XabcY\n    XABCY\n    XabcY\\=replace=  \n\n# Expect non-fixed-length error\n\n\"(?<=X(?(DEFINE)(.*))(?1)).\"\n\n/\\sxxx\\s/tables=1\n\\= Expect no match\n    AB\\x{85}xxx\\x{a0}XYZ\n\n/\\sxxx\\s/tables=2\n    AB\\x{85}xxx\\x{a0}XYZ\n\n/^\\w+/tables=2\n    \u00c9cole\n\n/^\\w+/tables=3\n    \u00c9cole\n\n#loadtables ./testbtables\n\n/^\\w+/tables=3\n    \u00c9cole\n\n/\"(*MARK:>\" 00 \"<)..\"/hex,mark,no_start_optimize\n    AB\n    A\\=ph \n\\= Expect no match\n    A\n\n/\"(*MARK:>\" 00 \"<).(?C1).\"/hex,mark,no_start_optimize\n    AB\n\n/(?(VERSION=0.0/\n\n# Perl has made \\K in lookarounds an error. PCRE2 now rejects as well, unless\n# explicitly authorized.\n\n/(?=a\\Kb)ab/\n\n/(?=a\\Kb)ab/allow_lookaround_bsk\n    ab \n\n/(?!a\\Kb)ac/\n\n/(?!a\\Kb)ac/allow_lookaround_bsk\n    ac \n    \n/^abc(?<=b\\Kc)d/\n\n/^abc(?<=b\\Kc)d/allow_lookaround_bsk\n    abcd\n\n/^abc(?<!b\\Kq)d/\n\n/^abc(?<!b\\Kq)d/,allow_lookaround_bsk\n    abcd\n    \n# --------- \n\n# Tests for zero-length NULL to be treated as an empty string.\n\n//\n    \\=null_subject\n\\= Expect error     \n    abc\\=null_subject\n\n//replace=[20]\n    abc\\=null_replacement\n    \\=null_subject\n    \\=null_replacement\n\n/X*/g,replace=xy\n\\= Expect error\n    >X<\\=null_replacement\n\n/X+/replace=[20]\n    >XX<\\=null_replacement\n\n# --------- \n\n/[Aa]{2}/BI\n    aabcd\n\n/A{2}/iBI\n    aabcd\n\n/[Aa]{2,3}/BI\n    aabcd\n\n# End of testinput2\n", "# This set of tests is not Perl-compatible. It checks on special features\n# of PCRE2's API, error diagnostics, and the compiled code of some patterns.\n# It also checks the non-Perl syntax that PCRE2 supports (Python, .NET,\n# Oniguruma). There are also some tests where PCRE2 and Perl differ,\n# either because PCRE2 can't be compatible, or there is a possible Perl\n# bug.\n\n# NOTE: This is a non-UTF set of tests. When UTF support is needed, use\n# test 5.\n\n#forbid_utf\n#newline_default lf any anycrlf\n\n# Test binary zeroes in the pattern\n\n# /a\\0B/ where 0 is a binary zero\n/61 5c 00 62/B,hex\n------------------------------------------------------------------\n        Bra\n        a\\x00b\n        Ket\n        End\n------------------------------------------------------------------\n    a\\x{0}b\n 0: a\\x00b\n\n# /a0b/ where 0 is a binary zero\n/61 00 62/B,hex\n------------------------------------------------------------------\n        Bra\n        a\\x00b\n        Ket\n        End\n------------------------------------------------------------------\n    a\\x{0}b\n 0: a\\x00b\n\n# /(?#B0C)DE/ where 0 is a binary zero\n/28 3f 23 42 00 43 29 44 45/B,hex\n------------------------------------------------------------------\n        Bra\n        DE\n        Ket\n        End\n------------------------------------------------------------------\n    DE\n 0: DE\n\n/(a)b|/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/abc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n    abc\n 0: abc\n    defabc\n 0: abc\n    abc\\=anchored\n 0: abc\n\\= Expect no match\n    defabc\\=anchored\nNo match\n    ABC\nNo match\n\n/^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n    abc\n 0: abc\n    abc\\=anchored\n 0: abc\n\\= Expect no match\n    defabc\nNo match\n    defabc\\=anchored\nNo match\n\n/a+bc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/a*bc/I\nCapture group count = 0\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/a{3}bc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 5\n\n/(abc|a+z)/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/^abc$/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n    abc\n 0: abc\n\\= Expect no match\n    def\\nabc\nNo match\n\n/ab\\idef/\nFailed: error 103 at offset 3: unrecognized character follows \\\n\n/(?X)ab\\idef/\nFailed: error 111 at offset 2: unrecognized character after (? or (?-\n\n/x{5,4}/\nFailed: error 104 at offset 5: numbers out of order in {} quantifier\n\n/z{65536}/\nFailed: error 105 at offset 7: number too big in {} quantifier\n\n/[abcd/\nFailed: error 106 at offset 5: missing terminating ] for character class\n\n/[\\B]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[\\R]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[\\X]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[z-a]/\nFailed: error 108 at offset 3: range out of order in character class\n\n/^*/\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/(abc/\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/(?# abc/\nFailed: error 118 at offset 7: missing ) after (?# comment\n\n/(?z)abc/\nFailed: error 111 at offset 2: unrecognized character after (? or (?-\n\n/.*b/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/.*?b/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/cat|dog|elephant/I\nCapture group count = 0\nStarting code units: c d e \nSubject length lower bound = 3\n    this sentence eventually mentions a cat\n 0: cat\n    this sentences rambles on and on for a while and then reaches elephant\n 0: elephant\n\n/cat|dog|elephant/I\nCapture group count = 0\nStarting code units: c d e \nSubject length lower bound = 3\n    this sentence eventually mentions a cat\n 0: cat\n    this sentences rambles on and on for a while and then reaches elephant\n 0: elephant\n\n/cat|dog|elephant/Ii\nCapture group count = 0\nOptions: caseless\nStarting code units: C D E c d e \nSubject length lower bound = 3\n    this sentence eventually mentions a CAT cat\n 0: CAT\n    this sentences rambles on and on for a while to elephant ElePhant\n 0: elephant\n\n/a|[bcd]/I\nCapture group count = 0\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a|[^\\dZ])/I\nCapture group count = 1\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / : ; < = > \n  ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y [ \\ ] ^ _ ` a b c d \n  e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \n  \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \n  \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \n  \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \n  \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \n  \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \n  \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \n  \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \n  \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \n  \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/(a|b)*[\\s]/I\nCapture group count = 1\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 a b \nSubject length lower bound = 1\n\n/(ab\\2)/\nFailed: error 115 at offset 4: reference to non-existent subpattern\n\n/{4,5}abc/\nFailed: error 109 at offset 4: quantifier does not follow a repeatable item\n\n/(a)(b)(c)\\2/I\nCapture group count = 3\nMax back reference = 2\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 4\n    abcb\n 0: abcb\n 1: a\n 2: b\n 3: c\n    abcb\\=ovector=0\n 0: abcb\n 1: a\n 2: b\n 3: c\n    abcb\\=ovector=1\nMatched, but too many substrings\n 0: abcb\n    abcb\\=ovector=2\nMatched, but too many substrings\n 0: abcb\n 1: a\n    abcb\\=ovector=3\nMatched, but too many substrings\n 0: abcb\n 1: a\n 2: b\n    abcb\\=ovector=4\n 0: abcb\n 1: a\n 2: b\n 3: c\n\n/(a)bc|(a)(b)\\2/I\nCapture group count = 3\nMax back reference = 2\nFirst code unit = 'a'\nSubject length lower bound = 3\n    abc\n 0: abc\n 1: a\n    abc\\=ovector=0\n 0: abc\n 1: a\n    abc\\=ovector=1\nMatched, but too many substrings\n 0: abc\n    abc\\=ovector=2\n 0: abc\n 1: a\n    aba\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n    aba\\=ovector=0\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n    aba\\=ovector=1\nMatched, but too many substrings\n 0: aba\n    aba\\=ovector=2\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n    aba\\=ovector=3\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n 2: a\n    aba\\=ovector=4\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n\n/abc$/I,dollar_endonly\nCapture group count = 0\nOptions: dollar_endonly\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n    abc\n 0: abc\n\\= Expect no match\n    abc\\n\nNo match\n    abc\\ndef\nNo match\n\n/(a)(b)(c)(d)(e)\\6/\nFailed: error 115 at offset 16: reference to non-existent subpattern\n\n/the quick brown fox/I\nCapture group count = 0\nFirst code unit = 't'\nLast code unit = 'x'\nSubject length lower bound = 19\n    the quick brown fox\n 0: the quick brown fox\n    this is a line with the quick brown fox\n 0: the quick brown fox\n\n/the quick brown fox/I,anchored\nCapture group count = 0\nOptions: anchored\nFirst code unit = 't'\nSubject length lower bound = 19\n    the quick brown fox\n 0: the quick brown fox\n\\= Expect no match\n    this is a line with the quick brown fox\nNo match\n\n/ab(?z)cd/\nFailed: error 111 at offset 4: unrecognized character after (? or (?-\n\n/^abc|def/I\nCapture group count = 0\nStarting code units: a d \nSubject length lower bound = 3\n    abcdef\n 0: abc\n    abcdef\\=notbol\n 0: def\n\n/.*((abc)$|(def))/I\nCapture group count = 3\nFirst code unit at start or follows newline\nSubject length lower bound = 3\n    defabc\n 0: defabc\n 1: abc\n 2: abc\n    defabc\\=noteol\n 0: def\n 1: def\n 2: <unset>\n 3: def\n\n/)/\nFailed: error 122 at offset 0: unmatched closing parenthesis\n\n/a[]b/\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/[^aeiou ]{3,}/I\nCapture group count = 0\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 \n  7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \n  \\ ] ^ _ ` b c d f g h j k l m n p q r s t v w x y z { | } ~ \\x7f \\x80 \\x81 \n  \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \n  \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \n  \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \n  \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \n  \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \n  \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \n  \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \n  \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \n  \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 3\n    co-processors, and for\n 0: -pr\n\n/<.*>/I\nCapture group count = 0\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>ghi<klm>\n\n/<.*?>/I\nCapture group count = 0\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>\n\n/<.*>/I,ungreedy\nCapture group count = 0\nOptions: ungreedy\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>\n\n/(?U)<.*>/I\nCapture group count = 0\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>\n\n/<.*?>/I,ungreedy\nCapture group count = 0\nOptions: ungreedy\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>ghi<klm>\n\n/={3,}/I,ungreedy\nCapture group count = 0\nOptions: ungreedy\nFirst code unit = '='\nLast code unit = '='\nSubject length lower bound = 3\n    abc========def\n 0: ===\n\n/(?U)={3,}?/I\nCapture group count = 0\nFirst code unit = '='\nLast code unit = '='\nSubject length lower bound = 3\n    abc========def\n 0: ========\n\n/(?<!bar|cattle)foo/I\nCapture group count = 0\nMax lookbehind = 6\nFirst code unit = 'f'\nLast code unit = 'o'\nSubject length lower bound = 3\n    foo\n 0: foo\n    catfoo\n 0: foo\n\\= Expect no match\n    the barfoo\nNo match\n    and cattlefoo\nNo match\n\n/abc(?<=a+)b/\nFailed: error 125 at offset 3: lookbehind assertion is not fixed length\n\n/12345(?<=aaa|b{0,3})b/\nFailed: error 125 at offset 5: lookbehind assertion is not fixed length\n\n/(?<!(foo)a\\1)bar/\n\n/(?i)abc/I\nCapture group count = 0\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/(a|(?m)a)/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?i)^1234/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = '1'\nSubject length lower bound = 4\n\n/(^b|(?i)^d)/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nStarting code units: D b d \nSubject length lower bound = 1\n\n/(?s).*/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/[abcd]/I\nCapture group count = 0\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(?i)[abcd]/I\nCapture group count = 0\nStarting code units: A B C D a b c d \nSubject length lower bound = 1\n\n/(?m)[xy]|(b|c)/I\nCapture group count = 1\nStarting code units: b c x y \nSubject length lower bound = 1\n\n/(^a|^b)/Im\nCapture group count = 1\nOptions: multiline\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(?i)(^a|^b)/Im\nCapture group count = 1\nOptions: multiline\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(a)(?(1)a|b|c)/\nFailed: error 127 at offset 3: conditional subpattern contains more than two branches\n\n/(?(?=a)a|b|c)/\nFailed: error 127 at offset 0: conditional subpattern contains more than two branches\n\n/(?(1a)/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/(?(1a))/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/(?(?i))/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/(?(abc))/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/(?(?<ab))/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/((?s)blah)\\s+\\1/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'b'\nLast code unit = 'h'\nSubject length lower bound = 9\n\n/((?i)blah)\\s+\\1/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'b' (caseless)\nLast code unit = 'h' (caseless)\nSubject length lower bound = 9\n\n/((?i)b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n     /i b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'b' (caseless)\nSubject length lower bound = 1\n\n/(a*b|(?i:c*(?-i)d))/I\nCapture group count = 1\nStarting code units: C a b c d \nSubject length lower bound = 1\n\n/a$/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n    a\n 0: a\n    a\\n\n 0: a\n\\= Expect no match\n    a\\=noteol\nNo match\n    a\\n\\=noteol\nNo match\n\n/a$/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit = 'a'\nSubject length lower bound = 1\n    a\n 0: a\n    a\\n\n 0: a\n    a\\n\\=noteol\n 0: a\n\\= Expect no match\n    a\\=noteol\nNo match\n\n/\\Aabc/Im\nCapture group count = 0\nMax lookbehind = 1\nCompile options: multiline\nOverall options: anchored multiline\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/^abc/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/I\nCapture group count = 5\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n  aaaaabbbbbcccccdef\n 0: aaaaabbbbbcccccdef\n 1: aaaaabbbbbcccccdef\n 2: aaaaa\n 3: b\n 4: bbbbccccc\n 5: def\n\n/(?<=foo)[ab]/I\nCapture group count = 0\nMax lookbehind = 3\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?<!foo)(alpha|omega)/I\nCapture group count = 1\nMax lookbehind = 3\nStarting code units: a o \nLast code unit = 'a'\nSubject length lower bound = 5\n\n/(?!alphabet)[ab]/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?<=foo\\n)^bar/Im\nCapture group count = 0\nMax lookbehind = 4\nContains explicit CR or LF match\nOptions: multiline\nLast code unit = 'r'\nSubject length lower bound = 3\n    foo\\nbarbar\n 0: bar\n\\= Expect no match\n    rhubarb\nNo match\n    barbell\nNo match\n    abc\\nbarton\nNo match\n\n/^(?<=foo\\n)bar/Im\nCapture group count = 0\nMax lookbehind = 4\nContains explicit CR or LF match\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'r'\nSubject length lower bound = 3\n    foo\\nbarbar\n 0: bar\n\\= Expect no match\n    rhubarb\nNo match\n    barbell\nNo match\n    abc\\nbarton\nNo match\n\n/(?>^abc)/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    abc\n 0: abc\n    def\\nabc\n 0: abc\n\\= Expect no match\n    defabc\nNo match\n\n/(?<=ab(c+)d)ef/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/(?<=ab(?<=c+)d)ef/\nFailed: error 125 at offset 6: lookbehind assertion is not fixed length\n\n/(?<=ab(c|de)f)g/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/The next three are in testinput2 because they have variable length branches/\n\n/(?<=bullock|donkey)-cart/I\nCapture group count = 0\nMax lookbehind = 7\nFirst code unit = '-'\nLast code unit = 't'\nSubject length lower bound = 5\n    the bullock-cart\n 0: -cart\n    a donkey-cart race\n 0: -cart\n\\= Expect no match\n    cart\nNo match\n    horse-and-cart\nNo match\n\n/(?<=ab(?i)x|y|z)/I\nCapture group count = 0\nMax lookbehind = 3\nMay match empty string\nSubject length lower bound = 0\n\n/(?>.*)(?<=(abcd)|(xyz))/I\nCapture group count = 2\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n    alphabetabcd\n 0: alphabetabcd\n 1: abcd\n    endingxyz\n 0: endingxyz\n 1: <unset>\n 2: xyz\n\n/(?<=ab(?i)x(?-i)y|(?i)z|b)ZZ/I\nCapture group count = 0\nMax lookbehind = 4\nFirst code unit = 'Z'\nLast code unit = 'Z'\nSubject length lower bound = 2\n    abxyZZ\n 0: ZZ\n    abXyZZ\n 0: ZZ\n    ZZZ\n 0: ZZ\n    zZZ\n 0: ZZ\n    bZZ\n 0: ZZ\n    BZZ\n 0: ZZ\n\\= Expect no match\n    ZZ\nNo match\n    abXYZZ\nNo match\n    zzz\nNo match\n    bzz\nNo match\n\n/(?<!(foo)a)bar/I\nCapture group count = 1\nMax lookbehind = 4\nFirst code unit = 'b'\nLast code unit = 'r'\nSubject length lower bound = 3\n    bar\n 0: bar\n    foobbar\n 0: bar\n\\= Expect no match\n    fooabar\nNo match\n\n# Perl does not fail these two for the final subjects.\n\n/^(xa|=?\\1a){2}$/\n    xa=xaa\n 0: xa=xaa\n 1: =xaa\n\\= Expect no match\n    xa=xaaa\nNo match\n\n/^(xa|=?\\1a)+$/\n    xa=xaa\n 0: xa=xaa\n 1: =xaa\n\\= Expect no match\n    xa=xaaa\nNo match\n\n# These are syntax tests from Perl 5.005\n\n/a[b-a]/\nFailed: error 108 at offset 4: range out of order in character class\n\n/a[]b/\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/a[/\nFailed: error 106 at offset 2: missing terminating ] for character class\n\n/*a/\nFailed: error 109 at offset 0: quantifier does not follow a repeatable item\n\n/(*)b/\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/abc)/\nFailed: error 122 at offset 3: unmatched closing parenthesis\n\n/(abc/\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/a**/\nFailed: error 109 at offset 2: quantifier does not follow a repeatable item\n\n/)(/\nFailed: error 122 at offset 0: unmatched closing parenthesis\n\n/\\1/\nFailed: error 115 at offset 1: reference to non-existent subpattern\n\n/\\2/\nFailed: error 115 at offset 1: reference to non-existent subpattern\n\n/(a)|\\2/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/a[b-a]/Ii\nFailed: error 108 at offset 4: range out of order in character class\n\n/a[]b/Ii\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/a[/Ii\nFailed: error 106 at offset 2: missing terminating ] for character class\n\n/*a/Ii\nFailed: error 109 at offset 0: quantifier does not follow a repeatable item\n\n/(*)b/Ii\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/abc)/Ii\nFailed: error 122 at offset 3: unmatched closing parenthesis\n\n/(abc/Ii\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/a**/Ii\nFailed: error 109 at offset 2: quantifier does not follow a repeatable item\n\n/)(/Ii\nFailed: error 122 at offset 0: unmatched closing parenthesis\n\n/:(?:/\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/(?<%)b/\nFailed: error 162 at offset 3: subpattern name expected\n\n/a(?{)b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{{})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{}})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{\"{\"})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{\"{\"}})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/(?(1?)a|b)/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/[a[:xyz:/\nFailed: error 106 at offset 8: missing terminating ] for character class\n\n/(?<=x+)y/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/a{37,17}/\nFailed: error 104 at offset 7: numbers out of order in {} quantifier\n\n/abc/\\\nFailed: error 101 at offset 4: \\ at end of pattern\n\n/abc/\\i\nFailed: error 101 at offset 4: \\ at end of pattern\n\n/(a)bc(d)/I\nCapture group count = 2\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n    abcd\n 0: abcd\n 1: a\n 2: d\n    abcd\\=copy=2\n 0: abcd\n 1: a\n 2: d\n 2C d (1)\n    abcd\\=copy=5\n 0: abcd\n 1: a\n 2: d\nCopy substring 5 failed (-49): unknown substring\n\n/(.{20})/I\nCapture group count = 1\nSubject length lower bound = 20\n    abcdefghijklmnopqrstuvwxyz\n 0: abcdefghijklmnopqrst\n 1: abcdefghijklmnopqrst\n    abcdefghijklmnopqrstuvwxyz\\=copy=1\n 0: abcdefghijklmnopqrst\n 1: abcdefghijklmnopqrst\n 1C abcdefghijklmnopqrst (20)\n    abcdefghijklmnopqrstuvwxyz\\=get=1\n 0: abcdefghijklmnopqrst\n 1: abcdefghijklmnopqrst\n 1G abcdefghijklmnopqrst (20)\n\n/(.{15})/I\nCapture group count = 1\nSubject length lower bound = 15\n    abcdefghijklmnopqrstuvwxyz\n 0: abcdefghijklmno\n 1: abcdefghijklmno\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1\n 0: abcdefghijklmno\n 1: abcdefghijklmno\n 1C abcdefghijklmno (15)\n 1G abcdefghijklmno (15)\n\n/(.{16})/I\nCapture group count = 1\nSubject length lower bound = 16\n    abcdefghijklmnopqrstuvwxyz\n 0: abcdefghijklmnop\n 1: abcdefghijklmnop\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1,getall\n 0: abcdefghijklmnop\n 1: abcdefghijklmnop\n 1C abcdefghijklmnop (16)\n 1G abcdefghijklmnop (16)\n 0L abcdefghijklmnop\n 1L abcdefghijklmnop\n\n/^(a|(bc))de(f)/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nSubject length lower bound = 4\n    adef\\=get=1,get=2,get=3,get=4,getall\n 0: adef\n 1: a\n 2: <unset>\n 3: f\n 1G a (1)\nGet substring 2 failed (-55): requested value is not set\n 3G f (1)\nGet substring 4 failed (-49): unknown substring\n 0L adef\n 1L a\n 2L \n 3L f\n    bcdef\\=get=1,get=2,get=3,get=4,getall\n 0: bcdef\n 1: bc\n 2: bc\n 3: f\n 1G bc (2)\n 2G bc (2)\n 3G f (1)\nGet substring 4 failed (-49): unknown substring\n 0L bcdef\n 1L bc\n 2L bc\n 3L f\n    adefghijk\\=copy=0\n 0: adef\n 1: a\n 2: <unset>\n 3: f\n 0C adef (4)\n\n/^abc\\00def/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 7\n    abc\\00def\\=copy=0,getall\n 0: abc\\x00def\n 0C abc\\x00def (7)\n 0L abc\\x00def\n\n/word ((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)?)?)?)?)?)?)?)?)?otherword/I\nCapture group count = 8\nContains explicit CR or LF match\nFirst code unit = 'w'\nLast code unit = 'd'\nSubject length lower bound = 14\n\n/.*X/IB\n------------------------------------------------------------------\n        Bra\n        Any*\n        X\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'X'\nSubject length lower bound = 1\n\n/.*X/IBs\n------------------------------------------------------------------\n        Bra\n        AllAny*\n        X\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'X'\nSubject length lower bound = 1\n\n/(.*X|^B)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Any*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(.*X|^B)/IBs\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        AllAny*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 1\n\n/(?s)(.*X|^B)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        AllAny*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n\n/(?s:.*X|^B)/IB\n------------------------------------------------------------------\n        Bra\n        Bra\n        AllAny*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n\n/\\Biss\\B/I,aftertext\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n\n/iss/I,aftertext,altglobal\nCapture group count = 0\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n 0: iss\n 0+ ippi\n\n/\\Biss\\B/I,aftertext,altglobal\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n\n/\\Biss\\B/Ig,aftertext\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n 0: iss\n 0+ ippi\n\\= Expect no match\n    Mississippi\\=anchored\nNo match\n\n/(?<=[Ms])iss/Ig,aftertext\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n 0: iss\n 0+ ippi\n\n/(?<=[Ms])iss/I,aftertext,altglobal\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n\n/^iss/Ig,aftertext\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'i'\nSubject length lower bound = 3\n    ississippi\n 0: iss\n 0+ issippi\n\n/.*iss/Ig,aftertext\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 's'\nSubject length lower bound = 3\n    abciss\\nxyzisspqr\n 0: abciss\n 0+ \\x0axyzisspqr\n 0: xyziss\n 0+ pqr\n\n/.i./Ig,aftertext\nCapture group count = 0\nLast code unit = 'i'\nSubject length lower bound = 3\n    Mississippi\n 0: Mis\n 0+ sissippi\n 0: sis\n 0+ sippi\n 0: sip\n 0+ pi\n    Mississippi\\=anchored\n 0: Mis\n 0+ sissippi\n 0: sis\n 0+ sippi\n 0: sip\n 0+ pi\n    Missouri river\n 0: Mis\n 0+ souri river\n 0: ri \n 0+ river\n 0: riv\n 0+ er\n    Missouri river\\=anchored\n 0: Mis\n 0+ souri river\n\n/^.is/Ig,aftertext\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 3\n    Mississippi\n 0: Mis\n 0+ sissippi\n\n/^ab\\n/Ig,aftertext\nCapture group count = 0\nContains explicit CR or LF match\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n    ab\\nab\\ncd\n 0: ab\\x0a\n 0+ ab\\x0acd\n\n/^ab\\n/Igm,aftertext\nCapture group count = 0\nContains explicit CR or LF match\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = \\x0a\nSubject length lower bound = 3\n    ab\\nab\\ncd\n 0: ab\\x0a\n 0+ ab\\x0acd\n 0: ab\\x0a\n 0+ cd\n\n/^/gm,newline=any\n    a\\rb\\nc\\r\\nxyz\\=aftertext\n 0: \n 0+ a\\x0db\\x0ac\\x0d\\x0axyz\n 0: \n 0+ b\\x0ac\\x0d\\x0axyz\n 0: \n 0+ c\\x0d\\x0axyz\n 0: \n 0+ xyz\n\n/abc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/abc|bac/I\nCapture group count = 0\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(abc|bac)/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(abc|(c|dc))/I\nCapture group count = 2\nStarting code units: a c d \nLast code unit = 'c'\nSubject length lower bound = 1\n\n/(abc|(d|de)c)/I\nCapture group count = 2\nStarting code units: a d \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/a*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/a+/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(baa|a+)/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'a'\nSubject length lower bound = 1\n\n/a{0,3}/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/baa{3,}/I\nCapture group count = 0\nFirst code unit = 'b'\nLast code unit = 'a'\nSubject length lower bound = 5\n\n/\"([^\\\\\"]+|\\\\.)*\"/I\nCapture group count = 1\nFirst code unit = '\"'\nLast code unit = '\"'\nSubject length lower bound = 2\n\n/(abc|ab[cd])/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(a|.)/I\nCapture group count = 1\nSubject length lower bound = 1\n\n/a|ba|\\w/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/abc(?=pqr)/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'r'\nSubject length lower bound = 3\n\n/...(?<=abc)/I\nCapture group count = 0\nMax lookbehind = 3\nSubject length lower bound = 3\n\n/abc(?!pqr)/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/ab./I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/ab[xyz]/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/abc*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/ab.c*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/a.c*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/.c*/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/ac*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(a.c*|b.c*)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/a.c*|aba/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/.+a/I\nCapture group count = 0\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/(?=abcda)a.*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/(?=a)a.*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/a(b)*/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/a\\d*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/ab\\d*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/a(\\d)*/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/abcde{0,0}/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n\n/ab\\d+/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/a(?(1)b)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/a(?(1)bag|big)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'g'\nSubject length lower bound = 5\n\n/a(?(1)bag|big)*(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/a(?(1)bag|big)+(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'g'\nSubject length lower bound = 5\n\n/a(?(1)b..|b..)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 5\n\n/ab\\d{0}e/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 3\n\n/a?b?/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    a\n 0: a\n    b\n 0: b\n    ab\n 0: ab\n    \\\n 0: \n\\= Expect no match\n    \\=notempty\nNo match\n\n/|-/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    abcd\n 0: \n    -abc\n 0: \n    ab-c\\=notempty\n 0: -\n\\= Expect no match\n    abc\\=notempty\nNo match\n\n/^.?abcd/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nLast code unit = 'd'\nSubject length lower bound = 4\n\n/\\(             # ( at start\n  (?:           # Non-capturing bracket\n  (?>[^()]+)    # Either a sequence of non-brackets (no backtracking)\n  |             # Or\n  (?R)          # Recurse - i.e. nested bracketed string\n  )*            # Zero or more contents\n  \\)            # Closing )\n  /Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (abcd)\n 0: (abcd)\n    (abcd)xyz\n 0: (abcd)\n    xyz(abcd)\n 0: (abcd)\n    (ab(xy)cd)pqr\n 0: (ab(xy)cd)\n    (ab(xycd)pqr\n 0: (xycd)\n    () abc ()\n 0: ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n 0: (abcde(fsh)xyz(foo(bar))lmno)\n\\= Expect no match\n    abcd\nNo match\n    abcd)\nNo match\n    (abcd\nNo match\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Igx\nCapture group count = 1\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)pqr\n 0: (ab(xy)cd)\n 1: cd\n    1(abcd)(x(y)z)pqr\n 0: (abcd)\n 1: abcd\n 0: (x(y)z)\n 1: z\n\n/\\(  (?: (?>[^()]+) | (?R) ) \\) /Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 3\n    (abcd)\n 0: (abcd)\n    (ab(xy)cd)\n 0: (xy)\n    (a(b(c)d)e)\n 0: (c)\n    ((ab))\n 0: ((ab))\n\\= Expect no match\n    ()\nNo match\n\n/\\(  (?: (?>[^()]+) | (?R) )? \\) /Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    ()\n 0: ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n 0: (fsh)\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Ix\nCapture group count = 1\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: cd\n\n/\\( ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\nCapture group count = 2\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: ab(xy)cd\n 2: cd\n\n/\\( (123)? ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: <unset>\n 2: ab(xy)cd\n 3: cd\n    (123ab(xy)cd)\n 0: (123ab(xy)cd)\n 1: 123\n 2: ab(xy)cd\n 3: cd\n\n/\\( ( (123)? ( (?>[^()]+) | (?R) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: ab(xy)cd\n 2: <unset>\n 3: cd\n    (123ab(xy)cd)\n 0: (123ab(xy)cd)\n 1: 123ab(xy)cd\n 2: 123\n 3: cd\n\n/\\( (((((((((( ( (?>[^()]+) | (?R) )* )))))))))) \\) /Ix\nCapture group count = 11\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: ab(xy)cd\n 2: ab(xy)cd\n 3: ab(xy)cd\n 4: ab(xy)cd\n 5: ab(xy)cd\n 6: ab(xy)cd\n 7: ab(xy)cd\n 8: ab(xy)cd\n 9: ab(xy)cd\n10: ab(xy)cd\n11: cd\n\n/\\( ( ( (?>[^()<>]+) | ((?>[^()]+)) | (?R) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (abcd(xyz<p>qrs)123)\n 0: (abcd(xyz<p>qrs)123)\n 1: abcd(xyz<p>qrs)123\n 2: 123\n\n/\\( ( ( (?>[^()]+) | ((?R)) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(cd)ef)\n 0: (ab(cd)ef)\n 1: ab(cd)ef\n 2: ef\n 3: (cd)\n    (ab(cd(ef)gh)ij)\n 0: (ab(cd(ef)gh)ij)\n 1: ab(cd(ef)gh)ij\n 2: ij\n 3: (cd(ef)gh)\n\n/^[[:alnum:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9A-Za-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:^alnum:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-/:-@[-`{-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / : ; < = > \n  ? @ [ \\ ] ^ _ ` { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \n  \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \n  \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \n  \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \n  \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \n  \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \n  \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \n  \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \n  \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[[:alpha:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [A-Za-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:^alpha:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-@[-`{-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 \n  5 6 7 8 9 : ; < = > ? @ [ \\ ] ^ _ ` { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \\x84 \n  \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \n  \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \n  \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \n  \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \n  \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \n  \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \n  \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \n  \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \n  \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/[_[:alpha:]]/I\nCapture group count = 0\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:ascii:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x7f]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 \n  5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y \n  Z [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \n  \\x7f \nSubject length lower bound = 1\n\n/^[[:^ascii:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x80-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x80 \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \n  \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \n  \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \n  \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \n  \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \n  \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \n  \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \n  \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \n  \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[[:blank:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x09 ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x09 \\x20 \nSubject length lower bound = 1\n\n/^[[:^blank:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x08\\x0a-\\x1f!-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x0a \\x0b \n  \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \n  \\x1b \\x1c \\x1d \\x1e \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 \n  : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ \n  _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \n  \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \n  \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \n  \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \n  \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \n  \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \n  \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \n  \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \n  \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \n  \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/[\\n\\x0b\\x0c\\x0d[:blank:]]/I\nCapture group count = 0\nContains explicit CR or LF match\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/^[[:cntrl:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x1f\\x7f]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x7f \nSubject length lower bound = 1\n\n/^[[:digit:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 1\n\n/^[[:graph:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [!-~]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : \n  ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ \n  ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \nSubject length lower bound = 1\n\n/^[[:lower:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [a-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:print:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [ -~]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 \n  9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] \n  ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \nSubject length lower bound = 1\n\n/^[[:punct:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [!-/:-@[-`{-~]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: ! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ \n  _ ` { | } ~ \nSubject length lower bound = 1\n\n/^[[:space:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/^[[:upper:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [A-Z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \nSubject length lower bound = 1\n\n/^[[:xdigit:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9A-Fa-f]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f \nSubject length lower bound = 1\n\n/^[[:word:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9A-Z_a-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:^cntrl:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [ -~\\x80-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 \n  9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] \n  ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x80 \\x81 \n  \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \n  \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \n  \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \n  \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \n  \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \n  \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \n  \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \n  \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \n  \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[12[:^digit:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-/12:-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / 1 2 : ; < \n  = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a \n  b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \\x81 \\x82 \n  \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \n  \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \n  \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \n  \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \n  \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \n  \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \n  \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \n  \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \n  \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[[:^blank:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x08\\x0a-\\x1f!-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x0a \\x0b \n  \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \n  \\x1b \\x1c \\x1d \\x1e \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 \n  : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ \n  _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \n  \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \n  \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \n  \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \n  \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \n  \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \n  \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \n  \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \n  \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \n  \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/[01[:alpha:]%]/IB\n------------------------------------------------------------------\n        Bra\n        [%01A-Za-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: % 0 1 A B C D E F G H I J K L M N O P Q R S T U V W \n  X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/[[.ch.]]/I\nFailed: error 113 at offset 1: POSIX collating elements are not supported\n\n/[[=ch=]]/I\nFailed: error 113 at offset 1: POSIX collating elements are not supported\n\n/[[:rhubarb:]]/I\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:upper:]]/Ii\nCapture group count = 0\nOptions: caseless\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n    A\n 0: A\n    a\n 0: a\n\n/[[:lower:]]/Ii\nCapture group count = 0\nOptions: caseless\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n    A\n 0: A\n    a\n 0: a\n\n/((?-i)[[:lower:]])[[:lower:]]/Ii\nCapture group count = 1\nOptions: caseless\nStarting code units: a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 2\n    ab\n 0: ab\n 1: a\n    aB\n 0: aB\n 1: a\n\\= Expect no match\n    Ab\nNo match\n    AB\nNo match\n\n/[\\200-\\110]/I\nFailed: error 108 at offset 9: range out of order in character class\n\n/^(?(0)f|b)oo/I\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n# This one's here because of the large output vector needed\n\n/(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\w+)\\s+(\\270)/I\nCapture group count = 271\nMax back reference = 270\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 1\n     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\\=ovector=300\n 0: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\n 1: 1 \n 2: 2 \n 3: 3 \n 4: 4 \n 5: 5 \n 6: 6 \n 7: 7 \n 8: 8 \n 9: 9 \n10: 10 \n11: 11 \n12: 12 \n13: 13 \n14: 14 \n15: 15 \n16: 16 \n17: 17 \n18: 18 \n19: 19 \n20: 20 \n21: 21 \n22: 22 \n23: 23 \n24: 24 \n25: 25 \n26: 26 \n27: 27 \n28: 28 \n29: 29 \n30: 30 \n31: 31 \n32: 32 \n33: 33 \n34: 34 \n35: 35 \n36: 36 \n37: 37 \n38: 38 \n39: 39 \n40: 40 \n41: 41 \n42: 42 \n43: 43 \n44: 44 \n45: 45 \n46: 46 \n47: 47 \n48: 48 \n49: 49 \n50: 50 \n51: 51 \n52: 52 \n53: 53 \n54: 54 \n55: 55 \n56: 56 \n57: 57 \n58: 58 \n59: 59 \n60: 60 \n61: 61 \n62: 62 \n63: 63 \n64: 64 \n65: 65 \n66: 66 \n67: 67 \n68: 68 \n69: 69 \n70: 70 \n71: 71 \n72: 72 \n73: 73 \n74: 74 \n75: 75 \n76: 76 \n77: 77 \n78: 78 \n79: 79 \n80: 80 \n81: 81 \n82: 82 \n83: 83 \n84: 84 \n85: 85 \n86: 86 \n87: 87 \n88: 88 \n89: 89 \n90: 90 \n91: 91 \n92: 92 \n93: 93 \n94: 94 \n95: 95 \n96: 96 \n97: 97 \n98: 98 \n99: 99 \n100: 100 \n101: 101 \n102: 102 \n103: 103 \n104: 104 \n105: 105 \n106: 106 \n107: 107 \n108: 108 \n109: 109 \n110: 110 \n111: 111 \n112: 112 \n113: 113 \n114: 114 \n115: 115 \n116: 116 \n117: 117 \n118: 118 \n119: 119 \n120: 120 \n121: 121 \n122: 122 \n123: 123 \n124: 124 \n125: 125 \n126: 126 \n127: 127 \n128: 128 \n129: 129 \n130: 130 \n131: 131 \n132: 132 \n133: 133 \n134: 134 \n135: 135 \n136: 136 \n137: 137 \n138: 138 \n139: 139 \n140: 140 \n141: 141 \n142: 142 \n143: 143 \n144: 144 \n145: 145 \n146: 146 \n147: 147 \n148: 148 \n149: 149 \n150: 150 \n151: 151 \n152: 152 \n153: 153 \n154: 154 \n155: 155 \n156: 156 \n157: 157 \n158: 158 \n159: 159 \n160: 160 \n161: 161 \n162: 162 \n163: 163 \n164: 164 \n165: 165 \n166: 166 \n167: 167 \n168: 168 \n169: 169 \n170: 170 \n171: 171 \n172: 172 \n173: 173 \n174: 174 \n175: 175 \n176: 176 \n177: 177 \n178: 178 \n179: 179 \n180: 180 \n181: 181 \n182: 182 \n183: 183 \n184: 184 \n185: 185 \n186: 186 \n187: 187 \n188: 188 \n189: 189 \n190: 190 \n191: 191 \n192: 192 \n193: 193 \n194: 194 \n195: 195 \n196: 196 \n197: 197 \n198: 198 \n199: 199 \n200: 200 \n201: 201 \n202: 202 \n203: 203 \n204: 204 \n205: 205 \n206: 206 \n207: 207 \n208: 208 \n209: 209 \n210: 210 \n211: 211 \n212: 212 \n213: 213 \n214: 214 \n215: 215 \n216: 216 \n217: 217 \n218: 218 \n219: 219 \n220: 220 \n221: 221 \n222: 222 \n223: 223 \n224: 224 \n225: 225 \n226: 226 \n227: 227 \n228: 228 \n229: 229 \n230: 230 \n231: 231 \n232: 232 \n233: 233 \n234: 234 \n235: 235 \n236: 236 \n237: 237 \n238: 238 \n239: 239 \n240: 240 \n241: 241 \n242: 242 \n243: 243 \n244: 244 \n245: 245 \n246: 246 \n247: 247 \n248: 248 \n249: 249 \n250: 250 \n251: 251 \n252: 252 \n253: 253 \n254: 254 \n255: 255 \n256: 256 \n257: 257 \n258: 258 \n259: 259 \n260: 260 \n261: 261 \n262: 262 \n263: 263 \n264: 264 \n265: 265 \n266: 266 \n267: 267 \n268: 268 \n269: 269 \n270: ABC\n271: ABC\n\n# This one's here because Perl does this differently and PCRE2 can't at present\n\n/(main(O)?)+/I\nCapture group count = 2\nFirst code unit = 'm'\nLast code unit = 'n'\nSubject length lower bound = 4\n    mainmain\n 0: mainmain\n 1: main\n    mainOmain\n 0: mainOmain\n 1: main\n 2: O\n\n# These are all cases where Perl does it differently (nested captures)\n\n/^(a(b)?)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 1\n    aba\n 0: aba\n 1: a\n 2: b\n\n/^(aa(bb)?)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n\n/^(aa|aa(bb))+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n\n/^(aa(bb)??)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n\n/^(?:aa(bb)?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: bb\n\n/^(aa(b(b))?)+$/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n 3: b\n\n/^(?:aa(b(b))?)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: bb\n 2: b\n\n/^(?:aa(b(?:b))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: bb\n\n/^(?:aa(bb(?:b))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: bbb\n\n/^(?:aa(b(?:bb))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: bbb\n\n/^(?:aa(?:b(b))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: b\n\n/^(?:aa(?:b(bb))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: bb\n\n/^(aa(b(bb))?)+$/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: aa\n 2: bbb\n 3: bb\n\n/^(aa(bb(bb))?)+$/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbbaa\n 0: aabbbbaa\n 1: aa\n 2: bbbb\n 3: bb\n\n# ----------------\n\n/#/IBx\n------------------------------------------------------------------\n        Bra\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nOptions: extended\nSubject length lower bound = 0\n\n/a#/IBx\n------------------------------------------------------------------\n        Bra\n        a\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/[\\s]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/[\\S]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x00-\\x08\\x0e-\\x1f!-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x0e \\x0f \n  \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \\x1b \\x1c \\x1d \\x1e \n  \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C \n  D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a b c d e f g h \n  i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \\x84 \n  \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \n  \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \n  \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \n  \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \n  \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \n  \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \n  \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \n  \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \n  \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/a(?i)b/IB\n------------------------------------------------------------------\n        Bra\n        a\n     /i b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b' (caseless)\nSubject length lower bound = 2\n    ab\n 0: ab\n    aB\n 0: aB\n\\= Expect no match\n    AB\nNo match\n\n/(a(?i)b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n     /i b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b' (caseless)\nSubject length lower bound = 2\n    ab\n 0: ab\n 1: ab\n    aB\n 0: aB\n 1: aB\n\\= Expect no match\n    AB\nNo match\n\n/   (?i)abc/IBx\n------------------------------------------------------------------\n        Bra\n     /i abc\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/#this is a comment\n  (?i)abc/IBx\n------------------------------------------------------------------\n        Bra\n     /i abc\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n------------------------------------------------------------------\n        Bra\n        123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = '1'\nLast code unit = '0'\nSubject length lower bound = 300\n\n/\\Q123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n------------------------------------------------------------------\n        Bra\n        123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = '1'\nLast code unit = '0'\nSubject length lower bound = 300\n\n/\\Q\\E/IB\n------------------------------------------------------------------\n        Bra\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    \\\n 0: \n\n/\\Q\\Ex/IB\n------------------------------------------------------------------\n        Bra\n        x\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nSubject length lower bound = 1\n\n/ \\Q\\E/IB\n------------------------------------------------------------------\n        Bra\n         \n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = ' '\nSubject length lower bound = 1\n\n/a\\Q\\E/IB\n------------------------------------------------------------------\n        Bra\n        a\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n  abc\n 0: a\n  bca\n 0: a\n  bac\n 0: a\n\n/a\\Q\\Eb/IB\n------------------------------------------------------------------\n        Bra\n        ab\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n  abc\n 0: ab\n\n/\\Q\\Eabc/IB\n------------------------------------------------------------------\n        Bra\n        abc\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/x*+\\w/IB\n------------------------------------------------------------------\n        Bra\n        x*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\\= Expect no match\n    xxxxx\nNo match\n\n/x?+/IB\n------------------------------------------------------------------\n        Bra\n        x?+\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/x++/IB\n------------------------------------------------------------------\n        Bra\n        x++\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nSubject length lower bound = 1\n\n/x{1,3}+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        x\n        x{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/x{1,3}+/Bi,no_auto_possess\n------------------------------------------------------------------\n        Bra\n     /i x\n     /i x{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^x]{1,3}+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        [^x]\n        [^x]{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^x]{1,3}+/Bi,no_auto_possess\n------------------------------------------------------------------\n        Bra\n     /i [^x]\n     /i [^x]{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/(x)*+/IB\n------------------------------------------------------------------\n        Bra\n        Braposzero\n        CBraPos 1\n        x\n        KetRpos\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/^(\\w++|\\s++)*$/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n    now is the time for all good men to come to the aid of the party\n 0: now is the time for all good men to come to the aid of the party\n 1: party\n\\= Expect no match\n    this is not a line with only words and spaces!\nNo match\n\n/(\\d++)(\\w)/I\nCapture group count = 2\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 2\n    12345a\n 0: 12345a\n 1: 12345\n 2: a\n\\= Expect no match\n    12345+\nNo match\n\n/a++b/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    aaab\n 0: aaab\n\n/(a++b)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    aaab\n 0: aaab\n 1: aaab\n\n/(a++)b/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    aaab\n 0: aaab\n 1: aaa\n\n/([^()]++|\\([^()]*\\))+/I\nCapture group count = 1\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( * + , - . / 0 1 2 3 4 5 \n  6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \n  \\x80 \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \n  \\x8f \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \n  \\x9e \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \n  \\xad \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \n  \\xbc \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \n  \\xcb \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \n  \\xda \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \n  \\xe9 \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \n  \\xf8 \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n    ((abc(ade)ufh()()x\n 0: abc(ade)ufh()()x\n 1: x\n\n/\\(([^()]++|\\([^()]+\\))+\\)/I\nCapture group count = 1\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 3\n    (abc)\n 0: (abc)\n 1: abc\n    (abc(def)xyz)\n 0: (abc(def)xyz)\n 1: xyz\n\\= Expect no match\n    ((()aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nNo match\n\n/(abc){1,3}+/IB\n------------------------------------------------------------------\n        Bra\n        Once\n        CBra 1\n        abc\n        Ket\n        Brazero\n        Bra\n        CBra 1\n        abc\n        Ket\n        Brazero\n        CBra 1\n        abc\n        Ket\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/a+?+/I\nFailed: error 109 at offset 3: quantifier does not follow a repeatable item\n\n/a{2,3}?+b/I\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/(?U)a+?+/I\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/a{2,3}?+b/I,ungreedy\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/x(?U)a++b/IB\n------------------------------------------------------------------\n        Bra\n        x\n        a++\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n    xaaaab\n 0: xaaaab\n\n/(?U)xa++b/IB\n------------------------------------------------------------------\n        Bra\n        x\n        a++\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n    xaaaab\n 0: xaaaab\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        CBra 2\n        a+\n        Ket\n        CBra 3\n        [ab]+?\n        Ket\n        CBra 4\n        [bc]+\n        Ket\n        CBra 5\n        \\w*+\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 5\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/^x(?U)a+b/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        x\n        a++\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/^x(?U)(a+)b/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        x\n        CBra 1\n        a+?\n        Ket\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/[.x.]/I\nFailed: error 113 at offset 0: POSIX collating elements are not supported\n\n/[=x=]/I\nFailed: error 113 at offset 0: POSIX collating elements are not supported\n\n/[:x:]/I\nFailed: error 112 at offset 0: POSIX named classes are supported only within a class\n\n/\\F/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\l/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\L/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\N{name}/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\u/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\U/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/a{1,3}b/ungreedy\n    ab\n 0: ab\n\n/[/I\nFailed: error 106 at offset 1: missing terminating ] for character class\n\n/[a-/I\nFailed: error 106 at offset 3: missing terminating ] for character class\n\n/[[:space:]/I\nFailed: error 106 at offset 10: missing terminating ] for character class\n\n/[\\s]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/[[:space:]]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/[[:space:]abcde]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d a-e]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 a b c d e \nSubject length lower bound = 1\n\n/< (?: (?(R) \\d++  | [^<>]*+) | (?R)) * >/Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    <>\n 0: <>\n    <abcd>\n 0: <abcd>\n    <abc <123> hij>\n 0: <abc <123> hij>\n    <abc <def> hij>\n 0: <def>\n    <abc<>def>\n 0: <abc<>def>\n    <abc<>\n 0: <>\n\\= Expect no match\n    <abc\nNo match\n\n/8J\\$WE\\<\\.rX\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n------------------------------------------------------------------\n        Bra\n        8J$WE<.rX+ix[d1b!H#?vV0vrK:ZH1=2M>iV;?aPhFB<*vW@QW@sO9}cfZA-i'w%hKd6gt1UJP,15_#QY$M^Mss_U/]&LK9[5vQub^w[KDD<EjmhUZ?.akp2dF>qmj;2}YWFdYx.Ap]hjCPTP(n28k+3;o&WXqs/gOXdr$:r'do0;b4c(f_Gr=\"\\4)[01T7ajQJvL$W~mL_sS/4h:x*[ZN=KLs&L5zX//>it,o:aU(;Z>pW&T7oP'2K^E:x9'c[%z-,64JQ5AeH_G#KijUKghQw^\\vea3a?kka_G$8#`*kynsxzBLru']k_[7FrVx}^=$blx>s-N%j;D*aZDnsw:YKZ%Q.Kne9#hP?+b3(SOvL,^;&u5@?5C5Bhb=m-vEh_L15Jl]U)0RP6{q%L^_z5E'Dw6X\n        \\b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = '8'\nLast code unit = 'X'\nSubject length lower bound = 409\n\n/\\$\\<\\.X\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n------------------------------------------------------------------\n        Bra\n        $<.X+ix[d1b!H#?vV0vrK:ZH1=2M>iV;?aPhFB<*vW@QW@sO9}cfZA-i'w%hKd6gt1UJP,15_#QY$M^Mss_U/]&LK9[5vQub^w[KDD<EjmhUZ?.akp2dF>qmj;2}YWFdYx.Ap]hjCPTP(n28k+3;o&WXqs/gOXdr$:r'do0;b4c(f_Gr=\"\\4)[01T7ajQJvL$W~mL_sS/4h:x*[ZN=KLs&L5zX//>it,o:aU(;Z>pW&T7oP'2K^E:x9'c[%z-,64JQ5AeH_G#KijUKghQw^\\vea3a?kka_G$8#`*kynsxzBLru']k_[7FrVx}^=$blx>s-N%j;D*aZDnsw:YKZ%Q.Kne9#hP?+b3(SOvL,^;&u5@?5C5Bhb=m-vEh_L15Jl]U)0RP6{q%L^_z5E'Dw6X\n        \\b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = '$'\nLast code unit = 'X'\nSubject length lower bound = 404\n\n/(.*)\\d+\\1/I\nCapture group count = 1\nMax back reference = 1\nSubject length lower bound = 1\n\n/(.*)\\d+/I\nCapture group count = 1\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(.*)\\d+\\1/Is\nCapture group count = 1\nMax back reference = 1\nOptions: dotall\nSubject length lower bound = 1\n\n/(.*)\\d+/Is\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 1\n\n/(.*(xyz))\\d+\\2/I\nCapture group count = 2\nMax back reference = 2\nFirst code unit at start or follows newline\nLast code unit = 'z'\nSubject length lower bound = 7\n\n/((.*))\\d+\\1/I\nCapture group count = 2\nMax back reference = 1\nSubject length lower bound = 1\n    abc123bc\n 0: bc123bc\n 1: bc\n 2: bc\n\n/a[b]/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?=a).*/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?=abc).xyz/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nLast code unit = 'z' (caseless)\nSubject length lower bound = 4\n\n/(?=abc)(?i).xyz/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'z' (caseless)\nSubject length lower bound = 4\n\n/(?=a)(?=b)/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?=.)a/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=abcda)a)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/((?=abcda)ab)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/()a/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?:(?=.)|(?<!x))a/I\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?(1)ab|ac)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(?(1)abz|acz)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(?(1)abz)(.)/I\nCapture group count = 1\nMax back reference = 1\nSubject length lower bound = 1\n\n/(?(1)abz)(1)23/I\nCapture group count = 1\nMax back reference = 1\nLast code unit = '3'\nSubject length lower bound = 3\n\n/(a)+/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(a){2,3}/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/(a)*/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/[a]/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/[ab]/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/[ab]/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/[^a]/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/\\d456/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '6'\nSubject length lower bound = 4\n\n/\\d456/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '6'\nSubject length lower bound = 4\n\n/a^b/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'a'\nSubject length lower bound = 1\n  abcde\n 0: a\n  xy\\nabc\n 0: a\n\\= Expect no match\n  xyabc\nNo match\n\n/c|abc/I\nCapture group count = 0\nStarting code units: a c \nLast code unit = 'c'\nSubject length lower bound = 1\n\n/(?i)[ab]/I\nCapture group count = 0\nStarting code units: A B a b \nSubject length lower bound = 1\n\n/[ab](?i)cd/I\nCapture group count = 0\nStarting code units: a b \nLast code unit = 'd' (caseless)\nSubject length lower bound = 3\n\n/abc(?C)def/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    abcdef\n--->abcdef\n  0 ^  ^       d\n 0: abcdef\n    1234abcdef\n--->1234abcdef\n  0     ^  ^       d\n 0: abcdef\n\\= Expect no match\n    abcxyz\nNo match\n    abcxyzf\n--->abcxyzf\n  0 ^  ^        d\nNo match\n\n/abc(?C)de(?C1)f/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    123abcdef\n--->123abcdef\n  0    ^  ^       d\n  1    ^    ^     f\n 0: abcdef\n\n/(?C1)\\dabc(?C2)def/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'f'\nSubject length lower bound = 7\n    1234abcdef\n--->1234abcdef\n  1 ^              \\d\n  1  ^             \\d\n  1   ^            \\d\n  1    ^           \\d\n  2    ^   ^       d\n 0: 4abcdef\n\\= Expect no match\n    abcdef\nNo match\n\n/(?C1)\\dabc(?C2)def/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'f'\nSubject length lower bound = 7\n    1234abcdef\n--->1234abcdef\n  1 ^              \\d\n  1  ^             \\d\n  1   ^            \\d\n  1    ^           \\d\n  2    ^   ^       d\n 0: 4abcdef\n\\= Expect no match\n    abcdef\nNo match\n\n/(?C255)ab/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?C256)ab/I\nFailed: error 138 at offset 6: number after (?C is greater than 255\n\n/(?Cab)xx/I\nFailed: error 182 at offset 3: unrecognized string delimiter follows (?C\n\n/(?C12vr)x/I\nFailed: error 139 at offset 5: closing parenthesis for (?C expected\n\n/abc(?C)def/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    \\x83\\x0\\x61bcdef\n--->\\x83\\x00abcdef\n  0         ^  ^       d\n 0: abcdef\n\n/(abc)(?C)de(?C1)f/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    123abcdef\n--->123abcdef\n  0    ^  ^       d\n  1    ^    ^     f\n 0: abcdef\n 1: abc\n    123abcdef\\=callout_capture\nCallout 0: last capture = 1\n 1: abc\n--->123abcdef\n       ^  ^       d\nCallout 1: last capture = 1\n 1: abc\n--->123abcdef\n       ^    ^     f\n 0: abcdef\n 1: abc\n    123abcdefC-\\=callout_none\n 0: abcdef\n 1: abc\n\\= Expect no match\n    123abcdef\\=callout_fail=1\n--->123abcdef\n  0    ^  ^       d\n  1    ^    ^     f\nNo match\n\n/(?C0)(abc(?C1))*/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n    abcabcabc\n--->abcabcabc\n  0 ^             (\n  1 ^  ^          )*\n  1 ^     ^       )*\n  1 ^        ^    )*\n 0: abcabcabc\n 1: abc\n    abcabc\\=callout_fail=1:4\n--->abcabc\n  0 ^          (\n  1 ^  ^       )*\n  1 ^     ^    )*\n 0: abcabc\n 1: abc\n    abcabcabc\\=callout_fail=1:4\n--->abcabcabc\n  0 ^             (\n  1 ^  ^          )*\n  1 ^     ^       )*\n  1 ^        ^    )*\n 0: abcabc\n 1: abc\n\n/(\\d{3}(?C))*/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n    123\\=callout_capture\nCallout 0: last capture = 0\n--->123\n    ^  ^    )*\n 0: 123\n 1: 123\n    123456\\=callout_capture\nCallout 0: last capture = 0\n--->123456\n    ^  ^       )*\nCallout 0: last capture = 1\n 1: 123\n--->123456\n    ^     ^    )*\n 0: 123456\n 1: 456\n    123456789\\=callout_capture\nCallout 0: last capture = 0\n--->123456789\n    ^  ^          )*\nCallout 0: last capture = 1\n 1: 123\n--->123456789\n    ^     ^       )*\nCallout 0: last capture = 1\n 1: 456\n--->123456789\n    ^        ^    )*\n 0: 123456789\n 1: 789\n\n/((xyz)(?C)p|(?C1)xyzabc)/I\nCapture group count = 2\nFirst code unit = 'x'\nSubject length lower bound = 4\n    xyzabc\\=callout_capture\nCallout 0: last capture = 2\n 1: <unset>\n 2: xyz\n--->xyzabc\n    ^  ^       p\nCallout 1: last capture = 0\n--->xyzabc\n    ^          x\n 0: xyzabc\n 1: xyzabc\n\n/(X)((xyz)(?C)p|(?C1)xyzabc)/I\nCapture group count = 3\nFirst code unit = 'X'\nLast code unit = 'x'\nSubject length lower bound = 5\n    Xxyzabc\\=callout_capture\nCallout 0: last capture = 3\n 1: X\n 2: <unset>\n 3: xyz\n--->Xxyzabc\n    ^   ^       p\nCallout 1: last capture = 1\n 1: X\n--->Xxyzabc\n    ^^          x\n 0: Xxyzabc\n 1: X\n 2: xyzabc\n\n/(?=(abc))(?C)abcdef/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    abcdef\\=callout_capture\nCallout 0: last capture = 1\n 1: abc\n--->abcdef\n    ^          a\n 0: abcdef\n 1: abc\n\n/(?!(abc)(?C1)d)(?C2)abcxyz/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 6\n    abcxyz\\=callout_capture\nCallout 1: last capture = 1\n 1: abc\n--->abcxyz\n    ^  ^       d\nCallout 2: last capture = 0\n--->abcxyz\n    ^          a\n 0: abcxyz\n\n/(?<=(abc)(?C))xyz/I\nCapture group count = 1\nMax lookbehind = 3\nFirst code unit = 'x'\nLast code unit = 'z'\nSubject length lower bound = 3\n   abcxyz\\=callout_capture\nCallout 0: last capture = 1\n 1: abc\n--->abcxyz\n       ^       )\n 0: xyz\n 1: abc\n\n/a(b+)(c*)(?C1)/I\nCapture group count = 2\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n--->abbbbbccc\n  1 ^        ^    End of pattern\nCallout data = 1\nNo match\n\n/a(b+?)(c*?)(?C1)/I\nCapture group count = 2\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n--->abbbbbccc\n  1 ^ ^           End of pattern\nCallout data = 1\n  1 ^  ^          End of pattern\nCallout data = 1\n  1 ^   ^         End of pattern\nCallout data = 1\n  1 ^    ^        End of pattern\nCallout data = 1\n  1 ^     ^       End of pattern\nCallout data = 1\n  1 ^      ^      End of pattern\nCallout data = 1\n  1 ^       ^     End of pattern\nCallout data = 1\n  1 ^        ^    End of pattern\nCallout data = 1\nNo match\n\n/(?C)abc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?C)^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(?C)a|b/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/a|(b)(?C)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 1\n    b\n--->b\n  0 ^^    End of pattern\n 0: b\n 1: b\n\n/x(ab|(bc|(de|(?R))))/I\nCapture group count = 3\nFirst code unit = 'x'\nSubject length lower bound = 3\n    xab\n 0: xab\n 1: ab\n    xbc\n 0: xbc\n 1: bc\n 2: bc\n    xde\n 0: xde\n 1: de\n 2: de\n 3: de\n    xxab\n 0: xxab\n 1: xab\n 2: xab\n 3: xab\n    xxxab\n 0: xxxab\n 1: xxab\n 2: xxab\n 3: xxab\n\\= Expect no match\n    xyab\nNo match\n\n/^([^()]|\\((?1)*\\))*$/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n    abc\n 0: abc\n 1: c\n    a(b)c\n 0: a(b)c\n 1: c\n    a(b(c))d\n 0: a(b(c))d\n 1: d\n\\= Expect no match)\n    a(b(c)d\nNo match\n\n/^>abc>([^()]|\\((?1)*\\))*<xyz<$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = '>'\nLast code unit = '<'\nSubject length lower bound = 10\n   >abc>123<xyz<\n 0: >abc>123<xyz<\n 1: 3\n   >abc>1(2)3<xyz<\n 0: >abc>1(2)3<xyz<\n 1: 3\n   >abc>(1(2)3)<xyz<\n 0: >abc>(1(2)3)<xyz<\n 1: (1(2)3)\n\n/(a(?1)b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Recurse\n        b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(a(?1)+b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        SBra\n        Recurse\n        KetRmax\n        b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^(\\d+|\\((?1)([+*-])(?1)\\)|-(?1))$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nStarting code units: ( - 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 1\n    12\n 0: 12\n 1: 12\n    (((2+2)*-3)-7)\n 0: (((2+2)*-3)-7)\n 1: (((2+2)*-3)-7)\n 2: -\n    -12\n 0: -12\n 1: -12\n\\= Expect no match\n    ((2+2)*-3)-7)\nNo match\n\n/^(x(y|(?1){2})z)/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'x'\nSubject length lower bound = 3\n    xyz\n 0: xyz\n 1: xyz\n 2: y\n    xxyzxyzz\n 0: xxyzxyzz\n 1: xxyzxyzz\n 2: xyzxyz\n\\= Expect no match\n    xxyzz\nNo match\n    xxyzxyzxyzz\nNo match\n\n/((< (?: (?(R) \\d++  | [^<>]*+) | (?2)) * >))/Ix\nCapture group count = 2\nOptions: extended\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    <>\n 0: <>\n 1: <>\n 2: <>\n    <abcd>\n 0: <abcd>\n 1: <abcd>\n 2: <abcd>\n    <abc <123> hij>\n 0: <abc <123> hij>\n 1: <abc <123> hij>\n 2: <abc <123> hij>\n    <abc <def> hij>\n 0: <def>\n 1: <def>\n 2: <def>\n    <abc<>def>\n 0: <abc<>def>\n 1: <abc<>def>\n 2: <abc<>def>\n    <abc<>\n 0: <>\n 1: <>\n 2: <>\n\\= Expect no match\n    <abc\nNo match\n\n/(?1)/I\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/((?2)(abc)/I\nFailed: error 114 at offset 10: missing closing parenthesis\n\n/^(abc)def(?1)/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 9\n    abcdefabc\n 0: abcdefabc\n 1: abc\n\n/^(a|b|c)=(?1)+/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b c \nSubject length lower bound = 2\n    a=a\n 0: a=a\n 1: a\n    a=b\n 0: a=b\n 1: a\n    a=bc\n 0: a=bc\n 1: a\n\n/^(a|b|c)=((?1))+/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b c \nSubject length lower bound = 2\n    a=a\n 0: a=a\n 1: a\n 2: a\n    a=b\n 0: a=b\n 1: a\n 2: b\n    a=bc\n 0: a=bc\n 1: a\n 2: c\n\n/a(?P<name1>b|c)d(?P<longername2>e)/IB\n------------------------------------------------------------------\n        Bra\n        a\n        CBra 1\n        b\n        Alt\n        c\n        Ket\n        d\n        CBra 2\n        e\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nNamed capture groups:\n  longername2   2\n  name1         1\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 4\n    abde\n 0: abde\n 1: b\n 2: e\n    acde\n 0: acde\n 1: c\n 2: e\n\n/(?:a(?P<c>c(?P<d>d)))(?P<a>a)/IB\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        CBra 1\n        c\n        CBra 2\n        d\n        Ket\n        Ket\n        Ket\n        CBra 3\n        a\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 3\nNamed capture groups:\n  a   3\n  c   1\n  d   2\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 4\n\n/(?P<a>a)...(?P=a)bbb(?P>a)d/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        Any\n        Any\n        Any\n        \\1\n        bbb\n        Recurse\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  a   1\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 10\n\n/^\\W*(?:(?P<one>(?P<two>.)\\W*(?P>one)\\W*(?P=two)|)|(?P<three>(?P<four>.)\\W*(?P>three)\\W*(?P=four)|\\W*.\\W*))\\W*$/Ii\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  four    4\n  one     1\n  three   3\n  two     2\nMay match empty string\nCompile options: caseless\nOverall options: anchored caseless\nSubject length lower bound = 0\n    1221\n 0: 1221\n 1: 1221\n 2: 1\n    Satan, oscillate my metallic sonatas!\n 0: Satan, oscillate my metallic sonatas!\n 1: <unset>\n 2: <unset>\n 3: Satan, oscillate my metallic sonatas\n 4: S\n    A man, a plan, a canal: Panama!\n 0: A man, a plan, a canal: Panama!\n 1: <unset>\n 2: <unset>\n 3: A man, a plan, a canal: Panama\n 4: A\n    Able was I ere I saw Elba.\n 0: Able was I ere I saw Elba.\n 1: <unset>\n 2: <unset>\n 3: Able was I ere I saw Elba\n 4: A\n\\= Expect no match\n    The quick brown fox\nNo match\n\n/((?(R)a|b))\\1(?1)?/I\nCapture group count = 1\nMax back reference = 1\nSubject length lower bound = 2\n  bb\n 0: bb\n 1: b\n  bbaa\n 0: bba\n 1: b\n\n/(.*)a/Is\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/(.*)a\\1/Is\nCapture group count = 1\nMax back reference = 1\nOptions: dotall\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/(.*)a(b)\\2/Is\nCapture group count = 2\nMax back reference = 2\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/((.*)a|(.*)b)z/Is\nCapture group count = 3\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/((.*)a|(.*)b)z\\1/Is\nCapture group count = 3\nMax back reference = 1\nOptions: dotall\nLast code unit = 'z'\nSubject length lower bound = 3\n\n/((.*)a|(.*)b)z\\2/Is\nCapture group count = 3\nMax back reference = 2\nOptions: dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/((.*)a|(.*)b)z\\3/Is\nCapture group count = 3\nMax back reference = 3\nOptions: dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/((.*)a|^(.*)b)z\\3/Is\nCapture group count = 3\nMax back reference = 3\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a/Is\nCapture group count = 31\nMay match empty string\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 0\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\31/Is\nCapture group count = 31\nMax back reference = 31\nMay match empty string\nOptions: dotall\nSubject length lower bound = 0\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\32/Is\nCapture group count = 32\nMax back reference = 32\nMay match empty string\nOptions: dotall\nSubject length lower bound = 0\n\n/(a)(bc)/IB,no_auto_capture\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        Ket\n        Bra\n        bc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: no_auto_capture\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n  abc\n 0: abc\n\n/(?P<one>a)(bc)/IB,no_auto_capture\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        Bra\n        bc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nNamed capture groups:\n  one   1\nOptions: no_auto_capture\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n  abc\n 0: abc\n 1: a\n\n/(a)(?P<named>bc)/IB,no_auto_capture\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        Ket\n        CBra 1\n        bc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nNamed capture groups:\n  named   1\nOptions: no_auto_capture\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(aaa(?C1)bbb|ab)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n   aaabbb\n--->aaabbb\n  1 ^  ^       b\n 0: aaabbb\n 1: aaabbb\n   aaabbb\\=callout_data=0\n--->aaabbb\n  1 ^  ^       b\n 0: aaabbb\n 1: aaabbb\n   aaabbb\\=callout_data=1\n--->aaabbb\n  1 ^  ^       b\nCallout data = 1\n 0: ab\n 1: ab\n\\= Expect no match\n   aaabbb\\=callout_data=-1\n--->aaabbb\n  1 ^  ^       b\nCallout data = -1\nNo match\n\n/ab(?P<one>cd)ef(?P<two>gh)/I\nCapture group count = 2\nNamed capture groups:\n  one   1\n  two   2\nFirst code unit = 'a'\nLast code unit = 'h'\nSubject length lower bound = 8\n    abcdefgh\n 0: abcdefgh\n 1: cd\n 2: gh\n    abcdefgh\\=copy=1,get=two\n 0: abcdefgh\n 1: cd\n 2: gh\n 1C cd (2)\n  G gh (2) two (group 2)\n    abcdefgh\\=copy=one,copy=two\n 0: abcdefgh\n 1: cd\n 2: gh\n  C cd (2) one (group 1)\n  C gh (2) two (group 2)\n    abcdefgh\\=copy=three\n 0: abcdefgh\n 1: cd\n 2: gh\nNumber not found for group 'three'\nCopy substring 'three' failed (-49): unknown substring\n\n/(?P<Tes>)(?P<Test>)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        CBra 2\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nNamed capture groups:\n  Tes    1\n  Test   2\nMay match empty string\nSubject length lower bound = 0\n\n/(?P<Test>)(?P<Tes>)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        CBra 2\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nNamed capture groups:\n  Tes    2\n  Test   1\nMay match empty string\nSubject length lower bound = 0\n\n/(?P<Z>zz)(?P<A>aa)/I\nCapture group count = 2\nNamed capture groups:\n  A   2\n  Z   1\nFirst code unit = 'z'\nLast code unit = 'a'\nSubject length lower bound = 4\n    zzaa\\=copy=Z\n 0: zzaa\n 1: zz\n 2: aa\n  C zz (2) Z (group 1)\n    zzaa\\=copy=A\n 0: zzaa\n 1: zz\n 2: aa\n  C aa (2) A (group 2)\n\n/(?P<x>eks)(?P<x>eccs)/I\nFailed: error 143 at offset 16: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n/(?P<abc>abc(?P<def>def)(?P<abc>xyz))/I\nFailed: error 143 at offset 31: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)\\]\"I\nCapture group count = 3\nNamed capture groups:\n  elem   2\nFirst code unit = '['\nLast code unit = ']'\nSubject length lower bound = 3\n    [10,20,30,5,5,4,4,2,43,23,4234]\n 0: [10,20,30,5,5,4,4,2,43,23,4234]\n 1: 10,20,30,5,5,4,4,2,43,23,4234\n 2: 10\n 3: ,4234\n\\= Expect no match\n    []\nNo match\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)?\\]\"I\nCapture group count = 3\nNamed capture groups:\n  elem   2\nFirst code unit = '['\nLast code unit = ']'\nSubject length lower bound = 2\n    [10,20,30,5,5,4,4,2,43,23,4234]\n 0: [10,20,30,5,5,4,4,2,43,23,4234]\n 1: 10,20,30,5,5,4,4,2,43,23,4234\n 2: 10\n 3: ,4234\n    []\n 0: []\n\n/(a(b(?2)c))?/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(a(b(?2)c))*/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        KetRmax\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(a(b(?2)c)){0,2}/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Bra\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        Ket\n        Brazero\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/[ab]{1}+/B\n------------------------------------------------------------------\n        Bra\n        [ab]\n        Ket\n        End\n------------------------------------------------------------------\n\n/()(?1){1}/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/()(?1)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\nCapture group count = 3\nOptions: caseless\nLast code unit = 'g' (caseless)\nSubject length lower bound = 8\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n 0: Baby Bjorn Active Carrier - With free SHIPPING!!\n 1: Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\nCapture group count = 3\nOptions: caseless\nLast code unit = 'g' (caseless)\nSubject length lower bound = 8\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n 0: Baby Bjorn Active Carrier - With free SHIPPING!!\n 1: Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/a*.*b/IB\n------------------------------------------------------------------\n        Bra\n        a*\n        Any*\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/(a|b)*.?c/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        CBra 1\n        a\n        Alt\n        b\n        KetRmax\n        Any?\n        c\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nLast code unit = 'c'\nSubject length lower bound = 1\n\n/abc(?C255)de(?C)f/IB\n------------------------------------------------------------------\n        Bra\n        abc\n        Callout 255 10 1\n        de\n        Callout 0 16 1\n        f\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n\n/abcde/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        a\n        Callout 255 1 1\n        b\n        Callout 255 2 1\n        c\n        Callout 255 3 1\n        d\n        Callout 255 4 1\n        e\n        Callout 255 5 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 5\n  abcde\n--->abcde\n +0 ^         a\n +1 ^^        b\n +2 ^ ^       c\n +3 ^  ^      d\n +4 ^   ^     e\n +5 ^    ^    End of pattern\n 0: abcde\n\\= Expect no match\n  abcdfe\n--->abcdfe\n +0 ^          a\n +1 ^^         b\n +2 ^ ^        c\n +3 ^  ^       d\n +4 ^   ^      e\nNo match\n\n/a*b/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 2\n        a*+\n        Callout 255 2 1\n        b\n        Callout 255 3 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 1\n  ab\n--->ab\n +0 ^      a*\n +2 ^^     b\n +3 ^ ^    End of pattern\n 0: ab\n  aaaab\n--->aaaab\n +0 ^         a*\n +2 ^   ^     b\n +3 ^    ^    End of pattern\n 0: aaaab\n  aaaacb\n--->aaaacb\n +0 ^          a*\n +2 ^   ^      b\n +0  ^         a*\n +2  ^  ^      b\n +0   ^        a*\n +2   ^ ^      b\n +0    ^       a*\n +2    ^^      b\n +0      ^     a*\n +2      ^     b\n +3      ^^    End of pattern\n 0: b\n\n/a*b/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 2\n        a*+\n        Callout 255 2 1\n        b\n        Callout 255 3 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 1\n  ab\n--->ab\n +0 ^      a*\n +2 ^^     b\n +3 ^ ^    End of pattern\n 0: ab\n  aaaab\n--->aaaab\n +0 ^         a*\n +2 ^   ^     b\n +3 ^    ^    End of pattern\n 0: aaaab\n  aaaacb\n--->aaaacb\n +0 ^          a*\n +2 ^   ^      b\n +0  ^         a*\n +2  ^  ^      b\n +0   ^        a*\n +2   ^ ^      b\n +0    ^       a*\n +2    ^^      b\n +0      ^     a*\n +2      ^     b\n +3      ^^    End of pattern\n 0: b\n\n/a+b/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 2\n        a++\n        Callout 255 2 1\n        b\n        Callout 255 3 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n  ab\n--->ab\n +0 ^      a+\n +2 ^^     b\n +3 ^ ^    End of pattern\n 0: ab\n  aaaab\n--->aaaab\n +0 ^         a+\n +2 ^   ^     b\n +3 ^    ^    End of pattern\n 0: aaaab\n\\= Expect no match\n  aaaacb\n--->aaaacb\n +0 ^          a+\n +2 ^   ^      b\n +0  ^         a+\n +2  ^  ^      b\n +0   ^        a+\n +2   ^ ^      b\n +0    ^       a+\n +2    ^^      b\nNo match\n\n/(abc|def)x/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 1\n        a\n        Callout 255 2 1\n        b\n        Callout 255 3 1\n        c\n        Callout 255 4 1\n        Alt\n        Callout 255 5 1\n        d\n        Callout 255 6 1\n        e\n        Callout 255 7 1\n        f\n        Callout 255 8 1\n        Ket\n        Callout 255 9 1\n        x\n        Callout 255 10 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a d \nLast code unit = 'x'\nSubject length lower bound = 4\n  abcx\n--->abcx\n +0 ^        (\n +1 ^        a\n +2 ^^       b\n +3 ^ ^      c\n +4 ^  ^     |\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: abcx\n 1: abc\n  defx\n--->defx\n +0 ^        (\n +1 ^        a\n +5 ^        d\n +6 ^^       e\n +7 ^ ^      f\n +8 ^  ^     )\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: defx\n 1: def\n\\= Expect no match\n  abcdefzx\n--->abcdefzx\n +0 ^            (\n +1 ^            a\n +2 ^^           b\n +3 ^ ^          c\n +4 ^  ^         |\n +9 ^  ^         x\n +5 ^            d\n +0    ^         (\n +1    ^         a\n +5    ^         d\n +6    ^^        e\n +7    ^ ^       f\n +8    ^  ^      )\n +9    ^  ^      x\nNo match\n\n/(abc|def)x/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 1\n        a\n        Callout 255 2 1\n        b\n        Callout 255 3 1\n        c\n        Callout 255 4 1\n        Alt\n        Callout 255 5 1\n        d\n        Callout 255 6 1\n        e\n        Callout 255 7 1\n        f\n        Callout 255 8 1\n        Ket\n        Callout 255 9 1\n        x\n        Callout 255 10 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a d \nLast code unit = 'x'\nSubject length lower bound = 4\n  abcx\n--->abcx\n +0 ^        (\n +1 ^        a\n +2 ^^       b\n +3 ^ ^      c\n +4 ^  ^     |\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: abcx\n 1: abc\n  defx\n--->defx\n +0 ^        (\n +1 ^        a\n +5 ^        d\n +6 ^^       e\n +7 ^ ^      f\n +8 ^  ^     )\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: defx\n 1: def\n\\= Expect no match\n  abcdefzx\n--->abcdefzx\n +0 ^            (\n +1 ^            a\n +2 ^^           b\n +3 ^ ^          c\n +4 ^  ^         |\n +9 ^  ^         x\n +5 ^            d\n +0    ^         (\n +1    ^         a\n +5    ^         d\n +6    ^^        e\n +7    ^ ^       f\n +8    ^  ^      )\n +9    ^  ^      x\nNo match\n\n/(ab|cd){3,4}/I,auto_callout\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a c \nSubject length lower bound = 6\n  ababab\n--->ababab\n +0 ^          (\n +1 ^          a\n +2 ^^         b\n +3 ^ ^        |\n +1 ^ ^        a\n +2 ^  ^       b\n +3 ^   ^      |\n +1 ^   ^      a\n +2 ^    ^     b\n +3 ^     ^    |\n +1 ^     ^    a\n +4 ^     ^    c\n+12 ^     ^    End of pattern\n 0: ababab\n 1: ab\n  abcdabcd\n--->abcdabcd\n +0 ^            (\n +1 ^            a\n +2 ^^           b\n +3 ^ ^          |\n +1 ^ ^          a\n +4 ^ ^          c\n +5 ^  ^         d\n +6 ^   ^        ){3,4}\n +1 ^   ^        a\n +2 ^    ^       b\n +3 ^     ^      |\n +1 ^     ^      a\n +4 ^     ^      c\n +5 ^      ^     d\n +6 ^       ^    ){3,4}\n+12 ^       ^    End of pattern\n 0: abcdabcd\n 1: cd\n  abcdcdcdcdcd\n--->abcdcdcdcdcd\n +0 ^                (\n +1 ^                a\n +2 ^^               b\n +3 ^ ^              |\n +1 ^ ^              a\n +4 ^ ^              c\n +5 ^  ^             d\n +6 ^   ^            ){3,4}\n +1 ^   ^            a\n +4 ^   ^            c\n +5 ^    ^           d\n +6 ^     ^          ){3,4}\n +1 ^     ^          a\n +4 ^     ^          c\n +5 ^      ^         d\n +6 ^       ^        ){3,4}\n+12 ^       ^        End of pattern\n 0: abcdcdcd\n 1: cd\n\n/([ab]{,4}c|xy)/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 4\n        [ab]\n        Callout 255 5 1\n        {\n        Callout 255 6 1\n        ,\n        Callout 255 7 1\n        4\n        Callout 255 8 1\n        }\n        Callout 255 9 1\n        c\n        Callout 255 10 1\n        Alt\n        Callout 255 11 1\n        x\n        Callout 255 12 1\n        y\n        Callout 255 13 1\n        Ket\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a b x \nSubject length lower bound = 2\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n--->Note: that { does NOT introduce a quantifier\n +0         ^                                        (\n +1         ^                                        [ab]\n +5         ^^                                       {\n+11         ^                                        x\n +0                                 ^                (\n +1                                 ^                [ab]\n +5                                 ^^               {\n+11                                 ^                x\n +0                                     ^            (\n +1                                     ^            [ab]\n +5                                     ^^           {\n+11                                     ^            x\nNo match\n\n/([ab]{,4}c|xy)/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 4\n        [ab]\n        Callout 255 5 1\n        {\n        Callout 255 6 1\n        ,\n        Callout 255 7 1\n        4\n        Callout 255 8 1\n        }\n        Callout 255 9 1\n        c\n        Callout 255 10 1\n        Alt\n        Callout 255 11 1\n        x\n        Callout 255 12 1\n        y\n        Callout 255 13 1\n        Ket\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a b x \nSubject length lower bound = 2\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n--->Note: that { does NOT introduce a quantifier\n +0         ^                                        (\n +1         ^                                        [ab]\n +5         ^^                                       {\n+11         ^                                        x\n +0                                 ^                (\n +1                                 ^                [ab]\n +5                                 ^^               {\n+11                                 ^                x\n +0                                     ^            (\n +1                                     ^            [ab]\n +5                                     ^^           {\n+11                                     ^            x\nNo match\n\n/([ab]{1,4}c|xy){4,5}?123/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        Braminzero\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        Callout 255 21 1\n        1\n        Callout 255 22 1\n        2\n        Callout 255 23 1\n        3\n        Callout 255 24 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a b x \nLast code unit = '3'\nSubject length lower bound = 11\n    aacaacaacaacaac123\n--->aacaacaacaacaac123\n +0 ^                      (\n +1 ^                      [ab]{1,4}\n+10 ^ ^                    c\n+11 ^  ^                   |\n +1 ^  ^                   [ab]{1,4}\n+10 ^    ^                 c\n+11 ^     ^                |\n +1 ^     ^                [ab]{1,4}\n+10 ^       ^              c\n+11 ^        ^             |\n +1 ^        ^             [ab]{1,4}\n+10 ^          ^           c\n+11 ^           ^          |\n+21 ^           ^          1\n +1 ^           ^          [ab]{1,4}\n+10 ^             ^        c\n+11 ^              ^       |\n+21 ^              ^       1\n+22 ^               ^      2\n+23 ^                ^     3\n+24 ^                 ^    End of pattern\n 0: aacaacaacaacaac123\n 1: aac\n\n/\\b.*/I\nCapture group count = 0\nMax lookbehind = 1\nMay match empty string\nSubject length lower bound = 0\n  ab cd\\=offset=1\n 0:  cd\n\n/\\b.*/Is\nCapture group count = 0\nMax lookbehind = 1\nMay match empty string\nOptions: dotall\nSubject length lower bound = 0\n  ab cd\\=startoffset=1\n 0:  cd\n\n/(?!.bcd).*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n  Xbcd12345\n 0: bcd12345\n\n/abcde/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 5\n    ab\\=ps\nPartial match: ab\n    abc\\=ps\nPartial match: abc\n    abcd\\=ps\nPartial match: abcd\n    abcde\\=ps\n 0: abcde\n    the quick brown abc\\=ps\nPartial match: abc\n\\= Expect no match\\=ps\n    the quick brown abxyz fox\\=ps\nNo match\n\n\"^(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/(20)?\\d\\d$\"I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '/'\nSubject length lower bound = 6\n    13/05/04\\=ps\n 0: 13/05/04\n 1: 13\n 2: 05\n    13/5/2004\\=ps\n 0: 13/5/2004\n 1: 13\n 2: 5\n 3: 20\n    02/05/09\\=ps\n 0: 02/05/09\n 1: 02\n 2: 05\n    1\\=ps\nPartial match: 1\n    1/2\\=ps\nPartial match: 1/2\n    1/2/0\\=ps\nPartial match: 1/2/0\n    1/2/04\\=ps\n 0: 1/2/04\n 1: 1\n 2: 2\n    0\\=ps\nPartial match: 0\n    02/\\=ps\nPartial match: 02/\n    02/0\\=ps\nPartial match: 02/0\n    02/1\\=ps\nPartial match: 02/1\n\\= Expect no match\\=ps\n    \\=ps\nNo match\n    123\\=ps\nNo match\n    33/4/04\\=ps\nNo match\n    3/13/04\\=ps\nNo match\n    0/1/2003\\=ps\nNo match\n    0/\\=ps\nNo match\n    02/0/\\=ps\nNo match\n    02/13\\=ps\nNo match\n\n/0{0,2}ABC/I\nCapture group count = 0\nStarting code units: 0 A \nLast code unit = 'C'\nSubject length lower bound = 3\n\n/\\d{3,}ABC/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'C'\nSubject length lower bound = 6\n\n/\\d*ABC/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A \nLast code unit = 'C'\nSubject length lower bound = 3\n\n/[abc]+DE/I\nCapture group count = 0\nStarting code units: a b c \nLast code unit = 'E'\nSubject length lower bound = 3\n\n/[abc]?123/I\nCapture group count = 0\nStarting code units: 1 a b c \nLast code unit = '3'\nSubject length lower bound = 3\n    123\\=ps\n 0: 123\n    a\\=ps\nPartial match: a\n    b\\=ps\nPartial match: b\n    c\\=ps\nPartial match: c\n    c12\\=ps\nPartial match: c12\n    c123\\=ps\n 0: c123\n\n/^(?:\\d){3,5}X/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'X'\nSubject length lower bound = 4\n    1\\=ps\nPartial match: 1\n    123\\=ps\nPartial match: 123\n    123X\n 0: 123X\n    1234\\=ps\nPartial match: 1234\n    1234X\n 0: 1234X\n    12345\\=ps\nPartial match: 12345\n    12345X\n 0: 12345X\n\\= Expect no match\n    1X\nNo match\n    123456\\=ps\nNo match\n\n\"<(\\w+)/?>(.)*</(\\1)>\"Igms\nCapture group count = 3\nMax back reference = 1\nOptions: dotall multiline\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 7\n    <!DOCTYPE seite SYSTEM \"http://www.lco.lineas.de/xmlCms.dtd\">\\n<seite>\\n<dokumenteninformation>\\n<seitentitel>Partner der LCO</seitentitel>\\n<sprache>de</sprache>\\n<seitenbeschreibung>Partner der LINEAS Consulting\\nGmbH</seitenbeschreibung>\\n<schluesselworte>LINEAS Consulting GmbH Hamburg\\nPartnerfirmen</schluesselworte>\\n<revisit>30 days</revisit>\\n<robots>index,follow</robots>\\n<menueinformation>\\n<aktiv>ja</aktiv>\\n<menueposition>3</menueposition>\\n<menuetext>Partner</menuetext>\\n</menueinformation>\\n<lastedited>\\n<autor>LCO</autor>\\n<firma>LINEAS Consulting</firma>\\n<datum>15.10.2003</datum>\\n</lastedited>\\n</dokumenteninformation>\\n<inhalt>\\n\\n<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\\nGmbH</absatzueberschrift>\\n\\n<absatz><link ziel=\"http://www.ca.com/\" zielfenster=\"_blank\">\\n<bild name=\"logo_ca.gif\" rahmen=\"no\"/></link> <link\\nziel=\"http://www.ey.com/\" zielfenster=\"_blank\"><bild\\nname=\"logo_euy.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.cisco.de/\" zielfenster=\"_blank\">\\n<bild name=\"logo_cisco.gif\" rahmen=\"ja\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.atelion.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_atelion.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.line-information.de/\"\\nzielfenster=\"_blank\">\\n<bild name=\"logo_line_information.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><bild name=\"logo_aw.gif\" rahmen=\"no\"/></absatz>\\n\\n<absatz><link ziel=\"http://www.incognis.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_incognis.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.addcraft.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_addcraft.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.comendo.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_comendo.gif\" rahmen=\"no\"/></link></absatz>\\n\\n</inhalt>\\n</seite>\\=jitstack=1024\n 0: <seite>\\x0a<dokumenteninformation>\\x0a<seitentitel>Partner der LCO</seitentitel>\\x0a<sprache>de</sprache>\\x0a<seitenbeschreibung>Partner der LINEAS Consulting\\x0aGmbH</seitenbeschreibung>\\x0a<schluesselworte>LINEAS Consulting GmbH Hamburg\\x0aPartnerfirmen</schluesselworte>\\x0a<revisit>30 days</revisit>\\x0a<robots>index,follow</robots>\\x0a<menueinformation>\\x0a<aktiv>ja</aktiv>\\x0a<menueposition>3</menueposition>\\x0a<menuetext>Partner</menuetext>\\x0a</menueinformation>\\x0a<lastedited>\\x0a<autor>LCO</autor>\\x0a<firma>LINEAS Consulting</firma>\\x0a<datum>15.10.2003</datum>\\x0a</lastedited>\\x0a</dokumenteninformation>\\x0a<inhalt>\\x0a\\x0a<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\\x0aGmbH</absatzueberschrift>\\x0a\\x0a<absatz><link ziel=\"http://www.ca.com/\" zielfenster=\"_blank\">\\x0a<bild name=\"logo_ca.gif\" rahmen=\"no\"/></link> <link\\x0aziel=\"http://www.ey.com/\" zielfenster=\"_blank\"><bild\\x0aname=\"logo_euy.gif\" rahmen=\"no\"/></link>\\x0a</absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.cisco.de/\" zielfenster=\"_blank\">\\x0a<bild name=\"logo_cisco.gif\" rahmen=\"ja\"/></link></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.atelion.de/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_atelion.gif\" rahmen=\"no\"/></link>\\x0a</absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.line-information.de/\"\\x0azielfenster=\"_blank\">\\x0a<bild name=\"logo_line_information.gif\" rahmen=\"no\"/></link>\\x0a</absatz>\\x0a\\x0a<absatz><bild name=\"logo_aw.gif\" rahmen=\"no\"/></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.incognis.de/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_incognis.gif\" rahmen=\"no\"/></link></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.addcraft.com/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_addcraft.gif\" rahmen=\"no\"/></link></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.comendo.com/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_comendo.gif\" rahmen=\"no\"/></link></absatz>\\x0a\\x0a</inhalt>\\x0a</seite>\n 1: seite\n 2: \\x0a\n 3: seite\n\n/line\\nbreak/I\nCapture group count = 0\nContains explicit CR or LF match\nFirst code unit = 'l'\nLast code unit = 'k'\nSubject length lower bound = 10\n    this is a line\\nbreak\n 0: line\\x0abreak\n    line one\\nthis is a line\\nbreak in the second line\n 0: line\\x0abreak\n\n/line\\nbreak/I,firstline\nCapture group count = 0\nContains explicit CR or LF match\nOptions: firstline\nFirst code unit = 'l'\nLast code unit = 'k'\nSubject length lower bound = 10\n    this is a line\\nbreak\n 0: line\\x0abreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\nNo match\n\n/line\\nbreak/Im,firstline\nCapture group count = 0\nContains explicit CR or LF match\nOptions: firstline multiline\nFirst code unit = 'l'\nLast code unit = 'k'\nSubject length lower bound = 10\n    this is a line\\nbreak\n 0: line\\x0abreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\nNo match\n\n/(?i)(?-i)AbCd/I\nCapture group count = 0\nFirst code unit = 'A'\nLast code unit = 'd'\nSubject length lower bound = 4\n    AbCd\n 0: AbCd\n\\= Expect no match\n    abcd\nNo match\n\n/a{11111111111111111111}/I\nFailed: error 105 at offset 8: number too big in {} quantifier\n\n/(){64294967295}/I\nFailed: error 105 at offset 9: number too big in {} quantifier\n\n/(){2,4294967295}/I\nFailed: error 105 at offset 11: number too big in {} quantifier\n\n\"(?i:a)(?i:b)(?i:c)(?i:d)(?i:e)(?i:f)(?i:g)(?i:h)(?i:i)(?i:j)(k)(?i:l)A\\1B\"I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a' (caseless)\nLast code unit = 'B'\nSubject length lower bound = 15\n    abcdefghijklAkB\n 0: abcdefghijklAkB\n 1: k\n\n\"(?P<n0>a)(?P<n1>b)(?P<n2>c)(?P<n3>d)(?P<n4>e)(?P<n5>f)(?P<n6>g)(?P<n7>h)(?P<n8>i)(?P<n9>j)(?P<n10>k)(?P<n11>l)A\\11B\"I\nCapture group count = 12\nMax back reference = 11\nNamed capture groups:\n  n0    1\n  n1    2\n  n10  11\n  n11  12\n  n2    3\n  n3    4\n  n4    5\n  n5    6\n  n6    7\n  n7    8\n  n8    9\n  n9   10\nFirst code unit = 'a'\nLast code unit = 'B'\nSubject length lower bound = 15\n    abcdefghijklAkB\n 0: abcdefghijklAkB\n 1: a\n 2: b\n 3: c\n 4: d\n 5: e\n 6: f\n 7: g\n 8: h\n 9: i\n10: j\n11: k\n12: l\n\n\"(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)A\\11B\"I\nCapture group count = 12\nMax back reference = 11\nFirst code unit = 'a'\nLast code unit = 'B'\nSubject length lower bound = 15\n    abcdefghijklAkB\n 0: abcdefghijklAkB\n 1: a\n 2: b\n 3: c\n 4: d\n 5: e\n 6: f\n 7: g\n 8: h\n 9: i\n10: j\n11: k\n12: l\n\n\"(?P<name0>a)(?P<name1>a)(?P<name2>a)(?P<name3>a)(?P<name4>a)(?P<name5>a)(?P<name6>a)(?P<name7>a)(?P<name8>a)(?P<name9>a)(?P<name10>a)(?P<name11>a)(?P<name12>a)(?P<name13>a)(?P<name14>a)(?P<name15>a)(?P<name16>a)(?P<name17>a)(?P<name18>a)(?P<name19>a)(?P<name20>a)(?P<name21>a)(?P<name22>a)(?P<name23>a)(?P<name24>a)(?P<name25>a)(?P<name26>a)(?P<name27>a)(?P<name28>a)(?P<name29>a)(?P<name30>a)(?P<name31>a)(?P<name32>a)(?P<name33>a)(?P<name34>a)(?P<name35>a)(?P<name36>a)(?P<name37>a)(?P<name38>a)(?P<name39>a)(?P<name40>a)(?P<name41>a)(?P<name42>a)(?P<name43>a)(?P<name44>a)(?P<name45>a)(?P<name46>a)(?P<name47>a)(?P<name48>a)(?P<name49>a)(?P<name50>a)(?P<name51>a)(?P<name52>a)(?P<name53>a)(?P<name54>a)(?P<name55>a)(?P<name56>a)(?P<name57>a)(?P<name58>a)(?P<name59>a)(?P<name60>a)(?P<name61>a)(?P<name62>a)(?P<name63>a)(?P<name64>a)(?P<name65>a)(?P<name66>a)(?P<name67>a)(?P<name68>a)(?P<name69>a)(?P<name70>a)(?P<name71>a)(?P<name72>a)(?P<name73>a)(?P<name74>a)(?P<name75>a)(?P<name76>a)(?P<name77>a)(?P<name78>a)(?P<name79>a)(?P<name80>a)(?P<name81>a)(?P<name82>a)(?P<name83>a)(?P<name84>a)(?P<name85>a)(?P<name86>a)(?P<name87>a)(?P<name88>a)(?P<name89>a)(?P<name90>a)(?P<name91>a)(?P<name92>a)(?P<name93>a)(?P<name94>a)(?P<name95>a)(?P<name96>a)(?P<name97>a)(?P<name98>a)(?P<name99>a)(?P<name100>a)\"I\nCapture group count = 101\nNamed capture groups:\n  name0     1\n  name1     2\n  name10   11\n  name100 101\n  name11   12\n  name12   13\n  name13   14\n  name14   15\n  name15   16\n  name16   17\n  name17   18\n  name18   19\n  name19   20\n  name2     3\n  name20   21\n  name21   22\n  name22   23\n  name23   24\n  name24   25\n  name25   26\n  name26   27\n  name27   28\n  name28   29\n  name29   30\n  name3     4\n  name30   31\n  name31   32\n  name32   33\n  name33   34\n  name34   35\n  name35   36\n  name36   37\n  name37   38\n  name38   39\n  name39   40\n  name4     5\n  name40   41\n  name41   42\n  name42   43\n  name43   44\n  name44   45\n  name45   46\n  name46   47\n  name47   48\n  name48   49\n  name49   50\n  name5     6\n  name50   51\n  name51   52\n  name52   53\n  name53   54\n  name54   55\n  name55   56\n  name56   57\n  name57   58\n  name58   59\n  name59   60\n  name6     7\n  name60   61\n  name61   62\n  name62   63\n  name63   64\n  name64   65\n  name65   66\n  name66   67\n  name67   68\n  name68   69\n  name69   70\n  name7     8\n  name70   71\n  name71   72\n  name72   73\n  name73   74\n  name74   75\n  name75   76\n  name76   77\n  name77   78\n  name78   79\n  name79   80\n  name8     9\n  name80   81\n  name81   82\n  name82   83\n  name83   84\n  name84   85\n  name85   86\n  name86   87\n  name87   88\n  name88   89\n  name89   90\n  name9    10\n  name90   91\n  name91   92\n  name92   93\n  name93   94\n  name94   95\n  name95   96\n  name96   97\n  name97   98\n  name98   99\n  name99  100\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 101\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nMatched, but too many substrings\n 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n 1: a\n 2: a\n 3: a\n 4: a\n 5: a\n 6: a\n 7: a\n 8: a\n 9: a\n10: a\n11: a\n12: a\n13: a\n14: a\n\n\"(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)\"I\nCapture group count = 101\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 101\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nMatched, but too many substrings\n 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n 1: a\n 2: a\n 3: a\n 4: a\n 5: a\n 6: a\n 7: a\n 8: a\n 9: a\n10: a\n11: a\n12: a\n13: a\n14: a\n\n/[^()]*(?:\\((?R)\\)[^()]*)*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: (this(and)that)\n    (this(and)that)stuff\n 0: (this(and)that)stuff\n\n/[^()]*(?:\\((?>(?R))\\)[^()]*)*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: (this(and)that)\n\n/[^()]*(?:\\((?R)\\))*[^()]*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: (this(and)that)\n\n/(?:\\((?R)\\))*[^()]*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: \n    ((this))\n 0: ((this))\n\n/(?:\\((?R)\\))|[^()]*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: \n    (this)\n 0: (this)\n    ((this))\n 0: ((this))\n\n/\\x{0000ff}/I\nCapture group count = 0\nFirst code unit = \\xff\nSubject length lower bound = 1\n\n/^((?P<A>a1)|(?P<A>a2)b)/I\nFailed: error 143 at offset 18: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  A   2\n  A   3\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    a1b\\=copy=A\n 0: a1\n 1: a1\n 2: a1\n  C a1 (2) A (non-unique)\n    a2b\\=copy=A\n 0: a2b\n 1: a2b\n 2: <unset>\n 3: a2\n  C a2 (2) A (non-unique)\n    a1b\\=copy=Z,copy=A\n 0: a1\n 1: a1\n 2: a1\nNumber not found for group 'Z'\nCopy substring 'Z' failed (-49): unknown substring\n  C a1 (2) A (non-unique)\n\n/(?|(?<a>)(?<b>)(?<a>)|(?<a>)(?<b>)(?<a>))/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  a   1\n  a   3\n  b   2\nMay match empty string\nOptions: dupnames\nSubject length lower bound = 0\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    ab\\=copy=A\n 0: ab\n 1: a\n 2: b\n  C a (1) A (non-unique)\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    ab\\=copy=A\n 0: ab\n 1: a\n 2: b\n  C a (1) A (non-unique)\n    cd\\=copy=A\n 0: cd\nCopy substring 'A' failed (-55): requested value is not set\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\nCapture group count = 4\nNamed capture groups:\n  A   1\n  A   2\n  A   3\n  A   4\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    cdefgh\\=copy=A\n 0: cdefgh\n 1: <unset>\n 2: <unset>\n 3: ef\n 4: gh\n  C ef (2) A (non-unique)\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  A   2\n  A   3\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    a1b\\=get=A\n 0: a1\n 1: a1\n 2: a1\n  G a1 (2) A (non-unique)\n    a2b\\=get=A\n 0: a2b\n 1: a2b\n 2: <unset>\n 3: a2\n  G a2 (2) A (non-unique)\n    a1b\\=get=Z,get=A\n 0: a1\n 1: a1\n 2: a1\nNumber not found for group 'Z'\nGet substring 'Z' failed (-49): unknown substring\n  G a1 (2) A (non-unique)\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    ab\\=get=A\n 0: ab\n 1: a\n 2: b\n  G a (1) A (non-unique)\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    ab\\=get=A\n 0: ab\n 1: a\n 2: b\n  G a (1) A (non-unique)\n    cd\\=get=A\n 0: cd\nGet substring 'A' failed (-55): requested value is not set\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\nCapture group count = 4\nNamed capture groups:\n  A   1\n  A   2\n  A   3\n  A   4\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    cdefgh\\=get=A\n 0: cdefgh\n 1: <unset>\n 2: <unset>\n 3: ef\n 4: gh\n  G ef (2) A (non-unique)\n\n/(?J)^((?P<A>a1)|(?P<A>a2)b)/I\nCapture group count = 3\nNamed capture groups:\n  A   2\n  A   3\nCompile options: <none>\nOverall options: anchored\nDuplicate name status changes\nFirst code unit = 'a'\nSubject length lower bound = 2\n    a1b\\=copy=A\n 0: a1\n 1: a1\n 2: a1\n  C a1 (2) A (non-unique)\n    a2b\\=copy=A\n 0: a2b\n 1: a2b\n 2: <unset>\n 3: a2\n  C a2 (2) A (non-unique)\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<A>d)/I\nFailed: error 143 at offset 38: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n# In this next test, J is not set at the outer level; consequently it isn't set\n# in the pattern's options; consequently pcre2_substring_get_byname() produces\n# a random value.\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<C>d)/I\nCapture group count = 4\nNamed capture groups:\n  A   1\n  B   2\n  B   3\n  C   4\nCompile options: <none>\nOverall options: anchored\nDuplicate name status changes\nFirst code unit = 'a'\nSubject length lower bound = 6\n    a bc d\\=copy=A,copy=B,copy=C\n 0: a bc d\n 1: a\n 2: b\n 3: c\n 4: d\n  C a (1) A (group 1)\n  C b (1) B (non-unique)\n  C d (1) C (group 4)\n\n/^(?P<A>a)?(?(A)a|b)/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  A   1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n    aabc\n 0: aa\n 1: a\n    bc\n 0: b\n\\= Expect no match\n    abc\nNo match\n\n/(?:(?(ZZ)a|b)(?P<ZZ>X))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  ZZ   1\nLast code unit = 'X'\nSubject length lower bound = 2\n    bXaX\n 0: bXaX\n 1: X\n\n/(?:(?(2y)a|b)(X))+/I\nFailed: error 124 at offset 7: missing closing parenthesis for condition\n\n/(?:(?(ZA)a|b)(?P<ZZ>X))+/I\nFailed: error 115 at offset 6: reference to non-existent subpattern\n\n/(?:(?(ZZ)a|b)(?(ZZ)a|b)(?P<ZZ>X))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  ZZ   1\nLast code unit = 'X'\nSubject length lower bound = 3\n    bbXaaX\n 0: bbXaaX\n 1: X\n\n/(?:(?(ZZ)a|\\(b\\))\\\\(?P<ZZ>X))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  ZZ   1\nLast code unit = 'X'\nSubject length lower bound = 3\n    (b)\\\\Xa\\\\X\n 0: (b)\\Xa\\X\n 1: X\n\n/(?P<ABC/I\nFailed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)\n\n/(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  A   1\nSubject length lower bound = 2\n    bXXaYYaY\n 0: bXXaYYaY\n 1: Y\n    bXYaXXaX\n 0: bX\n 1: X\n\n/()()()()()()()()()(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\nCapture group count = 10\nMax back reference = 10\nNamed capture groups:\n  A  10\nSubject length lower bound = 2\n    bXXaYYaY\n 0: bXXaYYaY\n 1: \n 2: \n 3: \n 4: \n 5: \n 6: \n 7: \n 8: \n 9: \n10: Y\n\n/\\s*,\\s*/I\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 , \nLast code unit = ','\nSubject length lower bound = 1\n    \\x0b,\\x0b\n 0: \\x0b,\\x0b\n    \\x0c,\\x0d\n 0: \\x0c,\\x0d\n\n/^abc/Im,newline=lf\nCapture group count = 0\nOptions: multiline\nForced newline is LF\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    xyz\\nabc\n 0: abc\n    xyz\\r\\nabc\n 0: abc\n\\= Expect no match\n    xyz\\rabc\nNo match\n    xyzabc\\r\nNo match\n    xyzabc\\rpqr\nNo match\n    xyzabc\\r\\n\nNo match\n    xyzabc\\r\\npqr\nNo match\n\n/^abc/Im,newline=crlf\nCapture group count = 0\nOptions: multiline\nForced newline is CRLF\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    xyz\\r\\nabclf>\n 0: abc\n\\= Expect no match\n    xyz\\nabclf\nNo match\n    xyz\\rabclf\nNo match\n\n/^abc/Im,newline=cr\nCapture group count = 0\nOptions: multiline\nForced newline is CR\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    xyz\\rabc\n 0: abc\n\\= Expect no match\n    xyz\\nabc\nNo match\n    xyz\\r\\nabc\nNo match\n\n/^abc/Im,newline=bad\n** Invalid value in 'newline=bad'\n\n/.*/I,newline=lf\nCapture group count = 0\nMay match empty string\nForced newline is LF\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n    abc\\ndef\n 0: abc\n    abc\\rdef\n 0: abc\\x0ddef\n    abc\\r\\ndef\n 0: abc\\x0d\n\n/.*/I,newline=cr\nCapture group count = 0\nMay match empty string\nForced newline is CR\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n    abc\\ndef\n 0: abc\\x0adef\n    abc\\rdef\n 0: abc\n    abc\\r\\ndef\n 0: abc\n\n/.*/I,newline=crlf\nCapture group count = 0\nMay match empty string\nForced newline is CRLF\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n    abc\\ndef\n 0: abc\\x0adef\n    abc\\rdef\n 0: abc\\x0ddef\n    abc\\r\\ndef\n 0: abc\n\n/\\w+(.)(.)?def/Is\nCapture group count = 2\nOptions: dotall\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nLast code unit = 'f'\nSubject length lower bound = 5\n    abc\\ndef\n 0: abc\\x0adef\n 1: \\x0a\n    abc\\rdef\n 0: abc\\x0ddef\n 1: \\x0d\n    abc\\r\\ndef\n 0: abc\\x0d\\x0adef\n 1: \\x0d\n 2: \\x0a\n\n/(?P<B>25[0-5]|2[0-4]\\d|[01]?\\d?\\d)(?:\\.(?P>B)){3}/I\nCapture group count = 1\nNamed capture groups:\n  B   1\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '.'\nSubject length lower bound = 7\n\n/()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n (.(.))/Ix\nCapture group count = 102\nOptions: extended\nSubject length lower bound = 2\n    XY\\=ovector=133\n 0: XY\n 1: \n 2: \n 3: \n 4: \n 5: \n 6: \n 7: \n 8: \n 9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n18: \n19: \n20: \n21: \n22: \n23: \n24: \n25: \n26: \n27: \n28: \n29: \n30: \n31: \n32: \n33: \n34: \n35: \n36: \n37: \n38: \n39: \n40: \n41: \n42: \n43: \n44: \n45: \n46: \n47: \n48: \n49: \n50: \n51: \n52: \n53: \n54: \n55: \n56: \n57: \n58: \n59: \n60: \n61: \n62: \n63: \n64: \n65: \n66: \n67: \n68: \n69: \n70: \n71: \n72: \n73: \n74: \n75: \n76: \n77: \n78: \n79: \n80: \n81: \n82: \n83: \n84: \n85: \n86: \n87: \n88: \n89: \n90: \n91: \n92: \n93: \n94: \n95: \n96: \n97: \n98: \n99: \n100: \n101: XY\n102: Y\n\n/(a*b|(?i:c*(?-i)d))/I\nCapture group count = 1\nStarting code units: C a b c d \nSubject length lower bound = 1\n\n/()[ab]xyz/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(|)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(|c)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(|c?)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(d?|c?)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c d \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(d?|c)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c d \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/^a*b\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a*+\n        b\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a*+b\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a*+\n        b\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a*?b\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a*+\n        b\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a+A\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a++\n        A\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nLast code unit = 'A'\nSubject length lower bound = 3\n    aaaA5\n 0: aaaA5\n\\= Expect no match\n    aaaa5\nNo match\n\n/^a*A\\d/IBi\n------------------------------------------------------------------\n        Bra\n        ^\n     /i a*\n     /i A\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: caseless\nOverall options: anchored caseless\nStarting code units: A a \nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aaaA5\n 0: aaaA5\n    aaaa5\n 0: aaaa5\n    a5 \n 0: a5\n\n/(a*|b*)[cd]/I\nCapture group count = 1\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a+|b*)[cd]/I\nCapture group count = 1\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a*|b+)[cd]/I\nCapture group count = 1\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a+|b+)[cd]/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n (((\n a\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n )))\n/Ix\nCapture group count = 203\nOptions: extended\nFirst code unit = 'a'\nSubject length lower bound = 1\n  large nest\nMatched, but too many substrings\n 0: a\n 1: a\n 2: a\n 3: a\n 4: a\n 5: a\n 6: a\n 7: a\n 8: a\n 9: a\n10: a\n11: a\n12: a\n13: a\n14: a\n\n/a*\\d/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\D/B\n------------------------------------------------------------------\n        Bra\n        a*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/0*\\d/B\n------------------------------------------------------------------\n        Bra\n        0*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/0*\\D/B\n------------------------------------------------------------------\n        Bra\n        0*+\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\s/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\S/B\n------------------------------------------------------------------\n        Bra\n        a*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/ *\\s/B\n------------------------------------------------------------------\n        Bra\n         *\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/ *\\S/B\n------------------------------------------------------------------\n        Bra\n         *+\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\w/B\n------------------------------------------------------------------\n        Bra\n        a*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\W/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/=*\\w/B\n------------------------------------------------------------------\n        Bra\n        =*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/=*\\W/B\n------------------------------------------------------------------\n        Bra\n        =*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*a/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*2/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*a/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*2/B\n------------------------------------------------------------------\n        Bra\n        \\D*+\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\D*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*a/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*2/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*a/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*2/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\S*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*a/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*2/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\w*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\w*+\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*a/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*2/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+a/B\n------------------------------------------------------------------\n        Bra\n        [^a]++\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+a/Bi\n------------------------------------------------------------------\n        Bra\n     /i [^a]++\n     /i a\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+A/Bi\n------------------------------------------------------------------\n        Bra\n     /i [^a]++\n     /i A\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+b/B\n------------------------------------------------------------------\n        Bra\n        [^a]+\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+\\d/B\n------------------------------------------------------------------\n        Bra\n        [^a]+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*[^a]/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        [^a]\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?P<abc>x)(?P<xyz>y)/I\nCapture group count = 2\nNamed capture groups:\n  abc   1\n  xyz   2\nFirst code unit = 'x'\nLast code unit = 'y'\nSubject length lower bound = 2\n    xy\\=copy=abc,copy=xyz\n 0: xy\n 1: x\n 2: y\n  C x (1) abc (group 1)\n  C y (1) xyz (group 2)\n\n/(?<abc>x)(?'xyz'y)/I\nCapture group count = 2\nNamed capture groups:\n  abc   1\n  xyz   2\nFirst code unit = 'x'\nLast code unit = 'y'\nSubject length lower bound = 2\n    xy\\=copy=abc,copy=xyz\n 0: xy\n 1: x\n 2: y\n  C x (1) abc (group 1)\n  C y (1) xyz (group 2)\n\n/(?<abc'x)(?'xyz'y)/I\nFailed: error 142 at offset 6: syntax error in subpattern name (missing terminator?)\n\n/(?<abc>x)(?'xyz>y)/I\nFailed: error 142 at offset 15: syntax error in subpattern name (missing terminator?)\n\n/(?P'abc'x)(?P<xyz>y)/I\nFailed: error 141 at offset 3: unrecognized character after (?P\n\n/^(?:(?(ZZ)a|b)(?<ZZ>X))+/\n    bXaX\n 0: bXaX\n 1: X\n    bXbX\n 0: bX\n 1: X\n\\= Expect no match\n    aXaX\nNo match\n    aXbX\nNo match\n\n/^(?P>abc)(?<abcd>xxx)/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/^(?P>abc)(?<abc>x|y)/\n    xx\n 0: xx\n 1: x\n    xy\n 0: xy\n 1: y\n    yy\n 0: yy\n 1: y\n    yx\n 0: yx\n 1: x\n\n/^(?P>abc)(?P<abc>x|y)/\n    xx\n 0: xx\n 1: x\n    xy\n 0: xy\n 1: y\n    yy\n 0: yy\n 1: y\n    yx\n 0: yx\n 1: x\n\n/^((?(abc)a|b)(?<abc>x|y))+/\n    bxay\n 0: bxay\n 1: ay\n 2: y\n    bxby\n 0: bx\n 1: bx\n 2: x\n\\= Expect no match\n    axby\nNo match\n\n/^(((?P=abc)|X)(?<abc>x|y))+/\n    XxXxxx\n 0: XxXxxx\n 1: xx\n 2: x\n 3: x\n    XxXyyx\n 0: XxXyyx\n 1: yx\n 2: y\n 3: x\n    XxXyxx\n 0: XxXy\n 1: Xy\n 2: X\n 3: y\n\\= Expect no match\n    x\nNo match\n\n/^(?1)(abc)/\n    abcabc\n 0: abcabc\n 1: abc\n\n/^(?:(?:\\1|X)(a|b))+/\n    Xaaa\n 0: Xaaa\n 1: a\n    Xaba\n 0: Xa\n 1: a\n\n/^[\\E\\Qa\\E-\\Qz\\E]+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        [a-z]++\n        Ket\n        End\n------------------------------------------------------------------\n\n/^[a\\Q]bc\\E]/B\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\]a-c]\n        Ket\n        End\n------------------------------------------------------------------\n\n/^[a-\\Q\\E]/B\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\-a]\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?P>abc)[()](?<abc>)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        [()]\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^((?(abc)y)[()](?P<abc>x))+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        Cond\n      2 Cond ref\n        y\n        Ket\n        [()]\n        CBra 2\n        x\n        Ket\n        KetRmax\n        Ket\n        End\n------------------------------------------------------------------\n    (xy)x\n 0: (xy)x\n 1: y)x\n 2: x\n\n/^(?P>abc)\\Q()\\E(?<abc>)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        ()\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?P>abc)[a\\Q(]\\E(](?<abc>)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        [(\\]a]\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?P>abc) # this is (a comment)\n  (?<abc>)/Bx\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^\\W*(?:(?<one>(?<two>.)\\W*(?&one)\\W*\\k<two>|)|(?<three>(?<four>.)\\W*(?&three)\\W*\\k'four'|\\W*.\\W*))\\W*$/Ii\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  four    4\n  one     1\n  three   3\n  two     2\nMay match empty string\nCompile options: caseless\nOverall options: anchored caseless\nSubject length lower bound = 0\n    1221\n 0: 1221\n 1: 1221\n 2: 1\n    Satan, oscillate my metallic sonatas!\n 0: Satan, oscillate my metallic sonatas!\n 1: <unset>\n 2: <unset>\n 3: Satan, oscillate my metallic sonatas\n 4: S\n    A man, a plan, a canal: Panama!\n 0: A man, a plan, a canal: Panama!\n 1: <unset>\n 2: <unset>\n 3: A man, a plan, a canal: Panama\n 4: A\n    Able was I ere I saw Elba.\n 0: Able was I ere I saw Elba.\n 1: <unset>\n 2: <unset>\n 3: Able was I ere I saw Elba\n 4: A\n\\= Expect no match\n    The quick brown fox\nNo match\n\n/(?=(\\w+))\\1:/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nLast code unit = ':'\nSubject length lower bound = 2\n    abcd:\n 0: abcd:\n 1: abcd\n\n/(?=(?'abc'\\w+))\\k<abc>:/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  abc   1\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nLast code unit = ':'\nSubject length lower bound = 2\n    abcd:\n 0: abcd:\n 1: abcd\n\n/(?'abc'a|b)(?<abc>d|e)\\k<abc>{2}/dupnames\n    adaa\n 0: adaa\n 1: a\n 2: d\n\\= Expect no match\n    addd\nNo match\n    adbb\nNo match\n\n/(?'abc'a|b)(?<abc>d|e)(?&abc){2}/dupnames\n    bdaa\n 0: bdaa\n 1: b\n 2: d\n    bdab\n 0: bdab\n 1: b\n 2: d\n\\= Expect no match\n    bddd\nNo match\n\n/(?(<bc))/\nFailed: error 142 at offset 6: syntax error in subpattern name (missing terminator?)\n\n/(?(''))/\nFailed: error 162 at offset 4: subpattern name expected\n\n/(?('R')stuff)/\nFailed: error 115 at offset 4: reference to non-existent subpattern\n\n/((abc (?(R) (?(R1)1) (?(R2)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n 0: abcabc1Xabc2XabcX\n 1: abcabc1Xabc2XabcX\n 2: abcabc1Xabc2XabcX\n\n/(?<A> (?'B' abc (?(R) (?(R&A)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n 0: abcabc1Xabc2XabcX\n 1: abcabc1Xabc2XabcX\n 2: abcabc1Xabc2XabcX\n\n/(?<A> (?'B' abc (?(R) (?(R&C)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\nFailed: error 115 at offset 27: reference to non-existent subpattern\n\n/^(?(DEFINE) abc | xyz ) /x\nFailed: error 154 at offset 4: DEFINE subpattern contains more than one branch\n\n/(?(DEFINE) abc) xyz/Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = 'x'\nLast code unit = 'z'\nSubject length lower bound = 3\n\n/(a|)*\\d/\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\\=ovector=0\n 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\n 1: \n\\= Expect no match\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\=ovector=0\nNo match\n\n/^a.b/newline=lf\n    a\\rb\n 0: a\\x0db\n\\= Expect no match\n    a\\nb\nNo match\n\n/^a.b/newline=cr\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\rb\nNo match\n\n/^a.b/newline=anycrlf\n    a\\x85b\n 0: a\\x85b\n\\= Expect no match\n    a\\rb\nNo match\n\n/^a.b/newline=any\n\\= Expect no match\n    a\\nb\nNo match\n    a\\rb\nNo match\n    a\\x85b\nNo match\n\n/^abc./gmx,newline=any\n    abc1 \\x0aabc2 \\x0babc3xx \\x0cabc4 \\x0dabc5xx \\x0d\\x0aabc6 \\x85abc7 JUNK\n 0: abc1\n 0: abc2\n 0: abc3\n 0: abc4\n 0: abc5\n 0: abc6\n 0: abc7\n\n/abc.$/gmx,newline=any\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc7 abc9\n 0: abc1\n 0: abc2\n 0: abc3\n 0: abc4\n 0: abc5\n 0: abc6\n 0: abc9\n\n/^a\\Rb/bsr=unicode\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x0bb\n 0: a\\x0bb\n    a\\x0cb\n 0: a\\x0cb\n    a\\x85b\n 0: a\\x85b\n\\= Expect no match\n    a\\n\\rb\nNo match\n\n/^a\\R*b/bsr=unicode\n    ab\n 0: ab\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x0bb\n 0: a\\x0bb\n    a\\x0cb\n 0: a\\x0cb\n    a\\x85b\n 0: a\\x85b\n    a\\n\\rb\n 0: a\\x0a\\x0db\n    a\\n\\r\\x85\\x0cb\n 0: a\\x0a\\x0d\\x85\\x0cb\n\n/^a\\R+b/bsr=unicode\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x0bb\n 0: a\\x0bb\n    a\\x0cb\n 0: a\\x0cb\n    a\\x85b\n 0: a\\x85b\n    a\\n\\rb\n 0: a\\x0a\\x0db\n    a\\n\\r\\x85\\x0cb\n 0: a\\x0a\\x0d\\x85\\x0cb\n\\= Expect no match\n    ab\nNo match\n\n/^a\\R{1,3}b/bsr=unicode\n    a\\nb\n 0: a\\x0ab\n    a\\n\\rb\n 0: a\\x0a\\x0db\n    a\\n\\r\\x85b\n 0: a\\x0a\\x0d\\x85b\n    a\\r\\n\\r\\nb\n 0: a\\x0d\\x0a\\x0d\\x0ab\n    a\\r\\n\\r\\n\\r\\nb\n 0: a\\x0d\\x0a\\x0d\\x0a\\x0d\\x0ab\n    a\\n\\r\\n\\rb\n 0: a\\x0a\\x0d\\x0a\\x0db\n    a\\n\\n\\r\\nb\n 0: a\\x0a\\x0a\\x0d\\x0ab\n\\= Expect no match\n    a\\n\\n\\n\\rb\nNo match\n    a\\r\nNo match\n\n/(?&abc)X(?<abc>P)/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nLast code unit = 'P'\nSubject length lower bound = 3\n    abcPXP123\n 0: PXP\n 1: P\n\n/(?1)X(?<abc>P)/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nLast code unit = 'P'\nSubject length lower bound = 3\n    abcPXP123\n 0: PXP\n 1: P\n\n/(?:a(?&abc)b)*(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n    123axbaxbaxb456\n 0: x\n 1: x\n\n/(?:a(?&abc)b){1,5}(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n\n/(?:a(?&abc)b){2,5}(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n\n/(?:a(?&abc)b){2,}(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n\n/(abc)(?i:(?1))/\n    defabcabcxyz\n 0: abcabc\n 1: abc\n\\= Expect no match\n    DEFabcABCXYZ\nNo match\n\n/(abc)(?:(?i)(?1))/\n    defabcabcxyz\n 0: abcabc\n 1: abc\n\\= Expect no match\n    DEFabcABCXYZ\nNo match\n\n/^(a)\\g-2/\nFailed: error 115 at offset 8: reference to non-existent subpattern\n\n/^(a)\\g/\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/^(a)\\g{0}/\nFailed: error 115 at offset 9: reference to non-existent subpattern\n\n/^(a)\\g{3/\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/^(a)\\g{aa}/\nFailed: error 115 at offset 7: reference to non-existent subpattern\n\n/^a.b/newline=lf\n    a\\rb\n 0: a\\x0db\n\\= Expect no match\n    a\\nb\nNo match\n\n/.+foo/\n    afoo\n 0: afoo\n\\= Expect no match\n    \\r\\nfoo\nNo match\n    \\nfoo\nNo match\n\n/.+foo/newline=crlf\n    afoo\n 0: afoo\n    \\nfoo\n 0: \\x0afoo\n\\= Expect no match\n    \\r\\nfoo\nNo match\n\n/.+foo/newline=any\n    afoo\n 0: afoo\n\\= Expect no match\n    \\nfoo\nNo match\n    \\r\\nfoo\nNo match\n\n/.+foo/s\n    afoo\n 0: afoo\n    \\r\\nfoo\n 0: \\x0d\\x0afoo\n    \\nfoo\n 0: \\x0afoo\n\n/^$/gm,newline=any\n    abc\\r\\rxyz\n 0: \n    abc\\n\\rxyz\n 0: \n\\= Expect no match\n    abc\\r\\nxyz\nNo match\n\n/(?m)^$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n 0: \n 0+ \\x0d\\x0a\n\n/(?m)^$|^\\r\\n/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n 0: \n 0+ \\x0d\\x0a\n 0: \\x0d\\x0a\n 0+ \n\n/(?m)$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n 0: \n 0+ \\x0d\\x0a\\x0d\\x0a\n 0: \n 0+ \\x0d\\x0a\n 0: \n 0+ \n\n/abc.$/gmx,newline=anycrlf\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc9\n 0: abc1\n 0: abc4\n 0: abc5\n 0: abc9\n\n/^X/m\n    XABC\n 0: X\n\\= Expect no match\n    XABC\\=notbol\nNo match\n\n/(ab|c)(?-1)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        ab\n        Alt\n        c\n        Ket\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n    abc\n 0: abc\n 1: ab\n\n/xy(?+1)(abc)/B\n------------------------------------------------------------------\n        Bra\n        xy\n        Recurse\n        CBra 1\n        abc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    xyabcabc\n 0: xyabcabc\n 1: abc\n\\= Expect no match\n    xyabc\nNo match\n\n/x(?-0)y/\nFailed: error 126 at offset 5: a relative value of zero is not allowed\n\n/x(?-1)y/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/x(?+0)y/\nFailed: error 126 at offset 5: a relative value of zero is not allowed\n\n/x(?+1)y/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/^(abc)?(?(-1)X|Y)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Brazero\n        CBra 1\n        abc\n        Ket\n        Cond\n      1 Cond ref\n        X\n        Alt\n        Y\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    abcX\n 0: abcX\n 1: abc\n    Y\n 0: Y\n\\= Expect no match\n    abcY\nNo match\n\n/^((?(+1)X|Y)(abc))+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        Cond\n      2 Cond ref\n        X\n        Alt\n        Y\n        Ket\n        CBra 2\n        abc\n        Ket\n        KetRmax\n        Ket\n        End\n------------------------------------------------------------------\n    YabcXabc\n 0: YabcXabc\n 1: Xabc\n 2: abc\n    YabcXabcXabc\n 0: YabcXabcXabc\n 1: Xabc\n 2: abc\n\\= Expect no match\n    XabcXabc\nNo match\n\n/(?(-1)a)/B\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/((?(-1)a))/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Cond\n      1 Cond ref\n        a\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/((?(-2)a))/B\nFailed: error 115 at offset 6: reference to non-existent subpattern\n\n/^(?(+1)X|Y)(.)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Cond\n      1 Cond ref\n        X\n        Alt\n        Y\n        Ket\n        CBra 1\n        Any\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    Y!\n 0: Y!\n 1: !\n\n/(?<A>tom|bon)-\\k{A}/\n    tom-tom\n 0: tom-tom\n 1: tom\n    bon-bon\n 0: bon-bon\n 1: bon\n\\= Expect no match\n    tom-bon\nNo match\n\n/\\g{A/\nFailed: error 142 at offset 4: syntax error in subpattern name (missing terminator?)\n\n/(?|(abc)|(xyz))/B\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        abc\n        Ket\n        Alt\n        CBra 1\n        xyz\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n   >abc<\n 0: abc\n 1: abc\n   >xyz<\n 0: xyz\n 1: xyz\n\n/(x)(?|(abc)|(xyz))(x)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        x\n        Ket\n        Bra\n        CBra 2\n        abc\n        Ket\n        Alt\n        CBra 2\n        xyz\n        Ket\n        Ket\n        CBra 3\n        x\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    xabcx\n 0: xabcx\n 1: x\n 2: abc\n 3: x\n    xxyzx\n 0: xxyzx\n 1: x\n 2: xyz\n 3: x\n\n/(x)(?|(abc)(pqr)|(xyz))(x)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        x\n        Ket\n        Bra\n        CBra 2\n        abc\n        Ket\n        CBra 3\n        pqr\n        Ket\n        Alt\n        CBra 2\n        xyz\n        Ket\n        Ket\n        CBra 4\n        x\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    xabcpqrx\n 0: xabcpqrx\n 1: x\n 2: abc\n 3: pqr\n 4: x\n    xxyzx\n 0: xxyzx\n 1: x\n 2: xyz\n 3: <unset>\n 4: x\n\n/\\H++X/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n        X\n        Ket\n        End\n------------------------------------------------------------------\n\\= Expect no match\n    XXXX\nNo match\n\n/\\H+\\hY/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n        \\h\n        Y\n        Ket\n        End\n------------------------------------------------------------------\n    XXXX Y\n 0: XXXX Y\n\n/\\H+ Y/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n         Y\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\h+A/B\n------------------------------------------------------------------\n        Bra\n        \\h++\n        A\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\v*B/B\n------------------------------------------------------------------\n        Bra\n        \\v*+\n        B\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\V+\\x0a/B\n------------------------------------------------------------------\n        Bra\n        \\V++\n        \\x0a\n        Ket\n        End\n------------------------------------------------------------------\n\n/A+\\h/B\n------------------------------------------------------------------\n        Bra\n        A++\n        \\h\n        Ket\n        End\n------------------------------------------------------------------\n\n/ *\\H/B\n------------------------------------------------------------------\n        Bra\n         *+\n        \\H\n        Ket\n        End\n------------------------------------------------------------------\n\n/A*\\v/B\n------------------------------------------------------------------\n        Bra\n        A*+\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\x0b*\\V/B\n------------------------------------------------------------------\n        Bra\n        \\x0b*+\n        \\V\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d+\\h/B\n------------------------------------------------------------------\n        Bra\n        \\d++\n        \\h\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\v/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/S+\\h\\S+\\v/B\n------------------------------------------------------------------\n        Bra\n        S++\n        \\h\n        \\S++\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w{3,}\\h\\w+\\v/B\n------------------------------------------------------------------\n        Bra\n        \\w{3}\n        \\w*+\n        \\h\n        \\w++\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\h+\\d\\h+\\w\\h+\\S\\h+\\H/B\n------------------------------------------------------------------\n        Bra\n        \\h++\n        \\d\n        \\h++\n        \\w\n        \\h++\n        \\S\n        \\h++\n        \\H\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\v+\\d\\v+\\w\\v+\\S\\v+\\V/B\n------------------------------------------------------------------\n        Bra\n        \\v++\n        \\d\n        \\v++\n        \\w\n        \\v++\n        \\S\n        \\v++\n        \\V\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\H+\\h\\H+\\d/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n        \\h\n        \\H+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\V+\\v\\V+\\w/B\n------------------------------------------------------------------\n        Bra\n        \\V++\n        \\v\n        \\V+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\( (?: [^()]* | (?R) )* \\)/x\n(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\\=jitstack=1024\n 0: (0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\n\n/[\\E]AAA/\nFailed: error 106 at offset 7: missing terminating ] for character class\n\n/[\\Q\\E]AAA/\nFailed: error 106 at offset 9: missing terminating ] for character class\n\n/[^\\E]AAA/\nFailed: error 106 at offset 8: missing terminating ] for character class\n\n/[^\\Q\\E]AAA/\nFailed: error 106 at offset 10: missing terminating ] for character class\n\n/[\\E^]AAA/\nFailed: error 106 at offset 8: missing terminating ] for character class\n\n/[\\Q\\E^]AAA/\nFailed: error 106 at offset 10: missing terminating ] for character class\n\n/A(*PRUNE)B(*SKIP)C(*THEN)D(*COMMIT)E(*F)F(*FAIL)G(?!)H(*ACCEPT)I/B\n------------------------------------------------------------------\n        Bra\n        A\n        *PRUNE\n        B\n        *SKIP\n        C\n        *THEN\n        D\n        *COMMIT\n        E\n        *FAIL\n        F\n        *FAIL\n        G\n        *FAIL\n        H\n        *ACCEPT\n        I\n        Ket\n        End\n------------------------------------------------------------------\n\n/^a+(*FAIL)/auto_callout\n\\= Expect no match\n    aaaaaa\n--->aaaaaa\n +0 ^          ^\n +1 ^          a+\n +3 ^     ^    (*FAIL)\n +3 ^    ^     (*FAIL)\n +3 ^   ^      (*FAIL)\n +3 ^  ^       (*FAIL)\n +3 ^ ^        (*FAIL)\n +3 ^^         (*FAIL)\nNo match\n\n/a+b?c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       c+\n +6 ^      ^    (*FAIL)\n +6 ^     ^     (*FAIL)\n +6 ^    ^      (*FAIL)\n +0  ^          a+\n +2  ^ ^        b?\n +4  ^  ^       c+\n +6  ^     ^    (*FAIL)\n +6  ^    ^     (*FAIL)\n +6  ^   ^      (*FAIL)\n +0   ^         a+\n +2   ^^        b?\n +4   ^ ^       c+\n +6   ^    ^    (*FAIL)\n +6   ^   ^     (*FAIL)\n +6   ^  ^      (*FAIL)\nNo match\n\n/a+b?(*PRUNE)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       (*PRUNE)\n+12 ^   ^       c+\n+14 ^      ^    (*FAIL)\n+14 ^     ^     (*FAIL)\n+14 ^    ^      (*FAIL)\n +0  ^          a+\n +2  ^ ^        b?\n +4  ^  ^       (*PRUNE)\n+12  ^  ^       c+\n+14  ^     ^    (*FAIL)\n+14  ^    ^     (*FAIL)\n+14  ^   ^      (*FAIL)\n +0   ^         a+\n +2   ^^        b?\n +4   ^ ^       (*PRUNE)\n+12   ^ ^       c+\n+14   ^    ^    (*FAIL)\n+14   ^   ^     (*FAIL)\n+14   ^  ^      (*FAIL)\nNo match\n\n/a+b?(*COMMIT)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       (*COMMIT)\n+13 ^   ^       c+\n+15 ^      ^    (*FAIL)\n+15 ^     ^     (*FAIL)\n+15 ^    ^      (*FAIL)\nNo match\n\n/a+b?(*SKIP)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabcccaaabccc\n--->aaabcccaaabccc\n +0 ^                  a+\n +2 ^  ^               b?\n +4 ^   ^              (*SKIP)\n+11 ^   ^              c+\n+13 ^      ^           (*FAIL)\n+13 ^     ^            (*FAIL)\n+13 ^    ^             (*FAIL)\n +0        ^           a+\n +2        ^  ^        b?\n +4        ^   ^       (*SKIP)\n+11        ^   ^       c+\n+13        ^      ^    (*FAIL)\n+13        ^     ^     (*FAIL)\n+13        ^    ^      (*FAIL)\nNo match\n\n/a+b?(*THEN)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       (*THEN)\n+11 ^   ^       c+\n+13 ^      ^    (*FAIL)\n+13 ^     ^     (*FAIL)\n+13 ^    ^      (*FAIL)\n +0  ^          a+\n +2  ^ ^        b?\n +4  ^  ^       (*THEN)\n+11  ^  ^       c+\n+13  ^     ^    (*FAIL)\n+13  ^    ^     (*FAIL)\n+13  ^   ^      (*FAIL)\n +0   ^         a+\n +2   ^^        b?\n +4   ^ ^       (*THEN)\n+11   ^ ^       c+\n+13   ^    ^    (*FAIL)\n+13   ^   ^     (*FAIL)\n+13   ^  ^      (*FAIL)\nNo match\n\n/a(*MARK)b/\nFailed: error 166 at offset 7: (*MARK) must have an argument\n\n/\\g6666666666/\nFailed: error 161 at offset 7: subpattern number is too big\n\n/[\\g6666666666]/B\n------------------------------------------------------------------\n        Bra\n        [6g]\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?1)\\c[/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/.+A/newline=crlf\n\\= Expect no match\n    \\r\\nA\nNo match\n\n/\\nA/newline=crlf\n    \\r\\nA\n 0: \\x0aA\n\n/[\\r\\n]A/newline=crlf\n    \\r\\nA\n 0: \\x0aA\n\n/(\\r|\\n)A/newline=crlf\n    \\r\\nA\n 0: \\x0aA\n 1: \\x0a\n\n/a(*CR)b/\nFailed: error 160 at offset 5: (*VERB) not recognized or malformed\n\n/(*CR)a.b/\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\rb\nNo match\n\n/(*CR)a.b/newline=lf\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\rb\nNo match\n\n/(*LF)a.b/newline=CRLF\n    a\\rb\n 0: a\\x0db\n\\= Expect no match\n    a\\nb\nNo match\n\n/(*CRLF)a.b/\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\r\\nb\nNo match\n\n/(*ANYCRLF)a.b/newline=CR\n\\= Expect no match\n    a\\rb\nNo match\n    a\\nb\nNo match\n    a\\r\\nb\nNo match\n\n/(*ANY)a.b/newline=cr\n\\= Expect no match\n    a\\rb\nNo match\n    a\\nb\nNo match\n    a\\r\\nb\nNo match\n    a\\x85b\nNo match\n\n/(*ANY).*/g\n    abc\\r\\ndef\n 0: abc\n 0: \n 0: def\n 0: \n\n/(*ANYCRLF).*/g\n    abc\\r\\ndef\n 0: abc\n 0: \n 0: def\n 0: \n\n/(*CRLF).*/g\n    abc\\r\\ndef\n 0: abc\n 0: \n 0: def\n 0: \n\n/(*NUL)^.*/\n    a\\nb\\x00ccc\n 0: a\\x0ab\n\n/(*NUL)^.*/s\n    a\\nb\\x00ccc\n 0: a\\x0ab\\x00ccc\n\n/^x/m,newline=NUL\n    ab\\x00xy\n 0: x\n\n/'#comment' 0d 0a 00 '^x\\' 0a 'y'/x,newline=nul,hex\n    x\\nyz\n 0: x\\x0ay\n\n/(*NUL)^X\\NY/\n    X\\nY\n 0: X\\x0aY\n    X\\rY\n 0: X\\x0dY\n\\= Expect no match\n    X\\x00Y\nNo match\n\n/a\\Rb/I,bsr=anycrlf\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n\\= Expect no match\n    a\\x85b\nNo match\n    a\\x0bb\nNo match\n\n/a\\Rb/I,bsr=unicode\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x85b\n 0: a\\x85b\n    a\\x0bb\n 0: a\\x0bb\n\n/a\\R?b/I,bsr=anycrlf\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n\\= Expect no match\n    a\\x85b\nNo match\n    a\\x0bb\nNo match\n\n/a\\R?b/I,bsr=unicode\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x85b\n 0: a\\x85b\n    a\\x0bb\n 0: a\\x0bb\n\n/a\\R{2,4}b/I,bsr=anycrlf\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 4\n    a\\r\\n\\nb\n 0: a\\x0d\\x0a\\x0ab\n    a\\n\\r\\rb\n 0: a\\x0a\\x0d\\x0db\n    a\\r\\n\\r\\n\\r\\n\\r\\nb\n 0: a\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\\x0d\\x0ab\n\\= Expect no match\n    a\\x85\\x85b\nNo match\n    a\\x0b\\x0bb\nNo match\n\n/a\\R{2,4}b/I,bsr=unicode\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 4\n    a\\r\\rb\n 0: a\\x0d\\x0db\n    a\\n\\n\\nb\n 0: a\\x0a\\x0a\\x0ab\n    a\\r\\n\\n\\r\\rb\n 0: a\\x0d\\x0a\\x0a\\x0d\\x0db\n    a\\x85\\x85b\n 0: a\\x85\\x85b\n    a\\x0b\\x0bb\n 0: a\\x0b\\x0bb\n\\= Expect no match\n    a\\r\\r\\r\\r\\rb\nNo match\n\n/(*BSR_ANYCRLF)a\\Rb/I\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n\n/(*BSR_UNICODE)a\\Rb/I\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\x85b\n 0: a\\x85b\n\n/(*BSR_ANYCRLF)(*CRLF)a\\Rb/I\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nForced newline is CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n\n/(*CRLF)(*BSR_UNICODE)a\\Rb/I\nCapture group count = 0\n\\R matches any Unicode newline\nForced newline is CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\x85b\n 0: a\\x85b\n\n/(*CRLF)(*BSR_ANYCRLF)(*CR)ab/I\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nForced newline is CR\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?<a>)(?&)/\nFailed: error 162 at offset 9: subpattern name expected\n\n/(?<abc>)(?&a)/\nFailed: error 115 at offset 11: reference to non-existent subpattern\n\n/(?<a>)(?&aaaaaaaaaaaaaaaaaaaaaaa)/\nFailed: error 115 at offset 9: reference to non-existent subpattern\n\n/(?+-a)/\nFailed: error 129 at offset 2: digit expected after (?+ or (?-\n\n/(?-+a)/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/(?(-1))/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/(?(+10))/\nFailed: error 115 at offset 4: reference to non-existent subpattern\n\n/(?(10))/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/(?(+2))()()/\n\n/(?(2))()()/\n\n/\\k''/\nFailed: error 162 at offset 3: subpattern name expected\n\n/\\k<>/\nFailed: error 162 at offset 3: subpattern name expected\n\n/\\k{}/\nFailed: error 162 at offset 3: subpattern name expected\n\n/\\k/\nFailed: error 169 at offset 2: \\k is not followed by a braced, angle-bracketed, or quoted name\n\n/\\kabc/\nFailed: error 169 at offset 2: \\k is not followed by a braced, angle-bracketed, or quoted name\n\n/(?P=)/\nFailed: error 162 at offset 4: subpattern name expected\n\n/(?P>)/\nFailed: error 162 at offset 4: subpattern name expected\n\n/[[:foo:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:1234:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:f\\oo:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[: :]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:...:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:l\\ower:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:abc\\:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[abc[:x\\]pqr:]]/\nFailed: error 130 at offset 6: unknown POSIX class name\n\n/[[:a\\dz:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/(^(a|b\\g<-1'c))/\nFailed: error 157 at offset 8: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/^(?+1)(?<a>x|y){0}z/\n    xzxx\n 0: xz\n    yzyy\n 0: yz\n\\= Expect no match\n    xxz\nNo match\n\n/(\\3)(\\1)(a)/\n\\= Expect no match\n    cat\nNo match\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n 0: a\n 1: \n 2: \n 3: a\n\n/TA]/\n    The ACTA] comes\n 0: TA]\n\n/TA]/allow_empty_class,match_unset_backref,dupnames\n    The ACTA] comes\n 0: TA]\n\n/(?2)[]a()b](abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n    abcbabc\n\n/(?2)[^]a()b](abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n    abcbabc\n\n/(?1)[]a()b](abc)/\n    abcbabc\n 0: abcbabc\n 1: abc\n\\= Expect no match\n    abcXabc\nNo match\n\n/(?1)[^]a()b](abc)/\n    abcXabc\n 0: abcXabc\n 1: abc\n\\= Expect no match\n    abcbabc\nNo match\n\n/(?2)[]a()b](abc)(xyz)/\n    xyzbabcxyz\n 0: xyzbabcxyz\n 1: abc\n 2: xyz\n\n/(?&N)[]a(?<N>)](?<M>abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n   abc<abc\n\n/(?&N)[]a(?<N>)](abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n   abc<abc\n\n/a[]b/\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/a[^]b/\nFailed: error 106 at offset 5: missing terminating ] for character class\n\n/a[]b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\nNo match\n\n/a[]+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\nNo match\n\n/a[]*+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\nNo match\n\n/a[^]b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n 0: aXb\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    ab\nNo match\n\n/a[^]+b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n 0: aXb\n    a\\nX\\nXb\n 0: a\\x0aX\\x0aXb\n\\= Expect no match\n    ab\nNo match\n\n/a(?!)b/B\n------------------------------------------------------------------\n        Bra\n        a\n        *FAIL\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?!)?a/B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Assert not\n        Ket\n        a\n        Ket\n        End\n------------------------------------------------------------------\n    ab\n 0: a\n\n/a(*FAIL)+b/\nFailed: error 109 at offset 8: quantifier does not follow a repeatable item\n\n/(abc|pqr|123){0}[xyz]/I\nCapture group count = 1\nStarting code units: x y z \nSubject length lower bound = 1\n\n/(?(?=.*b)b|^)/I,auto_callout\nCapture group count = 0\nMay match empty string\nOptions: auto_callout\nSubject length lower bound = 0\n   adc\n--->adc\n +0 ^       (?\n +2 ^       (?=\n +5 ^       .*\n +7 ^  ^    b\n +7 ^ ^     b\n +7 ^^      b\n +7 ^       b\n+11 ^       ^\n+12 ^       )\n+13 ^       End of pattern\n 0: \n   abc\n--->abc\n +0 ^       (?\n +2 ^       (?=\n +5 ^       .*\n +7 ^  ^    b\n +7 ^ ^     b\n +7 ^^      b\n +8 ^ ^     )\n +9 ^       b\n +0  ^      (?\n +2  ^      (?=\n +5  ^      .*\n +7  ^ ^    b\n +7  ^^     b\n +7  ^      b\n +8  ^^     )\n +9  ^      b\n+10  ^^     |\n+13  ^^     End of pattern\n 0: b\n\n/(?(?=b).*b|^d)/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/(?(?=.*b).*b|^d)/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/xyz/auto_callout\n  xyz\n--->xyz\n +0 ^       x\n +1 ^^      y\n +2 ^ ^     z\n +3 ^  ^    End of pattern\n 0: xyz\n  abcxyz\n--->abcxyz\n +0    ^       x\n +1    ^^      y\n +2    ^ ^     z\n +3    ^  ^    End of pattern\n 0: xyz\n\\= Expect no match\n  abc\nNo match\n  abcxypqr\nNo match\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n--->abcxyz\n +0 ^          x\n +0  ^         x\n +0   ^        x\n +0    ^       x\n +1    ^^      y\n +2    ^ ^     z\n +3    ^  ^    End of pattern\n 0: xyz\n\\= Expect no match\n  abc\n--->abc\n +0 ^       x\n +0  ^      x\n +0   ^     x\n +0    ^    x\nNo match\n  abcxypqr\n--->abcxypqr\n +0 ^            x\n +0  ^           x\n +0   ^          x\n +0    ^         x\n +1    ^^        y\n +2    ^ ^       z\n +0     ^        x\n +0      ^       x\n +0       ^      x\n +0        ^     x\n +0         ^    x\nNo match\n\n/(*NO_START_OPT)xyz/auto_callout\n  abcxyz\n--->abcxyz\n+15 ^          x\n+15  ^         x\n+15   ^        x\n+15    ^       x\n+16    ^^      y\n+17    ^ ^     z\n+18    ^  ^    End of pattern\n 0: xyz\n\n/(*NO_AUTO_POSSESS)a+b/B\n------------------------------------------------------------------\n        Bra\n        a+\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n--->abcxyz\n +0 ^          x\n +0  ^         x\n +0   ^        x\n +0    ^       x\n +1    ^^      y\n +2    ^ ^     z\n +3    ^  ^    End of pattern\n 0: xyz\n\n/^\"((?(?=[a])[^\"])|b)*\"$/auto_callout\n    \"ab\"\n--->\"ab\"\n +0 ^        ^\n +1 ^        \"\n +2 ^^       (\n +3 ^^       (?\n +5 ^^       (?=\n +8 ^^       [a]\n+11 ^ ^      )\n+12 ^^       [^\"]\n+16 ^ ^      )\n+17 ^ ^      |\n +3 ^ ^      (?\n +5 ^ ^      (?=\n +8 ^ ^      [a]\n+17 ^ ^      |\n+21 ^ ^      \"\n+18 ^ ^      b\n+19 ^  ^     )*\n +3 ^  ^     (?\n +5 ^  ^     (?=\n +8 ^  ^     [a]\n+17 ^  ^     |\n+21 ^  ^     \"\n+22 ^   ^    $\n+23 ^   ^    End of pattern\n 0: \"ab\"\n 1: \n\n/^\"((?(?=[a])[^\"])|b)*\"$/\n    \"ab\"\n 0: \"ab\"\n 1: \n\n/^X(?5)(a)(?|(b)|(q))(c)(d)Y/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n    XYabcdY\n\n/^X(?&N)(a)(?|(b)|(q))(c)(d)(?<N>Y)/\n    XYabcdY\n 0: XYabcdY\n 1: a\n 2: b\n 3: c\n 4: d\n 5: Y\n\n/Xa{2,4}b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/Xa{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/Xa{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X\\d{2,4}b/\n    X\\=ps\nPartial match: X\n    X3\\=ps\nPartial match: X3\n    X33\\=ps\nPartial match: X33\n    X333\\=ps\nPartial match: X333\n    X3333\\=ps\nPartial match: X3333\n\n/X\\d{2,4}?b/\n    X\\=ps\nPartial match: X\n    X3\\=ps\nPartial match: X3\n    X33\\=ps\nPartial match: X33\n    X333\\=ps\nPartial match: X333\n    X3333\\=ps\nPartial match: X3333\n\n/X\\d{2,4}+b/\n    X\\=ps\nPartial match: X\n    X3\\=ps\nPartial match: X3\n    X33\\=ps\nPartial match: X33\n    X333\\=ps\nPartial match: X333\n    X3333\\=ps\nPartial match: X3333\n\n/X\\D{2,4}b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X\\D{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X\\D{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[abc]{2,4}b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[abc]{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[abc]{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[^a]{2,4}b/\n    X\\=ps\nPartial match: X\n    Xz\\=ps\nPartial match: Xz\n    Xzz\\=ps\nPartial match: Xzz\n    Xzzz\\=ps\nPartial match: Xzzz\n    Xzzzz\\=ps\nPartial match: Xzzzz\n\n/X[^a]{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xz\\=ps\nPartial match: Xz\n    Xzz\\=ps\nPartial match: Xzz\n    Xzzz\\=ps\nPartial match: Xzzz\n    Xzzzz\\=ps\nPartial match: Xzzzz\n\n/X[^a]{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xz\\=ps\nPartial match: Xz\n    Xzz\\=ps\nPartial match: Xzz\n    Xzzz\\=ps\nPartial match: Xzzz\n    Xzzzz\\=ps\nPartial match: Xzzzz\n\n/(Y)X\\1{2,4}b/\n    YX\\=ps\nPartial match: YX\n    YXY\\=ps\nPartial match: YXY\n    YXYY\\=ps\nPartial match: YXYY\n    YXYYY\\=ps\nPartial match: YXYYY\n    YXYYYY\\=ps\nPartial match: YXYYYY\n\n/(Y)X\\1{2,4}?b/\n    YX\\=ps\nPartial match: YX\n    YXY\\=ps\nPartial match: YXY\n    YXYY\\=ps\nPartial match: YXYY\n    YXYYY\\=ps\nPartial match: YXYYY\n    YXYYYY\\=ps\nPartial match: YXYYYY\n\n/(Y)X\\1{2,4}+b/\n    YX\\=ps\nPartial match: YX\n    YXY\\=ps\nPartial match: YXY\n    YXYY\\=ps\nPartial match: YXYY\n    YXYYY\\=ps\nPartial match: YXYYY\n    YXYYYY\\=ps\nPartial match: YXYYYY\n\n/\\++\\KZ|\\d+X|9+Y/startchar\n    ++++123999\\=ps\nPartial match: 123999\n    ++++123999Y\\=ps\n 0: 999Y\n    ++++Z1234\\=ps\n 0: ++++Z\n    ^^^^\n\n/Z(*F)/\n\\= Expect no match\n    Z\\=ps\nNo match\n    ZA\\=ps\nNo match\n\n/Z(?!)/\n\\= Expect no match\n    Z\\=ps\nNo match\n    ZA\\=ps\nNo match\n\n/dog(sbody)?/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\nPartial match: dogs\n\n/dog(sbody)??/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\n 0: dog\n\n/dog|dogsbody/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\n 0: dog\n\n/dogsbody|dog/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\nPartial match: dogs\n\n/\\bthe cat\\b/\n    the cat\\=ps\n 0: the cat\n    the cat\\=ph\nPartial match: the cat\n\n/abc/\n   abc\\=ps\n 0: abc\n   abc\\=ph\n 0: abc\n\n/abc\\K123/startchar\n    xyzabc123pqr\n 0: abc123\n    ^^^\n    xyzabc12\\=ps\nPartial match: abc12\n    xyzabc12\\=ph\nPartial match: abc12\n\n/(?<=abc)123/\n    xyzabc123pqr\n 0: 123\n    xyzabc12\\=ps\nPartial match: 12\n    xyzabc12\\=ph\nPartial match: 12\n\n/\\babc\\b/\n    +++abc+++\n 0: abc\n    +++ab\\=ps\nPartial match: ab\n    +++ab\\=ph\nPartial match: ab\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^m][^>]>[^<])(?<word>\\w*+))/B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        Cond\n        Cond false\n        CBra 1\n        <\n        [^m]\n        [^>]\n        >\n        [^<]\n        Ket\n        CBra 2\n        \\w*+\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^\\d][^>]>[^<])(?<word>\\w*+))/B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        Cond\n        Cond false\n        CBra 1\n        <\n        [\\x00-/:-\\xff] (neg)\n        [^>]\n        >\n        [^<]\n        Ket\n        CBra 2\n        \\w*+\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(ab)(x(y)z(cd(*ACCEPT)))pq/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        ab\n        Ket\n        CBra 2\n        x\n        CBra 3\n        y\n        Ket\n        z\n        CBra 4\n        cd\n        Close 4\n        Close 2\n        *ACCEPT\n        Ket\n        Ket\n        pq\n        Ket\n        End\n------------------------------------------------------------------\n\n/abc\\K/aftertext,startchar\n    abcdef\n 0: abc\n    ^^^\n 0+ def\n    abcdef\\=notempty_atstart\n 0: abc\n    ^^^\n 0+ def\n    xyzabcdef\\=notempty_atstart\n 0: abc\n    ^^^\n 0+ def\n\\= Expect no match\n    abcdef\\=notempty\nNo match\n    xyzabcdef\\=notempty\nNo match\n\n/^(?:(?=abc)|abc\\K)/aftertext,startchar\n    abcdef\n 0: \n 0+ abcdef\n    abcdef\\=notempty_atstart\n 0: abc\n    ^^^\n 0+ def\n\\= Expect no match\n    abcdef\\=notempty\nNo match\n\n/a?b?/aftertext\n    xyz\n 0: \n 0+ xyz\n    xyzabc\n 0: \n 0+ xyzabc\n    xyzabc\\=notempty\n 0: ab\n 0+ c\n    xyzabc\\=notempty_atstart\n 0: \n 0+ yzabc\n    xyz\\=notempty_atstart\n 0: \n 0+ yz\n\\= Expect no match\n    xyz\\=notempty\nNo match\n\n/^a?b?/aftertext\n    xyz\n 0: \n 0+ xyz\n    xyzabc\n 0: \n 0+ xyzabc\n\\= Expect no match\n    xyzabc\\=notempty\nNo match\n    xyzabc\\=notempty_atstart\nNo match\n    xyz\\=notempty_atstart\nNo match\n    xyz\\=notempty\nNo match\n\n/^(?<name>a|b\\g<name>c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(?<name>a|b\\g'name'c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(a|b\\g<1>c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(a|b\\g'1'c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(a|b\\g'-1'c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/(^(a|b\\g<-1>c))/\n    aaaa\n 0: a\n 1: a\n 2: a\n    bacxxx\n 0: bac\n 1: bac\n 2: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n 2: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n 2: bbbaccc\n\n/(?-i:\\g<name>)(?i:(?<name>a))/\n    XaaX\n 0: aa\n 1: a\n    XAAX\n 0: AA\n 1: A\n\n/(?i:\\g<name>)(?-i:(?<name>a))/\n    XaaX\n 0: aa\n 1: a\n\\= Expect no match\n    XAAX\nNo match\n\n/(?-i:\\g<+1>)(?i:(a))/\n    XaaX\n 0: aa\n 1: a\n    XAAX\n 0: AA\n 1: A\n\n/(?=(?<regex>(?#simplesyntax)\\$(?<name>[a-zA-Z_\\x{7f}-\\x{ff}][a-zA-Z0-9_\\x{7f}-\\x{ff}]*)(?:\\[(?<index>[a-zA-Z0-9_\\x{7f}-\\x{ff}]+|\\$\\g<name>)\\]|->\\g<name>(\\(.*?\\))?)?|(?#simple syntax withbraces)\\$\\{(?:\\g<name>(?<indices>\\[(?:\\g<index>|'(?:\\\\.|[^'\\\\])*'|\"(?:\\g<regex>|\\\\.|[^\"\\\\])*\")\\])?|\\g<complex>|\\$\\{\\g<complex>\\})\\}|(?#complexsyntax)\\{(?<complex>\\$(?<segment>\\g<name>(\\g<indices>*|\\(.*?\\))?)(?:->\\g<segment>)*|\\$\\g<complex>|\\$\\{\\g<complex>\\})\\}))\\{/\n\n/(?<n>a|b|c)\\g<n>*/\n   abc\n 0: abc\n 1: a\n   accccbbb\n 0: accccbbb\n 1: a\n\n/^X(?7)(a)(?|(b)|(q)(r)(s))(c)(d)(Y)/\n    XYabcdY\n 0: XYabcdY\n 1: a\n 2: b\n 3: <unset>\n 4: <unset>\n 5: c\n 6: d\n 7: Y\n\n/(?<=b(?1)|zzz)(a)/\n    xbaax\n 0: a\n 1: a\n    xzzzax\n 0: a\n 1: a\n\n/(a)(?<=b\\1)/\n\n/(a)(?<=b+(?1))/\nFailed: error 125 at offset 3: lookbehind assertion is not fixed length\n\n/(a+)(?<=b(?1))/\nFailed: error 125 at offset 4: lookbehind assertion is not fixed length\n\n/(a(?<=b(?1)))/\nFailed: error 125 at offset 2: lookbehind assertion is not fixed length\n\n/(?<=b(?1))xyz/\nFailed: error 115 at offset 8: reference to non-existent subpattern\n\n/(?<=b(?1))xyz(b+)pqrstuvew/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/(a|bc)\\1/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|bc)\\1{2,3}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 3\n\n/(a|bc)(?1)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|b\\1)(a|b\\1)/I\nCapture group count = 2\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|b\\1){2}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|bbbb\\1)(a|bbbb\\1)/I\nCapture group count = 2\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|bbbb\\1){2}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/^From +([^ ]+) +[a-zA-Z][a-zA-Z][a-zA-Z] +[a-zA-Z][a-zA-Z][a-zA-Z] +[0-9]?[0-9] +[0-9][0-9]:[0-9][0-9]/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'F'\nLast code unit = ':'\nSubject length lower bound = 22\n\n/<tr([\\w\\W\\s\\d][^<>]{0,})><TD([\\w\\W\\s\\d][^<>]{0,})>([\\d]{0,}\\.)(.*)((<BR>([\\w\\W\\s\\d][^<>]{0,})|[\\s]{0,}))<\\/a><\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><\\/TR>/Iis\nCapture group count = 11\nOptions: caseless dotall\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 47\n\n\"(?>.*/)foo\"I\nCapture group count = 0\nLast code unit = 'o'\nSubject length lower bound = 4\n\n/(?(?=[^a-z]+[a-z])  \\d{2}-[a-z]{3}-\\d{2}  |  \\d{2}-\\d{2}-\\d{2} ) /Ix\nCapture group count = 0\nOptions: extended\nLast code unit = '-'\nSubject length lower bound = 8\n\n/(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))/Ii\nCapture group count = 1\nOptions: caseless\nStarting code units: A B C a b c \nSubject length lower bound = 1\n\n/(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))/I\nCapture group count = 0\nStarting code units: c d \nLast code unit = 'b'\nSubject length lower bound = 41\n\n/<a[\\s]+href[\\s]*=[\\s]*          # find <a href=\n ([\\\"\\'])?                       # find single or double quote\n (?(1) (.*?)\\1 | ([^\\s]+))       # if quote found, match up to next matching\n                                 # quote, otherwise match up to next space\n/Iisx\nCapture group count = 3\nMax back reference = 1\nOptions: caseless dotall extended\nFirst code unit = '<'\nLast code unit = '='\nSubject length lower bound = 9\n\n/^(?!:)                       # colon disallowed at start\n  (?:                         # start of item\n    (?: [0-9a-f]{1,4} |       # 1-4 hex digits or\n    (?(1)0 | () ) )           # if null previously matched, fail; else null\n    :                         # followed by colon\n  ){1,7}                      # end item; 1-7 of them required\n  [0-9a-f]{1,4} $             # final hex number at end of string\n  (?(1)|.)                    # check that there was an empty component\n  /Iix\nCapture group count = 1\nMax back reference = 1\nCompile options: caseless extended\nOverall options: anchored caseless extended\nLast code unit = ':'\nSubject length lower bound = 2\n\n/(?|(?<a>A)|(?<a>B))/I\nCapture group count = 1\nNamed capture groups:\n  a   1\nStarting code units: A B \nSubject length lower bound = 1\n    AB\\=copy=a\n 0: A\n 1: A\n  C A (1) a (group 1)\n    BA\\=copy=a\n 0: B\n 1: B\n  C B (1) a (group 1)\n\n/(?|(?<a>A)|(?<b>B))/\nFailed: error 165 at offset 16: different names for subpatterns of the same number are not allowed\n\n/(?:a(?<quote> (?<apostrophe>')|(?<realquote>\")) |\n    b(?<quote> (?<apostrophe>')|(?<realquote>\")) )\n    (?('quote')[a-z]+|[0-9]+)/Ix,dupnames\nCapture group count = 6\nMax back reference = 4\nNamed capture groups:\n  apostrophe   2\n  apostrophe   5\n  quote        1\n  quote        4\n  realquote    3\n  realquote    6\nOptions: dupnames extended\nStarting code units: a b \nSubject length lower bound = 3\n    a\"aaaaa\n 0: a\"aaaaa\n 1: \"\n 2: <unset>\n 3: \"\n    b\"aaaaa\n 0: b\"aaaaa\n 1: <unset>\n 2: <unset>\n 3: <unset>\n 4: \"\n 5: <unset>\n 6: \"\n\\= Expect no match\n    b\"11111\nNo match\n    a\"11111\nNo match\n\n/^(?|(a)(b)(c)(?<D>d)|(?<D>e)) (?('D')X|Y)/IBx,dupnames\n------------------------------------------------------------------\n        Bra\n        ^\n        Bra\n        CBra 1\n        a\n        Ket\n        CBra 2\n        b\n        Ket\n        CBra 3\n        c\n        Ket\n        CBra 4\n        d\n        Ket\n        Alt\n        CBra 1\n        e\n        Ket\n        Ket\n        Cond\n        Cond ref <D>2\n        X\n        Alt\n        Y\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  D   4\n  D   1\nCompile options: dupnames extended\nOverall options: anchored dupnames extended\nStarting code units: a e \nSubject length lower bound = 2\n    abcdX\n 0: abcdX\n 1: a\n 2: b\n 3: c\n 4: d\n    eX\n 0: eX\n 1: e\n\\= Expect no match\n    abcdY\nNo match\n    ey\nNo match\n\n/(?<A>a) (b)(c)  (?<A>d  (?(R&A)$ | (?4)) )/IBx,dupnames\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        CBra 2\n        b\n        Ket\n        CBra 3\n        c\n        Ket\n        CBra 4\n        d\n        Cond\n        Cond recurse <A>2\n        $\n        Alt\n        Recurse\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  A   1\n  A   4\nOptions: dupnames extended\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n    abcdd\n 0: abcdd\n 1: a\n 2: b\n 3: c\n 4: dd\n\\= Expect no match\n    abcdde\nNo match\n\n/abcd*/\n    xxxxabcd\\=ps\n 0: abcd\n    xxxxabcd\\=ph\nPartial match: abcd\n\n/abcd*/i\n    xxxxabcd\\=ps\n 0: abcd\n    xxxxabcd\\=ph\nPartial match: abcd\n    XXXXABCD\\=ps\n 0: ABCD\n    XXXXABCD\\=ph\nPartial match: ABCD\n\n/abc\\d*/\n    xxxxabc1\\=ps\n 0: abc1\n    xxxxabc1\\=ph\nPartial match: abc1\n\n/(a)bc\\1*/\n    xxxxabca\\=ps\n 0: abca\n 1: a\n    xxxxabca\\=ph\nPartial match: abca\n\n/abc[de]*/\n    xxxxabcde\\=ps\n 0: abcde\n    xxxxabcde\\=ph\nPartial match: abcde\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n 0: a\n 1: \n 2: \n 3: a\n\n/(\\3)(\\1)(a)/I,allow_empty_class,match_unset_backref,dupnames\nCapture group count = 3\nMax back reference = 3\nOptions: allow_empty_class dupnames match_unset_backref\nLast code unit = 'a'\nSubject length lower bound = 1\n    cat\n 0: a\n 1: \n 2: \n 3: a\n\n/(\\3)(\\1)(a)/I\nCapture group count = 3\nMax back reference = 3\nLast code unit = 'a'\nSubject length lower bound = 3\n\\= Expect no match\n    cat\nNo match\n\n/i(?(DEFINE)(?<s>a))/I\nCapture group count = 1\nNamed capture groups:\n  s   1\nFirst code unit = 'i'\nSubject length lower bound = 1\n    i\n 0: i\n\n/()i(?(1)a)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'i'\nSubject length lower bound = 1\n    ia\n 0: ia\n 1: \n\n/(?i)a(?-i)b|c/B\n------------------------------------------------------------------\n        Bra\n     /i a\n        b\n        Alt\n        c\n        Ket\n        End\n------------------------------------------------------------------\n    XabX\n 0: ab\n    XAbX\n 0: Ab\n    CcC\n 0: c\n\\= Expect no match\n    XABX\nNo match\n\n/(?i)a(?s)b|c/B\n------------------------------------------------------------------\n        Bra\n     /i ab\n        Alt\n     /i c\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?i)a(?s-i)b|c/B\n------------------------------------------------------------------\n        Bra\n     /i a\n        b\n        Alt\n        c\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(ab(c\\1)d|x){2}$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        ab\n        CBra 2\n        c\n        \\1\n        Ket\n        d\n        Alt\n        x\n        Ket\n        CBra 1\n        ab\n        CBra 2\n        c\n        \\1\n        Ket\n        d\n        Alt\n        x\n        Ket\n        $\n        Ket\n        End\n------------------------------------------------------------------\n    xabcxd\n 0: xabcxd\n 1: abcxd\n 2: cx\n\n/^(?&t)*+(?(DEFINE)(?<t>.))$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Braposzero\n        SBraPos\n        Recurse\n        KetRpos\n        Cond\n        Cond false\n        CBra 1\n        Any\n        Ket\n        Ket\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?&t)*(?(DEFINE)(?<t>.))$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Brazero\n        SBra\n        Recurse\n        KetRmax\n        Cond\n        Cond false\n        CBra 1\n        Any\n        Ket\n        Ket\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n# This one is here because Perl gives the match as \"b\" rather than \"ab\". I\n# believe this to be a Perl bug.\n\n/(?>a\\Kb)z|(ab)/\n    ab\\=startchar\n 0: ab\n 1: ab\n\n/(?P<L1>(?P<L2>0|)|(?P>L2)(?P>L1))/\n    abcd\n 0: \n 1: \n 2: \n    0abc\n 0: 0\n 1: 0\n 2: 0\n\n/abc(*MARK:)pqr/\nFailed: error 166 at offset 10: (*MARK) must have an argument\n\n/abc(*:)pqr/\nFailed: error 166 at offset 6: (*MARK) must have an argument\n\n/(*COMMIT:X)/B\n------------------------------------------------------------------\n        Bra\n        *COMMIT X\n        Ket\n        End\n------------------------------------------------------------------\n\n# This should, and does, fail. In Perl, it does not, which I think is a\n# bug because replacing the B in the pattern by (B|D) does make it fail.\n# Turning off Perl's optimization by inserting (??{\"\"}) also makes it fail.\n\n/A(*COMMIT)B/aftertext,mark\n\\= Expect no match\n    ACABX\nNo match\n\n# These should be different, but in Perl they are not, which I think\n# is a bug in Perl.\n\n/A(*THEN)B|A(*THEN)C/mark\n    AC\n 0: AC\n\n/A(*PRUNE)B|A(*PRUNE)C/mark\n\\= Expect no match\n    AC\nNo match\n\n# Mark names can be duplicated. Perl doesn't give a mark for this one,\n# though PCRE2 does.\n\n/^A(*:A)B|^X(*:A)Y/mark\n\\= Expect no match\n    XAQQ\nNo match, mark = A\n\n# COMMIT at the start of a pattern should be the same as an anchor. Perl\n# optimizations defeat this. So does the PCRE2 optimization unless we disable\n# it.\n\n/(*COMMIT)ABC/\n    ABCDEFG\n 0: ABC\n\n/(*COMMIT)ABC/no_start_optimize\n\\= Expect no match\n    DEFGABC\nNo match\n\n/^(ab (c+(*THEN)cd) | xyz)/x\n\\= Expect no match\n    abcccd\nNo match\n\n/^(ab (c+(*PRUNE)cd) | xyz)/x\n\\= Expect no match\n    abcccd\nNo match\n\n/^(ab (c+(*FAIL)cd) | xyz)/x\n\\= Expect no match\n    abcccd\nNo match\n\n# Perl gets some of these wrong\n\n/(?>.(*ACCEPT))*?5/\n    abcde\n 0: a\n\n/(.(*ACCEPT))*?5/\n    abcde\n 0: a\n 1: a\n\n/(.(*ACCEPT))5/\n    abcde\n 0: a\n 1: a\n\n/(.(*ACCEPT))*5/\n    abcde\n 0: a\n 1: a\n\n/A\\NB./B\n------------------------------------------------------------------\n        Bra\n        A\n        Any\n        B\n        Any\n        Ket\n        End\n------------------------------------------------------------------\n    ACBD\n 0: ACBD\n\\= Expect no match\n    A\\nB\nNo match\n    ACB\\n\nNo match\n\n/A\\NB./Bs\n------------------------------------------------------------------\n        Bra\n        A\n        Any\n        B\n        AllAny\n        Ket\n        End\n------------------------------------------------------------------\n    ACBD\n 0: ACBD\n    ACB\\n\n 0: ACB\\x0a\n\\= Expect no match\n    A\\nB\nNo match\n\n/A\\NB/newline=crlf\n    A\\nB\n 0: A\\x0aB\n    A\\rB\n 0: A\\x0dB\n\\= Expect no match\n    A\\r\\nB\nNo match\n\n/\\R+b/B\n------------------------------------------------------------------\n        Bra\n        \\R++\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\R+\\n/B\n------------------------------------------------------------------\n        Bra\n        \\R+\n        \\x0a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\R+\\d/B\n------------------------------------------------------------------\n        Bra\n        \\R++\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\R/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\R/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    \\x20\\x0a\n 0:  \\x0a\n    \\x20\\x0d\n 0:  \\x0d\n    \\x20\\x0d\\x0a\n 0:  \\x0d\\x0a\n\n/\\S*\\R/B\n------------------------------------------------------------------\n        Bra\n        \\S*+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    a\\x0a\n 0: a\\x0a\n\n/X\\h*\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\h*+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    X\\x20\\x0a\n 0: X \\x0a\n\n/X\\H*\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\H*\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    X\\x0d\\x0a\n 0: X\\x0d\\x0a\n\n/X\\H+\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\H+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    X\\x0d\\x0a\n 0: X\\x0d\\x0a\n\n/X\\H++\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\H++\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n\\= Expect no match\n    X\\x0d\\x0a\nNo match\n\n/(?<=abc)def/\n    abc\\=ph\nPartial match: \n\n/abc$/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc$/m\n    abc\n 0: abc\n    abc\\n\n 0: abc\n    abc\\=ph\nPartial match: abc\n    abc\\n\\=ph\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\n\\=ps\n 0: abc\n\n/abc\\z/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc\\Z/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc\\b/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc\\B/\n    abc\\=ps\nPartial match: abc\n    abc\\=ph\nPartial match: abc\n\\= Expect no match\n    abc\nNo match\n\n/.+/\n\\= Bad offsets\n    abc\\=offset=4\nFailed: error -33: bad offset value\n    abc\\=offset=-4\n** Invalid value in 'offset=-4'\n\\= Valid data\n    abc\\=offset=0\n 0: abc\n    abc\\=offset=1\n 0: bc\n    abc\\=offset=2\n 0: c\n\\= Expect no match\n    abc\\=offset=3\nNo match\n\n/^\\c\u00c4\u0141/\nFailed: error 168 at offset 3: \\c must be followed by a printable ASCII character\n\n/(?P<abn>(?P=abn)xxx)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        \\1\n        xxx\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(a\\1z)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        \\1\n        z\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?P<abn>(?P=abn)(?<badstufxxx)/B\nFailed: error 142 at offset 29: syntax error in subpattern name (missing terminator?)\n\n/(?P<abn>(?P=axn)xxx)/B\nFailed: error 115 at offset 12: reference to non-existent subpattern\n\n/(?P<abn>(?P=axn)xxx)(?<axn>yy)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        \\2\n        xxx\n        Ket\n        CBra 2\n        yy\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# These tests are here because Perl gets the first one wrong.\n\n/(\\R*)(.)/s\n    \\r\\n\n 0: \\x0d\n 1: \n 2: \\x0d\n    \\r\\r\\n\\n\\r\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n    \\r\\r\\n\\n\\r\\n\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n\n/(\\R)*(.)/s\n    \\r\\n\n 0: \\x0d\n 1: <unset>\n 2: \\x0d\n    \\r\\r\\n\\n\\r\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0a\n 2: \\x0d\n    \\r\\r\\n\\n\\r\\n\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0a\n 2: \\x0d\n\n/((?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)*)(.)/s\n    \\r\\n\n 0: \\x0d\n 1: \n 2: \\x0d\n    \\r\\r\\n\\n\\r\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n    \\r\\r\\n\\n\\r\\n\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n\n# -------------\n\n/^abc$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        abc\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/^abc$/Bm\n------------------------------------------------------------------\n        Bra\n     /m ^\n        abc\n     /m $\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a)*+(\\w)/\n    aaaaX\n 0: aaaaX\n 1: a\n 2: X\n\\= Expect no match\n    aaaa\nNo match\n\n/^(?:a)*+(\\w)/\n    aaaaX\n 0: aaaaX\n 1: X\n\\= Expect no match\n    aaaa\nNo match\n\n/(a)++1234/IB\n------------------------------------------------------------------\n        Bra\n        CBraPos 1\n        a\n        KetRpos\n        1234\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = '4'\nSubject length lower bound = 5\n\n/([abc])++1234/I\nCapture group count = 1\nStarting code units: a b c \nLast code unit = '4'\nSubject length lower bound = 5\n\n/(?<=(abc)+)X/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/(^ab)/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(^ab)++/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(^ab|^)+/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(^ab|^)++/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(?:^ab)/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(?:^ab)++/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(?:^ab|^)+/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(?:^ab|^)++/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(.*ab)/I\nCapture group count = 1\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(.*ab)++/I\nCapture group count = 1\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(.*ab|.*)+/I\nCapture group count = 1\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(.*ab|.*)++/I\nCapture group count = 1\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(?:.*ab)/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?:.*ab)++/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?:.*ab|.*)+/I\nCapture group count = 0\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(?:.*ab|.*)++/I\nCapture group count = 0\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(?=a)[bcd]/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=a))[bcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=a))+[bcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=a))++[bcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?=a+)[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nSubject length lower bound = 1\n\n/(?=a+?)[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nSubject length lower bound = 1\n\n/(?=a++)[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nSubject length lower bound = 1\n\n/(?=a{3})[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nLast code unit = 'a' (caseless)\nSubject length lower bound = 2\n\n/(abc)\\1+/\n\n# Perl doesn't get these right IMO (the 3rd is PCRE2-specific)\n\n/(?1)(?:(b(*ACCEPT))){0}/\n    b\n 0: b\n\n/(?1)(?:(b(*ACCEPT))){0}c/\n    bc\n 0: bc\n\\= Expect no match\n    b\nNo match\n\n/(?1)(?:((*ACCEPT))){0}c/\n    c\n 0: c\n    c\\=notempty\n 0: c\n\n/^.*?(?(?=a)a|b(*THEN)c)/\n\\= Expect no match\n    ba\nNo match\n\n/^.*?(?(?=a)a|bc)/\n    ba\n 0: ba\n\n/^.*?(?(?=a)a(*THEN)b|c)/\n\\= Expect no match\n    ac\nNo match\n\n/^.*?(?(?=a)a(*THEN)b)c/\n\\= Expect no match\n    ac\nNo match\n\n/^.*?(a(*THEN)b)c/\n\\= Expect no match\n    aabc\nNo match\n\n/^.*? (?1) c (?(DEFINE)(a(*THEN)b))/x\n    aabc\n 0: aabc\n\n/^.*?(a(*THEN)b|z)c/\n    aabc\n 0: aabc\n 1: ab\n\n/^.*?(z|a(*THEN)b)c/\n    aabc\n 0: aabc\n 1: ab\n\n# These are here because they are not Perl-compatible; the studying means the\n# mark is not seen.\n\n/(*MARK:A)(*SKIP:B)(C|X)/mark\n    C\n 0: C\n 1: C\nMK: A\n\\= Expect no match\n    D\nNo match, mark = A\n\n/(*:A)A+(*SKIP:A)(B|Z)/mark\n\\= Expect no match\n    AAAC\nNo match, mark = A\n\n# ----------------------------\n\n\"(?=a*(*ACCEPT)b)c\"\n    c\n 0: c\n    c\\=notempty\n 0: c\n\n/(?1)c(?(DEFINE)((*ACCEPT)b))/\n    c\n 0: c\n    c\\=notempty\n 0: c\n\n/(?>(*ACCEPT)b)c/\n    c\n 0: \n\\= Expect no match\n    c\\=notempty\nNo match\n\n/(?:(?>(a)))+a%/allaftertext\n    %aa%\n 0: aa%\n 0+ \n 1: a\n 1+ a%\n\n/(a)b|ac/allaftertext\n    ac\\=ovector=1\n 0: ac\n 0+ \n\n/(a)(b)x|abc/allaftertext\n     abc\\=ovector=2\n 0: abc\n 0+ \n\n/(a)bc|(a)(b)\\2/\n    abc\\=ovector=1\nMatched, but too many substrings\n 0: abc\n    abc\\=ovector=2\n 0: abc\n 1: a\n    aba\\=ovector=1\nMatched, but too many substrings\n 0: aba\n    aba\\=ovector=2\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n    aba\\=ovector=3\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n 2: a\n    aba\\=ovector=4\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n\n/(?(DEFINE)(a(?2)|b)(b(?1)|a))(?:(?1)|(?2))/I\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(a(?2)|b)(b(?1)|a)(?:(?1)|(?2))/I\nCapture group count = 2\nStarting code units: a b \nSubject length lower bound = 3\n\n/(a(?2)|b)(b(?1)|a)(?1)(?2)/I\nCapture group count = 2\nStarting code units: a b \nSubject length lower bound = 4\n\n/(abc)(?1)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 6\n\n/(?:(foo)|(bar)|(baz))X/allcaptures\n    bazfooX\n 0: fooX\n 1: foo\n 2: <unset>\n 3: <unset>\n    foobazbarX\n 0: barX\n 1: <unset>\n 2: bar\n 3: <unset>\n    barfooX\n 0: fooX\n 1: foo\n 2: <unset>\n 3: <unset>\n    bazX\n 0: bazX\n 1: <unset>\n 2: <unset>\n 3: baz\n    foobarbazX\n 0: bazX\n 1: <unset>\n 2: <unset>\n 3: baz\n    bazfooX\\=ovector=0\n 0: fooX\n 1: foo\n 2: <unset>\n 3: <unset>\n    bazfooX\\=ovector=1\nMatched, but too many substrings\n 0: fooX\n    bazfooX\\=ovector=2\n 0: fooX\n 1: foo\n    bazfooX\\=ovector=3\n 0: fooX\n 1: foo\n 2: <unset>\n\n/(?=abc){3}abc/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        abc\n        Ket\n        Assert\n        abc\n        Ket\n        Assert\n        abc\n        Ket\n        abc\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=abc)+abc/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        abc\n        Ket\n        Brazero\n        Assert\n        abc\n        Ket\n        abc\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=abc)++abc/B\n------------------------------------------------------------------\n        Bra\n        Once\n        Assert\n        abc\n        Ket\n        Brazero\n        Assert\n        abc\n        Ket\n        Ket\n        abc\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=abc){0}xyz/B\n------------------------------------------------------------------\n        Bra\n        Skip zero\n        Assert\n        abc\n        Ket\n        xyz\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=(a))?./B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Assert\n        CBra 1\n        a\n        Ket\n        Ket\n        Any\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=(a))??./B\n------------------------------------------------------------------\n        Bra\n        Braminzero\n        Assert\n        CBra 1\n        a\n        Ket\n        Ket\n        Any\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?=(a)){0}b(?1)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Skip zero\n        Assert\n        CBra 1\n        a\n        Ket\n        Ket\n        b\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(DEFINE)(a))?b(?1)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        CBra 1\n        a\n        Ket\n        Ket\n        b\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?=(?1))?[az]([abc])d/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Brazero\n        Assert\n        Recurse\n        Ket\n        [az]\n        CBra 1\n        [a-c]\n        Ket\n        d\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?!a){0}\\w+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Skip zero\n        Assert not\n        a\n        Ket\n        \\w++\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<=(abc))?xyz/B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Assert back\n        Reverse\n        CBra 1\n        abc\n        Ket\n        Ket\n        xyz\n        Ket\n        End\n------------------------------------------------------------------\n\n/[:a[:abc]b:]/B\n------------------------------------------------------------------\n        Bra\n        [:[a-c]\n        b:]\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a(*:A)(d|e(*:B))z|aeq)/auto_callout\n    adz\n--->adz\n +0 ^       ^\n +1 ^       (\n +2 ^       a\n +3 ^^      (*:A)\n +8 ^^      (\nLatest Mark: A\n +9 ^^      d\n+10 ^ ^     |\n+18 ^ ^     z\n+19 ^  ^    |\n+24 ^  ^    End of pattern\n 0: adz\n 1: adz\n 2: d\n    aez\n--->aez\n +0 ^       ^\n +1 ^       (\n +2 ^       a\n +3 ^^      (*:A)\n +8 ^^      (\nLatest Mark: A\n +9 ^^      d\n+11 ^^      e\n+12 ^ ^     (*:B)\n+17 ^ ^     )\nLatest Mark: B\n+18 ^ ^     z\n+19 ^  ^    |\n+24 ^  ^    End of pattern\n 0: aez\n 1: aez\n 2: e\n    aeqwerty\n--->aeqwerty\n +0 ^            ^\n +1 ^            (\n +2 ^            a\n +3 ^^           (*:A)\n +8 ^^           (\nLatest Mark: A\n +9 ^^           d\n+11 ^^           e\n+12 ^ ^          (*:B)\n+17 ^ ^          )\nLatest Mark: B\n+18 ^ ^          z\n+20 ^            a\n+21 ^^           e\n+22 ^ ^          q\n+23 ^  ^         )\n+24 ^  ^         End of pattern\n 0: aeq\n 1: aeq\n\n/.(*F)/\n\\= Expect no match\n    abc\\=ph\nNo match\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b/I\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 't'\nLast code unit = 't'\nSubject length lower bound = 18\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b|\\burl\\b\\W*?\\bshell:|<input\\b.*?\\btype\\b\\W*?\\bimage\\b|\\bonkeyup\\b\\W*?\\=/I\nCapture group count = 0\nMax lookbehind = 1\nStarting code units: < o t u \nSubject length lower bound = 8\n\n/a(*SKIP)c|b(*ACCEPT)|/I,aftertext\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    a\n 0: \n 0+ \n\n/a(*SKIP)c|b(*ACCEPT)cd(*ACCEPT)|x/I\nCapture group count = 0\nStarting code units: a b x \nSubject length lower bound = 1\n    ax\n 0: x\n\n'a*(*ACCEPT)b'aftertext\n    abc\\=notempty_atstart\n 0: a\n 0+ bc\n    bbb\\=notempty_atstart\n 0: \n 0+ bb\n\\= Expect no match\n    \\=notempty_atstart\nNo match\n\n/(*ACCEPT)a/I,aftertext\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    bax\n 0: \n 0+ bax\n\n/z(*ACCEPT)a/I,aftertext\nCapture group count = 0\nFirst code unit = 'z'\nSubject length lower bound = 1\n    baxzbx\n 0: z\n 0+ bx\n\n/^(?>a+)(?>(z+))\\w/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Once\n        a++\n        Ket\n        Once\n        CBra 1\n        z++\n        Ket\n        Ket\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n    aaaazzzzb\n 0: aaaazzzzb\n 1: zzzz\n\\= Expect no match\n    aazz\nNo match\n\n/(.)(\\1|a(?2))/\n    bab\n 0: bab\n 1: b\n 2: ab\n\n/\\1|(.)(?R)\\1/\n    cbbbc\n 0: cbbbc\n 1: c\n\n/(.)((?(1)c|a)|a(?2))/\n\\= Expect no match\n    baa\nNo match\n\n/(?P<abn>(?P=abn)xxx)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        \\1\n        xxx\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(a\\1z)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        \\1\n        z\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^a\\x41z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\\= Expect no match\n    ax41z\nNo match\n\n/^a[m\\x41]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\n/^a\\x1z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    ax1z\n 0: ax1z\n\n/^a\\u0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\\= Expect no match\n    au0041z\nNo match\n\n/^a[m\\u0041]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\n/^a\\u041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    au041z\n 0: au041z\n\\= Expect no match\n    aAz\nNo match\n\n/^a\\U0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aU0041z\n 0: aU0041z\n\\= Expect no match\n    aAz\nNo match\n    \n/^\\u{7a}/alt_bsux\n    u{7a}\n 0: u{7a}\n\\= Expect no match\n    zoo \nNo match\n\n/^\\u{7a}/extra_alt_bsux\n    zoo \n 0: z\n\n/(?(?=c)c|d)++Y/B\n------------------------------------------------------------------\n        Bra\n        BraPos\n        Cond\n        Assert\n        c\n        Ket\n        c\n        Alt\n        d\n        Ket\n        KetRpos\n        Y\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(?=c)c|d)*+Y/B\n------------------------------------------------------------------\n        Bra\n        Braposzero\n        BraPos\n        Cond\n        Assert\n        c\n        Ket\n        c\n        Alt\n        d\n        Ket\n        KetRpos\n        Y\n        Ket\n        End\n------------------------------------------------------------------\n\n/a[\\NB]c/\nFailed: error 171 at offset 4: \\N is not supported in a class\n    aNc\n\n/a[B-\\Nc]/\nFailed: error 150 at offset 6: invalid range in character class\n\n/a[B\\Nc]/\nFailed: error 171 at offset 5: \\N is not supported in a class\n\n/(a)(?2){0,1999}?(b)/\n\n/(a)(?(DEFINE)(b))(?2){0,1999}?(?2)/\n\n# This test, with something more complicated than individual letters, causes\n# different behaviour in Perl. Perhaps it disables some optimization; no tag is\n# passed back for the failures, whereas in PCRE2 there is a tag.\n\n/(A|P)(*:A)(B|P) | (X|P)(X|P)(*:B)(Y|P)/x,mark\n    AABC\n 0: AB\n 1: A\n 2: B\nMK: A\n    XXYZ\n 0: XXY\n 1: <unset>\n 2: <unset>\n 3: X\n 4: X\n 5: Y\nMK: B\n\\= Expect no match\n    XAQQ\nNo match, mark = A\n    XAQQXZZ\nNo match, mark = A\n    AXQQQ\nNo match, mark = A\n    AXXQQQ\nNo match, mark = B\n\n# Perl doesn't give marks for these, though it does if the alternatives are\n# replaced by single letters.\n\n/(b|q)(*:m)f|a(*:n)w/mark\n    aw\n 0: aw\nMK: n\n\\= Expect no match\n    abc\nNo match, mark = m\n\n/(q|b)(*:m)f|a(*:n)w/mark\n    aw\n 0: aw\nMK: n\n\\= Expect no match\n    abc\nNo match, mark = m\n\n# After a partial match, the behaviour is as for a failure.\n\n/^a(*:X)bcde/mark\n   abc\\=ps\nPartial match, mark=X: abc\n\n# These are here because Perl doesn't return a mark, except for the first.\n\n/(?=(*:x))(q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\n 1: \nMK: x\n\n/(?=(*:x))((*:y)q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\n 1: \nMK: x\n\n/(?=(*:x))(?:(*:y)q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\nMK: x\n\n/(?=(*:x))(?>(*:y)q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\nMK: x\n\n/(?=a(*:x))(?!a(*:y)c)/aftertext,mark\n    ab\n 0: \n 0+ ab\nMK: x\n\n/(?=a(*:x))(?=a(*:y)c|)/aftertext,mark\n    ab\n 0: \n 0+ ab\nMK: x\n\n/(..)\\1/\n    ab\\=ps\nPartial match: ab\n    aba\\=ps\nPartial match: aba\n    abab\\=ps\n 0: abab\n 1: ab\n\n/(..)\\1/i\n    ab\\=ps\nPartial match: ab\n    abA\\=ps\nPartial match: abA\n    aBAb\\=ps\n 0: aBAb\n 1: aB\n\n/(..)\\1{2,}/\n    ab\\=ps\nPartial match: ab\n    aba\\=ps\nPartial match: aba\n    abab\\=ps\nPartial match: abab\n    ababa\\=ps\nPartial match: ababa\n    ababab\\=ps\n 0: ababab\n 1: ab\n    ababab\\=ph\nPartial match: ababab\n    abababa\\=ps\n 0: ababab\n 1: ab\n    abababa\\=ph\nPartial match: abababa\n\n/(..)\\1{2,}/i\n    ab\\=ps\nPartial match: ab\n    aBa\\=ps\nPartial match: aBa\n    aBAb\\=ps\nPartial match: aBAb\n    AbaBA\\=ps\nPartial match: AbaBA\n    abABAb\\=ps\n 0: abABAb\n 1: ab\n    aBAbaB\\=ph\nPartial match: aBAbaB\n    abABabA\\=ps\n 0: abABab\n 1: ab\n    abaBABa\\=ph\nPartial match: abaBABa\n\n/(..)\\1{2,}?x/i\n    ab\\=ps\nPartial match: ab\n    abA\\=ps\nPartial match: abA\n    aBAb\\=ps\nPartial match: aBAb\n    abaBA\\=ps\nPartial match: abaBA\n    abAbaB\\=ps\nPartial match: abAbaB\n    abaBabA\\=ps\nPartial match: abaBabA\n    abAbABaBx\\=ps\n 0: abAbABaBx\n 1: ab\n\n/^(..)\\1/\n    aba\\=ps\nPartial match: aba\n\n/^(..)\\1{2,3}x/\n    aba\\=ps\nPartial match: aba\n    ababa\\=ps\nPartial match: ababa\n    ababa\\=ph\nPartial match: ababa\n    abababx\n 0: abababx\n 1: ab\n    ababababx\n 0: ababababx\n 1: ab\n\n/^(..)\\1{2,3}?x/\n    aba\\=ps\nPartial match: aba\n    ababa\\=ps\nPartial match: ababa\n    ababa\\=ph\nPartial match: ababa\n    abababx\n 0: abababx\n 1: ab\n    ababababx\n 0: ababababx\n 1: ab\n\n/^(..)(\\1{2,3})ab/\n    abababab\n 0: abababab\n 1: ab\n 2: abab\n\n/^\\R/\n    \\r\\=ps\n 0: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n\n/^\\R{2,3}x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\nPartial match: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\r\\r\\=ph\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\rx\n 0: \\x0d\\x0dx\n    \\r\\r\\rx\n 0: \\x0d\\x0d\\x0dx\n\n/^\\R{2,3}?x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\nPartial match: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\r\\r\\=ph\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\rx\n 0: \\x0d\\x0dx\n    \\r\\r\\rx\n 0: \\x0d\\x0d\\x0dx\n\n/^\\R?x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    x\n 0: x\n    \\rx\n 0: \\x0dx\n\n/^\\R+x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\n\\=ps\nPartial match: \\x0d\\x0a\n    \\r\\n\\=ph\nPartial match: \\x0d\\x0a\n    \\rx\n 0: \\x0dx\n\n/^a$/newline=crlf\n    a\\r\\=ps\nPartial match: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/^a$/m,newline=crlf\n    a\\r\\=ps\nPartial match: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/^(a$|a\\r)/newline=crlf\n    a\\r\\=ps\n 0: a\\x0d\n 1: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/^(a$|a\\r)/m,newline=crlf\n    a\\r\\=ps\n 0: a\\x0d\n 1: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/./newline=crlf\n    \\r\\=ps\n 0: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n\n/.{2,3}/newline=crlf\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\n 0: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\n 0: \\x0d\\x0d\\x0d\n    \\r\\r\\r\\=ph\nPartial match: \\x0d\\x0d\\x0d\n\n/.{2,3}?/newline=crlf\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\n 0: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\n 0: \\x0d\\x0d\n    \\r\\r\\r\\=ph\n 0: \\x0d\\x0d\n\n\"AB(C(D))(E(F))?(?(?=\\2)(?=\\4))\"\n    ABCDGHI\\=ovector=01\nMatched, but too many substrings\n 0: ABCD\n\n# These are all run as real matches in test 1; here we are just checking the\n# settings of the anchored and startline bits.\n\n/(?>.*?a)(?<=ba)/I\nCapture group count = 0\nMax lookbehind = 2\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/(?:.*?a)(?<=ba)/I\nCapture group count = 0\nMax lookbehind = 2\nFirst code unit at start or follows newline\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/.*?a(*PRUNE)b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/.*?a(*PRUNE)b/Is\nCapture group count = 0\nOptions: dotall\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a(*PRUNE)b/Is\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/.*?a(*SKIP)b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?>.*?a)b/Is\nCapture group count = 0\nOptions: dotall\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?>.*?a)b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?>^a)b/Is\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(?>.*?)(?<=(abcd)|(wxyz))/I\nCapture group count = 2\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n/(?>.*)(?<=(abcd)|(wxyz))/I\nCapture group count = 2\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n\"(?>.*)foo\"I\nCapture group count = 0\nLast code unit = 'o'\nSubject length lower bound = 3\n\n\"(?>.*?)foo\"I\nCapture group count = 0\nLast code unit = 'o'\nSubject length lower bound = 3\n\n/(?>^abc)/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?>.*abc)/Im\nCapture group count = 0\nOptions: multiline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?:.*abc)/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?:(a)+(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(?:(a)++(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(?:(?>(a))(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(?:(?1)(?C1)x|ab(?C2))((a)){0}/\n    aab\\=callout_capture\nCallout 1: last capture = 0\n--->aab\n    ^^      x\nCallout 1: last capture = 0\n--->aab\n     ^^     x\nCallout 2: last capture = 0\n--->aab\n     ^ ^    )\n 0: ab\n\n/(?1)(?C1)((a)(?C2)){0}/\n    aab\\=callout_capture\nCallout 2: last capture = 2\n 1: <unset>\n 2: a\n--->aab\n    ^^      ){0}\nCallout 1: last capture = 0\n--->aab\n    ^^      (\n 0: a\n\n/(?:(a)+(?C1)bb|aa(?C2)b)++/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n    aab\\=callout_capture,ovector=1\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(ab)x|ab/\n    ab\\=ovector=0\n 0: ab\n    ab\\=ovector=1\n 0: ab\n\n/(?<=123)(*MARK:xx)abc/mark\n    xxxx123a\\=ph\nPartial match, mark=xx: a\n    xxxx123a\\=ps\nPartial match, mark=xx: a\n\n/123\\Kabc/startchar\n    xxxx123a\\=ph\nPartial match: 123a\n    xxxx123a\\=ps\nPartial match: 123a\n\n/^(?(?=a)aa|bb)/auto_callout\n    bb\n--->bb\n +0 ^      ^\n +1 ^      (?\n +3 ^      (?=\n +6 ^      a\n+11 ^      b\n+12 ^^     b\n+13 ^ ^    )\n+14 ^ ^    End of pattern\n 0: bb\n\n/(?C1)^(?C2)(?(?C99)(?=(?C3)a(?C4))(?C5)a(?C6)a(?C7)|(?C8)b(?C9)b(?C10))(?C11)/\n    bb\n--->bb\n  1 ^      ^\n  2 ^      (?\n 99 ^      (?=\n  3 ^      a\n  8 ^      b\n  9 ^^     b\n 10 ^ ^    )\n 11 ^ ^    End of pattern\n 0: bb\n\n# Perl seems to have a bug with this one.\n\n/aaaaa(*COMMIT)(*PRUNE)b|a+c/\n    aaaaaac\n 0: aaaac\n\n# Here are some that Perl treats differently because of the way it handles\n# backtracking verbs.\n\n/(?!a(*COMMIT)b)ac|ad/\n     ac\n 0: ac\n     ad\n 0: ad\n\n/^(?!a(*THEN)b|ac)../\n     ad\n 0: ad\n\\= Expect no match\n     ac\nNo match\n\n/^(?=a(*THEN)b|ac)/\n    ac\n 0: \n\n/\\A.*?(?:a|b(*THEN)c)/\n    ba\n 0: ba\n\n/\\A.*?(?:a|b(*THEN)c)++/\n    ba\n 0: ba\n\n/\\A.*?(?:a|b(*THEN)c|d)/\n    ba\n 0: ba\n\n/(?:(a(*MARK:X)a+(*SKIP:X)b)){0}(?:(?1)|aac)/\n    aac\n 0: aac\n\n/\\A.*?(a|b(*THEN)c)/\n    ba\n 0: ba\n 1: a\n\n/^(A(*THEN)B|A(*THEN)D)/\n    AD\n 0: AD\n 1: AD\n\n/(?!b(*THEN)a)bn|bnn/\n    bnn\n 0: bn\n\n/(?(?=b(*SKIP)a)bn|bnn)/\n    bnn\n 0: bnn\n\n/(?=b(*THEN)a|)bn|bnn/\n    bnn\n 0: bn\n\n# This test causes a segfault with Perl 5.18.0\n\n/^(?=(a)){0}b(?1)/\n    backgammon\n 0: ba\n\n/(?|(?<n>f)|(?<n>b))/I,dupnames\nCapture group count = 1\nNamed capture groups:\n  n   1\nOptions: dupnames\nStarting code units: b f \nSubject length lower bound = 1\n\n/(?<a>abc)(?<a>z)\\k<a>()/IB,dupnames\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        abc\n        Ket\n        CBra 2\n        z\n        Ket\n        \\k<a>2\n        CBra 3\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 3\nMax back reference = 2\nNamed capture groups:\n  a   1\n  a   2\nOptions: dupnames\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 5\n\n/a*[bcd]/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        [b-d]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[bcd]*a/B\n------------------------------------------------------------------\n        Bra\n        [b-d]*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n# A complete set of tests for auto-possessification of character types, but\n# omitting \\C because it might be disabled (it has its own tests).\n\n/\\D+\\D \\D+\\d \\D+\\S \\D+\\s \\D+\\W \\D+\\w \\D+. \\D+\\R \\D+\\H \\D+\\h \\D+\\V \\D+\\v \\D+\\Z \\D+\\z \\D+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\D+\n        \\D\n        \\D++\n        \\d\n        \\D+\n        \\S\n        \\D+\n        \\s\n        \\D+\n        \\W\n        \\D+\n        \\w\n        \\D+\n        Any\n        \\D+\n        \\R\n        \\D+\n        \\H\n        \\D+\n        \\h\n        \\D+\n        \\V\n        \\D+\n        \\v\n        \\D+\n        \\Z\n        \\D++\n        \\z\n        \\D+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d+\\D \\d+\\d \\d+\\S \\d+\\s \\d+\\W \\d+\\w \\d+. \\d+\\R \\d+\\H \\d+\\h \\d+\\V \\d+\\v \\d+\\Z \\d+\\z \\d+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\d++\n        \\D\n        \\d+\n        \\d\n        \\d+\n        \\S\n        \\d++\n        \\s\n        \\d++\n        \\W\n        \\d+\n        \\w\n        \\d+\n        Any\n        \\d++\n        \\R\n        \\d+\n        \\H\n        \\d++\n        \\h\n        \\d+\n        \\V\n        \\d++\n        \\v\n        \\d++\n        \\Z\n        \\d++\n        \\z\n        \\d++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S+\\D \\S+\\d \\S+\\S \\S+\\s \\S+\\W \\S+\\w \\S+. \\S+\\R \\S+\\H \\S+\\h \\S+\\V \\S+\\v \\S+\\Z \\S+\\z \\S+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\S+\n        \\D\n        \\S+\n        \\d\n        \\S+\n        \\S\n        \\S++\n        \\s\n        \\S+\n        \\W\n        \\S+\n        \\w\n        \\S+\n        Any\n        \\S++\n        \\R\n        \\S+\n        \\H\n        \\S++\n        \\h\n        \\S+\n        \\V\n        \\S++\n        \\v\n        \\S++\n        \\Z\n        \\S++\n        \\z\n        \\S++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s+\\D \\s+\\d \\s+\\S \\s+\\s \\s+\\W \\s+\\w \\s+. \\s+\\R \\s+\\H \\s+\\h \\s+\\V \\s+\\v \\s+\\Z \\s+\\z \\s+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\s+\n        \\D\n        \\s++\n        \\d\n        \\s++\n        \\S\n        \\s+\n        \\s\n        \\s+\n        \\W\n        \\s++\n        \\w\n        \\s+\n        Any\n        \\s+\n        \\R\n        \\s+\n        \\H\n        \\s+\n        \\h\n        \\s+\n        \\V\n        \\s+\n        \\v\n        \\s+\n        \\Z\n        \\s++\n        \\z\n        \\s+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W+\\D \\W+\\d \\W+\\S \\W+\\s \\W+\\W \\W+\\w \\W+. \\W+\\R \\W+\\H \\W+\\h \\W+\\V \\W+\\v \\W+\\Z \\W+\\z \\W+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\W+\n        \\D\n        \\W++\n        \\d\n        \\W+\n        \\S\n        \\W+\n        \\s\n        \\W+\n        \\W\n        \\W++\n        \\w\n        \\W+\n        Any\n        \\W+\n        \\R\n        \\W+\n        \\H\n        \\W+\n        \\h\n        \\W+\n        \\V\n        \\W+\n        \\v\n        \\W+\n        \\Z\n        \\W++\n        \\z\n        \\W+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w+\\D \\w+\\d \\w+\\S \\w+\\s \\w+\\W \\w+\\w \\w+. \\w+\\R \\w+\\H \\w+\\h \\w+\\V \\w+\\v \\w+\\Z \\w+\\z \\w+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\w+\n        \\D\n        \\w+\n        \\d\n        \\w+\n        \\S\n        \\w++\n        \\s\n        \\w++\n        \\W\n        \\w+\n        \\w\n        \\w+\n        Any\n        \\w++\n        \\R\n        \\w+\n        \\H\n        \\w++\n        \\h\n        \\w+\n        \\V\n        \\w++\n        \\v\n        \\w++\n        \\Z\n        \\w++\n        \\z\n        \\w++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\R+\\D \\R+\\d \\R+\\S \\R+\\s \\R+\\W \\R+\\w \\R+. \\R+\\R \\R+\\H \\R+\\h \\R+\\V \\R+\\v \\R+\\Z \\R+\\z \\R+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\R+\n        \\D\n        \\R++\n        \\d\n        \\R+\n        \\S\n        \\R++\n        \\s\n        \\R+\n        \\W\n        \\R++\n        \\w\n        \\R++\n        Any\n        \\R+\n        \\R\n        \\R+\n        \\H\n        \\R++\n        \\h\n        \\R+\n        \\V\n        \\R+\n        \\v\n        \\R+\n        \\Z\n        \\R++\n        \\z\n        \\R+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\H+\\D \\H+\\d \\H+\\S \\H+\\s \\H+\\W \\H+\\w \\H+. \\H+\\R \\H+\\H \\H+\\h \\H+\\V \\H+\\v \\H+\\Z \\H+\\z \\H+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\H+\n        \\D\n        \\H+\n        \\d\n        \\H+\n        \\S\n        \\H+\n        \\s\n        \\H+\n        \\W\n        \\H+\n        \\w\n        \\H+\n        Any\n        \\H+\n        \\R\n        \\H+\n        \\H\n        \\H++\n        \\h\n        \\H+\n        \\V\n        \\H+\n        \\v\n        \\H+\n        \\Z\n        \\H++\n        \\z\n        \\H+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\h+\\D \\h+\\d \\h+\\S \\h+\\s \\h+\\W \\h+\\w \\h+. \\h+\\R \\h+\\H \\h+\\h \\h+\\V \\h+\\v \\h+\\Z \\h+\\z \\h+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\h+\n        \\D\n        \\h++\n        \\d\n        \\h++\n        \\S\n        \\h+\n        \\s\n        \\h+\n        \\W\n        \\h++\n        \\w\n        \\h+\n        Any\n        \\h++\n        \\R\n        \\h++\n        \\H\n        \\h+\n        \\h\n        \\h+\n        \\V\n        \\h++\n        \\v\n        \\h+\n        \\Z\n        \\h++\n        \\z\n        \\h+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\V+\\D \\V+\\d \\V+\\S \\V+\\s \\V+\\W \\V+\\w \\V+. \\V+\\R \\V+\\H \\V+\\h \\V+\\V \\V+\\v \\V+\\Z \\V+\\z \\V+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\V+\n        \\D\n        \\V+\n        \\d\n        \\V+\n        \\S\n        \\V+\n        \\s\n        \\V+\n        \\W\n        \\V+\n        \\w\n        \\V+\n        Any\n        \\V++\n        \\R\n        \\V+\n        \\H\n        \\V+\n        \\h\n        \\V+\n        \\V\n        \\V++\n        \\v\n        \\V+\n        \\Z\n        \\V++\n        \\z\n        \\V+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\v+\\D \\v+\\d \\v+\\S \\v+\\s \\v+\\W \\v+\\w \\v+. \\v+\\R \\v+\\H \\v+\\h \\v+\\V \\v+\\v \\v+\\Z \\v+\\z \\v+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\v+\n        \\D\n        \\v++\n        \\d\n        \\v++\n        \\S\n        \\v+\n        \\s\n        \\v+\n        \\W\n        \\v++\n        \\w\n        \\v+\n        Any\n        \\v+\n        \\R\n        \\v+\n        \\H\n        \\v++\n        \\h\n        \\v++\n        \\V\n        \\v+\n        \\v\n        \\v+\n        \\Z\n        \\v++\n        \\z\n        \\v+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ a+\\D  a+\\d  a+\\S  a+\\s  a+\\W  a+\\w  a+.  a+\\R  a+\\H  a+\\h  a+\\V  a+\\v  a+\\Z  a+\\z  a+$/Bx\n------------------------------------------------------------------\n        Bra\n        a+\n        \\D\n        a++\n        \\d\n        a+\n        \\S\n        a++\n        \\s\n        a++\n        \\W\n        a+\n        \\w\n        a+\n        Any\n        a++\n        \\R\n        a+\n        \\H\n        a++\n        \\h\n        a+\n        \\V\n        a++\n        \\v\n        a++\n        \\Z\n        a++\n        \\z\n        a++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\n+\\D \\n+\\d \\n+\\S \\n+\\s \\n+\\W \\n+\\w \\n+. \\n+\\R \\n+\\H \\n+\\h \\n+\\V \\n+\\v \\n+\\Z \\n+\\z \\n+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\x0a+\n        \\D\n        \\x0a++\n        \\d\n        \\x0a++\n        \\S\n        \\x0a+\n        \\s\n        \\x0a+\n        \\W\n        \\x0a++\n        \\w\n        \\x0a+\n        Any\n        \\x0a+\n        \\R\n        \\x0a+\n        \\H\n        \\x0a++\n        \\h\n        \\x0a++\n        \\V\n        \\x0a+\n        \\v\n        \\x0a+\n        \\Z\n        \\x0a++\n        \\z\n        \\x0a+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bx\n------------------------------------------------------------------\n        Bra\n        Any+\n        \\D\n        Any+\n        \\d\n        Any+\n        \\S\n        Any+\n        \\s\n        Any+\n        \\W\n        Any+\n        \\w\n        Any+\n        Any\n        Any++\n        \\R\n        Any+\n        \\H\n        Any+\n        \\h\n        Any+\n        \\V\n        Any+\n        \\v\n        Any+\n        \\Z\n        Any++\n        \\z\n        Any+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bsx\n------------------------------------------------------------------\n        Bra\n        AllAny+\n        \\D\n        AllAny+\n        \\d\n        AllAny+\n        \\S\n        AllAny+\n        \\s\n        AllAny+\n        \\W\n        AllAny+\n        \\w\n        AllAny+\n        AllAny\n        AllAny+\n        \\R\n        AllAny+\n        \\H\n        AllAny+\n        \\h\n        AllAny+\n        \\V\n        AllAny+\n        \\v\n        AllAny+\n        \\Z\n        AllAny++\n        \\z\n        AllAny+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ \\D+$  \\d+$  \\S+$  \\s+$  \\W+$  \\w+$  \\R+$  \\H+$  \\h+$  \\V+$ \\v+$  a+$   \\n+$  .+$  .+$/Bmx\n------------------------------------------------------------------\n        Bra\n        \\D+\n     /m $\n        \\d++\n     /m $\n        \\S++\n     /m $\n        \\s+\n     /m $\n        \\W+\n     /m $\n        \\w++\n     /m $\n        \\R+\n     /m $\n        \\H+\n     /m $\n        \\h+\n     /m $\n        \\V+\n     /m $\n        \\v+\n     /m $\n        a+\n     /m $\n        \\x0a+\n     /m $\n        Any+\n     /m $\n        Any+\n     /m $\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=a+)a(a+)++a/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        a++\n        Ket\n        a\n        CBraPos 1\n        a+\n        KetRpos\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(bb|cc)a+(?:bb|cc)a+(?>bb|cc)a+(?:bb|cc)+a+(aa)a+(?:bb|aa)/B\n------------------------------------------------------------------\n        Bra\n        a++\n        CBra 1\n        bb\n        Alt\n        cc\n        Ket\n        a++\n        Bra\n        bb\n        Alt\n        cc\n        Ket\n        a++\n        Once\n        bb\n        Alt\n        cc\n        Ket\n        a++\n        Bra\n        bb\n        Alt\n        cc\n        KetRmax\n        a+\n        CBra 2\n        aa\n        Ket\n        a+\n        Bra\n        bb\n        Alt\n        aa\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(bb|cc)?#a+(?:bb|cc)??#a+(?:bb|cc)?+#a+(?:bb|cc)*#a+(bb|cc)?a#a+(?:aa)?/B\n------------------------------------------------------------------\n        Bra\n        a++\n        Brazero\n        CBra 1\n        bb\n        Alt\n        cc\n        Ket\n        #\n        a++\n        Braminzero\n        Bra\n        bb\n        Alt\n        cc\n        Ket\n        #\n        a++\n        Once\n        Brazero\n        Bra\n        bb\n        Alt\n        cc\n        Ket\n        Ket\n        #\n        a++\n        Brazero\n        Bra\n        bb\n        Alt\n        cc\n        KetRmax\n        #\n        a+\n        Brazero\n        CBra 2\n        bb\n        Alt\n        cc\n        Ket\n        a#\n        a+\n        Brazero\n        Bra\n        aa\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(?:bb)?a#a+(?:|||)#a+(?:|b)a#a+(?:|||)?a/B\n------------------------------------------------------------------\n        Bra\n        a+\n        Brazero\n        Bra\n        bb\n        Ket\n        a#\n        a++\n        Bra\n        Alt\n        Alt\n        Alt\n        Ket\n        #\n        a+\n        Bra\n        Alt\n        b\n        Ket\n        a#\n        a+\n        Brazero\n        Bra\n        Alt\n        Alt\n        Alt\n        Ket\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/[ab]*/B\n------------------------------------------------------------------\n        Bra\n        [ab]*+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaaa\n\n/[ab]*?/B\n------------------------------------------------------------------\n        Bra\n        [ab]*?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: \n\n/[ab]?/B\n------------------------------------------------------------------\n        Bra\n        [ab]?+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: a\n\n/[ab]??/B\n------------------------------------------------------------------\n        Bra\n        [ab]??\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: \n\n/[ab]+/B\n------------------------------------------------------------------\n        Bra\n        [ab]++\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaaa\n\n/[ab]+?/B\n------------------------------------------------------------------\n        Bra\n        [ab]+?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: a\n\n/[ab]{2,3}/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,3}+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaa\n\n/[ab]{2,3}?/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,3}?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aa\n\n/[ab]{2,}/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,}+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaaa\n\n/[ab]{2,}?/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,}?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aa\n\n/\\d+\\s{0,5}=\\s*\\S?=\\w{0,4}\\W*/B\n------------------------------------------------------------------\n        Bra\n        \\d++\n        \\s{0,5}+\n        =\n        \\s*+\n        \\S?\n        =\n        \\w{0,4}+\n        \\W*+\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-d]{5,12}[e-z0-9]*#[^a-z]+[b-y]*a[2-7]?[^0-9a-z]+/B\n------------------------------------------------------------------\n        Bra\n        [a-d]{5,12}+\n        [0-9e-z]*+\n        #\n        [\\x00-`{-\\xff] (neg)++\n        [b-y]*+\n        a\n        [2-7]?+\n        [\\x00-/:-`{-\\xff] (neg)++\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-z]*\\s#[ \\t]?\\S#[a-c]*\\S#[C-G]+?\\d#[4-8]*\\D#[4-9,]*\\D#[!$]{0,5}\\w#[M-Xf-l]+\\W#[a-c,]?\\W/B\n------------------------------------------------------------------\n        Bra\n        [a-z]*+\n        \\s\n        #\n        [\\x09 ]?+\n        \\S\n        #\n        [a-c]*\n        \\S\n        #\n        [C-G]++\n        \\d\n        #\n        [4-8]*+\n        \\D\n        #\n        [,4-9]*\n        \\D\n        #\n        [!$]{0,5}+\n        \\w\n        #\n        [M-Xf-l]++\n        \\W\n        #\n        [,a-c]?\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(aa|bb)*c#a*(bb|cc)*a#a?(bb|cc)*d#[a-f]*(g|hh)*f/B\n------------------------------------------------------------------\n        Bra\n        a+\n        Brazero\n        CBra 1\n        aa\n        Alt\n        bb\n        KetRmax\n        c#\n        a*\n        Brazero\n        CBra 2\n        bb\n        Alt\n        cc\n        KetRmax\n        a#\n        a?+\n        Brazero\n        CBra 3\n        bb\n        Alt\n        cc\n        KetRmax\n        d#\n        [a-f]*\n        Brazero\n        CBra 4\n        g\n        Alt\n        hh\n        KetRmax\n        f\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-f]*(g|hh|i)*i#[a-x]{4,}(y{0,6})*y#[a-k]+(ll|mm)+n/B\n------------------------------------------------------------------\n        Bra\n        [a-f]*+\n        Brazero\n        CBra 1\n        g\n        Alt\n        hh\n        Alt\n        i\n        KetRmax\n        i#\n        [a-x]{4,}\n        Brazero\n        SCBra 2\n        y{0,6}\n        KetRmax\n        y#\n        [a-k]++\n        CBra 3\n        ll\n        Alt\n        mm\n        KetRmax\n        n\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-f]*(?>gg|hh)+#[a-f]*(?>gg|hh)?#[a-f]*(?>gg|hh)*a#[a-f]*(?>gg|hh)*h/B\n------------------------------------------------------------------\n        Bra\n        [a-f]*+\n        Once\n        gg\n        Alt\n        hh\n        KetRmax\n        #\n        [a-f]*+\n        Brazero\n        Once\n        gg\n        Alt\n        hh\n        Ket\n        #\n        [a-f]*\n        Brazero\n        Once\n        gg\n        Alt\n        hh\n        KetRmax\n        a#\n        [a-f]*+\n        Brazero\n        Once\n        gg\n        Alt\n        hh\n        KetRmax\n        h\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-c]*d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]*+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c d \nLast code unit = 'd'\nSubject length lower bound = 1\n\n/[a-c]+d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]++\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c \nLast code unit = 'd'\nSubject length lower bound = 2\n\n/[a-c]?d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]?+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c d \nLast code unit = 'd'\nSubject length lower bound = 1\n\n/[a-c]{4,6}d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]{4,6}+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c \nLast code unit = 'd'\nSubject length lower bound = 5\n\n/[a-c]{0,6}d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]{0,6}+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c d \nLast code unit = 'd'\nSubject length lower bound = 1\n\n# End of special auto-possessive tests\n\n/^A\\o{1239}B/\nFailed: error 164 at offset 8: non-octal character in \\o{} (closing brace missing?)\n    A\\123B\n\n/^A\\oB/\nFailed: error 155 at offset 4: missing opening brace after \\o\n\n/^A\\x{zz}B/\nFailed: error 167 at offset 5: non-hex character in \\x{} (closing brace missing?)\n\n/^A\\x{12Z/\nFailed: error 167 at offset 7: non-hex character in \\x{} (closing brace missing?)\n\n/^A\\x{/\nFailed: error 178 at offset 5: digits missing in \\x{} or \\o{} or \\N{U+}\n\n/[ab]++/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        [ab]++\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^ab]*+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        [\\x00-`c-\\xff] (neg)*+\n        Ket\n        End\n------------------------------------------------------------------\n\n/a{4}+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        a{4}\n        Ket\n        End\n------------------------------------------------------------------\n\n/a{4}+/Bi,no_auto_possess\n------------------------------------------------------------------\n        Bra\n     /i a{4}\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[A-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[a-[.xxx.]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[a-[=xxx=]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[a-[!xxx!]]+/\nFailed: error 108 at offset 3: range out of order in character class\n\n/[A-[!xxx!]]+/\n    A]]]\n 0: A]]]\n\n/[a-\\d]+/\nFailed: error 150 at offset 5: invalid range in character class\n\n/(?<0abc>xx)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?&1abc)xx(?<1abc>y)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?<ab-cd>xx)/\nFailed: error 142 at offset 5: syntax error in subpattern name (missing terminator?)\n\n/(?'0abc'xx)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?P<0abc>xx)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/\\k<5ghj>/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/\\k'5ghj'/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/\\k{2fgh}/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?P=8yuki)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/\\g{4df}/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/(?&1abc)xx(?<1abc>y)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?P>1abc)xx(?<1abc>y)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/\\g'3gh'/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/\\g<5fg>/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/(?(<4gh>)abc)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/(?('4gh')abc)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/(?(4gh)abc)/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/(?(R&6yh)abc)/\nFailed: error 144 at offset 5: subpattern name must start with a non-digit\n\n/(((a\\2)|(a*)\\g<-1>))*a?/B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        SCBra 1\n        CBra 2\n        CBra 3\n        a\n        \\2\n        Ket\n        Alt\n        CBra 4\n        a*\n        Ket\n        Recurse\n        Ket\n        KetRmax\n        a?+\n        Ket\n        End\n------------------------------------------------------------------\n\n# Test the ugly \"start or end of word\" compatibility syntax.\n\n/[[:<:]]red[[:>:]]/B\n------------------------------------------------------------------\n        Bra\n        \\b\n        Assert\n        \\w\n        Ket\n        red\n        \\b\n        Assert back\n        Reverse\n        \\w\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    little red riding hood\n 0: red\n    a /red/ thing\n 0: red\n    red is a colour\n 0: red\n    put it all on red\n 0: red\n\\= Expect no match\n    no reduction\nNo match\n    Alfred Winifred\nNo match\n\n/[a[:<:]] should give error/\nFailed: error 130 at offset 4: unknown POSIX class name\n\n/(?=ab\\K)/aftertext,allow_lookaround_bsk\n    abcd\\=startchar\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0+ abcd\n\n/abcd/newline=lf,firstline\n\\= Expect no match\n    xx\\nxabcd\nNo match\n\n# Test stack guard external calls.\n\n/(((a)))/stackguard=1\nFailed: error 133 at offset 7: parentheses are too deeply nested (stack check)\n\n/(((a)))/stackguard=2\nFailed: error 133 at offset 7: parentheses are too deeply nested (stack check)\n\n/(((a)))/stackguard=3\n\n/(((((a)))))/\n\n# End stack guard tests\n\n/^\\w+(?>\\s*)(?<=\\w)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        \\w+\n        Once\n        \\s*+\n        Ket\n        Assert back\n        Reverse\n        \\w\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\othing/\nFailed: error 155 at offset 2: missing opening brace after \\o\n\n/\\o{}/\nFailed: error 178 at offset 3: digits missing in \\x{} or \\o{} or \\N{U+}\n\n/\\o{whatever}/\nFailed: error 164 at offset 3: non-octal character in \\o{} (closing brace missing?)\n\n/\\xthing/\n\n/\\x{}/\nFailed: error 178 at offset 3: digits missing in \\x{} or \\o{} or \\N{U+}\n\n/\\x{whatever}/\nFailed: error 167 at offset 3: non-hex character in \\x{} (closing brace missing?)\n\n/A\\8B/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n/A\\9B/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n# This one is here because Perl fails to match \"12\" for this pattern when the $\n# is present.\n\n/^(?(?=abc)\\w{3}:|\\d\\d)$/\n    abc:\n 0: abc:\n    12\n 0: 12\n\\= Expect no match\n    123\nNo match\n    xyz\nNo match\n\n# Perl gets this one wrong, giving \"a\" as the after text for ca and failing to\n# match for cd.\n\n/(?(?=ab)ab)/aftertext\n    abxxx\n 0: ab\n 0+ xxx\n    ca\n 0: \n 0+ ca\n    cd\n 0: \n 0+ cd\n\n# This should test both paths for processing OP_RECURSE.\n\n/(?(R)a+|(?R)b)/\n    aaaabcde\n 0: aaaab\n    aaaabcde\\=ovector=100\n 0: aaaab\n\n/a*?b*?/\n    ab\n 0: \n\n/(*NOTEMPTY)a*?b*?/\n    ab\n 0: a\n    ba\n 0: b\n    cb\n 0: b\n\n/(*NOTEMPTY_ATSTART)a*?b*?/aftertext\n    ab\n 0: a\n 0+ b\n    cdab\n 0: \n 0+ dab\n\n/(?(VERSION>=10.0)yes|no)/I\nCapture group count = 0\nSubject length lower bound = 2\n    yesno\n 0: yes\n\n/(?(VERSION>=10.04)yes|no)/\n    yesno\n 0: yes\n\n/(?(VERSION=8)yes){3}/BI,aftertext\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        yes\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    yesno\n 0: \n 0+ yesno\n\n/(?(VERSION=8)yes|no){3}/I\nCapture group count = 0\nSubject length lower bound = 6\n    yesnononoyes\n 0: nonono\n\\= Expect no match\n    yesno\nNo match\n\n/(?:(?<VERSION>abc)|xyz)(?(VERSION)yes|no)/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  VERSION   1\nStarting code units: a x \nSubject length lower bound = 5\n    abcyes\n 0: abcyes\n 1: abc\n    xyzno\n 0: xyzno\n\\= Expect no match\n    abcno\nNo match\n    xyzyes\nNo match\n\n/(?(VERSION<10)yes|no)/\nFailed: error 179 at offset 10: syntax error or number too big in (?(VERSION condition\n\n/(?(VERSION>10)yes|no)/\nFailed: error 179 at offset 11: syntax error or number too big in (?(VERSION condition\n\n/(?(VERSION>=10.0.0)yes|no)/\nFailed: error 179 at offset 16: syntax error or number too big in (?(VERSION condition\n\n/(?(VERSION=10.101)yes|no)/\nFailed: error 179 at offset 16: syntax error or number too big in (?(VERSION condition\n\n/abcd/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n\n/abcd/I,no_start_optimize\nCapture group count = 0\nOptions: no_start_optimize\n\n/(|ab)*?d/I\nCapture group count = 1\nStarting code units: a d \nLast code unit = 'd'\nSubject length lower bound = 1\n   abd\n 0: abd\n 1: ab\n   xyd\n 0: d\n\n/(|ab)*?d/I,no_start_optimize\nCapture group count = 1\nOptions: no_start_optimize\n   abd\n 0: abd\n 1: ab\n   xyd\n 0: d\n\n/\\k<A>*(?<A>aa)(?<A>bb)/match_unset_backref,dupnames\n    aabb\n 0: aabb\n 1: aa\n 2: bb\n\n/(((((a)))))/parens_nest_limit=2\nFailed: error 119 at offset 3: parentheses are too deeply nested\n\n/abc/replace=XYZ\n    123123\n 0: 123123\n    123abc123\n 1: 123XYZ123\n    123abc123abc123\n 1: 123XYZ123abc123\n    123123\\=zero_terminate\n 0: 123123\n    123abc123\\=zero_terminate\n 1: 123XYZ123\n    123abc123abc123\\=zero_terminate\n 1: 123XYZ123abc123\n\n/abc/g,replace=XYZ\n    123abc123\n 1: 123XYZ123\n    123abc123abc123\n 2: 123XYZ123XYZ123\n\n/abc/replace=X$$Z\n    123abc123\n 1: 123X$Z123\n\n/abc/g,replace=X$$Z\n    123abc123abc123\n 2: 123X$Z123X$Z123\n\n/a(b)c(d)e/replace=X$1Y${2}Z\n    \"abcde\"\n 1: \"XbYdZ\"\n\n/a(b)c(d)e/replace=X$1Y${2}Z,global\n    \"abcde-abcde\"\n 2: \"XbYdZ-XbYdZ\"\n\n/a(?<ONE>b)c(?<TWO>d)e/replace=X$ONE+${TWO}Z\n    \"abcde\"\n 1: \"Xb+dZ\"\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z\n    \"abcde-abcde-\"\n 2: \"Xb+dZ-Xb+dZ-\"\n\n/abc/replace=a$++\n    123abc\nFailed: error -35 at offset 2 in replacement: invalid replacement string\n\n/abc/replace=a$bad\n    123abc\nFailed: error -49 at offset 5 in replacement: unknown substring\n\n/abc/replace=a${A234567890123456789_123456789012}z\n    123abc\nFailed: error -49 at offset 36 in replacement: unknown substring\n\n/abc/replace=a${A23456789012345678901234567890123}z\n    123abc\nFailed: error -35 at offset 35 in replacement: invalid replacement string\n\n/abc/replace=a${bcd\n    123abc\nFailed: error -58 at offset 6 in replacement: expected closing curly bracket in replacement string\n\n/abc/replace=a${b+d}z\n    123abc\nFailed: error -58 at offset 4 in replacement: expected closing curly bracket in replacement string\n\n/abc/replace=[10]XYZ\n    123abc123\n 1: 123XYZ123\n\n/abc/replace=[9]XYZ\n    123abc123\nFailed: error -48: no more memory\n\n/abc/replace=xyz\n    1abc2\\=partial_hard\nFailed: error -34: bad option value\n\n/abc/replace=xyz\n    123abc456\n 1: 123xyz456\n    123abc456\\=replace=pqr\n 1: 123pqr456\n    123abc456abc789\n 1: 123xyz456abc789\n    123abc456abc789\\=g\n 2: 123xyz456xyz789\n\n/(?<=abc)(|def)/g,replace=<$0>\n    123abcxyzabcdef789abcpqr\n 4: 123abc<>xyzabc<><def>789abc<>pqr\n\n/./replace=$0\n    a\n 1: a\n\n/(.)(.)/replace=$2+$1\n    abc\n 1: b+ac\n\n/(?<A>.)(?<B>.)/replace=$B+$A\n    abc\n 1: b+ac\n\n/(.)(.)/g,replace=$2$1\n    abcdefgh\n 4: badcfehg\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=${*MARK}\n    apple lemon blackberry\n 3: pear orange strawberry\n    apple strudel\n 1: pear strudel\n    fruitless\n 0: fruitless\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/replace=${*MARK} sauce,\n    apple lemon blackberry\n 1: pear sauce lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARK>\n    apple lemon blackberry\n 3: <pear> <orange> <strawberry>\n    apple strudel\n 1: <pear> strudel\n    fruitless\n 0: fruitless\n\n/(*:pear)apple/g,replace=${*MARKING}\n    apple lemon blackberry\nFailed: error -35 at offset 11 in replacement: invalid replacement string\n\n/(*:pear)apple/g,replace=${*MARK-time\n    apple lemon blackberry\nFailed: error -58 at offset 7 in replacement: expected closing curly bracket in replacement string\n\n/(*:pear)apple/g,replace=${*mark}\n    apple lemon blackberry\nFailed: error -35 at offset 8 in replacement: invalid replacement string\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARKET>\n    apple lemon blackberry\nFailed: error -35 at offset 9 in replacement: invalid replacement string\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[22]${*MARK}\n    apple lemon blackberry\nFailed: error -48: no more memory\n    apple lemon blackberry\\=substitute_overflow_length\nFailed: error -48: no more memory: 23 code units are needed\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[23]${*MARK}\n    apple lemon blackberry\n 3: pear orange strawberry\n\n/abc/\n    123abc123\\=replace=[9]XYZ\nFailed: error -48: no more memory\n    123abc123\\=substitute_overflow_length,replace=[9]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[6]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[1]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[0]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n\n/a(b)c/\n    123abc123\\=replace=[9]x$1z\nFailed: error -48: no more memory\n    123abc123\\=substitute_overflow_length,replace=[9]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[6]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[1]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[0]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n\n\"((?=(?(?=(?(?=(?(?=()))))))))\"\n    a\n 0: \n 1: \n 2: \n\n\"(?(?=)==)(((((((((?=)))))))))\"\n\\= Expect no match\n    a\nNo match\n\n/(a)(b)|(c)/\n    XcX\\=ovector=2,get=1,get=2,get=3,get=4,getall\nMatched, but too many substrings\n 0: c\n 1: <unset>\nGet substring 1 failed (-55): requested value is not set\nGet substring 2 failed (-54): requested value is not available\nGet substring 3 failed (-54): requested value is not available\nGet substring 4 failed (-49): unknown substring\n 0L c\n 1L \n\n/x(?=ab\\K)/allow_lookaround_bsk\n    xab\\=get=0\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0G  (0)\n    xab\\=copy=0\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0C  (0)\n    xab\\=getall\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0L \n\n/(?<A>a)|(?<A>b)/dupnames\n    a\\=ovector=1,copy=A,get=A,get=2\nMatched, but too many substrings\n 0: a\nCopy substring 'A' failed (-54): requested value is not available\nGet substring 2 failed (-54): requested value is not available\nGet substring 'A' failed (-54): requested value is not available\n    a\\=ovector=2,copy=A,get=A,get=2\n 0: a\n 1: a\n  C a (1) A (non-unique)\nGet substring 2 failed (-54): requested value is not available\n  G a (1) A (non-unique)\n    b\\=ovector=2,copy=A,get=A,get=2\nMatched, but too many substrings\n 0: b\n 1: <unset>\nCopy substring 'A' failed (-55): requested value is not set\nGet substring 2 failed (-54): requested value is not available\nGet substring 'A' failed (-55): requested value is not set\n\n/a(b)c(d)/\n    abc\\=ph,copy=0,copy=1,getall\nPartial match: abc\n 0C abc (3)\nCopy substring 1 failed (-2): partial match\nget substring list failed (-2): partial match\n\n/^abc/info\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/^abc/info,no_dotstar_anchor\nCapture group count = 0\nCompile options: no_dotstar_anchor\nOverall options: anchored no_dotstar_anchor\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/.*\\d/info,auto_callout\nCapture group count = 0\nOptions: auto_callout\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\\= Expect no match\n    aaa\n--->aaa\n +0 ^       .*\n +2 ^  ^    \\d\n +2 ^ ^     \\d\n +2 ^^      \\d\n +2 ^       \\d\nNo match\n\n/.*\\d/info,no_dotstar_anchor,auto_callout\nCapture group count = 0\nOptions: auto_callout no_dotstar_anchor\nSubject length lower bound = 1\n\\= Expect no match\n    aaa\n--->aaa\n +0 ^       .*\n +2 ^  ^    \\d\n +2 ^ ^     \\d\n +2 ^^      \\d\n +2 ^       \\d\n +0  ^      .*\n +2  ^ ^    \\d\n +2  ^^     \\d\n +2  ^      \\d\n +0   ^     .*\n +2   ^^    \\d\n +2   ^     \\d\nNo match\n\n/.*\\d/dotall,info\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 1\n\n/.*\\d/dotall,no_dotstar_anchor,info\nCapture group count = 0\nOptions: dotall no_dotstar_anchor\nSubject length lower bound = 1\n\n/(*NO_DOTSTAR_ANCHOR)(?s).*\\d/info\nCapture group count = 0\nCompile options: <none>\nOverall options: no_dotstar_anchor\nSubject length lower bound = 1\n\n'^(?:(a)|b)(?(1)A|B)'\n    aA123\\=ovector=1\nMatched, but too many substrings\n 0: aA\n    aA123\\=ovector=2\n 0: aA\n 1: a\n\n'^(?:(?<AA>a)|b)(?(<AA>)A|B)'\n    aA123\\=ovector=1\nMatched, but too many substrings\n 0: aA\n    aA123\\=ovector=2\n 0: aA\n 1: a\n\n'^(?<AA>)(?:(?<AA>a)|b)(?(<AA>)A|B)'dupnames\n    aA123\\=ovector=1\nMatched, but too many substrings\n 0: aA\n    aA123\\=ovector=2\nMatched, but too many substrings\n 0: aA\n 1: \n    aA123\\=ovector=3\n 0: aA\n 1: \n 2: a\n\n'^(?:(?<AA>X)|)(?:(?<AA>a)|b)\\k{AA}'dupnames\n    aa123\\=ovector=1\nMatched, but too many substrings\n 0: aa\n    aa123\\=ovector=2\nMatched, but too many substrings\n 0: aa\n 1: <unset>\n    aa123\\=ovector=3\n 0: aa\n 1: <unset>\n 2: a\n\n/(?<N111>(?J)(?<N111>1(111111)11|)1|1|)(?(<N111>)1)/\n\n/(?<N>(?J)(?<N>))(?-J)\\k<N>/\n\n# Quantifiers are not allowed on condition assertions, but are otherwise\n# OK in conditions.\n\n/(?(?=0)?)+/\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/(?(?=0)(?=00)?00765)/\n     00765\n 0: 00765\n\n/(?(?=0)(?=00)?00765|(?!3).56)/\n     00765\n 0: 00765\n     456\n 0: 456\n\\= Expect no match\n     356\nNo match\n\n'^(a)*+(\\w)'\n    g\n 0: g\n 1: <unset>\n 2: g\n    g\\=ovector=1\nMatched, but too many substrings\n 0: g\n\n'^(?:a)*+(\\w)'\n    g\n 0: g\n 1: g\n    g\\=ovector=1\nMatched, but too many substrings\n 0: g\n\n# These two pattern showeds up compile-time bugs\n\n\"((?2){0,1999}())?\"\n\n/((?+1)(\\1))/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Recurse\n        CBra 2\n        \\1\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# Callouts with string arguments\n\n/a(?C\"/\nFailed: error 181 at offset 4: missing terminating delimiter for callout with string argument\n\n/a(?C\"a/\nFailed: error 181 at offset 4: missing terminating delimiter for callout with string argument\n\n/a(?C\"a\"/\nFailed: error 139 at offset 7: closing parenthesis for (?C expected\n\n/a(?C\"a\"bcde(?C\"b\")xyz/\nFailed: error 139 at offset 7: closing parenthesis for (?C expected\n\n/a(?C\"a)b\"\"c\")/B\n------------------------------------------------------------------\n        Bra\n        a\n        CalloutStr \"a)b\"c\" 5 13 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/ab(?C\" any text with spaces \")cde/B\n------------------------------------------------------------------\n        Bra\n        ab\n        CalloutStr \" any text with spaces \" 6 30 1\n        cde\n        Ket\n        End\n------------------------------------------------------------------\n    abcde\nCallout (6): \" any text with spaces \"\n--->abcde\n    ^ ^       c\n 0: abcde\n    12abcde\nCallout (6): \" any text with spaces \"\n--->12abcde\n      ^ ^       c\n 0: abcde\n\n/^a(b)c(?C1)def/\n      abcdef\n--->abcdef\n  1 ^  ^       d\n 0: abcdef\n 1: b\n\n/^a(b)c(?C\"AB\")def/\n      abcdef\nCallout (10): \"AB\"\n--->abcdef\n    ^  ^       d\n 0: abcdef\n 1: b\n\n/^a(b)c(?C1)def/\n      abcdef\\=callout_capture\nCallout 1: last capture = 1\n 1: b\n--->abcdef\n    ^  ^       d\n 0: abcdef\n 1: b\n\n/^a(b)c(?C{AB})def/B\n------------------------------------------------------------------\n        Bra\n        ^\n        a\n        CBra 1\n        b\n        Ket\n        c\n        CalloutStr {AB} 10 14 1\n        def\n        Ket\n        End\n------------------------------------------------------------------\n      abcdef\\=callout_capture\nCallout (10): {AB} last capture = 1\n 1: b\n--->abcdef\n    ^  ^       d\n 0: abcdef\n 1: b\n\n/(?C`a``b`)(?C'a''b')(?C\"a\"\"b\")(?C^a^^b^)(?C%a%%b%)(?C#a##b#)(?C$a$$b$)(?C{a}}b})/B,callout_info\n------------------------------------------------------------------\n        Bra\n        CalloutStr `a`b` 4 10 0\n        CalloutStr 'a'b' 14 20 0\n        CalloutStr \"a\"b\" 24 30 0\n        CalloutStr ^a^b^ 34 40 0\n        CalloutStr %a%b% 44 50 0\n        CalloutStr #a#b# 54 60 0\n        CalloutStr $a$b$ 64 70 0\n        CalloutStr {a}b} 74 80 0\n        Ket\n        End\n------------------------------------------------------------------\nCallout `a`b`  (\nCallout 'a'b'  (\nCallout \"a\"b\"  (\nCallout ^a^b^  (\nCallout %a%b%  (\nCallout #a#b#  (\nCallout $a$b$  (\nCallout {a}b}  \n\n/(?:a(?C`code`)){3}/B\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        CalloutStr `code` 8 14 4\n        Ket\n        Bra\n        a\n        CalloutStr `code` 8 14 4\n        Ket\n        Bra\n        a\n        CalloutStr `code` 8 14 4\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?(?C25)(?=abc)abcd|xyz)/B,callout_info\n------------------------------------------------------------------\n        Bra\n        ^\n        Cond\n        Callout 25 9 3\n        Assert\n        abc\n        Ket\n        abcd\n        Alt\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCallout 25  (?=\n    abcdefg\n--->abcdefg\n 25 ^           (?=\n 0: abcd\n    xyz123\n--->xyz123\n 25 ^          (?=\n 0: xyz\n\n/^(?(?C$abc$)(?=abc)abcd|xyz)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Cond\n        CalloutStr $abc$ 7 12 3\n        Assert\n        abc\n        Ket\n        abcd\n        Alt\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    abcdefg\nCallout (7): $abc$\n--->abcdefg\n    ^           (?=\n 0: abcd\n    xyz123\nCallout (7): $abc$\n--->xyz123\n    ^          (?=\n 0: xyz\n\n/^ab(?C'first')cd(?C\"second\")ef/\n    abcdefg\nCallout (7): 'first'\n--->abcdefg\n    ^ ^         c\nCallout (20): \"second\"\n--->abcdefg\n    ^   ^       e\n 0: abcdef\n\n/(?:a(?C`code`)){3}X/\n    aaaXY\nCallout (8): `code`\n--->aaaXY\n    ^^        ){3}\nCallout (8): `code`\n--->aaaXY\n    ^ ^       ){3}\nCallout (8): `code`\n--->aaaXY\n    ^  ^      ){3}\n 0: aaaX\n\n# Binary zero in callout string\n#  a  (  ?  C  '  x     z  '  )  b\n/ 61 28 3f 43 27 78 00 7a 27 29 62/hex,callout_info\nCallout 'x\\x00z'  b\n    abcdefgh\nCallout (5): 'x\\x00z'\n--->abcdefgh\n    ^^           b\n 0: ab\n\n/(?(?!)^)/\n\n/(?(?!)a|b)/\n    bbb\n 0: b\n\\= Expect no match\n    aaa\nNo match\n\n# JIT gives a different error message for the infinite recursion\n\n\"(*NO_JIT)((?2)+)((?1)){\"\n    abcd{\nFailed: error -52: nested recursion at the same subject position\n\n# Perl fails to diagnose the absence of an assertion\n\n\"(?(?<E>.*!.*)?)\"\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n\"X((?2)()*+){2}+\"B\n------------------------------------------------------------------\n        Bra\n        X\n        Once\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n\"X((?2)()*+){2}\"B\n------------------------------------------------------------------\n        Bra\n        X\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<=\\bABQ(3(?-7)))/\nFailed: error 115 at offset 15: reference to non-existent subpattern\n\n/(?<=\\bABQ(3(?+7)))/\nFailed: error 115 at offset 15: reference to non-existent subpattern\n\n\";(?<=()((?3))((?2)))\"\nFailed: error 125 at offset 1: lookbehind assertion is not fixed length\n\n# Perl loops on this (PCRE2 used to!)\n\n/(?<=\\Ka)/g,aftertext,allow_lookaround_bsk\n    aaaaa\n 0: a\n 0+ aaaa\n 0: a\n 0+ aaa\n 0: a\n 0+ aa\n 0: a\n 0+ a\n 0: a\n 0+ \n\n/(?<=\\Ka)/altglobal,aftertext,allow_lookaround_bsk\n    aaaaa\n 0: a\n 0+ aaaa\n 0: a\n 0+ aaa\n 0: a\n 0+ aa\n 0: a\n 0+ a\n 0: a\n 0+ \n\n/((?2){73}(?2))((?1))/info\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/abc/\n\\= Expect no match\n    \\[9x!xxx(]{9999}\nNo match\n\n/(abc)*/\n    \\[abc]{5}\n 0: abcabcabcabcabc\n 1: abc\n\n/^/gm\n    \\n\\n\\n\n 0: \n 0: \n 0: \n\n/^/gm,alt_circumflex\n    \\n\\n\\n\n 0: \n 0: \n 0: \n 0: \n\n/((((((((x))))))))\\81/\nFailed: error 115 at offset 19: reference to non-existent subpattern\n    xx1\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\\80/\n    xx\nMatched, but too many substrings\n 0: xx\n 1: x\n 2: x\n 3: x\n 4: x\n 5: x\n 6: x\n 7: x\n 8: x\n 9: x\n10: x\n11: x\n12: x\n13: x\n14: x\n\n/\\80/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n/A\\8B\\9C/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n    A8B9C\n\n/(?x:((?'a')) # comment (with parentheses) and | vertical\n(?-x:#not a comment (?'b')) # this is a comment ()\n(?'c')) # not a comment (?'d')/info\nCapture group count = 5\nNamed capture groups:\n  a   2\n  b   3\n  c   4\n  d   5\nFirst code unit = '#'\nLast code unit = ' '\nSubject length lower bound = 32\n\n/(?|(?'a')(2)(?'b')|(?'a')(?'a')(3))/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  a   1\n  a   2\n  b   3\nOptions: dupnames\nStarting code units: 2 3 \nSubject length lower bound = 1\n    A23B\n 0: 2\n 1: \n 2: 2\n 3: \n    B32A\n 0: 3\n 1: \n 2: \n 3: 3\n\n# These are some patterns that used to cause buffer overflows or other errors\n# while compiling.\n\n/.((?2)(?R)|\\1|$)()/B\n------------------------------------------------------------------\n        Bra\n        Any\n        CBra 1\n        Recurse\n        Recurse\n        Alt\n        \\1\n        Alt\n        $\n        Ket\n        CBra 2\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/.((?3)(?R)()(?2)|\\1|$)()/B\n------------------------------------------------------------------\n        Bra\n        Any\n        CBra 1\n        Recurse\n        Recurse\n        CBra 2\n        Ket\n        Recurse\n        Alt\n        \\1\n        Alt\n        $\n        Ket\n        CBra 3\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(\\9*+(?2);\\3++()2|)++{/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n/\\V\\x85\\9*+((?2)\\3++()2)*:2/\nFailed: error 115 at offset 7: reference to non-existent subpattern\n\n/(((?(R)){0,2}) (?'x'((?'R')((?'R')))))/dupnames\n\n/(((?(X)){0,2}) (?'x'((?'X')((?'X')))))/dupnames\n\n/(((?(R)){0,2}) (?'x'((?'X')((?'R')))))/\n\n\"(?J)(?'d'(?'d'\\g{d}))\"\n\n\"(?=!((?2)(?))({8(?<=(?1){29}8bbbb\\x16\\xd\\xc6^($(\\xa9H4){4}h}?1)B))\\x15')\"\nFailed: error 125 at offset 16: lookbehind assertion is not fixed length\n\n/A(?'')Z/\nFailed: error 162 at offset 4: subpattern name expected\n\n\"(?J:(?|(?'R')(\\k'R')|((?'R'))))\"\n\n/(?<=|(\\,\\$(?73591620449005828816)\\xa8.{7}){6}\\x09)/\nFailed: error 161 at offset 17: subpattern number is too big\n\n/^(?:(?(1)x|)+)+$()/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SBra\n        SCond\n      1 Cond ref\n        x\n        Alt\n        KetRmax\n        KetRmax\n        $\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/[[:>:]](?<)/\nFailed: error 162 at offset 10: subpattern name expected\n\n/((?x)(*:0))#(?'/\nFailed: error 162 at offset 15: subpattern name expected\n\n/(?C$[$)(?<]/\nFailed: error 162 at offset 10: subpattern name expected\n\n/(?C$)$)(?<]/\nFailed: error 162 at offset 10: subpattern name expected\n\n/(?(R))*+/B\n------------------------------------------------------------------\n        Bra\n        Braposzero\n        SBraPos\n        SCond\n        Cond recurse any\n        Ket\n        KetRpos\n        Ket\n        End\n------------------------------------------------------------------\n    abcd\n 0: \n\n/((?x)(?#))#(?'/\nFailed: error 162 at offset 14: subpattern name expected\n\n/((?x)(?#))#(?'abc')/I\nCapture group count = 2\nNamed capture groups:\n  abc   2\nFirst code unit = '#'\nSubject length lower bound = 1\n\n/[[:\\\\](?<[::]/\nFailed: error 162 at offset 9: subpattern name expected\n\n/[[:\\\\](?'abc')[a:]/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nStarting code units: : [ \\ \nSubject length lower bound = 2\n\n\"[[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[:::::::::::::::::[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[[[:::E[[[:[:[[:[:::[[:::E[[[:[:[[:'[:::::E[[[:[::::::[[[:[[[[[[[::E[[[:[::::::[[[:[[[[[[[[:[[::[::::[[:::::::[[:[[[[[[[:[[::[:[[:[~\"\nFailed: error 106 at offset 353: missing terminating ] for character class\n\n/()(?(R)0)*+/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        Braposzero\n        SBraPos\n        SCond\n        Cond recurse any\n        0\n        Ket\n        KetRpos\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?R-:(?</\nFailed: error 158 at offset 3: (?R (recursive pattern call) must be followed by a closing parenthesis\n\n/(?R-:(?<)/\nFailed: error 158 at offset 3: (?R (recursive pattern call) must be followed by a closing parenthesis\n\n/(?(?C{\\Q})(?!(?'/\nFailed: error 162 at offset 16: subpattern name expected\n\n/(?(?C{\\Q})(?!(?'abc')))/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nMay match empty string\nSubject length lower bound = 0\n\n/(?1){3918}(((((0(\\k'R'))))(?J)(?'R'(?'R'\\3){99})))/I\nCapture group count = 8\nMax back reference = 8\nNamed capture groups:\n  R   7\n  R   8\nDuplicate name status changes\nLast code unit = '0'\nSubject length lower bound = 65535\n\n/(?|(aaa)|(b))\\g{1}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?|(aaa)|(b))(?1)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 4\n\n/(?|(aaa)|(b))/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?|(?'a'aaa)|(?'a'b))\\k'a'/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  a   1\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?|(?'a'aaa)|(?'a'b))(?'a'cccc)\\k'a'/I,dupnames\nCapture group count = 2\nMax back reference = 2\nNamed capture groups:\n  a   1\n  a   2\nOptions: dupnames\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 5\n\n/ab{3cd/\n    ab{3cd\n 0: ab{3cd\n\n/ab{3,cd/\n    ab{3,cd\n 0: ab{3,cd\n\n/ab{3,4a}cd/\n    ab{3,4a}cd\n 0: ab{3,4a}cd\n\n/{4,5a}bc/\n    {4,5a}bc\n 0: {4,5a}bc\n\n/\\x0{ab}/\n    \\0{ab}\n 0: \\x00{ab}\n\n/^(a(b))\\1\\g1\\g{1}\\g-1\\g{-1}\\g{-02}Z/\n    ababababbbabZXXXX\n 0: ababababbbabZ\n 1: ab\n 2: b\n\n/.*?a(*PRUNE)b/\n    aab\n 0: ab\n\n/.*?a(*PRUNE)b/s\n    aab\n 0: ab\n\n/^a(*PRUNE)b/s\n\\= Expect no match\n    aab\nNo match\n\n/.*?a(*SKIP)b/\n    aab\n 0: ab\n\n/(?(8000000000/\nFailed: error 161 at offset 8: subpattern number is too big\n\n/((?(R8000000000)))/\nFailed: error 161 at offset 9: subpattern number is too big\n\n/0(?0)|(1)(*THEN)(*SKIP:0)(*FAIL)/\n\\= Expect no match\n    01\nNo match\n\n/(?(1)()\\983040\\2)/\nFailed: error 161 at offset 14: subpattern number is too big\n\n/(*LIMIT_MATCH=)abc/\nFailed: error 160 at offset 14: (*VERB) not recognized or malformed\n\n/(*CRLF)(*LIMIT_MATCH=)abc/\nFailed: error 160 at offset 21: (*VERB) not recognized or malformed\n\n/(?:ab)?(?:ab)(?:ab)/\n    abab\n 0: abab\n    ababab\n 0: ababab\n\\= Expect no match\n    aba\nNo match\n\n/((*MARK:A))++a(*SKIP:B)b/\n\\= Expect no match\n    aacb\nNo match\n\n/(*MARK:a\\zb)z/alt_verbnames\nFailed: error 140 at offset 10: invalid escape sequence in (*VERB) name\n\n/(*:ab\\t(d\\)c)xxx/\nFailed: error 122 at offset 12: unmatched closing parenthesis\n\n/(*:ab\\t(d\\)c)xxx/alt_verbnames,mark\n    cxxxz\n 0: xxx\nMK: ab\\x09(d)c\n\n/(*:A\\Qxx)x\\EB)x/alt_verbnames,mark\n    x\n 0: x\nMK: Axx)xB\n\n/(*:A\\ExxxB)x/alt_verbnames,mark\n    x\n 0: x\nMK: AxxxB\n\n/(*: A \\ and #comment\n     \\ B)x/x,alt_verbnames,mark\n    x\n 0: x\nMK: A and B\n\n/(*: A \\ and #comment\n     \\ B)x/alt_verbnames,mark\n    x\n 0: x\nMK:  A  and #comment\\x0a      B\n\n/(*: A \\ and #comment\n     \\ B)x/x,mark\n    x\n 0: x\nMK:  A \\ and #comment\\x0a     \\ B\n\n/(*: A \\ and #comment\n     \\ B)x/mark\n    x\n 0: x\nMK:  A \\ and #comment\\x0a     \\ B\n\n/(*:A\nB)x/alt_verbnames,mark\n    x\n 0: x\nMK: A\\x0aB\n\n/(*:abc\\Qpqr)/alt_verbnames\nFailed: error 160 at offset 12: (*VERB) not recognized or malformed\n\n/abc/use_offset_limit\n    1234abcde\\=offset_limit=100\n 0: abc\n    1234abcde\\=offset_limit=9\n 0: abc\n    1234abcde\\=offset_limit=4\n 0: abc\n    1234abcde\\=offset_limit=4,offset=4\n 0: abc\n\\= Expect no match\n    1234abcde\\=offset_limit=4,offset=5\nNo match\n    1234abcde\\=offset_limit=3\nNo match\n\n/(?<=abc)/use_offset_limit\n    1234abc\\=offset_limit=7\n 0: \n\\= Expect no match\n    1234abc\\=offset_limit=6\nNo match\n\n/A/g,replace=-,use_offset_limit\n    XAXAXAXAXA\\=offset_limit=4\n 2: X-X-XAXAXA\n\n/abc/\n\\= Expect error\n    1234abcde\\=offset_limit=4\nFailed: error -56: offset limit set without PCRE2_USE_OFFSET_LIMIT\n\n/^\\w/m,use_offset_limit\n    \\n..\\naa\\=offset_limit=3\nNo match\n    \\n..\\naa\\=offset_limit=4\n 0: a\n\n/abcd/null_context\n    abcd\\=null_context\n 0: abcd\n\\= Expect error - not allowed together\n    abcd\\=null_context,find_limits\n** Not allowed together: find_limits null_context\n    abcd\\=allusedtext,startchar\n** Not allowed together: allusedtext startchar\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended\n    abcd\n 1: w\\x0dx\\x82y\\xdbz(12\\$34$$\\x345$)\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended,substitute_literal\n    >>abcd<<\n 1: >>w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$)<<\n    \n/abcd/g,replace=\\$1$2\\,substitute_literal\n    XabcdYabcdZ\n 2: X\\$1$2\\Y\\$1$2\\Z\n\n/a(bc)(DE)/replace=a\\u$1\\U$1\\E$1\\l$2\\L$2\\Eab\\Uab\\LYZ\\EDone,substitute_extended\n    abcDE\n 1: aBcBCbcdEdeabAByzDone\n\n/abcd/replace=xy\\kz,substitute_extended\n    abcd\nFailed: error -57 at offset 4 in replacement: bad escape sequence in replacement string\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:+1:-1}X${2:+2:-2}\n    ab\n 1: X1X-2\n    ac\n 1: X-1X2\n    ab\\=replace=${1:+$1\\:$1:$2}\n 1: b:b\n    ac\\=replace=${1:+$1\\:$1:$2}\n 1: c\n    >>ac<<\\=replace=${1:+$1\\:$1:$2},substitute_literal\n 1: >>${1:+$1\\:$1:$2}<<\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:-1:-1}X${2:-2:-2}\n    ab\n 1: XbX2:-2\n    ac\n 1: X1:-1Xc\n\n/(a)/substitute_extended,replace=>${1:+\\Q$1:{}$$\\E+\\U$1}<\n    a\n 1: >$1:{}$$+A<\n\n/X(b)Y/substitute_extended\n    XbY\\=replace=x${1:+$1\\U$1}y\n 1: xbBY\n    XbY\\=replace=\\Ux${1:+$1$1}y\n 1: XBBY\n\n/a/substitute_extended,replace=${*MARK:+a:b}\n    a\nFailed: error -58 at offset 7 in replacement: expected closing curly bracket in replacement string\n\n/(abcd)/replace=${1:+xy\\kz},substitute_extended\n    abcd\nFailed: error -57 at offset 8 in replacement: bad escape sequence in replacement string\n\n/(abcd)/\n    abcd\\=replace=${1:+xy\\kz},substitute_extended\nFailed: error -57 at offset 8 in replacement: bad escape sequence in replacement string\n\n/abcd/substitute_extended,replace=>$1<\n    abcd\nFailed: error -49 at offset 3 in replacement: unknown substring\n\n/abcd/substitute_extended,replace=>xxx${xyz}<<<\n    abcd\nFailed: error -49 at offset 10 in replacement: unknown substring\n\n/(?J)(?:(?<A>a)|(?<A>b))/replace=<$A>\n    [a]\n 1: [<a>]\n    [b]\n 1: [<b>]\n\\= Expect error\n    (a)\\=ovector=1\nFailed: error -54 at offset 3 in replacement: requested value is not available\n\n/(a)|(b)/replace=<$1>\n\\= Expect error\n    b\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/(aa)(BB)/substitute_extended,replace=\\U$1\\L$2\\E$1..\\U$1\\l$2$1\n    aaBB\n 1: AAbbaa..AAbBaa\n    \n/abcd/replace=wxyz,substitute_matched\n    abcd\n 1: wxyz\n    pqrs \n 0: pqrs\n\n/abcd/g\n    >abcd1234abcd5678<\\=replace=wxyz,substitute_matched\n 2: >wxyz1234wxyz5678<\n\n/^(o(\\1{72}{\\\"{\\\\{00000059079}\\d*){74}}){19}/I\nCapture group count = 2\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'o'\nLast code unit = '}'\nSubject length lower bound = 65535\n\n/((p(?'K/\nFailed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)\n\n/((p(?'K/no_auto_capture\nFailed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)\n\n/abc/replace=A$3123456789Z\n    abc\nFailed: error -49 at offset 3 in replacement: unknown substring\n\n/(?<!a{65535}a{5})x/I\nFailed: error 187 at offset 0: lookbehind assertion is too long\n\n/(?<!a{65535})x/I\nCapture group count = 0\nMax lookbehind = 65535\nFirst code unit = 'x'\nSubject length lower bound = 1\n\n/(?=a\\K)/replace=z,allow_lookaround_bsk\n    BaCaD\nFailed: error -60: match with end before start or start moved backwards is not supported\n    \n/(?<=\\K.)/g,replace=-,allow_lookaround_bsk\n    ab\nFailed: error -60: match with end before start or start moved backwards is not supported\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEFG'toolong)/\nFailed: error 148 at offset 36: subpattern name is too long (maximum 32 code units)\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEF'justright)/\n\n# These two use zero-termination\n/abcd/max_pattern_length=3\nFailed: error 188 at offset 0: pattern string is longer than the limit set by the application\n\n/abc/max_pattern_length=3\n\n# These two, being hex, pass the length\n/abcdefab/hex,max_pattern_length=3\nFailed: error 188 at offset 0: pattern string is longer than the limit set by the application\n\n/abcdef/hex,max_pattern_length=3\n\n# These patterns used to take a long time to compile\n\n\"(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\nCapture group count = 12\nMay match empty string\nOptions: extended\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n\"(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\nCapture group count = 12\nMax lookbehind = 2\nMay match empty string\nOptions: extended\nSubject length lower bound = 0\n\n\"(?|()|())(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\nCapture group count = 13\nMay match empty string\nOptions: extended\nSubject length lower bound = 0\n\n\"(?|()|())(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\nFailed: error 135 at offset 9: lookbehind is too complicated\n\n# Test the use of malloc for caching group information when there are more\n# groups than fit into the on-stack workspace.\n\n/\\[()]{1024}/I,expand\nExpanded: ()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()\nCapture group count = 1024\nMay match empty string\nSubject length lower bound = 0\n\n# Test minlength capped at 65535\n\n/(A{65000})\\1{65000}/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'A'\nLast code unit = 'A'\nSubject length lower bound = 65535\n\n# Test group scans when numbers are not unique\n\n/(?|()+|(a)+)/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        SCBra 1\n        KetRmax\n        Alt\n        CBra 1\n        a\n        KetRmax\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/(?|(a)+|()+)/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        a\n        KetRmax\n        Alt\n        SCBra 1\n        KetRmax\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/(?|()|(a))/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        Ket\n        Alt\n        CBra 1\n        a\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/(?|(a)|())/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        a\n        Ket\n        Alt\n        CBra 1\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n# Test CRLF handling in empty string substitutions\n\n/^$/gm,newline=anycrlf,replace=-\n    X\\r\\n\\r\\nY\n 1: X\\x0d\\x0a-\\x0d\\x0aY\n\n/^$/gm,newline=crlf,replace=-\n    X\\r\\n\\r\\nY\n 1: X\\x0d\\x0a-\\x0d\\x0aY\n\n/^$/gm,newline=any,replace=-\n    X\\r\\n\\r\\nY\n 1: X\\x0d\\x0a-\\x0d\\x0aY\n\n\"(*ANYCRLF)(?m)^(.*[^0-9\\r\\n].*|)$\"g,replace=NaN\n    15\\r\\nfoo\\r\\n20\\r\\nbar\\r\\nbaz\\r\\n\\r\\n20\n 4: 15\\x0d\\x0aNaN\\x0d\\x0a20\\x0d\\x0aNaN\\x0d\\x0aNaN\\x0d\\x0aNaN\\x0d\\x0a20\n\n/a[[:punct:]b]/bincode\n------------------------------------------------------------------\n        Bra\n        a\n        [!-/:-@[-`b{-~]\n        Ket\n        End\n------------------------------------------------------------------\n\n/a[b[:punct:]]/bincode\n------------------------------------------------------------------\n        Bra\n        a\n        [!-/:-@[-`b{-~]\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B\n------------------------------------------------------------------\n        Bra\n        L?+\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        L?\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 14\n        L?+\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B,no_auto_possess,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 14\n        L?\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/(A*)\\E+/B,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        SCBra 1\n        Callout 255 1 2\n        A*\n        Callout 255 3 4\n        KetRmax\n        Callout 255 7 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/()\\Q\\E*]/B,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        Brazero\n        SCBra 1\n        Callout 255 1 6\n        KetRmax\n        Callout 255 7 1\n        ]\n        Callout 255 8 0\n        Ket\n        End\n------------------------------------------------------------------\n    a[bc]d\n--->a[bc]d\n +0     ^      (\n +1     ^      )\\Q\\E*\n +7     ^      ]\n +8     ^^     End of pattern\n 0: ]\n 1: \n\n/\\x8a+f|;T?(*:;.'?`(\\xeap ){![^()!y*''C*(?';]{1;(\\x08)/B,alt_verbnames,dupnames,extended\n------------------------------------------------------------------\n        Bra\n        \\x{8a}++\n        f\n        Alt\n        ;\n        T?\n        *MARK ;.'?`(\\x{ea}p\n        {!\n        [\\x00- \"-&+-:<->@-BD-xz-\\xff] (neg)\n        {1;\n        CBra 1\n        \\x08\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# Tests for NULL characters in comments and verb \"names\" and callouts\n\n# /A#B\\x00C\\x0aZ/\n/41 23 42 00 43 0a 5a/Bx,hex\n------------------------------------------------------------------\n        Bra\n        AZ\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A+#B\\x00C\\x0a+/\n/41 2b 23 42 00 43 0a 2b/Bx,hex\n------------------------------------------------------------------\n        Bra\n        A++\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex,alt_verbnames\n------------------------------------------------------------------\n        Bra\n        A\n        *MARK B\\x{0}WC\n        Z\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex\n------------------------------------------------------------------\n        Bra\n        A\n        *MARK B\\x{0}W#X\\x{0}Y\\x{a}C\n        Z\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(?C{X\\x00Y})B/\n/41 28 3f 43 7b 58 00 59 7d 29 42/B,hex\n------------------------------------------------------------------\n        Bra\n        A\n        CalloutStr {X\\x{0}Y} 5 10 1\n        B\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(?#X\\x00Y)B/\n/41 28 3f 23 7b 00 7d 29 42/B,hex\n------------------------------------------------------------------\n        Bra\n        AB\n        Ket\n        End\n------------------------------------------------------------------\n\n# Tests for leading comment in extended patterns\n\n/ (?-x):?/extended\n\n/\u000b(?-x):?/extended\n\n/0b 28 3f 2d 78 29 3a/hex,extended\n\n/#comment\n(?-x):?/extended\n\n/(8(*:6^\\x09x\\xa6l\\)6!|\\xd0:[^:|)\\x09d\\Z\\d{85*m(?'(?<1!)*\\W[*\\xff]!!h\\w]*\\xbe;/alt_bsux,alt_verbnames,allow_empty_class,dollar_endonly,extended,multiline,never_utf,no_dotstar_anchor,no_start_optimize\nFailed: error 162 at offset 49: subpattern name expected\n\n/a|(b)c/replace=>$1<,substitute_unset_empty\n    cat\n 1: c><t\n    xbcom\n 1: x>b<om\n\n/a|(b)c/\n    cat\\=replace=>$1<\nFailed: error -55 at offset 3 in replacement: requested value is not set\n    cat\\=replace=>$1<,substitute_unset_empty\n 1: c><t\n    xbcom\\=replace=>$1<,substitute_unset_empty\n 1: x>b<om\n\n/a|(b)c/substitute_extended\n    cat\\=replace=>${2:-xx}<\nFailed: error -49 at offset 9 in replacement: unknown substring\n    cat\\=replace=>${2:-xx}<,substitute_unknown_unset\n 1: c>xx<t\n    cat\\=replace=>${X:-xx}<,substitute_unknown_unset\n 1: c>xx<t\n\n/a|(?'X'b)c/replace=>$X<,substitute_unset_empty\n    cat\n 1: c><t\n    xbcom\n 1: x>b<om\n\n/a|(?'X'b)c/replace=>$Y<,substitute_unset_empty\n    cat\nFailed: error -49 at offset 3 in replacement: unknown substring\n    cat\\=substitute_unknown_unset\n 1: c><t\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/a|(b)c/replace=>$2<,substitute_unset_empty\n    cat\nFailed: error -49 at offset 3 in replacement: unknown substring\n    cat\\=substitute_unknown_unset\n 1: c><t\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/()()()/use_offset_limit\n    \\=ovector=11000000000\n** Invalid value in 'ovector=11000000000'\n    \\=callout_fail=11000000000\n** Invalid value in 'callout_fail=11000000000'\n    \\=callout_fail=1:11000000000\n** Invalid value in 'callout_fail=1:11000000000'\n    \\=callout_data=11000000000\n** Invalid value in 'callout_data=11000000000'\n    \\=callout_data=-11000000000\n** Invalid value in 'callout_data=-11000000000'\n    \\=offset_limit=1100000000000000000000\n** Invalid value in 'offset_limit=1100000000000000000000'\n    \\=copy=11000000000\n** Invalid value in 'copy=11000000000'\n\n/(*MARK:A\\x00b)/mark\n    abc\n 0: \nMK: A\\x00b\n\n/(*MARK:A\\x00b)/mark,alt_verbnames\n    abc\n 0: \nMK: A\\x00b\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex\n    abc\n 0: \nMK: A\\x00b\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex,alt_verbnames\n    abc\n 0: \nMK: A\\x00b\n\n/efg/hex\n** Unexpected non-hex-digit 'g' at offset 2 in hex pattern: quote missing?\n\n/eff/hex\n** Odd number of digits in hex pattern\n\n/effg/hex\n** Unexpected non-hex-digit 'g' at offset 3 in hex pattern: quote missing?\n\n/(?J)(?'a'))(?'a')/\nFailed: error 122 at offset 10: unmatched closing parenthesis\n\n/(?<=((?C)0))/\n    9010\n--->9010\n  0  ^       0\n  0   ^      0\n 0: \n 1: 0\n\\= Expect no match\n    abc\n--->abc\n  0  ^      0\n  0   ^     0\n  0    ^    0\nNo match\n\n/aaa/\n\\[abc]{10000000000000000000000000000}\n** Repeat count too large\n\\[a]{3}\n 0: aaa\n\n/\\[AB]{6000000000000000000000}/expand\n** Pattern repeat count too large\n\n# Hex uses pattern length, not zero-terminated. This tests for overrunning\n# the given length of a pattern.\n\n/'(*U'/hex\nFailed: error 160 at offset 3: (*VERB) not recognized or malformed\n\n/'(*'/hex\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/'('/hex\nFailed: error 114 at offset 1: missing closing parenthesis\n\n//hex\n\n# These tests are here because Perl never allows a back reference in a\n# lookbehind. PCRE2 supports some limited cases.\n\n/([ab])...(?<=\\1)z/\n    a11az\n 0: a11az\n 1: a\n    b11bz\n 0: b11bz\n 1: b\n\\= Expect no match\n    b11az\nNo match\n\n/(?|([ab]))...(?<=\\1)z/\nFailed: error 125 at offset 13: lookbehind assertion is not fixed length\n\n/([ab])(\\1)...(?<=\\2)z/\n    aa11az\n 0: aa11az\n 1: a\n 2: a\n\n/(a\\2)(b\\1)(?<=\\2)/\nFailed: error 125 at offset 10: lookbehind assertion is not fixed length\n\n/(?<A>[ab])...(?<=\\k'A')z/\n    a11az\n 0: a11az\n 1: a\n    b11bz\n 0: b11bz\n 1: b\n\\= Expect no match\n    b11az\nNo match\n\n/(?<A>[ab])...(?<=\\k'A')(?<A>)z/dupnames\nFailed: error 125 at offset 13: lookbehind assertion is not fixed length\n\n# Perl does not support \\g+n\n\n/((\\g+1X)?([ab]))+/\n    aaXbbXa\n 0: aaXbbXa\n 1: bXa\n 2: bX\n 3: a\n\n/ab(?C1)c/auto_callout\n    abc\n--->abc\n +0 ^       a\n +1 ^^      b\n  1 ^ ^     c\n +8 ^  ^    End of pattern\n 0: abc\n\n/'ab(?C1)c'/hex,auto_callout\n    abc\n--->abc\n +0 ^       a\n +1 ^^      b\n  1 ^ ^     c\n +8 ^  ^    End of pattern\n 0: abc\n\n# Perl accepts these, but gives a warning. We can't warn, so give an error.\n\n/[a-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n    a-a9-a\n\n/[A-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n    A-A9-A\n\n/[a-\\d]+/\nFailed: error 150 at offset 5: invalid range in character class\n    a-a9-a\n\n/(?<RA>abc)(?(R)xyz)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        abc\n        Ket\n        Cond\n        Cond recurse any\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<R>abc)(?(R)xyz)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        abc\n        Ket\n        Cond\n      1 Cond ref\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=.*[A-Z])/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/()(?<=(?0))/\nFailed: error 125 at offset 2: lookbehind assertion is not fixed length\n\n/(?<!|!(?<!))/\n\n/(?<!|!|!||||||(?<!)||(?<!)!|!||(?<!)!|!(?<!)!|!|!|!||||!!|<!)!|!||||!|/\n\n/{2,2{2,2/use_length\n\n/.>*?\\g'0/use_length\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/.>*?\\g'0/\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/{\u201e\u00cd\u201e\u00cd\u00cd\u201e\u00cd{'{22{2{{2{'{22{\u0012{22{2{'{22{2{{2{{222{{2{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{222{2\u00c4\u201e\u00cd\u201e\u00cd\u00cd\u201e\u00cd{'{22{2{{2{'{22{\u0012{11{2{'{22{2{{2{{'{22{2{{2{'{22{\u0012{22{1{'{22{2{{2{{222{{2{'{22{2{22{2{'{/auto_callout\n\n//\n\\=get=i00000000000000000000000000000000\n** Group name in 'get' is too long\n\\=get=i2345678901234567890123456789012,get=i1245678901234567890123456789012\n** Too many characters in named 'get' modifiers\n\n\"(?(?C))\"\nFailed: error 128 at offset 6: assertion expected after (?( or (?(?C)\n\n/(?(?(?(?(?(?))))))/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/(?<=(?1))((?s))/anchored\n\n/(*:ab)*/\nFailed: error 109 at offset 6: quantifier does not follow a repeatable item\n\n%(*:\u001e(:\u0011(\u001fsvvvvvvvvvv:]*[   Z!*;[]*[^[]*!^[\u0019+.+{{2,7}'      _\\\\\\\\\\\\\\\\\\\\\\\\\\)?.:..    *w////\\\\\\Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\T\\\\\\\\\\+/?/////'+\\\\\\EEE?/////'+/*+/[^K]?]//(w)%never_backslash_c,alt_verbnames,auto_callout\n\n/./newline=crlf\n    \\=ph\nNo match\n\n/(\\x0e00\\000000\\xc)/replace=\\P,substitute_extended\n    \\x0e00\\000000\\xc\nFailed: error -57 at offset 2 in replacement: bad escape sequence in replacement string\n\n//replace=0\n    \\=offset=7\nFailed: error -33: bad offset value\n\n/(?<=\\G.)/g,replace=+\n    abc\n 3: a+b+c+\n\n\".+\\QX\\E+\"B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        Any+\n        X+\n        Ket\n        End\n------------------------------------------------------------------\n\n\".+\\QX\\E+\"B,auto_callout,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 4\n        Any+\n        Callout 255 4 4\n        X+\n        Callout 255 8 0\n        Ket\n        End\n------------------------------------------------------------------\n\n# This one is here because Perl gives an 'unmatched )' error which goes away\n# if one of the \\) sequences is removed - which is weird. PCRE finds it too\n# complicated to find a minimum matching length.\n\n\"()X|((((((((()))))))((((())))))\\2())((((((\\2\\2)))\\2)(\\22((((\\2\\2)2))\\2)))(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z+:)Z|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z((Z*(\\2(Z\\':))\\0)i|||||||||||||||loZ\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0nte!rnal errpr\\2\\\\21r(2\\ZZZ)+:)Z!|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZernZal ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\))\\ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)))\\2))))((((((\\2\\2))))))\"I\nCapture group count = 108\nMax back reference = 22\nContains explicit CR or LF match\nSubject length lower bound = 1\n\n# This checks that new code for handling groups that may match an empty string\n# works on a very large number of alternatives. This pattern used to provoke a\n# complaint that it was too complicated.\n\n/(?:\\[A|B|C|D|E|F|G|H|I|J|]{200}Z)/expand\n\n# This one used to compile rubbish instead of a compile error, and then\n# behave unpredictably at match time.\n\n/.+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X/\nFailed: error 128 at offset 63: assertion expected after (?( or (?(?C)\n    .+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X\n\n/[:[:alnum:]-[[a:lnum:]+/\nFailed: error 150 at offset 11: invalid range in character class\n\n/((?(?C'')\\QX\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\nFailed: error 128 at offset 11: assertion expected after (?( or (?(?C)\n\n/((?(?C'')\\Q\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\n\n/abcd/auto_callout\n    abcd\\=callout_error=255:2\n--->abcd\n +0 ^        a\n +1 ^^       b\nFailed: error -37: callout error code\n\n/()(\\g+65534)/\nFailed: error 161 at offset 11: subpattern number is too big\n\n/()(\\g+65533)/\nFailed: error 115 at offset 10: reference to non-existent subpattern\n\n/\u00c1\\x00\\x00\\x00\u0017\u0161(\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\x00k\\d+\\x00\u00e2\u20ac\u017d\\x00\\x00\\x00\\x00\\x00\\2*\\x00\\x00\\1*.){36}int^\\x00\\x00\b\u02d9\u02d9\\x00\u0161(\\1{50779}?)J\\w2/I\nCapture group count = 2\nMax back reference = 2\nFirst code unit = \\xc1\nLast code unit = '2'\nSubject length lower bound = 65535\n\n/(a)(b)\\2\\1\\1\\1\\1/I\nCapture group count = 2\nMax back reference = 2\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 7\n\n/(?<a>a)(?<b>b)\\g{b}\\g{a}\\g{a}\\g{a}\\g{a}(?<a>xx)(?<b>zz)/I,dupnames\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  a   1\n  a   3\n  b   2\n  b   4\nOptions: dupnames\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 11\n\n//\n    \\=ovector=7777777777\n** Invalid value in 'ovector=7777777777'\n\n# This is here because Perl matches, even though a COMMIT is encountered\n# outside of the recursion.\n\n/(?1)(A(*COMMIT)|B)D/\n    BAXBAD\nNo match\n\n\"(?1){2}(a)\"B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        CBra 1\n        a\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n\"(?1){2,4}(a)\"B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        Brazero\n        Bra\n        Bra\n        Recurse\n        Ket\n        Brazero\n        Bra\n        Recurse\n        Ket\n        Ket\n        CBra 1\n        a\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# This test differs from Perl for the first subject. Perl ends up with\n# $1 set to 'B'; PCRE2 has it unset (which I think is right).\n\n/^(?:\n(?:A| (?:B|B(*ACCEPT)) (?<=(.)) D)\n(Z)\n)+$/x\n    AZB\n 0: AZB\n 1: <unset>\n 2: Z\n    AZBDZ\n 0: AZBDZ\n 1: B\n 2: Z\n\n# The first of these, when run by Perl, gives the mark 'aa', which is wrong.\n\n'(?>a(*:aa))b|ac' mark\n    ac\n 0: ac\n\n'(?:a(*:aa))b|ac' mark\n    ac\n 0: ac\n\n/(R?){65}/\n    (R?){65}\n 0: \n 1: \n\n/\\[(a)]{60}/expand\n    aaaa\nNo match\n\n/(?<!\\1((?U)1((?U))))(*F)/never_backslash_c,alt_bsux,anchored,extended\n\n/\\g{3/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/(a(?C1)(b)(c)d)+/\n  abcdabcd\\=callout_capture\nCallout 1: last capture = 0\n--->abcdabcd\n    ^^           (\nCallout 1: last capture = 1\n 1: abcd\n 2: b\n 3: c\n--->abcdabcd\n    ^    ^       (\n 0: abcdabcd\n 1: abcd\n 2: b\n 3: c\n\n# Perl matches this one, but PCRE does not because (*ACCEPT) clears out any\n# pending backtracks in the recursion.\n\n/^ (?(DEFINE) (..(*ACCEPT)|...) ) (?1)$/x\n\\= Expect no match\n    abc\nNo match\n\n# Perl gives no match for this one\n\n/(a(*MARK:m)(*ACCEPT)){0}(?1)/mark\n    abc\n 0: a\nMK: m\n\n/abc/endanchored\n    xyzabc\n 0: abc\n\\= Expect no match\n    xyzabcdef\nNo match\n\\= Expect error\n    xyzabc\\=ph\nFailed: error -34: bad option value\n\n/abc/\n    xyzabc\\=endanchored\n 0: abc\n\\= Expect no match\n    xyzabcdef\\=endanchored\nNo match\n\\= Expect error\n    xyzabc\\=ps,endanchored\nFailed: error -34: bad option value\n\n/abc(*ACCEPT)d/endanchored\n    xyzabc\n 0: abc\n\\= Expect no match\n    xyzabcdef\nNo match\n\n/abc|bcd/endanchored\n    xyzabcd\n 0: bcd\n\\= Expect no match\n    xyzabcdef\nNo match\n\n/a(*ACCEPT)x|aa/endanchored\n    aaa\n 0: a\n\n# Check auto-anchoring when there is a group that is never obeyed at\n# the start of a branch.\n\n/(?(DEFINE)(a))^bc/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'b'\nSubject length lower bound = 2\n\n/(a){0}.*bc/sI\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'c'\nSubject length lower bound = 2\n\n# This should be anchored, as the condition is always false and there is\n# no alternative branch.\n\n/(?(VERSION>=999)yes)^bc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 2\n\n# This should not be anchored.\n\n/(?(VERSION>=999)yes|no)^bc/I\nCapture group count = 0\nLast code unit = 'c'\nSubject length lower bound = 4\n\n/(*LIMIT_HEAP=0)xxx/I\nCapture group count = 0\nHeap limit = 0\nFirst code unit = 'x'\nLast code unit = 'x'\nSubject length lower bound = 3\n\n/\\d{0,3}(*:abc)(?C1)xxx/callout_info\nCallout 1  x\n\n# ----------------------------------------------------------------------\n\n# These are a whole pile of tests that touch lines of code that are not\n# used by any other tests (at least when these were created).\n\n/^a+?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aaa\nNo match\n\n/^[^a]{3,}?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    bbb\nNo match\n    cc\nNo match\n\n/^X\\S/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\W/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\H/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\nNo match\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\nNo match\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\nNo match\n\n/^X.+?/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\R+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\nNo match\n\n/^X\\H+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\h+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\V+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    X\\n\nNo match\n\n/^X\\D+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    X9\nNo match\n\n/^X\\S+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    X\\n\nNo match\n\n/^X\\W+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    XX\nNo match\n\n/^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n\n/(*CRLF)^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\r\\=ps\nPartial match: XY\\x0d\n\n/^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\nNo match\n    X\\n\\r\\n\nNo match\n    X\\n\\rY\nNo match\n    X\\n\\nY\nNo match\n    X\\n\\x{0c}Y\nNo match\n\n/(*BSR_ANYCRLF)^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\nNo match\n    X\\n\\r\\n\nNo match\n    X\\n\\rY\nNo match\n    X\\n\\nY\nNo match\n    X\\n\\x{0c}Y\nNo match\n\n/^X\\H+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\t\nNo match\n    XYY\nNo match\n\n/^X\\h+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\nNo match\n    X\\tY\nNo match\n\n/^X\\V+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n    XYY\nNo match\n\n/^X\\v+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\nNo match\n    X\\nY\nNo match\n\n/^X\\D+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY9\nNo match\n    XYY\nNo match\n\n/^X\\d+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X99\nNo match\n    X9Y\nNo match\n\n/^X\\S+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n    XYY\nNo match\n\n/^X\\s+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\nNo match\n    X\\nY\nNo match\n\n/^X\\W+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X.A\nNo match\n    X++\nNo match\n\n/^X\\w+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.\nNo match\n    Xaa\nNo match\n\n/^X.{1,3}Z/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.bd\nNo match\n\n/^X\\h+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\nNo match\n    X\\tY\nNo match\n\n/^X\\V+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n    XYY\nNo match\n\n/^(X(*THEN)Y|AB){0}(?1)/\n    ABX\n 0: AB\n\\= Expect no match\n    XAB\nNo match\n\n/^(?!A(?C1)B)C/\n    ABC\\=callout_error=1,no_jit\nNo match\n\n/^(?!A(?C1)B)C/no_start_optimize\n    ABC\\=callout_error=1\n--->ABC\n  1 ^^      B\nFailed: error -37: callout error code\n\n/^(?(?!A(?C1)B)C)/\n    ABC\\=callout_error=1\n--->ABC\n  1 ^^      B\nFailed: error -37: callout error code\n\n# ----------------------------------------------------------------------\n\n/[a b c]/BxxI\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended_more\nStarting code units: a b c \nSubject length lower bound = 1\n\n/[a b c]/BxxxI\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended extended_more\nStarting code units: a b c \nSubject length lower bound = 1\n\n/[a b c]/B,extended_more\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[ a b c ]/B,extended_more\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a b](?xx: [ 12 ] (?-xx:[ 34 ]) )y z/B\n------------------------------------------------------------------\n        Bra\n        [ ab]\n        Bra\n        [12]\n        Bra\n        [ 34]\n        Ket\n        Ket\n        y z\n        Ket\n        End\n------------------------------------------------------------------\n\n# Unsetting /x also unsets /xx\n\n/[a b](?xx: [ 12 ] (?-x:[ 34 ]) )y z/B\n------------------------------------------------------------------\n        Bra\n        [ ab]\n        Bra\n        [12]\n        Bra\n        [ 34]\n        Ket\n        Ket\n        y z\n        Ket\n        End\n------------------------------------------------------------------\n\n/(a)(?-n:(b))(c)/nB\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        Ket\n        Bra\n        CBra 1\n        b\n        Ket\n        Ket\n        Bra\n        c\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# ----------------------------------------------------------------------\n# These test the dangerous PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL option.\n\n/\\j\\x{z}\\o{82}\\L\\uabcd\\u\\U\\g{\\g/B,\\bad_escape_is_literal\n** Unrecognized modifier '\\' in '\\bad_escape_is_literal'\n\n/\\N{\\c/IB,bad_escape_is_literal\n------------------------------------------------------------------\n        Bra\n        N{c\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nExtra options: bad_escape_is_literal\nFirst code unit = 'N'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/[\\j\\x{z}\\o\\gAb\\g]/B,bad_escape_is_literal\n------------------------------------------------------------------\n        Bra\n        [Abgjoxz{}]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[Q-\\N]/B,bad_escape_is_literal\nFailed: error 150 at offset 5: invalid range in character class\n\n/[\\s-_]/bad_escape_is_literal\nFailed: error 150 at offset 3: invalid range in character class\n\n/[_-\\s]/bad_escape_is_literal\nFailed: error 150 at offset 5: invalid range in character class\n\n/[\\B\\R\\X]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[\\B\\R\\X]/B,bad_escape_is_literal\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[A-\\BP-\\RV-\\X]/B\nFailed: error 107 at offset 4: escape sequence is invalid in character class\n\n/[A-\\BP-\\RV-\\X]/B,bad_escape_is_literal\nFailed: error 107 at offset 4: escape sequence is invalid in character class\n\n# ----------------------------------------------------------------------\n\n/a\\b(c/literal\n    a\\\\b(c\n 0: a\\b(c\n\n/a\\b(c/literal,caseless\n    a\\\\b(c\n 0: a\\b(c\n    a\\\\B(c\n 0: a\\B(c\n\n/a\\b(c/literal,firstline\n    XYYa\\\\b(c\n 0: a\\b(c\n\\= Expect no match\n    X\\na\\\\b(c\nNo match\n\n/a\\b?c/literal,use_offset_limit\n    XXXXa\\\\b?c\\=offset_limit=4\n 0: a\\b?c\n\\= Expect no match\n    XXXXa\\\\b?c\\=offset_limit=3\nNo match\n\n/a\\b(c/literal,anchored,endanchored\n    a\\\\b(c\n 0: a\\b(c\n\\= Expect no match\n    Xa\\\\b(c\nNo match\n    a\\\\b(cX\nNo match\n    Xa\\\\b(cX\nNo match\n\n//literal,extended\nFailed: error 192 at offset 0: invalid option bits with PCRE2_LITERAL\n\n/a\\b(c/literal,auto_callout,no_start_optimize\n    XXXXa\\\\b(c\n--->XXXXa\\b(c\n +0 ^             a\n +0  ^            a\n +0   ^           a\n +0    ^          a\n +0     ^         a\n +1     ^^        \\\n +2     ^ ^       b\n +3     ^  ^      (\n +4     ^   ^     c\n +5     ^    ^    End of pattern\n 0: a\\b(c\n\n/a\\b(c/literal,auto_callout\n    XXXXa\\\\b(c\n--->XXXXa\\b(c\n +0     ^         a\n +1     ^^        \\\n +2     ^ ^       b\n +3     ^  ^      (\n +4     ^   ^     c\n +5     ^    ^    End of pattern\n 0: a\\b(c\n\n/(*CR)abc/literal\n    (*CR)abc\n 0: (*CR)abc\n\n/cat|dog/I,match_word\nCapture group count = 0\nMax lookbehind = 1\nExtra options: match_word\nStarting code units: c d \nSubject length lower bound = 3\n    the cat sat\n 0: cat\n\\= Expect no match\n    caterpillar\nNo match\n    snowcat\nNo match\n    syndicate\nNo match\n\n/(cat)|dog/I,match_line,literal\nCapture group count = 0\nCompile options: literal\nOverall options: anchored literal\nExtra options: match_line\nFirst code unit = '('\nSubject length lower bound = 9\n    (cat)|dog\n 0: (cat)|dog\n\\= Expect no match\n    the cat sat\nNo match\n    caterpillar\nNo match\n    snowcat\nNo match\n    syndicate\nNo match\n\n/a whole line/match_line,multiline\n    Rhubarb \\na whole line\\n custard\n 0: a whole line\n\\= Expect no match\n    Not a whole line\nNo match\n\n# Perl gets this wrong, failing to capture 'b' in group 1.\n\n/^(b+|a){1,2}?bc/\n    bbc\n 0: bbc\n 1: b\n    \n# And again here, for the \"babc\" subject string. \n\n/^(b*|ba){1,2}?bc/\n    babc\n 0: babc\n 1: ba\n    bbabc\n 0: bbabc\n 1: ba\n    bababc\n 0: bababc\n 1: ba\n\\= Expect no match\n    bababbc\nNo match\n    babababc\nNo match\n\n/[[:digit:]-a]/\nFailed: error 150 at offset 10: invalid range in character class\n\n/[[:digit:]-[:print:]]/\nFailed: error 150 at offset 10: invalid range in character class\n\n/[\\d-a]/\nFailed: error 150 at offset 3: invalid range in character class\n\n/[\\H-z]/\nFailed: error 150 at offset 3: invalid range in character class\n\n/[\\d-[:print:]]/\nFailed: error 150 at offset 3: invalid range in character class\n\n# Perl gets the second of these wrong, giving no match.\n\n\"(?<=(a))\\1?b\"I\nCapture group count = 1\nMax back reference = 1\nMax lookbehind = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    ab\n 0: b\n 1: a\n    aaab \n 0: ab\n 1: a\n\n\"(?=(a))\\1?b\"I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    ab\n 0: ab\n 1: a\n    aaab\n 0: ab\n 1: a\n    \n# JIT does not support callout_extra  \n    \n/(*NO_JIT)(a+)b/auto_callout,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \nNew match attempt\n--->aac\n +9 ^       (\n+10 ^       a+\n+12 ^ ^     )\n+13 ^ ^     b\nBacktrack\n--->aac\n+12 ^^      )\n+13 ^^      b\nBacktrack\nNo other matching paths\nNew match attempt\n--->aac\n +9  ^      (\n+10  ^      a+\n+12  ^^     )\n+13  ^^     b\nBacktrack\nNo other matching paths\nNew match attempt\n--->aac\n +9   ^     (\n+10   ^     a+\nBacktrack\nNo other matching paths\nNew match attempt\n--->aac\n +9    ^    (\n+10    ^    a+\nNo match\n    \n/(*NO_JIT)a+(?C'XXX')b/no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \nNew match attempt\nCallout (15): 'XXX'\n--->aac\n    ^ ^     b\nBacktrack\nCallout (15): 'XXX'\n--->aac\n    ^^      b\nBacktrack\nNo other matching paths\nNew match attempt\nCallout (15): 'XXX'\n--->aac\n     ^^     b\nNo match\n\n/\\n/firstline\n    xyz\\nabc\n 0: \\x0a\n\n/\\nabc/firstline\n    xyz\\nabc\n 0: \\x0aabc\n\n/\\x{0a}abc/firstline,newline=crlf\n\\= Expect no match\n    xyz\\r\\nabc\nNo match\n\n/[abc]/firstline\n\\= Expect no match\n    \\na\nNo match\n    \n# These tests are matched in test 1 as they are Perl compatible. Here we are\n# looking at what does and does not get auto-possessified. \n\n/(?(DEFINE)(?<optional_a>a?))^(?&optional_a)a$/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        CBra 1\n        a?\n        Ket\n        Ket\n        ^\n        Recurse\n        a\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(DEFINE)(?<optional_a>a?)X)^(?&optional_a)a$/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        CBra 1\n        a?\n        Ket\n        X\n        Ket\n        ^\n        Recurse\n        a\n        $\n        Ket\n        End\n------------------------------------------------------------------\n    \n/^(a?)b(?1)a/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        a?\n        Ket\n        b\n        Recurse\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a?)+b(?1)a/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SCBra 1\n        a?\n        KetRmax\n        b\n        Recurse\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a?)++b(?1)a/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SCBraPos 1\n        a?\n        KetRpos\n        b\n        Recurse\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a?)+b/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SCBra 1\n        a?\n        KetRmax\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=a+)a(a+)++b/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        a++\n        Ket\n        a\n        CBraPos 1\n        a++\n        KetRpos\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<=(?=.){4,5}x)/B\n------------------------------------------------------------------\n        Bra\n        Assert back\n        Reverse\n        Assert\n        Any\n        Ket\n        Assert\n        Any\n        Ket\n        Assert\n        Any\n        Ket\n        Assert\n        Any\n        Ket\n        Brazero\n        Assert\n        Any\n        Ket\n        x\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# Perl behaves differently with these when optimization is turned off\n\n/a(*PRUNE:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\nNo match, mark = X\n\n/a(*THEN:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\nNo match, mark = X\n\n/(?^x-i)AB/ \nFailed: error 194 at offset 4: invalid hyphen in option setting\n\n/(?^-i)AB/ \nFailed: error 194 at offset 3: invalid hyphen in option setting\n\n/(?x-i-i)/\nFailed: error 194 at offset 5: invalid hyphen in option setting\n\n/(?(?=^))b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n\n/(?(?=^)|)b/I\nCapture group count = 0\nFirst code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n\n/(?(?=^)|^)b/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'b'\nSubject length lower bound = 1\n    bbc\n 0: b\n\\= Expect no match\n    abc     \nNo match\n\n/(?(1)^|^())/I\nCapture group count = 1\nMax back reference = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(?(1)^())b/I\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/(?(1)^())+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n 0+ c\n\n/(?(1)^()|^)+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'b'\nSubject length lower bound = 1\n    bbc \n 0: b\n 0+ bc\n\\= Expect no match     \n    abc\nNo match\n\n/(?(1)^()|^)*b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'b'\nSubject length lower bound = 1\n    bbc \n 0: b\n 0+ bc\n    abc\n 0: b\n 0+ c\n    xbc \n 0: b\n 0+ c\n\n/(?(1)^())+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n 0+ c\n\n/(?(1)^a()|^a)+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    abc \n 0: ab\n 0+ c\n\\= Expect no match     \n    bbc\nNo match\n\n/(?(1)^|^(a))+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc \n 0: ab\n 0+ c\n 1: a\n\\= Expect no match     \n    bbc\nNo match\n\n/(?(1)^a()|^a)*b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc \n 0: ab\n 0+ c\n    bbc\n 0: b\n 0+ bc\n    xbc \n 0: b\n 0+ c\n\n/a(b)c|xyz/g,allvector,replace=<$0>\n    abcdefabcpqr\\=ovector=4\n 2: <abc>def<abc>pqr\n 0: 6 9\n 1: 7 8\n 2: <unchanged>\n 3: <unchanged>\n    abxyz\\=ovector=4\n 1: ab<xyz>\n 0: 2 5\n 1: <unset>\n 2: <unchanged>\n 3: <unchanged>\n    abcdefxyz\\=ovector=4\n 2: <abc>def<xyz>\n 0: 6 9\n 1: <unset>\n 2: <unchanged>\n 3: <unchanged>\n    \n/a(b)c|xyz/allvector\n    abcdef\\=ovector=4\n 0: abc\n 1: b\n 2: <unchanged>\n 3: <unchanged>\n    abxyz\\=ovector=4\n 0: xyz\n 1: <unset>\n 2: <unchanged>\n 3: <unchanged>\n\n/a(b)c|xyz/g,replace=<$0>,substitute_callout\n    abcdefabcpqr\n 1(2) Old 0 3 \"abc\" New 0 5 \"<abc>\"\n 2(2) Old 6 9 \"abc\" New 8 13 \"<abc>\"\n 2: <abc>def<abc>pqr\n    abxyzpqrabcxyz\n 1(1) Old 2 5 \"xyz\" New 2 7 \"<xyz>\"\n 2(2) Old 8 11 \"abc\" New 10 15 \"<abc>\"\n 3(1) Old 11 14 \"xyz\" New 15 20 \"<xyz>\"\n 3: ab<xyz>pqr<abc><xyz>\n    12abc34xyz99abc55\\=substitute_stop=2\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 9 14 \"<xyz> STOPPED\"\n 2: 12<abc>34xyz99abc55\n    12abc34xyz99abc55\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> SKIPPED\"\n 2(1) Old 7 10 \"xyz\" New 7 12 \"<xyz>\"\n 3(2) Old 12 15 \"abc\" New 14 19 \"<abc>\"\n 3: 12abc34<xyz>99<abc>55\n    12abc34xyz99abc55\\=substitute_skip=2\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 9 14 \"<xyz> SKIPPED\"\n 3(2) Old 12 15 \"abc\" New 14 19 \"<abc>\"\n 3: 12<abc>34xyz99<abc>55\n\n/a(b)c|xyz/g,replace=<$0>\n    abcdefabcpqr\n 2: <abc>def<abc>pqr\n    abxyzpqrabcxyz\n 3: ab<xyz>pqr<abc><xyz>\n    12abc34xyz\\=substitute_stop=2\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 9 14 \"<xyz> STOPPED\"\n 2: 12<abc>34xyz\n    12abc34xyz\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> SKIPPED\"\n 2(1) Old 7 10 \"xyz\" New 7 12 \"<xyz>\"\n 2: 12abc34<xyz>\n\n/a(b)c|xyz/replace=<$0>\n    abcdefabcpqr\n 1: <abc>defabcpqr\n    12abc34xyz\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> SKIPPED\"\n 1: 12abc34xyz\n    12abc34xyz\\=substitute_stop=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> STOPPED\"\n 1: 12abc34xyz\n\n/abc\\rdef/\n    abc\\ndef\nNo match\n\n/abc\\rdef\\x{0d}xyz/escaped_cr_is_lf\n    abc\\ndef\\rxyz\n 0: abc\\x0adef\\x0dxyz\n\\= Expect no match     \n    abc\\ndef\\nxyz\nNo match\n\n/(?(*ACCEPT)xxx)/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/(?(*atomic:xx)xxx)/\nFailed: error 128 at offset 10: assertion expected after (?( or (?(?C)\n\n/(?(*script_run:xxx)zzz)/\nFailed: error 128 at offset 14: assertion expected after (?( or (?(?C)\n\n/foobar/\n    the foobar thing\\=copy_matched_subject\n 0: foobar\n    the foobar thing\\=copy_matched_subject,zero_terminate\n 0: foobar\n\n/foobar/g\n    the foobar thing foobar again\\=copy_matched_subject\n 0: foobar\n 0: foobar\n\n/(*:XX)^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(*COMMIT:XX)^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(*ACCEPT:XX)^abc/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/abc/replace=xyz\n    abc\\=null_context\n 1: xyz\n\n/abc/replace=xyz,substitute_callout\n    abc \n 1(1) Old 0 3 \"abc\" New 0 3 \"xyz\"\n 1: xyz\n\\= Expect error message\n    abc\\=null_context\n** Replacement callouts are not supported with null_context.\n\n/\\[()]{65535}()/expand\nFailed: error 197 at offset 131071: too many capturing groups (maximum 65535)\n\n/\\[()]{65535}(?<A>)/expand\nFailed: error 197 at offset 131075: too many capturing groups (maximum 65535)\n\n/a(?:(*ACCEPT))??bc/\n    abc\n 0: abc\n    axy\n 0: a\n\n/a(*ACCEPT)??bc/\n    abc\n 0: abc\n    axy\n 0: a\n\n/a(*ACCEPT:XX)??bc/mark\n    abc\n 0: abc\n    axy\n 0: a\nMK: XX\n\n/(*:\\)?/\nFailed: error 109 at offset 5: quantifier does not follow a repeatable item\n\n/(*:\\Q \\E){5}/alt_verbnames\nFailed: error 109 at offset 11: quantifier does not follow a repeatable item\n\n/(?=abc)/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 2\n\n/(?|(X)|(XY))\\1abc/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'X'\nLast code unit = 'c'\nSubject length lower bound = 4\n\n/(?|(a)|(bcde))(c)\\2/I\nCapture group count = 2\nMax back reference = 2\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?|(a)|(bcde))(c)\\1/I\nCapture group count = 2\nMax back reference = 1\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'B'(?'A')/I,dupnames\nCapture group count = 3\nMax back reference = 2\nNamed capture groups:\n  A   1\n  A   3\n  B   2\nOptions: dupnames\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'A'(?'A')/I,dupnames\nCapture group count = 3\nMax back reference = 3\nNamed capture groups:\n  A   1\n  A   3\n  B   2\nOptions: dupnames\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/((a|)+)+Z/I\nCapture group count = 2\nStarting code units: Z a \nLast code unit = 'Z'\nSubject length lower bound = 1\n\n/((?=a))[abcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/A(?:(*ACCEPT))?B/info\nCapture group count = 0\nFirst code unit = 'A'\nSubject length lower bound = 1\n\n/(A(*ACCEPT)??B)C/\n    ABC\n 0: ABC\n 1: AB\n    AXY \n 0: A\n 1: A\n\n/(?<=(?<=a)b)c.*/I\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'c'\nSubject length lower bound = 1\n    abc\\=ph\nPartial match: c\n\\= Expect no match\n    xbc\\=ph\nNo match\n\n/(?<=ab)c.*/I\nCapture group count = 0\nMax lookbehind = 2\nFirst code unit = 'c'\nSubject length lower bound = 1\n    abc\\=ph\nPartial match: c\n\\= Expect no match\n    xbc\\=ph\nNo match\n\n/(?<=a(?<=a|a)c)/I\nCapture group count = 0\nMax lookbehind = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(?<=a(?<=a|ba)c)/I\nCapture group count = 0\nMax lookbehind = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(?<=(?<=a)b)(?<!abcd)/I\nCapture group count = 0\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n/(?<=(?<=a)b)(?<!abcd)(?<=(?<=a)bcde)/I\nCapture group count = 0\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n# Addition overflow\n/( {32742} {42})(?<!\\1{65481})/\nFailed: error 187 at offset 15: lookbehind assertion is too long\n\n# Multiplication overflow\n/(X{65535})(?<=\\1{32770})/\nFailed: error 187 at offset 10: lookbehind assertion is too long\n\n# ---- Non-atomic assertion tests ----\n\n# Expect error: not allowed as a condition\n/(?(*napla:xx)bc)/\nFailed: error 198 at offset 9: atomic assertion expected after (?( or (?(?C)\n\n/\\A(*pla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\nNo match\n\n/\\A(*napla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n 0: word1 word3 word1 word2 word3 word2 word2 word1 word3\n 1: word3\n\n/\\A(?*.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n 0: word1 word3 word1 word2 word3 word2 word2 word1 word3\n 1: word3\n\n/(*plb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n 0: b\n 1: b\n 2: <unset>\n 3: b\n    abcda\\=offset=4 \nNo match\n\n/(*naplb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n 0: b\n 1: b\n 2: <unset>\n 3: b\n    abcda\\=offset=4 \n 0: a\n 1: <unset>\n 2: a\n 3: a\n    \n/(?<*(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n 0: b\n 1: b\n 2: <unset>\n 3: b\n    abcda\\=offset=4 \n 0: a\n 1: <unset>\n 2: a\n 3: a\n    \n/(*non_atomic_positive_lookahead:ab)/B\n------------------------------------------------------------------\n        Bra\n        Non-atomic assert\n        ab\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n \n/(*non_atomic_positive_lookbehind:ab)/B \n------------------------------------------------------------------\n        Bra\n        Non-atomic assert back\n        Reverse\n        ab\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(*pla:ab+)/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        a\n        b++\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(*napla:ab+)/B\n------------------------------------------------------------------\n        Bra\n        Non-atomic assert\n        a\n        b+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(*napla:)+/\n\n/(*naplb:)+/\n\n/(*napla:^x|^y)/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nStarting code units: x y \nSubject length lower bound = 1\n\n/(*napla:abc|abd)/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(*napla:a|(.)(*ACCEPT)zz)\\1../\n    abcd\n 0: abc\n 1: a\n    \n/(*napla:a(*ACCEPT)zz|(.))\\1../\n    abcd\n 0: bcd\n 1: b\n    \n/(*napla:a|(*COMMIT)(.))\\1\\1/\n    aabc\n 0: aa\n 1: a\n\\= Expect no match     \n    abbc   \nNo match\n\n/(*napla:a|(.))\\1\\1/\n    aabc\n 0: aa\n 1: a\n    abbc   \n 0: bb\n 1: b\n\n# ----\n\n# Expect error (recursion => not fixed length)\n/(\\2)((?=(?<=\\1)))/\nFailed: error 125 at offset 8: lookbehind assertion is not fixed length\n\n/c*+(?<=[bc])/\n    abc\\=ph\nPartial match: c\n    ab\\=ph\nPartial match: \n    abc\\=ps\n 0: c\n    ab\\=ps\n 0: \n\n/c++(?<=[bc])/\n    abc\\=ph\nPartial match: c\n    ab\\=ph\nPartial match: \n\n/(?<=(?=.(?<=x)))/\n    abx\n 0: \n    ab\\=ph\nPartial match: \n    bxyz \n 0: \n    xyz\n 0: \n    \n/\\z/\n   abc\\=ph\nPartial match: \n   abc\\=ps \n 0: \n   \n/\\Z/\n   abc\\=ph\nPartial match: \n   abc\\=ps \n 0: \n   abc\\n\\=ph\nPartial match: \\x0a\n   abc\\n\\=ps\n 0: \n\n/(?![ab]).*/\n    ab\\=ph\nPartial match: \n\n/c*+/\n    ab\\=ph,offset=2\nPartial match: \n\n/\\A\\s*(a|(?:[^`]{28500}){4})/I\nCapture group count = 1\nMax lookbehind = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n    a\n 0: a\n 1: a\n\n/\\A\\s*((?:[^`]{28500}){4})/I\nCapture group count = 1\nMax lookbehind = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 65535\n\n/\\A\\s*((?:[^`]{28500}){4}|a)/I\nCapture group count = 1\nMax lookbehind = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n    a\n 0: a\n 1: a\n\n/(?<A>a)(?(<A>)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        Cond\n      1 Cond ref\n        b\n        Ket\n        CBra 2\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(1)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n      1 Cond ref\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(R1)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond recurse 1\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(DEFINE)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(VERSION=10.3)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/[aA]b[cC]/IB\n------------------------------------------------------------------\n        Bra\n     /i a\n        b\n     /i c\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/[cc]abcd/I\nCapture group count = 0\nFirst code unit = 'c'\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/[Cc]abcd/I\nCapture group count = 0\nFirst code unit = 'C' (caseless)\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/[c]abcd/I\nCapture group count = 0\nFirst code unit = 'c'\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/(?:c|C)abcd/I\nCapture group count = 0\nFirst code unit = 'C' (caseless)\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/(a)?a/I\nCapture group count = 1\nStarting code units: a \nLast code unit = 'a'\nSubject length lower bound = 1\n    manm\n 0: a\n\n/^(?|(\\*)(*napla:\\S*_(\\2?+.+))|(\\w)(?=\\S*_(\\2?+\\1)))+_\\2$/\n    *abc_12345abc\n 0: *abc_12345abc\n 1: c\n 2: 12345abc\n\n/^(?|(\\*)(*napla:\\S*_(\\3?+.+))|(\\w)(?=\\S*_((\\2?+\\1))))+_\\2$/\n    *abc_12345abc\n 0: *abc_12345abc\n 1: c\n 2: 12345abc\n 3: 12345abc\n\n/^((\\1+)(?C)|\\d)+133X$/\n    111133X\\=callout_capture\nCallout 0: last capture = 2\n 1: 1\n 2: 111\n--->111133X\n    ^   ^       |\nCallout 0: last capture = 2\n 1: 3\n 2: 3\n--->111133X\n    ^     ^     |\nCallout 0: last capture = 2\n 1: 1\n 2: 11\n--->111133X\n    ^  ^        |\nCallout 0: last capture = 2\n 1: 3\n 2: 3\n--->111133X\n    ^     ^     |\n 0: 111133X\n 1: 11\n 2: 11\n\n/abc/replace=xyz,substitute_replacement_only\n    123abc456\n 1: xyz\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z,substitute_replacement_only\n    \"abcde-abcde-\"\n 2: Xb+dZXb+dZ\n     \n/a(b)c|xyz/g,replace=<$0>,substitute_callout,substitute_replacement_only\n    abcdefabcpqr                \n 1(2) Old 0 3 \"abc\" New 0 5 \"<abc>\"\n 2(2) Old 6 9 \"abc\" New 5 10 \"<abc>\"\n 2: <abc><abc>\n    abxyzpqrabcxyz              \n 1(1) Old 2 5 \"xyz\" New 0 5 \"<xyz>\"\n 2(2) Old 8 11 \"abc\" New 5 10 \"<abc>\"\n 3(1) Old 11 14 \"xyz\" New 10 15 \"<xyz>\"\n 3: <xyz><abc><xyz>\n    12abc34xyz99abc55\\=substitute_stop=2                          \n 1(2) Old 2 5 \"abc\" New 0 5 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 5 10 \"<xyz> STOPPED\"\n 2: <abc>\n    12abc34xyz99abc55\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 0 5 \"<abc> SKIPPED\"\n 2(1) Old 7 10 \"xyz\" New 0 5 \"<xyz>\"\n 3(2) Old 12 15 \"abc\" New 5 10 \"<abc>\"\n 3: <xyz><abc>\n    12abc34xyz99abc55\\=substitute_skip=2\n 1(2) Old 2 5 \"abc\" New 0 5 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 5 10 \"<xyz> SKIPPED\"\n 3(2) Old 12 15 \"abc\" New 5 10 \"<abc>\"\n 3: <abc><abc>\n\n/a(..)d/replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n 1: xyz>bc<xyzabcdxyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n 1: xyz>bc<xyzabcdxyz\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\nFailed: error -54 at offset 3 in replacement: requested value is not available\n\n/a(..)d/g,replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n 2: xyz>bc<xyz>bc<xyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n 2: xyz>bc<xyz>bc<xyz\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\nFailed: error -54 at offset 3 in replacement: requested value is not available\n    xyzabcdxyzabcdxyz\\=ovector=1,substitute_unset_empty\nFailed: error -54 at offset 3 in replacement: requested value is not available\n\n/55|a(..)d/g,replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 3: xyz><>bc<xyz>bc<xyz\n\\= Expect error     \n    xyz55abcdxyzabcdxyz\\=ovector=2\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/55|a(..)d/replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 1: xyz><abcdxyzabcdxyz\n\n/55|a(..)d/replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 1: xyz><abcdxyzabcdxyz\n\n/55|a(..)d/g,replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 3: xyz><>bc<xyz>bc<xyz\n    \n/abc/replace=,caseless\n    XabcY\n 0: abc\n    XABCY \n 0: ABC\n\n/abc/replace=[4],caseless\n    XabcY\n 1: XY\n    XABCY \n 1: XY\n\n/abc/replace=*,caseless\n    XabcY\n 1: X*Y\n    XABCY\n 1: X*Y\n    XabcY\\=replace=  \n 0: abc\n\n# Expect non-fixed-length error\n\n\"(?<=X(?(DEFINE)(.*))(?1)).\"\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/\\sxxx\\s/tables=1\n\\= Expect no match\n    AB\\x{85}xxx\\x{a0}XYZ\nNo match\n\n/\\sxxx\\s/tables=2\n    AB\\x{85}xxx\\x{a0}XYZ\n 0: \\x85xxx\\xa0\n\n/^\\w+/tables=2\n    \u0102\u2030cole\n 0: \\xc3\n\n/^\\w+/tables=3\n** 'Tables = 3' is invalid: binary tables have not been loaded\n    \u0102\u2030cole\n\n#loadtables ./testbtables\n\n/^\\w+/tables=3\n    \u0102\u2030cole\n 0: \\xc3\n\n/\"(*MARK:>\" 00 \"<)..\"/hex,mark,no_start_optimize\n    AB\n 0: AB\nMK: >\\x00<\n    A\\=ph \nPartial match, mark=>\\x00<: A\n\\= Expect no match\n    A\nNo match, mark = >\\x00<\n\n/\"(*MARK:>\" 00 \"<).(?C1).\"/hex,mark,no_start_optimize\n    AB\n--->AB\n  1 ^^     .\nLatest Mark: >\\x00<\n 0: AB\nMK: >\\x00<\n\n/(?(VERSION=0.0/\nFailed: error 179 at offset 14: syntax error or number too big in (?(VERSION condition\n\n# Perl has made \\K in lookarounds an error. PCRE2 now rejects as well, unless\n# explicitly authorized.\n\n/(?=a\\Kb)ab/\nFailed: error 199 at offset 10: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/(?=a\\Kb)ab/allow_lookaround_bsk\n    ab \n 0: b\n\n/(?!a\\Kb)ac/\nFailed: error 199 at offset 10: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/(?!a\\Kb)ac/allow_lookaround_bsk\n    ac \n 0: ac\n    \n/^abc(?<=b\\Kc)d/\nFailed: error 199 at offset 14: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/^abc(?<=b\\Kc)d/allow_lookaround_bsk\n    abcd\n 0: cd\n\n/^abc(?<!b\\Kq)d/\nFailed: error 199 at offset 14: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/^abc(?<!b\\Kq)d/,allow_lookaround_bsk\n    abcd\n 0: abcd\n    \n# --------- \n\n# Tests for zero-length NULL to be treated as an empty string.\n\n//\n    \\=null_subject\n 0: \n\\= Expect error     \n    abc\\=null_subject\nFailed: error -51: NULL argument passed with non-zero length\n\n//replace=[20]\n    abc\\=null_replacement\n 1: abc\n    \\=null_subject\n 1: \n    \\=null_replacement\n 1: \n\n/X*/g,replace=xy\n\\= Expect error\n    >X<\\=null_replacement\nFailed: error -51: NULL argument passed with non-zero length\n\n/X+/replace=[20]\n    >XX<\\=null_replacement\n 1: ><\n\n# --------- \n\n/[Aa]{2}/BI\n------------------------------------------------------------------\n        Bra\n     /i A{2}\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'A' (caseless)\nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aabcd\n 0: aa\n\n/A{2}/iBI\n------------------------------------------------------------------\n        Bra\n     /i A{2}\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'A' (caseless)\nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aabcd\n 0: aa\n\n/[Aa]{2,3}/BI\n------------------------------------------------------------------\n        Bra\n     /i A{2}\n     /i A?+\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'A' (caseless)\nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aabcd\n 0: aa\n\n# End of testinput2\nError -70: PCRE2_ERROR_BADDATA (unknown error number)\nError -62: bad serialized data\nError -2: partial match\nError -1: no match\nError 0: PCRE2_ERROR_BADDATA (unknown error number)\nError 100: no error\nError 101: \\ at end of pattern\nError 191: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not allowed in UTF-16 mode\nError 200: PCRE2_ERROR_BADDATA (unknown error number)\n"], "fixing_code": ["Change Log for PCRE2 - see also the Git log\n-------------------------------------------\n\n\nVersion 10.41 xx-xxx-2022\n-------------------------\n\n1. Add fflush() before and after a fork callout in pcre2grep to get its output\nto be the same on all systems. (THere were previously ordering differences in\nAlpine Linux).\n\n2. Merged patch from @carenas (GitHub #110) for pthreads support in CMake.\n\n3. SSF scorecards grumbled about possible overflow in an expression in\npcre2test. It never would have overflowed in practice, but some casts have been\nadded and at the some time there's been some tidying of fprints that output\nsize_t values.\n\n4. PR #94 showed up an unused enum in pcre2_convert.c, which is now removed.\n\n5. Minor code re-arrangement to remove gcc warning about realloc() in\npcre2test.\n\n6. Change a number of int variables that hold buffer and line lengths in\npcre2grep to PCRE2_SIZE (aka size_t).\n\n7. Added an #ifdef to cut out a call to PRIV(jit_free) when JIT is not\nsupported (even though that function would do nothing in that case) at the\nrequest of a user who doesn't even want to link with pcre_jit_compile.o. Also\ntidied up an untidy #ifdef arrangement in pcre2test.\n\n8. Fixed an issue in the backtracking optimization of character repeats in\nJIT. Furthermore optimize star repetitions, not just plus repetitions.\n\n9. Removed the use of an initial backtracking frames vector on the system stack \nin pcre2_match() so that it now always uses the heap. (In a multi-thread \nenvironment with very small stacks there had been an issue.) This also is \ntidier for JIT matching, which didn't need that vector. The heap vector is now \nremembered in the match data block and re-used if that block itself is re-used. \nIt is freed with the match data block.\n\n10. Adjusted the find_limits code in pcre2test to work with change 9 above.\n\n11. Added find_limits_noheap to pcre2test, because the heap limits are now \ndifferent in different environments and so cannot be included in the standard \ntests.\n\n12. Created a test for pcre2_match() heap processing that is not part of the \ntests run by 'make check', but can be run manually. The current output is from \na 64-bit system.\n\n13. Implemented -Z aka --null in pcre2grep.\n\n14. A minor change to pcre2test and the addition of several new pcre2grep tests\nhave improved LCOV coverage statistics. At the same time, code in pcre2grep and \nelsewhere that can never be obeyed in normal testing has been excluded from\ncoverage.\n\n15. Fixed a bug in pcre2grep that could cause an extra newline to be written\nafter output generaed by --output.\n\n16. If a file has a .bz2 extension but is not in fact compressed, pcre2grep \nshould process it as a plain text file. A bug stopped this happening; now fixed \nand added to the tests.\n\n17. When pcre2grep was running not in UTF mode, if a string specified by\n--output or obtained from a callout in a pattern contained a character (byte)\ngreater than 127, it was incorrectly output in UTF-8 format.\n\n18. Added some casts after warnings from Clang sanitize.\n\n19. Merged patch from cbouc (GitHub #139): 4 function prototypes were missing\nPCRE2_CALL_CONVENTION in src/pcre2posix.h. All function prototypes returning\npointers had out of place PCRE2_CALL_CONVENTION in src/pcre2.h.*. These\nproduced errors when building for Windows with #define PCRE2_CALL_CONVENTION\n__stdcall.\n\n20. A negative repeat value in a pcre2test subject line was not being \ndiagnosed, leading to infinite looping.\n\n\nVersion 10.40 15-April-2022\n---------------------------\n\n1. Merged patch from @carenas (GitHub #35, 7db87842) to fix pcre2grep incorrect\nhandling of multiple passes.\n\n2. Merged patch from @carenas (GitHub #36, dae47509) to fix portability issue\nin pcre2grep with buffered fseek(stdin).\n\n3. Merged patch from @carenas (GitHub #37, acc520924) to fix tests when -S is\nnot supported.\n\n4. Revert an unintended change in JIT repeat detection.\n\n5. Merged patch from @carenas (GitHub #52, b037bfa1) to fix build on GNU Hurd.\n\n6. Merged documentation and comments patches from @carenas (GitHub #47).\n\n7. Merged patch from @carenas (GitHub #49) to remove obsolete JFriedl test code\nfrom pcre2grep.\n\n8. Merged patch from @carenas (GitHub #48) to fix CMake install issue #46.\n\n9. Merged patch from @carenas (GitHub #53) fixing NULL checks in matching and\nsubstituting.\n\n10. Add null_subject and null_replacement modifiers to pcre2test.\n\n11. Add check for NULL subject to POSIX regexec() function.\n\n12. Add check for NULL replacement to pcre2_substitute().\n\n13. For the subject arguments of pcre2_match(), pcre2_dfa_match(), and\npcre2_substitute(), and the replacement argument of the latter, if the pointer\nis NULL and the length is zero, treat as an empty string. Apparently a number\nof applications treat NULL/0 in this way.\n\n14. Added support for Bidi_Class and a number of binary Unicode properties,\nincluding Bidi_Control.\n\n15. Fix some minor issues raised by clang sanitize.\n\n16. Very minor code speed up for maximizing character property matches.\n\n17. A number of changes to script matching for \\p and \\P:\n\n    (a) Script extensions for a character are now coded as a bitmap instead of\n        a list of script numbers, which should be faster and does not need a\n        loop.\n\n    (b) Added the syntax \\p{script:xxx} and \\p{script_extensions:xxx} (synonyms\n        sc and scx).\n\n    (c) Changed \\p{scriptname} from being the same as \\p{sc:scriptname} to being\n        the same as \\p{scx:scriptname} because this change happened in Perl at\n        release 5.26.\n\n    (d) The standard Unicode 4-letter abbreviations for script names are now\n        recognized.\n\n    (e) In accordance with Unicode and Perl's \"loose matching\" rules, spaces,\n        hyphens, and underscores are ignored in property names, which are then\n        matched independent of case.\n\n18. The Python scripts in the maint directory have been refactored. There are\nnow three scripts that generate pcre2_ucd.c, pcre2_ucp.h, and pcre2_ucptables.c\n(which is #included by pcre2_tables.c). The data lists that used to be\nduplicated are now held in a single common Python module.\n\n19. On CHERI, and thus Arm's Morello prototype, pointers are represented as\nhardware capabilities, which consist of both an integer address and additional\nmetadata, meaning they are twice the size of the platform's size_t type, i.e.\n16 bytes on a 64-bit system. The ovector member of heapframe happens to only be\n8 byte aligned, and so computing frame_size ended up with a multiple of 8 but\nnot 16. Whilst the first frame was always suitably aligned, this then\nmisaligned the frame that follows, resulting in an alignment fault when storing\na pointer to Fecode at the start of match. Patch to fix this issue by Jessica\nClarke PR#72.\n\n20. Added -LP and -LS listing options to pcre2test.\n\n21. A user discovered that the library names in CMakeLists.txt for MSVC\ndebugger (PDB) files were incorrect - perhaps never tried for PCRE2?\n\n22. An item such as [Aa] is optimized into a caseless single character match.\nWhen this was quantified (e.g. [Aa]{2}) and was also the last literal item in a\npattern, the optimizing \"must be present for a match\" character check was not\nbeing flagged as caseless, causing some matches that should have succeeded to\nfail.\n\n23. Fixed a unicode property matching issue in JIT. The character was not\nfully read in caseless matching.\n\n24. Fixed an issue affecting recursions in JIT caused by duplicated data\ntransfers.\n\n25. Merged patch from @carenas (GitHub #96) which fixes some problems with\npcre2test and readline/readedit:\n\n  * Use the right header for libedit in FreeBSD with autoconf\n  * Really allow libedit with cmake\n  * Avoid using readline headers with libedit\n\n\nVersion 10.39 29-October-2021\n-----------------------------\n\n1. Fix incorrect detection of alternatives in first character search in JIT.\n\n2. Merged patch from @carenas (GitHub #28):\n\n  Visual Studio 2013 includes support for %zu and %td, so let newer\n  versions of it avoid the fallback, and while at it, make sure that\n  the first check is for DISABLE_PERCENT_ZT so it will be always\n  honoured if chosen.\n\n  prtdiff_t is signed, so use a signed type instead, and make sure\n  that an appropriate width is chosen if pointers are 64bit wide and\n  long is not (ex: Windows 64bit).\n\n  IMHO removing the cast (and therefore the possibilty of truncation)\n  make the code cleaner and the fallback is likely portable enough\n  with all 64-bit POSIX systems doing LP64 except for Windows.\n\n3. Merged patch from @carenas (GitHub #29) to update to Unicode 14.0.0.\n\n4. Merged patch from @carenas (GitHub #30):\n\n  * Cleanup: remove references to no longer used stdint.h\n\n  Since 19c50b9d (Unconditionally use inttypes.h instead of trying for stdint.h\n  (simplification) and remove the now unnecessary inclusion in\n  pcre2_internal.h., 2018-11-14), stdint.h is no longer used.\n\n  Remove checks for it in autotools and CMake and document better the expected\n  build failures for systems that might have stdint.h (C99) and not inttypes.h\n  (from POSIX), like old Windows.\n\n  * Cleanup: remove detection for inttypes.h which is a hard dependency\n\n  CMake checks for standard headers are not meant to be used for hard\n  dependencies, so will prevent a possible fallback to work.\n\n  Alternatively, the header could be checked to make the configuration fail\n  instead of breaking the build, but that was punted, as it was missing anyway\n  from autotools.\n\n5. Merged patch from @carenas (GitHub #32):\n\n  * jit: allow building with ancient MSVC versions\n\n  Visual Studio older than 2013 fails to build with JIT enabled, because it is\n  unable to parse non C89 compatible syntax, with mixed declarations and code.\n  While most recent compilers wouldn't even report this as a warning since it\n  is valid C99, it could be also made visible by adding to gcc/clang the\n  -Wdeclaration-after-statement flag at build time.\n\n  Move the code below the affected definitions.\n\n  * pcre2grep: avoid mixing declarations with code\n\n  Since d5a61ee8 (Patch to detect (and ignore) symlink loops in pcre2grep,\n  2021-08-28), code will fail to build in a strict C89 compiler.\n\n  Reformat slightly to make it C89 compatible again.\n\n\nVersion 10.38 01-October-2021\n-----------------------------\n\n1. Fix invalid single character repetition issues in JIT when the repetition\nis inside a capturing bracket and the bracket is preceded by character\nliterals.\n\n2. Installed revised CMake configuration files provided by Jan-Willem Blokland.\nThis extends the CMake build system to build both static and shared libraries\nin one go, builds the static library with PIC, and exposes PCRE2 libraries\nusing the CMake config files. JWB provided these notes:\n\n- Introduced CMake variable BUILD_STATIC_LIBS to build the static library.\n\n- Make a small modification to config-cmake.h.in by removing the PCRE2_STATIC\n  variable. Added PCRE2_STATIC variable to the static build using the\n  target_compile_definitions() function.\n\n- Extended the CMake config files.\n\n  - Introduced CMake variable PCRE2_USE_STATIC_LIBS to easily switch between\n    the static and shared libraries.\n\n  - Added the PCRE_STATIC variable to the target compile definitions for the\n    import of the static library.\n\nBuilding static and shared libraries using MSVC results in a name clash of\nthe libraries. Both static and shared library builds create, for example, the\nfile pcre2-8.lib. Therefore, I decided to change the static library names by\nadding \"-static\". For example, pcre2-8.lib has become pcre2-8-static.lib.\n[Comment by PH: this is MSVC-specific. It doesn't happen on Linux.]\n\n3. Increased the minimum release number for CMake to 3.0.0 because older than\n2.8.12 is deprecated (it was set to 2.8.5) and causes warnings. Even 3.0.0 is\nquite old; it was released in 2014.\n\n4. Implemented a modified version of Thomas Tempelmann's pcre2grep patch for\ndetecting symlink loops. This is dependent on the availability of realpath(),\nwhich is now tested for in ./configure and CMakeLists.txt.\n\n5. Implemented a modified version of Thomas Tempelmann's patch for faster\ncase-independent \"first code unit\" searches for unanchored patterns in 8-bit\nmode in the interpreters. Instead of just remembering whether one case matched\nor not, it remembers the position of a previous match so as to avoid\nunnecessary repeated searching.\n\n6. Perl now locks out \\K in lookarounds, so PCRE2 now does the same by default.\nHowever, just in case anybody was relying on the old behaviour, there is an\noption called PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK that enables the old behaviour.\nAn option has also been added to pcre2grep to enable this.\n\n7. Re-enable a JIT optimization which was unintentionally disabled in 10.35.\n\n8. There is a loop counter to catch excessively crazy patterns when checking\nthe lengths of lookbehinds at compile time. This was incorrectly getting reset\nwhenever a lookahead was processed, leading to some fuzzer-generated patterns\ntaking a very long time to compile when (?|) was present in the pattern,\nbecause (?|) disables caching of group lengths.\n\n\nVersion 10.37 26-May-2021\n-------------------------\n\n1. Change RunGrepTest to use tr instead of sed when testing with binary\nzero bytes, because sed varies a lot from system to system and has problems\nwith binary zeros. This is from Bugzilla #2681. Patch from Jeremie\nCourreges-Anglas via Nam Nguyen. This fixes RunGrepTest for OpenBSD. Later:\nit broke it for at least one version of Solaris, where tr can't handle binary\nzeros. However, that system had /usr/xpg4/bin/tr installed, which works OK, so\nRunGrepTest now checks for that command and uses it if found.\n\n2. Compiling with gcc 10.2's -fanalyzer option showed up a hypothetical problem\nwith a NULL dereference. I don't think this case could ever occur in practice,\nbut I have put in a check in order to get rid of the compiler error.\n\n3. An alternative patch for CMakeLists.txt because 10.36 #4 breaks CMake on\nWindows. Patch from email@cs-ware.de fixes bugzilla #2688.\n\n4. Two bugs related to over-large numbers have been fixed so the behaviour is\nnow the same as Perl.\n\n  (a) A pattern such as /\\214748364/ gave an overflow error instead of being\n  treated as the octal number \\214 followed by literal digits.\n\n  (b) A sequence such as {65536 that has no terminating } so is not a\n  quantifier was nevertheless complaining that a quantifier number was too big.\n\n5. A run of autoconf suggested that configure.ac was out-of-date with respect\nto the lastest autoconf. Running autoupdate made some valid changes, some valid\nsuggestions, and also some invalid changes, which were fixed by hand. Autoconf\nnow runs clean and the resulting \"configure\" seems to work, so I hope nothing\nis broken. Later: the requirement for autoconf 2.70 broke some automatic test\nrobots. It doesn't seem to be necessary: trying a reduction to 2.60.\n\n6. The pattern /a\\K.(?0)*/ when matched against \"abac\" by the interpreter gave\nthe answer \"bac\", whereas Perl and JIT both yield \"c\". This was because the\neffect of \\K was not propagating back from the full pattern recursion. Other\nrecursions such as /(a\\K.(?1)*)/ did not have this problem.\n\n7. Restore single character repetition optimization in JIT. Currently fewer\ncharacter repetitions are optimized than in 10.34.\n\n8. When the names of the functions in the POSIX wrapper were changed to\npcre2_regcomp() etc. (see change 10.33 #4 below), functions with the original\nnames were left in the library so that pre-compiled programs would still work.\nHowever, this has proved troublesome when programs link with several libraries,\nsome of which use PCRE2 via the POSIX interface while others use a native POSIX\nlibrary. For this reason, the POSIX function names are removed in this release.\nThe macros in pcre2posix.h should ensure that re-compiling fixes any programs\nthat haven't been compiled since before 10.33.\n\n\nVersion 10.36 04-December-2020\n------------------------------\n\n1. Add CET_CFLAGS so that when Intel CET is enabled, pass -mshstk to\ncompiler. This fixes https://bugs.exim.org/show_bug.cgi?id=2578. Patch for\nMakefile.am and configure.ac by H.J. Lu. Equivalent patch for CMakeLists.txt\ninvented by PH.\n\n2. Fix inifinite loop when a single byte newline is searched in JIT when\ninvalid utf8 mode is enabled.\n\n3. Updated CMakeLists.txt with patch from Wolfgang St\u00f6ggl (Bugzilla #2584):\n\n  - Include GNUInstallDirs and use ${CMAKE_INSTALL_LIBDIR} instead of hardcoded\n    lib. This allows differentiation between lib and lib64.\n    CMAKE_INSTALL_LIBDIR is used for installation of libraries and also for\n    pkgconfig file generation.\n\n  - Add the version of PCRE2 to the configuration summary like ./configure\n    does.\n\n  - Fix typo: MACTHED_STRING->MATCHED_STRING\n\n4. Updated CMakeLists.txt with another patch from Wolfgang St\u00f6ggl (Bugzilla\n#2588):\n\n  - Add escaped double quotes around include directory in CMakeLists.txt to\n    allow spaces in directory names.\n\n  - This fixes a cmake error, if the path of the pcre2 source contains a space.\n\n5. Updated CMakeLists.txt with a patch from B. Scott Michel: CMake's\ndocumentation suggests using CHECK_SYMBOL_EXISTS over CHECK_FUNCTION_EXIST.\nMoreover, these functions come from specific header files, which need to be\nspecified (and, thankfully, are the same on both the Linux and WinXX\nplatforms.)\n\n6. Added a (uint32_t) cast to prevent a compiler warning in pcre2_compile.c.\n\n7. Applied a patch from Wolfgang St\u00f6ggl (Bugzilla #2600) to fix postfix for\ndebug Windows builds using CMake. This also updated configure so that it\ngenerates *.pc files and pcre2-config with the same content, as in the past.\n\n8. If a pattern ended with (?(VERSION=n.d where n is any number but d is just a\nsingle digit, the code unit beyond d was being read (i.e. there was a read\nbuffer overflow). Fixes ClusterFuzz 23779.\n\n9. After the rework in r1235, certain character ranges were incorrectly\nhandled by an optimization in JIT. Furthermore a wrong offset was used to\nread a value from a buffer which could lead to memory overread.\n\n10. Unnoticed for many years was the fact that delimiters other than / in the\ntestinput1 and testinput4 files could cause incorrect behaviour when these\nfiles were processed by perltest.sh. There were several tests that used quotes\nas delimiters, and it was just luck that they didn't go wrong with perltest.sh.\nAll the patterns in testinput1 and testinput4 now use / as their delimiter.\nThis fixes Bugzilla #2641.\n\n11. Perl has started to give an error for \\K within lookarounds (though there\nare cases where it doesn't). PCRE2 still allows this, so the tests that include\nthis case have been moved from test 1 to test 2.\n\n12. Further to 10 above, pcre2test has been updated to detect and grumble if a\ndelimiter other than / is used after #perltest.\n\n13. Fixed a bug with PCRE2_MATCH_INVALID_UTF in 8-bit mode when PCRE2_CASELESS\nwas set and PCRE2_NO_START_OPTIMIZE was not set. The optimization for finding\nthe start of a match was not resetting correctly after a failed match on the\nfirst valid fragment of the subject, possibly causing incorrect \"no match\"\nreturns on subsequent fragments. For example, the pattern /A/ failed to match\nthe subject \\xe5A. Fixes Bugzilla #2642.\n\n14. Fixed a bug in character set matching when JIT is enabled and both unicode\nscripts and unicode classes are present at the same time.\n\n15. Added GNU grep's -m (aka --max-count) option to pcre2grep.\n\n16. Refactored substitution processing in pcre2grep strings, both for the -O\noption and when dealing with callouts. There is now a single function that\nhandles $ expansion in all cases (instead of multiple copies of almost\nidentical code). This means that the same escape sequences are available\neverywhere, which was not previously the case. At the same time, the escape\nsequences $x{...} and $o{...} have been introduced, to allow for characters\nwhose code points are greater than 255 in Unicode mode.\n\n17. Applied the patch from Bugzilla #2628 to RunGrepTest. This does an explicit\ntest for a version of sed that can handle binary zero, instead of assuming that\nany Linux version will work. Later: replaced $(...) by `...` because not all\nshells recognize the former.\n\n18. Fixed a word boundary check bug in JIT when partial matching is enabled.\n\n19. Fix ARM64 compilation warning in JIT. Patch by Carlo.\n\n20. A bug in the RunTest script meant that if the first part of test 2 failed,\nthe failure was not reported.\n\n21. Test 2 was failing when run from a directory other than the source\ndirectory. This failure was previously missed in RunTest because of 20 above.\nFixes added to both RunTest and RunTest.bat.\n\n22. Patch to CMakeLists.txt from Daniel to fix problem with testing under\nWindows.\n\n\nVersion 10.35 09-May-2020\n---------------------------\n\n1. Use PCRE2_MATCH_EMPTY flag to detect empty matches in JIT.\n\n2. Fix ARMv5 JIT improper handling of labels right after a constant pool.\n\n3. A JIT bug is fixed which allowed to read the fields of the compiled\npattern before its existence is checked.\n\n4. Back in the PCRE1 day, capturing groups that contained recursive back\nreferences to themselves were made atomic (version 8.01, change 18) because\nafter the end a repeated group, the captured substrings had their values from\nthe final repetition, not from an earlier repetition that might be the\ndestination of a backtrack. This feature was documented, and was carried over\ninto PCRE2. However, it has now been realized that the major refactoring that\nwas done for 10.30 has made this atomicizing unnecessary, and it is confusing\nwhen users are unaware of it, making some patterns appear not to be working as\nexpected. Capture values of recursive back references in repeated groups are\nnow correctly backtracked, so this unnecessary restriction has been removed.\n\n5. Added PCRE2_SUBSTITUTE_LITERAL.\n\n6. Avoid some VS compiler warnings.\n\n7. Added PCRE2_SUBSTITUTE_MATCHED.\n\n8. Added (?* and (?<* as synonyms for (*napla: and (*naplb: to match another\nregex engine. The Perl regex folks are aware of this usage and have made a note\nabout it.\n\n9. When an assertion is repeated, PCRE2 used to limit the maximum repetition to\n1, believing that repeating an assertion is pointless. However, if a positive\nassertion contains capturing groups, repetition can be useful. In any case, an\nassertion could always be wrapped in a repeated group. The only restriction\nthat is now imposed is that an unlimited maximum is changed to one more than\nthe minimum.\n\n10. Fix *THEN verbs in lookahead assertions in JIT.\n\n11. Added PCRE2_SUBSTITUTE_REPLACEMENT_ONLY.\n\n12. The JIT stack should be freed when the low-level stack allocation fails.\n\n13. In pcre2grep, if the final line in a scanned file is output but does not\nend with a newline sequence, add a newline according to the --newline setting.\n\n14. (?(DEFINE)...) groups were not being handled correctly when checking for\nthe fixed length of a lookbehind assertion. Such a group within a lookbehind\nshould be skipped, as it does not contribute to the length of the group.\nInstead, the (DEFINE) group was being processed, and if at the end of the\nlookbehind, that end was not correctly recognized. Errors such as \"lookbehind\nassertion is not fixed length\" and also \"internal error: bad code value in\nparsed_skip()\" could result.\n\n15. Put a limit of 1000 on recursive calls in pcre2_study() when searching\nnested groups for starting code units, in order to avoid stack overflow issues.\nIf the limit is reached, it just gives up trying for this optimization.\n\n16. The control verb chain list must always be restored when exiting from a\nrecurse function in JIT.\n\n17. Fix a crash which occurs when the character type of an invalid UTF\ncharacter is decoded in JIT.\n\n18. Changes in many areas of the code so that when Unicode is supported and\nPCRE2_UCP is set without PCRE2_UTF, Unicode character properties are used for\nupper/lower case computations on characters whose code points are greater than\n127.\n\n19. The function for checking UTF-16 validity was returning an incorrect offset\nfor the start of the error when a high surrogate was not followed by a valid\nlow surrogate. This caused incorrect behaviour, for example when\nPCRE2_MATCH_INVALID_UTF was set and a match started immediately following the\ninvalid high surrogate, such as /aa/ matching \"\\x{d800}aa\".\n\n20. If a DEFINE group immediately preceded a lookbehind assertion, the pattern\ncould be mis-compiled and therefore not match correctly. This is the example\nthat found this: /(?(DEFINE)(?<foo>bar))(?<![-a-z0-9])word/ which failed to\nmatch \"word\" because the \"move back\" value was set to zero.\n\n21. Following a request from a user, some extensions and tidies to the\ncharacter tables handling have been done:\n\n  (a) The dftables auxiliary program is renamed pcre2_dftables, but it is still\n  not installed for public use.\n\n  (b) There is now a -b option for pcre2_dftables, which causes the tables to\n  be written in binary. There is also a -help option.\n\n  (c) PCRE2_CONFIG_TABLES_LENGTH is added to pcre2_config() so that an\n  application that wants to save tables in binary knows how long they are.\n\n22. Changed setting of CMAKE_MODULE_PATH in CMakeLists.txt from SET to\nLIST(APPEND...) to allow a setting from the command line to be included.\n\n23. Updated to Unicode 13.0.0.\n\n24. CMake build now checks for secure_getenv() and strerror(). Patch by Carlo.\n\n25. Avoid using [-1] as a suffix in pcre2test because it can provoke a compiler\nwarning.\n\n26. Added tests for __attribute__((uninitialized)) to both the configure and\nCMake build files, and then applied this attribute to the variable called\nstack_frames_vector[] in pcre2_match(). When implemented, this disables\nautomatic initialization (a facility in clang), which can take time on big\nvariables.\n\n27. Updated CMakeLists.txt (patches by Uwe Korn) to add support for\npcre2-config, the libpcre*.pc files, SOVERSION, VERSION and the\nMACHO_*_VERSIONS settings for CMake builds.\n\n28. Another patch to CMakeLists.txt to check for mkostemp (configure already\ndoes). Patch by Carlo Marcelo Arenas Belon.\n\n29. Check for the existence of memfd_create in both CMake and configure\nconfigurations. Patch by Carlo Marcelo Arenas Belon.\n\n30. Restrict the configuration setting for the SELinux compatible execmem\nallocator (change 10.30/44) to Linux and NetBSD.\n\n\nVersion 10.34 21-November-2019\n------------------------------\n\n1. The maximum number of capturing subpatterns is 65535 (documented), but no\ncheck on this was ever implemented. This omission has been rectified; it fixes\nClusterFuzz 14376.\n\n2. Improved the invalid utf32 support of the JIT compiler. Now it correctly\ndetects invalid characters in the 0xd800-0xdfff range.\n\n3. Fix minor typo bug in JIT compile when \\X is used in a non-UTF string.\n\n4. Add support for matching in invalid UTF strings to the pcre2_match()\ninterpreter, and integrate with the existing JIT support via the new\nPCRE2_MATCH_INVALID_UTF compile-time option.\n\n5. Give more error detail for invalid UTF-8 when detected in pcre2grep.\n\n6. Add support for invalid UTF-8 to pcre2grep.\n\n7. Adjust the limit for \"must have\" code unit searching, in particular,\nincrease it substantially for non-anchored patterns.\n\n8. Allow (*ACCEPT) to be quantified, because an ungreedy quantifier with a zero\nminimum is potentially useful.\n\n9. Some changes to the way the minimum subject length is handled:\n\n   * When PCRE2_NO_START_OPTIMIZE is set, no minimum length is computed;\n     pcre2test now omits this item instead of showing a value of zero.\n\n   * An incorrect minimum length could be calculated for a pattern that\n     contained (*ACCEPT) inside a qualified group whose minimum repetition was\n     zero, for example /A(?:(*ACCEPT))?B/, which incorrectly computed a minimum\n     of 2. The minimum length scan no longer happens for a pattern that\n     contains (*ACCEPT).\n\n   * When no minimum length is set by the normal scan, but a first and/or last\n     code unit is recorded, set the minimum to 1 or 2 as appropriate.\n\n   * When a pattern contains multiple groups with the same number, a back\n     reference cannot know which one to scan for a minimum length. This used to\n     cause the minimum length finder to give up with no result. Now it treats\n     such references as not adding to the minimum length (which it should have\n     done all along).\n\n   * Furthermore, the above action now happens only if the back reference is to\n     a group that exists more than once in a pattern instead of any back\n     reference in a pattern with duplicate numbers.\n\n10. A (*MARK) value inside a successful condition was not being returned by the\ninterpretive matcher (it was returned by JIT). This bug has been mended.\n\n11. A bug in pcre2grep meant that -o without an argument (or -o0) didn't work\nif the pattern had more than 32 capturing parentheses. This is fixed. In\naddition (a) the default limit for groups requested by -o<n> has been raised to\n50, (b) the new --om-capture option changes the limit, (c) an error is raised\nif -o asks for a group that is above the limit.\n\n12. The quantifier {1} was always being ignored, but this is incorrect when it\nis made possessive and applied to an item in parentheses, because a\nparenthesized item may contain multiple branches or other backtracking points,\nfor example /(a|ab){1}+c/ or /(a+){1}+a/.\n\n13. For partial matches, pcre2test was always showing the maximum lookbehind\ncharacters, flagged with \"<\", which is misleading when the lookbehind didn't\nactually look behind the start (because it was later in the pattern). Showing\nall consulted preceding characters for partial matches is now controlled by the\nexisting \"allusedtext\" modifier and, as for complete matches, this facility is\navailable only for non-JIT matching, because JIT does not maintain the first\nand last consulted characters.\n\n14. DFA matching (using pcre2_dfa_match()) was not recognising a partial match\nif the end of the subject was encountered in a lookahead (conditional or\notherwise), an atomic group, or a recursion.\n\n15. Give error if pcre2test -t, -T, -tm or -TM is given an argument of zero.\n\n16. Check for integer overflow when computing lookbehind lengths. Fixes\nClusterfuzz issue 15636.\n\n17. Implemented non-atomic positive lookaround assertions.\n\n18. If a lookbehind contained a lookahead that contained another lookbehind\nwithin it, the nested lookbehind was not correctly processed. For example, if\n/(?<=(?=(?<=a)))b/ was matched to \"ab\" it gave no match instead of matching\n\"b\".\n\n19. Implemented pcre2_get_match_data_size().\n\n20. Two alterations to partial matching:\n\n    (a) The definition of a partial match is slightly changed: if a pattern\n    contains any lookbehinds, an empty partial match may be given, because this\n    is another situation where adding characters to the current subject can\n    lead to a full match. Example: /c*+(?<=[bc])/ with subject \"ab\".\n\n    (b) Similarly, if a pattern could match an empty string, an empty partial\n    match may be given. Example: /(?![ab]).*/ with subject \"ab\". This case\n    applies only to PCRE2_PARTIAL_HARD.\n\n    (c) An empty string partial hard match can be returned for \\z and \\Z as it\n    is documented that they shouldn't match.\n\n21. A branch that started with (*ACCEPT) was not being recognized as one that\ncould match an empty string.\n\n22. Corrected pcre2_set_character_tables() tables data type: was const unsigned\nchar * instead of const uint8_t *, as generated by pcre2_maketables().\n\n23. Upgraded to Unicode 12.1.0.\n\n24. Add -jitfast command line option to pcre2test (to make all the jit options\navailable directly).\n\n25. Make pcre2test -C show if libreadline or libedit is supported.\n\n26. If the length of one branch of a group exceeded 65535 (the maximum value\nthat is remembered as a minimum length), the whole group's length was\nincorrectly recorded as 65535, leading to incorrect \"no match\" when start-up\noptimizations were in force.\n\n27. The \"rightmost consulted character\" value was not always correct; in\nparticular, if a pattern ended with a negative lookahead, characters that were\ninspected in that lookahead were not included.\n\n28. Add the pcre2_maketables_free() function.\n\n29. The start-up optimization that looks for a unique initial matching\ncode unit in the interpretive engines uses memchr() in 8-bit mode. When the\nsearch is caseless, it was doing so inefficiently, which ended up slowing down\nthe match drastically when the subject was very long. The revised code (a)\nremembers if one case is not found, so it never repeats the search for that\ncase after a bumpalong and (b) when one case has been found, it searches only\nup to that position for an earlier occurrence of the other case. This fix\napplies to both interpretive pcre2_match() and to pcre2_dfa_match().\n\n30. While scanning to find the minimum length of a group, if any branch has\nminimum length zero, there is no need to scan any subsequent branches (a small\ncompile-time performance improvement).\n\n31. Installed a .gitignore file on a user's suggestion. When using the svn\nrepository with git (through git svn) this helps keep it tidy.\n\n32. Add underflow check in JIT which may occur when the value of subject\nstring pointer is close to 0.\n\n33. Arrange for classes such as [Aa] which contain just the two cases of the\nsame character, to be treated as a single caseless character. This causes the\nfirst and required code unit optimizations to kick in where relevant.\n\n34. Improve the bitmap of starting bytes for positive classes that include wide\ncharacters, but no property types, in UTF-8 mode. Previously, on encountering\nsuch a class, the bits for all bytes greater than \\xc4 were set, thus\nspecifying any character with codepoint >= 0x100. Now the only bits that are\nset are for the relevant bytes that start the wide characters. This can give a\nnoticeable performance improvement.\n\n35. If the bitmap of starting code units contains only 1 or 2 bits, replace it\nwith a single starting code unit (1 bit) or a caseless single starting code\nunit if the two relevant characters are case-partners. This is particularly\nrelevant to the 8-bit library, though it applies to all. It can give a\nperformance boost for patterns such as [Ww]ord and (word|WORD). However, this\noptimization doesn't happen if there is a \"required\" code unit of the same\nvalue (because the search for a \"required\" code unit starts at the match start\nfor non-unique first code unit patterns, but after a unique first code unit,\nand patterns such as a*a need the former action).\n\n36. Small patch to pcre2posix.c to set the erroroffset field to -1 immediately\nafter a successful compile, instead of at the start of matching to avoid a\nsanitizer complaint (regexec is supposed to be thread safe).\n\n37. Add NEON vectorization to JIT to speed up matching of first character and\npairs of characters on ARM64 CPUs.\n\n38. If a non-ASCII character was the first in a starting assertion in a\ncaseless match, the \"first code unit\" optimization did not get the casing\nright, and the assertion failed to match a character in the other case if it\ndid not start with the same code unit.\n\n39. Fixed the incorrect computation of jump sizes on x86 CPUs in JIT. A masking\noperation was incorrectly removed in r1136. Reported by Ralf Junker.\n\n\nVersion 10.33 16-April-2019\n---------------------------\n\n1. Added \"allvector\" to pcre2test to make it easy to check the part of the\novector that shouldn't be changed, in particular after substitute and failed or\npartial matches.\n\n2. Fix subject buffer overread in JIT when UTF is disabled and \\X or \\R has\na greater than 1 fixed quantifier. This issue was found by Yunho Kim.\n\n3. Added support for callouts from pcre2_substitute(). After 10.33-RC1, but\nprior to release, fixed a bug that caused a crash if pcre2_substitute() was\ncalled with a NULL match context.\n\n4. The POSIX functions are now all called pcre2_regcomp() etc., with wrapper\nfunctions that use the standard POSIX names. However, in pcre2posix.h the POSIX\nnames are defined as macros. This should help avoid linking with the wrong\nlibrary in some environments while still exporting the POSIX names for\npre-existing programs that use them. (The Debian alternative names are also\ndefined as macros, but not documented.)\n\n5. Fix an xclass matching issue in JIT.\n\n6. Implement PCRE2_EXTRA_ESCAPED_CR_IS_LF (see Bugzilla 2315).\n\n7. Implement the Perl 5.28 experimental alphabetic names for atomic groups and\nlookaround assertions, for example, (*pla:...) and (*atomic:...). These are\ncharacterized by a lower case letter following (* and to simplify coding for\nthis, the character tables created by pcre2_maketables() were updated to add a\nnew \"is lower case letter\" bit. At the same time, the now unused \"is\nhexadecimal digit\" bit was removed. The default tables in\nsrc/pcre2_chartables.c.dist are updated.\n\n8. Implement the new Perl \"script run\" features (*script_run:...) and\n(*atomic_script_run:...) aka (*sr:...) and (*asr:...).\n\n9. Fixed two typos in change 22 for 10.21, which added special handling for\nranges such as a-z in EBCDIC environments. The original code probably never\nworked, though there were no bug reports.\n\n10. Implement PCRE2_COPY_MATCHED_SUBJECT for pcre2_match() (including JIT via\npcre2_match()) and pcre2_dfa_match(), but *not* the pcre2_jit_match() fast\npath. Also, when a match fails, set the subject field in the match data to NULL\nfor tidiness - none of the substring extractors should reference this after\nmatch failure.\n\n11. If a pattern started with a subroutine call that had a quantifier with a\nminimum of zero, an incorrect \"match must start with this character\" could be\nrecorded. Example: /(?&xxx)*ABC(?<xxx>XYZ)/ would (incorrectly) expect 'A' to\nbe the first character of a match.\n\n12. The heap limit checking code in pcre2_dfa_match() could suffer from\noverflow if the heap limit was set very large. This could cause incorrect \"heap\nlimit exceeded\" errors.\n\n13. Add \"kibibytes\" to the heap limit output from pcre2test -C to make the\nunits clear.\n\n14. Add a call to pcre2_jit_free_unused_memory() in pcre2grep, for tidiness.\n\n15. Updated the VMS-specific code in pcre2test on the advice of a VMS user.\n\n16. Removed the unnecessary inclusion of stdint.h (or inttypes.h) from\npcre2_internal.h as it is now included by pcre2.h. Also, change 17 for 10.32\nbelow was unnecessarily complicated, as inttypes.h is a Standard C header,\nwhich is defined to be a superset of stdint.h. Instead of conditionally\nincluding stdint.h or inttypes.h, pcre2.h now unconditionally includes\ninttypes.h. This supports environments that do not have stdint.h but do have\ninttypes.h, which are known to exist. A note in the autotools documentation\nsays (November 2018) that there are none known that are the other way round.\n\n17. Added --disable-percent-zt to \"configure\" (and equivalent to CMake) to\nforcibly disable the use of %zu and %td in formatting strings because there is\nat least one version of VMS that claims to be C99 but does not support these\nmodifiers.\n\n18. Added --disable-pcre2grep-callout-fork, which restricts the callout support\nin pcre2grep to the inbuilt echo facility. This may be useful in environments\nthat do not support fork().\n\n19. Fix two instances of <= 0 being applied to unsigned integers (the VMS\ncompiler complains).\n\n20. Added \"fork\" support for VMS to pcre2grep, for running an external program\nvia a string callout.\n\n21. Improve MAP_JIT flag usage on MacOS. Patch by Rich Siegel.\n\n22. If a pattern started with (*MARK), (*COMMIT), (*PRUNE), (*SKIP), or (*THEN)\nfollowed by ^ it was not recognized as anchored.\n\n23. The RunGrepTest script used to cut out the test of NUL characters for\nSolaris and MacOS as printf and sed can't handle them. It seems that the *BSD\nsystems can't either. I've inverted the test so that only those OS that are\nknown to work (currently only Linux) try to run this test.\n\n24. Some tests in RunGrepTest appended to testtrygrep from two different file\ndescriptors instead of redirecting stderr to stdout. This worked on Linux, but\nit was reported not to on other systems, causing the tests to fail.\n\n25. In the RunTest script, make the test for stack setting use the same value\nfor the stack as it needs for -bigstack.\n\n26. Insert a cast in pcre2_dfa_match.c to suppress a compiler warning.\n\n26. With PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL set, escape sequences such as \\s\nwhich are valid in character classes, but not as the end of ranges, were being\ntreated as literals. An example is [_-\\s] (but not [\\s-_] because that gave an\nerror at the *start* of a range). Now an \"invalid range\" error is given\nindependently of PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n27. Related to 26 above, PCRE2_BAD_ESCAPE_IS_LITERAL was affecting known escape\nsequences such as \\eX when they appeared invalidly in a character class. Now\nthe option applies only to unrecognized or malformed escape sequences.\n\n28. Fix word boundary in JIT compiler. Patch by Mike Munday.\n\n29. The pcre2_dfa_match() function was incorrectly handling conditional version\ntests such as (?(VERSION>=0)...) when the version test was true. Incorrect\nprocessing or a crash could result.\n\n30. When PCRE2_UTF is set, allow non-ASCII letters and decimal digits in group\nnames, as Perl does. There was a small bug in this new code, found by\nClusterFuzz 12950, fixed before release.\n\n31. Implemented PCRE2_EXTRA_ALT_BSUX to support ECMAScript 6's \\u{hhh}\nconstruct.\n\n32. Compile \\p{Any} to be the same as . in DOTALL mode, so that it benefits\nfrom auto-anchoring if \\p{Any}* starts a pattern.\n\n33. Compile invalid UTF check in JIT test when only pcre32 is enabled.\n\n34. For some time now, CMake has been warning about the setting of policy\nCMP0026 to \"OLD\" in CmakeLists.txt, and hinting that the feature might be\nremoved in a future version. A request for CMake expertise on the list produced\nno result, so I have now hacked CMakeLists.txt along the lines of some changes\nI found on the Internet. The new code no longer needs the policy setting, and\nit appears to work fine on Linux.\n\n35. Setting --enable-jit=auto for an out-of-tree build failed because the\nsource directory wasn't in the search path for AC_TRY_COMPILE always. Patch\nfrom Ross Burton.\n\n36. Disable SSE2 JIT optimizations in x86 CPUs when SSE2 is not available.\nPatch by Guillem Jover.\n\n37. Changed expressions such as 1<<10 to 1u<<10 in many places because compiler\nwarnings were reported.\n\n38. Using the clang compiler with sanitizing options causes runtime complaints\nabout truncation for statements such as x = ~x when x is an 8-bit value; it\nseems to compute ~x as a 32-bit value. Changing such statements to x = 255 ^ x\ngets rid of the warnings. There were also two missing casts in pcre2test.\n\n\nVersion 10.32 10-September-2018\n-------------------------------\n\n1. When matching using the the REG_STARTEND feature of the POSIX API with a\nnon-zero starting offset, unset capturing groups with lower numbers than a\ngroup that did capture something were not being correctly returned as \"unset\"\n(that is, with offset values of -1).\n\n2. When matching using the POSIX API, pcre2test used to omit listing unset\ngroups altogether. Now it shows those that come before any actual captures as\n\"<unset>\", as happens for non-POSIX matching.\n\n3. Running \"pcre2test -C\" always stated \"\\R matches CR, LF, or CRLF only\",\nwhatever the build configuration was. It now correctly says \"\\R matches all\nUnicode newlines\" in the default case when --enable-bsr-anycrlf has not been\nspecified. Similarly, running \"pcre2test -C bsr\" never produced the result\nANY.\n\n4. Matching the pattern /(*UTF)\\C[^\\v]+\\x80/ against an 8-bit string containing\nmulti-code-unit characters caused bad behaviour and possibly a crash. This\nissue was fixed for other kinds of repeat in release 10.20 by change 19, but\nrepeating character classes were overlooked.\n\n5. pcre2grep now supports the inclusion of binary zeros in patterns that are\nread from files via the -f option.\n\n6. A small fix to pcre2grep to avoid compiler warnings for -Wformat-overflow=2.\n\n7. Added --enable-jit=auto support to configure.ac.\n\n8. Added some dummy variables to the heapframe structure in 16-bit and 32-bit\nmodes for the benefit of m68k, where pointers can be 16-bit aligned. The\ndummies force 32-bit alignment and this ensures that the structure is a\nmultiple of PCRE2_SIZE, a requirement that is tested at compile time. In other\narchitectures, alignment requirements take care of this automatically.\n\n9. When returning an error from pcre2_pattern_convert(), ensure the error\noffset is set zero for early errors.\n\n10. A number of patches for Windows support from Daniel Richard G:\n\n  (a) List of error numbers in Runtest.bat corrected (it was not the same as in\n      Runtest).\n\n  (b) pcre2grep snprintf() workaround as used elsewhere in the tree.\n\n  (c) Support for non-C99 snprintf() that returns -1 in the overflow case.\n\n11. Minor tidy of pcre2_dfa_match() code.\n\n12. Refactored pcre2_dfa_match() so that the internal recursive calls no longer\nuse the stack for local workspace and local ovectors. Instead, an initial block\nof stack is reserved, but if this is insufficient, heap memory is used. The\nheap limit parameter now applies to pcre2_dfa_match().\n\n13. If a \"find limits\" test of DFA matching in pcre2test resulted in too many\nmatches for the ovector, no matches were displayed.\n\n14. Removed an occurrence of ctrl/Z from test 6 because Windows treats it as\nEOF. The test looks to have come from a fuzzer.\n\n15. If PCRE2 was built with a default match limit a lot greater than the\ndefault default of 10 000 000, some JIT tests of the match limit no longer\nfailed. All such tests now set 10 000 000 as the upper limit.\n\n16. Another Windows related patch for pcregrep to ensure that WIN32 is\nundefined under Cygwin.\n\n17. Test for the presence of stdint.h and inttypes.h in configure and CMake and\ninclude whichever exists (stdint preferred) instead of unconditionally\nincluding stdint. This makes life easier for old and non-standard systems.\n\n18. Further changes to improve portability, especially to old and or non-\nstandard systems:\n\n  (a) Put all printf arguments in RunGrepTest into single, not double, quotes,\n      and use \\0 not \\x00 for binary zero.\n\n  (b) Avoid the use of C++ (i.e. BCPL) // comments.\n\n  (c) Parameterize the use of %zu in pcre2test to make it like %td. For both of\n      these now, if using MSVC or a standard C before C99, %lu is used with a\n      cast if necessary.\n\n19. Applied a contributed patch to CMakeLists.txt to increase the stack size\nwhen linking pcre2test with MSVC. This gets rid of a stack overflow error in\nthe standard set of tests.\n\n20. Output a warning in pcre2test when ignoring the \"altglobal\" modifier when\nit is given with the \"replace\" modifier.\n\n21. In both pcre2test and pcre2_substitute(), with global matching, a pattern\nthat matched an empty string, but never at the starting match offset, was not\nhandled in a Perl-compatible way. The pattern /(<?=\\G.)/ is an example of such\na pattern. Because \\G is in a lookbehind assertion, there has to be a\n\"bumpalong\" before there can be a match. The automatic \"advance by one\ncharacter after an empty string match\" rule is therefore inappropriate. A more\ncomplicated algorithm has now been implemented.\n\n22. When checking to see if a lookbehind is of fixed length, lookaheads were\ncorrectly ignored, but qualifiers on lookaheads were not being ignored, leading\nto an incorrect \"lookbehind assertion is not fixed length\" error.\n\n23. The VERSION condition test was reading fractional PCRE2 version numbers\nsuch as the 04 in 10.04 incorrectly and hence giving wrong results.\n\n24. Updated to Unicode version 11.0.0. As well as the usual addition of new\nscripts and characters, this involved re-jigging the grapheme break property\nalgorithm because Unicode has changed the way emojis are handled.\n\n25. Fixed an obscure bug that struck when there were two atomic groups not\nseparated by something with a backtracking point. There could be an incorrect\nbacktrack into the first of the atomic groups. A complicated example is\n/(?>a(*:1))(?>b)(*SKIP:1)x|.*/ matched against \"abc\", where the *SKIP\nshouldn't find a MARK (because is in an atomic group), but it did.\n\n26. Upgraded the perltest.sh script: (1) #pattern lines can now be used to set\na list of modifiers for all subsequent patterns - only those that the script\nrecognizes are meaningful; (2) #subject lines can be used to set or unset a\ndefault \"mark\" modifier; (3) Unsupported #command lines give a warning when\nthey are ignored; (4) Mark data is output only if the \"mark\" modifier is\npresent.\n\n27. (*ACCEPT:ARG), (*FAIL:ARG), and (*COMMIT:ARG) are now supported.\n\n28. A (*MARK) name was not being passed back for positive assertions that were\nterminated by (*ACCEPT).\n\n29. Add support for \\N{U+dddd}, but only in Unicode mode.\n\n30. Add support for (?^) for unsetting all imnsx options.\n\n31. The PCRE2_EXTENDED (/x) option only ever discarded space characters whose\ncode point was less than 256 and that were recognized by the lookup table\ngenerated by pcre2_maketables(), which uses isspace() to identify white space.\nNow, when Unicode support is compiled, PCRE2_EXTENDED also discards U+0085,\nU+200E, U+200F, U+2028, and U+2029, which are additional characters defined by\nUnicode as \"Pattern White Space\". This makes PCRE2 compatible with Perl.\n\n32. In certain circumstances, option settings within patterns were not being\ncorrectly processed. For example, the pattern /((?i)A)(?m)B/ incorrectly\nmatched \"ab\". (The (?m) setting lost the fact that (?i) should be reset at the\nend of its group during the parse process, but without another setting such as\n(?m) the compile phase got it right.) This bug was introduced by the\nrefactoring in release 10.23.\n\n33. PCRE2 uses bcopy() if available when memmove() is not, and it used just to\ndefine memmove() as function call to bcopy(). This hasn't been tested for a\nlong time because in pcre2test the result of memmove() was being used, whereas\nbcopy() doesn't return a result. This feature is now refactored always to call\nan emulation function when there is no memmove(). The emulation makes use of\nbcopy() when available.\n\n34. When serializing a pattern, set the memctl, executable_jit, and tables\nfields (that is, all the fields that contain pointers) to zeros so that the\nresult of serializing is always the same. These fields are re-set when the\npattern is deserialized.\n\n35. In a pattern such as /[^\\x{100}-\\x{ffff}]*[\\x80-\\xff]/ which has a repeated\nnegative class with no characters less than 0x100 followed by a positive class\nwith only characters less than 0x100, the first class was incorrectly being\nauto-possessified, causing incorrect match failures.\n\n36. Removed the character type bit ctype_meta, which dates from PCRE1 and is\nnot used in PCRE2.\n\n37. Tidied up unnecessarily complicated macros used in the escapes table.\n\n38. Since 10.21, the new testoutput8-16-4 file has accidentally been omitted\nfrom distribution tarballs, owing to a typo in Makefile.am which had\ntestoutput8-16-3 twice. Now fixed.\n\n39. If the only branch in a conditional subpattern was anchored, the whole\nsubpattern was treated as anchored, when it should not have been, since the\nassumed empty second branch cannot be anchored. Demonstrated by test patterns\nsuch as /(?(1)^())b/ or /(?(?=^))b/.\n\n40. A repeated conditional subpattern that could match an empty string was\nalways assumed to be unanchored. Now it it checked just like any other\nrepeated conditional subpattern, and can be found to be anchored if the minimum\nquantifier is one or more. I can't see much use for a repeated anchored\npattern, but the behaviour is now consistent.\n\n41. Minor addition to pcre2_jit_compile.c to avoid static analyzer complaint\n(for an event that could never occur but you had to have external information\nto know that).\n\n42. If before the first match in a file that was being searched by pcre2grep\nthere was a line that was sufficiently long to cause the input buffer to be\nexpanded, the variable holding the location of the end of the previous match\nwas being adjusted incorrectly, and could cause an overflow warning from a code\nsanitizer. However, as the value is used only to print pending \"after\" lines\nwhen the next match is reached (and there are no such lines in this case) this\nbug could do no damage.\n\n\nVersion 10.31 12-February-2018\n------------------------------\n\n1. Fix typo (missing ]) in VMS code in pcre2test.c.\n\n2. Replace the replicated code for matching extended Unicode grapheme sequences\n(which got a lot more complicated by change 10.30/49) by a single subroutine\nthat is called by both pcre2_match() and pcre2_dfa_match().\n\n3. Add idempotent guard to pcre2_internal.h.\n\n4. Add new pcre2_config() options: PCRE2_CONFIG_NEVER_BACKSLASH_C and\nPCRE2_CONFIG_COMPILED_WIDTHS.\n\n5. Cut out \\C tests in the JIT regression tests when NEVER_BACKSLASH_C is\ndefined (e.g. by --enable-never-backslash-C).\n\n6. Defined public names for all the pcre2_compile() error numbers, and used\nthe public names in pcre2_convert.c.\n\n7. Fixed a small memory leak in pcre2test (convert contexts).\n\n8. Added two casts to compile.c and one to match.c to avoid compiler warnings.\n\n9. Added code to pcre2grep when compiled under VMS to set the symbol\nPCRE2GREP_RC to the exit status, because VMS does not distinguish between\nexit(0) and exit(1).\n\n10. Added the -LM (list modifiers) option to pcre2test. Also made -C complain\nabout a bad option only if the following argument item does not start with a\nhyphen.\n\n11. pcre2grep was truncating components of file names to 128 characters when\nprocessing files with the -r option, and also (some very odd code) truncating\npath names to 512 characters. There is now a check on the absolute length of\nfull path file names, which may be up to 2047 characters long.\n\n12. When an assertion contained (*ACCEPT) it caused all open capturing groups\nto be closed (as for a non-assertion ACCEPT), which was wrong and could lead to\nmisbehaviour for subsequent references to groups that started outside the\nassertion. ACCEPT in an assertion now closes only those groups that were\nstarted within that assertion. Fixes oss-fuzz issues 3852 and 3891.\n\n13. Multiline matching in pcre2grep was misbehaving if the pattern matched\nwithin a line, and then matched again at the end of the line and over into\nsubsequent lines. Behaviour was different with and without colouring, and\nsometimes context lines were incorrectly printed and/or line endings were lost.\nAll these issues should now be fixed.\n\n14. If --line-buffered was specified for pcre2grep when input was from a\ncompressed file (.gz or .bz2) a segfault occurred. (Line buffering should be\nignored for compressed files.)\n\n15. Although pcre2_jit_match checks whether the pattern is compiled\nin a given mode, it was also expected that at least one mode is available.\nThis is fixed and pcre2_jit_match returns with PCRE2_ERROR_JIT_BADOPTION\nwhen the pattern is not optimized by JIT at all.\n\n16. The line number and related variables such as match counts in pcre2grep\nwere all int variables, causing overflow when files with more than 2147483647\nlines were processed (assuming 32-bit ints). They have all been changed to\nunsigned long ints.\n\n17. If a backreference with a minimum repeat count of zero was first in a\npattern, apart from assertions, an incorrect first matching character could be\nrecorded. For example, for the pattern /(?=(a))\\1?b/, \"b\" was incorrectly set\nas the first character of a match.\n\n18. Characters in a leading positive assertion are considered for recording a\nfirst character of a match when the rest of the pattern does not provide one.\nHowever, a character in a non-assertive group within a leading assertion such\nas in the pattern /(?=(a))\\1?b/ caused this process to fail. This was an\ninfelicity rather than an outright bug, because it did not affect the result of\na match, just its speed. (In fact, in this case, the starting 'a' was\nsubsequently picked up in the study.)\n\n19. A minor tidy in pcre2_match(): making all PCRE2_ERROR_ returns use \"return\"\ninstead of \"RRETURN\" saves unwinding the backtracks in these cases (only one\ndidn't).\n\n20. Allocate a single callout block on the stack at the start of pcre2_match()\nand set its never-changing fields once only. Do the same for pcre2_dfa_match().\n\n21. Save the extra compile options (set in the compile context) with the\ncompiled pattern (they were not previously saved), add PCRE2_INFO_EXTRAOPTIONS\nto retrieve them, and update pcre2test to show them.\n\n22. Added PCRE2_CALLOUT_STARTMATCH and PCRE2_CALLOUT_BACKTRACK bits to a new\nfield callout_flags in callout blocks. The bits are set by pcre2_match(), but\nnot by JIT or pcre2_dfa_match(). Their settings are shown in pcre2test callouts\nif the callout_extra subject modifier is set. These bits are provided to help\nwith tracking how a backtracking match is proceeding.\n\n23. Updated the pcre2demo.c demonstration program, which was missing the extra\ncode for -g that handles the case when \\K in an assertion causes the match to\nend at the original start point. Also arranged for it to detect when \\K causes\nthe end of a match to be before its start.\n\n24. Similar to 23 above, strange things (including loops) could happen in\npcre2grep when \\K was used in an assertion when --colour was used or in\nmultiline mode. The \"end at original start point\" bug is fixed, and if the end\npoint is found to be before the start point, they are swapped.\n\n25. When PCRE2_FIRSTLINE without PCRE2_NO_START_OPTIMIZE was used in non-JIT\nmatching (both pcre2_match() and pcre2_dfa_match()) and the matched string\nstarted with the first code unit of a newline sequence, matching failed because\nit was not tried at the newline.\n\n26. Code for giving up a non-partial match after failing to find a starting\ncode unit anywhere in the subject was missing when searching for one of a\nnumber of code units (the bitmap case) in both pcre2_match() and\npcre2_dfa_match(). This was a missing optimization rather than a bug.\n\n27. Tidied up the ACROSSCHAR macro to be like FORWARDCHAR and BACKCHAR, using a\npointer argument rather than a code unit value. This should not have affected\nthe generated code.\n\n28. The JIT compiler has been updated.\n\n29. Avoid pointer overflow for unset captures in pcre2_substring_list_get().\nThis could not actually cause a crash because it was always used in a memcpy()\ncall with zero length.\n\n30. Some internal structures have a variable-length ovector[] as their last\nelement. Their actual memory is obtained dynamically, giving an ovector of\nappropriate length. However, they are defined in the structure as\novector[NUMBER], where NUMBER is large so that array bound checkers don't\ngrumble. The value of NUMBER was 10000, but a fuzzer exceeded 5000 capturing\ngroups, making the ovector larger than this. The number has been increased to\n131072, which allows for the maximum number of captures (65535) plus the\noverall match. This fixes oss-fuzz issue 5415.\n\n31. Auto-possessification at the end of a capturing group was dependent on what\nfollows the group (e.g. /(a+)b/ would auto-possessify the a+) but this caused\nincorrect behaviour when the group was called recursively from elsewhere in the\npattern where something different might follow. This bug is an unforseen\nconsequence of change #1 for 10.30 - the implementation of backtracking into\nrecursions. Iterators at the ends of capturing groups are no longer considered\nfor auto-possessification if the pattern contains any recursions. Fixes\nBugzilla #2232.\n\n\nVersion 10.30 14-August-2017\n----------------------------\n\n1. The main interpreter, pcre2_match(), has been refactored into a new version\nthat does not use recursive function calls (and therefore the stack) for\nremembering backtracking positions. This makes --disable-stack-for-recursion a\nNOOP. The new implementation allows backtracking into recursive group calls in\npatterns, making it more compatible with Perl, and also fixes some other\nhard-to-do issues such as #1887 in Bugzilla. The code is also cleaner because\nthe old code had a number of fudges to try to reduce stack usage. It seems to\nrun no slower than the old code.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. These\nbugs were never in fully released code, but are noted here for the record.\n\n  (a) If a pattern had fewer capturing parentheses than the ovector supplied in\n      the match data block, a memory error (detectable by ASAN) occurred after\n      a match, because the external block was being set from non-existent\n      internal ovector fields. Fixes oss-fuzz issue 781.\n\n  (b) A pattern with very many capturing parentheses (when the internal frame\n      size was greater than the initial frame vector on the stack) caused a\n      crash. A vector on the heap is now set up at the start of matching if the\n      vector on the stack is not big enough to handle at least 10 frames.\n      Fixes oss-fuzz issue 783.\n\n  (c) Handling of (*VERB)s in recursions was wrong in some cases.\n\n  (d) Captures in negative assertions that were used as conditions were not\n      happening if the assertion matched via (*ACCEPT).\n\n  (e) Mark values were not being passed out of recursions.\n\n  (f) Refactor some code in do_callout() to avoid picky compiler warnings about\n      negative indices. Fixes oss-fuzz issue 1454.\n\n  (g) Similarly refactor the way the variable length ovector is addressed for\n      similar reasons. Fixes oss-fuzz issue 1465.\n\n2. Now that pcre2_match() no longer uses recursive function calls (see above),\nthe \"match limit recursion\" value seems misnamed. It still exists, and limits\nthe depth of tree that is searched. To avoid future confusion, it has been\nrenamed as \"depth limit\" in all relevant places (--with-depth-limit,\n(*LIMIT_DEPTH), pcre2_set_depth_limit(), etc) but the old names are still\navailable for backwards compatibility.\n\n3. Hardened pcre2test so as to reduce the number of bugs reported by fuzzers:\n\n  (a) Check for malloc failures when getting memory for the ovector (POSIX) or\n      the match data block (non-POSIX).\n\n4. In the 32-bit library in non-UTF mode, an attempt to find a Unicode property\nfor a character with a code point greater than 0x10ffff (the Unicode maximum)\ncaused a crash.\n\n5. If a lookbehind assertion that contained a back reference to a group\nappearing later in the pattern was compiled with the PCRE2_ANCHORED option,\nundefined actions (often a segmentation fault) could occur, depending on what\nother options were set. An example assertion is (?<!\\1(abc)) where the\nreference \\1 precedes the group (abc). This fixes oss-fuzz issue 865.\n\n6. Added the PCRE2_INFO_FRAMESIZE item to pcre2_pattern_info() and arranged for\npcre2test to use it to output the frame size when the \"framesize\" modifier is\ngiven.\n\n7. Reworked the recursive pattern matching in the JIT compiler to follow the\ninterpreter changes.\n\n8. When the zero_terminate modifier was specified on a pcre2test subject line\nfor global matching, unpredictable things could happen. For example, in UTF-8\nmode, the pattern //g,zero_terminate read random memory when matched against an\nempty string with zero_terminate. This was a bug in pcre2test, not the library.\n\n9. Moved some Windows-specific code in pcre2grep (introduced in 10.23/13) out\nof the section that is compiled when Unix-style directory scanning is\navailable, and into a new section that is always compiled for Windows.\n\n10. In pcre2test, explicitly close the file after an error during serialization\nor deserialization (the \"load\" or \"save\" commands).\n\n11. Fix memory leak in pcre2_serialize_decode() when the input is invalid.\n\n12. Fix potential NULL dereference in pcre2_callout_enumerate() if called with\na NULL pattern pointer when Unicode support is available.\n\n13. When the 32-bit library was being tested by pcre2test, error messages that\nwere longer than 64 code units could cause a buffer overflow. This was a bug in\npcre2test.\n\n14. The alternative matching function, pcre2_dfa_match() misbehaved if it\nencountered a character class with a possessive repeat, for example [a-f]{3}+.\n\n15. The depth (formerly recursion) limit now applies to DFA matching (as\nof 10.23/36); pcre2test has been upgraded so that \\=find_limits works with DFA\nmatching to find the minimum value for this limit.\n\n16. Since 10.21, if pcre2_match() was called with a null context, default\nmemory allocation functions were used instead of whatever was used when the\npattern was compiled.\n\n17. Changes to the pcre2test \"memory\" modifier on a subject line. These apply\nonly to pcre2_match():\n\n  (a) Warn if null_context is set on both pattern and subject, because the\n      memory details cannot then be shown.\n\n  (b) Remember (up to a certain number of) memory allocations and their\n      lengths, and list only the lengths, so as to be system-independent.\n      (In practice, the new interpreter never has more than 2 blocks allocated\n      simultaneously.)\n\n18. Make pcre2test detect an error return from pcre2_get_error_message(), give\na message, and abandon the run (this would have detected #13 above).\n\n19. Implemented PCRE2_ENDANCHORED.\n\n20. Applied Jason Hood's patches (slightly modified) to pcre2grep, to implement\nthe --output=text (-O) option and the inbuilt callout echo.\n\n21. Extend auto-anchoring etc. to ignore groups with a zero qualifier and\nsingle-branch conditions with a false condition (e.g. DEFINE) at the start of a\nbranch. For example, /(?(DEFINE)...)^A/ and /(...){0}^B/ are now flagged as\nanchored.\n\n22. Added an explicit limit on the amount of heap used by pcre2_match(), set by\npcre2_set_heap_limit() or (*LIMIT_HEAP=xxx). Upgraded pcre2test to show the\nheap limit along with other pattern information, and to find the minimum when\nthe find_limits modifier is set.\n\n23. Write to the last 8 bytes of the pcre2_real_code structure when a compiled\npattern is set up so as to initialize any padding the compiler might have\nincluded. This avoids valgrind warnings when a compiled pattern is copied, in\nparticular when it is serialized.\n\n24. Remove a redundant line of code left in accidentally a long time ago.\n\n25. Remove a duplication typo in pcre2_tables.c\n\n26. Correct an incorrect cast in pcre2_valid_utf.c\n\n27. Update pcre2test, remove some unused code in pcre2_match(), and upgrade the\ntests to improve coverage.\n\n28. Some fixes/tidies as a result of looking at Coverity Scan output:\n\n    (a) Typo: \">\" should be \">=\" in opcode check in pcre2_auto_possess.c.\n    (b) Added some casts to avoid \"suspicious implicit sign extension\".\n    (c) Resource leaks in pcre2test in rare error cases.\n    (d) Avoid warning for never-use case OP_TABLE_LENGTH which is just a fudge\n        for checking at compile time that tables are the right size.\n    (e) Add missing \"fall through\" comment.\n\n29. Implemented PCRE2_EXTENDED_MORE and related /xx and (?xx) features.\n\n30. Implement (?n: for PCRE2_NO_AUTO_CAPTURE, because Perl now has this.\n\n31. If more than one of \"push\", \"pushcopy\", or \"pushtablescopy\" were set in\npcre2test, a crash could occur.\n\n32. Make -bigstack in RunTest allocate a 64MiB stack (instead of 16MiB) so\nthat all the tests can run with clang's sanitizing options.\n\n33. Implement extra compile options in the compile context and add the first\none: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES.\n\n34. Implement newline type PCRE2_NEWLINE_NUL.\n\n35. A lookbehind assertion that had a zero-length branch caused undefined\nbehaviour when processed by pcre2_dfa_match(). This is oss-fuzz issue 1859.\n\n36. The match limit value now also applies to pcre2_dfa_match() as there are\npatterns that can use up a lot of resources without necessarily recursing very\ndeeply. (Compare item 10.23/36.) This should fix oss-fuzz #1761.\n\n37. Implement PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n38. Fix returned offsets from regexec() when REG_STARTEND is used with a\nstarting offset greater than zero.\n\n39. Implement REG_PEND (GNU extension) for the POSIX wrapper.\n\n40. Implement the subject_literal modifier in pcre2test, and allow jitstack on\npattern lines.\n\n41. Implement PCRE2_LITERAL and use it to support REG_NOSPEC.\n\n42. Implement PCRE2_EXTRA_MATCH_LINE and PCRE2_EXTRA_MATCH_WORD for the benefit\nof pcre2grep.\n\n43. Re-implement pcre2grep's -F, -w, and -x options using PCRE2_LITERAL,\nPCRE2_EXTRA_MATCH_WORD, and PCRE2_EXTRA_MATCH_LINE. This fixes two bugs:\n\n    (a) The -F option did not work for fixed strings containing \\E.\n    (b) The -w option did not work for patterns with multiple branches.\n\n44. Added configuration options for the SELinux compatible execmem allocator in\nJIT.\n\n45. Increased the limit for searching for a \"must be present\" code unit in\nsubjects from 1000 to 2000 for 8-bit searches, since they use memchr() and are\nmuch faster.\n\n46. Arrange for anchored patterns to record and use \"first code unit\" data,\nbecause this can give a fast \"no match\" without searching for a \"required code\nunit\". Previously only non-anchored patterns did this.\n\n47. Upgraded the Unicode tables from Unicode 8.0.0 to Unicode 10.0.0.\n\n48. Add the callout_no_where modifier to pcre2test.\n\n49. Update extended grapheme breaking rules to the latest set that are in\nUnicode Standard Annex #29.\n\n50. Added experimental foreign pattern conversion facilities\n(pcre2_pattern_convert() and friends).\n\n51. Change the macro FWRITE, used in pcre2grep, to FWRITE_IGNORE because FWRITE\nis defined in a system header in cygwin. Also modified some of the #ifdefs in\npcre2grep related to Windows and Cygwin support.\n\n52. Change 3(g) for 10.23 was a bit too zealous. If a hyphen that follows a\ncharacter class is the last character in the class, Perl does not give a\nwarning. PCRE2 now also treats this as a literal.\n\n53. Related to 52, though PCRE2 was throwing an error for [[:digit:]-X] it was\nnot doing so for [\\d-X] (and similar escapes), as is documented.\n\n54. Fixed a MIPS issue in the JIT compiler reported by Joshua Kinard.\n\n55. Fixed a \"maybe uninitialized\" warning for class_uchardata in \\p handling in\npcre2_compile() which could never actually trigger (code should have been cut\nout when Unicode support is disabled).\n\n\nVersion 10.23 14-February-2017\n------------------------------\n\n1. Extended pcre2test with the utf8_input modifier so that it is able to\ngenerate all possible 16-bit and 32-bit code unit values in non-UTF modes.\n\n2. In any wide-character mode (8-bit UTF or any 16-bit or 32-bit mode), without\nPCRE2_UCP set, a negative character type such as \\D in a positive class should\ncause all characters greater than 255 to match, whatever else is in the class.\nThere was a bug that caused this not to happen if a Unicode property item was\nadded to such a class, for example [\\D\\P{Nd}] or [\\W\\pL].\n\n3. There has been a major re-factoring of the pcre2_compile.c file. Most syntax\nchecking is now done in the pre-pass that identifies capturing groups. This has\nreduced the amount of duplication and made the code tidier. While doing this,\nsome minor bugs and Perl incompatibilities were fixed, including:\n\n  (a) \\Q\\E in the middle of a quantifier such as A+\\Q\\E+ is now ignored instead\n      of giving an invalid quantifier error.\n\n  (b) {0} can now be used after a group in a lookbehind assertion; previously\n      this caused an \"assertion is not fixed length\" error.\n\n  (c) Perl always treats (?(DEFINE) as a \"define\" group, even if a group with\n      the name \"DEFINE\" exists. PCRE2 now does likewise.\n\n  (d) A recursion condition test such as (?(R2)...) must now refer to an\n      existing subpattern.\n\n  (e) A conditional recursion test such as (?(R)...) misbehaved if there was a\n      group whose name began with \"R\".\n\n  (f) When testing zero-terminated patterns under valgrind, the terminating\n      zero is now marked \"no access\". This catches bugs that would otherwise\n      show up only with non-zero-terminated patterns.\n\n  (g) A hyphen appearing immediately after a POSIX character class (for example\n      /[[:ascii:]-z]/) now generates an error. Perl does accept this as a\n      literal, but gives a warning, so it seems best to fail it in PCRE.\n\n  (h) An empty \\Q\\E sequence may appear after a callout that precedes an\n      assertion condition (it is, of course, ignored).\n\nOne effect of the refactoring is that some error numbers and messages have\nchanged, and the pattern offset given for compiling errors is not always the\nright-most character that has been read. In particular, for a variable-length\nlookbehind assertion it now points to the start of the assertion. Another\nchange is that when a callout appears before a group, the \"length of next\npattern item\" that is passed now just gives the length of the opening\nparenthesis item, not the length of the whole group. A length of zero is now\ngiven only for a callout at the end of the pattern. Automatic callouts are no\nlonger inserted before and after explicit callouts in the pattern.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. Many\nof the bugs were discovered by fuzzing testing. Several of them were related to\nthe change from assuming a zero-terminated pattern (which previously had\nrequired non-zero terminated strings to be copied). These bugs were never in\nfully released code, but are noted here for the record.\n\n  (a) An overall recursion such as (?0) inside a lookbehind assertion was not\n      being diagnosed as an error.\n\n  (b) In utf mode, the length of a *MARK (or other verb) name was being checked\n      in characters instead of code units, which could lead to bad code being\n      compiled, leading to unpredictable behaviour.\n\n  (c) In extended /x mode, characters whose code was greater than 255 caused\n      a lookup outside one of the global tables. A similar bug existed for wide\n      characters in *VERB names.\n\n  (d) The amount of memory needed for a compiled pattern was miscalculated if a\n      lookbehind contained more than one toplevel branch and the first branch\n      was of length zero.\n\n  (e) In UTF-8 or UTF-16 modes with PCRE2_EXTENDED (/x) set and a non-zero-\n      terminated pattern, if a # comment ran on to the end of the pattern, one\n      or more code units past the end were being read.\n\n  (f) An unterminated repeat at the end of a non-zero-terminated pattern (e.g.\n      \"{2,2\") could cause reading beyond the pattern.\n\n  (g) When reading a callout string, if the end delimiter was at the end of the\n      pattern one further code unit was read.\n\n  (h) An unterminated number after \\g' could cause reading beyond the pattern.\n\n  (i) An insufficient memory size was being computed for compiling with\n      PCRE2_AUTO_CALLOUT.\n\n  (j) A conditional group with an assertion condition used more memory than was\n      allowed for it during parsing, so too many of them could therefore\n      overrun a buffer.\n\n  (k) If parsing a pattern exactly filled the buffer, the internal test for\n      overrun did not check when the final META_END item was added.\n\n  (l) If a lookbehind contained a subroutine call, and the called group\n      contained an option setting such as (?s), and the PCRE2_ANCHORED option\n      was set, unpredictable behaviour could occur. The underlying bug was\n      incorrect code and insufficient checking while searching for the end of\n      the called subroutine in the parsed pattern.\n\n  (m) Quantifiers following (*VERB)s were not being diagnosed as errors.\n\n  (n) The use of \\Q...\\E in a (*VERB) name when PCRE2_ALT_VERBNAMES and\n      PCRE2_AUTO_CALLOUT were both specified caused undetermined behaviour.\n\n  (o) If \\Q was preceded by a quantified item, and the following \\E was\n      followed by '?' or '+', and there was at least one literal character\n      between them, an internal error \"unexpected repeat\" occurred (example:\n      /.+\\QX\\E+/).\n\n  (p) A buffer overflow could occur while sorting the names in the group name\n      list (depending on the order in which the names were seen).\n\n  (q) A conditional group that started with a callout was not doing the right\n      check for a following assertion, leading to compiling bad code. Example:\n      /(?(C'XX))?!XX/\n\n  (r) If a character whose code point was greater than 0xffff appeared within\n      a lookbehind that was within another lookbehind, the calculation of the\n      lookbehind length went wrong and could provoke an internal error.\n\n  (t) The sequence \\E- or \\Q\\E- after a POSIX class in a character class caused\n      an internal error. Now the hyphen is treated as a literal.\n\n4. Back references are now permitted in lookbehind assertions when there are\nno duplicated group numbers (that is, (?| has not been used), and, if the\nreference is by name, there is only one group of that name. The referenced\ngroup must, of course be of fixed length.\n\n5. pcre2test has been upgraded so that, when run under valgrind with valgrind\nsupport enabled, reading past the end of the pattern is detected, both when\ncompiling and during callout processing.\n\n6. \\g{+<number>} (e.g. \\g{+2} ) is now supported. It is a \"forward back\nreference\" and can be useful in repetitions (compare \\g{-<number>} ). Perl does\nnot recognize this syntax.\n\n7. Automatic callouts are no longer generated before and after callouts in the\npattern.\n\n8. When pcre2test was outputing information from a callout, the caret indicator\nfor the current position in the subject line was incorrect if it was after an\nescape sequence for a character whose code point was greater than \\x{ff}.\n\n9. Change 19 for 10.22 had a typo (PCRE_STATIC_RUNTIME should be\nPCRE2_STATIC_RUNTIME). Fix from David Gaussmann.\n\n10. Added --max-buffer-size to pcre2grep, to allow for automatic buffer\nexpansion when long lines are encountered. Original patch by Dmitry\nCherniachenko.\n\n11. If pcre2grep was compiled with JIT support, but the library was compiled\nwithout it (something that neither ./configure nor CMake allow, but it can be\ndone by editing config.h), pcre2grep was giving a JIT error. Now it detects\nthis situation and does not try to use JIT.\n\n12. Added some \"const\" qualifiers to variables in pcre2grep.\n\n13. Added Dmitry Cherniachenko's patch for colouring output in Windows\n(untested by me). Also, look for GREP_COLOUR or GREP_COLOR if the environment\nvariables PCRE2GREP_COLOUR and PCRE2GREP_COLOR are not found.\n\n14. Add the -t (grand total) option to pcre2grep.\n\n15. A number of bugs have been mended relating to match start-up optimizations\nwhen the first thing in a pattern is a positive lookahead. These all applied\nonly when PCRE2_NO_START_OPTIMIZE was *not* set:\n\n    (a) A pattern such as (?=.*X)X$ was incorrectly optimized as if it needed\n        both an initial 'X' and a following 'X'.\n    (b) Some patterns starting with an assertion that started with .* were\n        incorrectly optimized as having to match at the start of the subject or\n        after a newline. There are cases where this is not true, for example,\n        (?=.*[A-Z])(?=.{8,16})(?!.*[\\s]) matches after the start in lines that\n        start with spaces. Starting .* in an assertion is no longer taken as an\n        indication of matching at the start (or after a newline).\n\n16. The \"offset\" modifier in pcre2test was not being ignored (as documented)\nwhen the POSIX API was in use.\n\n17. Added --enable-fuzz-support to \"configure\", causing an non-installed\nlibrary containing a test function that can be called by fuzzers to be\ncompiled. A non-installed  binary to run the test function locally, called\npcre2fuzzcheck is also compiled.\n\n18. A pattern with PCRE2_DOTALL (/s) set but not PCRE2_NO_DOTSTAR_ANCHOR, and\nwhich started with .* inside a positive lookahead was incorrectly being\ncompiled as implicitly anchored.\n\n19. Removed all instances of \"register\" declarations, as they are considered\nobsolete these days and in any case had become very haphazard.\n\n20. Add strerror() to pcre2test for failed file opening.\n\n21. Make pcre2test -C list valgrind support when it is enabled.\n\n22. Add the use_length modifier to pcre2test.\n\n23. Fix an off-by-one bug in pcre2test for the list of names for 'get' and\n'copy' modifiers.\n\n24. Add PCRE2_CALL_CONVENTION into the prototype declarations in pcre2.h as it\nis apparently needed there as well as in the function definitions. (Why did\nnobody ask for this in PCRE1?)\n\n25. Change the _PCRE2_H and _PCRE2_UCP_H guard macros in the header files to\nPCRE2_H_IDEMPOTENT_GUARD and PCRE2_UCP_H_IDEMPOTENT_GUARD to be more standard\ncompliant and unique.\n\n26. pcre2-config --libs-posix was listing -lpcre2posix instead of\n-lpcre2-posix. Also, the CMake build process was building the library with the\nwrong name.\n\n27. In pcre2test, give some offset information for errors in hex patterns.\nThis uses the C99 formatting sequence %td, except for MSVC which doesn't\nsupport it - %lu is used instead.\n\n28. Implemented pcre2_code_copy_with_tables(), and added pushtablescopy to\npcre2test for testing it.\n\n29. Fix small memory leak in pcre2test.\n\n30. Fix out-of-bounds read for partial matching of /./ against an empty string\nwhen the newline type is CRLF.\n\n31. Fix a bug in pcre2test that caused a crash when a locale was set either in\nthe current pattern or a previous one and a wide character was matched.\n\n32. The appearance of \\p, \\P, or \\X in a substitution string when\nPCRE2_SUBSTITUTE_EXTENDED was set caused a segmentation fault (NULL\ndereference).\n\n33. If the starting offset was specified as greater than the subject length in\na call to pcre2_substitute() an out-of-bounds memory reference could occur.\n\n34. When PCRE2 was compiled to use the heap instead of the stack for recursive\ncalls to match(), a repeated minimizing caseless back reference, or a\nmaximizing one where the two cases had different numbers of code units,\nfollowed by a caseful back reference, could lose the caselessness of the first\nrepeated back reference (example: /(Z)(a)\\2{1,2}?(?-i)\\1X/i should match ZaAAZX\nbut didn't).\n\n35. When a pattern is too complicated, PCRE2 gives up trying to find a minimum\nmatching length and just records zero. Typically this happens when there are\ntoo many nested or recursive back references. If the limit was reached in\ncertain recursive cases it failed to be triggered and an internal error could\nbe the result.\n\n36. The pcre2_dfa_match() function now takes note of the recursion limit for\nthe internal recursive calls that are used for lookrounds and recursions within\nthe pattern.\n\n37. More refactoring has got rid of the internal could_be_empty_branch()\nfunction (around 400 lines of code, including comments) by keeping track of\ncould-be-emptiness as the pattern is compiled instead of scanning compiled\ngroups. (This would have been much harder before the refactoring of #3 above.)\nThis lifts a restriction on the number of branches in a group (more than about\n1100 would give \"pattern is too complicated\").\n\n38. Add the \"-ac\" command line option to pcre2test as a synonym for \"-pattern\nauto_callout\".\n\n39. In a library with Unicode support, incorrect data was compiled for a\npattern with PCRE2_UCP set without PCRE2_UTF if a class required all wide\ncharacters to match (for example, /[\\s[:^ascii:]]/).\n\n40. The callout_error modifier has been added to pcre2test to make it possible\nto return PCRE2_ERROR_CALLOUT from a callout.\n\n41. A minor change to pcre2grep: colour reset is now \"<esc>[0m\" instead of\n\"<esc>[00m\".\n\n42. The limit in the auto-possessification code that was intended to catch\noverly-complicated patterns and not spend too much time auto-possessifying was\nbeing reset too often, resulting in very long compile times for some patterns.\nNow such patterns are no longer completely auto-possessified.\n\n43. Applied Jason Hood's revised patch for RunTest.bat.\n\n44. Added a new Windows script RunGrepTest.bat, courtesy of Jason Hood.\n\n45. Minor cosmetic fix to pcre2test: move a variable that is not used under\nWindows into the \"not Windows\" code.\n\n46. Applied Jason Hood's patches to upgrade pcre2grep under Windows and tidy\nsome of the code:\n\n  * normalised the Windows condition by ensuring WIN32 is defined;\n  * enables the callout feature under Windows;\n  * adds globbing (Microsoft's implementation expands quoted args),\n    using a tweaked opendirectory;\n  * implements the is_*_tty functions for Windows;\n  * --color=always will write the ANSI sequences to file;\n  * add sequences 4 (underline works on Win10) and 5 (blink as bright\n    background, relatively standard on DOS/Win);\n  * remove the (char *) casts for the now-const strings;\n  * remove GREP_COLOUR (grep's command line allowed the 'u', but not\n    the environment), parsing GREP_COLORS instead;\n  * uses the current colour if not set, rather than black;\n  * add print_match for the undefined case;\n  * fixes a typo.\n\nIn addition, colour settings containing anything other than digits and\nsemicolon are ignored, and the colour controls are no longer output for empty\nstrings.\n\n47. Detecting patterns that are too large inside the length-measuring loop\nsaves processing ridiculously long patterns to their end.\n\n48. Ignore PCRE2_CASELESS when processing \\h, \\H, \\v, and \\V in classes as it\njust wastes time. In the UTF case it can also produce redundant entries in\nXCLASS lists caused by characters with multiple other cases and pairs of\ncharacters in the same \"not-x\" sublists.\n\n49. A pattern such as /(?=(a\\K))/ can report the end of the match being before\nits start; pcre2test was not handling this correctly when using the POSIX\ninterface (it was OK with the native interface).\n\n50. In pcre2grep, ignore all JIT compile errors. This means that pcre2grep will\ncontinue to work, falling back to interpretation if anything goes wrong with\nJIT.\n\n51. Applied patches from Christian Persch to configure.ac to make use of the\nAC_USE_SYSTEM_EXTENSIONS macro and to test for functions used by the JIT\nmodules.\n\n52. Minor fixes to pcre2grep from Jason Hood:\n    * fixed some spacing;\n    * Windows doesn't usually use single quotes, so I've added a define\n      to use appropriate quotes [in an example];\n    * LC_ALL was displayed as \"LCC_ALL\";\n    * numbers 11, 12 & 13 should end in \"th\";\n    * use double quotes in usage message.\n\n53. When autopossessifying, skip empty branches without recursion, to reduce\nstack usage for the benefit of clang with -fsanitize-address, which uses huge\nstack frames. Example pattern: /X?(R||){3335}/. Fixes oss-fuzz issue 553.\n\n54. A pattern with very many explicit back references to a group that is a long\nway from the start of the pattern could take a long time to compile because\nsearching for the referenced group in order to find the minimum length was\nbeing done repeatedly. Now up to 128 group minimum lengths are cached and the\nattempt to find a minimum length is abandoned if there is a back reference to a\ngroup whose number is greater than 128. (In that case, the pattern is so\ncomplicated that this optimization probably isn't worth it.) This fixes\noss-fuzz issue 557.\n\n55. Issue 32 for 10.22 below was not correctly fixed. If pcre2grep in multiline\nmode with --only-matching matched several lines, it restarted scanning at the\nnext line instead of moving on to the end of the matched string, which can be\nseveral lines after the start.\n\n56. Applied Jason Hood's new patch for RunGrepTest.bat that updates it in line\nwith updates to the non-Windows version.\n\n\n\nVersion 10.22 29-July-2016\n--------------------------\n\n1. Applied Jason Hood's patches to RunTest.bat and testdata/wintestoutput3\nto fix problems with running the tests under Windows.\n\n2. Implemented a facility for quoting literal characters within hexadecimal\npatterns in pcre2test, to make it easier to create patterns with just a few\nnon-printing characters.\n\n3. Binary zeros are not supported in pcre2test input files. It now detects them\nand gives an error.\n\n4. Updated the valgrind parameters in RunTest: (a) changed smc-check=all to\nsmc-check=all-non-file; (b) changed obj:* in the suppression file to obj:??? so\nthat it matches only unknown objects.\n\n5. Updated the maintenance script maint/ManyConfigTests to make it easier to\nselect individual groups of tests.\n\n6. When the POSIX wrapper function regcomp() is called, the REG_NOSUB option\nused to set PCRE2_NO_AUTO_CAPTURE when calling pcre2_compile(). However, this\ndisables the use of back references (and subroutine calls), which are supported\nby other implementations of regcomp() with RE_NOSUB. Therefore, REG_NOSUB no\nlonger causes PCRE2_NO_AUTO_CAPTURE to be set, though it still ignores nmatch\nand pmatch when regexec() is called.\n\n7. Because of 6 above, pcre2test has been modified with a new modifier called\nposix_nosub, to call regcomp() with REG_NOSUB. Previously the no_auto_capture\nmodifier had this effect. That option is now ignored when the POSIX API is in\nuse.\n\n8. Minor tidies to the pcre2demo.c sample program, including more comments\nabout its 8-bit-ness.\n\n9. Detect unmatched closing parentheses and give the error in the pre-scan\ninstead of later. Previously the pre-scan carried on and could give a\nmisleading incorrect error message. For example, /(?J)(?'a'))(?'a')/ gave a\nmessage about invalid duplicate group names.\n\n10. It has happened that pcre2test was accidentally linked with another POSIX\nregex library instead of libpcre2-posix. In this situation, a call to regcomp()\n(in the other library) may succeed, returning zero, but of course putting its\nown data into the regex_t block. In one example the re_pcre2_code field was\nleft as NULL, which made pcre2test think it had not got a compiled POSIX regex,\nso it treated the next line as another pattern line, resulting in a confusing\nerror message. A check has been added to pcre2test to see if the data returned\nfrom a successful call of regcomp() are valid for PCRE2's regcomp(). If they\nare not, an error message is output and the pcre2test run is abandoned. The\nmessage points out the possibility of a mis-linking. Hopefully this will avoid\nsome head-scratching the next time this happens.\n\n11. A pattern such as /(?<=((?C)0))/, which has a callout inside a lookbehind\nassertion, caused pcre2test to output a very large number of spaces when the\ncallout was taken, making the program appearing to loop.\n\n12. A pattern that included (*ACCEPT) in the middle of a sufficiently deeply\nnested set of parentheses of sufficient size caused an overflow of the\ncompiling workspace (which was diagnosed, but of course is not desirable).\n\n13. Detect missing closing parentheses during the pre-pass for group\nidentification.\n\n14. Changed some integer variable types and put in a number of casts, following\na report of compiler warnings from Visual Studio 2013 and a few tests with\ngcc's -Wconversion (which still throws up a lot).\n\n15. Implemented pcre2_code_copy(), and added pushcopy and #popcopy to pcre2test\nfor testing it.\n\n16. Change 66 for 10.21 introduced the use of snprintf() in PCRE2's version of\nregerror(). When the error buffer is too small, my version of snprintf() puts a\nbinary zero in the final byte. Bug #1801 seems to show that other versions do\nnot do this, leading to bad output from pcre2test when it was checking for\nbuffer overflow. It no longer assumes a binary zero at the end of a too-small\nregerror() buffer.\n\n17. Fixed typo (\"&&\" for \"&\") in pcre2_study(). Fortunately, this could not\nactually affect anything, by sheer luck.\n\n18. Two minor fixes for MSVC compilation: (a) removal of apparently incorrect\n\"const\" qualifiers in pcre2test and (b) defining snprintf as _snprintf for\nolder MSVC compilers. This has been done both in src/pcre2_internal.h for most\nof the library, and also in src/pcre2posix.c, which no longer includes\npcre2_internal.h (see 24 below).\n\n19. Applied Chris Wilson's patch (Bugzilla #1681) to CMakeLists.txt for MSVC\nstatic compilation. Subsequently applied Chris Wilson's second patch, putting\nthe first patch under a new option instead of being unconditional when\nPCRE_STATIC is set.\n\n20. Updated pcre2grep to set stdout as binary when run under Windows, so as not\nto convert \\r\\n at the ends of reflected lines into \\r\\r\\n. This required\nensuring that other output that is written to stdout (e.g. file names) uses the\nappropriate line terminator: \\r\\n for Windows, \\n otherwise.\n\n21. When a line is too long for pcre2grep's internal buffer, show the maximum\nlength in the error message.\n\n22. Added support for string callouts to pcre2grep (Zoltan's patch with PH\nadditions).\n\n23. RunTest.bat was missing a \"set type\" line for test 22.\n\n24. The pcre2posix.c file was including pcre2_internal.h, and using some\n\"private\" knowledge of the data structures. This is unnecessary; the code has\nbeen re-factored and no longer includes pcre2_internal.h.\n\n25. A racing condition is fixed in JIT reported by Mozilla.\n\n26. Minor code refactor to avoid \"array subscript is below array bounds\"\ncompiler warning.\n\n27. Minor code refactor to avoid \"left shift of negative number\" warning.\n\n28. Add a bit more sanity checking to pcre2_serialize_decode() and document\nthat it expects trusted data.\n\n29. Fix typo in pcre2_jit_test.c\n\n30. Due to an oversight, pcre2grep was not making use of JIT when available.\nThis is now fixed.\n\n31. The RunGrepTest script is updated to use the valgrind suppressions file\nwhen testing with JIT under valgrind (compare 10.21/51 below). The suppressions\nfile is updated so that is now the same as for PCRE1: it suppresses the\nMemcheck warnings Addr16 and Cond in unknown objects (that is, JIT-compiled\ncode). Also changed smc-check=all to smc-check=all-non-file as was done for\nRunTest (see 4 above).\n\n32. Implemented the PCRE2_NO_JIT option for pcre2_match().\n\n33. Fix typo that gave a compiler error when JIT not supported.\n\n34. Fix comment describing the returns from find_fixedlength().\n\n35. Fix potential negative index in pcre2test.\n\n36. Calls to pcre2_get_error_message() with error numbers that are never\nreturned by PCRE2 functions were returning empty strings. Now the error code\nPCRE2_ERROR_BADDATA is returned. A facility has been added to pcre2test to\nshow the texts for given error numbers (i.e. to call pcre2_get_error_message()\nand display what it returns) and a few representative error codes are now\nchecked in RunTest.\n\n37. Added \"&& !defined(__INTEL_COMPILER)\" to the test for __GNUC__ in\npcre2_match.c, in anticipation that this is needed for the same reason it was\nrecently added to pcrecpp.cc in PCRE1.\n\n38. Using -o with -M in pcre2grep could cause unnecessary repeated output when\nthe match extended over a line boundary, as it tried to find more matches \"on\nthe same line\" - but it was already over the end.\n\n39. Allow \\C in lookbehinds and DFA matching in UTF-32 mode (by converting it\nto the same code as '.' when PCRE2_DOTALL is set).\n\n40. Fix two clang compiler warnings in pcre2test when only one code unit width\nis supported.\n\n41. Upgrade RunTest to automatically re-run test 2 with a large (64MiB) stack\nif it fails when running the interpreter with a 16MiB stack (and if changing\nthe stack size via pcre2test is possible). This avoids having to manually set a\nlarge stack size when testing with clang.\n\n42. Fix register overwite in JIT when SSE2 acceleration is enabled.\n\n43. Detect integer overflow in pcre2test pattern and data repetition counts.\n\n44. In pcre2test, ignore \"allcaptures\" after DFA matching.\n\n45. Fix unaligned accesses on x86. Patch by Marc Mutz.\n\n46. Fix some more clang compiler warnings.\n\n\nVersion 10.21 12-January-2016\n-----------------------------\n\n1. Improve matching speed of patterns starting with + or * in JIT.\n\n2. Use memchr() to find the first character in an unanchored match in 8-bit\nmode in the interpreter. This gives a significant speed improvement.\n\n3. Removed a redundant copy of the opcode_possessify table in the\npcre2_auto_possessify.c source.\n\n4. Fix typos in dftables.c for z/OS.\n\n5. Change 36 for 10.20 broke the handling of [[:>:]] and [[:<:]] in that\nprocessing them could involve a buffer overflow if the following character was\nan opening parenthesis.\n\n6. Change 36 for 10.20 also introduced a bug in processing this pattern:\n/((?x)(*:0))#(?'/. Specifically: if a setting of (?x) was followed by a (*MARK)\nsetting (which (*:0) is), then (?x) did not get unset at the end of its group\nduring the scan for named groups, and hence the external # was incorrectly\ntreated as a comment and the invalid (?' at the end of the pattern was not\ndiagnosed. This caused a buffer overflow during the real compile. This bug was\ndiscovered by Karl Skomski with the LLVM fuzzer.\n\n7. Moved the pcre2_find_bracket() function from src/pcre2_compile.c into its\nown source module to avoid a circular dependency between src/pcre2_compile.c\nand src/pcre2_study.c\n\n8. A callout with a string argument containing an opening square bracket, for\nexample /(?C$[$)(?<]/, was incorrectly processed and could provoke a buffer\noverflow. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n9. The handling of callouts during the pre-pass for named group identification\nhas been tightened up.\n\n10. The quantifier {1} can be ignored, whether greedy, non-greedy, or\npossessive. This is a very minor optimization.\n\n11. A possessively repeated conditional group that could match an empty string,\nfor example, /(?(R))*+/, was incorrectly compiled.\n\n12. The Unicode tables have been updated to Unicode 8.0.0 (thanks to Christian\nPersch).\n\n13. An empty comment (?#) in a pattern was incorrectly processed and could\nprovoke a buffer overflow. This bug was discovered by Karl Skomski with the\nLLVM fuzzer.\n\n14. Fix infinite recursion in the JIT compiler when certain patterns such as\n/(?:|a|){100}x/ are analysed.\n\n15. Some patterns with character classes involving [: and \\\\ were incorrectly\ncompiled and could cause reading from uninitialized memory or an incorrect\nerror diagnosis. Examples are: /[[:\\\\](?<[::]/ and /[[:\\\\](?'abc')[a:]. The\nfirst of these bugs was discovered by Karl Skomski with the LLVM fuzzer.\n\n16. Pathological patterns containing many nested occurrences of [: caused\npcre2_compile() to run for a very long time. This bug was found by the LLVM\nfuzzer.\n\n17. A missing closing parenthesis for a callout with a string argument was not\nbeing diagnosed, possibly leading to a buffer overflow. This bug was found by\nthe LLVM fuzzer.\n\n18. A conditional group with only one branch has an implicit empty alternative\nbranch and must therefore be treated as potentially matching an empty string.\n\n19. If (?R was followed by - or + incorrect behaviour happened instead of a\ndiagnostic. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n20. Another bug that was introduced by change 36 for 10.20: conditional groups\nwhose condition was an assertion preceded by an explicit callout with a string\nargument might be incorrectly processed, especially if the string contained \\Q.\nThis bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n21. Compiling PCRE2 with the sanitize options of clang showed up a number of\nvery pedantic coding infelicities and a buffer overflow while checking a UTF-8\nstring if the final multi-byte UTF-8 character was truncated.\n\n22. For Perl compatibility in EBCDIC environments, ranges such as a-z in a\nclass, where both values are literal letters in the same case, omit the\nnon-letter EBCDIC code points within the range.\n\n23. Finding the minimum matching length of complex patterns with back\nreferences and/or recursions can take a long time. There is now a cut-off that\ngives up trying to find a minimum length when things get too complex.\n\n24. An optimization has been added that speeds up finding the minimum matching\nlength for patterns containing repeated capturing groups or recursions.\n\n25. If a pattern contained a back reference to a group whose number was\nduplicated as a result of appearing in a (?|...) group, the computation of the\nminimum matching length gave a wrong result, which could cause incorrect \"no\nmatch\" errors. For such patterns, a minimum matching length cannot at present\nbe computed.\n\n26. Added a check for integer overflow in conditions (?(<digits>) and\n(?(R<digits>). This omission was discovered by Karl Skomski with the LLVM\nfuzzer.\n\n27. Fixed an issue when \\p{Any} inside an xclass did not read the current\ncharacter.\n\n28. If pcre2grep was given the -q option with -c or -l, or when handling a\nbinary file, it incorrectly wrote output to stdout.\n\n29. The JIT compiler did not restore the control verb head in case of *THEN\ncontrol verbs. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n30. The way recursive references such as (?3) are compiled has been re-written\nbecause the old way was the cause of many issues. Now, conversion of the group\nnumber into a pattern offset does not happen until the pattern has been\ncompletely compiled. This does mean that detection of all infinitely looping\nrecursions is postponed till match time. In the past, some easy ones were\ndetected at compile time. This re-writing was done in response to yet another\nbug found by the LLVM fuzzer.\n\n31. A test for a back reference to a non-existent group was missing for items\nsuch as \\987. This caused incorrect code to be compiled. This issue was found\nby Karl Skomski with a custom LLVM fuzzer.\n\n32. Error messages for syntax errors following \\g and \\k were giving inaccurate\noffsets in the pattern.\n\n33. Improve the performance of starting single character repetitions in JIT.\n\n34. (*LIMIT_MATCH=) now gives an error instead of setting the value to 0.\n\n35. Error messages for syntax errors in *LIMIT_MATCH and *LIMIT_RECURSION now\ngive the right offset instead of zero.\n\n36. The JIT compiler should not check repeats after a {0,1} repeat byte code.\nThis issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n37. The JIT compiler should restore the control chain for empty possessive\nrepeats. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n38. A bug which was introduced by the single character repetition optimization\nwas fixed.\n\n39. Match limit check added to recursion. This issue was found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n40. Arrange for the UTF check in pcre2_match() and pcre2_dfa_match() to look\nonly at the part of the subject that is relevant when the starting offset is\nnon-zero.\n\n41. Improve first character match in JIT with SSE2 on x86.\n\n42. Fix two assertion fails in JIT. These issues were found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n43. Correct the setting of CMAKE_C_FLAGS in CMakeLists.txt (patch from Roy Ivy\nIII).\n\n44. Fix bug in RunTest.bat for new test 14, and adjust the script for the added\ntest (there are now 20 in total).\n\n45. Fixed a corner case of range optimization in JIT.\n\n46. Add the ${*MARK} facility to pcre2_substitute().\n\n47. Modifier lists in pcre2test were splitting at spaces without the required\ncommas.\n\n48. Implemented PCRE2_ALT_VERBNAMES.\n\n49. Fixed two issues in JIT. These were found by Karl Skomski with a custom\nLLVM fuzzer.\n\n50. The pcre2test program has been extended by adding the #newline_default\ncommand. This has made it possible to run the standard tests when PCRE2 is\ncompiled with either CR or CRLF as the default newline convention. As part of\nthis work, the new command was added to several test files and the testing\nscripts were modified. The pcre2grep tests can now also be run when there is no\nLF in the default newline convention.\n\n51. The RunTest script has been modified so that, when JIT is used and valgrind\nis specified, a valgrind suppressions file is set up to ignore \"Invalid read of\nsize 16\" errors because these are false positives when the hardware supports\nthe SSE2 instruction set.\n\n52. It is now possible to have comment lines amid the subject strings in\npcre2test (and perltest.sh) input.\n\n53. Implemented PCRE2_USE_OFFSET_LIMIT and pcre2_set_offset_limit().\n\n54. Add the null_context modifier to pcre2test so that calling pcre2_compile()\nand the matching functions with NULL contexts can be tested.\n\n55. Implemented PCRE2_SUBSTITUTE_EXTENDED.\n\n56. In a character class such as [\\W\\p{Any}] where both a negative-type escape\n(\"not a word character\") and a property escape were present, the property\nescape was being ignored.\n\n57. Fixed integer overflow for patterns whose minimum matching length is very,\nvery large.\n\n58. Implemented --never-backslash-C.\n\n59. Change 55 above introduced a bug by which certain patterns provoked the\nerroneous error \"\\ at end of pattern\".\n\n60. The special sequences [[:<:]] and [[:>:]] gave rise to incorrect compiling\nerrors or other strange effects if compiled in UCP mode. Found with libFuzzer\nand AddressSanitizer.\n\n61. Whitespace at the end of a pcre2test pattern line caused a spurious error\nmessage if there were only single-character modifiers. It should be ignored.\n\n62. The use of PCRE2_NO_AUTO_CAPTURE could cause incorrect compilation results\nor segmentation errors for some patterns. Found with libFuzzer and\nAddressSanitizer.\n\n63. Very long names in (*MARK) or (*THEN) etc. items could provoke a buffer\noverflow.\n\n64. Improve error message for overly-complicated patterns.\n\n65. Implemented an optional replication feature for patterns in pcre2test, to\nmake it easier to test long repetitive patterns. The tests for 63 above are\nconverted to use the new feature.\n\n66. In the POSIX wrapper, if regerror() was given too small a buffer, it could\nmisbehave.\n\n67. In pcre2_substitute() in UTF mode, the UTF validity check on the\nreplacement string was happening before the length setting when the replacement\nstring was zero-terminated.\n\n68. In pcre2_substitute() in UTF mode, PCRE2_NO_UTF_CHECK can be set for the\nsecond and subsequent calls to pcre2_match().\n\n69. There was no check for integer overflow for a replacement group number in\npcre2_substitute(). An added check for a number greater than the largest group\nnumber in the pattern means this is not now needed.\n\n70. The PCRE2-specific VERSION condition didn't work correctly if only one\ndigit was given after the decimal point, or if more than two digits were given.\nIt now works with one or two digits, and gives a compile time error if more are\ngiven.\n\n71. In pcre2_substitute() there was the possibility of reading one code unit\nbeyond the end of the replacement string.\n\n72. The code for checking a subject's UTF-32 validity for a pattern with a\nlookbehind involved an out-of-bounds pointer, which could potentially cause\ntrouble in some environments.\n\n73. The maximum lookbehind length was incorrectly calculated for patterns such\nas /(?<=(a)(?-1))x/ which have a recursion within a backreference.\n\n74. Give an error if a lookbehind assertion is longer than 65535 code units.\n\n75. Give an error in pcre2_substitute() if a match ends before it starts (as a\nresult of the use of \\K).\n\n76. Check the length of subpattern names and the names in (*MARK:xx) etc.\ndynamically to avoid the possibility of integer overflow.\n\n77. Implement pcre2_set_max_pattern_length() so that programs can restrict the\nsize of patterns that they are prepared to handle.\n\n78. (*NO_AUTO_POSSESS) was not working.\n\n79. Adding group information caching improves the speed of compiling when\nchecking whether a group has a fixed length and/or could match an empty string,\nespecially when recursion or subroutine calls are involved. However, this\ncannot be used when (?| is present in the pattern because the same number may\nbe used for groups of different sizes. To catch runaway patterns in this\nsituation, counts have been introduced to the functions that scan for empty\nbranches or compute fixed lengths.\n\n80. Allow for the possibility of the size of the nest_save structure not being\na factor of the size of the compiling workspace (it currently is).\n\n81. Check for integer overflow in minimum length calculation and cap it at\n65535.\n\n82. Small optimizations in code for finding the minimum matching length.\n\n83. Lock out configuring for EBCDIC with non-8-bit libraries.\n\n84. Test for error code <= 0 in regerror().\n\n85. Check for too many replacements (more than INT_MAX) in pcre2_substitute().\n\n86. Avoid the possibility of computing with an out-of-bounds pointer (though\nnot dereferencing it) while handling lookbehind assertions.\n\n87. Failure to get memory for the match data in regcomp() is now given as a\nregcomp() error instead of waiting for regexec() to pick it up.\n\n88. In pcre2_substitute(), ensure that CRLF is not split when it is a valid\nnewline sequence.\n\n89. Paranoid check in regcomp() for bad error code from pcre2_compile().\n\n90. Run test 8 (internal offsets and code sizes) for link sizes 3 and 4 as well\nas for link size 2.\n\n91. Document that JIT has a limit on pattern size, and give more information\nabout JIT compile failures in pcre2test.\n\n92. Implement PCRE2_INFO_HASBACKSLASHC.\n\n93. Re-arrange valgrind support code in pcre2test to avoid spurious reports\nwith JIT (possibly caused by SSE2?).\n\n94. Support offset_limit in JIT.\n\n95. A sequence such as [[:punct:]b] that is, a POSIX character class followed\nby a single ASCII character in a class item, was incorrectly compiled in UCP\nmode. The POSIX class got lost, but only if the single character followed it.\n\n96. [:punct:] in UCP mode was matching some characters in the range 128-255\nthat should not have been matched.\n\n97. If [:^ascii:] or [:^xdigit:] are present in a non-negated class, all\ncharacters with code points greater than 255 are in the class. When a Unicode\nproperty was also in the class (if PCRE2_UCP is set, escapes such as \\w are\nturned into Unicode properties), wide characters were not correctly handled,\nand could fail to match.\n\n98. In pcre2test, make the \"startoffset\" modifier a synonym of \"offset\",\nbecause it sets the \"startoffset\" parameter for pcre2_match().\n\n99. If PCRE2_AUTO_CALLOUT was set on a pattern that had a (?# comment between\nan item and its qualifier (for example, A(?#comment)?B) pcre2_compile()\nmisbehaved. This bug was found by the LLVM fuzzer.\n\n100. The error for an invalid UTF pattern string always gave the code unit\noffset as zero instead of where the invalidity was found.\n\n101. Further to 97 above, negated classes such as [^[:^ascii:]\\d] were also not\nworking correctly in UCP mode.\n\n102. Similar to 99 above, if an isolated \\E was present between an item and its\nqualifier when PCRE2_AUTO_CALLOUT was set, pcre2_compile() misbehaved. This bug\nwas found by the LLVM fuzzer.\n\n103. The POSIX wrapper function regexec() crashed if the option REG_STARTEND\nwas set when the pmatch argument was NULL. It now returns REG_INVARG.\n\n104. Allow for up to 32-bit numbers in the ordin() function in pcre2grep.\n\n105. An empty \\Q\\E sequence between an item and its qualifier caused\npcre2_compile() to misbehave when auto callouts were enabled. This bug\nwas found by the LLVM fuzzer.\n\n106. If both PCRE2_ALT_VERBNAMES and PCRE2_EXTENDED were set, and a (*MARK) or\nother verb \"name\" ended with whitespace immediately before the closing\nparenthesis, pcre2_compile() misbehaved. Example: /(*:abc )/, but only when\nboth those options were set.\n\n107. In a number of places pcre2_compile() was not handling NULL characters\ncorrectly, and pcre2test with the \"bincode\" modifier was not always correctly\ndisplaying fields containing NULLS:\n\n   (a) Within /x extended #-comments\n   (b) Within the \"name\" part of (*MARK) and other *verbs\n   (c) Within the text argument of a callout\n\n108. If a pattern that was compiled with PCRE2_EXTENDED started with white\nspace or a #-type comment that was followed by (?-x), which turns off\nPCRE2_EXTENDED, and there was no subsequent (?x) to turn it on again,\npcre2_compile() assumed that (?-x) applied to the whole pattern and\nconsequently mis-compiled it. This bug was found by the LLVM fuzzer. The fix\nfor this bug means that a setting of any of the (?imsxJU) options at the start\nof a pattern is no longer transferred to the options that are returned by\nPCRE2_INFO_ALLOPTIONS. In fact, this was an anachronism that should have\nchanged when the effects of those options were all moved to compile time.\n\n109. An escaped closing parenthesis in the \"name\" part of a (*verb) when\nPCRE2_ALT_VERBNAMES was set caused pcre2_compile() to malfunction. This bug\nwas found by the LLVM fuzzer.\n\n110. Implemented PCRE2_SUBSTITUTE_UNSET_EMPTY, and updated pcre2test to make it\npossible to test it.\n\n111. \"Harden\" pcre2test against ridiculously large values in modifiers and\ncommand line arguments.\n\n112. Implemented PCRE2_SUBSTITUTE_UNKNOWN_UNSET and PCRE2_SUBSTITUTE_OVERFLOW_\nLENGTH.\n\n113. Fix printing of *MARK names that contain binary zeroes in pcre2test.\n\n\nVersion 10.20 30-June-2015\n--------------------------\n\n1. Callouts with string arguments have been added.\n\n2. Assertion code generator in JIT has been optimized.\n\n3. The invalid pattern (?(?C) has a missing assertion condition at the end. The\npcre2_compile() function read past the end of the input before diagnosing an\nerror. This bug was discovered by the LLVM fuzzer.\n\n4. Implemented pcre2_callout_enumerate().\n\n5. Fix JIT compilation of conditional blocks whose assertion is converted to\n(*FAIL). E.g: /(?(?!))/.\n\n6. The pattern /(?(?!)^)/ caused references to random memory. This bug was\ndiscovered by the LLVM fuzzer.\n\n7. The assertion (?!) is optimized to (*FAIL). This was not handled correctly\nwhen this assertion was used as a condition, for example (?(?!)a|b). In\npcre2_match() it worked by luck; in pcre2_dfa_match() it gave an incorrect\nerror about an unsupported item.\n\n8. For some types of pattern, for example /Z*(|d*){216}/, the auto-\npossessification code could take exponential time to complete. A recursion\ndepth limit of 1000 has been imposed to limit the resources used by this\noptimization. This infelicity was discovered by the LLVM fuzzer.\n\n9. A pattern such as /(*UTF)[\\S\\V\\H]/, which contains a negated special class\nsuch as \\S in non-UCP mode, explicit wide characters (> 255) can be ignored\nbecause \\S ensures they are all in the class. The code for doing this was\ninteracting badly with the code for computing the amount of space needed to\ncompile the pattern, leading to a buffer overflow. This bug was discovered by\nthe LLVM fuzzer.\n\n10. A pattern such as /((?2)+)((?1))/ which has mutual recursion nested inside\nother kinds of group caused stack overflow at compile time. This bug was\ndiscovered by the LLVM fuzzer.\n\n11. A pattern such as /(?1)(?#?'){8}(a)/ which had a parenthesized comment\nbetween a subroutine call and its quantifier was incorrectly compiled, leading\nto buffer overflow or other errors. This bug was discovered by the LLVM fuzzer.\n\n12. The illegal pattern /(?(?<E>.*!.*)?)/ was not being diagnosed as missing an\nassertion after (?(. The code was failing to check the character after (?(?<\nfor the ! or = that would indicate a lookbehind assertion. This bug was\ndiscovered by the LLVM fuzzer.\n\n13. A pattern such as /X((?2)()*+){2}+/ which has a possessive quantifier with\na fixed maximum following a group that contains a subroutine reference was\nincorrectly compiled and could trigger buffer overflow. This bug was discovered\nby the LLVM fuzzer.\n\n14. Negative relative recursive references such as (?-7) to non-existent\nsubpatterns were not being diagnosed and could lead to unpredictable behaviour.\nThis bug was discovered by the LLVM fuzzer.\n\n15. The bug fixed in 14 was due to an integer variable that was unsigned when\nit should have been signed. Some other \"int\" variables, having been checked,\nhave either been changed to uint32_t or commented as \"must be signed\".\n\n16. A mutual recursion within a lookbehind assertion such as (?<=((?2))((?1)))\ncaused a stack overflow instead of the diagnosis of a non-fixed length\nlookbehind assertion. This bug was discovered by the LLVM fuzzer.\n\n17. The use of \\K in a positive lookbehind assertion in a non-anchored pattern\n(e.g. /(?<=\\Ka)/) could make pcre2grep loop.\n\n18. There was a similar problem to 17 in pcre2test for global matches, though\nthe code there did catch the loop.\n\n19. If a greedy quantified \\X was preceded by \\C in UTF mode (e.g. \\C\\X*),\nand a subsequent item in the pattern caused a non-match, backtracking over the\nrepeated \\X did not stop, but carried on past the start of the subject, causing\nreference to random memory and/or a segfault. There were also some other cases\nwhere backtracking after \\C could crash. This set of bugs was discovered by the\nLLVM fuzzer.\n\n20. The function for finding the minimum length of a matching string could take\na very long time if mutual recursion was present many times in a pattern, for\nexample, /((?2){73}(?2))((?1))/. A better mutual recursion detection method has\nbeen implemented. This infelicity was discovered by the LLVM fuzzer.\n\n21. Implemented PCRE2_NEVER_BACKSLASH_C.\n\n22. The feature for string replication in pcre2test could read from freed\nmemory if the replication required a buffer to be extended, and it was not\nworking properly in 16-bit and 32-bit modes. This issue was discovered by a\nfuzzer: see http://lcamtuf.coredump.cx/afl/.\n\n23. Added the PCRE2_ALT_CIRCUMFLEX option.\n\n24. Adjust the treatment of \\8 and \\9 to be the same as the current Perl\nbehaviour.\n\n25. Static linking against the PCRE2 library using the pkg-config module was\nfailing on missing pthread symbols.\n\n26. If a group that contained a recursive back reference also contained a\nforward reference subroutine call followed by a non-forward-reference\nsubroutine call, for example /.((?2)(?R)\\1)()/, pcre2_compile() failed to\ncompile correct code, leading to undefined behaviour or an internally detected\nerror. This bug was discovered by the LLVM fuzzer.\n\n27. Quantification of certain items (e.g. atomic back references) could cause\nincorrect code to be compiled when recursive forward references were involved.\nFor example, in this pattern: /(?1)()((((((\\1++))\\x85)+)|))/. This bug was\ndiscovered by the LLVM fuzzer.\n\n28. A repeated conditional group whose condition was a reference by name caused\na buffer overflow if there was more than one group with the given name. This\nbug was discovered by the LLVM fuzzer.\n\n29. A recursive back reference by name within a group that had the same name as\nanother group caused a buffer overflow. For example: /(?J)(?'d'(?'d'\\g{d}))/.\nThis bug was discovered by the LLVM fuzzer.\n\n30. A forward reference by name to a group whose number is the same as the\ncurrent group, for example in this pattern: /(?|(\\k'Pm')|(?'Pm'))/, caused a\nbuffer overflow at compile time. This bug was discovered by the LLVM fuzzer.\n\n31. Fix -fsanitize=undefined warnings for left shifts of 1 by 31 (it treats 1\nas an int; fixed by writing it as 1u).\n\n32. Fix pcre2grep compile when -std=c99 is used with gcc, though it still gives\na warning for \"fileno\" unless -std=gnu99 us used.\n\n33. A lookbehind assertion within a set of mutually recursive subpatterns could\nprovoke a buffer overflow. This bug was discovered by the LLVM fuzzer.\n\n34. Give an error for an empty subpattern name such as (?'').\n\n35. Make pcre2test give an error if a pattern that follows #forbud_utf contains\n\\P, \\p, or \\X.\n\n36. The way named subpatterns are handled has been refactored. There is now a\npre-pass over the regex which does nothing other than identify named\nsubpatterns and count the total captures. This means that information about\nnamed patterns is known before the rest of the compile. In particular, it means\nthat forward references can be checked as they are encountered. Previously, the\ncode for handling forward references was contorted and led to several errors in\ncomputing the memory requirements for some patterns, leading to buffer\noverflows.\n\n37. There was no check for integer overflow in subroutine calls such as (?123).\n\n38. The table entry for \\l in EBCDIC environments was incorrect, leading to its\nbeing treated as a literal 'l' instead of causing an error.\n\n39. If a non-capturing group containing a conditional group that could match\nan empty string was repeated, it was not identified as matching an empty string\nitself. For example: /^(?:(?(1)x|)+)+$()/.\n\n40. In an EBCDIC environment, pcretest was mishandling the escape sequences\n\\a and \\e in test subject lines.\n\n41. In an EBCDIC environment, \\a in a pattern was converted to the ASCII\ninstead of the EBCDIC value.\n\n42. The handling of \\c in an EBCDIC environment has been revised so that it is\nnow compatible with the specification in Perl's perlebcdic page.\n\n43. Single character repetition in JIT has been improved. 20-30% speedup\nwas achieved on certain patterns.\n\n44. The EBCDIC character 0x41 is a non-breaking space, equivalent to 0xa0 in\nASCII/Unicode. This has now been added to the list of characters that are\nrecognized as white space in EBCDIC.\n\n45. When PCRE2 was compiled without Unicode support, the use of \\p and \\P gave\nan error (correctly) when used outside a class, but did not give an error\nwithin a class.\n\n46. \\h within a class was incorrectly compiled in EBCDIC environments.\n\n47. JIT should return with error when the compiled pattern requires\nmore stack space than the maximum.\n\n48. Fixed a memory leak in pcre2grep when a locale is set.\n\n\nVersion 10.10 06-March-2015\n---------------------------\n\n1. When a pattern is compiled, it remembers the highest back reference so that\nwhen matching, if the ovector is too small, extra memory can be obtained to\nuse instead. A conditional subpattern whose condition is a check on a capture\nhaving happened, such as, for example in the pattern /^(?:(a)|b)(?(1)A|B)/, is\nanother kind of back reference, but it was not setting the highest\nbackreference number. This mattered only if pcre2_match() was called with an\novector that was too small to hold the capture, and there was no other kind of\nback reference (a situation which is probably quite rare). The effect of the\nbug was that the condition was always treated as FALSE when the capture could\nnot be consulted, leading to a incorrect behaviour by pcre2_match(). This bug\nhas been fixed.\n\n2. Functions for serialization and deserialization of sets of compiled patterns\nhave been added.\n\n3. The value that is returned by PCRE2_INFO_SIZE has been corrected to remove\nexcess code units at the end of the data block that may occasionally occur if\nthe code for calculating the size over-estimates. This change stops the\nserialization code copying uninitialized data, to which valgrind objects. The\ndocumentation of PCRE2_INFO_SIZE was incorrect in stating that the size did not\ninclude the general overhead. This has been corrected.\n\n4. All code units in every slot in the table of group names are now set, again\nin order to avoid accessing uninitialized data when serializing.\n\n5. The (*NO_JIT) feature is implemented.\n\n6. If a bug that caused pcre2_compile() to use more memory than allocated was\ntriggered when using valgrind, the code in (3) above passed a stupidly large\nvalue to valgrind. This caused a crash instead of an \"internal error\" return.\n\n7. A reference to a duplicated named group (either a back reference or a test\nfor being set in a conditional) that occurred in a part of the pattern where\nPCRE2_DUPNAMES was not set caused the amount of memory needed for the pattern\nto be incorrectly calculated, leading to overwriting.\n\n8. A mutually recursive set of back references such as (\\2)(\\1) caused a\nsegfault at compile time (while trying to find the minimum matching length).\nThe infinite loop is now broken (with the minimum length unset, that is, zero).\n\n9. If an assertion that was used as a condition was quantified with a minimum\nof zero, matching went wrong. In particular, if the whole group had unlimited\nrepetition and could match an empty string, a segfault was likely. The pattern\n(?(?=0)?)+ is an example that caused this. Perl allows assertions to be\nquantified, but not if they are being used as conditions, so the above pattern\nis faulted by Perl. PCRE2 has now been changed so that it also rejects such\npatterns.\n\n10. The error message for an invalid quantifier has been changed from \"nothing\nto repeat\" to \"quantifier does not follow a repeatable item\".\n\n11. If a bad UTF string is compiled with NO_UTF_CHECK, it may succeed, but\nscanning the compiled pattern in subsequent auto-possessification can get out\nof step and lead to an unknown opcode. Previously this could have caused an\ninfinite loop. Now it generates an \"internal error\" error. This is a tidyup,\nnot a bug fix; passing bad UTF with NO_UTF_CHECK is documented as having an\nundefined outcome.\n\n12. A UTF pattern containing a \"not\" match of a non-ASCII character and a\nsubroutine reference could loop at compile time. Example: /[^\\xff]((?1))/.\n\n13. The locale test (RunTest 3) has been upgraded. It now checks that a locale\nthat is found in the output of \"locale -a\" can actually be set by pcre2test\nbefore it is accepted. Previously, in an environment where a locale was listed\nbut would not set (an example does exist), the test would \"pass\" without\nactually doing anything. Also the fr_CA locale has been added to the list of\nlocales that can be used.\n\n14. Fixed a bug in pcre2_substitute(). If a replacement string ended in a\ncapturing group number without parentheses, the last character was incorrectly\nliterally included at the end of the replacement string.\n\n15. A possessive capturing group such as (a)*+ with a minimum repeat of zero\nfailed to allow the zero-repeat case if pcre2_match() was called with an\novector too small to capture the group.\n\n16. Improved error message in pcre2test when setting the stack size (-S) fails.\n\n17. Fixed two bugs in CMakeLists.txt: (1) Some lines had got lost in the\ntransfer from PCRE1, meaning that CMake configuration failed if \"build tests\"\nwas selected. (2) The file src/pcre2_serialize.c had not been added to the list\nof PCRE2 sources, which caused a failure to build pcre2test.\n\n18. Fixed typo in pcre2_serialize.c (DECL instead of DEFN) that causes problems\nonly on Windows.\n\n19. Use binary input when reading back saved serialized patterns in pcre2test.\n\n20. Added RunTest.bat for running the tests under Windows.\n\n21. \"make distclean\" was not removing config.h, a file that may be created for\nuse with CMake.\n\n22. A pattern such as \"((?2){0,1999}())?\", which has a group containing a\nforward reference repeated a large (but limited) number of times within a\nrepeated outer group that has a zero minimum quantifier, caused incorrect code\nto be compiled, leading to the error \"internal error: previously-checked\nreferenced subpattern not found\" when an incorrect memory address was read.\nThis bug was reported as \"heap overflow\", discovered by Kai Lu of Fortinet's\nFortiGuard Labs. (Added 24-March-2015: CVE-2015-2325 was given to this.)\n\n23. A pattern such as \"((?+1)(\\1))/\" containing a forward reference subroutine\ncall within a group that also contained a recursive back reference caused\nincorrect code to be compiled. This bug was reported as \"heap overflow\",\ndiscovered by Kai Lu of Fortinet's FortiGuard Labs. (Added 24-March-2015:\nCVE-2015-2326 was given to this.)\n\n24. Computing the size of the JIT read-only data in advance has been a source\nof various issues, and new ones are still appear unfortunately. To fix\nexisting and future issues, size computation is eliminated from the code,\nand replaced by on-demand memory allocation.\n\n25. A pattern such as /(?i)[A-`]/, where characters in the other case are\nadjacent to the end of the range, and the range contained characters with more\nthan one other case, caused incorrect behaviour when compiled in UTF mode. In\nthat example, the range a-j was left out of the class.\n\n\nVersion 10.00 05-January-2015\n-----------------------------\n\nVersion 10.00 is the first release of PCRE2, a revised API for the PCRE\nlibrary. Changes prior to 10.00 are logged in the ChangeLog file for the old\nAPI, up to item 20 for release 8.36.\n\nThe code of the library was heavily revised as part of the new API\nimplementation. Details of each and every modification were not individually\nlogged. In addition to the API changes, the following changes were made. They\nare either new functionality, or bug fixes and other noticeable changes of\nbehaviour that were implemented after the code had been forked.\n\n1. Including Unicode support at build time is now enabled by default, but it\ncan optionally be disabled. It is not enabled by default at run time (no\nchange).\n\n2. The test program, now called pcre2test, was re-specified and almost\ncompletely re-written. Its input is not compatible with input for pcretest.\n\n3. Patterns may start with (*NOTEMPTY) or (*NOTEMPTY_ATSTART) to set the\nPCRE2_NOTEMPTY or PCRE2_NOTEMPTY_ATSTART options for every subject line that is\nmatched by that pattern.\n\n4. For the benefit of those who use PCRE2 via some other application, that is,\nnot writing the function calls themselves, it is possible to check the PCRE2\nversion by matching a pattern such as /(?(VERSION>=10)yes|no)/ against a\nstring such as \"yesno\".\n\n5. There are case-equivalent Unicode characters whose encodings use different\nnumbers of code units in UTF-8. U+023A and U+2C65 are one example. (It is\ntheoretically possible for this to happen in UTF-16 too.) If a backreference to\na group containing one of these characters was greedily repeated, and during\nthe match a backtrack occurred, the subject might be backtracked by the wrong\nnumber of code units. For example, if /^(\\x{23a})\\1*(.)/ is matched caselessly\n(and in UTF-8 mode) against \"\\x{23a}\\x{2c65}\\x{2c65}\\x{2c65}\", group 2 should\ncapture the final character, which is the three bytes E2, B1, and A5 in UTF-8.\nIncorrect backtracking meant that group 2 captured only the last two bytes.\nThis bug has been fixed; the new code is slower, but it is used only when the\nstrings matched by the repetition are not all the same length.\n\n6. A pattern such as /()a/ was not setting the \"first character must be 'a'\"\ninformation. This applied to any pattern with a group that matched no\ncharacters, for example: /(?:(?=.)|(?<!x))a/.\n\n7. When an (*ACCEPT) is triggered inside capturing parentheses, it arranges for\nthose parentheses to be closed with whatever has been captured so far. However,\nit was failing to mark any other groups between the highest capture so far and\nthe currrent group as \"unset\". Thus, the ovector for those groups contained\nwhatever was previously there. An example is the pattern /(x)|((*ACCEPT))/ when\nmatched against \"abcd\".\n\n8. The pcre2_substitute() function has been implemented.\n\n9. If an assertion used as a condition was quantified with a minimum of zero\n(an odd thing to do, but it happened), SIGSEGV or other misbehaviour could\noccur.\n\n10. The PCRE2_NO_DOTSTAR_ANCHOR option has been implemented.\n\n****\n", "/*************************************************\n*             PCRE2 testing program              *\n*************************************************/\n\n/* PCRE2 is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language. In 2014\nthe API was completely revised and '2' was added to the name, because the old\nAPI, which had lasted for 16 years, could not accommodate new requirements. At\nthe same time, this testing program was re-designed because its original\nhacked-up (non-) design had also run out of steam.\n\n                       Written by Philip Hazel\n     Original code Copyright (c) 1997-2012 University of Cambridge\n    Rewritten code Copyright (c) 2016-2022 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n\n/* This program supports testing of the 8-bit, 16-bit, and 32-bit PCRE2\nlibraries in a single program, though its input and output are always 8-bit.\nIt is different from modules such as pcre2_compile.c in the library itself,\nwhich are compiled separately for each code unit width. If two widths are\nenabled, for example, pcre2_compile.c is compiled twice. In contrast,\npcre2test.c is compiled only once, and linked with all the enabled libraries.\nTherefore, it must not make use of any of the macros from pcre2.h or\npcre2_internal.h that depend on PCRE2_CODE_UNIT_WIDTH. It does, however, make\nuse of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16, and SUPPORT_PCRE2_32, to ensure that\nit references only the enabled library functions. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <locale.h>\n#include <errno.h>\n\n#if defined NATIVE_ZOS\n#include \"pcrzoscs.h\"\n/* That header is not included in the main PCRE2 distribution because other\napparatus is needed to compile pcre2test for z/OS. The header can be found in\nthe special z/OS distribution, which is available from www.zaconsultants.net or\nfrom www.cbttape.org. */\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n/* Debugging code enabler */\n\n/* #define DEBUG_SHOW_MALLOC_ADDRESSES */\n\n/* Both libreadline and libedit are optionally supported */\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\n#if defined(SUPPORT_LIBREADLINE)\n#include <readline/readline.h>\n#include <readline/history.h>\n#else\n#if defined(HAVE_EDITLINE_READLINE_H)\n#include <editline/readline.h>\n#elif defined(HAVE_EDIT_READLINE_READLINE_H)\n#include <edit/readline/readline.h>\n#else\n#include <readline.h>\n/* GNU readline defines this macro but libedit doesn't, if that ever changes\nthis needs to be updated or the build could break */\n#ifdef RL_VERSION_MAJOR\n#include <history.h>\n#endif\n#endif\n#endif\n#endif\n\n/* Put the test for interactive input into a macro so that it can be changed if\nrequired for different environments. */\n\n#define INTERACTIVE(f) isatty(fileno(f))\n\n\n/* ---------------------- System-specific definitions ---------------------- */\n\n/* A number of things vary for Windows builds. Originally, pcretest opened its\ninput and output without \"b\"; then I was told that \"b\" was needed in some\nenvironments, so it was added for release 5.0 to both the input and output. (It\nmakes no difference on Unix-like systems.) Later I was told that it is wrong\nfor the input on Windows. I've now abstracted the modes into macros that are\nset here, to make it easier to fiddle with them, and removed \"b\" from the input\nmode under Windows. The BINARY versions are used when saving/restoring compiled\npatterns. */\n\n#if defined(_WIN32) || defined(WIN32)\n#include <io.h>                /* For _setmode() */\n#include <fcntl.h>             /* For _O_BINARY */\n#define INPUT_MODE          \"r\"\n#define OUTPUT_MODE         \"wb\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n\n#ifndef isatty\n#define isatty _isatty         /* This is what Windows calls them, I'm told, */\n#endif                         /* though in some environments they seem to   */\n                               /* be already defined, hence the #ifndefs.    */\n#ifndef fileno\n#define fileno _fileno\n#endif\n\n/* A user sent this fix for Borland Builder 5 under Windows. */\n\n#ifdef __BORLANDC__\n#define _setmode(handle, mode) setmode(handle, mode)\n#endif\n\n/* Not Windows */\n\n#else\n#include <sys/time.h>          /* These two includes are needed */\n#include <sys/resource.h>      /* for setrlimit(). */\n#if defined NATIVE_ZOS         /* z/OS uses non-binary I/O */\n#define INPUT_MODE   \"r\"\n#define OUTPUT_MODE  \"w\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n#else\n#define INPUT_MODE          \"rb\"\n#define OUTPUT_MODE         \"wb\"\n#define BINARY_INPUT_MODE   \"rb\"\n#define BINARY_OUTPUT_MODE  \"wb\"\n#endif\n#endif\n\n/* VMS-specific code was included as suggested by a VMS user [1]. Another VMS\nuser [2] provided alternative code which worked better for him. I have\ncommented out the original, but kept it around just in case. */\n\n#ifdef __VMS\n#include <ssdef.h>\n/* These two includes came from [2]. */\n#include descrip\n#include lib$routines\n/* void vms_setsymbol( char *, char *, int ); Original code from [1]. */\n#endif\n\n/* old VC and older compilers don't support %td or %zu, and even some that\nclaim to be C99 don't support it (hence DISABLE_PERCENT_ZT). */\n\n#if defined(DISABLE_PERCENT_ZT) || (defined(_MSC_VER) && (_MSC_VER < 1800)) || \\\n  (!defined(_MSC_VER) && (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L)))\n#ifdef _WIN64\n#define PTR_FORM \"lld\"\n#define SIZ_FORM \"llu\"\n#else\n#define PTR_FORM \"ld\"\n#define SIZ_FORM \"lu\"\n#endif\n#else\n#define PTR_FORM \"td\"\n#define SIZ_FORM \"zu\"\n#endif\n\n/* ------------------End of system-specific definitions -------------------- */\n\n/* Glueing macros that are used in several places below. */\n\n#define glue(a,b) a##b\n#define G(a,b) glue(a,b)\n\n/* Miscellaneous parameters and manifests */\n\n#ifndef CLOCKS_PER_SEC\n#ifdef CLK_TCK\n#define CLOCKS_PER_SEC CLK_TCK\n#else\n#define CLOCKS_PER_SEC 100\n#endif\n#endif\n\n#define CFORE_UNSET UINT32_MAX    /* Unset value for startend/cfail/cerror fields */\n#define CONVERT_UNSET UINT32_MAX  /* Unset value for convert_type field */\n#define DFA_WS_DIMENSION 1000     /* Size of DFA workspace */\n#define DEFAULT_OVECCOUNT 15      /* Default ovector count */\n#define JUNK_OFFSET 0xdeadbeef    /* For initializing ovector */\n#define LOCALESIZE 32             /* Size of locale name */\n#define LOOPREPEAT 500000         /* Default loop count for timing */\n#define MALLOCLISTSIZE 20         /* For remembering mallocs */\n#define PARENS_NEST_DEFAULT 220   /* Default parentheses nest limit */\n#define PATSTACKSIZE 20           /* Pattern stack for save/restore testing */\n#define REPLACE_MODSIZE 100       /* Field for reading 8-bit replacement */\n#define VERSION_SIZE 64           /* Size of buffer for the version strings */\n\n/* Default JIT compile options */\n\n#define JIT_DEFAULT (PCRE2_JIT_COMPLETE|\\\n                     PCRE2_JIT_PARTIAL_SOFT|\\\n                     PCRE2_JIT_PARTIAL_HARD)\n\n/* Make sure the buffer into which replacement strings are copied is big enough\nto hold them as 32-bit code units. */\n\n#define REPLACE_BUFFSIZE 1024   /* This is a byte value */\n\n/* Execution modes */\n\n#define PCRE8_MODE   8\n#define PCRE16_MODE 16\n#define PCRE32_MODE 32\n\n/* Processing returns */\n\nenum { PR_OK, PR_SKIP, PR_ABEND };\n\n/* The macro PRINTABLE determines whether to print an output character as-is or\nas a hex value when showing compiled patterns. is We use it in cases when the\nlocale has not been explicitly changed, so as to get consistent output from\nsystems that differ in their output from isprint() even in the \"C\" locale. */\n\n#ifdef EBCDIC\n#define PRINTABLE(c) ((c) >= 64 && (c) < 255)\n#else\n#define PRINTABLE(c) ((c) >= 32 && (c) < 127)\n#endif\n\n#define PRINTOK(c) ((use_tables != NULL && c < 256)? isprint(c) : PRINTABLE(c))\n\n/* We have to include some of the library source files because we need\nto use some of the macros, internal structure definitions, and other internal\nvalues - pcre2test has \"inside information\" compared to an application program\nthat strictly follows the PCRE2 API.\n\nBefore including pcre2_internal.h we define PRIV so that it does not get\ndefined therein. This ensures that PRIV names in the included files do not\nclash with those in the libraries. Also, although pcre2_internal.h does itself\ninclude pcre2.h, we explicitly include it beforehand, along with pcre2posix.h,\nso that the PCRE2_EXP_xxx macros get set appropriately for an application, not\nfor building the library. */\n\n#define PRIV(name) name\n#define PCRE2_CODE_UNIT_WIDTH 0\n#include \"pcre2.h\"\n#include \"pcre2posix.h\"\n#include \"pcre2_internal.h\"\n\n/* We need access to some of the data tables that PCRE2 uses. Defining\nPCRE2_PCRETEST makes some minor changes in the files. The previous definition\nof PRIV avoids name clashes. */\n\n#define PCRE2_PCRE2TEST\n#include \"pcre2_tables.c\"\n#include \"pcre2_ucd.c\"\n\n/* 32-bit integer values in the input are read by strtoul() or strtol(). The\ncheck needed for overflow depends on whether long ints are in fact longer than\nints. They are defined not to be shorter. */\n\n#if ULONG_MAX > UINT32_MAX\n#define U32OVERFLOW(x) (x > UINT32_MAX)\n#else\n#define U32OVERFLOW(x) (x == UINT32_MAX)\n#endif\n\n#if LONG_MAX > INT32_MAX\n#define S32OVERFLOW(x) (x > INT32_MAX || x < INT32_MIN)\n#else\n#define S32OVERFLOW(x) (x == INT32_MAX || x == INT32_MIN)\n#endif\n\n/* When PCRE2_CODE_UNIT_WIDTH is zero, pcre2_internal.h does not include\npcre2_intmodedep.h, which is where mode-dependent macros and structures are\ndefined. We can now include it for each supported code unit width. Because\nPCRE2_CODE_UNIT_WIDTH was defined as zero before including pcre2.h, it will\nhave left PCRE2_SUFFIX defined as a no-op. We must re-define it appropriately\nwhile including these files, and then restore it to a no-op. Because LINK_SIZE\nmay be changed in 16-bit mode and forced to 1 in 32-bit mode, the order of\nthese inclusions should not be changed. */\n\n#undef PCRE2_SUFFIX\n#undef PCRE2_CODE_UNIT_WIDTH\n\n#ifdef   SUPPORT_PCRE2_8\n#define  PCRE2_CODE_UNIT_WIDTH 8\n#define  PCRE2_SUFFIX(a) G(a,8)\n#include \"pcre2_intmodedep.h\"\n#include \"pcre2_printint.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_8 */\n\n#ifdef   SUPPORT_PCRE2_16\n#define  PCRE2_CODE_UNIT_WIDTH 16\n#define  PCRE2_SUFFIX(a) G(a,16)\n#include \"pcre2_intmodedep.h\"\n#include \"pcre2_printint.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_16 */\n\n#ifdef   SUPPORT_PCRE2_32\n#define  PCRE2_CODE_UNIT_WIDTH 32\n#define  PCRE2_SUFFIX(a) G(a,32)\n#include \"pcre2_intmodedep.h\"\n#include \"pcre2_printint.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SUFFIX\n#endif   /* SUPPORT_PCRE2_32 */\n\n#define PCRE2_SUFFIX(a) a\n\n/* We need to be able to check input text for UTF-8 validity, whatever code\nwidths are actually available, because the input to pcre2test is always in\n8-bit code units. So we include the UTF validity checking function for 8-bit\ncode units. */\n\nextern int valid_utf(PCRE2_SPTR8, PCRE2_SIZE, PCRE2_SIZE *);\n\n#define  PCRE2_CODE_UNIT_WIDTH 8\n#undef   PCRE2_SPTR\n#define  PCRE2_SPTR PCRE2_SPTR8\n#include \"pcre2_valid_utf.c\"\n#undef   PCRE2_CODE_UNIT_WIDTH\n#undef   PCRE2_SPTR\n\n/* If we have 8-bit support, default to it; if there is also 16-or 32-bit\nsupport, it can be selected by a command-line option. If there is no 8-bit\nsupport, there must be 16-bit or 32-bit support, so default to one of them. The\nconfig function, JIT stack, contexts, and version string are the same in all\nmodes, so use the form of the first that is available. */\n\n#if defined SUPPORT_PCRE2_8\n#define DEFAULT_TEST_MODE PCRE8_MODE\n#define VERSION_TYPE PCRE2_UCHAR8\n#define PCRE2_CONFIG pcre2_config_8\n#define PCRE2_JIT_STACK pcre2_jit_stack_8\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_8\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_8\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_8\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_8\n\n#elif defined SUPPORT_PCRE2_16\n#define DEFAULT_TEST_MODE PCRE16_MODE\n#define VERSION_TYPE PCRE2_UCHAR16\n#define PCRE2_CONFIG pcre2_config_16\n#define PCRE2_JIT_STACK pcre2_jit_stack_16\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_16\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_16\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_16\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_16\n\n#elif defined SUPPORT_PCRE2_32\n#define DEFAULT_TEST_MODE PCRE32_MODE\n#define VERSION_TYPE PCRE2_UCHAR32\n#define PCRE2_CONFIG pcre2_config_32\n#define PCRE2_JIT_STACK pcre2_jit_stack_32\n#define PCRE2_REAL_GENERAL_CONTEXT pcre2_real_general_context_32\n#define PCRE2_REAL_COMPILE_CONTEXT pcre2_real_compile_context_32\n#define PCRE2_REAL_CONVERT_CONTEXT pcre2_real_convert_context_32\n#define PCRE2_REAL_MATCH_CONTEXT pcre2_real_match_context_32\n#endif\n\n/* ------------- Structure and table for handling #-commands ------------- */\n\ntypedef struct cmdstruct {\n  const char *name;\n  int  value;\n} cmdstruct;\n\nenum { CMD_FORBID_UTF, CMD_LOAD, CMD_LOADTABLES, CMD_NEWLINE_DEFAULT,\n  CMD_PATTERN, CMD_PERLTEST, CMD_POP, CMD_POPCOPY, CMD_SAVE, CMD_SUBJECT,\n  CMD_UNKNOWN };\n\nstatic cmdstruct cmdlist[] = {\n  { \"forbid_utf\",      CMD_FORBID_UTF },\n  { \"load\",            CMD_LOAD },\n  { \"loadtables\",      CMD_LOADTABLES },\n  { \"newline_default\", CMD_NEWLINE_DEFAULT },\n  { \"pattern\",         CMD_PATTERN },\n  { \"perltest\",        CMD_PERLTEST },\n  { \"pop\",             CMD_POP },\n  { \"popcopy\",         CMD_POPCOPY },\n  { \"save\",            CMD_SAVE },\n  { \"subject\",         CMD_SUBJECT }};\n\n#define cmdlistcount (sizeof(cmdlist)/sizeof(cmdstruct))\n\n/* ------------- Structures and tables for handling modifiers -------------- */\n\n/* Table of names for newline types. Must be kept in step with the definitions\nof PCRE2_NEWLINE_xx in pcre2.h. */\n\nstatic const char *newlines[] = {\n  \"DEFAULT\", \"CR\", \"LF\", \"CRLF\", \"ANY\", \"ANYCRLF\", \"NUL\" };\n\n/* Structure and table for handling pattern conversion types. */\n\ntypedef struct convertstruct {\n  const char *name;\n  uint32_t option;\n} convertstruct;\n\nstatic convertstruct convertlist[] = {\n  { \"glob\",                   PCRE2_CONVERT_GLOB },\n  { \"glob_no_starstar\",       PCRE2_CONVERT_GLOB_NO_STARSTAR },\n  { \"glob_no_wild_separator\", PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR },\n  { \"posix_basic\",            PCRE2_CONVERT_POSIX_BASIC },\n  { \"posix_extended\",         PCRE2_CONVERT_POSIX_EXTENDED },\n  { \"unset\",                  CONVERT_UNSET }};\n\n#define convertlistcount (sizeof(convertlist)/sizeof(convertstruct))\n\n/* Modifier types and applicability */\n\nenum { MOD_CTC,    /* Applies to a compile context */\n       MOD_CTM,    /* Applies to a match context */\n       MOD_PAT,    /* Applies to a pattern */\n       MOD_PATP,   /* Ditto, OK for Perl test */\n       MOD_DAT,    /* Applies to a data line */\n       MOD_DATP,   /* Ditto, OK for Perl test */\n       MOD_PD,     /* Applies to a pattern or a data line */\n       MOD_PDP,    /* As MOD_PD, OK for Perl test */\n       MOD_PND,    /* As MOD_PD, but not for a default pattern */\n       MOD_PNDP,   /* As MOD_PND, OK for Perl test */\n       MOD_CHR,    /* Is a single character */\n       MOD_CON,    /* Is a \"convert\" type/options list */\n       MOD_CTL,    /* Is a control bit */\n       MOD_BSR,    /* Is a BSR value */\n       MOD_IN2,    /* Is one or two unsigned integers */\n       MOD_INS,    /* Is a signed integer */\n       MOD_INT,    /* Is an unsigned integer */\n       MOD_IND,    /* Is an unsigned integer, but no value => default */\n       MOD_NL,     /* Is a newline value */\n       MOD_NN,     /* Is a number or a name; more than one may occur */\n       MOD_OPT,    /* Is an option bit */\n       MOD_SIZ,    /* Is a PCRE2_SIZE value */\n       MOD_STR };  /* Is a string */\n\n/* Control bits. Some apply to compiling, some to matching, but some can be set\neither on a pattern or a data line, so they must all be distinct. There are now\nso many of them that they are split into two fields. */\n\n#define CTL_AFTERTEXT                    0x00000001u\n#define CTL_ALLAFTERTEXT                 0x00000002u\n#define CTL_ALLCAPTURES                  0x00000004u\n#define CTL_ALLUSEDTEXT                  0x00000008u\n#define CTL_ALTGLOBAL                    0x00000010u\n#define CTL_BINCODE                      0x00000020u\n#define CTL_CALLOUT_CAPTURE              0x00000040u\n#define CTL_CALLOUT_INFO                 0x00000080u\n#define CTL_CALLOUT_NONE                 0x00000100u\n#define CTL_DFA                          0x00000200u\n#define CTL_EXPAND                       0x00000400u\n#define CTL_FINDLIMITS                   0x00000800u\n#define CTL_FINDLIMITS_NOHEAP            0x00001000u\n#define CTL_FULLBINCODE                  0x00002000u\n#define CTL_GETALL                       0x00004000u\n#define CTL_GLOBAL                       0x00008000u\n#define CTL_HEXPAT                       0x00010000u  /* Same word as USE_LENGTH */\n#define CTL_INFO                         0x00020000u\n#define CTL_JITFAST                      0x00040000u\n#define CTL_JITVERIFY                    0x00080000u\n#define CTL_MARK                         0x00100000u\n#define CTL_MEMORY                       0x00200000u\n#define CTL_NULLCONTEXT                  0x00400000u\n#define CTL_POSIX                        0x00800000u\n#define CTL_POSIX_NOSUB                  0x01000000u\n#define CTL_PUSH                         0x02000000u  /* These three must be */\n#define CTL_PUSHCOPY                     0x04000000u  /*   all in the same */\n#define CTL_PUSHTABLESCOPY               0x08000000u  /*     word. */\n#define CTL_STARTCHAR                    0x10000000u\n#define CTL_USE_LENGTH                   0x20000000u  /* Same word as HEXPAT */\n#define CTL_UTF8_INPUT                   0x40000000u\n#define CTL_ZERO_TERMINATE               0x80000000u\n\n/* Combinations */\n\n#define CTL_DEBUG            (CTL_FULLBINCODE|CTL_INFO)  /* For setting */\n#define CTL_ANYINFO          (CTL_DEBUG|CTL_BINCODE|CTL_CALLOUT_INFO)\n#define CTL_ANYGLOB          (CTL_ALTGLOBAL|CTL_GLOBAL)\n\n/* Second control word */\n\n#define CTL2_SUBSTITUTE_CALLOUT          0x00000001u\n#define CTL2_SUBSTITUTE_EXTENDED         0x00000002u\n#define CTL2_SUBSTITUTE_LITERAL          0x00000004u\n#define CTL2_SUBSTITUTE_MATCHED          0x00000008u\n#define CTL2_SUBSTITUTE_OVERFLOW_LENGTH  0x00000010u\n#define CTL2_SUBSTITUTE_REPLACEMENT_ONLY 0x00000020u\n#define CTL2_SUBSTITUTE_UNKNOWN_UNSET    0x00000040u\n#define CTL2_SUBSTITUTE_UNSET_EMPTY      0x00000080u\n#define CTL2_SUBJECT_LITERAL             0x00000100u\n#define CTL2_CALLOUT_NO_WHERE            0x00000200u\n#define CTL2_CALLOUT_EXTRA               0x00000400u\n#define CTL2_ALLVECTOR                   0x00000800u\n#define CTL2_NULL_SUBJECT                0x00001000u\n#define CTL2_NULL_REPLACEMENT            0x00002000u\n#define CTL2_FRAMESIZE                   0x00004000u\n\n#define CTL2_NL_SET                      0x40000000u  /* Informational */\n#define CTL2_BSR_SET                     0x80000000u  /* Informational */\n\n/* These are the matching controls that may be set either on a pattern or on a\ndata line. They are copied from the pattern controls as initial settings for\ndata line controls. Note that CTL_MEMORY is not included here, because it does\ndifferent things in the two cases. */\n\n#define CTL_ALLPD  (CTL_AFTERTEXT|\\\n                    CTL_ALLAFTERTEXT|\\\n                    CTL_ALLCAPTURES|\\\n                    CTL_ALLUSEDTEXT|\\\n                    CTL_ALTGLOBAL|\\\n                    CTL_GLOBAL|\\\n                    CTL_MARK|\\\n                    CTL_STARTCHAR|\\\n                    CTL_UTF8_INPUT)\n\n#define CTL2_ALLPD (CTL2_SUBSTITUTE_CALLOUT|\\\n                    CTL2_SUBSTITUTE_EXTENDED|\\\n                    CTL2_SUBSTITUTE_LITERAL|\\\n                    CTL2_SUBSTITUTE_MATCHED|\\\n                    CTL2_SUBSTITUTE_OVERFLOW_LENGTH|\\\n                    CTL2_SUBSTITUTE_REPLACEMENT_ONLY|\\\n                    CTL2_SUBSTITUTE_UNKNOWN_UNSET|\\\n                    CTL2_SUBSTITUTE_UNSET_EMPTY|\\\n                    CTL2_ALLVECTOR)\n\n/* Structures for holding modifier information for patterns and subject strings\n(data). Fields containing modifiers that can be set either for a pattern or a\nsubject must be at the start and in the same order in both cases so that the\nsame offset in the big table below works for both. */\n\ntypedef struct patctl {       /* Structure for pattern modifiers. */\n  uint32_t  options;          /* Must be in same position as datctl */\n  uint32_t  control;          /* Must be in same position as datctl */\n  uint32_t  control2;         /* Must be in same position as datctl */\n  uint32_t  jitstack;         /* Must be in same position as datctl */\n   uint8_t  replacement[REPLACE_MODSIZE];  /* So must this */\n  uint32_t  substitute_skip;  /* Must be in same position as patctl */\n  uint32_t  substitute_stop;  /* Must be in same position as patctl */\n  uint32_t  jit;\n  uint32_t  stackguard_test;\n  uint32_t  tables_id;\n  uint32_t  convert_type;\n  uint32_t  convert_length;\n  uint32_t  convert_glob_escape;\n  uint32_t  convert_glob_separator;\n  uint32_t  regerror_buffsize;\n   uint8_t  locale[LOCALESIZE];\n} patctl;\n\n#define MAXCPYGET 10\n#define LENCPYGET 64\n\ntypedef struct datctl {       /* Structure for data line modifiers. */\n  uint32_t  options;          /* Must be in same position as patctl */\n  uint32_t  control;          /* Must be in same position as patctl */\n  uint32_t  control2;         /* Must be in same position as patctl */\n  uint32_t  jitstack;         /* Must be in same position as patctl */\n   uint8_t  replacement[REPLACE_MODSIZE];  /* So must this */\n  uint32_t  substitute_skip;  /* Must be in same position as patctl */\n  uint32_t  substitute_stop;  /* Must be in same position as patctl */\n  uint32_t  startend[2];\n  uint32_t  cerror[2];\n  uint32_t  cfail[2];\n   int32_t  callout_data;\n   int32_t  copy_numbers[MAXCPYGET];\n   int32_t  get_numbers[MAXCPYGET];\n  uint32_t  oveccount;\n  uint32_t  offset;\n  uint8_t   copy_names[LENCPYGET];\n  uint8_t   get_names[LENCPYGET];\n} datctl;\n\n/* Ids for which context to modify. */\n\nenum { CTX_PAT,            /* Active pattern context */\n       CTX_POPPAT,         /* Ditto, for a popped pattern */\n       CTX_DEFPAT,         /* Default pattern context */\n       CTX_DAT,            /* Active data (match) context */\n       CTX_DEFDAT };       /* Default data (match) context */\n\n/* Macros to simplify the big table below. */\n\n#define CO(name) offsetof(PCRE2_REAL_COMPILE_CONTEXT, name)\n#define MO(name) offsetof(PCRE2_REAL_MATCH_CONTEXT, name)\n#define PO(name) offsetof(patctl, name)\n#define PD(name) PO(name)\n#define DO(name) offsetof(datctl, name)\n\n/* Table of all long-form modifiers. Must be in collating sequence of modifier\nname because it is searched by binary chop. */\n\ntypedef struct modstruct {\n  const char   *name;\n  uint16_t      which;\n  uint16_t      type;\n  uint32_t      value;\n  PCRE2_SIZE    offset;\n} modstruct;\n\nstatic modstruct modlist[] = {\n  { \"aftertext\",                   MOD_PNDP, MOD_CTL, CTL_AFTERTEXT,              PO(control) },\n  { \"allaftertext\",                MOD_PNDP, MOD_CTL, CTL_ALLAFTERTEXT,           PO(control) },\n  { \"allcaptures\",                 MOD_PND,  MOD_CTL, CTL_ALLCAPTURES,            PO(control) },\n  { \"allow_empty_class\",           MOD_PAT,  MOD_OPT, PCRE2_ALLOW_EMPTY_CLASS,    PO(options) },\n  { \"allow_lookaround_bsk\",        MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK, CO(extra_options) },\n  { \"allow_surrogate_escapes\",     MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES, CO(extra_options) },\n  { \"allusedtext\",                 MOD_PNDP, MOD_CTL, CTL_ALLUSEDTEXT,            PO(control) },\n  { \"allvector\",                   MOD_PND,  MOD_CTL, CTL2_ALLVECTOR,             PO(control2) },\n  { \"alt_bsux\",                    MOD_PAT,  MOD_OPT, PCRE2_ALT_BSUX,             PO(options) },\n  { \"alt_circumflex\",              MOD_PAT,  MOD_OPT, PCRE2_ALT_CIRCUMFLEX,       PO(options) },\n  { \"alt_verbnames\",               MOD_PAT,  MOD_OPT, PCRE2_ALT_VERBNAMES,        PO(options) },\n  { \"altglobal\",                   MOD_PND,  MOD_CTL, CTL_ALTGLOBAL,              PO(control) },\n  { \"anchored\",                    MOD_PD,   MOD_OPT, PCRE2_ANCHORED,             PD(options) },\n  { \"auto_callout\",                MOD_PAT,  MOD_OPT, PCRE2_AUTO_CALLOUT,         PO(options) },\n  { \"bad_escape_is_literal\",       MOD_CTC,  MOD_OPT, PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL, CO(extra_options) },\n  { \"bincode\",                     MOD_PAT,  MOD_CTL, CTL_BINCODE,                PO(control) },\n  { \"bsr\",                         MOD_CTC,  MOD_BSR, 0,                          CO(bsr_convention) },\n  { \"callout_capture\",             MOD_DAT,  MOD_CTL, CTL_CALLOUT_CAPTURE,        DO(control) },\n  { \"callout_data\",                MOD_DAT,  MOD_INS, 0,                          DO(callout_data) },\n  { \"callout_error\",               MOD_DAT,  MOD_IN2, 0,                          DO(cerror) },\n  { \"callout_extra\",               MOD_DAT,  MOD_CTL, CTL2_CALLOUT_EXTRA,         DO(control2) },\n  { \"callout_fail\",                MOD_DAT,  MOD_IN2, 0,                          DO(cfail) },\n  { \"callout_info\",                MOD_PAT,  MOD_CTL, CTL_CALLOUT_INFO,           PO(control) },\n  { \"callout_no_where\",            MOD_DAT,  MOD_CTL, CTL2_CALLOUT_NO_WHERE,      DO(control2) },\n  { \"callout_none\",                MOD_DAT,  MOD_CTL, CTL_CALLOUT_NONE,           DO(control) },\n  { \"caseless\",                    MOD_PATP, MOD_OPT, PCRE2_CASELESS,             PO(options) },\n  { \"convert\",                     MOD_PAT,  MOD_CON, 0,                          PO(convert_type) },\n  { \"convert_glob_escape\",         MOD_PAT,  MOD_CHR, 0,                          PO(convert_glob_escape) },\n  { \"convert_glob_separator\",      MOD_PAT,  MOD_CHR, 0,                          PO(convert_glob_separator) },\n  { \"convert_length\",              MOD_PAT,  MOD_INT, 0,                          PO(convert_length) },\n  { \"copy\",                        MOD_DAT,  MOD_NN,  DO(copy_numbers),           DO(copy_names) },\n  { \"copy_matched_subject\",        MOD_DAT,  MOD_OPT, PCRE2_COPY_MATCHED_SUBJECT, DO(options) },\n  { \"debug\",                       MOD_PAT,  MOD_CTL, CTL_DEBUG,                  PO(control) },\n  { \"depth_limit\",                 MOD_CTM,  MOD_INT, 0,                          MO(depth_limit) },\n  { \"dfa\",                         MOD_DAT,  MOD_CTL, CTL_DFA,                    DO(control) },\n  { \"dfa_restart\",                 MOD_DAT,  MOD_OPT, PCRE2_DFA_RESTART,          DO(options) },\n  { \"dfa_shortest\",                MOD_DAT,  MOD_OPT, PCRE2_DFA_SHORTEST,         DO(options) },\n  { \"dollar_endonly\",              MOD_PAT,  MOD_OPT, PCRE2_DOLLAR_ENDONLY,       PO(options) },\n  { \"dotall\",                      MOD_PATP, MOD_OPT, PCRE2_DOTALL,               PO(options) },\n  { \"dupnames\",                    MOD_PATP, MOD_OPT, PCRE2_DUPNAMES,             PO(options) },\n  { \"endanchored\",                 MOD_PD,   MOD_OPT, PCRE2_ENDANCHORED,          PD(options) },\n  { \"escaped_cr_is_lf\",            MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ESCAPED_CR_IS_LF, CO(extra_options) },\n  { \"expand\",                      MOD_PAT,  MOD_CTL, CTL_EXPAND,                 PO(control) },\n  { \"extended\",                    MOD_PATP, MOD_OPT, PCRE2_EXTENDED,             PO(options) },\n  { \"extended_more\",               MOD_PATP, MOD_OPT, PCRE2_EXTENDED_MORE,        PO(options) },\n  { \"extra_alt_bsux\",              MOD_CTC,  MOD_OPT, PCRE2_EXTRA_ALT_BSUX,       CO(extra_options) },\n  { \"find_limits\",                 MOD_DAT,  MOD_CTL, CTL_FINDLIMITS,             DO(control) },\n  { \"find_limits_noheap\",          MOD_DAT,  MOD_CTL, CTL_FINDLIMITS_NOHEAP,      DO(control) },\n  { \"firstline\",                   MOD_PAT,  MOD_OPT, PCRE2_FIRSTLINE,            PO(options) },\n  { \"framesize\",                   MOD_PAT,  MOD_CTL, CTL2_FRAMESIZE,             PO(control2) },\n  { \"fullbincode\",                 MOD_PAT,  MOD_CTL, CTL_FULLBINCODE,            PO(control) },\n  { \"get\",                         MOD_DAT,  MOD_NN,  DO(get_numbers),            DO(get_names) },\n  { \"getall\",                      MOD_DAT,  MOD_CTL, CTL_GETALL,                 DO(control) },\n  { \"global\",                      MOD_PNDP, MOD_CTL, CTL_GLOBAL,                 PO(control) },\n  { \"heap_limit\",                  MOD_CTM,  MOD_INT, 0,                          MO(heap_limit) },\n  { \"hex\",                         MOD_PAT,  MOD_CTL, CTL_HEXPAT,                 PO(control) },\n  { \"info\",                        MOD_PAT,  MOD_CTL, CTL_INFO,                   PO(control) },\n  { \"jit\",                         MOD_PAT,  MOD_IND, 7,                          PO(jit) },\n  { \"jitfast\",                     MOD_PAT,  MOD_CTL, CTL_JITFAST,                PO(control) },\n  { \"jitstack\",                    MOD_PNDP, MOD_INT, 0,                          PO(jitstack) },\n  { \"jitverify\",                   MOD_PAT,  MOD_CTL, CTL_JITVERIFY,              PO(control) },\n  { \"literal\",                     MOD_PAT,  MOD_OPT, PCRE2_LITERAL,              PO(options) },\n  { \"locale\",                      MOD_PAT,  MOD_STR, LOCALESIZE,                 PO(locale) },\n  { \"mark\",                        MOD_PNDP, MOD_CTL, CTL_MARK,                   PO(control) },\n  { \"match_invalid_utf\",           MOD_PAT,  MOD_OPT, PCRE2_MATCH_INVALID_UTF,    PO(options) },\n  { \"match_limit\",                 MOD_CTM,  MOD_INT, 0,                          MO(match_limit) },\n  { \"match_line\",                  MOD_CTC,  MOD_OPT, PCRE2_EXTRA_MATCH_LINE,     CO(extra_options) },\n  { \"match_unset_backref\",         MOD_PAT,  MOD_OPT, PCRE2_MATCH_UNSET_BACKREF,  PO(options) },\n  { \"match_word\",                  MOD_CTC,  MOD_OPT, PCRE2_EXTRA_MATCH_WORD,     CO(extra_options) },\n  { \"max_pattern_length\",          MOD_CTC,  MOD_SIZ, 0,                          CO(max_pattern_length) },\n  { \"memory\",                      MOD_PD,   MOD_CTL, CTL_MEMORY,                 PD(control) },\n  { \"multiline\",                   MOD_PATP, MOD_OPT, PCRE2_MULTILINE,            PO(options) },\n  { \"never_backslash_c\",           MOD_PAT,  MOD_OPT, PCRE2_NEVER_BACKSLASH_C,    PO(options) },\n  { \"never_ucp\",                   MOD_PAT,  MOD_OPT, PCRE2_NEVER_UCP,            PO(options) },\n  { \"never_utf\",                   MOD_PAT,  MOD_OPT, PCRE2_NEVER_UTF,            PO(options) },\n  { \"newline\",                     MOD_CTC,  MOD_NL,  0,                          CO(newline_convention) },\n  { \"no_auto_capture\",             MOD_PAT,  MOD_OPT, PCRE2_NO_AUTO_CAPTURE,      PO(options) },\n  { \"no_auto_possess\",             MOD_PATP, MOD_OPT, PCRE2_NO_AUTO_POSSESS,      PO(options) },\n  { \"no_dotstar_anchor\",           MOD_PAT,  MOD_OPT, PCRE2_NO_DOTSTAR_ANCHOR,    PO(options) },\n  { \"no_jit\",                      MOD_DATP, MOD_OPT, PCRE2_NO_JIT,               DO(options) },\n  { \"no_start_optimize\",           MOD_PATP, MOD_OPT, PCRE2_NO_START_OPTIMIZE,    PO(options) },\n  { \"no_utf_check\",                MOD_PD,   MOD_OPT, PCRE2_NO_UTF_CHECK,         PD(options) },\n  { \"notbol\",                      MOD_DAT,  MOD_OPT, PCRE2_NOTBOL,               DO(options) },\n  { \"notempty\",                    MOD_DAT,  MOD_OPT, PCRE2_NOTEMPTY,             DO(options) },\n  { \"notempty_atstart\",            MOD_DAT,  MOD_OPT, PCRE2_NOTEMPTY_ATSTART,     DO(options) },\n  { \"noteol\",                      MOD_DAT,  MOD_OPT, PCRE2_NOTEOL,               DO(options) },\n  { \"null_context\",                MOD_PD,   MOD_CTL, CTL_NULLCONTEXT,            PO(control) },\n  { \"null_replacement\",            MOD_DAT,  MOD_CTL, CTL2_NULL_REPLACEMENT,      DO(control2) },\n  { \"null_subject\",                MOD_DAT,  MOD_CTL, CTL2_NULL_SUBJECT,          DO(control2) },\n  { \"offset\",                      MOD_DAT,  MOD_INT, 0,                          DO(offset) },\n  { \"offset_limit\",                MOD_CTM,  MOD_SIZ, 0,                          MO(offset_limit)},\n  { \"ovector\",                     MOD_DAT,  MOD_INT, 0,                          DO(oveccount) },\n  { \"parens_nest_limit\",           MOD_CTC,  MOD_INT, 0,                          CO(parens_nest_limit) },\n  { \"partial_hard\",                MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_HARD,         DO(options) },\n  { \"partial_soft\",                MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_SOFT,         DO(options) },\n  { \"ph\",                          MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_HARD,         DO(options) },\n  { \"posix\",                       MOD_PAT,  MOD_CTL, CTL_POSIX,                  PO(control) },\n  { \"posix_nosub\",                 MOD_PAT,  MOD_CTL, CTL_POSIX|CTL_POSIX_NOSUB,  PO(control) },\n  { \"posix_startend\",              MOD_DAT,  MOD_IN2, 0,                          DO(startend) },\n  { \"ps\",                          MOD_DAT,  MOD_OPT, PCRE2_PARTIAL_SOFT,         DO(options) },\n  { \"push\",                        MOD_PAT,  MOD_CTL, CTL_PUSH,                   PO(control) },\n  { \"pushcopy\",                    MOD_PAT,  MOD_CTL, CTL_PUSHCOPY,               PO(control) },\n  { \"pushtablescopy\",              MOD_PAT,  MOD_CTL, CTL_PUSHTABLESCOPY,         PO(control) },\n  { \"recursion_limit\",             MOD_CTM,  MOD_INT, 0,                          MO(depth_limit) },  /* Obsolete synonym */\n  { \"regerror_buffsize\",           MOD_PAT,  MOD_INT, 0,                          PO(regerror_buffsize) },\n  { \"replace\",                     MOD_PND,  MOD_STR, REPLACE_MODSIZE,            PO(replacement) },\n  { \"stackguard\",                  MOD_PAT,  MOD_INT, 0,                          PO(stackguard_test) },\n  { \"startchar\",                   MOD_PND,  MOD_CTL, CTL_STARTCHAR,              PO(control) },\n  { \"startoffset\",                 MOD_DAT,  MOD_INT, 0,                          DO(offset) },\n  { \"subject_literal\",             MOD_PATP, MOD_CTL, CTL2_SUBJECT_LITERAL,       PO(control2) },\n  { \"substitute_callout\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_CALLOUT,    PO(control2) },\n  { \"substitute_extended\",         MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_EXTENDED,   PO(control2) },\n  { \"substitute_literal\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_LITERAL,    PO(control2) },\n  { \"substitute_matched\",          MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_MATCHED,    PO(control2) },\n  { \"substitute_overflow_length\",  MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_OVERFLOW_LENGTH, PO(control2) },\n  { \"substitute_replacement_only\", MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_REPLACEMENT_ONLY, PO(control2) },\n  { \"substitute_skip\",             MOD_PND,  MOD_INT, 0,                          PO(substitute_skip) },\n  { \"substitute_stop\",             MOD_PND,  MOD_INT, 0,                          PO(substitute_stop) },\n  { \"substitute_unknown_unset\",    MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_UNKNOWN_UNSET, PO(control2) },\n  { \"substitute_unset_empty\",      MOD_PND,  MOD_CTL, CTL2_SUBSTITUTE_UNSET_EMPTY, PO(control2) },\n  { \"tables\",                      MOD_PAT,  MOD_INT, 0,                          PO(tables_id) },\n  { \"ucp\",                         MOD_PATP, MOD_OPT, PCRE2_UCP,                  PO(options) },\n  { \"ungreedy\",                    MOD_PAT,  MOD_OPT, PCRE2_UNGREEDY,             PO(options) },\n  { \"use_length\",                  MOD_PAT,  MOD_CTL, CTL_USE_LENGTH,             PO(control) },\n  { \"use_offset_limit\",            MOD_PAT,  MOD_OPT, PCRE2_USE_OFFSET_LIMIT,     PO(options) },\n  { \"utf\",                         MOD_PATP, MOD_OPT, PCRE2_UTF,                  PO(options) },\n  { \"utf8_input\",                  MOD_PAT,  MOD_CTL, CTL_UTF8_INPUT,             PO(control) },\n  { \"zero_terminate\",              MOD_DAT,  MOD_CTL, CTL_ZERO_TERMINATE,         DO(control) }\n};\n\n#define MODLISTCOUNT sizeof(modlist)/sizeof(modstruct)\n\n/* Controls and options that are supported for use with the POSIX interface. */\n\n#define POSIX_SUPPORTED_COMPILE_OPTIONS ( \\\n  PCRE2_CASELESS|PCRE2_DOTALL|PCRE2_LITERAL|PCRE2_MULTILINE|PCRE2_UCP| \\\n  PCRE2_UTF|PCRE2_UNGREEDY)\n\n#define POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS (0)\n\n#define POSIX_SUPPORTED_COMPILE_CONTROLS ( \\\n  CTL_AFTERTEXT|CTL_ALLAFTERTEXT|CTL_EXPAND|CTL_HEXPAT|CTL_POSIX| \\\n  CTL_POSIX_NOSUB|CTL_USE_LENGTH)\n\n#define POSIX_SUPPORTED_COMPILE_CONTROLS2 (0)\n\n#define POSIX_SUPPORTED_MATCH_OPTIONS ( \\\n  PCRE2_NOTBOL|PCRE2_NOTEMPTY|PCRE2_NOTEOL)\n\n#define POSIX_SUPPORTED_MATCH_CONTROLS  (CTL_AFTERTEXT|CTL_ALLAFTERTEXT)\n#define POSIX_SUPPORTED_MATCH_CONTROLS2 (CTL2_NULL_SUBJECT)\n\n/* Control bits that are not ignored with 'push'. */\n\n#define PUSH_SUPPORTED_COMPILE_CONTROLS ( \\\n  CTL_BINCODE|CTL_CALLOUT_INFO|CTL_FULLBINCODE|CTL_HEXPAT|CTL_INFO| \\\n  CTL_JITVERIFY|CTL_MEMORY|CTL_PUSH|CTL_PUSHCOPY| \\\n  CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)\n\n#define PUSH_SUPPORTED_COMPILE_CONTROLS2 (CTL2_BSR_SET|CTL2_FRAMESIZE| \\\n  CTL2_NL_SET)\n\n/* Controls that apply only at compile time with 'push'. */\n\n#define PUSH_COMPILE_ONLY_CONTROLS   CTL_JITVERIFY\n#define PUSH_COMPILE_ONLY_CONTROLS2  (0)\n\n/* Controls that are forbidden with #pop or #popcopy. */\n\n#define NOTPOP_CONTROLS (CTL_HEXPAT|CTL_POSIX|CTL_POSIX_NOSUB|CTL_PUSH| \\\n  CTL_PUSHCOPY|CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)\n\n/* Pattern controls that are mutually exclusive. At present these are all in\nthe first control word. Note that CTL_POSIX_NOSUB is always accompanied by\nCTL_POSIX, so it doesn't need its own entries. */\n\nstatic uint32_t exclusive_pat_controls[] = {\n  CTL_POSIX    | CTL_PUSH,\n  CTL_POSIX    | CTL_PUSHCOPY,\n  CTL_POSIX    | CTL_PUSHTABLESCOPY,\n  CTL_PUSH     | CTL_PUSHCOPY,\n  CTL_PUSH     | CTL_PUSHTABLESCOPY,\n  CTL_PUSHCOPY | CTL_PUSHTABLESCOPY,\n  CTL_EXPAND   | CTL_HEXPAT };\n\n/* Data controls that are mutually exclusive. At present these are all in the\nfirst control word. */\n\nstatic uint32_t exclusive_dat_controls[] = {\n  CTL_ALLUSEDTEXT        | CTL_STARTCHAR,\n  CTL_FINDLIMITS         | CTL_NULLCONTEXT,\n  CTL_FINDLIMITS_NOHEAP  | CTL_NULLCONTEXT };\n\n/* Table of single-character abbreviated modifiers. The index field is\ninitialized to -1, but the first time the modifier is encountered, it is filled\nin with the index of the full entry in modlist, to save repeated searching when\nprocessing multiple test items. This short list is searched serially, so its\norder does not matter. */\n\ntypedef struct c1modstruct {\n  const char *fullname;\n  uint32_t    onechar;\n  int         index;\n} c1modstruct;\n\nstatic c1modstruct c1modlist[] = {\n  { \"bincode\",         'B',           -1 },\n  { \"info\",            'I',           -1 },\n  { \"global\",          'g',           -1 },\n  { \"caseless\",        'i',           -1 },\n  { \"multiline\",       'm',           -1 },\n  { \"no_auto_capture\", 'n',           -1 },\n  { \"dotall\",          's',           -1 },\n  { \"extended\",        'x',           -1 }\n};\n\n#define C1MODLISTCOUNT sizeof(c1modlist)/sizeof(c1modstruct)\n\n/* Table of arguments for the -C command line option. Use macros to make the\ntable itself easier to read. */\n\n#if defined SUPPORT_PCRE2_8\n#define SUPPORT_8 1\n#endif\n#if defined SUPPORT_PCRE2_16\n#define SUPPORT_16 1\n#endif\n#if defined SUPPORT_PCRE2_32\n#define SUPPORT_32 1\n#endif\n\n#ifndef SUPPORT_8\n#define SUPPORT_8 0\n#endif\n#ifndef SUPPORT_16\n#define SUPPORT_16 0\n#endif\n#ifndef SUPPORT_32\n#define SUPPORT_32 0\n#endif\n\n#ifdef EBCDIC\n#define SUPPORT_EBCDIC 1\n#define EBCDIC_NL CHAR_LF\n#else\n#define SUPPORT_EBCDIC 0\n#define EBCDIC_NL 0\n#endif\n\n#ifdef NEVER_BACKSLASH_C\n#define BACKSLASH_C 0\n#else\n#define BACKSLASH_C 1\n#endif\n\ntypedef struct coptstruct {\n  const char *name;\n  uint32_t    type;\n  uint32_t    value;\n} coptstruct;\n\nenum { CONF_BSR,\n       CONF_FIX,\n       CONF_FIZ,\n       CONF_INT,\n       CONF_NL\n};\n\nstatic coptstruct coptlist[] = {\n  { \"backslash-C\", CONF_FIX, BACKSLASH_C },\n  { \"bsr\",         CONF_BSR, PCRE2_CONFIG_BSR },\n  { \"ebcdic\",      CONF_FIX, SUPPORT_EBCDIC },\n  { \"ebcdic-nl\",   CONF_FIZ, EBCDIC_NL },\n  { \"jit\",         CONF_INT, PCRE2_CONFIG_JIT },\n  { \"linksize\",    CONF_INT, PCRE2_CONFIG_LINKSIZE },\n  { \"newline\",     CONF_NL,  PCRE2_CONFIG_NEWLINE },\n  { \"pcre2-16\",    CONF_FIX, SUPPORT_16 },\n  { \"pcre2-32\",    CONF_FIX, SUPPORT_32 },\n  { \"pcre2-8\",     CONF_FIX, SUPPORT_8 },\n  { \"unicode\",     CONF_INT, PCRE2_CONFIG_UNICODE }\n};\n\n#define COPTLISTCOUNT sizeof(coptlist)/sizeof(coptstruct)\n\n#undef SUPPORT_8\n#undef SUPPORT_16\n#undef SUPPORT_32\n#undef SUPPORT_EBCDIC\n\n\n/* ----------------------- Static variables ------------------------ */\n\nstatic FILE *infile;\nstatic FILE *outfile;\n\nstatic const void *last_callout_mark;\nstatic PCRE2_JIT_STACK *jit_stack = NULL;\nstatic size_t jit_stack_size = 0;\n\nstatic BOOL first_callout;\nstatic BOOL jit_was_used;\nstatic BOOL restrict_for_perl_test = FALSE;\nstatic BOOL show_memory = FALSE;\n\nstatic int jitrc;                             /* Return from JIT compile */\nstatic int test_mode = DEFAULT_TEST_MODE;\nstatic int timeit = 0;\nstatic int timeitm = 0;\n\nclock_t total_compile_time = 0;\nclock_t total_jit_compile_time = 0;\nclock_t total_match_time = 0;\n\nstatic uint32_t code_unit_size;               /* Bytes */\nstatic uint32_t dfa_matched;\nstatic uint32_t forbid_utf = 0;\nstatic uint32_t maxlookbehind;\nstatic uint32_t max_oveccount;\nstatic uint32_t callout_count;\nstatic uint32_t maxcapcount;\n\nstatic uint16_t local_newline_default = 0;\n\nstatic VERSION_TYPE jittarget[VERSION_SIZE];\nstatic VERSION_TYPE version[VERSION_SIZE];\nstatic VERSION_TYPE uversion[VERSION_SIZE];\n\nstatic patctl def_patctl;\nstatic patctl pat_patctl;\nstatic datctl def_datctl;\nstatic datctl dat_datctl;\n\nstatic void *patstack[PATSTACKSIZE];\nstatic int patstacknext = 0;\n\nstatic void *malloclist[MALLOCLISTSIZE];\nstatic PCRE2_SIZE malloclistlength[MALLOCLISTSIZE];\nstatic uint32_t malloclistptr = 0;\n\n#ifdef SUPPORT_PCRE2_8\nstatic regex_t preg = { NULL, NULL, 0, 0, 0, 0 };\n#endif\n\nstatic int *dfa_workspace = NULL;\nstatic const uint8_t *locale_tables = NULL;\nstatic const uint8_t *use_tables = NULL;\nstatic uint8_t locale_name[32];\nstatic uint8_t *tables3 = NULL;         /* For binary-loaded tables */\nstatic uint32_t loadtables_length = 0;\n\n/* We need buffers for building 16/32-bit strings; 8-bit strings don't need\nrebuilding, but set up the same naming scheme for use in macros. The \"buffer\"\nbuffer is where all input lines are read. Its size is the same as pbuffer8.\nPattern lines are always copied to pbuffer8 for use in callouts, even if they\nare actually compiled from pbuffer16 or pbuffer32. */\n\nstatic size_t    pbuffer8_size  = 50000;        /* Initial size, bytes */\nstatic uint8_t  *pbuffer8 = NULL;\nstatic uint8_t  *buffer = NULL;\n\n/* The dbuffer is where all processed data lines are put. In non-8-bit modes it\nis cast as needed. For long data lines it grows as necessary. */\n\nstatic size_t dbuffer_size = 1u << 14;    /* Initial size, bytes */\nstatic uint8_t *dbuffer = NULL;\n\n\n/* ---------------- Mode-dependent variables -------------------*/\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_code_8             *compiled_code8;\nstatic pcre2_general_context_8  *general_context8, *general_context_copy8;\nstatic pcre2_compile_context_8  *pat_context8, *default_pat_context8;\nstatic pcre2_convert_context_8  *con_context8, *default_con_context8;\nstatic pcre2_match_context_8    *dat_context8, *default_dat_context8;\nstatic pcre2_match_data_8       *match_data8;\n#endif\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_code_16            *compiled_code16;\nstatic pcre2_general_context_16 *general_context16, *general_context_copy16;\nstatic pcre2_compile_context_16 *pat_context16, *default_pat_context16;\nstatic pcre2_convert_context_16 *con_context16, *default_con_context16;\nstatic pcre2_match_context_16   *dat_context16, *default_dat_context16;\nstatic pcre2_match_data_16      *match_data16;\nstatic PCRE2_SIZE pbuffer16_size = 0;   /* Set only when needed */\nstatic uint16_t *pbuffer16 = NULL;\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_code_32            *compiled_code32;\nstatic pcre2_general_context_32 *general_context32, *general_context_copy32;\nstatic pcre2_compile_context_32 *pat_context32, *default_pat_context32;\nstatic pcre2_convert_context_32 *con_context32, *default_con_context32;\nstatic pcre2_match_context_32   *dat_context32, *default_dat_context32;\nstatic pcre2_match_data_32      *match_data32;\nstatic PCRE2_SIZE pbuffer32_size = 0;   /* Set only when needed */\nstatic uint32_t *pbuffer32 = NULL;\n#endif\n\n\n/* ---------------- Macros that work in all modes ----------------- */\n\n#define CAST8VAR(x) CASTVAR(uint8_t *, x)\n#define SET(x,y) SETOP(x,y,=)\n#define SETPLUS(x,y) SETOP(x,y,+=)\n#define strlen8(x) strlen((char *)x)\n\n\n/* ---------------- Mode-dependent, runtime-testing macros ------------------*/\n\n/* Define macros for variables and functions that must be selected dynamically\ndepending on the mode setting (8, 16, 32). These are dependent on which modes\nare supported. */\n\n#if (defined (SUPPORT_PCRE2_8) + defined (SUPPORT_PCRE2_16) + \\\n     defined (SUPPORT_PCRE2_32)) >= 2\n\n/* ----- All three modes supported ----- */\n\n#if defined(SUPPORT_PCRE2_8) && defined(SUPPORT_PCRE2_16) && defined(SUPPORT_PCRE2_32)\n\n#define CASTFLD(t,a,b) ((test_mode == PCRE8_MODE)? (t)(G(a,8)->b) : \\\n  (test_mode == PCRE16_MODE)? (t)(G(a,16)->b) : (t)(G(a,32)->b))\n\n#define CASTVAR(t,x) ( \\\n  (test_mode == PCRE8_MODE)? (t)G(x,8) : \\\n  (test_mode == PCRE16_MODE)? (t)G(x,16) : (t)G(x,32))\n\n#define CODE_UNIT(a,b) ( \\\n  (test_mode == PCRE8_MODE)? (uint32_t)(((PCRE2_SPTR8)(a))[b]) : \\\n  (test_mode == PCRE16_MODE)? (uint32_t)(((PCRE2_SPTR16)(a))[b]) : \\\n  (uint32_t)(((PCRE2_SPTR32)(a))[b]))\n\n#define CONCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))\n\n#define CONVERT_COPY(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),(char *)b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),(char *)b,(c)*2); \\\n  else if (test_mode == PCRE32_MODE) \\\n    memcpy(G(a,32),(char *)b,(c)*4)\n\n#define DATCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))\n\n#define FLD(a,b) ((test_mode == PCRE8_MODE)? G(a,8)->b : \\\n  (test_mode == PCRE16_MODE)? G(a,16)->b : G(a,32)->b)\n\n#define PATCTXCPY(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16)); \\\n  else memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))\n\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  if (test_mode == PCRE32_MODE) \\\n    lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \\\n  else if (test_mode == PCRE16_MODE) \\\n    lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \\\n  else \\\n    lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n\n#define PCHARSV(p, offset, len, utf, f) \\\n  if (test_mode == PCRE32_MODE) \\\n    (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \\\n  else if (test_mode == PCRE16_MODE) \\\n    (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \\\n  else \\\n    (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n     a = pcre2_callout_enumerate_8(compiled_code8, \\\n       (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n     a = pcre2_callout_enumerate_16(compiled_code16, \\\n       (int(*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c); \\\n  else \\\n     a = pcre2_callout_enumerate_32(compiled_code32, \\\n       (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)\n\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_code_copy_8(b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_code_copy_16(b); \\\n  else \\\n    G(a,32) = pcre2_code_copy_32(b)\n\n#define PCRE2_CODE_COPY_TO_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (void *)pcre2_code_copy_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (void *)pcre2_code_copy_16(G(b,16)); \\\n  else \\\n    a = (void *)pcre2_code_copy_32(G(b,32))\n\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (void *)pcre2_code_copy_with_tables_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (void *)pcre2_code_copy_with_tables_16(G(b,16)); \\\n  else \\\n    a = (void *)pcre2_code_copy_with_tables_32(G(b,32))\n\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g); \\\n  else \\\n    G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)\n\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a); \\\n  else pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)\n\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j); \\\n  else \\\n    a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)\n\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2)); \\\n  else \\\n    r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))\n\n#define PCRE2_GET_OVECTOR_COUNT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_get_ovector_count_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_get_ovector_count_16(G(b,16)); \\\n  else \\\n    a = pcre2_get_ovector_count_32(G(b,32))\n\n#define PCRE2_GET_STARTCHAR(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_get_startchar_8(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_get_startchar_16(G(b,16)); \\\n  else \\\n    a = pcre2_get_startchar_32(G(b,32))\n\n#define PCRE2_JIT_COMPILE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) r = pcre2_jit_compile_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) r = pcre2_jit_compile_16(G(a,16),b); \\\n  else r = pcre2_jit_compile_32(G(a,32),b)\n\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_jit_free_unused_memory_8(G(a,8)); \\\n  else if (test_mode == PCRE16_MODE) pcre2_jit_free_unused_memory_16(G(a,16)); \\\n  else pcre2_jit_free_unused_memory_32(G(a,32))\n\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \\\n  else \\\n    a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d); \\\n  else \\\n    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);\n\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c); \\\n  else \\\n    pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);\n\n#define PCRE2_JIT_STACK_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a); \\\n  else \\\n    pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);\n\n#define PCRE2_MAKETABLES(a,c) \\\n  if (test_mode == PCRE8_MODE) a = pcre2_maketables_8(G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) a = pcre2_maketables_16(G(c,16)); \\\n  else a = pcre2_maketables_32(G(c,32))\n\n#define PCRE2_MAKETABLES_FREE(c,a) \\\n  if (test_mode == PCRE8_MODE) pcre2_maketables_free_8(G(c,8),a); \\\n  else if (test_mode == PCRE16_MODE) pcre2_maketables_free_16(G(c,16),a); \\\n  else pcre2_maketables_free_32(G(c,32),a)\n\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \\\n  else \\\n    a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_match_data_create_8(b,G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_match_data_create_16(b,G(c,16)); \\\n  else \\\n    G(a,32) = pcre2_match_data_create_32(b,G(c,32))\n\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),G(c,16)); \\\n  else \\\n    G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),G(c,32))\n\n#define PCRE2_MATCH_DATA_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_match_data_free_8(G(a,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_match_data_free_16(G(a,16)); \\\n  else \\\n    pcre2_match_data_free_32(G(a,32))\n\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16)); \\\n  else \\\n    a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))\n\n#define PCRE2_PATTERN_INFO(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_pattern_info_8(G(b,8),c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_pattern_info_16(G(b,16),c,d); \\\n  else \\\n    a = pcre2_pattern_info_32(G(b,32),c,d)\n\n#define PCRE2_PRINTINT(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_printint_8(compiled_code8,outfile,a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_printint_16(compiled_code16,outfile,a); \\\n  else \\\n    pcre2_printint_32(compiled_code32,outfile,a)\n\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16)); \\\n  else \\\n    r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))\n\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16)); \\\n  else \\\n    r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))\n\n#define PCRE2_SERIALIZE_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_serialize_free_8(a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_serialize_free_16(a); \\\n  else \\\n    pcre2_serialize_free_32(a)\n\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_serialize_get_number_of_codes_8(a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_serialize_get_number_of_codes_16(a); \\\n  else \\\n    r = pcre2_serialize_get_number_of_codes_32(a); \\\n\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c); \\\n  else \\\n    pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c);\n\n#define PCRE2_SET_CHARACTER_TABLES(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_character_tables_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_character_tables_16(G(a,16),b); \\\n  else \\\n    pcre2_set_character_tables_32(G(a,32),b)\n\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_compile_recursion_guard_8(G(a,8),b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_compile_recursion_guard_16(G(a,16),b,c); \\\n  else \\\n    pcre2_set_compile_recursion_guard_32(G(a,32),b,c)\n\n#define PCRE2_SET_DEPTH_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_depth_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_depth_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_depth_limit_32(G(a,32),b)\n\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_set_glob_separator_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_set_glob_separator_16(G(a,16),b); \\\n  else \\\n    r = pcre2_set_glob_separator_32(G(a,32),b)\n\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    r = pcre2_set_glob_escape_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    r = pcre2_set_glob_escape_16(G(a,16),b); \\\n  else \\\n    r = pcre2_set_glob_escape_32(G(a,32),b)\n\n#define PCRE2_SET_HEAP_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_heap_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_heap_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_heap_limit_32(G(a,32),b)\n\n#define PCRE2_SET_MATCH_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_match_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_match_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_match_limit_32(G(a,32),b)\n\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_max_pattern_length_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_max_pattern_length_16(G(a,16),b); \\\n  else \\\n    pcre2_set_max_pattern_length_32(G(a,32),b)\n\n#define PCRE2_SET_OFFSET_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_offset_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_offset_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_offset_limit_32(G(a,32),b)\n\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_parens_nest_limit_8(G(a,8),b); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_parens_nest_limit_16(G(a,16),b); \\\n  else \\\n    pcre2_set_parens_nest_limit_32(G(a,32),b)\n\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_set_substitute_callout_8(G(a,8), \\\n      (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_set_substitute_callout_16(G(a,16), \\\n      (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c); \\\n  else \\\n    pcre2_set_substitute_callout_32(G(a,32), \\\n      (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)\n\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \\\n      (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \\\n      (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l); \\\n  else \\\n    a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \\\n      (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)\n\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e); \\\n  else \\\n    a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)\n\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e); \\\n  else \\\n    a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e)\n\n#define PCRE2_SUBSTRING_FREE(a) \\\n  if (test_mode == PCRE8_MODE) pcre2_substring_free_8((PCRE2_UCHAR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_substring_free_16((PCRE2_UCHAR16 *)a); \\\n  else pcre2_substring_free_32((PCRE2_UCHAR32 *)a)\n\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e); \\\n  else \\\n    a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)\n\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e); \\\n  else \\\n    a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d); \\\n  else \\\n    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_length_bynumber_8(G(b,8),c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_length_bynumber_16(G(b,16),c,d); \\\n  else \\\n    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)\n\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d); \\\n  else \\\n    a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)\n\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  if (test_mode == PCRE8_MODE) \\\n    pcre2_substring_list_free_8((PCRE2_SPTR8 *)a); \\\n  else if (test_mode == PCRE16_MODE) \\\n    pcre2_substring_list_free_16((PCRE2_SPTR16 *)a); \\\n  else \\\n    pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)\n\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  if (test_mode == PCRE8_MODE) \\\n    a = pcre2_substring_number_from_name_8(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) \\\n    a = pcre2_substring_number_from_name_16(G(b,16),G(c,16)); \\\n  else \\\n    a = pcre2_substring_number_from_name_32(G(b,32),G(c,32))\n\n#define PTR(x) ( \\\n  (test_mode == PCRE8_MODE)? (void *)G(x,8) : \\\n  (test_mode == PCRE16_MODE)? (void *)G(x,16) : \\\n  (void *)G(x,32))\n\n#define SETFLD(x,y,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8)->y = z; \\\n  else if (test_mode == PCRE16_MODE) G(x,16)->y = z; \\\n  else G(x,32)->y = z\n\n#define SETFLDVEC(x,y,v,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8)->y[v] = z; \\\n  else if (test_mode == PCRE16_MODE) G(x,16)->y[v] = z; \\\n  else G(x,32)->y[v] = z\n\n#define SETOP(x,y,z) \\\n  if (test_mode == PCRE8_MODE) G(x,8) z y; \\\n  else if (test_mode == PCRE16_MODE) G(x,16) z y; \\\n  else G(x,32) z y\n\n#define SETCASTPTR(x,y) \\\n  if (test_mode == PCRE8_MODE) \\\n    G(x,8) = (uint8_t *)(y); \\\n  else if (test_mode == PCRE16_MODE) \\\n    G(x,16) = (uint16_t *)(y); \\\n  else \\\n    G(x,32) = (uint32_t *)(y)\n\n#define STRLEN(p) ((test_mode == PCRE8_MODE)? ((int)strlen((char *)p)) : \\\n  (test_mode == PCRE16_MODE)? ((int)strlen16((PCRE2_SPTR16)p)) : \\\n  ((int)strlen32((PCRE2_SPTR32)p)))\n\n#define SUB1(a,b) \\\n  if (test_mode == PCRE8_MODE) G(a,8)(G(b,8)); \\\n  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16)); \\\n  else G(a,32)(G(b,32))\n\n#define SUB2(a,b,c) \\\n  if (test_mode == PCRE8_MODE) G(a,8)(G(b,8),G(c,8)); \\\n  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16),G(c,16)); \\\n  else G(a,32)(G(b,32),G(c,32))\n\n#define TEST(x,r,y) ( \\\n  (test_mode == PCRE8_MODE && G(x,8) r (y)) || \\\n  (test_mode == PCRE16_MODE && G(x,16) r (y)) || \\\n  (test_mode == PCRE32_MODE && G(x,32) r (y)))\n\n#define TESTFLD(x,f,r,y) ( \\\n  (test_mode == PCRE8_MODE && G(x,8)->f r (y)) || \\\n  (test_mode == PCRE16_MODE && G(x,16)->f r (y)) || \\\n  (test_mode == PCRE32_MODE && G(x,32)->f r (y)))\n\n\n/* ----- Two out of three modes are supported ----- */\n\n#else\n\n/* We can use some macro trickery to make a single set of definitions work in\nthe three different cases. */\n\n/* ----- 32-bit and 16-bit but not 8-bit supported ----- */\n\n#if defined(SUPPORT_PCRE2_32) && defined(SUPPORT_PCRE2_16)\n#define BITONE 32\n#define BITTWO 16\n\n/* ----- 32-bit and 8-bit but not 16-bit supported ----- */\n\n#elif defined(SUPPORT_PCRE2_32) && defined(SUPPORT_PCRE2_8)\n#define BITONE 32\n#define BITTWO 8\n\n/* ----- 16-bit and 8-bit but not 32-bit supported ----- */\n\n#else\n#define BITONE 16\n#define BITTWO 8\n#endif\n\n\n/* ----- Common macros for two-mode cases ----- */\n\n#define BYTEONE (BITONE/8)\n#define BYTETWO (BITTWO/8)\n\n#define CASTFLD(t,a,b) \\\n  ((test_mode == G(G(PCRE,BITONE),_MODE))? (t)(G(a,BITONE)->b) : \\\n    (t)(G(a,BITTWO)->b))\n\n#define CASTVAR(t,x) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n    (t)G(x,BITONE) : (t)G(x,BITTWO))\n\n#define CODE_UNIT(a,b) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  (uint32_t)(((G(PCRE2_SPTR,BITONE))(a))[b]) : \\\n  (uint32_t)(((G(PCRE2_SPTR,BITTWO))(a))[b]))\n\n#define CONCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_convert_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_convert_context_,BITTWO)))\n\n#define CONVERT_COPY(a,b,c) \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  memcpy(G(a,BITONE),(char *)b,(c)*BYTEONE) : \\\n  memcpy(G(a,BITTWO),(char *)b,(c)*BYTETWO)\n\n#define DATCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_match_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_match_context_,BITTWO)))\n\n#define FLD(a,b) \\\n  ((test_mode == G(G(PCRE,BITONE),_MODE))? G(a,BITONE)->b : G(a,BITTWO)->b)\n\n#define PATCTXCPY(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_compile_context_,BITONE))); \\\n  else \\\n    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_compile_context_,BITTWO)))\n\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    lv = G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \\\n  else \\\n    lv = G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)\n\n#define PCHARSV(p, offset, len, utf, f) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    (void)G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \\\n  else \\\n    (void)G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)\n\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n     a = G(pcre2_callout_enumerate,BITONE)(G(compiled_code,BITONE), \\\n       (int (*)(struct G(pcre2_callout_enumerate_block_,BITONE) *, void *))b,c); \\\n  else \\\n     a = G(pcre2_callout_enumerate,BITTWO)(G(compiled_code,BITTWO), \\\n       (int (*)(struct G(pcre2_callout_enumerate_block_,BITTWO) *, void *))b,c)\n\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_code_copy_,BITONE)(b); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_code_copy_,BITTWO)(b)\n\n#define PCRE2_CODE_COPY_TO_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (void *)G(pcre2_code_copy_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = (void *)G(pcre2_code_copy_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (void *)G(pcre2_code_copy_with_tables_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = (void *)G(pcre2_code_copy_with_tables_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_compile_,BITONE)(G(b,BITONE),c,d,e,f,g); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_compile_,BITTWO)(G(b,BITTWO),c,d,e,f,g)\n\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_converted_pattern_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \\\n  else \\\n    G(pcre2_converted_pattern_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)\n\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_dfa_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h,i,j); \\\n  else \\\n    a = G(pcre2_dfa_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h,i,j)\n\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_get_error_message_,BITONE)(a,G(b,BITONE),G(G(b,BITONE),_size/BYTEONE)); \\\n  else \\\n    r = G(pcre2_get_error_message_,BITTWO)(a,G(b,BITTWO),G(G(b,BITTWO),_size/BYTETWO))\n\n#define PCRE2_GET_OVECTOR_COUNT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_get_ovector_count_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = G(pcre2_get_ovector_count_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_GET_STARTCHAR(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_get_startchar_,BITONE)(G(b,BITONE)); \\\n  else \\\n    a = G(pcre2_get_startchar_,BITTWO)(G(b,BITTWO))\n\n#define PCRE2_JIT_COMPILE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_jit_compile_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_jit_compile_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_free_unused_memory_,BITONE)(G(a,BITONE)); \\\n  else \\\n    G(pcre2_jit_free_unused_memory_,BITTWO)(G(a,BITTWO))\n\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_jit_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h); \\\n  else \\\n    a = G(pcre2_jit_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h)\n\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITONE)(b,c,d); \\\n  else \\\n    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITTWO)(b,c,d); \\\n\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_stack_assign_,BITONE)(G(a,BITONE),(G(pcre2_jit_callback_,BITONE))b,c); \\\n  else \\\n    G(pcre2_jit_stack_assign_,BITTWO)(G(a,BITTWO),(G(pcre2_jit_callback_,BITTWO))b,c);\n\n#define PCRE2_JIT_STACK_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_jit_stack_free_,BITONE)((G(pcre2_jit_stack_,BITONE) *)a); \\\n  else \\\n    G(pcre2_jit_stack_free_,BITTWO)((G(pcre2_jit_stack_,BITTWO) *)a);\n\n#define PCRE2_MAKETABLES(a,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_maketables_,BITONE)(G(c,BITONE)); \\\n  else \\\n    a = G(pcre2_maketables_,BITTWO)(G(c,BITTWO))\n\n#define PCRE2_MAKETABLES_FREE(c,a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_maketables_free_,BITONE)(G(c,BITONE),a); \\\n  else \\\n    G(pcre2_maketables_free_,BITTWO)(G(c,BITTWO),a)\n\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h); \\\n  else \\\n    a = G(pcre2_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h)\n\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_match_data_create_,BITONE)(b,G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_match_data_create_,BITTWO)(b,G(c,BITTWO))\n\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE) = G(pcre2_match_data_create_from_pattern_,BITONE)(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO) = G(pcre2_match_data_create_from_pattern_,BITTWO)(G(b,BITTWO),G(c,BITTWO))\n\n#define PCRE2_MATCH_DATA_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_match_data_free_,BITONE)(G(a,BITONE)); \\\n  else \\\n    G(pcre2_match_data_free_,BITTWO)(G(a,BITTWO))\n\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_pattern_convert_,BITONE)(G(b,BITONE),c,d,(G(PCRE2_UCHAR,BITONE) **)e,f,G(g,BITONE)); \\\n  else \\\n    a = G(pcre2_pattern_convert_,BITTWO)(G(b,BITTWO),c,d,(G(PCRE2_UCHAR,BITTWO) **)e,f,G(g,BITTWO))\n\n#define PCRE2_PATTERN_INFO(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_pattern_info_,BITONE)(G(b,BITONE),c,d); \\\n  else \\\n    a = G(pcre2_pattern_info_,BITTWO)(G(b,BITTWO),c,d)\n\n#define PCRE2_PRINTINT(a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_printint_,BITONE)(G(compiled_code,BITONE),outfile,a); \\\n  else \\\n    G(pcre2_printint_,BITTWO)(G(compiled_code,BITTWO),outfile,a)\n\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_decode_,BITONE)((G(pcre2_code_,BITONE) **)a,b,c,G(d,BITONE)); \\\n  else \\\n    r = G(pcre2_serialize_decode_,BITTWO)((G(pcre2_code_,BITTWO) **)a,b,c,G(d,BITTWO))\n\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_encode_,BITONE)((G(const pcre2_code_,BITONE) **)a,b,c,d,G(e,BITONE)); \\\n  else \\\n    r = G(pcre2_serialize_encode_,BITTWO)((G(const pcre2_code_,BITTWO) **)a,b,c,d,G(e,BITTWO))\n\n#define PCRE2_SERIALIZE_FREE(a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_serialize_free_,BITONE)(a); \\\n  else \\\n    G(pcre2_serialize_free_,BITTWO)(a)\n\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_serialize_get_number_of_codes_,BITONE)(a); \\\n  else \\\n    r = G(pcre2_serialize_get_number_of_codes_,BITTWO)(a)\n\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_callout_,BITONE)(G(a,BITONE), \\\n      (int (*)(G(pcre2_callout_block_,BITONE) *, void *))b,c); \\\n  else \\\n    G(pcre2_set_callout_,BITTWO)(G(a,BITTWO), \\\n      (int (*)(G(pcre2_callout_block_,BITTWO) *, void *))b,c);\n\n#define PCRE2_SET_CHARACTER_TABLES(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_character_tables_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_character_tables_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_compile_recursion_guard_,BITONE)(G(a,BITONE),b,c); \\\n  else \\\n    G(pcre2_set_compile_recursion_guard_,BITTWO)(G(a,BITTWO),b,c)\n\n#define PCRE2_SET_DEPTH_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_depth_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_depth_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_set_glob_escape_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_set_glob_escape_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    r = G(pcre2_set_glob_separator_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    r = G(pcre2_set_glob_separator_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_HEAP_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_heap_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_heap_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_MATCH_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_match_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_match_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_max_pattern_length_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_max_pattern_length_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_OFFSET_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_offset_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_offset_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_parens_nest_limit_,BITONE)(G(a,BITONE),b); \\\n  else \\\n    G(pcre2_set_parens_nest_limit_,BITTWO)(G(a,BITTWO),b)\n\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_set_substitute_callout_,BITONE)(G(a,BITONE), \\\n      (int (*)(G(pcre2_substitute_callout_block_,BITONE) *, void *))b,c); \\\n  else \\\n    G(pcre2_set_substitute_callout_,BITTWO)(G(a,BITTWO), \\\n      (int (*)(G(pcre2_substitute_callout_block_,BITTWO) *, void *))b,c)\n\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substitute_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \\\n      G(g,BITONE),h,(G(PCRE2_SPTR,BITONE))i,j, \\\n      (G(PCRE2_UCHAR,BITONE) *)k,l); \\\n  else \\\n    a = G(pcre2_substitute_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \\\n      G(g,BITTWO),h,(G(PCRE2_SPTR,BITTWO))i,j, \\\n      (G(PCRE2_UCHAR,BITTWO) *)k,l)\n\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_copy_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\\\n      (G(PCRE2_UCHAR,BITONE) *)d,e); \\\n  else \\\n    a = G(pcre2_substring_copy_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\\\n      (G(PCRE2_UCHAR,BITTWO) *)d,e)\n\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_copy_bynumber_,BITONE)(G(b,BITONE),c,\\\n      (G(PCRE2_UCHAR,BITONE) *)d,e); \\\n  else \\\n    a = G(pcre2_substring_copy_bynumber_,BITTWO)(G(b,BITTWO),c,\\\n      (G(PCRE2_UCHAR,BITTWO) *)d,e)\n\n#define PCRE2_SUBSTRING_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_substring_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \\\n  else G(pcre2_substring_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)\n\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_get_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\\\n      (G(PCRE2_UCHAR,BITONE) **)d,e); \\\n  else \\\n    a = G(pcre2_substring_get_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\\\n      (G(PCRE2_UCHAR,BITTWO) **)d,e)\n\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_get_bynumber_,BITONE)(G(b,BITONE),c,\\\n      (G(PCRE2_UCHAR,BITONE) **)d,e); \\\n  else \\\n    a = G(pcre2_substring_get_bynumber_,BITTWO)(G(b,BITTWO),c,\\\n      (G(PCRE2_UCHAR,BITTWO) **)d,e)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_length_byname_,BITONE)(G(b,BITONE),G(c,BITONE),d); \\\n  else \\\n    a = G(pcre2_substring_length_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),d)\n\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_length_bynumber_,BITONE)(G(b,BITONE),c,d); \\\n  else \\\n    a = G(pcre2_substring_length_bynumber_,BITTWO)(G(b,BITTWO),c,d)\n\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_list_get_,BITONE)(G(b,BITONE), \\\n      (G(PCRE2_UCHAR,BITONE) ***)c,d); \\\n  else \\\n    a = G(pcre2_substring_list_get_,BITTWO)(G(b,BITTWO), \\\n      (G(PCRE2_UCHAR,BITTWO) ***)c,d)\n\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(pcre2_substring_list_free_,BITONE)((G(PCRE2_SPTR,BITONE) *)a); \\\n  else \\\n    G(pcre2_substring_list_free_,BITTWO)((G(PCRE2_SPTR,BITTWO) *)a)\n\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    a = G(pcre2_substring_number_from_name_,BITONE)(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    a = G(pcre2_substring_number_from_name_,BITTWO)(G(b,BITTWO),G(c,BITTWO))\n\n#define PTR(x) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE))? (void *)G(x,BITONE) : \\\n  (void *)G(x,BITTWO))\n\n#define SETFLD(x,y,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)->y = z; \\\n  else G(x,BITTWO)->y = z\n\n#define SETFLDVEC(x,y,v,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)->y[v] = z; \\\n  else G(x,BITTWO)->y[v] = z\n\n#define SETOP(x,y,z) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE) z y; \\\n  else G(x,BITTWO) z y\n\n#define SETCASTPTR(x,y) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(x,BITONE) = (G(G(uint,BITONE),_t) *)(y); \\\n  else \\\n    G(x,BITTWO) = (G(G(uint,BITTWO),_t) *)(y)\n\n#define STRLEN(p) ((test_mode == G(G(PCRE,BITONE),_MODE))? \\\n  G(strlen,BITONE)((G(PCRE2_SPTR,BITONE))p) : \\\n  G(strlen,BITTWO)((G(PCRE2_SPTR,BITTWO))p))\n\n#define SUB1(a,b) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE)(G(b,BITONE)); \\\n  else \\\n    G(a,BITTWO)(G(b,BITTWO))\n\n#define SUB2(a,b,c) \\\n  if (test_mode == G(G(PCRE,BITONE),_MODE)) \\\n    G(a,BITONE))(G(b,BITONE),G(c,BITONE)); \\\n  else \\\n    G(a,BITTWO))(G(b,BITTWO),G(c,BITTWO))\n\n#define TEST(x,r,y) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE) && G(x,BITONE) r (y)) || \\\n  (test_mode == G(G(PCRE,BITTWO),_MODE) && G(x,BITTWO) r (y)))\n\n#define TESTFLD(x,f,r,y) ( \\\n  (test_mode == G(G(PCRE,BITONE),_MODE) && G(x,BITONE)->f r (y)) || \\\n  (test_mode == G(G(PCRE,BITTWO),_MODE) && G(x,BITTWO)->f r (y)))\n\n\n#endif  /* Two out of three modes */\n\n/* ----- End of cases where more than one mode is supported ----- */\n\n\n/* ----- Only 8-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_8\n#define CASTFLD(t,a,b) (t)(G(a,8)->b)\n#define CASTVAR(t,x) (t)G(x,8)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR8)(a))[b])\n#define CONCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,8),(char *)b, c)\n#define DATCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8))\n#define FLD(a,b) G(a,8)->b\n#define PATCTXCPY(a,b) memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_8(compiled_code8, \\\n     (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,8) = pcre2_code_copy_8(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_8(G(b,8))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_8(G(b,8))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_8(G(b,8))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_8(G(b,8))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_8(G(a,8),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_8(G(a,8))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a);\n#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_8(G(c,8))\n#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_8(G(c,8),a)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,8) = pcre2_match_data_create_8(b,G(c,8))\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),G(c,8))\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_8(G(a,8))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_8(G(b,8),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_8(compiled_code8,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_8(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_8(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c)\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_8(G(a,8),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_8(G(a,8),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_8(G(a,8),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_8(G(a,8),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_8(G(a,8),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_8(G(a,8),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_8(G(a,8),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_8(G(a,8),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_8(G(a,8),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_8(G(a,8),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_8(G(a,8), \\\n    (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \\\n    (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e)\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_8((PCRE2_UCHAR8 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_8(G(b,8),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_8((PCRE2_SPTR8 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_8(G(b,8),G(c,8));\n#define PTR(x) (void *)G(x,8)\n#define SETFLD(x,y,z) G(x,8)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,8)->y[v] = z\n#define SETOP(x,y,z) G(x,8) z y\n#define SETCASTPTR(x,y) G(x,8) = (uint8_t *)(y)\n#define STRLEN(p) (int)strlen((char *)p)\n#define SUB1(a,b) G(a,8)(G(b,8))\n#define SUB2(a,b,c) G(a,8)(G(b,8),G(c,8))\n#define TEST(x,r,y) (G(x,8) r (y))\n#define TESTFLD(x,f,r,y) (G(x,8)->f r (y))\n\n\n/* ----- Only 16-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_16\n#define CASTFLD(t,a,b) (t)(G(a,16)->b)\n#define CASTVAR(t,x) (t)G(x,16)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR16)(a))[b])\n#define CONCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,16),(char *)b, (c)*2)\n#define DATCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16))\n#define FLD(a,b) G(a,16)->b\n#define PATCTXCPY(a,b) memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_16(compiled_code16, \\\n     (int (*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,16) = pcre2_code_copy_16(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_16(G(b,16))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_16(G(b,16))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_16(G(b,16))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_16(G(b,16))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_16(G(a,16),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_16(G(a,16))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a);\n#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_16(G(c,16))\n#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_16(G(c,16),a)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,16) = pcre2_match_data_create_16(b,G(c,16))\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),G(c,16))\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_16(G(a,16))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_16(G(b,16),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_16(compiled_code16,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_16(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_16(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c);\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_16(G(a,16),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_16(G(a,16),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_16(G(a,16),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_16(G(a,16),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_16(G(a,16),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_16(G(a,16),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_16(G(a,16),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_16(G(a,16),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_16(G(a,16),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_16(G(a,16),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_16(G(a,16), \\\n    (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \\\n    (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e)\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_16((PCRE2_UCHAR16 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_16(G(b,16),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_16((PCRE2_SPTR16 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_16(G(b,16),G(c,16));\n#define PTR(x) (void *)G(x,16)\n#define SETFLD(x,y,z) G(x,16)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,16)->y[v] = z\n#define SETOP(x,y,z) G(x,16) z y\n#define SETCASTPTR(x,y) G(x,16) = (uint16_t *)(y)\n#define STRLEN(p) (int)strlen16((PCRE2_SPTR16)p)\n#define SUB1(a,b) G(a,16)(G(b,16))\n#define SUB2(a,b,c) G(a,16)(G(b,16),G(c,16))\n#define TEST(x,r,y) (G(x,16) r (y))\n#define TESTFLD(x,f,r,y) (G(x,16)->f r (y))\n\n\n/* ----- Only 32-bit mode is supported ----- */\n\n#elif defined SUPPORT_PCRE2_32\n#define CASTFLD(t,a,b) (t)(G(a,32)->b)\n#define CASTVAR(t,x) (t)G(x,32)\n#define CODE_UNIT(a,b) (uint32_t)(((PCRE2_SPTR32)(a))[b])\n#define CONCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))\n#define CONVERT_COPY(a,b,c) memcpy(G(a,32),(char *)b, (c)*4)\n#define DATCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))\n#define FLD(a,b) G(a,32)->b\n#define PATCTXCPY(a,b) memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))\n#define PCHARS(lv, p, offset, len, utf, f) \\\n  lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)\n#define PCHARSV(p, offset, len, utf, f) \\\n  (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)\n#define PCRE2_CALLOUT_ENUMERATE(a,b,c) \\\n   a = pcre2_callout_enumerate_32(compiled_code32, \\\n     (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)\n#define PCRE2_CODE_COPY_FROM_VOID(a,b) G(a,32) = pcre2_code_copy_32(b)\n#define PCRE2_CODE_COPY_TO_VOID(a,b) a = (void *)pcre2_code_copy_32(G(b,32))\n#define PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(a,b) a = (void *)pcre2_code_copy_with_tables_32(G(b,32))\n#define PCRE2_COMPILE(a,b,c,d,e,f,g) \\\n  G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)\n#define PCRE2_CONVERTED_PATTERN_FREE(a) \\\n  pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)\n#define PCRE2_DFA_MATCH(a,b,c,d,e,f,g,h,i,j) \\\n  a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)\n#define PCRE2_GET_ERROR_MESSAGE(r,a,b) \\\n  r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))\n#define PCRE2_GET_OVECTOR_COUNT(a,b) a = pcre2_get_ovector_count_32(G(b,32))\n#define PCRE2_GET_STARTCHAR(a,b) a = pcre2_get_startchar_32(G(b,32))\n#define PCRE2_JIT_COMPILE(r,a,b) r = pcre2_jit_compile_32(G(a,32),b)\n#define PCRE2_JIT_FREE_UNUSED_MEMORY(a) pcre2_jit_free_unused_memory_32(G(a,32))\n#define PCRE2_JIT_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n#define PCRE2_JIT_STACK_CREATE(a,b,c,d) \\\n  a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);\n#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \\\n  pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);\n#define PCRE2_JIT_STACK_FREE(a) pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);\n#define PCRE2_MAKETABLES(a,c) a = pcre2_maketables_32(G(c,32))\n#define PCRE2_MAKETABLES_FREE(c,a) pcre2_maketables_free_32(G(c,32),a)\n#define PCRE2_MATCH(a,b,c,d,e,f,g,h) \\\n  a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)\n#define PCRE2_MATCH_DATA_CREATE(a,b,c) G(a,32) = pcre2_match_data_create_32(b,G(c,32))\n#define PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(a,b,c) \\\n  G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),G(c,32))\n#define PCRE2_MATCH_DATA_FREE(a) pcre2_match_data_free_32(G(a,32))\n#define PCRE2_PATTERN_CONVERT(a,b,c,d,e,f,g) a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))\n#define PCRE2_PATTERN_INFO(a,b,c,d) a = pcre2_pattern_info_32(G(b,32),c,d)\n#define PCRE2_PRINTINT(a) pcre2_printint_32(compiled_code32,outfile,a)\n#define PCRE2_SERIALIZE_DECODE(r,a,b,c,d) \\\n  r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))\n#define PCRE2_SERIALIZE_ENCODE(r,a,b,c,d,e) \\\n  r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))\n#define PCRE2_SERIALIZE_FREE(a) pcre2_serialize_free_32(a)\n#define PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(r,a) \\\n  r = pcre2_serialize_get_number_of_codes_32(a)\n#define PCRE2_SET_CALLOUT(a,b,c) \\\n  pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c)\n#define PCRE2_SET_CHARACTER_TABLES(a,b) pcre2_set_character_tables_32(G(a,32),b)\n#define PCRE2_SET_COMPILE_RECURSION_GUARD(a,b,c) \\\n  pcre2_set_compile_recursion_guard_32(G(a,32),b,c)\n#define PCRE2_SET_DEPTH_LIMIT(a,b) pcre2_set_depth_limit_32(G(a,32),b)\n#define PCRE2_SET_GLOB_ESCAPE(r,a,b) r = pcre2_set_glob_escape_32(G(a,32),b)\n#define PCRE2_SET_GLOB_SEPARATOR(r,a,b) r = pcre2_set_glob_separator_32(G(a,32),b)\n#define PCRE2_SET_HEAP_LIMIT(a,b) pcre2_set_heap_limit_32(G(a,32),b)\n#define PCRE2_SET_MATCH_LIMIT(a,b) pcre2_set_match_limit_32(G(a,32),b)\n#define PCRE2_SET_MAX_PATTERN_LENGTH(a,b) pcre2_set_max_pattern_length_32(G(a,32),b)\n#define PCRE2_SET_OFFSET_LIMIT(a,b) pcre2_set_offset_limit_32(G(a,32),b)\n#define PCRE2_SET_PARENS_NEST_LIMIT(a,b) pcre2_set_parens_nest_limit_32(G(a,32),b)\n#define PCRE2_SET_SUBSTITUTE_CALLOUT(a,b,c) \\\n  pcre2_set_substitute_callout_32(G(a,32), \\\n    (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)\n#define PCRE2_SUBSTITUTE(a,b,c,d,e,f,g,h,i,j,k,l) \\\n  a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \\\n    (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)\n#define PCRE2_SUBSTRING_COPY_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)\n#define PCRE2_SUBSTRING_COPY_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e);\n#define PCRE2_SUBSTRING_FREE(a) pcre2_substring_free_32((PCRE2_UCHAR32 *)a)\n#define PCRE2_SUBSTRING_GET_BYNAME(a,b,c,d,e) \\\n  a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)\n#define PCRE2_SUBSTRING_GET_BYNUMBER(a,b,c,d,e) \\\n  a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)\n#define PCRE2_SUBSTRING_LENGTH_BYNAME(a,b,c,d) \\\n    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)\n#define PCRE2_SUBSTRING_LENGTH_BYNUMBER(a,b,c,d) \\\n    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)\n#define PCRE2_SUBSTRING_LIST_GET(a,b,c,d) \\\n  a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)\n#define PCRE2_SUBSTRING_LIST_FREE(a) \\\n  pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)\n#define PCRE2_SUBSTRING_NUMBER_FROM_NAME(a,b,c) \\\n  a = pcre2_substring_number_from_name_32(G(b,32),G(c,32));\n#define PTR(x) (void *)G(x,32)\n#define SETFLD(x,y,z) G(x,32)->y = z\n#define SETFLDVEC(x,y,v,z) G(x,32)->y[v] = z\n#define SETOP(x,y,z) G(x,32) z y\n#define SETCASTPTR(x,y) G(x,32) = (uint32_t *)(y)\n#define STRLEN(p) (int)strlen32((PCRE2_SPTR32)p)\n#define SUB1(a,b) G(a,32)(G(b,32))\n#define SUB2(a,b,c) G(a,32)(G(b,32),G(c,32))\n#define TEST(x,r,y) (G(x,32) r (y))\n#define TESTFLD(x,f,r,y) (G(x,32)->f r (y))\n\n#endif\n\n/* ----- End of mode-specific function call macros ----- */\n\n\n\n\n/*************************************************\n*         Alternate character tables             *\n*************************************************/\n\n/* By default, the \"tables\" pointer in the compile context when calling\npcre2_compile() is not set (= NULL), thereby using the default tables of the\nlibrary. However, the tables modifier can be used to select alternate sets of\ntables, for different kinds of testing. Note that the locale modifier also\nadjusts the tables. */\n\n/* This is the set of tables distributed as default with PCRE2. It recognizes\nonly ASCII characters. */\n\nstatic const uint8_t tables1[] = {\n\n/* This table is a lower casing table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122, 91, 92, 93, 94, 95,\n   96, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,\n  200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,\n  216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,\n  232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table is a case flipping table. */\n\n    0,  1,  2,  3,  4,  5,  6,  7,\n    8,  9, 10, 11, 12, 13, 14, 15,\n   16, 17, 18, 19, 20, 21, 22, 23,\n   24, 25, 26, 27, 28, 29, 30, 31,\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63,\n   64, 97, 98, 99,100,101,102,103,\n  104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,\n  120,121,122, 91, 92, 93, 94, 95,\n   96, 65, 66, 67, 68, 69, 70, 71,\n   72, 73, 74, 75, 76, 77, 78, 79,\n   80, 81, 82, 83, 84, 85, 86, 87,\n   88, 89, 90,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,\n  136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,\n  152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,\n  168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,\n  184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,\n  200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,\n  216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,\n  232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,\n  248,249,250,251,252,253,254,255,\n\n/* This table contains bit maps for various character classes. Each map is 32\nbytes long and the bits run from the least significant end of each byte. The\nclasses that have their own maps are: space, xdigit, digit, upper, lower, word,\ngraph, print, punct, and cntrl. Other classes are built from combinations. */\n\n  0x00,0x3e,0x00,0x00,0x01,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0x7e,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0xfe,0xff,0xff,0x07,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x07,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,\n  0xfe,0xff,0xff,0x87,0xfe,0xff,0xff,0x07,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,\n  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0x00,0x00,0x00,0x00,0xfe,0xff,0x00,0xfc,\n  0x01,0x00,0x00,0xf8,0x01,0x00,0x00,0x78,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n  0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\n/* This table identifies various classes of character by individual bits:\n  0x01   white space character\n  0x02   letter\n  0x04   decimal digit\n  0x08   hexadecimal digit\n  0x10   alphanumeric or '_'\n  0x80   regular expression metacharacter or binary zero\n*/\n\n  0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*   0-  7 */\n  0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00, /*   8- 15 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  16- 23 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  24- 31 */\n  0x01,0x00,0x00,0x00,0x80,0x00,0x00,0x00, /*    - '  */\n  0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x00, /*  ( - /  */\n  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c, /*  0 - 7  */\n  0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x80, /*  8 - ?  */\n  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  @ - G  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  H - O  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  P - W  */\n  0x12,0x12,0x12,0x80,0x80,0x00,0x80,0x10, /*  X - _  */\n  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  ` - g  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  h - o  */\n  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  p - w  */\n  0x12,0x12,0x12,0x80,0x80,0x00,0x00,0x00, /*  x -127 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 128-135 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 136-143 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 144-151 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 152-159 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 160-167 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 168-175 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 176-183 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 184-191 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 192-199 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 200-207 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 208-215 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 216-223 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 224-231 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 232-239 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 240-247 */\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/* 248-255 */\n\n/* This is a set of tables that came originally from a Windows user. It seems\nto be at least an approximation of ISO 8859. In particular, there are\ncharacters greater than 128 that are marked as spaces, letters, etc. */\n\nstatic const uint8_t tables2[] = {\n0,1,2,3,4,5,6,7,\n8,9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,25,26,27,28,29,30,31,\n32,33,34,35,36,37,38,39,\n40,41,42,43,44,45,46,47,\n48,49,50,51,52,53,54,55,\n56,57,58,59,60,61,62,63,\n64,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,91,92,93,94,95,\n96,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,123,124,125,126,127,\n128,129,130,131,132,133,134,135,\n136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,\n152,153,154,155,156,157,158,159,\n160,161,162,163,164,165,166,167,\n168,169,170,171,172,173,174,175,\n176,177,178,179,180,181,182,183,\n184,185,186,187,188,189,190,191,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,215,\n248,249,250,251,252,253,254,223,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,247,\n248,249,250,251,252,253,254,255,\n0,1,2,3,4,5,6,7,\n8,9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,25,26,27,28,29,30,31,\n32,33,34,35,36,37,38,39,\n40,41,42,43,44,45,46,47,\n48,49,50,51,52,53,54,55,\n56,57,58,59,60,61,62,63,\n64,97,98,99,100,101,102,103,\n104,105,106,107,108,109,110,111,\n112,113,114,115,116,117,118,119,\n120,121,122,91,92,93,94,95,\n96,65,66,67,68,69,70,71,\n72,73,74,75,76,77,78,79,\n80,81,82,83,84,85,86,87,\n88,89,90,123,124,125,126,127,\n128,129,130,131,132,133,134,135,\n136,137,138,139,140,141,142,143,\n144,145,146,147,148,149,150,151,\n152,153,154,155,156,157,158,159,\n160,161,162,163,164,165,166,167,\n168,169,170,171,172,173,174,175,\n176,177,178,179,180,181,182,183,\n184,185,186,187,188,189,190,191,\n224,225,226,227,228,229,230,231,\n232,233,234,235,236,237,238,239,\n240,241,242,243,244,245,246,215,\n248,249,250,251,252,253,254,223,\n192,193,194,195,196,197,198,199,\n200,201,202,203,204,205,206,207,\n208,209,210,211,212,213,214,247,\n216,217,218,219,220,221,222,255,\n0,62,0,0,1,0,0,0,\n0,0,0,0,0,0,0,0,\n32,0,0,0,1,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,255,3,\n126,0,0,0,126,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,255,3,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,12,2,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n254,255,255,7,0,0,0,0,\n0,0,0,0,0,0,0,0,\n255,255,127,127,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,254,255,255,7,\n0,0,0,0,0,4,32,4,\n0,0,0,128,255,255,127,255,\n0,0,0,0,0,0,255,3,\n254,255,255,135,254,255,255,7,\n0,0,0,0,0,4,44,6,\n255,255,127,255,255,255,127,255,\n0,0,0,0,254,255,255,255,\n255,255,255,255,255,255,255,127,\n0,0,0,0,254,255,255,255,\n255,255,255,255,255,255,255,255,\n0,2,0,0,255,255,255,255,\n255,255,255,255,255,255,255,127,\n0,0,0,0,255,255,255,255,\n255,255,255,255,255,255,255,255,\n0,0,0,0,254,255,0,252,\n1,0,0,248,1,0,0,120,\n0,0,0,0,254,255,255,255,\n0,0,128,0,0,0,128,0,\n255,255,255,255,0,0,0,0,\n0,0,0,0,0,0,0,128,\n255,255,255,255,0,0,0,0,\n0,0,0,0,0,0,0,0,\n128,0,0,0,0,0,0,0,\n0,1,1,0,1,1,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n1,0,0,0,128,0,0,0,\n128,128,128,128,0,0,128,0,\n28,28,28,28,28,28,28,28,\n28,28,0,0,0,0,0,128,\n0,26,26,26,26,26,26,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,128,128,0,128,16,\n0,26,26,26,26,26,26,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,128,128,0,0,0,\n0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,\n1,0,0,0,0,0,0,0,\n0,0,18,0,0,0,0,0,\n0,0,20,20,0,18,0,0,\n0,20,18,0,0,0,0,0,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,0,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,18,\n18,18,18,18,18,18,18,0,\n18,18,18,18,18,18,18,18\n};\n\n\n\n#if !defined(VPCOMPAT) && !defined(HAVE_MEMMOVE)\n/*************************************************\n*    Emulated memmove() for systems without it   *\n*************************************************/\n\n/* This function can make use of bcopy() if it is available. Otherwise do it by\nsteam, as there are some non-Unix environments that lack both memmove() and\nbcopy(). */\n\nstatic void *\nemulated_memmove(void *d, const void *s, size_t n)\n{\n#ifdef HAVE_BCOPY\nbcopy(s, d, n);\nreturn d;\n#else\nsize_t i;\nunsigned char *dest = (unsigned char *)d;\nconst unsigned char *src = (const unsigned char *)s;\nif (dest > src)\n  {\n  dest += n;\n  src += n;\n  for (i = 0; i < n; ++i) *(--dest) = *(--src);\n  return (void *)dest;\n  }\nelse\n  {\n  for (i = 0; i < n; ++i) *dest++ = *src++;\n  return (void *)(dest - n);\n  }\n#endif   /* not HAVE_BCOPY */\n}\n#undef memmove\n#define memmove(d,s,n) emulated_memmove(d,s,n)\n#endif   /* not VPCOMPAT && not HAVE_MEMMOVE */\n\n\n\n#ifndef HAVE_STRERROR\n/*************************************************\n*     Provide strerror() for non-ANSI libraries  *\n*************************************************/\n\n/* Some old-fashioned systems (e.g. SunOS4) didn't have strerror() in their\nlibraries. They may no longer be around, but just in case, we can try to\nprovide the same facility by this simple alternative function. */\n\nextern int   sys_nerr;\nextern char *sys_errlist[];\n\nchar *\nstrerror(int n)\n{\nif (n < 0 || n >= sys_nerr) return \"unknown error number\";\nreturn sys_errlist[n];\n}\n#endif /* HAVE_STRERROR */\n\n\n\n/*************************************************\n*            Local memory functions              *\n*************************************************/\n\n/* Alternative memory functions, to test functionality. */\n\nstatic void *my_malloc(PCRE2_SIZE size, void *data)\n{\nvoid *block = malloc(size);\n(void)data;\nif (show_memory)\n  {\n  if (block == NULL)\n    {\n    fprintf(outfile, \"** malloc() failed for %\" SIZ_FORM \"\\n\", size);\n    }\n  else\n    {\n    fprintf(outfile, \"malloc  %5\" SIZ_FORM, size);\n#ifdef DEBUG_SHOW_MALLOC_ADDRESSES\n    fprintf(outfile, \" %p\", block);   /* Not portable */\n#endif\n    if (malloclistptr < MALLOCLISTSIZE)\n      {\n      malloclist[malloclistptr] = block;\n      malloclistlength[malloclistptr++] = size;\n      }\n    else\n      fprintf(outfile, \" (not remembered)\");\n    fprintf(outfile, \"\\n\");\n    }\n  }\nreturn block;\n}\n\nstatic void my_free(void *block, void *data)\n{\n(void)data;\nif (show_memory && block != NULL)\n  {\n  uint32_t i, j;\n  BOOL found = FALSE;\n\n  fprintf(outfile, \"free\");\n  for (i = 0; i < malloclistptr; i++)\n    {\n    if (block == malloclist[i])\n      {\n      fprintf(outfile, \"    %5\" SIZ_FORM, malloclistlength[i]);\n      malloclistptr--;\n      for (j = i; j < malloclistptr; j++)\n        {\n        malloclist[j] = malloclist[j+1];\n        malloclistlength[j] = malloclistlength[j+1];\n        }\n      found = TRUE;\n      break;\n      }\n    }\n  if (!found) fprintf(outfile, \" unremembered block\");\n#ifdef DEBUG_SHOW_MALLOC_ADDRESSES\n  fprintf(outfile, \" %p\", block);  /* Not portable */\n#endif\n  fprintf(outfile, \"\\n\");\n  }\nfree(block);\n}\n\n\n\n/*************************************************\n*       Callback function for stack guard        *\n*************************************************/\n\n/* This is set up to be called from pcre2_compile() when the stackguard=n\nmodifier sets a value greater than zero. The test we do is whether the\nparenthesis nesting depth is greater than the value set by the modifier.\n\nArgument:  the current parenthesis nesting depth\nReturns:   non-zero to kill the compilation\n*/\n\nstatic int\nstack_guard(uint32_t depth, void *user_data)\n{\n(void)user_data;\nreturn depth > pat_patctl.stackguard_test;\n}\n\n\n/*************************************************\n*         JIT memory callback                    *\n*************************************************/\n\nstatic PCRE2_JIT_STACK*\njit_callback(void *arg)\n{\njit_was_used = TRUE;\nreturn (PCRE2_JIT_STACK *)arg;\n}\n\n\n/*************************************************\n*      Convert UTF-8 character to code point     *\n*************************************************/\n\n/* This function reads one or more bytes that represent a UTF-8 character,\nand returns the codepoint of that character. Note that the function supports\nthe original UTF-8 definition of RFC 2279, allowing for values in the range 0\nto 0x7fffffff, up to 6 bytes long. This makes it possible to generate\ncodepoints greater than 0x10ffff which are useful for testing PCRE2's error\nchecking, and also for generating 32-bit non-UTF data values above the UTF\nlimit.\n\nArgument:\n  utf8bytes   a pointer to the byte vector\n  vptr        a pointer to an int to receive the value\n\nReturns:      >  0 => the number of bytes consumed\n              -6 to 0 => malformed UTF-8 character at offset = (-return)\n*/\n\nstatic int\nutf82ord(PCRE2_SPTR8 utf8bytes, uint32_t *vptr)\n{\nuint32_t c = *utf8bytes++;\nuint32_t d = c;\nint i, j, s;\n\nfor (i = -1; i < 6; i++)               /* i is number of additional bytes */\n  {\n  if ((d & 0x80) == 0) break;\n  d <<= 1;\n  }\n\nif (i == -1) { *vptr = c; return 1; }  /* ascii character */\nif (i == 0 || i == 6) return 0;        /* invalid UTF-8 */\n\n/* i now has a value in the range 1-5 */\n\ns = 6*i;\nd = (c & utf8_table3[i]) << s;\n\nfor (j = 0; j < i; j++)\n  {\n  c = *utf8bytes++;\n  if ((c & 0xc0) != 0x80) return -(j+1);\n  s -= 6;\n  d |= (c & 0x3f) << s;\n  }\n\n/* Check that encoding was the correct unique one */\n\nfor (j = 0; j < utf8_table1_size; j++)\n  if (d <= (uint32_t)utf8_table1[j]) break;\nif (j != i) return -(i+1);\n\n/* Valid value */\n\n*vptr = d;\nreturn i+1;\n}\n\n\n\n/*************************************************\n*             Print one character                *\n*************************************************/\n\n/* Print a single character either literally, or as a hex escape, and count how\nmany printed characters are used.\n\nArguments:\n  c            the character\n  utf          TRUE in UTF mode\n  f            the FILE to print to, or NULL just to count characters\n\nReturns:       number of characters written\n*/\n\nstatic int\npchar(uint32_t c, BOOL utf, FILE *f)\n{\nint n = 0;\nchar tempbuffer[16];\n\nif (PRINTOK(c))\n  {\n  if (f != NULL) fprintf(f, \"%c\", c);\n  return 1;\n  }\n\nif (c < 0x100)\n  {\n  if (utf)\n    {\n    if (f != NULL) fprintf(f, \"\\\\x{%02x}\", c);\n    return 6;\n    }\n  else\n    {\n    if (f != NULL) fprintf(f, \"\\\\x%02x\", c);\n    return 4;\n    }\n  }\n\nif (f != NULL) n = fprintf(f, \"\\\\x{%02x}\", c);\n  else n = sprintf(tempbuffer, \"\\\\x{%02x}\", c);\n\nreturn n >= 0 ? n : 0;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*    Find length of 0-terminated 16-bit string   *\n*************************************************/\n\nstatic size_t strlen16(PCRE2_SPTR16 p)\n{\nPCRE2_SPTR16 pp = p;\nwhile (*pp != 0) pp++;\nreturn (int)(pp - p);\n}\n#endif  /* SUPPORT_PCRE2_16 */\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*    Find length of 0-terminated 32-bit string   *\n*************************************************/\n\nstatic size_t strlen32(PCRE2_SPTR32 p)\n{\nPCRE2_SPTR32 pp = p;\nwhile (*pp != 0) pp++;\nreturn (int)(pp - p);\n}\n#endif  /* SUPPORT_PCRE2_32 */\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*         Print 8-bit character string           *\n*************************************************/\n\n/* Must handle UTF-8 strings in utf8 mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, this function just\ncounts chars without printing (because pchar() does that). */\n\nstatic int pchars8(PCRE2_SPTR8 p, int length, BOOL utf, FILE *f)\n{\nuint32_t c = 0;\nint yield = 0;\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  if (utf)\n    {\n    int rc = utf82ord(p, &c);\n    if (rc > 0 && rc <= length + 1)   /* Mustn't run over the end */\n      {\n      length -= rc - 1;\n      p += rc;\n      yield += pchar(c, utf, f);\n      continue;\n      }\n    }\n  c = *p++;\n  yield += pchar(c, utf, f);\n  }\n\nreturn yield;\n}\n#endif\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*           Print 16-bit character string        *\n*************************************************/\n\n/* Must handle UTF-16 strings in utf mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, just counts chars\nwithout printing. */\n\nstatic int pchars16(PCRE2_SPTR16 p, int length, BOOL utf, FILE *f)\n{\nint yield = 0;\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  uint32_t c = *p++ & 0xffff;\n  if (utf && c >= 0xD800 && c < 0xDC00 && length > 0)\n    {\n    int d = *p & 0xffff;\n    if (d >= 0xDC00 && d <= 0xDFFF)\n      {\n      c = ((c & 0x3ff) << 10) + (d & 0x3ff) + 0x10000;\n      length--;\n      p++;\n      }\n    }\n  yield += pchar(c, utf, f);\n  }\nreturn yield;\n}\n#endif  /* SUPPORT_PCRE2_16 */\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*           Print 32-bit character string        *\n*************************************************/\n\n/* Must handle UTF-32 strings in utf mode. Yields number of characters printed.\nFor printing *MARK strings, a negative length is given, indicating that the\nlength is in the first code unit. If handed a NULL file, just counts chars\nwithout printing. */\n\nstatic int pchars32(PCRE2_SPTR32 p, int length, BOOL utf, FILE *f)\n{\nint yield = 0;\n(void)(utf);  /* Avoid compiler warning */\nif (length < 0) length = *p++;\nwhile (length-- > 0)\n  {\n  uint32_t c = *p++;\n  yield += pchar(c, utf, f);\n  }\nreturn yield;\n}\n#endif  /* SUPPORT_PCRE2_32 */\n\n\n\n\n/*************************************************\n*       Convert character value to UTF-8         *\n*************************************************/\n\n/* This function takes an integer value in the range 0 - 0x7fffffff\nand encodes it as a UTF-8 character in 0 to 6 bytes. It is needed even when the\n8-bit library is not supported, to generate UTF-8 output for non-ASCII\ncharacters.\n\nArguments:\n  cvalue     the character value\n  utf8bytes  pointer to buffer for result - at least 6 bytes long\n\nReturns:     number of characters placed in the buffer\n*/\n\nstatic int\nord2utf8(uint32_t cvalue, uint8_t *utf8bytes)\n{\nint i, j;\nif (cvalue > 0x7fffffffu)\n  return -1;\nfor (i = 0; i < utf8_table1_size; i++)\n  if (cvalue <= (uint32_t)utf8_table1[i]) break;\nutf8bytes += i;\nfor (j = i; j > 0; j--)\n {\n *utf8bytes-- = 0x80 | (cvalue & 0x3f);\n cvalue >>= 6;\n }\n*utf8bytes = utf8_table2[i] | cvalue;\nreturn i + 1;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_16\n/*************************************************\n*           Convert string to 16-bit             *\n*************************************************/\n\n/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using\nthe original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and\ncode values from 0 to 0x7fffffff. However, values greater than the later UTF\nlimit of 0x10ffff cause an error. In non-UTF mode the input is interpreted as\nUTF-8 if the utf8_input modifier is set, but an error is generated for values\ngreater than 0xffff.\n\nIf all the input bytes are ASCII, the space needed for a 16-bit string is\nexactly double the 8-bit size. Otherwise, the size needed for a 16-bit string\nis no more than double, because up to 0xffff uses no more than 3 bytes in UTF-8\nbut possibly 4 in UTF-16. Higher values use 4 bytes in UTF-8 and up to 4 bytes\nin UTF-16. The result is always left in pbuffer16. Impose a minimum size to\nsave repeated re-sizing.\n\nNote that this function does not object to surrogate values. This is\ndeliberate; it makes it possible to construct UTF-16 strings that are invalid,\nfor the purpose of testing that they are correctly faulted.\n\nArguments:\n  p          points to a byte string\n  utf        true in UTF mode\n  lenptr     points to number of bytes in the string (excluding trailing zero)\n\nReturns:     0 on success, with the length updated to the number of 16-bit\n               data items used (excluding the trailing zero)\n             OR -1 if a UTF-8 string is malformed\n             OR -2 if a value > 0x10ffff is encountered in UTF mode\n             OR -3 if a value > 0xffff is encountered when not in UTF mode\n*/\n\nstatic int\nto16(uint8_t *p, int utf, PCRE2_SIZE *lenptr)\n{\nuint16_t *pp;\nPCRE2_SIZE len = *lenptr;\n\nif (pbuffer16_size < 2*len + 2)\n  {\n  if (pbuffer16 != NULL) free(pbuffer16);\n  pbuffer16_size = 2*len + 2;\n  if (pbuffer16_size < 4096) pbuffer16_size = 4096;\n  pbuffer16 = (uint16_t *)malloc(pbuffer16_size);\n  if (pbuffer16 == NULL)\n    {\n    fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer16\\n\",\n      pbuffer16_size);\n    exit(1);\n    }\n  }\n\npp = pbuffer16;\nif (!utf && (pat_patctl.control & CTL_UTF8_INPUT) == 0)\n  {\n  for (; len > 0; len--) *pp++ = *p++;\n  }\nelse while (len > 0)\n  {\n  uint32_t c;\n  int chlen = utf82ord(p, &c);\n  if (chlen <= 0) return -1;\n  if (!utf && c > 0xffff) return -3;\n  if (c > 0x10ffff) return -2;\n  p += chlen;\n  len -= chlen;\n  if (c < 0x10000) *pp++ = c; else\n    {\n    c -= 0x10000;\n    *pp++ = 0xD800 | (c >> 10);\n    *pp++ = 0xDC00 | (c & 0x3ff);\n    }\n  }\n\n*pp = 0;\n*lenptr = pp - pbuffer16;\nreturn 0;\n}\n#endif\n\n\n\n#ifdef SUPPORT_PCRE2_32\n/*************************************************\n*           Convert string to 32-bit             *\n*************************************************/\n\n/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using\nthe original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and\ncode values from 0 to 0x7fffffff. However, values greater than the later UTF\nlimit of 0x10ffff cause an error.\n\nIn non-UTF mode the input is interpreted as UTF-8 if the utf8_input modifier\nis set, and no limit is imposed. There is special interpretation of the 0xff\nbyte (which is illegal in UTF-8) in this case: it causes the top bit of the\nnext character to be set. This provides a way of generating 32-bit characters\ngreater than 0x7fffffff.\n\nIf all the input bytes are ASCII, the space needed for a 32-bit string is\nexactly four times the 8-bit size. Otherwise, the size needed for a 32-bit\nstring is no more than four times, because the number of characters must be\nless than the number of bytes. The result is always left in pbuffer32. Impose a\nminimum size to save repeated re-sizing.\n\nNote that this function does not object to surrogate values. This is\ndeliberate; it makes it possible to construct UTF-32 strings that are invalid,\nfor the purpose of testing that they are correctly faulted.\n\nArguments:\n  p          points to a byte string\n  utf        true in UTF mode\n  lenptr     points to number of bytes in the string (excluding trailing zero)\n\nReturns:     0 on success, with the length updated to the number of 32-bit\n               data items used (excluding the trailing zero)\n             OR -1 if a UTF-8 string is malformed\n             OR -2 if a value > 0x10ffff is encountered in UTF mode\n*/\n\nstatic int\nto32(uint8_t *p, int utf, PCRE2_SIZE *lenptr)\n{\nuint32_t *pp;\nPCRE2_SIZE len = *lenptr;\n\nif (pbuffer32_size < 4*len + 4)\n  {\n  if (pbuffer32 != NULL) free(pbuffer32);\n  pbuffer32_size = 4*len + 4;\n  if (pbuffer32_size < 8192) pbuffer32_size = 8192;\n  pbuffer32 = (uint32_t *)malloc(pbuffer32_size);\n  if (pbuffer32 == NULL)\n    {\n    fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer32\\n\",\n      pbuffer32_size);\n    exit(1);\n    }\n  }\n\npp = pbuffer32;\n\nif (!utf && (pat_patctl.control & CTL_UTF8_INPUT) == 0)\n  {\n  for (; len > 0; len--) *pp++ = *p++;\n  }\n\nelse while (len > 0)\n  {\n  int chlen;\n  uint32_t c;\n  uint32_t topbit = 0;\n  if (!utf && *p == 0xff && len > 1)\n    {\n    topbit = 0x80000000u;\n    p++;\n    len--;\n    }\n  chlen = utf82ord(p, &c);\n  if (chlen <= 0) return -1;\n  if (utf && c > 0x10ffff) return -2;\n  p += chlen;\n  len -= chlen;\n  *pp++ = c | topbit;\n  }\n\n*pp = 0;\n*lenptr = pp - pbuffer32;\nreturn 0;\n}\n#endif /* SUPPORT_PCRE2_32 */\n\n\n\n/* This function is no longer used. Keep it around for a while, just in case it\nneeds to be re-instated. */\n\n#ifdef NEVERNEVERNEVER\n\n/*************************************************\n*         Move back by so many characters        *\n*************************************************/\n\n/* Given a code unit offset in a subject string, move backwards by a number of\ncharacters, and return the resulting offset.\n\nArguments:\n  subject   pointer to the string\n  offset    start offset\n  count     count to move back by\n  utf       TRUE if in UTF mode\n\nReturns:   a possibly changed offset\n*/\n\nstatic PCRE2_SIZE\nbackchars(uint8_t *subject, PCRE2_SIZE offset, uint32_t count, BOOL utf)\n{\nif (!utf || test_mode == PCRE32_MODE)\n  return (count >= offset)? 0 : (offset - count);\n\nelse if (test_mode == PCRE8_MODE)\n  {\n  PCRE2_SPTR8 pp = (PCRE2_SPTR8)subject + offset;\n  for (; count > 0 && pp > (PCRE2_SPTR8)subject; count--)\n    {\n    pp--;\n    while ((*pp & 0xc0) == 0x80) pp--;\n    }\n  return pp - (PCRE2_SPTR8)subject;\n  }\n\nelse  /* 16-bit mode */\n  {\n  PCRE2_SPTR16 pp = (PCRE2_SPTR16)subject + offset;\n  for (; count > 0 && pp > (PCRE2_SPTR16)subject; count--)\n    {\n    pp--;\n    if ((*pp & 0xfc00) == 0xdc00) pp--;\n    }\n  return pp - (PCRE2_SPTR16)subject;\n  }\n}\n#endif  /* NEVERNEVERNEVER */\n\n\n\n/*************************************************\n*           Expand input buffers                 *\n*************************************************/\n\n/* This function doubles the size of the input buffer and the buffer for\nkeeping an 8-bit copy of patterns (pbuffer8), and copies the current buffers to\nthe new ones.\n\nArguments: none\nReturns:   nothing (aborts if malloc() fails)\n*/\n\nstatic void\nexpand_input_buffers(void)\n{\nint new_pbuffer8_size = 2*pbuffer8_size;\nuint8_t *new_buffer = (uint8_t *)malloc(new_pbuffer8_size);\nuint8_t *new_pbuffer8 = (uint8_t *)malloc(new_pbuffer8_size);\n\nif (new_buffer == NULL || new_pbuffer8 == NULL)\n  {\n  fprintf(stderr, \"pcre2test: malloc(%d) failed\\n\", new_pbuffer8_size);\n  exit(1);\n  }\n\nmemcpy(new_buffer, buffer, pbuffer8_size);\nmemcpy(new_pbuffer8, pbuffer8, pbuffer8_size);\n\npbuffer8_size = new_pbuffer8_size;\n\nfree(buffer);\nfree(pbuffer8);\n\nbuffer = new_buffer;\npbuffer8 = new_pbuffer8;\n}\n\n\n\n/*************************************************\n*        Read or extend an input line            *\n*************************************************/\n\n/* Input lines are read into buffer, but both patterns and data lines can be\ncontinued over multiple input lines. In addition, if the buffer fills up, we\nwant to automatically expand it so as to be able to handle extremely large\nlines that are needed for certain stress tests, although this is less likely\nnow that there are repetition features for both patterns and data. When the\ninput buffer is expanded, the other two buffers must also be expanded likewise,\nand the contents of pbuffer, which are a copy of the input for callouts, must\nbe preserved (for when expansion happens for a data line). This is not the most\noptimal way of handling this, but hey, this is just a test program!\n\nArguments:\n  f            the file to read\n  start        where in buffer to start (this *must* be within buffer)\n  prompt       for stdin or readline()\n\nReturns:       pointer to the start of new data\n               could be a copy of start, or could be moved\n               NULL if no data read and EOF reached\n*/\n\nstatic uint8_t *\nextend_inputline(FILE *f, uint8_t *start, const char *prompt)\n{\nuint8_t *here = start;\n\nfor (;;)\n  {\n  size_t rlen = (size_t)(pbuffer8_size - (here - buffer));\n\n  if (rlen > 1000)\n    {\n    size_t dlen;\n\n    /* If libreadline or libedit support is required, use readline() to read a\n    line if the input is a terminal. Note that readline() removes the trailing\n    newline, so we must put it back again, to be compatible with fgets(). */\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\n    if (INTERACTIVE(f))\n      {\n      size_t len;\n      char *s = readline(prompt);\n      if (s == NULL) return (here == start)? NULL : start;\n      len = strlen(s);\n      if (len > 0) add_history(s);\n      if (len > rlen - 1) len = rlen - 1;\n      memcpy(here, s, len);\n      here[len] = '\\n';\n      here[len+1] = 0;\n      free(s);\n      }\n    else\n#endif\n\n    /* Read the next line by normal means, prompting if the file is a tty. */\n\n      {\n      if (INTERACTIVE(f)) printf(\"%s\", prompt);\n      if (fgets((char *)here, rlen,  f) == NULL)\n        return (here == start)? NULL : start;\n      }\n\n    dlen = strlen((char *)here);\n    here += dlen;\n\n    /* Check for end of line reached. Take care not to read data from before\n    start (dlen will be zero for a file starting with a binary zero). */\n\n    if (here > start && here[-1] == '\\n') return start;\n\n    /* If we have not read a newline when reading a file, we have either filled\n    the buffer or reached the end of the file. We can detect the former by\n    checking that the string fills the buffer, and the latter by feof(). If\n    neither of these is true, it means we read a binary zero which has caused\n    strlen() to give a short length. This is a hard error because pcre2test\n    expects to work with C strings. */\n\n    if (!INTERACTIVE(f) && dlen < rlen - 1 && !feof(f))\n      {\n      fprintf(outfile, \"** Binary zero encountered in input\\n\");\n      fprintf(outfile, \"** pcre2test run abandoned\\n\");\n      exit(1);\n      }\n    }\n\n  else\n    {\n    size_t start_offset = start - buffer;\n    size_t here_offset = here - buffer;\n    expand_input_buffers();\n    start = buffer + start_offset;\n    here = buffer + here_offset;\n    }\n  }\n\n/* Control never gets here */\n}\n\n\n\n/*************************************************\n*         Case-independent strncmp() function    *\n*************************************************/\n\n/*\nArguments:\n  s         first string\n  t         second string\n  n         number of characters to compare\n\nReturns:    < 0, = 0, or > 0, according to the comparison\n*/\n\nstatic int\nstrncmpic(const uint8_t *s, const uint8_t *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c != 0) return c;\n  }\nreturn 0;\n}\n\n\n\n/*************************************************\n*          Scan the main modifier list           *\n*************************************************/\n\n/* This function searches the modifier list for a long modifier name.\n\nArgument:\n  p         start of the name\n  lenp      length of the name\n\nReturns:    an index in the modifier list, or -1 on failure\n*/\n\nstatic int\nscan_modifiers(const uint8_t *p, unsigned int len)\n{\nint bot = 0;\nint top = MODLISTCOUNT;\n\nwhile (top > bot)\n  {\n  int mid = (bot + top)/2;\n  unsigned int mlen = strlen(modlist[mid].name);\n  int c = strncmp((char *)p, modlist[mid].name, (len < mlen)? len : mlen);\n  if (c == 0)\n    {\n    if (len == mlen) return mid;\n    c = (int)len - (int)mlen;\n    }\n  if (c > 0) bot = mid + 1; else top = mid;\n  }\n\nreturn -1;\n\n}\n\n\n\n/*************************************************\n*        Check a modifer and find its field      *\n*************************************************/\n\n/* This function is called when a modifier has been identified. We check that\nit is allowed here and find the field that is to be changed.\n\nArguments:\n  m          the modifier list entry\n  ctx        CTX_PAT     => pattern context\n             CTX_POPPAT  => pattern context for popped pattern\n             CTX_DEFPAT  => default pattern context\n             CTX_DAT     => data context\n             CTX_DEFDAT  => default data context\n  pctl       point to pattern control block\n  dctl       point to data control block\n  c          a single character or 0\n\nReturns:     a field pointer or NULL\n*/\n\nstatic void *\ncheck_modifier(modstruct *m, int ctx, patctl *pctl, datctl *dctl, uint32_t c)\n{\nvoid *field = NULL;\nPCRE2_SIZE offset = m->offset;\n\nif (restrict_for_perl_test) switch(m->which)\n  {\n  case MOD_PNDP:\n  case MOD_PATP:\n  case MOD_DATP:\n  case MOD_PDP:\n  break;\n\n  default:\n  fprintf(outfile, \"** '%s' is not allowed in a Perl-compatible test\\n\",\n    m->name);\n  return NULL;\n  }\n\nswitch (m->which)\n  {\n  case MOD_CTC:  /* Compile context modifier */\n  if (ctx == CTX_DEFPAT) field = PTR(default_pat_context);\n    else if (ctx == CTX_PAT) field = PTR(pat_context);\n  break;\n\n  case MOD_CTM:  /* Match context modifier */\n  if (ctx == CTX_DEFDAT) field = PTR(default_dat_context);\n    else if (ctx == CTX_DAT) field = PTR(dat_context);\n  break;\n\n  case MOD_DAT:    /* Data line modifier */\n  case MOD_DATP:   /* Allowed for Perl test */\n  if (dctl != NULL) field = dctl;\n  break;\n\n  case MOD_PAT:    /* Pattern modifier */\n  case MOD_PATP:   /* Allowed for Perl test */\n  if (pctl != NULL) field = pctl;\n  break;\n\n  case MOD_PD:   /* Pattern or data line modifier */\n  case MOD_PDP:  /* Ditto, allowed for Perl test */\n  case MOD_PND:  /* Ditto, but not default pattern */\n  case MOD_PNDP: /* Ditto, allowed for Perl test */\n  if (dctl != NULL) field = dctl;\n    else if (pctl != NULL && (m->which == MOD_PD || m->which == MOD_PDP ||\n             ctx != CTX_DEFPAT))\n      field = pctl;\n  break;\n  }\n\nif (field == NULL)\n  {\n  if (c == 0)\n    fprintf(outfile, \"** '%s' is not valid here\\n\", m->name);\n  else\n    fprintf(outfile, \"** /%c is not valid here\\n\", c);\n  return NULL;\n  }\n\nreturn (char *)field + offset;\n}\n\n\n\n/*************************************************\n*            Decode a modifier list              *\n*************************************************/\n\n/* A pointer to a control block is NULL when called in cases when that block is\nnot relevant. They are never all relevant in one call. At least one of patctl\nand datctl is NULL. The second argument specifies which context to use for\nmodifiers that apply to contexts.\n\nArguments:\n  p          point to modifier string\n  ctx        CTX_PAT     => pattern context\n             CTX_POPPAT  => pattern context for popped pattern\n             CTX_DEFPAT  => default pattern context\n             CTX_DAT     => data context\n             CTX_DEFDAT  => default data context\n  pctl       point to pattern control block\n  dctl       point to data control block\n\nReturns: TRUE if successful decode, FALSE otherwise\n*/\n\nstatic BOOL\ndecode_modifiers(uint8_t *p, int ctx, patctl *pctl, datctl *dctl)\n{\nuint8_t *ep, *pp;\nlong li;\nunsigned long uli;\nBOOL first = TRUE;\n\nfor (;;)\n  {\n  void *field;\n  modstruct *m;\n  BOOL off = FALSE;\n  unsigned int i, len;\n  int index;\n  char *endptr;\n\n  /* Skip white space and commas. */\n\n  while (isspace(*p) || *p == ',') p++;\n  if (*p == 0) break;\n\n  /* Find the end of the item; lose trailing whitespace at end of line. */\n\n  for (ep = p; *ep != 0 && *ep != ','; ep++);\n  if (*ep == 0)\n    {\n    while (ep > p && isspace(ep[-1])) ep--;\n    *ep = 0;\n    }\n\n  /* Remember if the first character is '-'. */\n\n  if (*p == '-')\n    {\n    off = TRUE;\n    p++;\n    }\n\n  /* Find the length of a full-length modifier name, and scan for it. */\n\n  pp = p;\n  while (pp < ep && *pp != '=') pp++;\n  index = scan_modifiers(p, pp - p);\n\n  /* If the first modifier is unrecognized, try to interpret it as a sequence\n  of single-character abbreviated modifiers. None of these modifiers have any\n  associated data. They just set options or control bits. */\n\n  if (index < 0)\n    {\n    uint32_t cc;\n    uint8_t *mp = p;\n\n    if (!first)\n      {\n      fprintf(outfile, \"** Unrecognized modifier '%.*s'\\n\", (int)(ep-p), p);\n      if (ep - p == 1)\n        fprintf(outfile, \"** Single-character modifiers must come first\\n\");\n      return FALSE;\n      }\n\n    for (cc = *p; cc != ',' && cc != '\\n' && cc != 0; cc = *(++p))\n      {\n      for (i = 0; i < C1MODLISTCOUNT; i++)\n        if (cc == c1modlist[i].onechar) break;\n\n      if (i >= C1MODLISTCOUNT)\n        {\n        fprintf(outfile, \"** Unrecognized modifier '%c' in '%.*s'\\n\",\n          *p, (int)(ep-mp), mp);\n        return FALSE;\n        }\n\n      if (c1modlist[i].index >= 0)\n        {\n        index = c1modlist[i].index;\n        }\n\n      else\n        {\n        index = scan_modifiers((uint8_t *)(c1modlist[i].fullname),\n          strlen(c1modlist[i].fullname));\n        if (index < 0)\n          {\n          fprintf(outfile, \"** Internal error: single-character equivalent \"\n            \"modifier '%s' not found\\n\", c1modlist[i].fullname);\n          return FALSE;\n          }\n        c1modlist[i].index = index;     /* Cache for next time */\n        }\n\n      field = check_modifier(modlist + index, ctx, pctl, dctl, *p);\n      if (field == NULL) return FALSE;\n\n      /* /x is a special case; a second appearance changes PCRE2_EXTENDED to\n      PCRE2_EXTENDED_MORE. */\n\n      if (cc == 'x' && (*((uint32_t *)field) & PCRE2_EXTENDED) != 0)\n        {\n        *((uint32_t *)field) &= ~PCRE2_EXTENDED;\n        *((uint32_t *)field) |= PCRE2_EXTENDED_MORE;\n        }\n      else\n        *((uint32_t *)field) |= modlist[index].value;\n      }\n\n    continue;    /* With tne next (fullname) modifier */\n    }\n\n  /* We have a match on a full-name modifier. Check for the existence of data\n  when needed. */\n\n  m = modlist + index;      /* Save typing */\n  if (m->type != MOD_CTL && m->type != MOD_OPT &&\n      (m->type != MOD_IND || *pp == '='))\n    {\n    if (*pp++ != '=')\n      {\n      fprintf(outfile, \"** '=' expected after '%s'\\n\", m->name);\n      return FALSE;\n      }\n    if (off)\n      {\n      fprintf(outfile, \"** '-' is not valid for '%s'\\n\", m->name);\n      return FALSE;\n      }\n    }\n\n  /* These on/off types have no data. */\n\n  else if (*pp != ',' && *pp != '\\n' && *pp != ' ' && *pp != 0)\n    {\n    fprintf(outfile, \"** Unrecognized modifier '%.*s'\\n\", (int)(ep-p), p);\n    return FALSE;\n    }\n\n  /* Set the data length for those types that have data. Then find the field\n  that is to be set. If check_modifier() returns NULL, it has already output an\n  error message. */\n\n  len = ep - pp;\n  field = check_modifier(m, ctx, pctl, dctl, 0);\n  if (field == NULL) return FALSE;\n\n  /* Process according to data type. */\n\n  switch (m->type)\n    {\n    case MOD_CTL:\n    case MOD_OPT:\n    if (off) *((uint32_t *)field) &= ~m->value;\n      else *((uint32_t *)field) |= m->value;\n    break;\n\n    case MOD_BSR:\n    if (len == 7 && strncmpic(pp, (const uint8_t *)\"default\", 7) == 0)\n      {\n#ifdef BSR_ANYCRLF\n      *((uint16_t *)field) = PCRE2_BSR_ANYCRLF;\n#else\n      *((uint16_t *)field) = PCRE2_BSR_UNICODE;\n#endif\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 &= ~CTL2_BSR_SET;\n        else dctl->control2 &= ~CTL2_BSR_SET;\n      }\n    else\n      {\n      if (len == 7 && strncmpic(pp, (const uint8_t *)\"anycrlf\", 7) == 0)\n        *((uint16_t *)field) = PCRE2_BSR_ANYCRLF;\n      else if (len == 7 && strncmpic(pp, (const uint8_t *)\"unicode\", 7) == 0)\n        *((uint16_t *)field) = PCRE2_BSR_UNICODE;\n      else goto INVALID_VALUE;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 |= CTL2_BSR_SET;\n        else dctl->control2 |= CTL2_BSR_SET;\n      }\n    pp = ep;\n    break;\n\n    case MOD_CHR:  /* A single character */\n    *((uint32_t *)field) = *pp++;\n    break;\n\n    case MOD_CON:  /* A convert type/options list */\n    for (;; pp++)\n      {\n      uint8_t *colon = (uint8_t *)strchr((const char *)pp, ':');\n      len = ((colon != NULL && colon < ep)? colon:ep) - pp;\n      for (i = 0; i < convertlistcount; i++)\n        {\n        if (strncmpic(pp, (const uint8_t *)convertlist[i].name, len) == 0)\n          {\n          if (*((uint32_t *)field) == CONVERT_UNSET)\n            *((uint32_t *)field) = convertlist[i].option;\n          else\n            *((uint32_t *)field) |= convertlist[i].option;\n          break;\n          }\n        }\n      if (i >= convertlistcount) goto INVALID_VALUE;\n      pp += len;\n      if (*pp != ':') break;\n      }\n    break;\n\n    case MOD_IN2:    /* One or two unsigned integers */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n    ((uint32_t *)field)[0] = (uint32_t)uli;\n    if (*endptr == ':')\n      {\n      uli = strtoul((const char *)endptr+1, &endptr, 10);\n      if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n      ((uint32_t *)field)[1] = (uint32_t)uli;\n      }\n    else ((uint32_t *)field)[1] = 0;\n    pp = (uint8_t *)endptr;\n    break;\n\n    /* PCRE2_SIZE_MAX is usually SIZE_MAX, which may be greater, equal to, or\n    less than ULONG_MAX. So first test for overflowing the long int, and then\n    test for overflowing PCRE2_SIZE_MAX if it is smaller than ULONG_MAX. */\n\n    case MOD_SIZ:    /* PCRE2_SIZE value */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (uli == ULONG_MAX) goto INVALID_VALUE;\n#if ULONG_MAX > PCRE2_SIZE_MAX\n    if (uli > PCRE2_SIZE_MAX) goto INVALID_VALUE;\n#endif\n    *((PCRE2_SIZE *)field) = (PCRE2_SIZE)uli;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_IND:    /* Unsigned integer with default */\n    if (len == 0)\n      {\n      *((uint32_t *)field) = (uint32_t)(m->value);\n      break;\n      }\n    /* Fall through */\n\n    case MOD_INT:    /* Unsigned integer */\n    if (!isdigit(*pp)) goto INVALID_VALUE;\n    uli = strtoul((const char *)pp, &endptr, 10);\n    if (U32OVERFLOW(uli)) goto INVALID_VALUE;\n    *((uint32_t *)field) = (uint32_t)uli;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_INS:   /* Signed integer */\n    if (!isdigit(*pp) && *pp != '-') goto INVALID_VALUE;\n    li = strtol((const char *)pp, &endptr, 10);\n    if (S32OVERFLOW(li)) goto INVALID_VALUE;\n    *((int32_t *)field) = (int32_t)li;\n    pp = (uint8_t *)endptr;\n    break;\n\n    case MOD_NL:\n    for (i = 0; i < sizeof(newlines)/sizeof(char *); i++)\n      if (len == strlen(newlines[i]) &&\n        strncmpic(pp, (const uint8_t *)newlines[i], len) == 0) break;\n    if (i >= sizeof(newlines)/sizeof(char *)) goto INVALID_VALUE;\n    if (i == 0)\n      {\n      *((uint16_t *)field) = NEWLINE_DEFAULT;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 &= ~CTL2_NL_SET;\n        else dctl->control2 &= ~CTL2_NL_SET;\n      }\n    else\n      {\n      *((uint16_t *)field) = i;\n      if (ctx == CTX_PAT || ctx == CTX_DEFPAT) pctl->control2 |= CTL2_NL_SET;\n        else dctl->control2 |= CTL2_NL_SET;\n      }\n    pp = ep;\n    break;\n\n    case MOD_NN:              /* Name or (signed) number; may be several */\n    if (isdigit(*pp) || *pp == '-')\n      {\n      int ct = MAXCPYGET - 1;\n      int32_t value;\n      li = strtol((const char *)pp, &endptr, 10);\n      if (S32OVERFLOW(li)) goto INVALID_VALUE;\n      value = (int32_t)li;\n      field = (char *)field - m->offset + m->value;      /* Adjust field ptr */\n      if (value >= 0)                                    /* Add new number */\n        {\n        while (*((int32_t *)field) >= 0 && ct-- > 0)   /* Skip previous */\n          field = (char *)field + sizeof(int32_t);\n        if (ct <= 0)\n          {\n          fprintf(outfile, \"** Too many numeric '%s' modifiers\\n\", m->name);\n          return FALSE;\n          }\n        }\n      *((int32_t *)field) = value;\n      if (ct > 0) ((int32_t *)field)[1] = -1;\n      pp = (uint8_t *)endptr;\n      }\n\n    /* Multiple strings are put end to end. */\n\n    else\n      {\n      char *nn = (char *)field;\n      if (len > 0)                    /* Add new name */\n        {\n        if (len > MAX_NAME_SIZE)\n          {\n          fprintf(outfile, \"** Group name in '%s' is too long\\n\", m->name);\n          return FALSE;\n          }\n        while (*nn != 0) nn += strlen(nn) + 1;\n        if (nn + len + 2 - (char *)field > LENCPYGET)\n          {\n          fprintf(outfile, \"** Too many characters in named '%s' modifiers\\n\",\n            m->name);\n          return FALSE;\n          }\n        memcpy(nn, pp, len);\n        }\n      nn[len] = 0 ;\n      nn[len+1] = 0;\n      pp = ep;\n      }\n    break;\n\n    case MOD_STR:\n    if (len + 1 > m->value)\n      {\n      fprintf(outfile, \"** Overlong value for '%s' (max %d code units)\\n\",\n        m->name, m->value - 1);\n      return FALSE;\n      }\n    memcpy(field, pp, len);\n    ((uint8_t *)field)[len] = 0;\n    pp = ep;\n    break;\n    }\n\n  if (*pp != ',' && *pp != '\\n' && *pp != ' ' && *pp != 0)\n    {\n    fprintf(outfile, \"** Comma expected after modifier item '%s'\\n\", m->name);\n    return FALSE;\n    }\n\n  p = pp;\n  first = FALSE;\n\n  if (ctx == CTX_POPPAT &&\n     (pctl->options != 0 ||\n      pctl->tables_id != 0 ||\n      pctl->locale[0] != 0 ||\n      (pctl->control & NOTPOP_CONTROLS) != 0))\n    {\n    fprintf(outfile, \"** '%s' is not valid here\\n\", m->name);\n    return FALSE;\n    }\n  }\n\nreturn TRUE;\n\nINVALID_VALUE:\nfprintf(outfile, \"** Invalid value in '%.*s'\\n\", (int)(ep-p), p);\nreturn FALSE;\n}\n\n\n/*************************************************\n*             Get info from a pattern            *\n*************************************************/\n\n/* A wrapped call to pcre2_pattern_info(), applied to the current compiled\npattern.\n\nArguments:\n  what        code for the required information\n  where       where to put the answer\n  unsetok     PCRE2_ERROR_UNSET is an \"expected\" result\n\nReturns:      the return from pcre2_pattern_info()\n*/\n\nstatic int\npattern_info(int what, void *where, BOOL unsetok)\n{\nint rc;\nPCRE2_PATTERN_INFO(rc, compiled_code, what, NULL);  /* Exercise the code */\nPCRE2_PATTERN_INFO(rc, compiled_code, what, where);\nif (rc >= 0) return 0;\nif (rc != PCRE2_ERROR_UNSET || !unsetok)\n  {\n  fprintf(outfile, \"Error %d from pcre2_pattern_info_%d(%d)\\n\", rc, test_mode,\n    what);\n  if (rc == PCRE2_ERROR_BADMODE)\n    fprintf(outfile, \"Running in %d-bit mode but pattern was compiled in \"\n      \"%d-bit mode\\n\", test_mode,\n      8 * (FLD(compiled_code, flags) & PCRE2_MODE_MASK));\n  }\nreturn rc;\n}\n\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*             Show something in a list           *\n*************************************************/\n\n/* This function just helps to keep the code that uses it tidier. It's used for\nvarious lists of things where there needs to be introductory text before the\nfirst item. As these calls are all in the POSIX-support code, they happen only\nwhen 8-bit mode is supported. */\n\nstatic void\nprmsg(const char **msg, const char *s)\n{\nfprintf(outfile, \"%s %s\", *msg, s);\n*msg = \"\";\n}\n#endif  /* SUPPORT_PCRE2_8 */\n\n\n\n/*************************************************\n*                Show control bits               *\n*************************************************/\n\n/* Called for mutually exclusive controls and for unsupported POSIX controls.\nBecause the bits are unique, this can be used for both pattern and data control\nwords.\n\nArguments:\n  controls    control bits\n  controls2   more control bits\n  before      text to print before\n\nReturns:      nothing\n*/\n\nstatic void\nshow_controls(uint32_t controls, uint32_t controls2, const char *before)\n{\nfprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  before,\n  ((controls & CTL_AFTERTEXT) != 0)? \" aftertext\" : \"\",\n  ((controls & CTL_ALLAFTERTEXT) != 0)? \" allaftertext\" : \"\",\n  ((controls & CTL_ALLCAPTURES) != 0)? \" allcaptures\" : \"\",\n  ((controls & CTL_ALLUSEDTEXT) != 0)? \" allusedtext\" : \"\",\n  ((controls2 & CTL2_ALLVECTOR) != 0)? \" allvector\" : \"\",\n  ((controls & CTL_ALTGLOBAL) != 0)? \" altglobal\" : \"\",\n  ((controls & CTL_BINCODE) != 0)? \" bincode\" : \"\",\n  ((controls2 & CTL2_BSR_SET) != 0)? \" bsr\" : \"\",\n  ((controls & CTL_CALLOUT_CAPTURE) != 0)? \" callout_capture\" : \"\",\n  ((controls2 & CTL2_CALLOUT_EXTRA) != 0)? \" callout_extra\" : \"\",\n  ((controls & CTL_CALLOUT_INFO) != 0)? \" callout_info\" : \"\",\n  ((controls & CTL_CALLOUT_NONE) != 0)? \" callout_none\" : \"\",\n  ((controls2 & CTL2_CALLOUT_NO_WHERE) != 0)? \" callout_no_where\" : \"\",\n  ((controls & CTL_DFA) != 0)? \" dfa\" : \"\",\n  ((controls & CTL_EXPAND) != 0)? \" expand\" : \"\",\n  ((controls & CTL_FINDLIMITS) != 0)? \" find_limits\" : \"\",\n  ((controls & CTL_FINDLIMITS_NOHEAP) != 0)? \" find_limits_noheap\" : \"\",\n  ((controls2 & CTL2_FRAMESIZE) != 0)? \" framesize\" : \"\",\n  ((controls & CTL_FULLBINCODE) != 0)? \" fullbincode\" : \"\",\n  ((controls & CTL_GETALL) != 0)? \" getall\" : \"\",\n  ((controls & CTL_GLOBAL) != 0)? \" global\" : \"\",\n  ((controls & CTL_HEXPAT) != 0)? \" hex\" : \"\",\n  ((controls & CTL_INFO) != 0)? \" info\" : \"\",\n  ((controls & CTL_JITFAST) != 0)? \" jitfast\" : \"\",\n  ((controls & CTL_JITVERIFY) != 0)? \" jitverify\" : \"\",\n  ((controls & CTL_MARK) != 0)? \" mark\" : \"\",\n  ((controls & CTL_MEMORY) != 0)? \" memory\" : \"\",\n  ((controls2 & CTL2_NL_SET) != 0)? \" newline\" : \"\",\n  ((controls & CTL_NULLCONTEXT) != 0)? \" null_context\" : \"\",\n  ((controls2 & CTL2_NULL_REPLACEMENT) != 0)? \" null_replacement\" : \"\",\n  ((controls2 & CTL2_NULL_SUBJECT) != 0)? \" null_subject\" : \"\",\n  ((controls & CTL_POSIX) != 0)? \" posix\" : \"\",\n  ((controls & CTL_POSIX_NOSUB) != 0)? \" posix_nosub\" : \"\",\n  ((controls & CTL_PUSH) != 0)? \" push\" : \"\",\n  ((controls & CTL_PUSHCOPY) != 0)? \" pushcopy\" : \"\",\n  ((controls & CTL_PUSHTABLESCOPY) != 0)? \" pushtablescopy\" : \"\",\n  ((controls & CTL_STARTCHAR) != 0)? \" startchar\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_CALLOUT) != 0)? \" substitute_callout\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_EXTENDED) != 0)? \" substitute_extended\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_LITERAL) != 0)? \" substitute_literal\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_MATCHED) != 0)? \" substitute_matched\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)? \" substitute_overflow_length\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) != 0)? \" substitute_replacement_only\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) != 0)? \" substitute_unknown_unset\" : \"\",\n  ((controls2 & CTL2_SUBSTITUTE_UNSET_EMPTY) != 0)? \" substitute_unset_empty\" : \"\",\n  ((controls & CTL_USE_LENGTH) != 0)? \" use_length\" : \"\",\n  ((controls & CTL_UTF8_INPUT) != 0)? \" utf8_input\" : \"\",\n  ((controls & CTL_ZERO_TERMINATE) != 0)? \" zero_terminate\" : \"\");\n}\n\n\n\n/*************************************************\n*                Show compile options            *\n*************************************************/\n\n/* Called from show_pattern_info() and for unsupported POSIX options.\n\nArguments:\n  options     an options word\n  before      text to print before\n  after       text to print after\n\nReturns:      nothing\n*/\n\nstatic void\nshow_compile_options(uint32_t options, const char *before, const char *after)\n{\nif (options == 0) fprintf(outfile, \"%s <none>%s\", before, after);\nelse fprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  before,\n  ((options & PCRE2_ALT_BSUX) != 0)? \" alt_bsux\" : \"\",\n  ((options & PCRE2_ALT_CIRCUMFLEX) != 0)? \" alt_circumflex\" : \"\",\n  ((options & PCRE2_ALT_VERBNAMES) != 0)? \" alt_verbnames\" : \"\",\n  ((options & PCRE2_ALLOW_EMPTY_CLASS) != 0)? \" allow_empty_class\" : \"\",\n  ((options & PCRE2_ANCHORED) != 0)? \" anchored\" : \"\",\n  ((options & PCRE2_AUTO_CALLOUT) != 0)? \" auto_callout\" : \"\",\n  ((options & PCRE2_CASELESS) != 0)? \" caseless\" : \"\",\n  ((options & PCRE2_DOLLAR_ENDONLY) != 0)? \" dollar_endonly\" : \"\",\n  ((options & PCRE2_DOTALL) != 0)? \" dotall\" : \"\",\n  ((options & PCRE2_DUPNAMES) != 0)? \" dupnames\" : \"\",\n  ((options & PCRE2_ENDANCHORED) != 0)? \" endanchored\" : \"\",\n  ((options & PCRE2_EXTENDED) != 0)? \" extended\" : \"\",\n  ((options & PCRE2_EXTENDED_MORE) != 0)? \" extended_more\" : \"\",\n  ((options & PCRE2_FIRSTLINE) != 0)? \" firstline\" : \"\",\n  ((options & PCRE2_LITERAL) != 0)? \" literal\" : \"\",\n  ((options & PCRE2_MATCH_INVALID_UTF) != 0)? \" match_invalid_utf\" : \"\",\n  ((options & PCRE2_MATCH_UNSET_BACKREF) != 0)? \" match_unset_backref\" : \"\",\n  ((options & PCRE2_MULTILINE) != 0)? \" multiline\" : \"\",\n  ((options & PCRE2_NEVER_BACKSLASH_C) != 0)? \" never_backslash_c\" : \"\",\n  ((options & PCRE2_NEVER_UCP) != 0)? \" never_ucp\" : \"\",\n  ((options & PCRE2_NEVER_UTF) != 0)? \" never_utf\" : \"\",\n  ((options & PCRE2_NO_AUTO_CAPTURE) != 0)? \" no_auto_capture\" : \"\",\n  ((options & PCRE2_NO_AUTO_POSSESS) != 0)? \" no_auto_possess\" : \"\",\n  ((options & PCRE2_NO_DOTSTAR_ANCHOR) != 0)? \" no_dotstar_anchor\" : \"\",\n  ((options & PCRE2_NO_UTF_CHECK) != 0)? \" no_utf_check\" : \"\",\n  ((options & PCRE2_NO_START_OPTIMIZE) != 0)? \" no_start_optimize\" : \"\",\n  ((options & PCRE2_UCP) != 0)? \" ucp\" : \"\",\n  ((options & PCRE2_UNGREEDY) != 0)? \" ungreedy\" : \"\",\n  ((options & PCRE2_USE_OFFSET_LIMIT) != 0)? \" use_offset_limit\" : \"\",\n  ((options & PCRE2_UTF) != 0)? \" utf\" : \"\",\n  after);\n}\n\n\n/*************************************************\n*           Show compile extra options           *\n*************************************************/\n\n/* Called from show_pattern_info() and for unsupported POSIX options.\n\nArguments:\n  options     an options word\n  before      text to print before\n  after       text to print after\n\nReturns:      nothing\n*/\n\nstatic void\nshow_compile_extra_options(uint32_t options, const char *before,\n  const char *after)\n{\nif (options == 0) fprintf(outfile, \"%s <none>%s\", before, after);\nelse fprintf(outfile, \"%s%s%s%s%s%s%s%s\",\n  before,\n  ((options & PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES) != 0)? \" allow_surrogate_escapes\" : \"\",\n  ((options & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) != 0)? \" bad_escape_is_literal\" : \"\",\n  ((options & PCRE2_EXTRA_ALT_BSUX) != 0)? \" extra_alt_bsux\" : \"\",\n  ((options & PCRE2_EXTRA_MATCH_WORD) != 0)? \" match_word\" : \"\",\n  ((options & PCRE2_EXTRA_MATCH_LINE) != 0)? \" match_line\" : \"\",\n  ((options & PCRE2_EXTRA_ESCAPED_CR_IS_LF) != 0)? \" escaped_cr_is_lf\" : \"\",\n  after);\n}\n\n\n\n#ifdef SUPPORT_PCRE2_8\n/*************************************************\n*                Show match options              *\n*************************************************/\n\n/* Called for unsupported POSIX options. */\n\nstatic void\nshow_match_options(uint32_t options)\n{\nfprintf(outfile, \"%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n  ((options & PCRE2_ANCHORED) != 0)? \" anchored\" : \"\",\n  ((options & PCRE2_COPY_MATCHED_SUBJECT) != 0)? \" copy_matched_subject\" : \"\",\n  ((options & PCRE2_DFA_RESTART) != 0)? \" dfa_restart\" : \"\",\n  ((options & PCRE2_DFA_SHORTEST) != 0)? \" dfa_shortest\" : \"\",\n  ((options & PCRE2_ENDANCHORED) != 0)? \" endanchored\" : \"\",\n  ((options & PCRE2_NO_JIT) != 0)? \" no_jit\" : \"\",\n  ((options & PCRE2_NO_UTF_CHECK) != 0)? \" no_utf_check\" : \"\",\n  ((options & PCRE2_NOTBOL) != 0)? \" notbol\" : \"\",\n  ((options & PCRE2_NOTEMPTY) != 0)? \" notempty\" : \"\",\n  ((options & PCRE2_NOTEMPTY_ATSTART) != 0)? \" notempty_atstart\" : \"\",\n  ((options & PCRE2_NOTEOL) != 0)? \" noteol\" : \"\",\n  ((options & PCRE2_PARTIAL_HARD) != 0)? \" partial_hard\" : \"\",\n  ((options & PCRE2_PARTIAL_SOFT) != 0)? \" partial_soft\" : \"\");\n}\n#endif  /* SUPPORT_PCRE2_8 */\n\n\n\n/*************************************************\n*      Show memory usage info for a pattern      *\n*************************************************/\n\nstatic void\nshow_memory_info(void)\n{\nuint32_t name_count, name_entry_size;\nsize_t size, cblock_size;\n\n/* One of the test_mode values will always be true, but to stop a compiler\nwarning we must initialize cblock_size. */\n\ncblock_size = 0;\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE) cblock_size = sizeof(pcre2_real_code_8);\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE) cblock_size = sizeof(pcre2_real_code_16);\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE) cblock_size = sizeof(pcre2_real_code_32);\n#endif\n\n(void)pattern_info(PCRE2_INFO_SIZE, &size, FALSE);\n(void)pattern_info(PCRE2_INFO_NAMECOUNT, &name_count, FALSE);\n(void)pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &name_entry_size, FALSE);\n\n/* The uint32_t variables are cast before multiplying to stop code analyzers\ngrumbling about potential overflow. */\n\nfprintf(outfile, \"Memory allocation (code space): %\" SIZ_FORM \"\\n\", size -\n  (size_t)name_count * (size_t)name_entry_size * (size_t)code_unit_size -\n  cblock_size);\n\nif (pat_patctl.jit != 0)\n  {\n  (void)pattern_info(PCRE2_INFO_JITSIZE, &size, FALSE);\n  fprintf(outfile, \"Memory allocation (JIT code): %\" SIZ_FORM \"\\n\", size);\n  }\n}\n\n\n\n/*************************************************\n*       Show frame size info for a pattern       *\n*************************************************/\n\nstatic void\nshow_framesize(void)\n{\nsize_t frame_size;\n(void)pattern_info(PCRE2_INFO_FRAMESIZE, &frame_size, FALSE);\nfprintf(outfile, \"Frame size for pcre2_match(): %\" SIZ_FORM \"\\n\", frame_size);\n}\n\n\n\n/*************************************************\n*         Get and output an error message        *\n*************************************************/\n\nstatic BOOL\nprint_error_message(int errorcode, const char *before, const char *after)\n{\nint len;\nPCRE2_GET_ERROR_MESSAGE(len, errorcode, pbuffer);\nif (len < 0)\n  {\n  fprintf(outfile, \"\\n** pcre2test internal error: cannot interpret error \"\n    \"number\\n** Unexpected return (%d) from pcre2_get_error_message()\\n\", len);\n  }\nelse\n  {\n  fprintf(outfile, \"%s\", before);\n  PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, outfile);\n  fprintf(outfile, \"%s\", after);\n  }\nreturn len >= 0;\n}\n\n\n/*************************************************\n*     Callback function for callout enumeration  *\n*************************************************/\n\n/* The only differences in the callout emumeration block for different code\nunit widths are that the pointers to the subject, the most recent MARK, and a\ncallout argument string point to strings of the appropriate width. Casts can be\nused to deal with this.\n\nArgument:\n  cb            pointer to enumerate block\n  callout_data  user data\n\nReturns:    0\n*/\n\nstatic int callout_callback(pcre2_callout_enumerate_block_8 *cb,\n  void *callout_data)\n{\nuint32_t i;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n\n(void)callout_data;  /* Not currently displayed */\n\nfprintf(outfile, \"Callout \");\nif (cb->callout_string != NULL)\n  {\n  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);\n  fprintf(outfile, \"%c\", delimiter);\n  PCHARSV(cb->callout_string, 0,\n    cb->callout_string_length, utf, outfile);\n  for (i = 0; callout_start_delims[i] != 0; i++)\n    if (delimiter == callout_start_delims[i])\n      {\n      delimiter = callout_end_delims[i];\n      break;\n      }\n  fprintf(outfile, \"%c  \", delimiter);\n  }\nelse fprintf(outfile, \"%d  \", cb->callout_number);\n\nfprintf(outfile, \"%.*s\\n\",\n  (int)((cb->next_item_length == 0)? 1 : cb->next_item_length),\n  pbuffer8 + cb->pattern_position);\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*        Show information about a pattern        *\n*************************************************/\n\n/* This function is called after a pattern has been compiled if any of the\ninformation-requesting controls have been set.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nshow_pattern_info(void)\n{\nuint32_t compile_options, overall_options, extra_options;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n\nif ((pat_patctl.control & (CTL_BINCODE|CTL_FULLBINCODE)) != 0)\n  {\n  fprintf(outfile, \"------------------------------------------------------------------\\n\");\n  PCRE2_PRINTINT((pat_patctl.control & CTL_FULLBINCODE) != 0);\n  }\n\nif ((pat_patctl.control & CTL_INFO) != 0)\n  {\n  int rc;\n  void *nametable;\n  uint8_t *start_bits;\n  BOOL heap_limit_set, match_limit_set, depth_limit_set;\n  uint32_t backrefmax, bsr_convention, capture_count, first_ctype, first_cunit,\n    hasbackslashc, hascrorlf, jchanged, last_ctype, last_cunit, match_empty,\n    depth_limit, heap_limit, match_limit, minlength, nameentrysize, namecount,\n    newline_convention;\n\n  /* Exercise the error route. */\n\n  PCRE2_PATTERN_INFO(rc, compiled_code, 999, NULL);\n  (void)rc;\n\n  /* These info requests may return PCRE2_ERROR_UNSET. */\n\n  switch(pattern_info(PCRE2_INFO_HEAPLIMIT, &heap_limit, TRUE))\n    {\n    case 0:\n    heap_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    heap_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  switch(pattern_info(PCRE2_INFO_MATCHLIMIT, &match_limit, TRUE))\n    {\n    case 0:\n    match_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    match_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  switch(pattern_info(PCRE2_INFO_DEPTHLIMIT, &depth_limit, TRUE))\n    {\n    case 0:\n    depth_limit_set = TRUE;\n    break;\n\n    case PCRE2_ERROR_UNSET:\n    depth_limit_set = FALSE;\n    break;\n\n    default:\n    return PR_ABEND;\n    }\n\n  /* These info requests should always succeed. */\n\n  if (pattern_info(PCRE2_INFO_BACKREFMAX, &backrefmax, FALSE) +\n      pattern_info(PCRE2_INFO_BSR, &bsr_convention, FALSE) +\n      pattern_info(PCRE2_INFO_CAPTURECOUNT, &capture_count, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTBITMAP, &start_bits, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTCODEUNIT, &first_cunit, FALSE) +\n      pattern_info(PCRE2_INFO_FIRSTCODETYPE, &first_ctype, FALSE) +\n      pattern_info(PCRE2_INFO_HASBACKSLASHC, &hasbackslashc, FALSE) +\n      pattern_info(PCRE2_INFO_HASCRORLF, &hascrorlf, FALSE) +\n      pattern_info(PCRE2_INFO_JCHANGED, &jchanged, FALSE) +\n      pattern_info(PCRE2_INFO_LASTCODEUNIT, &last_cunit, FALSE) +\n      pattern_info(PCRE2_INFO_LASTCODETYPE, &last_ctype, FALSE) +\n      pattern_info(PCRE2_INFO_MATCHEMPTY, &match_empty, FALSE) +\n      pattern_info(PCRE2_INFO_MINLENGTH, &minlength, FALSE) +\n      pattern_info(PCRE2_INFO_NAMECOUNT, &namecount, FALSE) +\n      pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &nameentrysize, FALSE) +\n      pattern_info(PCRE2_INFO_NAMETABLE, &nametable, FALSE) +\n      pattern_info(PCRE2_INFO_NEWLINE, &newline_convention, FALSE)\n      != 0)\n    return PR_ABEND;\n\n  fprintf(outfile, \"Capture group count = %d\\n\", capture_count);\n\n  if (backrefmax > 0)\n    fprintf(outfile, \"Max back reference = %d\\n\", backrefmax);\n\n  if (maxlookbehind > 0)\n    fprintf(outfile, \"Max lookbehind = %d\\n\", maxlookbehind);\n\n  if (heap_limit_set)\n    fprintf(outfile, \"Heap limit = %u\\n\", heap_limit);\n\n  if (match_limit_set)\n    fprintf(outfile, \"Match limit = %u\\n\", match_limit);\n\n  if (depth_limit_set)\n    fprintf(outfile, \"Depth limit = %u\\n\", depth_limit);\n\n  if (namecount > 0)\n    {\n    fprintf(outfile, \"Named capture groups:\\n\");\n    for (; namecount > 0; namecount--)\n      {\n      int imm2_size = test_mode == PCRE8_MODE ? 2 : 1;\n      uint32_t length = (uint32_t)STRLEN(nametable + imm2_size);\n      fprintf(outfile, \"  \");\n\n      /* In UTF mode the name may be a UTF string containing non-ASCII\n      letters and digits. We must output it as a UTF-8 string. In non-UTF mode,\n      use the normal string printing functions, which use escapes for all\n      non-ASCII characters. */\n\n      if (utf)\n        {\n#ifdef SUPPORT_PCRE2_32\n        if (test_mode == PCRE32_MODE)\n          {\n          PCRE2_SPTR32 nameptr = (PCRE2_SPTR32)nametable + imm2_size;\n          while (*nameptr != 0)\n            {\n            uint8_t u8buff[6];\n            int len = ord2utf8(*nameptr++, u8buff);\n            fprintf(outfile, \"%.*s\", len, u8buff);\n            }\n          }\n#endif\n#ifdef SUPPORT_PCRE2_16\n        if (test_mode == PCRE16_MODE)\n          {\n          PCRE2_SPTR16 nameptr = (PCRE2_SPTR16)nametable + imm2_size;\n          while (*nameptr != 0)\n            {\n            int len;\n            uint8_t u8buff[6];\n            uint32_t c = *nameptr++ & 0xffff;\n            if (c >= 0xD800 && c < 0xDC00)\n              c = ((c & 0x3ff) << 10) + (*nameptr++ & 0x3ff) + 0x10000;\n            len = ord2utf8(c, u8buff);\n            fprintf(outfile, \"%.*s\", len, u8buff);\n            }\n          }\n#endif\n#ifdef SUPPORT_PCRE2_8\n        if (test_mode == PCRE8_MODE)\n          fprintf(outfile, \"%s\", (PCRE2_SPTR8)nametable + imm2_size);\n#endif\n        }\n      else  /* Not UTF mode */\n        {\n        PCHARSV(nametable, imm2_size, length, FALSE, outfile);\n        }\n\n      while (length++ < nameentrysize - imm2_size) putc(' ', outfile);\n\n#ifdef SUPPORT_PCRE2_32\n      if (test_mode == PCRE32_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(((PCRE2_SPTR32)nametable)[0]));\n#endif\n#ifdef SUPPORT_PCRE2_16\n      if (test_mode == PCRE16_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(((PCRE2_SPTR16)nametable)[0]));\n#endif\n#ifdef SUPPORT_PCRE2_8\n      if (test_mode == PCRE8_MODE)\n        fprintf(outfile, \"%3d\\n\", (int)(\n        ((((PCRE2_SPTR8)nametable)[0]) << 8) | ((PCRE2_SPTR8)nametable)[1]));\n#endif\n\n      nametable = (void*)((PCRE2_SPTR8)nametable + nameentrysize * code_unit_size);\n      }\n    }\n\n  if (hascrorlf)     fprintf(outfile, \"Contains explicit CR or LF match\\n\");\n  if (hasbackslashc) fprintf(outfile, \"Contains \\\\C\\n\");\n  if (match_empty)   fprintf(outfile, \"May match empty string\\n\");\n\n  pattern_info(PCRE2_INFO_ARGOPTIONS, &compile_options, FALSE);\n  pattern_info(PCRE2_INFO_ALLOPTIONS, &overall_options, FALSE);\n  pattern_info(PCRE2_INFO_EXTRAOPTIONS, &extra_options, FALSE);\n\n  /* Remove UTF/UCP if they were there only because of forbid_utf. This saves\n  cluttering up the verification output of non-UTF test files. */\n\n  if ((pat_patctl.options & PCRE2_NEVER_UTF) == 0)\n    {\n    compile_options &= ~PCRE2_NEVER_UTF;\n    overall_options &= ~PCRE2_NEVER_UTF;\n    }\n\n  if ((pat_patctl.options & PCRE2_NEVER_UCP) == 0)\n    {\n    compile_options &= ~PCRE2_NEVER_UCP;\n    overall_options &= ~PCRE2_NEVER_UCP;\n    }\n\n  if ((compile_options|overall_options) != 0)\n    {\n    if (compile_options == overall_options)\n      show_compile_options(compile_options, \"Options:\", \"\\n\");\n    else\n      {\n      show_compile_options(compile_options, \"Compile options:\", \"\\n\");\n      show_compile_options(overall_options, \"Overall options:\", \"\\n\");\n      }\n    }\n\n  if (extra_options != 0)\n    show_compile_extra_options(extra_options, \"Extra options:\", \"\\n\");\n\n  if (jchanged) fprintf(outfile, \"Duplicate name status changes\\n\");\n\n  if ((pat_patctl.control2 & CTL2_BSR_SET) != 0 ||\n      (FLD(compiled_code, flags) & PCRE2_BSR_SET) != 0)\n    fprintf(outfile, \"\\\\R matches %s\\n\", (bsr_convention == PCRE2_BSR_UNICODE)?\n      \"any Unicode newline\" : \"CR, LF, or CRLF\");\n\n  if ((FLD(compiled_code, flags) & PCRE2_NL_SET) != 0)\n    {\n    switch (newline_convention)\n      {\n      case PCRE2_NEWLINE_CR:\n      fprintf(outfile, \"Forced newline is CR\\n\");\n      break;\n\n      case PCRE2_NEWLINE_LF:\n      fprintf(outfile, \"Forced newline is LF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_CRLF:\n      fprintf(outfile, \"Forced newline is CRLF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_ANYCRLF:\n      fprintf(outfile, \"Forced newline is CR, LF, or CRLF\\n\");\n      break;\n\n      case PCRE2_NEWLINE_ANY:\n      fprintf(outfile, \"Forced newline is any Unicode newline\\n\");\n      break;\n\n      case PCRE2_NEWLINE_NUL:\n      fprintf(outfile, \"Forced newline is NUL\\n\");\n      break;\n\n      default:\n      break;\n      }\n    }\n\n  if (first_ctype == 2)\n    {\n    fprintf(outfile, \"First code unit at start or follows newline\\n\");\n    }\n  else if (first_ctype == 1)\n    {\n    const char *caseless =\n      ((FLD(compiled_code, flags) & PCRE2_FIRSTCASELESS) == 0)?\n      \"\" : \" (caseless)\";\n    if (PRINTOK(first_cunit))\n      fprintf(outfile, \"First code unit = \\'%c\\'%s\\n\", first_cunit, caseless);\n    else\n      {\n      fprintf(outfile, \"First code unit = \");\n      pchar(first_cunit, FALSE, outfile);\n      fprintf(outfile, \"%s\\n\", caseless);\n      }\n    }\n  else if (start_bits != NULL)\n    {\n    int i;\n    int c = 24;\n    fprintf(outfile, \"Starting code units: \");\n    for (i = 0; i < 256; i++)\n      {\n      if ((start_bits[i/8] & (1u << (i&7))) != 0)\n        {\n        if (c > 75)\n          {\n          fprintf(outfile, \"\\n  \");\n          c = 2;\n          }\n        if (PRINTOK(i) && i != ' ')\n          {\n          fprintf(outfile, \"%c \", i);\n          c += 2;\n          }\n        else\n          {\n          fprintf(outfile, \"\\\\x%02x \", i);\n          c += 5;\n          }\n        }\n      }\n    fprintf(outfile, \"\\n\");\n    }\n\n  if (last_ctype != 0)\n    {\n    const char *caseless =\n      ((FLD(compiled_code, flags) & PCRE2_LASTCASELESS) == 0)?\n      \"\" : \" (caseless)\";\n    if (PRINTOK(last_cunit))\n      fprintf(outfile, \"Last code unit = \\'%c\\'%s\\n\", last_cunit, caseless);\n    else\n      {\n      fprintf(outfile, \"Last code unit = \");\n      pchar(last_cunit, FALSE, outfile);\n      fprintf(outfile, \"%s\\n\", caseless);\n      }\n    }\n\n  if ((FLD(compiled_code, overall_options) & PCRE2_NO_START_OPTIMIZE) == 0)\n    fprintf(outfile, \"Subject length lower bound = %d\\n\", minlength);\n\n  if (pat_patctl.jit != 0 && (pat_patctl.control & CTL_JITVERIFY) != 0)\n    {\n#ifdef SUPPORT_JIT\n    if (FLD(compiled_code, executable_jit) != NULL)\n      fprintf(outfile, \"JIT compilation was successful\\n\");\n    else\n      {\n      fprintf(outfile, \"JIT compilation was not successful\");\n      if (jitrc != 0 && !print_error_message(jitrc, \" (\", \")\"))\n        return PR_ABEND;\n      fprintf(outfile, \"\\n\");\n      }\n#else\n      fprintf(outfile, \"JIT support is not available in this version of PCRE2\\n\");\n#endif\n    }\n  }\n\nif ((pat_patctl.control & CTL_CALLOUT_INFO) != 0)\n  {\n  int errorcode;\n  PCRE2_CALLOUT_ENUMERATE(errorcode, callout_callback, 0);\n  if (errorcode != 0)\n    {\n    fprintf(outfile, \"Callout enumerate failed: error %d: \", errorcode);\n    if (errorcode < 0 && !print_error_message(errorcode, \"\", \"\\n\"))\n      return PR_ABEND;\n    return PR_SKIP;\n    }\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*              Handle serialization error        *\n*************************************************/\n\n/* Print an error message after a serialization failure.\n\nArguments:\n  rc         the error code\n  msg        an initial message for what failed\n\nReturns:     FALSE if print_error_message() fails\n*/\n\nstatic BOOL\nserial_error(int rc, const char *msg)\n{\nfprintf(outfile, \"%s failed: error %d: \", msg, rc);\nreturn print_error_message(rc, \"\", \"\\n\");\n}\n\n\n\n/*************************************************\n*        Open file for save/load commands        *\n*************************************************/\n\n/* This function decodes the file name and opens the file.\n\nArguments:\n  buffptr     point after the #command\n  mode        open mode\n  fptr        points to the FILE variable\n  name        name of # command\n\nReturns:      PR_OK or PR_ABEND\n*/\n\nstatic int\nopen_file(uint8_t *buffptr, const char *mode, FILE **fptr, const char *name)\n{\nchar *endf;\nchar *filename = (char *)buffptr;\nwhile (isspace(*filename)) filename++;\nendf = filename + strlen8(filename);\nwhile (endf > filename && isspace(endf[-1])) endf--;\n\nif (endf == filename)\n  {\n  fprintf(outfile, \"** File name expected after %s\\n\", name);\n  return PR_ABEND;\n  }\n\n*endf = 0;\n*fptr = fopen((const char *)filename, mode);\nif (*fptr == NULL)\n  {\n  fprintf(outfile, \"** Failed to open '%s': %s\\n\", filename, strerror(errno));\n  return PR_ABEND;\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*               Process command line             *\n*************************************************/\n\n/* This function is called for lines beginning with # and a character that is\nnot ! or whitespace, when encountered between tests, which means that there is\nno compiled pattern (compiled_code is NULL). The line is in buffer.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_command(void)\n{\nFILE *f;\nPCRE2_SIZE serial_size;\nsize_t i;\nint rc, cmd, cmdlen, yield;\nuint16_t first_listed_newline;\nconst char *cmdname;\nuint8_t *argptr, *serial;\n\nyield = PR_OK;\ncmd = CMD_UNKNOWN;\ncmdlen = 0;\n\nfor (i = 0; i < cmdlistcount; i++)\n  {\n  cmdname = cmdlist[i].name;\n  cmdlen = strlen(cmdname);\n  if (strncmp((char *)(buffer+1), cmdname, cmdlen) == 0 &&\n      isspace(buffer[cmdlen+1]))\n    {\n    cmd = cmdlist[i].value;\n    break;\n    }\n  }\n\nargptr = buffer + cmdlen + 1;\n\nif (restrict_for_perl_test && cmd != CMD_PATTERN && cmd != CMD_SUBJECT)\n  {\n  fprintf(outfile, \"** #%s is not allowed after #perltest\\n\", cmdname);\n  return PR_ABEND;\n  }\n\nswitch(cmd)\n  {\n  case CMD_UNKNOWN:\n  fprintf(outfile, \"** Unknown command: %s\", buffer);\n  break;\n\n  case CMD_FORBID_UTF:\n  forbid_utf = PCRE2_NEVER_UTF|PCRE2_NEVER_UCP;\n  break;\n\n  case CMD_PERLTEST:\n  restrict_for_perl_test = TRUE;\n  break;\n\n  /* Set default pattern modifiers */\n\n  case CMD_PATTERN:\n  (void)decode_modifiers(argptr, CTX_DEFPAT, &def_patctl, NULL);\n  if (def_patctl.jit == 0 && (def_patctl.control & CTL_JITVERIFY) != 0)\n    def_patctl.jit = JIT_DEFAULT;\n  break;\n\n  /* Set default subject modifiers */\n\n  case CMD_SUBJECT:\n  (void)decode_modifiers(argptr, CTX_DEFDAT, NULL, &def_datctl);\n  break;\n\n  /* Check the default newline, and if not one of those listed, set up the\n  first one to be forced. An empty list unsets. */\n\n  case CMD_NEWLINE_DEFAULT:\n  local_newline_default = 0;   /* Unset */\n  first_listed_newline = 0;\n  for (;;)\n    {\n    while (isspace(*argptr)) argptr++;\n    if (*argptr == 0) break;\n    for (i = 1; i < sizeof(newlines)/sizeof(char *); i++)\n      {\n      size_t nlen = strlen(newlines[i]);\n      if (strncmpic(argptr, (const uint8_t *)newlines[i], nlen) == 0 &&\n          isspace(argptr[nlen]))\n        {\n        if (i == NEWLINE_DEFAULT) return PR_OK;  /* Default is valid */\n        if (first_listed_newline == 0) first_listed_newline = i;\n        }\n      }\n    while (*argptr != 0 && !isspace(*argptr)) argptr++;\n    }\n  local_newline_default = first_listed_newline;\n  break;\n\n  /* Pop or copy a compiled pattern off the stack. Modifiers that do not affect\n  the compiled pattern (e.g. to give information) are permitted. The default\n  pattern modifiers are ignored. */\n\n  case CMD_POP:\n  case CMD_POPCOPY:\n  if (patstacknext <= 0)\n    {\n    fprintf(outfile, \"** Can't pop off an empty stack\\n\");\n    return PR_SKIP;\n    }\n  memset(&pat_patctl, 0, sizeof(patctl));   /* Completely unset */\n  if (!decode_modifiers(argptr, CTX_POPPAT, &pat_patctl, NULL))\n    return PR_SKIP;\n\n  if (cmd == CMD_POP)\n    {\n    SET(compiled_code, patstack[--patstacknext]);\n    }\n  else\n    {\n    PCRE2_CODE_COPY_FROM_VOID(compiled_code, patstack[patstacknext - 1]);\n    }\n\n  if (pat_patctl.jit != 0)\n    {\n    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n    }\n  if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();\n  if ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();\n  if ((pat_patctl.control & CTL_ANYINFO) != 0)\n    {\n    rc = show_pattern_info();\n    if (rc != PR_OK) return rc;\n    }\n  break;\n\n  /* Save the stack of compiled patterns to a file, then empty the stack. */\n\n  case CMD_SAVE:\n  if (patstacknext <= 0)\n    {\n    fprintf(outfile, \"** No stacked patterns to save\\n\");\n    return PR_OK;\n    }\n\n  rc = open_file(argptr+1, BINARY_OUTPUT_MODE, &f, \"#save\");\n  if (rc != PR_OK) return rc;\n\n  PCRE2_SERIALIZE_ENCODE(rc, patstack, patstacknext, &serial, &serial_size,\n    general_context);\n  if (rc < 0)\n    {\n    fclose(f);\n    if (!serial_error(rc, \"Serialization\")) return PR_ABEND;\n    break;\n    }\n\n  /* Write the length at the start of the file to make it straightforward to\n  get the right memory when re-loading. This saves having to read the file size\n  in different operating systems. To allow for different endianness (even\n  though reloading with the opposite endianness does not work), write the\n  length byte-by-byte. */\n\n  for (i = 0; i < 4; i++) fputc((serial_size >> (i*8)) & 255, f);\n  if (fwrite(serial, 1, serial_size, f) != serial_size)\n    {\n    fprintf(outfile, \"** Wrong return from fwrite()\\n\");\n    fclose(f);\n    return PR_ABEND;\n    }\n\n  fclose(f);\n  PCRE2_SERIALIZE_FREE(serial);\n  while(patstacknext > 0)\n    {\n    SET(compiled_code, patstack[--patstacknext]);\n    SUB1(pcre2_code_free, compiled_code);\n    }\n  SET(compiled_code, NULL);\n  break;\n\n  /* Load a set of compiled patterns from a file onto the stack */\n\n  case CMD_LOAD:\n  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, \"#load\");\n  if (rc != PR_OK) return rc;\n\n  serial_size = 0;\n  for (i = 0; i < 4; i++) serial_size |= fgetc(f) << (i*8);\n\n  serial = malloc(serial_size);\n  if (serial == NULL)\n    {\n    fprintf(outfile, \"** Failed to get memory (size %\" SIZ_FORM \") for #load\\n\",\n      serial_size);\n    fclose(f);\n    return PR_ABEND;\n    }\n\n  i = fread(serial, 1, serial_size, f);\n  fclose(f);\n\n  if (i != serial_size)\n    {\n    fprintf(outfile, \"** Wrong return from fread()\\n\");\n    yield = PR_ABEND;\n    }\n  else\n    {\n    PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(rc, serial);\n    if (rc < 0)\n      {\n      if (!serial_error(rc, \"Get number of codes\")) yield = PR_ABEND;\n      }\n    else\n      {\n      if (rc + patstacknext > PATSTACKSIZE)\n        {\n        fprintf(outfile, \"** Not enough space on pattern stack for %d pattern%s\\n\",\n          rc, (rc == 1)? \"\" : \"s\");\n        rc = PATSTACKSIZE - patstacknext;\n        fprintf(outfile, \"** Decoding %d pattern%s\\n\", rc,\n          (rc == 1)? \"\" : \"s\");\n        }\n      PCRE2_SERIALIZE_DECODE(rc, patstack + patstacknext, rc, serial,\n        general_context);\n      if (rc < 0)\n        {\n        if (!serial_error(rc, \"Deserialization\")) yield = PR_ABEND;\n        }\n      else patstacknext += rc;\n      }\n    }\n\n  free(serial);\n  break;\n\n  /* Load a set of binary tables into tables3. */\n\n  case CMD_LOADTABLES:\n  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, \"#loadtables\");\n  if (rc != PR_OK) return rc;\n\n  if (tables3 == NULL)\n    {\n    (void)PCRE2_CONFIG(PCRE2_CONFIG_TABLES_LENGTH, &loadtables_length);\n    tables3 = malloc(loadtables_length);\n    }\n\n  if (tables3 == NULL)\n    {\n    fprintf(outfile, \"** Failed: malloc failed for #loadtables\\n\");\n    yield = PR_ABEND;\n    }\n  else if (fread(tables3, 1, loadtables_length, f) != loadtables_length)\n    {\n    fprintf(outfile, \"** Wrong return from fread()\\n\");\n    yield = PR_ABEND;\n    }\n\n  fclose(f);\n  break;\n  }\n\nreturn yield;\n}\n\n\n\n/*************************************************\n*               Process pattern line             *\n*************************************************/\n\n/* This function is called when the input buffer contains the start of a\npattern. The first character is known to be a valid delimiter. The pattern is\nread, modifiers are interpreted, and a suitable local context is set up for\nthis test. The pattern is then compiled.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_pattern(void)\n{\nBOOL utf;\nuint32_t k;\nuint8_t *p = buffer;\nunsigned int delimiter = *p++;\nint errorcode;\nvoid *use_pat_context;\nuint32_t use_forbid_utf = forbid_utf;\nPCRE2_SIZE patlen;\nPCRE2_SIZE valgrind_access_length;\nPCRE2_SIZE erroroffset;\n\n/* The perltest.sh script supports only / as a delimiter. */\n\nif (restrict_for_perl_test && delimiter != '/')\n  {\n  fprintf(outfile, \"** The only allowed delimiter after #perltest is '/'\\n\");\n  return PR_ABEND;\n  }\n\n/* Initialize the context and pattern/data controls for this test from the\ndefaults. */\n\nPATCTXCPY(pat_context, default_pat_context);\nmemcpy(&pat_patctl, &def_patctl, sizeof(patctl));\n\n/* Find the end of the pattern, reading more lines if necessary. */\n\nfor(;;)\n  {\n  while (*p != 0)\n    {\n    if (*p == '\\\\' && p[1] != 0) p++;\n      else if (*p == delimiter) break;\n    p++;\n    }\n  if (*p != 0) break;\n  if ((p = extend_inputline(infile, p, \"    > \")) == NULL)\n    {\n    fprintf(outfile, \"** Unexpected EOF\\n\");\n    return PR_ABEND;\n    }\n  if (!INTERACTIVE(infile)) fprintf(outfile, \"%s\", (char *)p);\n  }\n\n/* If the first character after the delimiter is backslash, make the pattern\nend with backslash. This is purely to provide a way of testing for the error\nmessage when a pattern ends with backslash. */\n\nif (p[1] == '\\\\') *p++ = '\\\\';\n\n/* Terminate the pattern at the delimiter, and compute the length. */\n\n*p++ = 0;\npatlen = p - buffer - 2;\n\n/* Look for modifiers and options after the final delimiter. */\n\nif (!decode_modifiers(p, CTX_PAT, &pat_patctl, NULL)) return PR_SKIP;\n\n/* Note that the match_invalid_utf option also sets utf when passed to\npcre2_compile(). */\n\nutf = (pat_patctl.options & (PCRE2_UTF|PCRE2_MATCH_INVALID_UTF)) != 0;\n\n/* The utf8_input modifier is not allowed in 8-bit mode, and is mutually\nexclusive with the utf modifier. */\n\nif ((pat_patctl.control & CTL_UTF8_INPUT) != 0)\n  {\n  if (test_mode == PCRE8_MODE)\n    {\n    fprintf(outfile, \"** The utf8_input modifier is not allowed in 8-bit mode\\n\");\n    return PR_SKIP;\n    }\n  if (utf)\n    {\n    fprintf(outfile, \"** The utf and utf8_input modifiers are mutually exclusive\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* The convert and posix modifiers are mutually exclusive. */\n\nif (pat_patctl.convert_type != CONVERT_UNSET &&\n    (pat_patctl.control & CTL_POSIX) != 0)\n  {\n  fprintf(outfile, \"** The convert and posix modifiers are mutually exclusive\\n\");\n  return PR_SKIP;\n  }\n\n/* Check for mutually exclusive control modifiers. At present, these are all in\nthe first control word. */\n\nfor (k = 0; k < sizeof(exclusive_pat_controls)/sizeof(uint32_t); k++)\n  {\n  uint32_t c = pat_patctl.control & exclusive_pat_controls[k];\n  if (c != 0 && c != (c & (~c+1)))\n    {\n    show_controls(c, 0, \"** Not allowed together:\");\n    fprintf(outfile, \"\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* Assume full JIT compile for jitverify and/or jitfast if nothing else was\nspecified. */\n\nif (pat_patctl.jit == 0 &&\n    (pat_patctl.control & (CTL_JITVERIFY|CTL_JITFAST)) != 0)\n  pat_patctl.jit = JIT_DEFAULT;\n\n/* Now copy the pattern to pbuffer8 for use in 8-bit testing and for reflecting\nin callouts. Convert from hex if requested (literal strings in quotes may be\npresent within the hexadecimal pairs). The result must necessarily be fewer\ncharacters so will always fit in pbuffer8. */\n\nif ((pat_patctl.control & CTL_HEXPAT) != 0)\n  {\n  uint8_t *pp, *pt;\n  uint32_t c, d;\n\n  pt = pbuffer8;\n  for (pp = buffer + 1; *pp != 0; pp++)\n    {\n    if (isspace(*pp)) continue;\n    c = *pp++;\n\n    /* Handle a literal substring */\n\n    if (c == '\\'' || c == '\"')\n      {\n      uint8_t *pq = pp;\n      for (;; pp++)\n        {\n        d = *pp;\n        if (d == 0)\n          {\n          fprintf(outfile, \"** Missing closing quote in hex pattern: \"\n            \"opening quote is at offset %\" PTR_FORM \".\\n\", pq - buffer - 2);\n          return PR_SKIP;\n          }\n        if (d == c) break;\n        *pt++ = d;\n        }\n      }\n\n    /* Expect a hex pair */\n\n    else\n      {\n      if (!isxdigit(c))\n        {\n        fprintf(outfile, \"** Unexpected non-hex-digit '%c' at offset %\"\n          PTR_FORM \" in hex pattern: quote missing?\\n\", c, pp - buffer - 2);\n        return PR_SKIP;\n        }\n      if (*pp == 0)\n        {\n        fprintf(outfile, \"** Odd number of digits in hex pattern\\n\");\n        return PR_SKIP;\n        }\n      d = *pp;\n      if (!isxdigit(d))\n        {\n        fprintf(outfile, \"** Unexpected non-hex-digit '%c' at offset %\"\n          PTR_FORM \" in hex pattern: quote missing?\\n\", d, pp - buffer - 1);\n        return PR_SKIP;\n        }\n      c = toupper(c);\n      d = toupper(d);\n      *pt++ = ((isdigit(c)? (c - '0') : (c - 'A' + 10)) << 4) +\n               (isdigit(d)? (d - '0') : (d - 'A' + 10));\n      }\n    }\n  *pt = 0;\n  patlen = pt - pbuffer8;\n  }\n\n/* If not a hex string, process for repetition expansion if requested. */\n\nelse if ((pat_patctl.control & CTL_EXPAND) != 0)\n  {\n  uint8_t *pp, *pt;\n\n  pt = pbuffer8;\n  for (pp = buffer + 1; *pp != 0; pp++)\n    {\n    uint8_t *pc = pp;\n    uint32_t count = 1;\n    size_t length = 1;\n\n    /* Check for replication syntax; if not found, the defaults just set will\n    prevail and one character will be copied. */\n\n    if (pp[0] == '\\\\' && pp[1] == '[')\n      {\n      uint8_t *pe;\n      for (pe = pp + 2; *pe != 0; pe++)\n        {\n        if (pe[0] == ']' && pe[1] == '{')\n          {\n          uint32_t clen = pe - pc - 2;\n          uint32_t i = 0;\n          unsigned long uli;\n          char *endptr;\n\n          pe += 2;\n          uli = strtoul((const char *)pe, &endptr, 10);\n          if (U32OVERFLOW(uli))\n            {\n            fprintf(outfile, \"** Pattern repeat count too large\\n\");\n            return PR_SKIP;\n            }\n\n          i = (uint32_t)uli;\n          pe = (uint8_t *)endptr;\n          if (*pe == '}')\n            {\n            if (i == 0)\n              {\n              fprintf(outfile, \"** Zero repeat not allowed\\n\");\n              return PR_SKIP;\n              }\n            pc += 2;\n            count = i;\n            length = clen;\n            pp = pe;\n            break;\n            }\n          }\n        }\n      }\n\n    /* Add to output. If the buffer is too small expand it. The function for\n    expanding buffers always keeps buffer and pbuffer8 in step as far as their\n    size goes. */\n\n    while (pt + count * length > pbuffer8 + pbuffer8_size)\n      {\n      size_t pc_offset = pc - buffer;\n      size_t pp_offset = pp - buffer;\n      size_t pt_offset = pt - pbuffer8;\n      expand_input_buffers();\n      pc = buffer + pc_offset;\n      pp = buffer + pp_offset;\n      pt = pbuffer8 + pt_offset;\n      }\n\n    for (; count > 0; count--)\n      {\n      memcpy(pt, pc, length);\n      pt += length;\n      }\n    }\n\n  *pt = 0;\n  patlen = pt - pbuffer8;\n\n  if ((pat_patctl.control & CTL_INFO) != 0)\n    fprintf(outfile, \"Expanded: %s\\n\", pbuffer8);\n  }\n\n/* Neither hex nor expanded, just copy the input verbatim. */\n\nelse\n  {\n  strncpy((char *)pbuffer8, (char *)(buffer+1), patlen + 1);\n  }\n\n/* Sort out character tables */\n\nif (pat_patctl.locale[0] != 0)\n  {\n  if (pat_patctl.tables_id != 0)\n    {\n    fprintf(outfile, \"** 'Locale' and 'tables' must not both be set\\n\");\n    return PR_SKIP;\n    }\n  if (setlocale(LC_CTYPE, (const char *)pat_patctl.locale) == NULL)\n    {\n    fprintf(outfile, \"** Failed to set locale '%s'\\n\", pat_patctl.locale);\n    return PR_SKIP;\n    }\n  if (strcmp((const char *)pat_patctl.locale, (const char *)locale_name) != 0)\n    {\n    strcpy((char *)locale_name, (char *)pat_patctl.locale);\n    if (locale_tables != NULL)\n      { \n      PCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);\n      } \n    PCRE2_MAKETABLES(locale_tables, general_context);\n    }\n  use_tables = locale_tables;\n  }\n\nelse switch (pat_patctl.tables_id)\n  {\n  case 0: use_tables = NULL; break;\n  case 1: use_tables = tables1; break;\n  case 2: use_tables = tables2; break;\n\n  case 3:\n  if (tables3 == NULL)\n    {\n    fprintf(outfile, \"** 'Tables = 3' is invalid: binary tables have not \"\n      \"been loaded\\n\");\n    return PR_SKIP;\n    }\n  use_tables = tables3;\n  break;\n\n  default:\n  fprintf(outfile, \"** 'Tables' must specify 0, 1, 2, or 3.\\n\");\n  return PR_SKIP;\n  }\n\nPCRE2_SET_CHARACTER_TABLES(pat_context, use_tables);\n\n/* Set up for the stackguard test. */\n\nif (pat_patctl.stackguard_test != 0)\n  {\n  PCRE2_SET_COMPILE_RECURSION_GUARD(pat_context, stack_guard, NULL);\n  }\n\n/* Handle compiling via the POSIX interface, which doesn't support the\ntiming, showing, or debugging options, nor the ability to pass over\nlocal character tables. Neither does it have 16-bit or 32-bit support. */\n\nif ((pat_patctl.control & CTL_POSIX) != 0)\n  {\n#ifdef SUPPORT_PCRE2_8\n  int rc;\n  int cflags = 0;\n  const char *msg = \"** Ignored with POSIX interface:\";\n#endif\n\n  if (test_mode != PCRE8_MODE)\n    {\n    fprintf(outfile, \"** The POSIX interface is available only in 8-bit mode\\n\");\n    return PR_SKIP;\n    }\n\n#ifdef SUPPORT_PCRE2_8\n  /* Check for features that the POSIX interface does not support. */\n\n  if (pat_patctl.locale[0] != 0) prmsg(&msg, \"locale\");\n  if (pat_patctl.replacement[0] != 0) prmsg(&msg, \"replace\");\n  if (pat_patctl.tables_id != 0) prmsg(&msg, \"tables\");\n  if (pat_patctl.stackguard_test != 0) prmsg(&msg, \"stackguard\");\n  if (timeit > 0) prmsg(&msg, \"timing\");\n  if (pat_patctl.jit != 0) prmsg(&msg, \"JIT\");\n\n  if ((pat_patctl.options & ~POSIX_SUPPORTED_COMPILE_OPTIONS) != 0)\n    {\n    show_compile_options(\n      pat_patctl.options & (uint32_t)(~POSIX_SUPPORTED_COMPILE_OPTIONS),\n        msg, \"\");\n    msg = \"\";\n    }\n\n  if ((FLD(pat_context, extra_options) &\n       (uint32_t)(~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS)) != 0)\n    {\n    show_compile_extra_options(\n      FLD(pat_context, extra_options) &\n        (uint32_t)(~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS), msg, \"\");\n    msg = \"\";\n    }\n\n  if ((pat_patctl.control & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS)) != 0 ||\n      (pat_patctl.control2 & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS2)) != 0)\n    {\n    show_controls(\n      pat_patctl.control & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS),\n      pat_patctl.control2 & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS2),\n      msg);\n    msg = \"\";\n    }\n\n  if (local_newline_default != 0) prmsg(&msg, \"#newline_default\");\n  if (FLD(pat_context, max_pattern_length) != PCRE2_UNSET)\n    prmsg(&msg, \"max_pattern_length\");\n  if (FLD(pat_context, parens_nest_limit) != PARENS_NEST_DEFAULT)\n    prmsg(&msg, \"parens_nest_limit\");\n\n  if (msg[0] == 0) fprintf(outfile, \"\\n\");\n\n  /* Translate PCRE2 options to POSIX options and then compile. */\n\n  if (utf) cflags |= REG_UTF;\n  if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0) cflags |= REG_NOSUB;\n  if ((pat_patctl.options & PCRE2_UCP) != 0) cflags |= REG_UCP;\n  if ((pat_patctl.options & PCRE2_CASELESS) != 0) cflags |= REG_ICASE;\n  if ((pat_patctl.options & PCRE2_LITERAL) != 0) cflags |= REG_NOSPEC;\n  if ((pat_patctl.options & PCRE2_MULTILINE) != 0) cflags |= REG_NEWLINE;\n  if ((pat_patctl.options & PCRE2_DOTALL) != 0) cflags |= REG_DOTALL;\n  if ((pat_patctl.options & PCRE2_UNGREEDY) != 0) cflags |= REG_UNGREEDY;\n\n  if ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) != 0)\n    {\n    preg.re_endp = (char *)pbuffer8 + patlen;\n    cflags |= REG_PEND;\n    }\n\n  rc = regcomp(&preg, (char *)pbuffer8, cflags);\n\n  /* Compiling failed */\n\n  if (rc != 0)\n    {\n    size_t bsize, usize;\n    int psize;\n\n    preg.re_pcre2_code = NULL;     /* In case something was left in there */\n    preg.re_match_data = NULL;\n\n    bsize = (pat_patctl.regerror_buffsize != 0)?\n      pat_patctl.regerror_buffsize : pbuffer8_size;\n    if (bsize + 8 < pbuffer8_size)\n      memcpy(pbuffer8 + bsize, \"DEADBEEF\", 8);\n    usize = regerror(rc, &preg, (char *)pbuffer8, bsize);\n\n    /* Inside regerror(), snprintf() is used. If the buffer is too small, some\n    versions of snprintf() put a zero byte at the end, but others do not.\n    Therefore, we print a maximum of one less than the size of the buffer. */\n\n    psize = (int)bsize - 1;\n    fprintf(outfile, \"Failed: POSIX code %d: %.*s\\n\", rc, psize, pbuffer8);\n    if (usize > bsize)\n      {\n      fprintf(outfile, \"** regerror() message truncated\\n\");\n      if (memcmp(pbuffer8 + bsize, \"DEADBEEF\", 8) != 0)\n        fprintf(outfile, \"** regerror() buffer overflow\\n\");\n      }\n    return PR_SKIP;\n    }\n\n  /* Compiling succeeded. Check that the values in the preg block are sensible.\n  It can happen that pcre2test is accidentally linked with a different POSIX\n  library which succeeds, but of course puts different things into preg. In\n  this situation, calling regfree() may cause a segfault (or invalid free() in\n  valgrind), so ensure that preg.re_pcre2_code is NULL, which suppresses the\n  calling of regfree() on exit. */\n\n  if (preg.re_pcre2_code == NULL ||\n      ((pcre2_real_code_8 *)preg.re_pcre2_code)->magic_number != MAGIC_NUMBER ||\n      ((pcre2_real_code_8 *)preg.re_pcre2_code)->top_bracket != preg.re_nsub ||\n      preg.re_match_data == NULL ||\n      preg.re_cflags != cflags)\n    {\n    fprintf(outfile,\n      \"** The regcomp() function returned zero (success), but the values set\\n\"\n      \"** in the preg block are not valid for PCRE2. Check that pcre2test is\\n\"\n      \"** linked with PCRE2's pcre2posix module (-lpcre2-posix) and not with\\n\"\n      \"** some other POSIX regex library.\\n**\\n\");\n    preg.re_pcre2_code = NULL;\n    return PR_ABEND;\n    }\n\n  return PR_OK;\n#endif  /* SUPPORT_PCRE2_8 */\n  }\n\n/* Handle compiling via the native interface. Controls that act later are\nignored with \"push\". Replacements are locked out. */\n\nif ((pat_patctl.control & (CTL_PUSH|CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)\n  {\n  if (pat_patctl.replacement[0] != 0)\n    {\n    fprintf(outfile, \"** Replacement text is not supported with 'push'.\\n\");\n    return PR_OK;\n    }\n  if ((pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS) != 0 ||\n      (pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS,\n                  pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2,\n      \"** Ignored when compiled pattern is stacked with 'push':\");\n    fprintf(outfile, \"\\n\");\n    }\n  if ((pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS) != 0 ||\n      (pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2) != 0)\n    {\n    show_controls(pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS,\n                  pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2,\n      \"** Applies only to compile when pattern is stacked with 'push':\");\n    fprintf(outfile, \"\\n\");\n    }\n  }\n\n/* Convert the input in non-8-bit modes. */\n\nerrorcode = 0;\n\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE) errorcode = to16(pbuffer8, utf, &patlen);\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE) errorcode = to32(pbuffer8, utf, &patlen);\n#endif\n\nswitch(errorcode)\n  {\n  case -1:\n  fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be \"\n    \"converted to %d-bit string\\n\", (test_mode == PCRE16_MODE)? 16:32);\n  return PR_SKIP;\n\n  case -2:\n  fprintf(outfile, \"** Failed: character value greater than 0x10ffff \"\n    \"cannot be converted to UTF\\n\");\n  return PR_SKIP;\n\n  case -3:\n  fprintf(outfile, \"** Failed: character value greater than 0xffff \"\n    \"cannot be converted to 16-bit in non-UTF mode\\n\");\n  return PR_SKIP;\n\n  default:\n  break;\n  }\n\n/* The pattern is now in pbuffer[8|16|32], with the length in code units in\npatlen. If it is to be converted, copy the result back afterwards so that it\nends up back in the usual place. */\n\nif (pat_patctl.convert_type != CONVERT_UNSET)\n  {\n  int rc;\n  int convert_return = PR_OK;\n  uint32_t convert_options = pat_patctl.convert_type;\n  void *converted_pattern;\n  PCRE2_SIZE converted_length;\n\n  if (pat_patctl.convert_length != 0)\n    {\n    converted_length = pat_patctl.convert_length;\n    converted_pattern = malloc(converted_length * code_unit_size);\n    if (converted_pattern == NULL)\n      {\n      fprintf(outfile, \"** Failed: malloc failed for converted pattern\\n\");\n      return PR_SKIP;\n      }\n    }\n  else converted_pattern = NULL;  /* Let the library allocate */\n\n  if (utf) convert_options |= PCRE2_CONVERT_UTF;\n  if ((pat_patctl.options & PCRE2_NO_UTF_CHECK) != 0)\n    convert_options |= PCRE2_CONVERT_NO_UTF_CHECK;\n\n  CONCTXCPY(con_context, default_con_context);\n\n  if (pat_patctl.convert_glob_escape != 0)\n    {\n    uint32_t escape = (pat_patctl.convert_glob_escape == '0')? 0 :\n      pat_patctl.convert_glob_escape;\n    PCRE2_SET_GLOB_ESCAPE(rc, con_context, escape);\n    if (rc != 0)\n      {\n      fprintf(outfile, \"** Invalid glob escape '%c'\\n\",\n        pat_patctl.convert_glob_escape);\n      convert_return = PR_SKIP;\n      goto CONVERT_FINISH;\n      }\n    }\n\n  if (pat_patctl.convert_glob_separator != 0)\n    {\n    PCRE2_SET_GLOB_SEPARATOR(rc, con_context, pat_patctl.convert_glob_separator);\n    if (rc != 0)\n      {\n      fprintf(outfile, \"** Invalid glob separator '%c'\\n\",\n        pat_patctl.convert_glob_separator);\n      convert_return = PR_SKIP;\n      goto CONVERT_FINISH;\n      }\n    }\n\n  PCRE2_PATTERN_CONVERT(rc, pbuffer, patlen, convert_options,\n    &converted_pattern, &converted_length, con_context);\n\n  if (rc != 0)\n    {\n    fprintf(outfile, \"** Pattern conversion error at offset %\" SIZ_FORM \": \",\n      converted_length);\n    convert_return = print_error_message(rc, \"\", \"\\n\")? PR_SKIP:PR_ABEND;\n    }\n\n  /* Output the converted pattern, then copy it. */\n\n  else\n    {\n    PCHARSV(converted_pattern, 0, converted_length, utf, outfile);\n    fprintf(outfile, \"\\n\");\n    patlen = converted_length;\n    CONVERT_COPY(pbuffer, converted_pattern, converted_length + 1);\n    }\n\n  /* Free the converted pattern. */\n\n  CONVERT_FINISH:\n  if (pat_patctl.convert_length != 0)\n    free(converted_pattern);\n  else\n    PCRE2_CONVERTED_PATTERN_FREE(converted_pattern);\n\n  /* Return if conversion was unsuccessful. */\n\n  if (convert_return != PR_OK) return convert_return;\n  }\n\n/* By default we pass a zero-terminated pattern, but a length is passed if\n\"use_length\" was specified or this is a hex pattern (which might contain binary\nzeros). When valgrind is supported, arrange for the unused part of the buffer\nto be marked as no access. */\n\nvalgrind_access_length = patlen;\nif ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) == 0)\n  {\n  patlen = PCRE2_ZERO_TERMINATED;\n  valgrind_access_length += 1;  /* For the terminating zero */\n  }\n\n#ifdef SUPPORT_VALGRIND\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE && pbuffer8 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer8 + valgrind_access_length,\n    pbuffer8_size - valgrind_access_length);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE && pbuffer16 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer16 + valgrind_access_length,\n    pbuffer16_size - valgrind_access_length*sizeof(uint16_t));\n  }\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE && pbuffer32 != NULL)\n  {\n  VALGRIND_MAKE_MEM_NOACCESS(pbuffer32 + valgrind_access_length,\n    pbuffer32_size - valgrind_access_length*sizeof(uint32_t));\n  }\n#endif\n#else  /* Valgrind not supported */\n(void)valgrind_access_length;  /* Avoid compiler warning */\n#endif\n\n/* If #newline_default has been used and the library was not compiled with an\nappropriate default newline setting, local_newline_default will be non-zero. We\nuse this if there is no explicit newline modifier. */\n\nif ((pat_patctl.control2 & CTL2_NL_SET) == 0 && local_newline_default != 0)\n  {\n  SETFLD(pat_context, newline_convention, local_newline_default);\n  }\n\n/* The null_context modifier is used to test calling pcre2_compile() with a\nNULL context. */\n\nuse_pat_context = ((pat_patctl.control & CTL_NULLCONTEXT) != 0)?\n  NULL : PTR(pat_context);\n\n/* If PCRE2_LITERAL is set, set use_forbid_utf zero because PCRE2_NEVER_UTF\nand PCRE2_NEVER_UCP are invalid with it. */\n\nif ((pat_patctl.options & PCRE2_LITERAL) != 0) use_forbid_utf = 0;\n\n/* Compile many times when timing. */\n\nif (timeit > 0)\n  {\n  int i;\n  clock_t time_taken = 0;\n  for (i = 0; i < timeit; i++)\n    {\n    clock_t start_time = clock();\n    PCRE2_COMPILE(compiled_code, pbuffer, patlen,\n      pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,\n        use_pat_context);\n    time_taken += clock() - start_time;\n    if (TEST(compiled_code, !=, NULL))\n      { SUB1(pcre2_code_free, compiled_code); }\n    }\n  total_compile_time += time_taken;\n  fprintf(outfile, \"Compile time %.4f milliseconds\\n\",\n    (((double)time_taken * 1000.0) / (double)timeit) /\n      (double)CLOCKS_PER_SEC);\n  }\n\n/* A final compile that is used \"for real\". */\n\nPCRE2_COMPILE(compiled_code, pbuffer, patlen, pat_patctl.options|use_forbid_utf,\n  &errorcode, &erroroffset, use_pat_context);\n\n/* Call the JIT compiler if requested. When timing, we must free and recompile\nthe pattern each time because that is the only way to free the JIT compiled\ncode. We know that compilation will always succeed. */\n\nif (TEST(compiled_code, !=, NULL) && pat_patctl.jit != 0)\n  {\n  if (timeit > 0)\n    {\n    int i;\n    clock_t time_taken = 0;\n\n    for (i = 0; i < timeit; i++)\n      {\n      clock_t start_time;\n      SUB1(pcre2_code_free, compiled_code);\n      PCRE2_COMPILE(compiled_code, pbuffer, patlen,\n        pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,\n        use_pat_context);\n      start_time = clock();\n      PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n      time_taken += clock() - start_time;\n      }\n    total_jit_compile_time += time_taken;\n    fprintf(outfile, \"JIT compile  %.4f milliseconds\\n\",\n      (((double)time_taken * 1000.0) / (double)timeit) /\n        (double)CLOCKS_PER_SEC);\n    }\n  else\n    {\n    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);\n    }\n  }\n\n/* If valgrind is supported, mark the pbuffer as accessible again. The 16-bit\nand 32-bit buffers can be marked completely undefined, but we must leave the\npattern in the 8-bit buffer defined because it may be read from a callout\nduring matching. */\n\n#ifdef SUPPORT_VALGRIND\n#ifdef SUPPORT_PCRE2_8\nif (test_mode == PCRE8_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer8 + valgrind_access_length,\n    pbuffer8_size - valgrind_access_length);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_16\nif (test_mode == PCRE16_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer16, pbuffer16_size);\n  }\n#endif\n#ifdef SUPPORT_PCRE2_32\nif (test_mode == PCRE32_MODE)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer32, pbuffer32_size);\n  }\n#endif\n#endif\n\n/* Compilation failed; go back for another re, skipping to blank line\nif non-interactive. */\n\nif (TEST(compiled_code, ==, NULL))\n  {\n  fprintf(outfile, \"Failed: error %d at offset %d: \", errorcode,\n    (int)erroroffset);\n  if (!print_error_message(errorcode, \"\", \"\\n\")) return PR_ABEND;\n  return PR_SKIP;\n  }\n\n/* If forbid_utf is non-zero, we are running a non-UTF test. UTF and UCP are\nlocked out at compile time, but we must also check for occurrences of \\P, \\p,\nand \\X, which are only supported when Unicode is supported. */\n\nif (forbid_utf != 0)\n  {\n  if ((FLD(compiled_code, flags) & PCRE2_HASBKPORX) != 0)\n    {\n    fprintf(outfile, \"** \\\\P, \\\\p, and \\\\X are not allowed after the \"\n      \"#forbid_utf command\\n\");\n    return PR_SKIP;\n    }\n  }\n\n/* Remember the maximum lookbehind, for partial matching. */\n\nif (pattern_info(PCRE2_INFO_MAXLOOKBEHIND, &maxlookbehind, FALSE) != 0)\n  return PR_ABEND;\n\n/* Remember the number of captures. */\n\nif (pattern_info(PCRE2_INFO_CAPTURECOUNT, &maxcapcount, FALSE) < 0)\n  return PR_ABEND;\n\n/* If an explicit newline modifier was given, set the information flag in the\npattern so that it is preserved over push/pop. */\n\nif ((pat_patctl.control2 & CTL2_NL_SET) != 0)\n  {\n  SETFLD(compiled_code, flags, FLD(compiled_code, flags) | PCRE2_NL_SET);\n  }\n\n/* Output code size and other information if requested. */\n\nif ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();\nif ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();\nif ((pat_patctl.control & CTL_ANYINFO) != 0)\n  {\n  int rc = show_pattern_info();\n  if (rc != PR_OK) return rc;\n  }\n\n/* The \"push\" control requests that the compiled pattern be remembered on a\nstack. This is mainly for testing the serialization functionality. */\n\nif ((pat_patctl.control & CTL_PUSH) != 0)\n  {\n  if (patstacknext >= PATSTACKSIZE)\n    {\n    fprintf(outfile, \"** Too many pushed patterns (max %d)\\n\", PATSTACKSIZE);\n    return PR_ABEND;\n    }\n  patstack[patstacknext++] = PTR(compiled_code);\n  SET(compiled_code, NULL);\n  }\n\n/* The \"pushcopy\" and \"pushtablescopy\" controls are similar, but push a\ncopy of the pattern, the latter with a copy of its character tables. This tests\nthe pcre2_code_copy() and pcre2_code_copy_with_tables() functions. */\n\nif ((pat_patctl.control & (CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)\n  {\n  if (patstacknext >= PATSTACKSIZE)\n    {\n    fprintf(outfile, \"** Too many pushed patterns (max %d)\\n\", PATSTACKSIZE);\n    return PR_ABEND;\n    }\n  if ((pat_patctl.control & CTL_PUSHCOPY) != 0)\n    {\n    PCRE2_CODE_COPY_TO_VOID(patstack[patstacknext++], compiled_code);\n    }\n  else\n    {\n    PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(patstack[patstacknext++],\n      compiled_code); }\n  }\n\nreturn PR_OK;\n}\n\n\n\n/*************************************************\n*          Check heap, match or depth limit      *\n*************************************************/\n\n/* This is used for DFA, normal, and JIT fast matching. For DFA matching it\nshould only be called with the third argument set to PCRE2_ERROR_DEPTHLIMIT.\n\nArguments:\n  pp        the subject string\n  ulen      length of subject or PCRE2_ZERO_TERMINATED\n  errnumber defines which limit to test\n  msg       string to include in final message\n\nReturns:    the return from the final match function call\n*/\n\nstatic int\ncheck_match_limit(uint8_t *pp, PCRE2_SIZE ulen, int errnumber, const char *msg)\n{\nint capcount;\nuint32_t min = 0;\nuint32_t mid = 64;\nuint32_t max = UINT32_MAX;\n\nPCRE2_SET_MATCH_LIMIT(dat_context, max);\nPCRE2_SET_DEPTH_LIMIT(dat_context, max);\nPCRE2_SET_HEAP_LIMIT(dat_context, max);\n\nfor (;;)\n  {\n  uint32_t stack_start = 0;\n\n  /* If we are checking the heap limit, free any frames vector that is cached\n  in the match_data so we always start without one. */\n\n  if (errnumber == PCRE2_ERROR_HEAPLIMIT)\n    {\n    PCRE2_SET_HEAP_LIMIT(dat_context, mid);\n\n#ifdef SUPPORT_PCRE2_8\n    if (code_unit_size == 1)\n      {\n      match_data8->memctl.free(match_data8->heapframes,\n        match_data8->memctl.memory_data);\n      match_data8->heapframes = NULL;\n      match_data8->heapframes_size = 0;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n    if (code_unit_size == 2)\n      {\n      match_data16->memctl.free(match_data16->heapframes,\n        match_data16->memctl.memory_data);\n      match_data16->heapframes = NULL;\n      match_data16->heapframes_size = 0;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n    if (code_unit_size == 4)\n      {\n      match_data32->memctl.free(match_data32->heapframes,\n        match_data32->memctl.memory_data);\n      match_data32->heapframes = NULL;\n      match_data32->heapframes_size = 0;\n      }\n#endif\n    }\n\n  /* No need to mess with the frames vector for match or depth limits. */\n\n  else if (errnumber == PCRE2_ERROR_MATCHLIMIT)\n    {\n    PCRE2_SET_MATCH_LIMIT(dat_context, mid);\n    }\n  else\n    {\n    PCRE2_SET_DEPTH_LIMIT(dat_context, mid);\n    }\n\n  /* Do the appropriate match */\n\n  if ((dat_datctl.control & CTL_DFA) != 0)\n    {\n    stack_start = DFA_START_RWS_SIZE/1024;\n    if (dfa_workspace == NULL)\n      dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n    if (dfa_matched++ == 0)\n      dfa_workspace[0] = -1;  /* To catch bad restart */\n    PCRE2_DFA_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data,\n      PTR(dat_context), dfa_workspace, DFA_WS_DIMENSION);\n    }\n\n  else if ((pat_patctl.control & CTL_JITFAST) != 0)\n    PCRE2_JIT_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, PTR(dat_context));\n\n  else\n    {\n    PCRE2_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, PTR(dat_context));\n    }\n\n  if (capcount == errnumber)\n    {\n    if ((mid & 0x80000000u) != 0)\n      {\n      fprintf(outfile, \"Can't find minimum %s limit: check pattern for \"\n        \"restriction\\n\", msg);\n      break;\n      }\n\n    min = mid;\n    mid = (mid == max - 1)? max : (max != UINT32_MAX)? (min + max)/2 : mid*2;\n    }\n  else if (capcount >= 0 ||\n           capcount == PCRE2_ERROR_NOMATCH ||\n           capcount == PCRE2_ERROR_PARTIAL)\n    {\n    /* If we've not hit the error with a heap limit less than the size of the\n    initial stack frame vector (for pcre2_match()) or the initial stack\n    workspace vector (for pcre2_dfa_match()), the heap is not being used, so\n    the minimum limit is zero; there's no need to go on. The other limits are\n    always greater than zero. */\n\n    if (errnumber == PCRE2_ERROR_HEAPLIMIT && mid < stack_start)\n      {\n      fprintf(outfile, \"Minimum %s limit = 0\\n\", msg);\n      break;\n      }\n    if (mid == min + 1)\n      {\n      fprintf(outfile, \"Minimum %s limit = %d\\n\", msg, mid);\n      break;\n      }\n    max = mid;\n    mid = (min + max)/2;\n    }\n  else break;    /* Some other error */\n  }\n\nreturn capcount;\n}\n\n\n\n/*************************************************\n*        Substitute callout function             *\n*************************************************/\n\n/* Called from pcre2_substitute() when the substitute_callout modifier is set.\nPrint out the data that is passed back. The substitute callout block is\nidentical for all code unit widths, so we just pick one.\n\nArguments:\n  scb         pointer to substitute callout block\n  data_ptr    callout data\n\nReturns:      nothing\n*/\n\nstatic int\nsubstitute_callout_function(pcre2_substitute_callout_block_8 *scb,\n  void *data_ptr)\n{\nint yield = 0;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n(void)data_ptr;   /* Not used */\n\nfprintf(outfile, \"%2d(%d) Old %\" SIZ_FORM \" %\" SIZ_FORM \" \\\"\",\n  scb->subscount, scb->oveccount,\n  scb->ovector[0], scb->ovector[1]);\n\nPCHARSV(scb->input, scb->ovector[0], scb->ovector[1] - scb->ovector[0],\n  utf, outfile);\n\nfprintf(outfile, \"\\\" New %\" SIZ_FORM \" %\" SIZ_FORM \" \\\"\",\n  scb->output_offsets[0], scb->output_offsets[1]);\n\nPCHARSV(scb->output, scb->output_offsets[0],\n  scb->output_offsets[1] - scb->output_offsets[0], utf, outfile);\n\nif (scb->subscount == dat_datctl.substitute_stop)\n  {\n  yield = -1;\n  fprintf(outfile, \" STOPPED\");\n  }\nelse if (scb->subscount == dat_datctl.substitute_skip)\n  {\n  yield = +1;\n  fprintf(outfile, \" SKIPPED\");\n  }\n\nfprintf(outfile, \"\\\"\\n\");\nreturn yield;\n}\n\n\n/*************************************************\n*              Callout function                  *\n*************************************************/\n\n/* Called from a PCRE2 library as a result of the (?C) item. We print out where\nwe are in the match (unless suppressed). Yield zero unless more callouts than\nthe fail count, or the callout data is not zero. The only differences in the\ncallout block for different code unit widths are that the pointers to the\nsubject, the most recent MARK, and a callout argument string point to strings\nof the appropriate width. Casts can be used to deal with this.\n\nArguments:\n  cb                a pointer to a callout block\n  callout_data_ptr  the provided callout data\n\nReturns:            0 or 1 or an error, as determined by settings\n*/\n\nstatic int\ncallout_function(pcre2_callout_block_8 *cb, void *callout_data_ptr)\n{\nFILE *f, *fdefault;\nuint32_t i, pre_start, post_start, subject_length;\nPCRE2_SIZE current_position;\nBOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\nBOOL callout_capture = (dat_datctl.control & CTL_CALLOUT_CAPTURE) != 0;\nBOOL callout_where = (dat_datctl.control2 & CTL2_CALLOUT_NO_WHERE) == 0;\n\n/* The FILE f is used for echoing the subject string if it is non-NULL. This\nhappens only once in simple cases, but we want to repeat after any additional\noutput caused by CALLOUT_EXTRA. */\n\nfdefault = (!first_callout && !callout_capture && cb->callout_string == NULL)?\n  NULL : outfile;\n\nif ((dat_datctl.control2 & CTL2_CALLOUT_EXTRA) != 0)\n  {\n  f = outfile;\n  switch (cb->callout_flags)\n    {\n    case PCRE2_CALLOUT_BACKTRACK:\n    fprintf(f, \"Backtrack\\n\");\n    break;\n\n    case PCRE2_CALLOUT_STARTMATCH|PCRE2_CALLOUT_BACKTRACK:\n    fprintf(f, \"Backtrack\\nNo other matching paths\\n\");\n    /* Fall through */\n\n    case PCRE2_CALLOUT_STARTMATCH:\n    fprintf(f, \"New match attempt\\n\");\n    break;\n\n    default:\n    f = fdefault;\n    break;\n    }\n  }\nelse f = fdefault;\n\n/* For a callout with a string argument, show the string first because there\nisn't a tidy way to fit it in the rest of the data. */\n\nif (cb->callout_string != NULL)\n  {\n  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);\n  fprintf(outfile, \"Callout (%\" SIZ_FORM \"): %c\",\n    cb->callout_string_offset, delimiter);\n  PCHARSV(cb->callout_string, 0,\n    cb->callout_string_length, utf, outfile);\n  for (i = 0; callout_start_delims[i] != 0; i++)\n    if (delimiter == callout_start_delims[i])\n      {\n      delimiter = callout_end_delims[i];\n      break;\n      }\n  fprintf(outfile, \"%c\", delimiter);\n  if (!callout_capture) fprintf(outfile, \"\\n\");\n  }\n\n/* Show captured strings if required */\n\nif (callout_capture)\n  {\n  if (cb->callout_string == NULL)\n    fprintf(outfile, \"Callout %d:\", cb->callout_number);\n  fprintf(outfile, \" last capture = %d\\n\", cb->capture_last);\n  for (i = 2; i < cb->capture_top * 2; i += 2)\n    {\n    fprintf(outfile, \"%2d: \", i/2);\n    if (cb->offset_vector[i] == PCRE2_UNSET)\n      fprintf(outfile, \"<unset>\");\n    else\n      {\n      PCHARSV(cb->subject, cb->offset_vector[i],\n        cb->offset_vector[i+1] - cb->offset_vector[i], utf, f);\n      }\n    fprintf(outfile, \"\\n\");\n    }\n  }\n\n/* Unless suppressed, re-print the subject in canonical form (with escapes for\nnon-printing characters), the first time, or if giving full details. On\nsubsequent calls in the same match, we use PCHARS() just to find the printed\nlengths of the substrings. */\n\nif (callout_where)\n  {\n  if (f != NULL) fprintf(f, \"--->\");\n\n  /* The subject before the match start. */\n\n  PCHARS(pre_start, cb->subject, 0, cb->start_match, utf, f);\n\n  /* If a lookbehind is involved, the current position may be earlier than the\n  match start. If so, use the match start instead. */\n\n  current_position = (cb->current_position >= cb->start_match)?\n    cb->current_position : cb->start_match;\n\n  /* The subject between the match start and the current position. */\n\n  PCHARS(post_start, cb->subject, cb->start_match,\n    current_position - cb->start_match, utf, f);\n\n  /* Print from the current position to the end. */\n\n  PCHARSV(cb->subject, current_position, cb->subject_length - current_position,\n    utf, f);\n\n  /* Calculate the total subject printed length (no print). */\n\n  PCHARS(subject_length, cb->subject, 0, cb->subject_length, utf, NULL);\n\n  if (f != NULL) fprintf(f, \"\\n\");\n\n  /* For automatic callouts, show the pattern offset. Otherwise, for a\n  numerical callout whose number has not already been shown with captured\n  strings, show the number here. A callout with a string argument has been\n  displayed above. */\n\n  if (cb->callout_number == 255)\n    {\n    fprintf(outfile, \"%+3d \", (int)cb->pattern_position);\n    if (cb->pattern_position > 99) fprintf(outfile, \"\\n    \");\n    }\n  else\n    {\n    if (callout_capture || cb->callout_string != NULL) fprintf(outfile, \"    \");\n      else fprintf(outfile, \"%3d \", cb->callout_number);\n    }\n\n  /* Now show position indicators */\n\n  for (i = 0; i < pre_start; i++) fprintf(outfile, \" \");\n  fprintf(outfile, \"^\");\n\n  if (post_start > 0)\n    {\n    for (i = 0; i < post_start - 1; i++) fprintf(outfile, \" \");\n    fprintf(outfile, \"^\");\n    }\n\n  for (i = 0; i < subject_length - pre_start - post_start + 4; i++)\n    fprintf(outfile, \" \");\n\n  if (cb->next_item_length != 0)\n    fprintf(outfile, \"%.*s\", (int)(cb->next_item_length),\n      pbuffer8 + cb->pattern_position);\n  else\n    fprintf(outfile, \"End of pattern\");\n\n  fprintf(outfile, \"\\n\");\n  }\n\nfirst_callout = FALSE;\n\n/* Show any mark info */\n\nif (cb->mark != last_callout_mark)\n  {\n  if (cb->mark == NULL)\n    fprintf(outfile, \"Latest Mark: <unset>\\n\");\n  else\n    {\n    fprintf(outfile, \"Latest Mark: \");\n    PCHARSV(cb->mark, -1, -1, utf, outfile);\n    putc('\\n', outfile);\n    }\n  last_callout_mark = cb->mark;\n  }\n\n/* Show callout data */\n\nif (callout_data_ptr != NULL)\n  {\n  int callout_data = *((int32_t *)callout_data_ptr);\n  if (callout_data != 0)\n    {\n    fprintf(outfile, \"Callout data = %d\\n\", callout_data);\n    return callout_data;\n    }\n  }\n\n/* Keep count and give the appropriate return code */\n\ncallout_count++;\n\nif (cb->callout_number == dat_datctl.cerror[0] &&\n    callout_count >= dat_datctl.cerror[1])\n  return PCRE2_ERROR_CALLOUT;\n\nif (cb->callout_number == dat_datctl.cfail[0] &&\n    callout_count >= dat_datctl.cfail[1])\n  return 1;\n\nreturn 0;\n}\n\n\n\n/*************************************************\n*       Handle *MARK and copy/get tests          *\n*************************************************/\n\n/* This function is called after complete and partial matches. It runs the\ntests for substring extraction.\n\nArguments:\n  utf       TRUE for utf\n  capcount  return from pcre2_match()\n\nReturns:    FALSE if print_error_message() fails\n*/\n\nstatic BOOL\ncopy_and_get(BOOL utf, int capcount)\n{\nint i;\nuint8_t *nptr;\n\n/* Test copy strings by number */\n\nfor (i = 0; i < MAXCPYGET && dat_datctl.copy_numbers[i] >= 0; i++)\n  {\n  int rc;\n  PCRE2_SIZE length, length2;\n  uint32_t copybuffer[256];\n  uint32_t n = (uint32_t)(dat_datctl.copy_numbers[i]);\n  length = sizeof(copybuffer)/code_unit_size;\n  PCRE2_SUBSTRING_COPY_BYNUMBER(rc, match_data, n, copybuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Copy substring %d failed (%d): \", n, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    PCRE2_SUBSTRING_LENGTH_BYNUMBER(rc, match_data, n, &length2);\n    if (rc < 0)\n      {\n      fprintf(outfile, \"Get substring %d length failed (%d): \", n, rc);\n      if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n      }\n    else if (length2 != length)\n      {\n      fprintf(outfile, \"Mismatched substring lengths: %\"\n        SIZ_FORM \" %\" SIZ_FORM \"\\n\", length, length2);\n      }\n    fprintf(outfile, \"%2dC \", n);\n    PCHARSV(copybuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \")\\n\", length);\n    }\n  }\n\n/* Test copy strings by name */\n\nnptr = dat_datctl.copy_names;\nfor (;;)\n  {\n  int rc;\n  int groupnumber;\n  PCRE2_SIZE length, length2;\n  uint32_t copybuffer[256];\n  int namelen = strlen((const char *)nptr);\n#if defined SUPPORT_PCRE2_16 || defined SUPPORT_PCRE2_32\n  PCRE2_SIZE cnl = namelen;\n#endif\n  if (namelen == 0) break;\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE) strcpy((char *)pbuffer8, (char *)nptr);\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)(void)to16(nptr, utf, &cnl);\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)(void)to32(nptr, utf, &cnl);\n#endif\n\n  PCRE2_SUBSTRING_NUMBER_FROM_NAME(groupnumber, compiled_code, pbuffer);\n  if (groupnumber < 0 && groupnumber != PCRE2_ERROR_NOUNIQUESUBSTRING)\n    fprintf(outfile, \"Number not found for group '%s'\\n\", nptr);\n\n  length = sizeof(copybuffer)/code_unit_size;\n  PCRE2_SUBSTRING_COPY_BYNAME(rc, match_data, pbuffer, copybuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Copy substring '%s' failed (%d): \", nptr, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    PCRE2_SUBSTRING_LENGTH_BYNAME(rc, match_data, pbuffer, &length2);\n    if (rc < 0)\n      {\n      fprintf(outfile, \"Get substring '%s' length failed (%d): \", nptr, rc);\n      if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n      }\n    else if (length2 != length)\n      {\n      fprintf(outfile, \"Mismatched substring lengths: %\"\n        SIZ_FORM \" %\" SIZ_FORM \"\\n\", length, length2);\n      }\n    fprintf(outfile, \"  C \");\n    PCHARSV(copybuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \") %s\", length, nptr);\n    if (groupnumber >= 0) fprintf(outfile, \" (group %d)\\n\", groupnumber);\n      else fprintf(outfile, \" (non-unique)\\n\");\n    }\n  nptr += namelen + 1;\n  }\n\n/* Test get strings by number */\n\nfor (i = 0; i < MAXCPYGET && dat_datctl.get_numbers[i] >= 0; i++)\n  {\n  int rc;\n  PCRE2_SIZE length;\n  void *gotbuffer;\n  uint32_t n = (uint32_t)(dat_datctl.get_numbers[i]);\n  PCRE2_SUBSTRING_GET_BYNUMBER(rc, match_data, n, &gotbuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Get substring %d failed (%d): \", n, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    fprintf(outfile, \"%2dG \", n);\n    PCHARSV(gotbuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \")\\n\", length);\n    PCRE2_SUBSTRING_FREE(gotbuffer);\n    }\n  }\n\n/* Test get strings by name */\n\nnptr = dat_datctl.get_names;\nfor (;;)\n  {\n  PCRE2_SIZE length;\n  void *gotbuffer;\n  int rc;\n  int groupnumber;\n  int namelen = strlen((const char *)nptr);\n#if defined SUPPORT_PCRE2_16 || defined SUPPORT_PCRE2_32\n  PCRE2_SIZE cnl = namelen;\n#endif\n  if (namelen == 0) break;\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE) strcpy((char *)pbuffer8, (char *)nptr);\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)(void)to16(nptr, utf, &cnl);\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)(void)to32(nptr, utf, &cnl);\n#endif\n\n  PCRE2_SUBSTRING_NUMBER_FROM_NAME(groupnumber, compiled_code, pbuffer);\n  if (groupnumber < 0 && groupnumber != PCRE2_ERROR_NOUNIQUESUBSTRING)\n    fprintf(outfile, \"Number not found for group '%s'\\n\", nptr);\n\n  PCRE2_SUBSTRING_GET_BYNAME(rc, match_data, pbuffer, &gotbuffer, &length);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Get substring '%s' failed (%d): \", nptr, rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    fprintf(outfile, \"  G \");\n    PCHARSV(gotbuffer, 0, length, utf, outfile);\n    fprintf(outfile, \" (%\" SIZ_FORM \") %s\", length, nptr);\n    if (groupnumber >= 0) fprintf(outfile, \" (group %d)\\n\", groupnumber);\n      else fprintf(outfile, \" (non-unique)\\n\");\n    PCRE2_SUBSTRING_FREE(gotbuffer);\n    }\n  nptr += namelen + 1;\n  }\n\n/* Test getting the complete list of captured strings. */\n\nif ((dat_datctl.control & CTL_GETALL) != 0)\n  {\n  int rc;\n  void **stringlist;\n  PCRE2_SIZE *lengths;\n  PCRE2_SUBSTRING_LIST_GET(rc, match_data, &stringlist, &lengths);\n  if (rc < 0)\n    {\n    fprintf(outfile, \"get substring list failed (%d): \", rc);\n    if (!print_error_message(rc, \"\", \"\\n\")) return FALSE;\n    }\n  else\n    {\n    for (i = 0; i < capcount; i++)\n      {\n      fprintf(outfile, \"%2dL \", i);\n      PCHARSV(stringlist[i], 0, lengths[i], utf, outfile);\n      putc('\\n', outfile);\n      }\n    if (stringlist[i] != NULL)\n      fprintf(outfile, \"string list not terminated by NULL\\n\");\n    PCRE2_SUBSTRING_LIST_FREE(stringlist);\n    }\n  }\n\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*            Show an entire ovector              *\n*************************************************/\n\n/* This function is called after partial matching or match failure, when the\n\"allvector\" modifier is set. It is a means of checking the contents of the\nentire ovector, to ensure no modification of fields that should be unchanged.\n\nArguments:\n  ovector      points to the ovector\n  oveccount    number of pairs\n\nReturns:       nothing\n*/\n\nstatic void\nshow_ovector(PCRE2_SIZE *ovector, uint32_t oveccount)\n{\nuint32_t i;\nfor (i = 0; i < 2*oveccount; i += 2)\n  {\n  PCRE2_SIZE start = ovector[i];\n  PCRE2_SIZE end = ovector[i+1];\n\n  fprintf(outfile, \"%2d: \", i/2);\n  if (start == PCRE2_UNSET && end == PCRE2_UNSET)\n    fprintf(outfile, \"<unset>\\n\");\n  else if (start == JUNK_OFFSET && end == JUNK_OFFSET)\n    fprintf(outfile, \"<unchanged>\\n\");\n  else\n    fprintf(outfile, \"%ld %ld\\n\", (unsigned long int)start,\n      (unsigned long int)end);\n  }\n}\n\n\n/*************************************************\n*               Process a data line              *\n*************************************************/\n\n/* The line is in buffer; it will not be empty.\n\nArguments:  none\n\nReturns:    PR_OK     continue processing next line\n            PR_SKIP   skip to a blank line\n            PR_ABEND  abort the pcre2test run\n*/\n\nstatic int\nprocess_data(void)\n{\nPCRE2_SIZE len, ulen, arg_ulen;\nuint32_t gmatched;\nuint32_t c, k;\nuint32_t g_notempty = 0;\nuint8_t *p, *pp, *start_rep;\nsize_t needlen;\nvoid *use_dat_context;\nBOOL utf;\nBOOL subject_literal;\n\nPCRE2_SIZE *ovector;\nPCRE2_SIZE ovecsave[3];\nuint32_t oveccount;\n\n#ifdef SUPPORT_PCRE2_8\nuint8_t *q8 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_16\nuint16_t *q16 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_32\nuint32_t *q32 = NULL;\n#endif\n\nsubject_literal = (pat_patctl.control2 & CTL2_SUBJECT_LITERAL) != 0;\n\n/* Copy the default context and data control blocks to the active ones. Then\ncopy from the pattern the controls that can be set in either the pattern or the\ndata. This allows them to be overridden in the data line. We do not do this for\noptions because those that are common apply separately to compiling and\nmatching. */\n\nDATCTXCPY(dat_context, default_dat_context);\nmemcpy(&dat_datctl, &def_datctl, sizeof(datctl));\ndat_datctl.control |= (pat_patctl.control & CTL_ALLPD);\ndat_datctl.control2 |= (pat_patctl.control2 & CTL2_ALLPD);\nstrcpy((char *)dat_datctl.replacement, (char *)pat_patctl.replacement);\nif (dat_datctl.jitstack == 0) dat_datctl.jitstack = pat_patctl.jitstack;\n\nif (dat_datctl.substitute_skip == 0)\n    dat_datctl.substitute_skip = pat_patctl.substitute_skip;\nif (dat_datctl.substitute_stop == 0)\n    dat_datctl.substitute_stop = pat_patctl.substitute_stop;\n\n/* Initialize for scanning the data line. */\n\n#ifdef SUPPORT_PCRE2_8\nutf = ((((pat_patctl.control & CTL_POSIX) != 0)?\n  ((pcre2_real_code_8 *)preg.re_pcre2_code)->overall_options :\n  FLD(compiled_code, overall_options)) & PCRE2_UTF) != 0;\n#else\nutf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;\n#endif\n\nstart_rep = NULL;\nlen = strlen((const char *)buffer);\nwhile (len > 0 && isspace(buffer[len-1])) len--;\nbuffer[len] = 0;\np = buffer;\nwhile (isspace(*p)) p++;\n\n/* Check that the data is well-formed UTF-8 if we're in UTF mode. To create\ninvalid input to pcre2_match(), you must use \\x?? or \\x{} sequences. */\n\nif (utf)\n  {\n  uint8_t *q;\n  uint32_t cc;\n  int n = 1;\n  for (q = p; n > 0 && *q; q += n) n = utf82ord(q, &cc);\n  if (n <= 0)\n    {\n    fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be used as input \"\n      \"in UTF mode\\n\");\n    return PR_OK;\n    }\n  }\n\n#ifdef SUPPORT_VALGRIND\n/* Mark the dbuffer as addressable but undefined again. */\nif (dbuffer != NULL)\n  {\n  VALGRIND_MAKE_MEM_UNDEFINED(dbuffer, dbuffer_size);\n  }\n#endif\n\n/* Allocate a buffer to hold the data line; len+1 is an upper bound on\nthe number of code units that will be needed (though the buffer may have to be\nextended if replication is involved). */\n\nneedlen = (size_t)((len+1) * code_unit_size);\nif (dbuffer == NULL || needlen >= dbuffer_size)\n  {\n  while (needlen >= dbuffer_size) dbuffer_size *= 2;\n  dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);\n  if (dbuffer == NULL)\n    {\n    fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);\n    exit(1);\n    }\n  }\nSETCASTPTR(q, dbuffer);  /* Sets q8, q16, or q32, as appropriate. */\n\n/* Scan the data line, interpreting data escapes, and put the result into a\nbuffer of the appropriate width. In UTF mode, input is always UTF-8; otherwise,\nin 16- and 32-bit modes, it can be forced to UTF-8 by the utf8_input modifier.\n*/\n\nwhile ((c = *p++) != 0)\n  {\n  int32_t i = 0;\n  size_t replen;\n\n  /* ] may mark the end of a replicated sequence */\n\n  if (c == ']' && start_rep != NULL)\n    {\n    long li;\n    char *endptr;\n\n    if (*p++ != '{')\n      {\n      fprintf(outfile, \"** Expected '{' after \\\\[....]\\n\");\n      return PR_OK;\n      }\n\n    li = strtol((const char *)p, &endptr, 10);\n    if (S32OVERFLOW(li))\n      {\n      fprintf(outfile, \"** Repeat count too large\\n\");\n      return PR_OK;\n      }\n\n    p = (uint8_t *)endptr;\n    if (*p++ != '}')\n      {\n      fprintf(outfile, \"** Expected '}' after \\\\[...]{...\\n\");\n      return PR_OK;\n      }\n\n    i = (int32_t)li;\n    if (i-- <= 0)\n      {\n      fprintf(outfile, \"** Zero or negative repeat not allowed\\n\");\n      return PR_OK;\n      }\n\n    replen = CAST8VAR(q) - start_rep;\n    needlen += replen * i;\n\n    if (needlen >= dbuffer_size)\n      {\n      size_t qoffset = CAST8VAR(q) - dbuffer;\n      size_t rep_offset = start_rep - dbuffer;\n      while (needlen >= dbuffer_size) dbuffer_size *= 2;\n      dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);\n      if (dbuffer == NULL)\n        {\n        fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);\n        exit(1);\n        }\n      SETCASTPTR(q, dbuffer + qoffset);\n      start_rep = dbuffer + rep_offset;\n      }\n\n    while (i-- > 0)\n      {\n      memcpy(CAST8VAR(q), start_rep, replen);\n      SETPLUS(q, replen/code_unit_size);\n      }\n\n    start_rep = NULL;\n    continue;\n    }\n\n  /* Handle a non-escaped character. In non-UTF 32-bit mode with utf8_input\n  set, do the fudge for setting the top bit. */\n\n  if (c != '\\\\' || subject_literal)\n    {\n    uint32_t topbit = 0;\n    if (test_mode == PCRE32_MODE && c == 0xff && *p != 0)\n      {\n      topbit = 0x80000000;\n      c = *p++;\n      }\n    if ((utf || (pat_patctl.control & CTL_UTF8_INPUT) != 0) &&\n      HASUTF8EXTRALEN(c)) { GETUTF8INC(c, p); }\n    c |= topbit;\n    }\n\n  /* Handle backslash escapes */\n\n  else switch ((c = *p++))\n    {\n    case '\\\\': break;\n    case 'a': c = CHAR_BEL; break;\n    case 'b': c = '\\b'; break;\n    case 'e': c = CHAR_ESC; break;\n    case 'f': c = '\\f'; break;\n    case 'n': c = '\\n'; break;\n    case 'r': c = '\\r'; break;\n    case 't': c = '\\t'; break;\n    case 'v': c = '\\v'; break;\n\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n    c -= '0';\n    while (i++ < 2 && isdigit(*p) && *p != '8' && *p != '9')\n      c = c * 8 + *p++ - '0';\n    break;\n\n    case 'o':\n    if (*p == '{')\n      {\n      uint8_t *pt = p;\n      c = 0;\n      for (pt++; isdigit(*pt) && *pt != '8' && *pt != '9'; pt++)\n        {\n        if (++i == 12)\n          fprintf(outfile, \"** Too many octal digits in \\\\o{...} item; \"\n                           \"using only the first twelve.\\n\");\n        else c = c * 8 + *pt - '0';\n        }\n      if (*pt == '}') p = pt + 1;\n        else fprintf(outfile, \"** Missing } after \\\\o{ (assumed)\\n\");\n      }\n    break;\n\n    case 'x':\n    if (*p == '{')\n      {\n      uint8_t *pt = p;\n      c = 0;\n\n      /* We used to have \"while (isxdigit(*(++pt)))\" here, but it fails\n      when isxdigit() is a macro that refers to its argument more than\n      once. This is banned by the C Standard, but apparently happens in at\n      least one MacOS environment. */\n\n      for (pt++; isxdigit(*pt); pt++)\n        {\n        if (++i == 9)\n          fprintf(outfile, \"** Too many hex digits in \\\\x{...} item; \"\n                           \"using only the first eight.\\n\");\n        else c = c * 16 + tolower(*pt) - ((isdigit(*pt))? '0' : 'a' - 10);\n        }\n      if (*pt == '}')\n        {\n        p = pt + 1;\n        break;\n        }\n      /* Not correct form for \\x{...}; fall through */\n      }\n\n    /* \\x without {} always defines just one byte in 8-bit mode. This\n    allows UTF-8 characters to be constructed byte by byte, and also allows\n    invalid UTF-8 sequences to be made. Just copy the byte in UTF-8 mode.\n    Otherwise, pass it down as data. */\n\n    c = 0;\n    while (i++ < 2 && isxdigit(*p))\n      {\n      c = c * 16 + tolower(*p) - ((isdigit(*p))? '0' : 'a' - 10);\n      p++;\n      }\n#if defined SUPPORT_PCRE2_8\n    if (utf && (test_mode == PCRE8_MODE))\n      {\n      *q8++ = c;\n      continue;\n      }\n#endif\n    break;\n\n    case 0:     /* \\ followed by EOF allows for an empty line */\n    p--;\n    continue;\n\n    case '=':   /* \\= terminates the data, starts modifiers */\n    goto ENDSTRING;\n\n    case '[':   /* \\[ introduces a replicated character sequence */\n    if (start_rep != NULL)\n      {\n      fprintf(outfile, \"** Nested replication is not supported\\n\");\n      return PR_OK;\n      }\n    start_rep = CAST8VAR(q);\n    continue;\n\n    default:\n    if (isalnum(c))\n      {\n      fprintf(outfile, \"** Unrecognized escape sequence \\\"\\\\%c\\\"\\n\", c);\n      return PR_OK;\n      }\n    }\n\n  /* We now have a character value in c that may be greater than 255.\n  In 8-bit mode we convert to UTF-8 if we are in UTF mode. Values greater\n  than 127 in UTF mode must have come from \\x{...} or octal constructs\n  because values from \\x.. get this far only in non-UTF mode. */\n\n#ifdef SUPPORT_PCRE2_8\n  if (test_mode == PCRE8_MODE)\n    {\n    if (utf)\n      {\n      if (c > 0x7fffffff)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 0x7fffffff \"\n          \"and so cannot be converted to UTF-8\\n\", c);\n        return PR_OK;\n        }\n      q8 += ord2utf8(c, q8);\n      }\n    else\n      {\n      if (c > 0xffu)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 255 \"\n          \"and UTF-8 mode is not enabled.\\n\", c);\n        fprintf(outfile, \"** Truncation will probably give the wrong \"\n          \"result.\\n\");\n        }\n      *q8++ = (uint8_t)c;\n      }\n    }\n#endif\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)\n    {\n    if (utf)\n      {\n      if (c > 0x10ffffu)\n        {\n        fprintf(outfile, \"** Failed: character \\\\x{%x} is greater than \"\n          \"0x10ffff and so cannot be converted to UTF-16\\n\", c);\n        return PR_OK;\n        }\n      else if (c >= 0x10000u)\n        {\n        c-= 0x10000u;\n        *q16++ = 0xD800 | (c >> 10);\n        *q16++ = 0xDC00 | (c & 0x3ff);\n        }\n      else\n        *q16++ = c;\n      }\n    else\n      {\n      if (c > 0xffffu)\n        {\n        fprintf(outfile, \"** Character \\\\x{%x} is greater than 0xffff \"\n          \"and UTF-16 mode is not enabled.\\n\", c);\n        fprintf(outfile, \"** Truncation will probably give the wrong \"\n          \"result.\\n\");\n        }\n\n      *q16++ = (uint16_t)c;\n      }\n    }\n#endif\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)\n    {\n    *q32++ = c;\n    }\n#endif\n  }\n\nENDSTRING:\nSET(*q, 0);\nlen = CASTVAR(uint8_t *, q) - dbuffer;    /* Length in bytes */\nulen = len/code_unit_size;                /* Length in code units */\narg_ulen = ulen;                          /* Value to use in match arg */\n\n/* If the string was terminated by \\= we must now interpret modifiers. */\n\nif (p[-1] != 0 && !decode_modifiers(p, CTX_DAT, NULL, &dat_datctl))\n  return PR_OK;\n\n/* Setting substitute_{skip,fail} implies a substitute callout. */\n\nif (dat_datctl.substitute_skip != 0 || dat_datctl.substitute_stop != 0)\n  dat_datctl.control2 |= CTL2_SUBSTITUTE_CALLOUT;\n\n/* Check for mutually exclusive modifiers. At present, these are all in the\nfirst control word. */\n\nfor (k = 0; k < sizeof(exclusive_dat_controls)/sizeof(uint32_t); k++)\n  {\n  c = dat_datctl.control & exclusive_dat_controls[k];\n  if (c != 0 && c != (c & (~c+1)))\n    {\n    show_controls(c, 0, \"** Not allowed together:\");\n    fprintf(outfile, \"\\n\");\n    return PR_OK;\n    }\n  }\n\nif (pat_patctl.replacement[0] != 0)\n  {\n  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0 &&\n      (dat_datctl.control & CTL_NULLCONTEXT) != 0)\n    {\n    fprintf(outfile, \"** Replacement callouts are not supported with null_context.\\n\");\n    return PR_OK;\n    }\n\n  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)\n    fprintf(outfile, \"** Ignored with replacement text: allcaptures\\n\");\n  }\n\n/* Warn for modifiers that are ignored for DFA. */\n\nif ((dat_datctl.control & CTL_DFA) != 0)\n  {\n  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)\n    fprintf(outfile, \"** Ignored after DFA matching: allcaptures\\n\");\n  }\n\n/* We now have the subject in dbuffer, with len containing the byte length, and\nulen containing the code unit length, with a copy in arg_ulen for use in match\nfunction arguments (this gets changed to PCRE2_ZERO_TERMINATED when the\nzero_terminate modifier is present).\n\nMove the data to the end of the buffer so that a read over the end can be\ncaught by valgrind or other means. If we have explicit valgrind support, mark\nthe unused start of the buffer unaddressable. If we are using the POSIX\ninterface, or testing zero-termination, we must include the terminating zero in\nthe usable data. */\n\nc = code_unit_size * (((pat_patctl.control & CTL_POSIX) +\n                       (dat_datctl.control & CTL_ZERO_TERMINATE) != 0)? 1:0);\npp = memmove(dbuffer + dbuffer_size - len - c, dbuffer, len + c);\n#ifdef SUPPORT_VALGRIND\n  VALGRIND_MAKE_MEM_NOACCESS(dbuffer, dbuffer_size - (len + c));\n#endif\n\n/* Now pp points to the subject string, but if null_subject was specified, set\nit to NULL to test PCRE2's behaviour. */\n\nif ((dat_datctl.control2 & CTL2_NULL_SUBJECT) != 0) pp = NULL;\n\n/* POSIX matching is only possible in 8-bit mode, and it does not support\ntiming or other fancy features. Some were checked at compile time, but we need\nto check the match-time settings here. */\n\n#ifdef SUPPORT_PCRE2_8\nif ((pat_patctl.control & CTL_POSIX) != 0)\n  {\n  int rc;\n  int eflags = 0;\n  regmatch_t *pmatch = NULL;\n  const char *msg = \"** Ignored with POSIX interface:\";\n\n  if (dat_datctl.cerror[0] != CFORE_UNSET || dat_datctl.cerror[1] != CFORE_UNSET)\n    prmsg(&msg, \"callout_error\");\n  if (dat_datctl.cfail[0] != CFORE_UNSET || dat_datctl.cfail[1] != CFORE_UNSET)\n    prmsg(&msg, \"callout_fail\");\n  if (dat_datctl.copy_numbers[0] >= 0 || dat_datctl.copy_names[0] != 0)\n    prmsg(&msg, \"copy\");\n  if (dat_datctl.get_numbers[0] >= 0 || dat_datctl.get_names[0] != 0)\n    prmsg(&msg, \"get\");\n  if (dat_datctl.jitstack != 0) prmsg(&msg, \"jitstack\");\n  if (dat_datctl.offset != 0) prmsg(&msg, \"offset\");\n\n  if ((dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS) != 0)\n    {\n    fprintf(outfile, \"%s\", msg);\n    show_match_options(dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS);\n    msg = \"\";\n    }\n  if ((dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS) != 0 ||\n      (dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2) != 0)\n    {\n    show_controls(dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS,\n                  dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2, msg);\n    msg = \"\";\n    }\n\n  if (msg[0] == 0) fprintf(outfile, \"\\n\");\n\n  if (dat_datctl.oveccount > 0)\n    {\n    pmatch = (regmatch_t *)malloc(sizeof(regmatch_t) * dat_datctl.oveccount);\n    if (pmatch == NULL)\n      {\n      fprintf(outfile, \"** Failed to get memory for recording matching \"\n        \"information (size set = %du)\\n\", dat_datctl.oveccount);\n      return PR_OK;\n      }\n    }\n\n  if (dat_datctl.startend[0] != CFORE_UNSET)\n    {\n    pmatch[0].rm_so = dat_datctl.startend[0];\n    pmatch[0].rm_eo = (dat_datctl.startend[1] != 0)?\n      dat_datctl.startend[1] : len;\n    eflags |= REG_STARTEND;\n    }\n\n  if ((dat_datctl.options & PCRE2_NOTBOL) != 0) eflags |= REG_NOTBOL;\n  if ((dat_datctl.options & PCRE2_NOTEOL) != 0) eflags |= REG_NOTEOL;\n  if ((dat_datctl.options & PCRE2_NOTEMPTY) != 0) eflags |= REG_NOTEMPTY;\n\n  rc = regexec(&preg, (const char *)pp, dat_datctl.oveccount, pmatch, eflags);\n  if (rc != 0)\n    {\n    (void)regerror(rc, &preg, (char *)pbuffer8, pbuffer8_size);\n    fprintf(outfile, \"No match: POSIX code %d: %s\\n\", rc, pbuffer8);\n    }\n  else if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0)\n    fprintf(outfile, \"Matched with REG_NOSUB\\n\");\n  else if (dat_datctl.oveccount == 0)\n    fprintf(outfile, \"Matched without capture\\n\");\n  else\n    {\n    size_t i, j;\n    size_t last_printed = (size_t)dat_datctl.oveccount;\n    for (i = 0; i < (size_t)dat_datctl.oveccount; i++)\n      {\n      if (pmatch[i].rm_so >= 0)\n        {\n        PCRE2_SIZE start = pmatch[i].rm_so;\n        PCRE2_SIZE end = pmatch[i].rm_eo;\n        for (j = last_printed + 1; j < i; j++)\n          fprintf(outfile, \"%2d: <unset>\\n\", (int)j);\n        last_printed = i;\n        if (start > end)\n          {\n          start = pmatch[i].rm_eo;\n          end = pmatch[i].rm_so;\n          fprintf(outfile, \"Start of matched string is beyond its end - \"\n            \"displaying from end to start.\\n\");\n          }\n        fprintf(outfile, \"%2d: \", (int)i);\n        PCHARSV(pp, start, end - start, utf, outfile);\n        fprintf(outfile, \"\\n\");\n\n        if ((i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0) ||\n            (dat_datctl.control & CTL_ALLAFTERTEXT) != 0)\n          {\n          fprintf(outfile, \"%2d+ \", (int)i);\n          /* Note: don't use the start/end variables here because we want to\n          show the text from what is reported as the end. */\n          PCHARSV(pp, pmatch[i].rm_eo, len - pmatch[i].rm_eo, utf, outfile);\n          fprintf(outfile, \"\\n\"); }\n        }\n      }\n    }\n  free(pmatch);\n  return PR_OK;\n  }\n#endif  /* SUPPORT_PCRE2_8 */\n\n /* Handle matching via the native interface. Check for consistency of\nmodifiers. */\n\nif (dat_datctl.startend[0] != CFORE_UNSET)\n  fprintf(outfile, \"** \\\\=posix_startend ignored for non-POSIX matching\\n\");\n\n/* ALLUSEDTEXT is not supported with JIT, but JIT is not used with DFA\nmatching, even if the JIT compiler was used. */\n\nif ((dat_datctl.control & (CTL_ALLUSEDTEXT|CTL_DFA)) == CTL_ALLUSEDTEXT &&\n    FLD(compiled_code, executable_jit) != NULL)\n  {\n  fprintf(outfile, \"** Showing all consulted text is not supported by JIT: ignored\\n\");\n  dat_datctl.control &= ~CTL_ALLUSEDTEXT;\n  }\n\n/* Handle passing the subject as zero-terminated. */\n\nif ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)\n  arg_ulen = PCRE2_ZERO_TERMINATED;\n\n/* The nullcontext modifier is used to test calling pcre2_[jit_]match() with a\nNULL context. */\n\nuse_dat_context = ((dat_datctl.control & CTL_NULLCONTEXT) != 0)?\n  NULL : PTR(dat_context);\n\n/* Enable display of malloc/free if wanted. We can do this only if either the\npattern or the subject is processed with a context. */\n\nshow_memory = (dat_datctl.control & CTL_MEMORY) != 0;\n\nif (show_memory &&\n    (pat_patctl.control & dat_datctl.control & CTL_NULLCONTEXT) != 0)\n  fprintf(outfile, \"** \\\\=memory requires either a pattern or a subject \"\n    \"context: ignored\\n\");\n\n/* Create and assign a JIT stack if requested. */\n\nif (dat_datctl.jitstack != 0)\n  {\n  if (dat_datctl.jitstack != jit_stack_size)\n    {\n    PCRE2_JIT_STACK_FREE(jit_stack);\n    PCRE2_JIT_STACK_CREATE(jit_stack, 1, dat_datctl.jitstack * 1024, NULL);\n    jit_stack_size = dat_datctl.jitstack;\n    }\n  PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, jit_stack);\n  }\n\n/* Or de-assign */\n\nelse if (jit_stack != NULL)\n  {\n  PCRE2_JIT_STACK_ASSIGN(dat_context, NULL, NULL);\n  PCRE2_JIT_STACK_FREE(jit_stack);\n  jit_stack = NULL;\n  jit_stack_size = 0;\n  }\n\n/* When no JIT stack is assigned, we must ensure that there is a JIT callback\nif we want to verify that JIT was actually used. */\n\nif ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_stack == NULL)\n   {\n   PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, NULL);\n   }\n\n/* Adjust match_data according to size of offsets required. A size of zero\ncauses a new match data block to be obtained that exactly fits the pattern. */\n\nif (dat_datctl.oveccount == 0)\n  {\n  PCRE2_MATCH_DATA_FREE(match_data);\n  PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code,\n    general_context);\n  PCRE2_GET_OVECTOR_COUNT(max_oveccount, match_data);\n  }\nelse if (dat_datctl.oveccount <= max_oveccount)\n  {\n  SETFLD(match_data, oveccount, dat_datctl.oveccount);\n  }\nelse\n  {\n  max_oveccount = dat_datctl.oveccount;\n  PCRE2_MATCH_DATA_FREE(match_data);\n  PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, general_context);\n  }\n\nif (CASTVAR(void *, match_data) == NULL)\n  {\n  fprintf(outfile, \"** Failed to get memory for recording matching \"\n    \"information (size requested: %d)\\n\", dat_datctl.oveccount);\n  max_oveccount = 0;\n  return PR_OK;\n  }\n\novector = FLD(match_data, ovector);\nPCRE2_GET_OVECTOR_COUNT(oveccount, match_data);\n\n/* Replacement processing is ignored for DFA matching. */\n\nif (dat_datctl.replacement[0] != 0 && (dat_datctl.control & CTL_DFA) != 0)\n  {\n  fprintf(outfile, \"** Ignored for DFA matching: replace\\n\");\n  dat_datctl.replacement[0] = 0;\n  }\n\n/* If a replacement string is provided, call pcre2_substitute() instead of one\nof the matching functions. First we have to convert the replacement string to\nthe appropriate width. */\n\nif (dat_datctl.replacement[0] != 0)\n  {\n  int rc;\n  uint8_t *pr;\n  uint8_t rbuffer[REPLACE_BUFFSIZE];\n  uint8_t nbuffer[REPLACE_BUFFSIZE];\n  uint8_t *rbptr;\n  uint32_t xoptions;\n  uint32_t emoption;  /* External match option */\n  PCRE2_SIZE j, rlen, nsize, erroroffset;\n  BOOL badutf = FALSE;\n\n#ifdef SUPPORT_PCRE2_8\n  uint8_t *r8 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_16\n  uint16_t *r16 = NULL;\n#endif\n#ifdef SUPPORT_PCRE2_32\n  uint32_t *r32 = NULL;\n#endif\n\n  /* Fill the ovector with junk to detect elements that do not get set\n  when they should be (relevant only when \"allvector\" is specified). */\n\n  for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;\n\n  if (timeitm)\n    fprintf(outfile, \"** Timing is not supported with replace: ignored\\n\");\n\n  if ((dat_datctl.control & CTL_ALTGLOBAL) != 0)\n    fprintf(outfile, \"** Altglobal is not supported with replace: ignored\\n\");\n\n  /* Check for a test that does substitution after an initial external match.\n  If this is set, we run the external match, but leave the interpretation of\n  its output to pcre2_substitute(). */\n\n  emoption = ((dat_datctl.control2 & CTL2_SUBSTITUTE_MATCHED) == 0)? 0 :\n    PCRE2_SUBSTITUTE_MATCHED;\n\n  if (emoption != 0)\n    {\n    PCRE2_MATCH(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,\n      dat_datctl.options, match_data, use_dat_context);\n    }\n\n  xoptions = emoption |\n             (((dat_datctl.control & CTL_GLOBAL) == 0)? 0 :\n                PCRE2_SUBSTITUTE_GLOBAL) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_EXTENDED) == 0)? 0 :\n                PCRE2_SUBSTITUTE_EXTENDED) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_LITERAL) == 0)? 0 :\n                PCRE2_SUBSTITUTE_LITERAL) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) == 0)? 0 :\n                PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) == 0)? 0 :\n                PCRE2_SUBSTITUTE_REPLACEMENT_ONLY) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) == 0)? 0 :\n                PCRE2_SUBSTITUTE_UNKNOWN_UNSET) |\n             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNSET_EMPTY) == 0)? 0 :\n                PCRE2_SUBSTITUTE_UNSET_EMPTY);\n\n  SETCASTPTR(r, rbuffer);  /* Sets r8, r16, or r32, as appropriate. */\n  pr = dat_datctl.replacement;\n\n  /* If the replacement starts with '[<number>]' we interpret that as length\n  value for the replacement buffer. */\n\n  nsize = REPLACE_BUFFSIZE/code_unit_size;\n  if (*pr == '[')\n    {\n    PCRE2_SIZE n = 0;\n    while ((c = *(++pr)) >= CHAR_0 && c <= CHAR_9) n = n * 10 + c - CHAR_0;\n    if (*pr++ != ']')\n      {\n      fprintf(outfile, \"Bad buffer size in replacement string\\n\");\n      return PR_OK;\n      }\n    if (n > nsize)\n      {\n      fprintf(outfile, \"Replacement buffer setting (%\" SIZ_FORM \") is too \"\n        \"large (max %\" SIZ_FORM \")\\n\", n, nsize);\n      return PR_OK;\n      }\n    nsize = n;\n    }\n\n  /* Now copy the replacement string to a buffer of the appropriate width. No\n  escape processing is done for replacements. In UTF mode, check for an invalid\n  UTF-8 input string, and if it is invalid, just copy its code units without\n  UTF interpretation. This provides a means of checking that an invalid string\n  is detected. Otherwise, UTF-8 can be used to include wide characters in a\n  replacement. */\n\n  if (utf) badutf = valid_utf(pr, strlen((const char *)pr), &erroroffset);\n\n  /* Not UTF or invalid UTF-8: just copy the code units. */\n\n  if (!utf || badutf)\n    {\n    while ((c = *pr++) != 0)\n      {\n#ifdef SUPPORT_PCRE2_8\n      if (test_mode == PCRE8_MODE) *r8++ = c;\n#endif\n#ifdef SUPPORT_PCRE2_16\n      if (test_mode == PCRE16_MODE) *r16++ = c;\n#endif\n#ifdef SUPPORT_PCRE2_32\n      if (test_mode == PCRE32_MODE) *r32++ = c;\n#endif\n      }\n    }\n\n  /* Valid UTF-8 replacement string */\n\n  else while ((c = *pr++) != 0)\n    {\n    if (HASUTF8EXTRALEN(c)) { GETUTF8INC(c, pr); }\n\n#ifdef SUPPORT_PCRE2_8\n    if (test_mode == PCRE8_MODE) r8 += ord2utf8(c, r8);\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n    if (test_mode == PCRE16_MODE)\n      {\n      if (c >= 0x10000u)\n        {\n        c-= 0x10000u;\n        *r16++ = 0xD800 | (c >> 10);\n        *r16++ = 0xDC00 | (c & 0x3ff);\n        }\n      else *r16++ = c;\n      }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n    if (test_mode == PCRE32_MODE) *r32++ = c;\n#endif\n    }\n\n  SET(*r, 0);\n  if ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)\n    rlen = PCRE2_ZERO_TERMINATED;\n  else\n    rlen = (CASTVAR(uint8_t *, r) - rbuffer)/code_unit_size;\n\n  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0)\n    {\n    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, substitute_callout_function, NULL);\n    }\n  else\n    {\n    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, NULL, NULL);  /* No callout */\n    }\n\n  /* There is a special option to set the replacement to NULL in order to test\n  that case. */\n\n  rbptr = ((dat_datctl.control2 & CTL2_NULL_REPLACEMENT) == 0)? rbuffer : NULL;\n\n  PCRE2_SUBSTITUTE(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,\n    dat_datctl.options|xoptions, match_data, use_dat_context,\n    rbptr, rlen, nbuffer, &nsize);\n\n  if (rc < 0)\n    {\n    fprintf(outfile, \"Failed: error %d\", rc);\n    if (rc != PCRE2_ERROR_NOMEMORY && nsize != PCRE2_UNSET)\n      fprintf(outfile, \" at offset %ld in replacement\", (long int)nsize);\n    fprintf(outfile, \": \");\n    if (!print_error_message(rc, \"\", \"\")) return PR_ABEND;\n    if (rc == PCRE2_ERROR_NOMEMORY &&\n        (xoptions & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)\n      fprintf(outfile, \": %ld code units are needed\", (long int)nsize);\n    }\n  else\n    {\n    fprintf(outfile, \"%2d: \", rc);\n    PCHARSV(nbuffer, 0, nsize, utf, outfile);\n    }\n\n  fprintf(outfile, \"\\n\");\n  show_memory = FALSE;\n\n  /* Show final ovector contents if requested. */\n\n  if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n    show_ovector(ovector, oveccount);\n\n  return PR_OK;\n  }   /* End of substitution handling */\n\n/* When a replacement string is not provided, run a loop for global matching\nwith one of the basic matching functions. For altglobal (or first time round\nthe loop), set an \"unset\" value for the previous match info. */\n\novecsave[0] = ovecsave[1] = ovecsave[2] = PCRE2_UNSET;\n\nfor (gmatched = 0;; gmatched++)\n  {\n  PCRE2_SIZE j;\n  int capcount;\n\n  /* Fill the ovector with junk to detect elements that do not get set\n  when they should be. */\n\n  for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;\n\n  /* When matching is via pcre2_match(), we will detect the use of JIT via the\n  stack callback function. */\n\n  jit_was_used = (pat_patctl.control & CTL_JITFAST) != 0;\n\n  /* Do timing if required. */\n\n  if (timeitm > 0)\n    {\n    int i;\n    clock_t start_time, time_taken;\n\n    if ((dat_datctl.control & CTL_DFA) != 0)\n      {\n      if ((dat_datctl.options & PCRE2_DFA_RESTART) != 0)\n        {\n        fprintf(outfile, \"Timing DFA restarts is not supported\\n\");\n        return PR_OK;\n        }\n      if (dfa_workspace == NULL)\n        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context, dfa_workspace, DFA_WS_DIMENSION);\n        }\n      }\n\n    else if ((pat_patctl.control & CTL_JITFAST) != 0)\n      {\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context);\n        }\n      }\n\n    else\n      {\n      start_time = clock();\n      for (i = 0; i < timeitm; i++)\n        {\n        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen,\n          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n          use_dat_context);\n        }\n      }\n    total_match_time += (time_taken = clock() - start_time);\n    fprintf(outfile, \"Match time %.4f milliseconds\\n\",\n      (((double)time_taken * 1000.0) / (double)timeitm) /\n        (double)CLOCKS_PER_SEC);\n    }\n\n  /* Find the heap, match and depth limits if requested. The depth and heap\n  limits are not relevant for JIT. The return from check_match_limit() is the\n  return from the final call to pcre2_match() or pcre2_dfa_match(). */\n\n  if ((dat_datctl.control & (CTL_FINDLIMITS|CTL_FINDLIMITS_NOHEAP)) != 0)\n    {\n    capcount = 0;  /* This stops compiler warnings */\n\n    if ((dat_datctl.control & CTL_FINDLIMITS_NOHEAP) == 0 &&\n        (FLD(compiled_code, executable_jit) == NULL ||\n          (dat_datctl.options & PCRE2_NO_JIT) != 0))\n      {\n      (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, \"heap\");\n      }\n\n    capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,\n      \"match\");\n\n    if (FLD(compiled_code, executable_jit) == NULL ||\n        (dat_datctl.options & PCRE2_NO_JIT) != 0 ||\n        (dat_datctl.control & CTL_DFA) != 0)\n      {\n      capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_DEPTHLIMIT,\n        \"depth\");\n      }\n\n    if (capcount == 0)\n      {\n      fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");\n      capcount = dat_datctl.oveccount;\n      }\n    }\n\n  /* Otherwise just run a single match, setting up a callout if required (the\n  default). There is a copy of the pattern in pbuffer8 for use by callouts. */\n\n  else\n    {\n    if ((dat_datctl.control & CTL_CALLOUT_NONE) == 0)\n      {\n      PCRE2_SET_CALLOUT(dat_context, callout_function,\n        (void *)(&dat_datctl.callout_data));\n      first_callout = TRUE;\n      last_callout_mark = NULL;\n      callout_count = 0;\n      }\n    else\n      {\n      PCRE2_SET_CALLOUT(dat_context, NULL, NULL);  /* No callout */\n      }\n\n    /* Run a single DFA or NFA match. */\n\n    if ((dat_datctl.control & CTL_DFA) != 0)\n      {\n      if (dfa_workspace == NULL)\n        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));\n      if (dfa_matched++ == 0)\n        dfa_workspace[0] = -1;  /* To catch bad restart */\n      PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,\n        dat_datctl.offset, dat_datctl.options | g_notempty, match_data,\n        use_dat_context, dfa_workspace, DFA_WS_DIMENSION);\n      if (capcount == 0)\n        {\n        fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");\n        capcount = dat_datctl.oveccount;\n        }\n      }\n    else\n      {\n      if ((pat_patctl.control & CTL_JITFAST) != 0)\n        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,\n          dat_datctl.options | g_notempty, match_data, use_dat_context);\n      else\n        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,\n          dat_datctl.options | g_notempty, match_data, use_dat_context);\n      if (capcount == 0)\n        {\n        fprintf(outfile, \"Matched, but too many substrings\\n\");\n        capcount = dat_datctl.oveccount;\n        }\n      }\n    }\n\n  /* The result of the match is now in capcount. First handle a successful\n  match. If pp was forced to be NULL (to test NULL handling) it will have been\n  treated as an empty string if the length was zero. So re-create that for\n  outputting. */\n\n  if (capcount >= 0)\n    {\n    int i;\n\n    if (pp == NULL) pp = (uint8_t *)\"\";\n\n    if (capcount > (int)oveccount)   /* Check for lunatic return value */\n      {\n      fprintf(outfile,\n        \"** PCRE2 error: returned count %d is too big for ovector count %d\\n\",\n        capcount, oveccount);\n      capcount = oveccount;\n      if ((dat_datctl.control & CTL_ANYGLOB) != 0)\n        {\n        fprintf(outfile, \"** Global loop abandoned\\n\");\n        dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */\n        }\n      }\n\n    /* If PCRE2_COPY_MATCHED_SUBJECT was set, check that things are as they\n    should be, but not for fast JIT, where it isn't supported. */\n\n    if ((dat_datctl.options & PCRE2_COPY_MATCHED_SUBJECT) != 0 &&\n        (pat_patctl.control & CTL_JITFAST) == 0)\n      {\n      if ((FLD(match_data, flags) & PCRE2_MD_COPIED_SUBJECT) == 0)\n        fprintf(outfile,\n          \"** PCRE2 error: flag not set after copy_matched_subject\\n\");\n\n      if (CASTFLD(void *, match_data, subject) == pp)\n        fprintf(outfile,\n          \"** PCRE2 error: copy_matched_subject has not copied\\n\");\n\n      if (memcmp(CASTFLD(void *, match_data, subject), pp, ulen) != 0)\n        fprintf(outfile,\n          \"** PCRE2 error: copy_matched_subject mismatch\\n\");\n      }\n\n    /* If this is not the first time round a global loop, check that the\n    returned string has changed. If it has not, check for an empty string match\n    at different starting offset from the previous match. This is a failed test\n    retry for null-matching patterns that don't match at their starting offset,\n    for example /(?<=\\G.)/. A repeated match at the same point is not such a\n    pattern, and must be discarded, and we then proceed to seek a non-null\n    match at the current point. For any other repeated match, there is a bug\n    somewhere and we must break the loop because it will go on for ever. We\n    know that there are always at least two elements in the ovector. */\n\n    if (gmatched > 0 && ovecsave[0] == ovector[0] && ovecsave[1] == ovector[1])\n      {\n      if (ovector[0] == ovector[1] && ovecsave[2] != dat_datctl.offset)\n        {\n        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n        ovecsave[2] = dat_datctl.offset;\n        continue;    /* Back to the top of the loop */\n        }\n      fprintf(outfile,\n        \"** PCRE2 error: global repeat returned the same string as previous\\n\");\n      fprintf(outfile, \"** Global loop abandoned\\n\");\n      dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */\n      }\n\n    /* \"allcaptures\" requests showing of all captures in the pattern, to check\n    unset ones at the end. It may be set on the pattern or the data. Implement\n    by setting capcount to the maximum. This is not relevant for DFA matching,\n    so ignore it (warning given above). */\n\n    if ((dat_datctl.control & (CTL_ALLCAPTURES|CTL_DFA)) == CTL_ALLCAPTURES)\n      {\n      capcount = maxcapcount + 1;   /* Allow for full match */\n      if (capcount > (int)oveccount) capcount = oveccount;\n      }\n\n    /* \"allvector\" request showing the entire ovector. */\n\n    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0) capcount = oveccount;\n\n    /* Output the captured substrings. Note that, for the matched string,\n    the use of \\K in an assertion can make the start later than the end. */\n\n    for (i = 0; i < 2*capcount; i += 2)\n      {\n      PCRE2_SIZE lleft, lmiddle, lright;\n      PCRE2_SIZE start = ovector[i];\n      PCRE2_SIZE end = ovector[i+1];\n\n      if (start > end)\n        {\n        start = ovector[i+1];\n        end = ovector[i];\n        fprintf(outfile, \"Start of matched string is beyond its end - \"\n          \"displaying from end to start.\\n\");\n        }\n\n      fprintf(outfile, \"%2d: \", i/2);\n\n      /* Check for an unset group */\n\n      if (start == PCRE2_UNSET && end == PCRE2_UNSET)\n        {\n        fprintf(outfile, \"<unset>\\n\");\n        continue;\n        }\n\n      /* Check for silly offsets, in particular, values that have not been\n      set when they should have been. However, if we are past the end of the\n      captures for this pattern (\"allvector\" causes this), or if we are DFA\n      matching, it isn't an error if the entry is unchanged. */\n\n      if (start > ulen || end > ulen)\n        {\n        if (((dat_datctl.control & CTL_DFA) != 0 ||\n              i >= (int)(2*maxcapcount + 2)) &&\n            start == JUNK_OFFSET && end == JUNK_OFFSET)\n          fprintf(outfile, \"<unchanged>\\n\");\n        else\n          fprintf(outfile, \"ERROR: bad value(s) for offset(s): 0x%lx 0x%lx\\n\",\n            (unsigned long int)start, (unsigned long int)end);\n        continue;\n        }\n\n      /* When JIT is not being used, ALLUSEDTEXT may be set. (It if is set with\n      JIT, it is disabled above, with a comment.) When the match is done by the\n      interpreter, leftchar and rightchar are available, and if ALLUSEDTEXT is\n      set, and if the leftmost consulted character is before the start of the\n      match or the rightmost consulted character is past the end of the match,\n      we want to show all consulted characters for the main matched string, and\n      indicate which were lookarounds. */\n\n      if (i == 0)\n        {\n        BOOL showallused;\n        PCRE2_SIZE leftchar, rightchar;\n\n        if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)\n          {\n          leftchar = FLD(match_data, leftchar);\n          rightchar = FLD(match_data, rightchar);\n          showallused = i == 0 && (leftchar < start || rightchar > end);\n          }\n        else showallused = FALSE;\n\n        if (showallused)\n          {\n          PCHARS(lleft, pp, leftchar, start - leftchar, utf, outfile);\n          PCHARS(lmiddle, pp, start, end - start, utf, outfile);\n          PCHARS(lright, pp, end, rightchar - end, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          fprintf(outfile, \"\\n    \");\n          for (j = 0; j < lleft; j++) fprintf(outfile, \"<\");\n          for (j = 0; j < lmiddle; j++) fprintf(outfile, \" \");\n          for (j = 0; j < lright; j++) fprintf(outfile, \">\");\n          }\n\n        /* When a pattern contains \\K, the start of match position may be\n        different to the start of the matched string. When this is the case,\n        show it when requested. */\n\n        else if ((dat_datctl.control & CTL_STARTCHAR) != 0)\n          {\n          PCRE2_SIZE startchar;\n          PCRE2_GET_STARTCHAR(startchar, match_data);\n          PCHARS(lleft, pp, startchar, start - startchar, utf, outfile);\n          PCHARSV(pp, start, end - start, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          if (startchar != start)\n            {\n            fprintf(outfile, \"\\n    \");\n            for (j = 0; j < lleft; j++) fprintf(outfile, \"^\");\n            }\n          }\n\n        /* Otherwise, just show the matched string. */\n\n        else\n          {\n          PCHARSV(pp, start, end - start, utf, outfile);\n          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n            fprintf(outfile, \" (JIT)\");\n          }\n        }\n\n      /* Not the main matched string. Just show it unadorned. */\n\n      else\n        {\n        PCHARSV(pp, start, end - start, utf, outfile);\n        }\n\n      fprintf(outfile, \"\\n\");\n\n      /* Note: don't use the start/end variables here because we want to\n      show the text from what is reported as the end. */\n\n      if ((dat_datctl.control & CTL_ALLAFTERTEXT) != 0 ||\n          (i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0))\n        {\n        fprintf(outfile, \"%2d+ \", i/2);\n        PCHARSV(pp, ovector[i+1], ulen - ovector[i+1], utf, outfile);\n        fprintf(outfile, \"\\n\");\n        }\n      }\n\n    /* Output (*MARK) data if requested */\n\n    if ((dat_datctl.control & CTL_MARK) != 0 &&\n         TESTFLD(match_data, mark, !=, NULL))\n      {\n      fprintf(outfile, \"MK: \");\n      PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);\n      fprintf(outfile, \"\\n\");\n      }\n\n    /* Process copy/get strings */\n\n    if (!copy_and_get(utf, capcount)) return PR_ABEND;\n\n    }    /* End of handling a successful match */\n\n  /* There was a partial match. The value of ovector[0] is the bumpalong point,\n  that is, startchar, not any \\K point that might have been passed. When JIT is\n  not in use, \"allusedtext\" may be set, in which case we indicate the leftmost\n  consulted character. */\n\n  else if (capcount == PCRE2_ERROR_PARTIAL)\n    {\n    PCRE2_SIZE leftchar;\n    int backlength;\n    int rubriclength = 0;\n\n    if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)\n      {\n      leftchar = FLD(match_data, leftchar);\n      }\n    else leftchar = ovector[0];\n\n    fprintf(outfile, \"Partial match\");\n    if ((dat_datctl.control & CTL_MARK) != 0 &&\n         TESTFLD(match_data, mark, !=, NULL))\n      {\n      fprintf(outfile, \", mark=\");\n      PCHARS(rubriclength, CASTFLD(void *, match_data, mark), -1, -1, utf,\n        outfile);\n      rubriclength += 7;\n      }\n    fprintf(outfile, \": \");\n    rubriclength += 15;\n\n    PCHARS(backlength, pp, leftchar, ovector[0] - leftchar, utf, outfile);\n    PCHARSV(pp, ovector[0], ulen - ovector[0], utf, outfile);\n\n    if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n      fprintf(outfile, \" (JIT)\");\n    fprintf(outfile, \"\\n\");\n\n    if (backlength != 0)\n      {\n      int i;\n      for (i = 0; i < rubriclength; i++) fprintf(outfile, \" \");\n      for (i = 0; i < backlength; i++) fprintf(outfile, \"<\");\n      fprintf(outfile, \"\\n\");\n      }\n\n    if (ulen != ovector[1])\n      fprintf(outfile, \"** ovector[1] is not equal to the subject length: \"\n        \"%ld != %ld\\n\", (unsigned long int)ovector[1], (unsigned long int)ulen);\n\n    /* Process copy/get strings */\n\n    if (!copy_and_get(utf, 1)) return PR_ABEND;\n\n    /* \"allvector\" outputs the entire vector */\n\n    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n      show_ovector(ovector, oveccount);\n\n    break;  /* Out of the /g loop */\n    }       /* End of handling partial match */\n\n  /* Failed to match. If this is a /g or /G loop, we might previously have\n  set g_notempty (to PCRE2_NOTEMPTY_ATSTART|PCRE2_ANCHORED) after a null match.\n  If that is the case, this is not necessarily the end. We want to advance the\n  start offset, and continue. We won't be at the end of the string - that was\n  checked before setting g_notempty. We achieve the effect by pretending that a\n  single character was matched.\n\n  Complication arises in the case when the newline convention is \"any\", \"crlf\",\n  or \"anycrlf\". If the previous match was at the end of a line terminated by\n  CRLF, an advance of one character just passes the CR, whereas we should\n  prefer the longer newline sequence, as does the code in pcre2_match().\n\n  Otherwise, in the case of UTF-8 or UTF-16 matching, the advance must be one\n  character, not one byte. */\n\n  else if (g_notempty != 0)   /* There was a previous null match */\n    {\n    uint16_t nl = FLD(compiled_code, newline_convention);\n    PCRE2_SIZE start_offset = dat_datctl.offset;    /* Where the match was */\n    PCRE2_SIZE end_offset = start_offset + 1;\n\n    if ((nl == PCRE2_NEWLINE_CRLF || nl == PCRE2_NEWLINE_ANY ||\n         nl == PCRE2_NEWLINE_ANYCRLF) &&\n        start_offset < ulen - 1 &&\n        CODE_UNIT(pp, start_offset) == '\\r' &&\n        CODE_UNIT(pp, end_offset) == '\\n')\n      end_offset++;\n\n    else if (utf && test_mode != PCRE32_MODE)\n      {\n      if (test_mode == PCRE8_MODE)\n        {\n        for (; end_offset < ulen; end_offset++)\n          if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;\n        }\n      else  /* 16-bit mode */\n        {\n        for (; end_offset < ulen; end_offset++)\n          if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;\n        }\n      }\n\n    SETFLDVEC(match_data, ovector, 0, start_offset);\n    SETFLDVEC(match_data, ovector, 1, end_offset);\n    }  /* End of handling null match in a global loop */\n\n  /* A \"normal\" match failure. There will be a negative error number in\n  capcount. */\n\n  else\n    {\n    switch(capcount)\n      {\n      case PCRE2_ERROR_NOMATCH:\n      if (gmatched == 0)\n        {\n        fprintf(outfile, \"No match\");\n        if ((dat_datctl.control & CTL_MARK) != 0 &&\n             TESTFLD(match_data, mark, !=, NULL))\n          {\n          fprintf(outfile, \", mark = \");\n          PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);\n          }\n        if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)\n          fprintf(outfile, \" (JIT)\");\n        fprintf(outfile, \"\\n\");\n\n        /* \"allvector\" outputs the entire vector */\n\n        if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)\n          show_ovector(ovector, oveccount);\n        }\n      break;\n\n      case PCRE2_ERROR_BADUTFOFFSET:\n      fprintf(outfile, \"Error %d (bad UTF-%d offset)\\n\", capcount, test_mode);\n      break;\n\n      default:\n      fprintf(outfile, \"Failed: error %d: \", capcount);\n      if (!print_error_message(capcount, \"\", \"\")) return PR_ABEND;\n      if (capcount <= PCRE2_ERROR_UTF8_ERR1 &&\n          capcount >= PCRE2_ERROR_UTF32_ERR2)\n        {\n        PCRE2_SIZE startchar;\n        PCRE2_GET_STARTCHAR(startchar, match_data);\n        fprintf(outfile, \" at offset %\" SIZ_FORM, startchar);\n        }\n      fprintf(outfile, \"\\n\");\n      break;\n      }\n\n    break;  /* Out of the /g loop */\n    }       /* End of failed match handling */\n\n  /* Control reaches here in two circumstances: (a) after a match, and (b)\n  after a non-match that immediately followed a match on an empty string when\n  doing a global search. Such a match is done with PCRE2_NOTEMPTY_ATSTART and\n  PCRE2_ANCHORED set in g_notempty. The code above turns it into a fake match\n  of one character. So effectively we get here only after a match. If we\n  are not doing a global search, we are done. */\n\n  if ((dat_datctl.control & CTL_ANYGLOB) == 0) break; else\n    {\n    PCRE2_SIZE match_offset = FLD(match_data, ovector)[0];\n    PCRE2_SIZE end_offset = FLD(match_data, ovector)[1];\n\n    /* We must now set up for the next iteration of a global search. If we have\n    matched an empty string, first check to see if we are at the end of the\n    subject. If so, the loop is over. Otherwise, mimic what Perl's /g option\n    does. Set PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED and try the match again\n    at the same point. If this fails it will be picked up above, where a fake\n    match is set up so that at this point we advance to the next character.\n\n    However, in order to cope with patterns that never match at their starting\n    offset (e.g. /(?<=\\G.)/) we don't do this when the match offset is greater\n    than the starting offset. This means there will be a retry with the\n    starting offset at the match offset. If this returns the same match again,\n    it is picked up above and ignored, and the special action is then taken. */\n\n    if (match_offset == end_offset)\n      {\n      if (end_offset == ulen) break;           /* End of subject */\n      if (match_offset <= dat_datctl.offset)\n        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;\n      }\n\n    /* However, even after matching a non-empty string, there is still one\n    tricky case. If a pattern contains \\K within a lookbehind assertion at the\n    start, the end of the matched string can be at the offset where the match\n    started. In the case of a normal /g iteration without special action, this\n    leads to a loop that keeps on returning the same substring. The loop would\n    be caught above, but we really want to move on to the next match. */\n\n    else\n      {\n      g_notempty = 0;   /* Set for a \"normal\" repeat */\n      if ((dat_datctl.control & CTL_GLOBAL) != 0)\n        {\n        PCRE2_SIZE startchar;\n        PCRE2_GET_STARTCHAR(startchar, match_data);\n        if (end_offset <= startchar)\n          {\n          if (startchar >= ulen) break;       /* End of subject */\n          end_offset = startchar + 1;\n          if (utf && test_mode != PCRE32_MODE)\n            {\n            if (test_mode == PCRE8_MODE)\n              {\n              for (; end_offset < ulen; end_offset++)\n                if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;\n              }\n            else  /* 16-bit mode */\n              {\n              for (; end_offset < ulen; end_offset++)\n                if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;\n              }\n            }\n          }\n        }\n      }\n\n    /* For a normal global (/g) iteration, save the current ovector[0,1] and\n    the starting offset so that we can check that they do change each time.\n    Otherwise a matching bug that returns the same string causes an infinite\n    loop. It has happened! Then update the start offset, leaving other\n    parameters alone. */\n\n    if ((dat_datctl.control & CTL_GLOBAL) != 0)\n      {\n      ovecsave[0] = ovector[0];\n      ovecsave[1] = ovector[1];\n      ovecsave[2] = dat_datctl.offset;\n      dat_datctl.offset = end_offset;\n      }\n\n    /* For altglobal, just update the pointer and length. */\n\n    else\n      {\n      pp += end_offset * code_unit_size;\n      len -= end_offset * code_unit_size;\n      ulen -= end_offset;\n      if (arg_ulen != PCRE2_ZERO_TERMINATED) arg_ulen -= end_offset;\n      }\n    }\n  }  /* End of global loop */\n\nshow_memory = FALSE;\nreturn PR_OK;\n}\n\n\n\n\n/*************************************************\n*               Print PCRE2 version              *\n*************************************************/\n\nstatic void\nprint_version(FILE *f)\n{\nVERSION_TYPE *vp;\nfprintf(f, \"PCRE2 version \");\nfor (vp = version; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\nfprintf(f, \"\\n\");\n}\n\n\n\n/*************************************************\n*               Print Unicode version            *\n*************************************************/\n\nstatic void\nprint_unicode_version(FILE *f)\n{\nVERSION_TYPE *vp;\nfprintf(f, \"Unicode version \");\nfor (vp = uversion; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\n}\n\n\n\n/*************************************************\n*               Print JIT target                 *\n*************************************************/\n\nstatic void\nprint_jit_target(FILE *f)\n{\nVERSION_TYPE *vp;\nfor (vp = jittarget; *vp != 0; vp++) fprintf(f, \"%c\", *vp);\n}\n\n\n\n/*************************************************\n*       Print newline configuration              *\n*************************************************/\n\n/* Output is always to stdout.\n\nArguments:\n  rc         the return code from PCRE2_CONFIG_NEWLINE\n  isc        TRUE if called from \"-C newline\"\nReturns:     nothing\n*/\n\nstatic void\nprint_newline_config(uint32_t optval, BOOL isc)\n{\nif (!isc) printf(\"  Default newline sequence is \");\nif (optval < sizeof(newlines)/sizeof(char *))\n  printf(\"%s\\n\", newlines[optval]);\nelse\n  printf(\"a non-standard value: %d\\n\", optval);\n}\n\n\n\n/*************************************************\n*             Usage function                     *\n*************************************************/\n\nstatic void\nusage(void)\n{\nprintf(\"Usage:     pcre2test [options] [<input file> [<output file>]]\\n\\n\");\nprintf(\"Input and output default to stdin and stdout.\\n\");\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nprintf(\"If input is a terminal, readline() is used to read from it.\\n\");\n#else\nprintf(\"This version of pcre2test is not linked with readline().\\n\");\n#endif\nprintf(\"\\nOptions:\\n\");\n#ifdef SUPPORT_PCRE2_8\nprintf(\"  -8            use the 8-bit library\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_16\nprintf(\"  -16           use the 16-bit library\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_32\nprintf(\"  -32           use the 32-bit library\\n\");\n#endif\nprintf(\"  -ac           set default pattern modifier PCRE2_AUTO_CALLOUT\\n\");\nprintf(\"  -AC           as -ac, but also set subject 'callout_extra' modifier\\n\");\nprintf(\"  -b            set default pattern modifier 'fullbincode'\\n\");\nprintf(\"  -C            show PCRE2 compile-time options and exit\\n\");\nprintf(\"  -C arg        show a specific compile-time option and exit with its\\n\");\nprintf(\"                  value if numeric (else 0). The arg can be:\\n\");\nprintf(\"     backslash-C    use of \\\\C is enabled [0, 1]\\n\");\nprintf(\"     bsr            \\\\R type [ANYCRLF, ANY]\\n\");\nprintf(\"     ebcdic         compiled for EBCDIC character code [0,1]\\n\");\nprintf(\"     ebcdic-nl      NL code if compiled for EBCDIC\\n\");\nprintf(\"     jit            just-in-time compiler supported [0, 1]\\n\");\nprintf(\"     linksize       internal link size [2, 3, 4]\\n\");\nprintf(\"     newline        newline type [CR, LF, CRLF, ANYCRLF, ANY, NUL]\\n\");\nprintf(\"     pcre2-8        8 bit library support enabled [0, 1]\\n\");\nprintf(\"     pcre2-16       16 bit library support enabled [0, 1]\\n\");\nprintf(\"     pcre2-32       32 bit library support enabled [0, 1]\\n\");\nprintf(\"     unicode        Unicode and UTF support enabled [0, 1]\\n\");\nprintf(\"  -d            set default pattern modifier 'debug'\\n\");\nprintf(\"  -dfa          set default subject modifier 'dfa'\\n\");\nprintf(\"  -error <n,m,..>  show messages for error numbers, then exit\\n\");\nprintf(\"  -help         show usage information\\n\");\nprintf(\"  -i            set default pattern modifier 'info'\\n\");\nprintf(\"  -jit          set default pattern modifier 'jit'\\n\");\nprintf(\"  -jitfast      set default pattern modifier 'jitfast'\\n\");\nprintf(\"  -jitverify    set default pattern modifier 'jitverify'\\n\");\nprintf(\"  -LM           list pattern and subject modifiers, then exit\\n\");\nprintf(\"  -LP           list non-script properties, then exit\\n\");\nprintf(\"  -LS           list supported scripts, then exit\\n\");\nprintf(\"  -q            quiet: do not output PCRE2 version number at start\\n\");\nprintf(\"  -pattern <s>  set default pattern modifier fields\\n\");\nprintf(\"  -subject <s>  set default subject modifier fields\\n\");\nprintf(\"  -S <n>        set stack size to <n> mebibytes\\n\");\nprintf(\"  -t [<n>]      time compilation and execution, repeating <n> times\\n\");\nprintf(\"  -tm [<n>]     time execution (matching) only, repeating <n> times\\n\");\nprintf(\"  -T            same as -t, but show total times at the end\\n\");\nprintf(\"  -TM           same as -tm, but show total time at the end\\n\");\nprintf(\"  -version      show PCRE2 version and exit\\n\");\n}\n\n\n\n/*************************************************\n*             Handle -C option                   *\n*************************************************/\n\n/* This option outputs configuration options and sets an appropriate return\ncode when asked for a single option. The code is abstracted into a separate\nfunction because of its size. Use whichever pcre2_config() function is\navailable.\n\nArgument:   an option name or NULL\nReturns:    the return code\n*/\n\nstatic int\nc_option(const char *arg)\n{\nuint32_t optval;\nunsigned int i = COPTLISTCOUNT;\nint yield = 0;\n\nif (arg != NULL && arg[0] != CHAR_MINUS)\n  {\n  for (i = 0; i < COPTLISTCOUNT; i++)\n    if (strcmp(arg, coptlist[i].name) == 0) break;\n\n  if (i >= COPTLISTCOUNT)\n    {\n    fprintf(stderr, \"** Unknown -C option '%s'\\n\", arg);\n    return 0;\n    }\n\n  switch (coptlist[i].type)\n    {\n    case CONF_BSR:\n    (void)PCRE2_CONFIG(coptlist[i].value, &optval);\n    printf(\"%s\\n\", (optval == PCRE2_BSR_ANYCRLF)? \"ANYCRLF\" : \"ANY\");\n    break;\n\n    case CONF_FIX:\n    yield = coptlist[i].value;\n    printf(\"%d\\n\", yield);\n    break;\n\n    case CONF_FIZ:\n    optval = coptlist[i].value;\n    printf(\"%d\\n\", optval);\n    break;\n\n    case CONF_INT:\n    (void)PCRE2_CONFIG(coptlist[i].value, &yield);\n    printf(\"%d\\n\", yield);\n    break;\n\n    case CONF_NL:\n    (void)PCRE2_CONFIG(coptlist[i].value, &optval);\n    print_newline_config(optval, TRUE);\n    break;\n    }\n\n/* For VMS, return the value by setting a symbol, for certain values only. This\nis contributed code which the PCRE2 developers have no means of testing. */\n\n#ifdef __VMS\n\n/* This is the original code provided by the first VMS contributor. */\n#ifdef NEVER\n  if (copytlist[i].type == CONF_FIX || coptlist[i].type == CONF_INT)\n    {\n    char ucname[16];\n    strcpy(ucname, coptlist[i].name);\n    for (i = 0; ucname[i] != 0; i++) ucname[i] = toupper[ucname[i]];\n    vms_setsymbol(ucname, 0, optval);\n    }\n#endif\n\n/* This is the new code, provided by a second VMS contributor. */\n\n  if (coptlist[i].type == CONF_FIX || coptlist[i].type == CONF_INT)\n    {\n    char nam_buf[22], val_buf[4];\n    $DESCRIPTOR(nam, nam_buf);\n    $DESCRIPTOR(val, val_buf);\n\n    strcpy(nam_buf, coptlist[i].name);\n    nam.dsc$w_length = strlen(nam_buf);\n    sprintf(val_buf, \"%d\", yield);\n    val.dsc$w_length = strlen(val_buf);\n    lib$set_symbol(&nam, &val);\n    }\n#endif  /* __VMS */\n\n  return yield;\n  }\n\n/* No argument for -C: output all configuration information. */\n\nprint_version(stdout);\nprintf(\"Compiled with\\n\");\n\n#ifdef EBCDIC\nprintf(\"  EBCDIC code support: LF is 0x%02x\\n\", CHAR_LF);\n#if defined NATIVE_ZOS\nprintf(\"  EBCDIC code page %s or similar\\n\", pcrz_cpversion());\n#endif\n#endif\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_COMPILED_WIDTHS, &optval);\nif (optval & 1) printf(\"  8-bit support\\n\");\nif (optval & 2) printf(\"  16-bit support\\n\");\nif (optval & 4) printf(\"  32-bit support\\n\");\n\n#ifdef SUPPORT_VALGRIND\nprintf(\"  Valgrind support\\n\");\n#endif\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, &optval);\nif (optval != 0)\n  {\n  printf(\"  UTF and UCP support (\");\n  print_unicode_version(stdout);\n  printf(\")\\n\");\n  }\nelse printf(\"  No Unicode support\\n\");\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_JIT, &optval);\nif (optval != 0)\n  {\n  printf(\"  Just-in-time compiler support: \");\n  print_jit_target(stdout);\n  printf(\"\\n\");\n  }\nelse\n  {\n  printf(\"  No just-in-time compiler support\\n\");\n  }\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_NEWLINE, &optval);\nprint_newline_config(optval, FALSE);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_BSR, &optval);\nprintf(\"  \\\\R matches %s\\n\",\n  (optval == PCRE2_BSR_ANYCRLF)? \"CR, LF, or CRLF only\" :\n                                 \"all Unicode newlines\");\n(void)PCRE2_CONFIG(PCRE2_CONFIG_NEVER_BACKSLASH_C, &optval);\nprintf(\"  \\\\C is %ssupported\\n\", optval? \"not \":\"\");\n(void)PCRE2_CONFIG(PCRE2_CONFIG_LINKSIZE, &optval);\nprintf(\"  Internal link size = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_PARENSLIMIT, &optval);\nprintf(\"  Parentheses nest limit = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_HEAPLIMIT, &optval);\nprintf(\"  Default heap limit = %d kibibytes\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, &optval);\nprintf(\"  Default match limit = %d\\n\", optval);\n(void)PCRE2_CONFIG(PCRE2_CONFIG_DEPTHLIMIT, &optval);\nprintf(\"  Default depth limit = %d\\n\", optval);\n\n#if defined SUPPORT_LIBREADLINE\nprintf(\"  pcre2test has libreadline support\\n\");\n#elif defined SUPPORT_LIBEDIT\nprintf(\"  pcre2test has libedit support\\n\");\n#else\nprintf(\"  pcre2test has neither libreadline nor libedit support\\n\");\n#endif\n\nreturn 0;\n}\n\n\n/*************************************************\n*      Format one property/script list item      *\n*************************************************/\n\n#ifdef SUPPORT_UNICODE\nstatic void\nformat_list_item(int16_t *ff, char *buff, BOOL isscript)\n{\nint count;\nint maxi = 0;\nconst char *maxs = \"\";\nsize_t max = 0;\n\nfor (count = 0; ff[count] >= 0; count++) {}\n\n/* Find the name to put first. For scripts, any 3-character name is chosen.\nFor non-scripts, or if there is no 3-character name, take the longest. */\n\nfor (int i = 0; ff[i] >= 0; i++)\n  {\n  const char *s = PRIV(utt_names) + ff[i];\n  size_t len = strlen(s);\n  if (isscript && len == 3)\n    {\n    maxi = i;\n    max = len;\n    maxs = s;\n    break;\n    }\n  else if (len > max)\n    {\n    max = len;\n    maxi = i;\n    maxs = s;\n    }\n  }\n\nstrcpy(buff, maxs);\nbuff += max;\n\nif (count > 1)\n  {\n  const char *sep = \" (\";\n  for (int i = 0; i < count; i++)\n    {\n    if (i == maxi) continue;\n    buff += sprintf(buff, \"%s%s\", sep, PRIV(utt_names) + ff[i]);\n    sep = \", \";\n    }\n  (void)sprintf(buff, \")\");\n  }\n}\n#endif  /* SUPPORT_UNICODE */\n\n\n\n/*************************************************\n*        Display scripts or properties           *\n*************************************************/\n\n#define MAX_SYNONYMS 5\n\nstatic void\ndisplay_properties(BOOL wantscripts)\n{\n#ifndef SUPPORT_UNICODE\n(void)wantscripts;\nprintf(\"** This version of PCRE2 was compiled without Unicode support.\\n\");\n#else\n\nconst char *typename;\nuint16_t seentypes[1024];\nuint16_t seenvalues[1024];\nint seencount = 0;\nint16_t found[256][MAX_SYNONYMS + 1];\nint fc = 0;\nint colwidth = 40;\nint n;\n\nif (wantscripts)\n  {\n  n = ucp_Script_Count;\n  typename = \"SCRIPTS\";\n  }\nelse\n  {\n  n = ucp_Bprop_Count;\n  typename = \"PROPERTIES\";\n  }\n\nfor (size_t i = 0; i < PRIV(utt_size); i++)\n  {\n  int k;\n  int m = 0;\n  int16_t *fv;\n  const ucp_type_table *t = PRIV(utt) + i;\n  unsigned int value = t->value;\n\n  if (wantscripts)\n    {\n    if (t->type != PT_SC && t->type != PT_SCX) continue;\n    }\n  else\n    {\n    if (t->type != PT_BOOL) continue;\n    }\n\n  for (k = 0; k < seencount; k++)\n    {\n    if (t->type == seentypes[k] && t->value == seenvalues[k]) break;\n    }\n  if (k < seencount) continue;\n\n  seentypes[seencount] = t->type;\n  seenvalues[seencount++] = t->value;\n\n  fv = found[fc++];\n  fv[m++] = t->name_offset;\n\n  for (size_t j = i + 1; j < PRIV(utt_size); j++)\n    {\n    const ucp_type_table *tt = PRIV(utt) + j;\n    if (tt->type != t->type || tt->value != value) continue;\n    if (m >= MAX_SYNONYMS)\n      printf(\"** Too many synonyms: %s ignored\\n\",\n        PRIV(utt_names) + tt->name_offset);\n    else fv[m++] = tt->name_offset;\n    }\n\n  fv[m] = -1;\n  }\n\nprintf(\"-------------------------- SUPPORTED %s --------------------------\\n\\n\",\n  typename);\n\nif (!wantscripts) printf(\n\"This release of PCRE2 supports Unicode's general category properties such\\n\"\n\"as Lu (upper case letter), bi-directional properties such as Bidi_Class,\\n\"\n\"and the following binary (yes/no) properties:\\n\\n\");\n\n\nfor (int k = 0; k < (n+1)/2; k++)\n  {\n  int x;\n  char buff1[128];\n  char buff2[128];\n\n  format_list_item(found[k], buff1, wantscripts);\n  x = k + (n+1)/2;\n  if (x < n) format_list_item(found[x], buff2, wantscripts);\n    else buff2[0] = 0;\n\n  x = printf(\"%s\", buff1);\n  while (x++ < colwidth) printf(\" \");\n  printf(\"%s\\n\", buff2);\n  }\n\n#endif  /* SUPPORT_UNICODE */\n}\n\n\n\n/*************************************************\n*              Display one modifier              *\n*************************************************/\n\nstatic void\ndisplay_one_modifier(modstruct *m, BOOL for_pattern)\n{\nuint32_t c = (!for_pattern && (m->which == MOD_PND || m->which == MOD_PNDP))?\n  '*' : ' ';\nprintf(\"%c%s\", c, m->name);\nfor (size_t i = 0; i < C1MODLISTCOUNT; i++)\n  {\n  if (strcmp(m->name, c1modlist[i].fullname) == 0)\n    printf(\" (%c)\", c1modlist[i].onechar);\n  }\n}\n\n\n\n/*************************************************\n*       Display pattern or subject modifiers     *\n*************************************************/\n\n/* In order to print in two columns, first scan without printing to get a list\nof the modifiers that are required.\n\nArguments:\n  for_pattern   TRUE for pattern modifiers, FALSE for subject modifiers\n  title         string to be used in title\n\nReturns:        nothing\n*/\n\nstatic void\ndisplay_selected_modifiers(BOOL for_pattern, const char *title)\n{\nuint32_t i, j;\nuint32_t n = 0;\nuint32_t list[MODLISTCOUNT];\nuint32_t extra[MODLISTCOUNT];\n\nfor (i = 0; i < MODLISTCOUNT; i++)\n  {\n  BOOL is_pattern = TRUE;\n  modstruct *m = modlist + i;\n\n  switch (m->which)\n    {\n    case MOD_CTC:       /* Compile context */\n    case MOD_PAT:       /* Pattern */\n    case MOD_PATP:      /* Pattern, OK for Perl-compatible test */\n    break;\n\n    /* The MOD_PND and MOD_PNDP modifiers are precisely those that affect\n    subjects, but can be given with a pattern. We list them as subject\n    modifiers, but marked with an asterisk.*/\n\n    case MOD_CTM:       /* Match context */\n    case MOD_DAT:       /* Subject line */\n    case MOD_DATP:      /* Subject line, OK for Perl-compatible test */\n    case MOD_PND:       /* As PD, but not default pattern */\n    case MOD_PNDP:      /* As PND, OK for Perl-compatible test */\n    is_pattern = FALSE;\n    break;\n\n    default: printf(\"** Unknown type for modifier '%s'\\n\", m->name);\n    /* Fall through */\n    case MOD_PD:        /* Pattern or subject */\n    case MOD_PDP:       /* As PD, OK for Perl-compatible test */\n    is_pattern = for_pattern;\n    break;\n    }\n\n  if (for_pattern == is_pattern)\n    {\n    extra[n] = 0;\n    for (size_t k = 0; k < C1MODLISTCOUNT; k++)\n      {\n      if (strcmp(m->name, c1modlist[k].fullname) == 0)\n        {\n        extra[n] += 4;\n        break;\n        }\n      }\n    list[n++] = i;\n    }\n  }\n\n/* Now print from the list in two columns. */\n\nprintf(\"-------------- %s MODIFIERS --------------\\n\", title);\n\nfor (i = 0, j = (n+1)/2; i < (n+1)/2; i++, j++)\n  {\n  modstruct *m = modlist + list[i];\n  display_one_modifier(m, for_pattern);\n  if (j < n)\n    {\n    uint32_t k = 27 - strlen(m->name) - extra[i];\n    while (k-- > 0) printf(\" \");\n    display_one_modifier(modlist + list[j], for_pattern);\n    }\n  printf(\"\\n\");\n  }\n}\n\n\n\n/*************************************************\n*          Display the list of modifiers         *\n*************************************************/\n\nstatic void\ndisplay_modifiers(void)\n{\nprintf(\n  \"An asterisk on a subject modifier means that it may be given on a pattern\\n\"\n  \"line, in order to apply to all subjects matched by that pattern. Modifiers\\n\"\n  \"that are listed for both patterns and subjects have different effects in\\n\"\n  \"each case.\\n\\n\");\ndisplay_selected_modifiers(TRUE, \"PATTERN\");\nprintf(\"\\n\");\ndisplay_selected_modifiers(FALSE, \"SUBJECT\");\n}\n\n\n\n/*************************************************\n*                Main Program                    *\n*************************************************/\n\nint\nmain(int argc, char **argv)\n{\nuint32_t temp;\nuint32_t yield = 0;\nuint32_t op = 1;\nBOOL notdone = TRUE;\nBOOL quiet = FALSE;\nBOOL showtotaltimes = FALSE;\nBOOL skipping = FALSE;\nchar *arg_subject = NULL;\nchar *arg_pattern = NULL;\nchar *arg_error = NULL;\n\n/* The offsets to the options and control bits fields of the pattern and data\ncontrol blocks must be the same so that common options and controls such as\n\"anchored\" or \"memory\" can work for either of them from a single table entry.\nWe cannot test this till runtime because \"offsetof\" does not work in the\npreprocessor. */\n\nif (PO(options) != DO(options) || PO(control) != DO(control) ||\n    PO(control2) != DO(control2))\n  {\n  fprintf(stderr, \"** Coding error: \"\n    \"options and control offsets for pattern and data must be the same.\\n\");\n  return 1;\n  }\n\n/* Get the PCRE2 and Unicode version number and JIT target information, at the\nsame time checking that a request for the length gives the same answer. Also\ncheck lengths for non-string items. */\n\nif (PCRE2_CONFIG(PCRE2_CONFIG_VERSION, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_VERSION, version) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, uversion) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, NULL) !=\n    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, jittarget) ||\n\n    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, NULL) != sizeof(uint32_t) ||\n    PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, NULL) != sizeof(uint32_t))\n  {\n  fprintf(stderr, \"** Error in pcre2_config(): bad length\\n\");\n  return 1;\n  }\n\n/* Check that bad options are diagnosed. */\n\nif (PCRE2_CONFIG(999, NULL) != PCRE2_ERROR_BADOPTION ||\n    PCRE2_CONFIG(999, &temp) != PCRE2_ERROR_BADOPTION)\n  {\n  fprintf(stderr, \"** Error in pcre2_config(): bad option not diagnosed\\n\");\n  return 1;\n  }\n\n/* This configuration option is now obsolete, but running a quick check ensures\nthat its code is covered. */\n\n(void)PCRE2_CONFIG(PCRE2_CONFIG_STACKRECURSE, &temp);\n\n/* Get buffers from malloc() so that valgrind will check their misuse when\ndebugging. They grow automatically when very long lines are read. The 16-\nand 32-bit buffers (pbuffer16, pbuffer32) are obtained only if needed. */\n\nbuffer = (uint8_t *)malloc(pbuffer8_size);\npbuffer8 = (uint8_t *)malloc(pbuffer8_size);\n\n/* The following  _setmode() stuff is some Windows magic that tells its runtime\nlibrary to translate CRLF into a single LF character. At least, that's what\nI've been told: never having used Windows I take this all on trust. Originally\nit set 0x8000, but then I was advised that _O_BINARY was better. */\n\n#if defined(_WIN32) || defined(WIN32)\n_setmode( _fileno( stdout ), _O_BINARY );\n#endif\n\n/* Initialization that does not depend on the running mode. */\n\nlocale_name[0] = 0;\n\nmemset(&def_patctl, 0, sizeof(patctl));\ndef_patctl.convert_type = CONVERT_UNSET;\n\nmemset(&def_datctl, 0, sizeof(datctl));\ndef_datctl.oveccount = DEFAULT_OVECCOUNT;\ndef_datctl.copy_numbers[0] = -1;\ndef_datctl.get_numbers[0] = -1;\ndef_datctl.startend[0] = def_datctl.startend[1] = CFORE_UNSET;\ndef_datctl.cerror[0] = def_datctl.cerror[1] = CFORE_UNSET;\ndef_datctl.cfail[0] = def_datctl.cfail[1] = CFORE_UNSET;\n\n/* Scan command line options. */\n\nwhile (argc > 1 && argv[op][0] == '-' && argv[op][1] != 0)\n  {\n  char *endptr;\n  char *arg = argv[op];\n  unsigned long uli;\n\n  /* List modifiers and exit. */\n\n  if (strcmp(arg, \"-LM\") == 0)\n    {\n    display_modifiers();\n    goto EXIT;\n    }\n\n  /* List properties and exit */\n\n  if (strcmp(arg, \"-LP\") == 0)\n    {\n    display_properties(FALSE);\n    goto EXIT;\n    }\n\n  /* List scripts and exit */\n\n  if (strcmp(arg, \"-LS\") == 0)\n    {\n    display_properties(TRUE);\n    goto EXIT;\n    }\n\n  /* Display and/or set return code for configuration options. */\n\n  if (strcmp(arg, \"-C\") == 0)\n    {\n    yield = c_option(argv[op + 1]);\n    goto EXIT;\n    }\n\n  /* Select operating mode. Ensure that pcre2_config() is called in 16-bit\n  and 32-bit modes because that won't happen naturally when 8-bit is also\n  configured. Also call some other functions that are not otherwise used. This\n  means that a coverage report won't claim there are uncalled functions. */\n\n  if (strcmp(arg, \"-8\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_8\n    test_mode = PCRE8_MODE;\n    (void)pcre2_set_bsr_8(pat_context8, 999);\n    (void)pcre2_set_newline_8(pat_context8, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 8-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  else if (strcmp(arg, \"-16\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_16\n    test_mode = PCRE16_MODE;\n    (void)pcre2_config_16(PCRE2_CONFIG_VERSION, NULL);\n    (void)pcre2_set_bsr_16(pat_context16, 999);\n    (void)pcre2_set_newline_16(pat_context16, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 16-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  else if (strcmp(arg, \"-32\") == 0)\n    {\n#ifdef SUPPORT_PCRE2_32\n    test_mode = PCRE32_MODE;\n    (void)pcre2_config_32(PCRE2_CONFIG_VERSION, NULL);\n    (void)pcre2_set_bsr_32(pat_context32, 999);\n    (void)pcre2_set_newline_32(pat_context32, 999);\n#else\n    fprintf(stderr,\n      \"** This version of PCRE2 was built without 32-bit support\\n\");\n    exit(1);\n#endif\n    }\n\n  /* Set quiet (no version verification) */\n\n  else if (strcmp(arg, \"-q\") == 0) quiet = TRUE;\n\n  /* Set system stack size */\n\n  else if (strcmp(arg, \"-S\") == 0 && argc > 2 &&\n      ((uli = strtoul(argv[op+1], &endptr, 10)), *endptr == 0))\n    {\n#if defined(_WIN32) || defined(WIN32) || defined(__HAIKU__) || defined(NATIVE_ZOS) || defined(__VMS)\n    fprintf(stderr, \"pcre2test: -S is not supported on this OS\\n\");\n    exit(1);\n#else\n    int rc;\n    uint32_t stack_size;\n    struct rlimit rlim;\n    if (U32OVERFLOW(uli))\n      {\n      fprintf(stderr, \"** Argument for -S is too big\\n\");\n      exit(1);\n      }\n    stack_size = (uint32_t)uli;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = stack_size * 1024 * 1024;\n    if (rlim.rlim_cur > rlim.rlim_max)\n      {\n      fprintf(stderr,\n        \"pcre2test: requested stack size %luMiB is greater than hard limit \"\n          \"%luMiB\\n\", (unsigned long int)stack_size,\n          (unsigned long int)(rlim.rlim_max));\n      exit(1);\n      }\n    rc = setrlimit(RLIMIT_STACK, &rlim);\n    if (rc != 0)\n      {\n      fprintf(stderr, \"pcre2test: setting stack size %luMiB failed: %s\\n\",\n        (unsigned long int)stack_size, strerror(errno));\n      exit(1);\n      }\n    op++;\n    argc--;\n#endif\n    }\n\n  /* Set some common pattern and subject controls */\n\n  else if (strcmp(arg, \"-AC\") == 0)\n    {\n    def_patctl.options |= PCRE2_AUTO_CALLOUT;\n    def_datctl.control2 |= CTL2_CALLOUT_EXTRA;\n    }\n  else if (strcmp(arg, \"-ac\") == 0)  def_patctl.options |= PCRE2_AUTO_CALLOUT;\n  else if (strcmp(arg, \"-b\") == 0)   def_patctl.control |= CTL_FULLBINCODE;\n  else if (strcmp(arg, \"-d\") == 0)   def_patctl.control |= CTL_DEBUG;\n  else if (strcmp(arg, \"-dfa\") == 0) def_datctl.control |= CTL_DFA;\n  else if (strcmp(arg, \"-i\") == 0)   def_patctl.control |= CTL_INFO;\n  else if (strcmp(arg, \"-jit\") == 0 || strcmp(arg, \"-jitverify\") == 0 ||\n           strcmp(arg, \"-jitfast\") == 0)\n    {\n    if (arg[4] == 'v') def_patctl.control |= CTL_JITVERIFY;\n      else if (arg[4] == 'f') def_patctl.control |= CTL_JITFAST;\n    def_patctl.jit = JIT_DEFAULT;  /* full & partial */\n#ifndef SUPPORT_JIT\n    fprintf(stderr, \"** Warning: JIT support is not available: \"\n                    \"-jit[fast|verify] calls functions that do nothing.\\n\");\n#endif\n    }\n\n  /* Set timing parameters */\n\n  else if (strcmp(arg, \"-t\") == 0 || strcmp(arg, \"-tm\") == 0 ||\n           strcmp(arg, \"-T\") == 0 || strcmp(arg, \"-TM\") == 0)\n    {\n    int both = arg[2] == 0;\n    showtotaltimes = arg[1] == 'T';\n    if (argc > 2 && (uli = strtoul(argv[op+1], &endptr, 10), *endptr == 0))\n      {\n      if (uli == 0)\n        {\n        fprintf(stderr, \"** Argument for %s must not be zero\\n\", arg);\n        exit(1);\n        }\n      if (U32OVERFLOW(uli))\n        {\n        fprintf(stderr, \"** Argument for %s is too big\\n\", arg);\n        exit(1);\n        }\n      timeitm = (int)uli;\n      op++;\n      argc--;\n      }\n    else timeitm = LOOPREPEAT;\n    if (both) timeit = timeitm;\n    }\n\n  /* Give help */\n\n  else if (strcmp(arg, \"-help\") == 0 ||\n           strcmp(arg, \"--help\") == 0)\n    {\n    usage();\n    goto EXIT;\n    }\n\n  /* Show version */\n\n  else if (strcmp(arg, \"-version\") == 0 ||\n           strcmp(arg, \"--version\") == 0)\n    {\n    print_version(stdout);\n    goto EXIT;\n    }\n\n  /* The following options save their data for processing once we know what\n  the running mode is. */\n\n  else if (strcmp(arg, \"-error\") == 0)\n    {\n    arg_error = argv[op+1];\n    goto CHECK_VALUE_EXISTS;\n    }\n\n  else if (strcmp(arg, \"-subject\") == 0)\n    {\n    arg_subject = argv[op+1];\n    goto CHECK_VALUE_EXISTS;\n    }\n\n  else if (strcmp(arg, \"-pattern\") == 0)\n    {\n    arg_pattern = argv[op+1];\n    CHECK_VALUE_EXISTS:\n    if (argc <= 2)\n      {\n      fprintf(stderr, \"** Missing value for %s\\n\", arg);\n      yield = 1;\n      goto EXIT;\n      }\n    op++;\n    argc--;\n    }\n\n  /* Unrecognized option */\n\n  else\n    {\n    fprintf(stderr, \"** Unknown or malformed option '%s'\\n\", arg);\n    usage();\n    yield = 1;\n    goto EXIT;\n    }\n  op++;\n  argc--;\n  }\n\n/* If -error was present, get the error numbers, show the messages, and exit.\nWe wait to do this until we know which mode we are in. */\n\nif (arg_error != NULL)\n  {\n  int len;\n  int errcode;\n  char *endptr;\n\n/* Ensure the relevant non-8-bit buffer is available. Ensure that it is at\nleast 128 code units, because it is used for retrieving error messages. */\n\n#ifdef SUPPORT_PCRE2_16\n  if (test_mode == PCRE16_MODE)\n    {\n    pbuffer16_size = 256;\n    pbuffer16 = (uint16_t *)malloc(pbuffer16_size);\n    if (pbuffer16 == NULL)\n      {\n      fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer16\\n\",\n        pbuffer16_size);\n      yield = 1;\n      goto EXIT;\n      }\n    }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n  if (test_mode == PCRE32_MODE)\n    {\n    pbuffer32_size = 512;\n    pbuffer32 = (uint32_t *)malloc(pbuffer32_size);\n    if (pbuffer32 == NULL)\n      {\n      fprintf(stderr, \"pcre2test: malloc(%\" SIZ_FORM \") failed for pbuffer32\\n\",\n        pbuffer32_size);\n      yield = 1;\n      goto EXIT;\n      }\n    }\n#endif\n\n  /* Loop along a list of error numbers. */\n\n  for (;;)\n    {\n    errcode = strtol(arg_error, &endptr, 10);\n    if (*endptr != 0 && *endptr != CHAR_COMMA)\n      {\n      fprintf(stderr, \"** '%s' is not a valid error number list\\n\", arg_error);\n      yield = 1;\n      goto EXIT;\n      }\n    printf(\"Error %d: \", errcode);\n    PCRE2_GET_ERROR_MESSAGE(len, errcode, pbuffer);\n    if (len < 0)\n      {\n      switch (len)\n        {\n        case PCRE2_ERROR_BADDATA:\n        printf(\"PCRE2_ERROR_BADDATA (unknown error number)\");\n        break;\n\n        case PCRE2_ERROR_NOMEMORY:\n        printf(\"PCRE2_ERROR_NOMEMORY (buffer too small)\");\n        break;\n\n        default:\n        printf(\"Unexpected return (%d) from pcre2_get_error_message()\", len);\n        break;\n        }\n      }\n    else\n      {\n      PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, stdout);\n      }\n    printf(\"\\n\");\n    if (*endptr == 0) goto EXIT;\n    arg_error = endptr + 1;\n    }\n  /* Control never reaches here */\n  }  /* End of -error handling */\n\n/* Initialize things that cannot be done until we know which test mode we are\nrunning in. Exercise the general context copying and match data size functions,\nwhich are not otherwise used. */\n\ncode_unit_size = test_mode/8;\nmax_oveccount = DEFAULT_OVECCOUNT;\n\n/* Use macros to save a lot of duplication. */\n\n#define CREATECONTEXTS \\\n  G(general_context,BITS) = G(pcre2_general_context_create_,BITS)(&my_malloc, &my_free, NULL); \\\n  G(general_context_copy,BITS) = G(pcre2_general_context_copy_,BITS)(G(general_context,BITS)); \\\n  G(default_pat_context,BITS) = G(pcre2_compile_context_create_,BITS)(G(general_context,BITS)); \\\n  G(pat_context,BITS) = G(pcre2_compile_context_copy_,BITS)(G(default_pat_context,BITS)); \\\n  G(default_dat_context,BITS) = G(pcre2_match_context_create_,BITS)(G(general_context,BITS)); \\\n  G(dat_context,BITS) = G(pcre2_match_context_copy_,BITS)(G(default_dat_context,BITS)); \\\n  G(default_con_context,BITS) = G(pcre2_convert_context_create_,BITS)(G(general_context,BITS)); \\\n  G(con_context,BITS) = G(pcre2_convert_context_copy_,BITS)(G(default_con_context,BITS)); \\\n  G(match_data,BITS) = G(pcre2_match_data_create_,BITS)(max_oveccount, G(general_context,BITS))\n\n#define CONTEXTTESTS \\\n  (void)G(pcre2_set_compile_extra_options_,BITS)(G(pat_context,BITS), 0); \\\n  (void)G(pcre2_set_max_pattern_length_,BITS)(G(pat_context,BITS), 0); \\\n  (void)G(pcre2_set_offset_limit_,BITS)(G(dat_context,BITS), 0); \\\n  (void)G(pcre2_get_match_data_size_,BITS)(G(match_data,BITS))\n\n\n/* Call the appropriate functions for the current mode, and exercise some\nfunctions that are not otherwise called. */\n\n#ifdef SUPPORT_PCRE2_8\n#undef BITS\n#define BITS 8\nif (test_mode == PCRE8_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n#undef BITS\n#define BITS 16\nif (test_mode == PCRE16_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n#undef BITS\n#define BITS 32\nif (test_mode == PCRE32_MODE)\n  {\n  CREATECONTEXTS;\n  CONTEXTTESTS;\n  }\n#endif\n\n/* Set a default parentheses nest limit that is large enough to run the\nstandard tests (this also exercises the function). */\n\nPCRE2_SET_PARENS_NEST_LIMIT(default_pat_context, PARENS_NEST_DEFAULT);\n\n/* Handle command line modifier settings, sending any error messages to\nstderr. We need to know the mode before modifying the context, and it is tidier\nto do them all in the same way. */\n\noutfile = stderr;\nif ((arg_pattern != NULL &&\n    !decode_modifiers((uint8_t *)arg_pattern, CTX_DEFPAT, &def_patctl, NULL)) ||\n    (arg_subject != NULL &&\n    !decode_modifiers((uint8_t *)arg_subject, CTX_DEFDAT, NULL, &def_datctl)))\n  {\n  yield = 1;\n  goto EXIT;\n  }\n\n/* Sort out the input and output files, defaulting to stdin/stdout. */\n\ninfile = stdin;\noutfile = stdout;\n\nif (argc > 1 && strcmp(argv[op], \"-\") != 0)\n  {\n  infile = fopen(argv[op], INPUT_MODE);\n  if (infile == NULL)\n    {\n    printf(\"** Failed to open '%s': %s\\n\", argv[op], strerror(errno));\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nif (INTERACTIVE(infile)) using_history();\n#endif\n\nif (argc > 2)\n  {\n  outfile = fopen(argv[op+1], OUTPUT_MODE);\n  if (outfile == NULL)\n    {\n    printf(\"** Failed to open '%s': %s\\n\", argv[op+1], strerror(errno));\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n/* Output a heading line unless quiet, then process input lines. */\n\nif (!quiet) print_version(outfile);\n\nSET(compiled_code, NULL);\n\n#ifdef SUPPORT_PCRE2_8\npreg.re_pcre2_code = NULL;\npreg.re_match_data = NULL;\n#endif\n\nwhile (notdone)\n  {\n  uint8_t *p;\n  int rc = PR_OK;\n  BOOL expectdata = TEST(compiled_code, !=, NULL);\n#ifdef SUPPORT_PCRE2_8\n  expectdata |= preg.re_pcre2_code != NULL;\n#endif\n\n  if (extend_inputline(infile, buffer, expectdata? \"data> \" : \"  re> \") == NULL)\n    break;\n  if (!INTERACTIVE(infile)) fprintf(outfile, \"%s\", (char *)buffer);\n  fflush(outfile);\n  p = buffer;\n\n  /* If we have a pattern set up for testing, or we are skipping after a\n  compile failure, a blank line terminates this test. */\n\n  if (expectdata || skipping)\n    {\n    while (isspace(*p)) p++;\n    if (*p == 0)\n      {\n#ifdef SUPPORT_PCRE2_8\n      if (preg.re_pcre2_code != NULL)\n        {\n        regfree(&preg);\n        preg.re_pcre2_code = NULL;\n        preg.re_match_data = NULL;\n        }\n#endif  /* SUPPORT_PCRE2_8 */\n      if (TEST(compiled_code, !=, NULL))\n        {\n        SUB1(pcre2_code_free, compiled_code);\n        SET(compiled_code, NULL);\n        }\n      skipping = FALSE;\n      setlocale(LC_CTYPE, \"C\");\n      }\n\n    /* Otherwise, if we are not skipping, and the line is not a data comment\n    line starting with \"\\=\", process a data line. */\n\n    else if (!skipping && !(p[0] == '\\\\' && p[1] == '=' && isspace(p[2])))\n      {\n      rc = process_data();\n      }\n    }\n\n  /* We do not have a pattern set up for testing. Lines starting with # are\n  either comments or special commands. Blank lines are ignored. Otherwise, the\n  line must start with a valid delimiter. It is then processed as a pattern\n  line. A copy of the pattern is left in pbuffer8 for use by callouts. Under\n  valgrind, make the unused part of the buffer undefined, to catch overruns. */\n\n  else if (*p == '#')\n    {\n    if (isspace(p[1]) || p[1] == '!' || p[1] == 0) continue;\n    rc = process_command();\n    }\n\n  else if (strchr(\"/!\\\"'`%&-=_:;,@~\", *p) != NULL)\n    {\n    rc = process_pattern();\n    dfa_matched = 0;\n    }\n\n  else\n    {\n    while (isspace(*p)) p++;\n    if (*p != 0)\n      {\n      fprintf(outfile, \"** Invalid pattern delimiter '%c' (x%x).\\n\", *buffer,\n        *buffer);\n      rc = PR_SKIP;\n      }\n    }\n\n  if (rc == PR_SKIP && !INTERACTIVE(infile)) skipping = TRUE;\n  else if (rc == PR_ABEND)\n    {\n    fprintf(outfile, \"** pcre2test run abandoned\\n\");\n    yield = 1;\n    goto EXIT;\n    }\n  }\n\n/* Finish off a normal run. */\n\nif (INTERACTIVE(infile)) fprintf(outfile, \"\\n\");\n\nif (showtotaltimes)\n  {\n  const char *pad = \"\";\n  fprintf(outfile, \"--------------------------------------\\n\");\n  if (timeit > 0)\n    {\n    fprintf(outfile, \"Total compile time %.4f milliseconds\\n\",\n      (((double)total_compile_time * 1000.0) / (double)timeit) /\n        (double)CLOCKS_PER_SEC);\n    if (total_jit_compile_time > 0)\n      fprintf(outfile, \"Total JIT compile  %.4f milliseconds\\n\",\n        (((double)total_jit_compile_time * 1000.0) / (double)timeit) /\n          (double)CLOCKS_PER_SEC);\n    pad = \"  \";\n    }\n  fprintf(outfile, \"Total match time %s%.4f milliseconds\\n\", pad,\n    (((double)total_match_time * 1000.0) / (double)timeitm) /\n      (double)CLOCKS_PER_SEC);\n  }\n\n\nEXIT:\n\n#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)\nif (infile != NULL && INTERACTIVE(infile)) clear_history();\n#endif\n\nif (infile != NULL && infile != stdin) fclose(infile);\nif (outfile != NULL && outfile != stdout) fclose(outfile);\n\nfree(buffer);\nfree(dbuffer);\nfree(pbuffer8);\nfree(dfa_workspace);\nfree(tables3);\nPCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);\nPCRE2_MATCH_DATA_FREE(match_data);\nSUB1(pcre2_code_free, compiled_code);\n\nwhile(patstacknext-- > 0)\n  {\n  SET(compiled_code, patstack[patstacknext]);\n  SUB1(pcre2_code_free, compiled_code);\n  }\n\nPCRE2_JIT_FREE_UNUSED_MEMORY(general_context);\nif (jit_stack != NULL)\n  {\n  PCRE2_JIT_STACK_FREE(jit_stack);\n  }\n\n#define FREECONTEXTS \\\n  G(pcre2_general_context_free_,BITS)(G(general_context,BITS)); \\\n  G(pcre2_general_context_free_,BITS)(G(general_context_copy,BITS)); \\\n  G(pcre2_compile_context_free_,BITS)(G(pat_context,BITS)); \\\n  G(pcre2_compile_context_free_,BITS)(G(default_pat_context,BITS)); \\\n  G(pcre2_match_context_free_,BITS)(G(dat_context,BITS)); \\\n  G(pcre2_match_context_free_,BITS)(G(default_dat_context,BITS)); \\\n  G(pcre2_convert_context_free_,BITS)(G(default_con_context,BITS)); \\\n  G(pcre2_convert_context_free_,BITS)(G(con_context,BITS));\n\n#ifdef SUPPORT_PCRE2_8\n#undef BITS\n#define BITS 8\nif (preg.re_pcre2_code != NULL) regfree(&preg);\nFREECONTEXTS;\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n#undef BITS\n#define BITS 16\nfree(pbuffer16);\nFREECONTEXTS;\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n#undef BITS\n#define BITS 32\nfree(pbuffer32);\nFREECONTEXTS;\n#endif\n\n#if defined(__VMS)\n  yield = SS$_NORMAL;  /* Return values via DCL symbols */\n#endif\n\nreturn yield;\n}\n\n/* End of pcre2test.c */\n", "# This set of tests is not Perl-compatible. It checks on special features\n# of PCRE2's API, error diagnostics, and the compiled code of some patterns.\n# It also checks the non-Perl syntax that PCRE2 supports (Python, .NET,\n# Oniguruma). There are also some tests where PCRE2 and Perl differ,\n# either because PCRE2 can't be compatible, or there is a possible Perl\n# bug.\n\n# NOTE: This is a non-UTF set of tests. When UTF support is needed, use\n# test 5.\n\n#forbid_utf\n#newline_default lf any anycrlf\n\n# Test binary zeroes in the pattern\n\n# /a\\0B/ where 0 is a binary zero\n/61 5c 00 62/B,hex\n    a\\x{0}b\n\n# /a0b/ where 0 is a binary zero\n/61 00 62/B,hex\n    a\\x{0}b\n\n# /(?#B0C)DE/ where 0 is a binary zero\n/28 3f 23 42 00 43 29 44 45/B,hex\n    DE\n\n/(a)b|/I\n\n/abc/I\n    abc\n    defabc\n    abc\\=anchored\n\\= Expect no match\n    defabc\\=anchored\n    ABC\n\n/^abc/I\n    abc\n    abc\\=anchored\n\\= Expect no match\n    defabc\n    defabc\\=anchored\n\n/a+bc/I\n\n/a*bc/I\n\n/a{3}bc/I\n\n/(abc|a+z)/I\n\n/^abc$/I\n    abc\n\\= Expect no match\n    def\\nabc\n\n/ab\\idef/\n\n/(?X)ab\\idef/\n\n/x{5,4}/\n\n/z{65536}/\n\n/[abcd/\n\n/[\\B]/B\n\n/[\\R]/B\n\n/[\\X]/B\n\n/[z-a]/\n\n/^*/\n\n/(abc/\n\n/(?# abc/\n\n/(?z)abc/\n\n/.*b/I\n\n/.*?b/I\n\n/cat|dog|elephant/I\n    this sentence eventually mentions a cat\n    this sentences rambles on and on for a while and then reaches elephant\n\n/cat|dog|elephant/I\n    this sentence eventually mentions a cat\n    this sentences rambles on and on for a while and then reaches elephant\n\n/cat|dog|elephant/Ii\n    this sentence eventually mentions a CAT cat\n    this sentences rambles on and on for a while to elephant ElePhant\n\n/a|[bcd]/I\n\n/(a|[^\\dZ])/I\n\n/(a|b)*[\\s]/I\n\n/(ab\\2)/\n\n/{4,5}abc/\n\n/(a)(b)(c)\\2/I\n    abcb\n    abcb\\=ovector=0\n    abcb\\=ovector=1\n    abcb\\=ovector=2\n    abcb\\=ovector=3\n    abcb\\=ovector=4\n\n/(a)bc|(a)(b)\\2/I\n    abc\n    abc\\=ovector=0\n    abc\\=ovector=1\n    abc\\=ovector=2\n    aba\n    aba\\=ovector=0\n    aba\\=ovector=1\n    aba\\=ovector=2\n    aba\\=ovector=3\n    aba\\=ovector=4\n\n/abc$/I,dollar_endonly\n    abc\n\\= Expect no match\n    abc\\n\n    abc\\ndef\n\n/(a)(b)(c)(d)(e)\\6/\n\n/the quick brown fox/I\n    the quick brown fox\n    this is a line with the quick brown fox\n\n/the quick brown fox/I,anchored\n    the quick brown fox\n\\= Expect no match\n    this is a line with the quick brown fox\n\n/ab(?z)cd/\n\n/^abc|def/I\n    abcdef\n    abcdef\\=notbol\n\n/.*((abc)$|(def))/I\n    defabc\n    defabc\\=noteol\n\n/)/\n\n/a[]b/\n\n/[^aeiou ]{3,}/I\n    co-processors, and for\n\n/<.*>/I\n    abc<def>ghi<klm>nop\n\n/<.*?>/I\n    abc<def>ghi<klm>nop\n\n/<.*>/I,ungreedy\n    abc<def>ghi<klm>nop\n\n/(?U)<.*>/I\n    abc<def>ghi<klm>nop\n\n/<.*?>/I,ungreedy\n    abc<def>ghi<klm>nop\n\n/={3,}/I,ungreedy\n    abc========def\n\n/(?U)={3,}?/I\n    abc========def\n\n/(?<!bar|cattle)foo/I\n    foo\n    catfoo\n\\= Expect no match\n    the barfoo\n    and cattlefoo\n\n/abc(?<=a+)b/\n\n/12345(?<=aaa|b{0,3})b/\n\n/(?<!(foo)a\\1)bar/\n\n/(?i)abc/I\n\n/(a|(?m)a)/I\n\n/(?i)^1234/I\n\n/(^b|(?i)^d)/I\n\n/(?s).*/I\n\n/[abcd]/I\n\n/(?i)[abcd]/I\n\n/(?m)[xy]|(b|c)/I\n\n/(^a|^b)/Im\n\n/(?i)(^a|^b)/Im\n\n/(a)(?(1)a|b|c)/\n\n/(?(?=a)a|b|c)/\n\n/(?(1a)/\n\n/(?(1a))/\n\n/(?(?i))/\n\n/(?(abc))/\n\n/(?(?<ab))/\n\n/((?s)blah)\\s+\\1/I\n\n/((?i)blah)\\s+\\1/I\n\n/((?i)b)/IB\n\n/(a*b|(?i:c*(?-i)d))/I\n\n/a$/I\n    a\n    a\\n\n\\= Expect no match\n    a\\=noteol\n    a\\n\\=noteol\n\n/a$/Im\n    a\n    a\\n\n    a\\n\\=noteol\n\\= Expect no match\n    a\\=noteol\n\n/\\Aabc/Im\n\n/^abc/Im\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/I\n  aaaaabbbbbcccccdef\n\n/(?<=foo)[ab]/I\n\n/(?<!foo)(alpha|omega)/I\n\n/(?!alphabet)[ab]/I\n\n/(?<=foo\\n)^bar/Im\n    foo\\nbarbar\n\\= Expect no match\n    rhubarb\n    barbell\n    abc\\nbarton\n\n/^(?<=foo\\n)bar/Im\n    foo\\nbarbar\n\\= Expect no match\n    rhubarb\n    barbell\n    abc\\nbarton\n\n/(?>^abc)/Im\n    abc\n    def\\nabc\n\\= Expect no match\n    defabc\n\n/(?<=ab(c+)d)ef/\n\n/(?<=ab(?<=c+)d)ef/\n\n/(?<=ab(c|de)f)g/\n\n/The next three are in testinput2 because they have variable length branches/\n\n/(?<=bullock|donkey)-cart/I\n    the bullock-cart\n    a donkey-cart race\n\\= Expect no match\n    cart\n    horse-and-cart\n\n/(?<=ab(?i)x|y|z)/I\n\n/(?>.*)(?<=(abcd)|(xyz))/I\n    alphabetabcd\n    endingxyz\n\n/(?<=ab(?i)x(?-i)y|(?i)z|b)ZZ/I\n    abxyZZ\n    abXyZZ\n    ZZZ\n    zZZ\n    bZZ\n    BZZ\n\\= Expect no match\n    ZZ\n    abXYZZ\n    zzz\n    bzz\n\n/(?<!(foo)a)bar/I\n    bar\n    foobbar\n\\= Expect no match\n    fooabar\n\n# Perl does not fail these two for the final subjects.\n\n/^(xa|=?\\1a){2}$/\n    xa=xaa\n\\= Expect no match\n    xa=xaaa\n\n/^(xa|=?\\1a)+$/\n    xa=xaa\n\\= Expect no match\n    xa=xaaa\n\n# These are syntax tests from Perl 5.005\n\n/a[b-a]/\n\n/a[]b/\n\n/a[/\n\n/*a/\n\n/(*)b/\n\n/abc)/\n\n/(abc/\n\n/a**/\n\n/)(/\n\n/\\1/\n\n/\\2/\n\n/(a)|\\2/\n\n/a[b-a]/Ii\n\n/a[]b/Ii\n\n/a[/Ii\n\n/*a/Ii\n\n/(*)b/Ii\n\n/abc)/Ii\n\n/(abc/Ii\n\n/a**/Ii\n\n/)(/Ii\n\n/:(?:/\n\n/(?<%)b/\n\n/a(?{)b/\n\n/a(?{{})b/\n\n/a(?{}})b/\n\n/a(?{\"{\"})b/\n\n/a(?{\"{\"}})b/\n\n/(?(1?)a|b)/\n\n/[a[:xyz:/\n\n/(?<=x+)y/\n\n/a{37,17}/\n\n/abc/\\\n\n/abc/\\i\n\n/(a)bc(d)/I\n    abcd\n    abcd\\=copy=2\n    abcd\\=copy=5\n\n/(.{20})/I\n    abcdefghijklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\\=copy=1\n    abcdefghijklmnopqrstuvwxyz\\=get=1\n\n/(.{15})/I\n    abcdefghijklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1\n\n/(.{16})/I\n    abcdefghijklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1,getall\n\n/^(a|(bc))de(f)/I\n    adef\\=get=1,get=2,get=3,get=4,getall\n    bcdef\\=get=1,get=2,get=3,get=4,getall\n    adefghijk\\=copy=0\n\n/^abc\\00def/I\n    abc\\00def\\=copy=0,getall\n\n/word ((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)?)?)?)?)?)?)?)?)?otherword/I\n\n/.*X/IB\n\n/.*X/IBs\n\n/(.*X|^B)/IB\n\n/(.*X|^B)/IBs\n\n/(?s)(.*X|^B)/IB\n\n/(?s:.*X|^B)/IB\n\n/\\Biss\\B/I,aftertext\n    Mississippi\n\n/iss/I,aftertext,altglobal\n    Mississippi\n\n/\\Biss\\B/I,aftertext,altglobal\n    Mississippi\n\n/\\Biss\\B/Ig,aftertext\n    Mississippi\n\\= Expect no match\n    Mississippi\\=anchored\n\n/(?<=[Ms])iss/Ig,aftertext\n    Mississippi\n\n/(?<=[Ms])iss/I,aftertext,altglobal\n    Mississippi\n\n/^iss/Ig,aftertext\n    ississippi\n\n/.*iss/Ig,aftertext\n    abciss\\nxyzisspqr\n\n/.i./Ig,aftertext\n    Mississippi\n    Mississippi\\=anchored\n    Missouri river\n    Missouri river\\=anchored\n\n/^.is/Ig,aftertext\n    Mississippi\n\n/^ab\\n/Ig,aftertext\n    ab\\nab\\ncd\n\n/^ab\\n/Igm,aftertext\n    ab\\nab\\ncd\n\n/^/gm,newline=any\n    a\\rb\\nc\\r\\nxyz\\=aftertext\n\n/abc/I\n\n/abc|bac/I\n\n/(abc|bac)/I\n\n/(abc|(c|dc))/I\n\n/(abc|(d|de)c)/I\n\n/a*/I\n\n/a+/I\n\n/(baa|a+)/I\n\n/a{0,3}/I\n\n/baa{3,}/I\n\n/\"([^\\\\\"]+|\\\\.)*\"/I\n\n/(abc|ab[cd])/I\n\n/(a|.)/I\n\n/a|ba|\\w/I\n\n/abc(?=pqr)/I\n\n/...(?<=abc)/I\n\n/abc(?!pqr)/I\n\n/ab./I\n\n/ab[xyz]/I\n\n/abc*/I\n\n/ab.c*/I\n\n/a.c*/I\n\n/.c*/I\n\n/ac*/I\n\n/(a.c*|b.c*)/I\n\n/a.c*|aba/I\n\n/.+a/I\n\n/(?=abcda)a.*/I\n\n/(?=a)a.*/I\n\n/a(b)*/I\n\n/a\\d*/I\n\n/ab\\d*/I\n\n/a(\\d)*/I\n\n/abcde{0,0}/I\n\n/ab\\d+/I\n\n/a(?(1)b)(.)/I\n\n/a(?(1)bag|big)(.)/I\n\n/a(?(1)bag|big)*(.)/I\n\n/a(?(1)bag|big)+(.)/I\n\n/a(?(1)b..|b..)(.)/I\n\n/ab\\d{0}e/I\n\n/a?b?/I\n    a\n    b\n    ab\n    \\\n\\= Expect no match\n    \\=notempty\n\n/|-/I\n    abcd\n    -abc\n    ab-c\\=notempty\n\\= Expect no match\n    abc\\=notempty\n\n/^.?abcd/I\n\n/\\(             # ( at start\n  (?:           # Non-capturing bracket\n  (?>[^()]+)    # Either a sequence of non-brackets (no backtracking)\n  |             # Or\n  (?R)          # Recurse - i.e. nested bracketed string\n  )*            # Zero or more contents\n  \\)            # Closing )\n  /Ix\n    (abcd)\n    (abcd)xyz\n    xyz(abcd)\n    (ab(xy)cd)pqr\n    (ab(xycd)pqr\n    () abc ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n\\= Expect no match\n    abcd\n    abcd)\n    (abcd\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Igx\n    (ab(xy)cd)pqr\n    1(abcd)(x(y)z)pqr\n\n/\\(  (?: (?>[^()]+) | (?R) ) \\) /Ix\n    (abcd)\n    (ab(xy)cd)\n    (a(b(c)d)e)\n    ((ab))\n\\= Expect no match\n    ()\n\n/\\(  (?: (?>[^()]+) | (?R) )? \\) /Ix\n    ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Ix\n    (ab(xy)cd)\n\n/\\( ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\n    (ab(xy)cd)\n\n/\\( (123)? ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\n    (ab(xy)cd)\n    (123ab(xy)cd)\n\n/\\( ( (123)? ( (?>[^()]+) | (?R) )* ) \\) /Ix\n    (ab(xy)cd)\n    (123ab(xy)cd)\n\n/\\( (((((((((( ( (?>[^()]+) | (?R) )* )))))))))) \\) /Ix\n    (ab(xy)cd)\n\n/\\( ( ( (?>[^()<>]+) | ((?>[^()]+)) | (?R) )* ) \\) /Ix\n    (abcd(xyz<p>qrs)123)\n\n/\\( ( ( (?>[^()]+) | ((?R)) )* ) \\) /Ix\n    (ab(cd)ef)\n    (ab(cd(ef)gh)ij)\n\n/^[[:alnum:]]/IB\n\n/^[[:^alnum:]]/IB\n\n/^[[:alpha:]]/IB\n\n/^[[:^alpha:]]/IB\n\n/[_[:alpha:]]/I\n\n/^[[:ascii:]]/IB\n\n/^[[:^ascii:]]/IB\n\n/^[[:blank:]]/IB\n\n/^[[:^blank:]]/IB\n\n/[\\n\\x0b\\x0c\\x0d[:blank:]]/I\n\n/^[[:cntrl:]]/IB\n\n/^[[:digit:]]/IB\n\n/^[[:graph:]]/IB\n\n/^[[:lower:]]/IB\n\n/^[[:print:]]/IB\n\n/^[[:punct:]]/IB\n\n/^[[:space:]]/IB\n\n/^[[:upper:]]/IB\n\n/^[[:xdigit:]]/IB\n\n/^[[:word:]]/IB\n\n/^[[:^cntrl:]]/IB\n\n/^[12[:^digit:]]/IB\n\n/^[[:^blank:]]/IB\n\n/[01[:alpha:]%]/IB\n\n/[[.ch.]]/I\n\n/[[=ch=]]/I\n\n/[[:rhubarb:]]/I\n\n/[[:upper:]]/Ii\n    A\n    a\n\n/[[:lower:]]/Ii\n    A\n    a\n\n/((?-i)[[:lower:]])[[:lower:]]/Ii\n    ab\n    aB\n\\= Expect no match\n    Ab\n    AB\n\n/[\\200-\\110]/I\n\n/^(?(0)f|b)oo/I\n\n# This one's here because of the large output vector needed\n\n/(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\w+)\\s+(\\270)/I\n     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\\=ovector=300\n\n# This one's here because Perl does this differently and PCRE2 can't at present\n\n/(main(O)?)+/I\n    mainmain\n    mainOmain\n\n# These are all cases where Perl does it differently (nested captures)\n\n/^(a(b)?)+$/I\n    aba\n\n/^(aa(bb)?)+$/I\n    aabbaa\n\n/^(aa|aa(bb))+$/I\n    aabbaa\n\n/^(aa(bb)??)+$/I\n    aabbaa\n\n/^(?:aa(bb)?)+$/I\n    aabbaa\n\n/^(aa(b(b))?)+$/I\n    aabbaa\n\n/^(?:aa(b(b))?)+$/I\n    aabbaa\n\n/^(?:aa(b(?:b))?)+$/I\n    aabbaa\n\n/^(?:aa(bb(?:b))?)+$/I\n    aabbbaa\n\n/^(?:aa(b(?:bb))?)+$/I\n    aabbbaa\n\n/^(?:aa(?:b(b))?)+$/I\n    aabbaa\n\n/^(?:aa(?:b(bb))?)+$/I\n    aabbbaa\n\n/^(aa(b(bb))?)+$/I\n    aabbbaa\n\n/^(aa(bb(bb))?)+$/I\n    aabbbbaa\n\n# ----------------\n\n/#/IBx\n\n/a#/IBx\n\n/[\\s]/IB\n\n/[\\S]/IB\n\n/a(?i)b/IB\n    ab\n    aB\n\\= Expect no match\n    AB\n\n/(a(?i)b)/IB\n    ab\n    aB\n\\= Expect no match\n    AB\n\n/   (?i)abc/IBx\n\n/#this is a comment\n  (?i)abc/IBx\n\n/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n\n/\\Q123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n\n/\\Q\\E/IB\n    \\\n\n/\\Q\\Ex/IB\n\n/ \\Q\\E/IB\n\n/a\\Q\\E/IB\n  abc\n  bca\n  bac\n\n/a\\Q\\Eb/IB\n  abc\n\n/\\Q\\Eabc/IB\n\n/x*+\\w/IB\n\\= Expect no match\n    xxxxx\n\n/x?+/IB\n\n/x++/IB\n\n/x{1,3}+/B,no_auto_possess\n\n/x{1,3}+/Bi,no_auto_possess\n\n/[^x]{1,3}+/B,no_auto_possess\n\n/[^x]{1,3}+/Bi,no_auto_possess\n\n/(x)*+/IB\n\n/^(\\w++|\\s++)*$/I\n    now is the time for all good men to come to the aid of the party\n\\= Expect no match\n    this is not a line with only words and spaces!\n\n/(\\d++)(\\w)/I\n    12345a\n\\= Expect no match\n    12345+\n\n/a++b/I\n    aaab\n\n/(a++b)/I\n    aaab\n\n/(a++)b/I\n    aaab\n\n/([^()]++|\\([^()]*\\))+/I\n    ((abc(ade)ufh()()x\n\n/\\(([^()]++|\\([^()]+\\))+\\)/I\n    (abc)\n    (abc(def)xyz)\n\\= Expect no match\n    ((()aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n/(abc){1,3}+/IB\n\n/a+?+/I\n\n/a{2,3}?+b/I\n\n/(?U)a+?+/I\n\n/a{2,3}?+b/I,ungreedy\n\n/x(?U)a++b/IB\n    xaaaab\n\n/(?U)xa++b/IB\n    xaaaab\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/IB\n\n/^x(?U)a+b/IB\n\n/^x(?U)(a+)b/IB\n\n/[.x.]/I\n\n/[=x=]/I\n\n/[:x:]/I\n\n/\\F/I\n\n/\\l/I\n\n/\\L/I\n\n/\\N{name}/I\n\n/\\u/I\n\n/\\U/I\n\n/a{1,3}b/ungreedy\n    ab\n\n/[/I\n\n/[a-/I\n\n/[[:space:]/I\n\n/[\\s]/IB\n\n/[[:space:]]/IB\n\n/[[:space:]abcde]/IB\n\n/< (?: (?(R) \\d++  | [^<>]*+) | (?R)) * >/Ix\n    <>\n    <abcd>\n    <abc <123> hij>\n    <abc <def> hij>\n    <abc<>def>\n    <abc<>\n\\= Expect no match\n    <abc\n\n/8J\\$WE\\<\\.rX\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n\n/\\$\\<\\.X\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n\n/(.*)\\d+\\1/I\n\n/(.*)\\d+/I\n\n/(.*)\\d+\\1/Is\n\n/(.*)\\d+/Is\n\n/(.*(xyz))\\d+\\2/I\n\n/((.*))\\d+\\1/I\n    abc123bc\n\n/a[b]/I\n\n/(?=a).*/I\n\n/(?=abc).xyz/Ii\n\n/(?=abc)(?i).xyz/I\n\n/(?=a)(?=b)/I\n\n/(?=.)a/I\n\n/((?=abcda)a)/I\n\n/((?=abcda)ab)/I\n\n/()a/I\n\n/(?:(?=.)|(?<!x))a/I\n\n/(?(1)ab|ac)(.)/I\n\n/(?(1)abz|acz)(.)/I\n\n/(?(1)abz)(.)/I\n\n/(?(1)abz)(1)23/I\n\n/(a)+/I\n\n/(a){2,3}/I\n\n/(a)*/I\n\n/[a]/I\n\n/[ab]/I\n\n/[ab]/I\n\n/[^a]/I\n\n/\\d456/I\n\n/\\d456/I\n\n/a^b/I\n\n/^a/Im\n  abcde\n  xy\\nabc\n\\= Expect no match\n  xyabc\n\n/c|abc/I\n\n/(?i)[ab]/I\n\n/[ab](?i)cd/I\n\n/abc(?C)def/I\n    abcdef\n    1234abcdef\n\\= Expect no match\n    abcxyz\n    abcxyzf\n\n/abc(?C)de(?C1)f/I\n    123abcdef\n\n/(?C1)\\dabc(?C2)def/I\n    1234abcdef\n\\= Expect no match\n    abcdef\n\n/(?C1)\\dabc(?C2)def/I\n    1234abcdef\n\\= Expect no match\n    abcdef\n\n/(?C255)ab/I\n\n/(?C256)ab/I\n\n/(?Cab)xx/I\n\n/(?C12vr)x/I\n\n/abc(?C)def/I\n    \\x83\\x0\\x61bcdef\n\n/(abc)(?C)de(?C1)f/I\n    123abcdef\n    123abcdef\\=callout_capture\n    123abcdefC-\\=callout_none\n\\= Expect no match\n    123abcdef\\=callout_fail=1\n\n/(?C0)(abc(?C1))*/I\n    abcabcabc\n    abcabc\\=callout_fail=1:4\n    abcabcabc\\=callout_fail=1:4\n\n/(\\d{3}(?C))*/I\n    123\\=callout_capture\n    123456\\=callout_capture\n    123456789\\=callout_capture\n\n/((xyz)(?C)p|(?C1)xyzabc)/I\n    xyzabc\\=callout_capture\n\n/(X)((xyz)(?C)p|(?C1)xyzabc)/I\n    Xxyzabc\\=callout_capture\n\n/(?=(abc))(?C)abcdef/I\n    abcdef\\=callout_capture\n\n/(?!(abc)(?C1)d)(?C2)abcxyz/I\n    abcxyz\\=callout_capture\n\n/(?<=(abc)(?C))xyz/I\n   abcxyz\\=callout_capture\n\n/a(b+)(c*)(?C1)/I\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n\n/a(b+?)(c*?)(?C1)/I\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n\n/(?C)abc/I\n\n/(?C)^abc/I\n\n/(?C)a|b/I\n\n/a|(b)(?C)/I\n    b\n\n/x(ab|(bc|(de|(?R))))/I\n    xab\n    xbc\n    xde\n    xxab\n    xxxab\n\\= Expect no match\n    xyab\n\n/^([^()]|\\((?1)*\\))*$/I\n    abc\n    a(b)c\n    a(b(c))d\n\\= Expect no match)\n    a(b(c)d\n\n/^>abc>([^()]|\\((?1)*\\))*<xyz<$/I\n   >abc>123<xyz<\n   >abc>1(2)3<xyz<\n   >abc>(1(2)3)<xyz<\n\n/(a(?1)b)/IB\n\n/(a(?1)+b)/IB\n\n/^(\\d+|\\((?1)([+*-])(?1)\\)|-(?1))$/I\n    12\n    (((2+2)*-3)-7)\n    -12\n\\= Expect no match\n    ((2+2)*-3)-7)\n\n/^(x(y|(?1){2})z)/I\n    xyz\n    xxyzxyzz\n\\= Expect no match\n    xxyzz\n    xxyzxyzxyzz\n\n/((< (?: (?(R) \\d++  | [^<>]*+) | (?2)) * >))/Ix\n    <>\n    <abcd>\n    <abc <123> hij>\n    <abc <def> hij>\n    <abc<>def>\n    <abc<>\n\\= Expect no match\n    <abc\n\n/(?1)/I\n\n/((?2)(abc)/I\n\n/^(abc)def(?1)/I\n    abcdefabc\n\n/^(a|b|c)=(?1)+/I\n    a=a\n    a=b\n    a=bc\n\n/^(a|b|c)=((?1))+/I\n    a=a\n    a=b\n    a=bc\n\n/a(?P<name1>b|c)d(?P<longername2>e)/IB\n    abde\n    acde\n\n/(?:a(?P<c>c(?P<d>d)))(?P<a>a)/IB\n\n/(?P<a>a)...(?P=a)bbb(?P>a)d/IB\n\n/^\\W*(?:(?P<one>(?P<two>.)\\W*(?P>one)\\W*(?P=two)|)|(?P<three>(?P<four>.)\\W*(?P>three)\\W*(?P=four)|\\W*.\\W*))\\W*$/Ii\n    1221\n    Satan, oscillate my metallic sonatas!\n    A man, a plan, a canal: Panama!\n    Able was I ere I saw Elba.\n\\= Expect no match\n    The quick brown fox\n\n/((?(R)a|b))\\1(?1)?/I\n  bb\n  bbaa\n\n/(.*)a/Is\n\n/(.*)a\\1/Is\n\n/(.*)a(b)\\2/Is\n\n/((.*)a|(.*)b)z/Is\n\n/((.*)a|(.*)b)z\\1/Is\n\n/((.*)a|(.*)b)z\\2/Is\n\n/((.*)a|(.*)b)z\\3/Is\n\n/((.*)a|^(.*)b)z\\3/Is\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a/Is\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\31/Is\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\32/Is\n\n/(a)(bc)/IB,no_auto_capture\n  abc\n\n/(?P<one>a)(bc)/IB,no_auto_capture\n  abc\n\n/(a)(?P<named>bc)/IB,no_auto_capture\n\n/(aaa(?C1)bbb|ab)/I\n   aaabbb\n   aaabbb\\=callout_data=0\n   aaabbb\\=callout_data=1\n\\= Expect no match\n   aaabbb\\=callout_data=-1\n\n/ab(?P<one>cd)ef(?P<two>gh)/I\n    abcdefgh\n    abcdefgh\\=copy=1,get=two\n    abcdefgh\\=copy=one,copy=two\n    abcdefgh\\=copy=three\n\n/(?P<Tes>)(?P<Test>)/IB\n\n/(?P<Test>)(?P<Tes>)/IB\n\n/(?P<Z>zz)(?P<A>aa)/I\n    zzaa\\=copy=Z\n    zzaa\\=copy=A\n\n/(?P<x>eks)(?P<x>eccs)/I\n\n/(?P<abc>abc(?P<def>def)(?P<abc>xyz))/I\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)\\]\"I\n    [10,20,30,5,5,4,4,2,43,23,4234]\n\\= Expect no match\n    []\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)?\\]\"I\n    [10,20,30,5,5,4,4,2,43,23,4234]\n    []\n\n/(a(b(?2)c))?/IB\n\n/(a(b(?2)c))*/IB\n\n/(a(b(?2)c)){0,2}/IB\n\n/[ab]{1}+/B\n\n/()(?1){1}/B\n\n/()(?1)/B\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/a*.*b/IB\n\n/(a|b)*.?c/IB\n\n/abc(?C255)de(?C)f/IB\n\n/abcde/IB,auto_callout\n  abcde\n\\= Expect no match\n  abcdfe\n\n/a*b/IB,auto_callout\n  ab\n  aaaab\n  aaaacb\n\n/a*b/IB,auto_callout\n  ab\n  aaaab\n  aaaacb\n\n/a+b/IB,auto_callout\n  ab\n  aaaab\n\\= Expect no match\n  aaaacb\n\n/(abc|def)x/IB,auto_callout\n  abcx\n  defx\n\\= Expect no match\n  abcdefzx\n\n/(abc|def)x/IB,auto_callout\n  abcx\n  defx\n\\= Expect no match\n  abcdefzx\n\n/(ab|cd){3,4}/I,auto_callout\n  ababab\n  abcdabcd\n  abcdcdcdcdcd\n\n/([ab]{,4}c|xy)/IB,auto_callout\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n\n/([ab]{,4}c|xy)/IB,auto_callout\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n\n/([ab]{1,4}c|xy){4,5}?123/IB,auto_callout\n    aacaacaacaacaac123\n\n/\\b.*/I\n  ab cd\\=offset=1\n\n/\\b.*/Is\n  ab cd\\=startoffset=1\n\n/(?!.bcd).*/I\n  Xbcd12345\n\n/abcde/I\n    ab\\=ps\n    abc\\=ps\n    abcd\\=ps\n    abcde\\=ps\n    the quick brown abc\\=ps\n\\= Expect no match\\=ps\n    the quick brown abxyz fox\\=ps\n\n\"^(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/(20)?\\d\\d$\"I\n    13/05/04\\=ps\n    13/5/2004\\=ps\n    02/05/09\\=ps\n    1\\=ps\n    1/2\\=ps\n    1/2/0\\=ps\n    1/2/04\\=ps\n    0\\=ps\n    02/\\=ps\n    02/0\\=ps\n    02/1\\=ps\n\\= Expect no match\\=ps\n    \\=ps\n    123\\=ps\n    33/4/04\\=ps\n    3/13/04\\=ps\n    0/1/2003\\=ps\n    0/\\=ps\n    02/0/\\=ps\n    02/13\\=ps\n\n/0{0,2}ABC/I\n\n/\\d{3,}ABC/I\n\n/\\d*ABC/I\n\n/[abc]+DE/I\n\n/[abc]?123/I\n    123\\=ps\n    a\\=ps\n    b\\=ps\n    c\\=ps\n    c12\\=ps\n    c123\\=ps\n\n/^(?:\\d){3,5}X/I\n    1\\=ps\n    123\\=ps\n    123X\n    1234\\=ps\n    1234X\n    12345\\=ps\n    12345X\n\\= Expect no match\n    1X\n    123456\\=ps\n\n\"<(\\w+)/?>(.)*</(\\1)>\"Igms\n    <!DOCTYPE seite SYSTEM \"http://www.lco.lineas.de/xmlCms.dtd\">\\n<seite>\\n<dokumenteninformation>\\n<seitentitel>Partner der LCO</seitentitel>\\n<sprache>de</sprache>\\n<seitenbeschreibung>Partner der LINEAS Consulting\\nGmbH</seitenbeschreibung>\\n<schluesselworte>LINEAS Consulting GmbH Hamburg\\nPartnerfirmen</schluesselworte>\\n<revisit>30 days</revisit>\\n<robots>index,follow</robots>\\n<menueinformation>\\n<aktiv>ja</aktiv>\\n<menueposition>3</menueposition>\\n<menuetext>Partner</menuetext>\\n</menueinformation>\\n<lastedited>\\n<autor>LCO</autor>\\n<firma>LINEAS Consulting</firma>\\n<datum>15.10.2003</datum>\\n</lastedited>\\n</dokumenteninformation>\\n<inhalt>\\n\\n<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\\nGmbH</absatzueberschrift>\\n\\n<absatz><link ziel=\"http://www.ca.com/\" zielfenster=\"_blank\">\\n<bild name=\"logo_ca.gif\" rahmen=\"no\"/></link> <link\\nziel=\"http://www.ey.com/\" zielfenster=\"_blank\"><bild\\nname=\"logo_euy.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.cisco.de/\" zielfenster=\"_blank\">\\n<bild name=\"logo_cisco.gif\" rahmen=\"ja\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.atelion.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_atelion.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.line-information.de/\"\\nzielfenster=\"_blank\">\\n<bild name=\"logo_line_information.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><bild name=\"logo_aw.gif\" rahmen=\"no\"/></absatz>\\n\\n<absatz><link ziel=\"http://www.incognis.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_incognis.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.addcraft.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_addcraft.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.comendo.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_comendo.gif\" rahmen=\"no\"/></link></absatz>\\n\\n</inhalt>\\n</seite>\\=jitstack=1024\n\n/line\\nbreak/I\n    this is a line\\nbreak\n    line one\\nthis is a line\\nbreak in the second line\n\n/line\\nbreak/I,firstline\n    this is a line\\nbreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\n\n/line\\nbreak/Im,firstline\n    this is a line\\nbreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\n\n/(?i)(?-i)AbCd/I\n    AbCd\n\\= Expect no match\n    abcd\n\n/a{11111111111111111111}/I\n\n/(){64294967295}/I\n\n/(){2,4294967295}/I\n\n\"(?i:a)(?i:b)(?i:c)(?i:d)(?i:e)(?i:f)(?i:g)(?i:h)(?i:i)(?i:j)(k)(?i:l)A\\1B\"I\n    abcdefghijklAkB\n\n\"(?P<n0>a)(?P<n1>b)(?P<n2>c)(?P<n3>d)(?P<n4>e)(?P<n5>f)(?P<n6>g)(?P<n7>h)(?P<n8>i)(?P<n9>j)(?P<n10>k)(?P<n11>l)A\\11B\"I\n    abcdefghijklAkB\n\n\"(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)A\\11B\"I\n    abcdefghijklAkB\n\n\"(?P<name0>a)(?P<name1>a)(?P<name2>a)(?P<name3>a)(?P<name4>a)(?P<name5>a)(?P<name6>a)(?P<name7>a)(?P<name8>a)(?P<name9>a)(?P<name10>a)(?P<name11>a)(?P<name12>a)(?P<name13>a)(?P<name14>a)(?P<name15>a)(?P<name16>a)(?P<name17>a)(?P<name18>a)(?P<name19>a)(?P<name20>a)(?P<name21>a)(?P<name22>a)(?P<name23>a)(?P<name24>a)(?P<name25>a)(?P<name26>a)(?P<name27>a)(?P<name28>a)(?P<name29>a)(?P<name30>a)(?P<name31>a)(?P<name32>a)(?P<name33>a)(?P<name34>a)(?P<name35>a)(?P<name36>a)(?P<name37>a)(?P<name38>a)(?P<name39>a)(?P<name40>a)(?P<name41>a)(?P<name42>a)(?P<name43>a)(?P<name44>a)(?P<name45>a)(?P<name46>a)(?P<name47>a)(?P<name48>a)(?P<name49>a)(?P<name50>a)(?P<name51>a)(?P<name52>a)(?P<name53>a)(?P<name54>a)(?P<name55>a)(?P<name56>a)(?P<name57>a)(?P<name58>a)(?P<name59>a)(?P<name60>a)(?P<name61>a)(?P<name62>a)(?P<name63>a)(?P<name64>a)(?P<name65>a)(?P<name66>a)(?P<name67>a)(?P<name68>a)(?P<name69>a)(?P<name70>a)(?P<name71>a)(?P<name72>a)(?P<name73>a)(?P<name74>a)(?P<name75>a)(?P<name76>a)(?P<name77>a)(?P<name78>a)(?P<name79>a)(?P<name80>a)(?P<name81>a)(?P<name82>a)(?P<name83>a)(?P<name84>a)(?P<name85>a)(?P<name86>a)(?P<name87>a)(?P<name88>a)(?P<name89>a)(?P<name90>a)(?P<name91>a)(?P<name92>a)(?P<name93>a)(?P<name94>a)(?P<name95>a)(?P<name96>a)(?P<name97>a)(?P<name98>a)(?P<name99>a)(?P<name100>a)\"I\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n\"(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)\"I\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n/[^()]*(?:\\((?R)\\)[^()]*)*/I\n    (this(and)that\n    (this(and)that)\n    (this(and)that)stuff\n\n/[^()]*(?:\\((?>(?R))\\)[^()]*)*/I\n    (this(and)that\n    (this(and)that)\n\n/[^()]*(?:\\((?R)\\))*[^()]*/I\n    (this(and)that\n    (this(and)that)\n\n/(?:\\((?R)\\))*[^()]*/I\n    (this(and)that\n    (this(and)that)\n    ((this))\n\n/(?:\\((?R)\\))|[^()]*/I\n    (this(and)that\n    (this(and)that)\n    (this)\n    ((this))\n\n/\\x{0000ff}/I\n\n/^((?P<A>a1)|(?P<A>a2)b)/I\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\n    a1b\\=copy=A\n    a2b\\=copy=A\n    a1b\\=copy=Z,copy=A\n\n/(?|(?<a>)(?<b>)(?<a>)|(?<a>)(?<b>)(?<a>))/I,dupnames\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\n    ab\\=copy=A\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\n    ab\\=copy=A\n    cd\\=copy=A\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\n    cdefgh\\=copy=A\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\n    a1b\\=get=A\n    a2b\\=get=A\n    a1b\\=get=Z,get=A\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\n    ab\\=get=A\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\n    ab\\=get=A\n    cd\\=get=A\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\n    cdefgh\\=get=A\n\n/(?J)^((?P<A>a1)|(?P<A>a2)b)/I\n    a1b\\=copy=A\n    a2b\\=copy=A\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<A>d)/I\n\n# In this next test, J is not set at the outer level; consequently it isn't set\n# in the pattern's options; consequently pcre2_substring_get_byname() produces\n# a random value.\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<C>d)/I\n    a bc d\\=copy=A,copy=B,copy=C\n\n/^(?P<A>a)?(?(A)a|b)/I\n    aabc\n    bc\n\\= Expect no match\n    abc\n\n/(?:(?(ZZ)a|b)(?P<ZZ>X))+/I\n    bXaX\n\n/(?:(?(2y)a|b)(X))+/I\n\n/(?:(?(ZA)a|b)(?P<ZZ>X))+/I\n\n/(?:(?(ZZ)a|b)(?(ZZ)a|b)(?P<ZZ>X))+/I\n    bbXaaX\n\n/(?:(?(ZZ)a|\\(b\\))\\\\(?P<ZZ>X))+/I\n    (b)\\\\Xa\\\\X\n\n/(?P<ABC/I\n\n/(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\n    bXXaYYaY\n    bXYaXXaX\n\n/()()()()()()()()()(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\n    bXXaYYaY\n\n/\\s*,\\s*/I\n    \\x0b,\\x0b\n    \\x0c,\\x0d\n\n/^abc/Im,newline=lf\n    xyz\\nabc\n    xyz\\r\\nabc\n\\= Expect no match\n    xyz\\rabc\n    xyzabc\\r\n    xyzabc\\rpqr\n    xyzabc\\r\\n\n    xyzabc\\r\\npqr\n\n/^abc/Im,newline=crlf\n    xyz\\r\\nabclf>\n\\= Expect no match\n    xyz\\nabclf\n    xyz\\rabclf\n\n/^abc/Im,newline=cr\n    xyz\\rabc\n\\= Expect no match\n    xyz\\nabc\n    xyz\\r\\nabc\n\n/^abc/Im,newline=bad\n\n/.*/I,newline=lf\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/.*/I,newline=cr\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/.*/I,newline=crlf\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/\\w+(.)(.)?def/Is\n    abc\\ndef\n    abc\\rdef\n    abc\\r\\ndef\n\n/(?P<B>25[0-5]|2[0-4]\\d|[01]?\\d?\\d)(?:\\.(?P>B)){3}/I\n\n/()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n (.(.))/Ix\n    XY\\=ovector=133\n\n/(a*b|(?i:c*(?-i)d))/I\n\n/()[ab]xyz/I\n\n/(|)[ab]xyz/I\n\n/(|c)[ab]xyz/I\n\n/(|c?)[ab]xyz/I\n\n/(d?|c?)[ab]xyz/I\n\n/(d?|c)[ab]xyz/I\n\n/^a*b\\d/IB\n\n/^a*+b\\d/IB\n\n/^a*?b\\d/IB\n\n/^a+A\\d/IB\n    aaaA5\n\\= Expect no match\n    aaaa5\n\n/^a*A\\d/IBi\n    aaaA5\n    aaaa5\n    a5 \n\n/(a*|b*)[cd]/I\n\n/(a+|b*)[cd]/I\n\n/(a*|b+)[cd]/I\n\n/(a+|b+)[cd]/I\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n (((\n a\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n )))\n/Ix\n  large nest\n\n/a*\\d/B\n\n/a*\\D/B\n\n/0*\\d/B\n\n/0*\\D/B\n\n/a*\\s/B\n\n/a*\\S/B\n\n/ *\\s/B\n\n/ *\\S/B\n\n/a*\\w/B\n\n/a*\\W/B\n\n/=*\\w/B\n\n/=*\\W/B\n\n/\\d*a/B\n\n/\\d*2/B\n\n/\\d*\\d/B\n\n/\\d*\\D/B\n\n/\\d*\\s/B\n\n/\\d*\\S/B\n\n/\\d*\\w/B\n\n/\\d*\\W/B\n\n/\\D*a/B\n\n/\\D*2/B\n\n/\\D*\\d/B\n\n/\\D*\\D/B\n\n/\\D*\\s/B\n\n/\\D*\\S/B\n\n/\\D*\\w/B\n\n/\\D*\\W/B\n\n/\\s*a/B\n\n/\\s*2/B\n\n/\\s*\\d/B\n\n/\\s*\\D/B\n\n/\\s*\\s/B\n\n/\\s*\\S/B\n\n/\\s*\\w/B\n\n/\\s*\\W/B\n\n/\\S*a/B\n\n/\\S*2/B\n\n/\\S*\\d/B\n\n/\\S*\\D/B\n\n/\\S*\\s/B\n\n/\\S*\\S/B\n\n/\\S*\\w/B\n\n/\\S*\\W/B\n\n/\\w*a/B\n\n/\\w*2/B\n\n/\\w*\\d/B\n\n/\\w*\\D/B\n\n/\\w*\\s/B\n\n/\\w*\\S/B\n\n/\\w*\\w/B\n\n/\\w*\\W/B\n\n/\\W*a/B\n\n/\\W*2/B\n\n/\\W*\\d/B\n\n/\\W*\\D/B\n\n/\\W*\\s/B\n\n/\\W*\\S/B\n\n/\\W*\\w/B\n\n/\\W*\\W/B\n\n/[^a]+a/B\n\n/[^a]+a/Bi\n\n/[^a]+A/Bi\n\n/[^a]+b/B\n\n/[^a]+\\d/B\n\n/a*[^a]/B\n\n/(?P<abc>x)(?P<xyz>y)/I\n    xy\\=copy=abc,copy=xyz\n\n/(?<abc>x)(?'xyz'y)/I\n    xy\\=copy=abc,copy=xyz\n\n/(?<abc'x)(?'xyz'y)/I\n\n/(?<abc>x)(?'xyz>y)/I\n\n/(?P'abc'x)(?P<xyz>y)/I\n\n/^(?:(?(ZZ)a|b)(?<ZZ>X))+/\n    bXaX\n    bXbX\n\\= Expect no match\n    aXaX\n    aXbX\n\n/^(?P>abc)(?<abcd>xxx)/\n\n/^(?P>abc)(?<abc>x|y)/\n    xx\n    xy\n    yy\n    yx\n\n/^(?P>abc)(?P<abc>x|y)/\n    xx\n    xy\n    yy\n    yx\n\n/^((?(abc)a|b)(?<abc>x|y))+/\n    bxay\n    bxby\n\\= Expect no match\n    axby\n\n/^(((?P=abc)|X)(?<abc>x|y))+/\n    XxXxxx\n    XxXyyx\n    XxXyxx\n\\= Expect no match\n    x\n\n/^(?1)(abc)/\n    abcabc\n\n/^(?:(?:\\1|X)(a|b))+/\n    Xaaa\n    Xaba\n\n/^[\\E\\Qa\\E-\\Qz\\E]+/B\n\n/^[a\\Q]bc\\E]/B\n\n/^[a-\\Q\\E]/B\n\n/^(?P>abc)[()](?<abc>)/B\n\n/^((?(abc)y)[()](?P<abc>x))+/B\n    (xy)x\n\n/^(?P>abc)\\Q()\\E(?<abc>)/B\n\n/^(?P>abc)[a\\Q(]\\E(](?<abc>)/B\n\n/^(?P>abc) # this is (a comment)\n  (?<abc>)/Bx\n\n/^\\W*(?:(?<one>(?<two>.)\\W*(?&one)\\W*\\k<two>|)|(?<three>(?<four>.)\\W*(?&three)\\W*\\k'four'|\\W*.\\W*))\\W*$/Ii\n    1221\n    Satan, oscillate my metallic sonatas!\n    A man, a plan, a canal: Panama!\n    Able was I ere I saw Elba.\n\\= Expect no match\n    The quick brown fox\n\n/(?=(\\w+))\\1:/I\n    abcd:\n\n/(?=(?'abc'\\w+))\\k<abc>:/I\n    abcd:\n\n/(?'abc'a|b)(?<abc>d|e)\\k<abc>{2}/dupnames\n    adaa\n\\= Expect no match\n    addd\n    adbb\n\n/(?'abc'a|b)(?<abc>d|e)(?&abc){2}/dupnames\n    bdaa\n    bdab\n\\= Expect no match\n    bddd\n\n/(?(<bc))/\n\n/(?(''))/\n\n/(?('R')stuff)/\n\n/((abc (?(R) (?(R1)1) (?(R2)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n\n/(?<A> (?'B' abc (?(R) (?(R&A)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n\n/(?<A> (?'B' abc (?(R) (?(R&C)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\n\n/^(?(DEFINE) abc | xyz ) /x\n\n/(?(DEFINE) abc) xyz/Ix\n\n/(a|)*\\d/\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\\=ovector=0\n\\= Expect no match\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\=ovector=0\n\n/^a.b/newline=lf\n    a\\rb\n\\= Expect no match\n    a\\nb\n\n/^a.b/newline=cr\n    a\\nb\n\\= Expect no match\n    a\\rb\n\n/^a.b/newline=anycrlf\n    a\\x85b\n\\= Expect no match\n    a\\rb\n\n/^a.b/newline=any\n\\= Expect no match\n    a\\nb\n    a\\rb\n    a\\x85b\n\n/^abc./gmx,newline=any\n    abc1 \\x0aabc2 \\x0babc3xx \\x0cabc4 \\x0dabc5xx \\x0d\\x0aabc6 \\x85abc7 JUNK\n\n/abc.$/gmx,newline=any\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc7 abc9\n\n/^a\\Rb/bsr=unicode\n    a\\nb\n    a\\rb\n    a\\r\\nb\n    a\\x0bb\n    a\\x0cb\n    a\\x85b\n\\= Expect no match\n    a\\n\\rb\n\n/^a\\R*b/bsr=unicode\n    ab\n    a\\nb\n    a\\rb\n    a\\r\\nb\n    a\\x0bb\n    a\\x0cb\n    a\\x85b\n    a\\n\\rb\n    a\\n\\r\\x85\\x0cb\n\n/^a\\R+b/bsr=unicode\n    a\\nb\n    a\\rb\n    a\\r\\nb\n    a\\x0bb\n    a\\x0cb\n    a\\x85b\n    a\\n\\rb\n    a\\n\\r\\x85\\x0cb\n\\= Expect no match\n    ab\n\n/^a\\R{1,3}b/bsr=unicode\n    a\\nb\n    a\\n\\rb\n    a\\n\\r\\x85b\n    a\\r\\n\\r\\nb\n    a\\r\\n\\r\\n\\r\\nb\n    a\\n\\r\\n\\rb\n    a\\n\\n\\r\\nb\n\\= Expect no match\n    a\\n\\n\\n\\rb\n    a\\r\n\n/(?&abc)X(?<abc>P)/I\n    abcPXP123\n\n/(?1)X(?<abc>P)/I\n    abcPXP123\n\n/(?:a(?&abc)b)*(?<abc>x)/\n    123axbaxbaxbx456\n    123axbaxbaxb456\n\n/(?:a(?&abc)b){1,5}(?<abc>x)/\n    123axbaxbaxbx456\n\n/(?:a(?&abc)b){2,5}(?<abc>x)/\n    123axbaxbaxbx456\n\n/(?:a(?&abc)b){2,}(?<abc>x)/\n    123axbaxbaxbx456\n\n/(abc)(?i:(?1))/\n    defabcabcxyz\n\\= Expect no match\n    DEFabcABCXYZ\n\n/(abc)(?:(?i)(?1))/\n    defabcabcxyz\n\\= Expect no match\n    DEFabcABCXYZ\n\n/^(a)\\g-2/\n\n/^(a)\\g/\n\n/^(a)\\g{0}/\n\n/^(a)\\g{3/\n\n/^(a)\\g{aa}/\n\n/^a.b/newline=lf\n    a\\rb\n\\= Expect no match\n    a\\nb\n\n/.+foo/\n    afoo\n\\= Expect no match\n    \\r\\nfoo\n    \\nfoo\n\n/.+foo/newline=crlf\n    afoo\n    \\nfoo\n\\= Expect no match\n    \\r\\nfoo\n\n/.+foo/newline=any\n    afoo\n\\= Expect no match\n    \\nfoo\n    \\r\\nfoo\n\n/.+foo/s\n    afoo\n    \\r\\nfoo\n    \\nfoo\n\n/^$/gm,newline=any\n    abc\\r\\rxyz\n    abc\\n\\rxyz\n\\= Expect no match\n    abc\\r\\nxyz\n\n/(?m)^$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n\n/(?m)^$|^\\r\\n/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n\n/(?m)$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n\n/abc.$/gmx,newline=anycrlf\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc9\n\n/^X/m\n    XABC\n\\= Expect no match\n    XABC\\=notbol\n\n/(ab|c)(?-1)/B\n    abc\n\n/xy(?+1)(abc)/B\n    xyabcabc\n\\= Expect no match\n    xyabc\n\n/x(?-0)y/\n\n/x(?-1)y/\n\n/x(?+0)y/\n\n/x(?+1)y/\n\n/^(abc)?(?(-1)X|Y)/B\n    abcX\n    Y\n\\= Expect no match\n    abcY\n\n/^((?(+1)X|Y)(abc))+/B\n    YabcXabc\n    YabcXabcXabc\n\\= Expect no match\n    XabcXabc\n\n/(?(-1)a)/B\n\n/((?(-1)a))/B\n\n/((?(-2)a))/B\n\n/^(?(+1)X|Y)(.)/B\n    Y!\n\n/(?<A>tom|bon)-\\k{A}/\n    tom-tom\n    bon-bon\n\\= Expect no match\n    tom-bon\n\n/\\g{A/\n\n/(?|(abc)|(xyz))/B\n   >abc<\n   >xyz<\n\n/(x)(?|(abc)|(xyz))(x)/B\n    xabcx\n    xxyzx\n\n/(x)(?|(abc)(pqr)|(xyz))(x)/B\n    xabcpqrx\n    xxyzx\n\n/\\H++X/B\n\\= Expect no match\n    XXXX\n\n/\\H+\\hY/B\n    XXXX Y\n\n/\\H+ Y/B\n\n/\\h+A/B\n\n/\\v*B/B\n\n/\\V+\\x0a/B\n\n/A+\\h/B\n\n/ *\\H/B\n\n/A*\\v/B\n\n/\\x0b*\\V/B\n\n/\\d+\\h/B\n\n/\\d*\\v/B\n\n/S+\\h\\S+\\v/B\n\n/\\w{3,}\\h\\w+\\v/B\n\n/\\h+\\d\\h+\\w\\h+\\S\\h+\\H/B\n\n/\\v+\\d\\v+\\w\\v+\\S\\v+\\V/B\n\n/\\H+\\h\\H+\\d/B\n\n/\\V+\\v\\V+\\w/B\n\n/\\( (?: [^()]* | (?R) )* \\)/x\n(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\\=jitstack=1024\n\n/[\\E]AAA/\n\n/[\\Q\\E]AAA/\n\n/[^\\E]AAA/\n\n/[^\\Q\\E]AAA/\n\n/[\\E^]AAA/\n\n/[\\Q\\E^]AAA/\n\n/A(*PRUNE)B(*SKIP)C(*THEN)D(*COMMIT)E(*F)F(*FAIL)G(?!)H(*ACCEPT)I/B\n\n/^a+(*FAIL)/auto_callout\n\\= Expect no match\n    aaaaaa\n\n/a+b?c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a+b?(*PRUNE)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a+b?(*COMMIT)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a+b?(*SKIP)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabcccaaabccc\n\n/a+b?(*THEN)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n\n/a(*MARK)b/\n\n/\\g6666666666/\n\n/[\\g6666666666]/B\n\n/(?1)\\c[/\n\n/.+A/newline=crlf\n\\= Expect no match\n    \\r\\nA\n\n/\\nA/newline=crlf\n    \\r\\nA\n\n/[\\r\\n]A/newline=crlf\n    \\r\\nA\n\n/(\\r|\\n)A/newline=crlf\n    \\r\\nA\n\n/a(*CR)b/\n\n/(*CR)a.b/\n    a\\nb\n\\= Expect no match\n    a\\rb\n\n/(*CR)a.b/newline=lf\n    a\\nb\n\\= Expect no match\n    a\\rb\n\n/(*LF)a.b/newline=CRLF\n    a\\rb\n\\= Expect no match\n    a\\nb\n\n/(*CRLF)a.b/\n    a\\rb\n    a\\nb\n\\= Expect no match\n    a\\r\\nb\n\n/(*ANYCRLF)a.b/newline=CR\n\\= Expect no match\n    a\\rb\n    a\\nb\n    a\\r\\nb\n\n/(*ANY)a.b/newline=cr\n\\= Expect no match\n    a\\rb\n    a\\nb\n    a\\r\\nb\n    a\\x85b\n\n/(*ANY).*/g\n    abc\\r\\ndef\n\n/(*ANYCRLF).*/g\n    abc\\r\\ndef\n\n/(*CRLF).*/g\n    abc\\r\\ndef\n\n/(*NUL)^.*/\n    a\\nb\\x00ccc\n\n/(*NUL)^.*/s\n    a\\nb\\x00ccc\n\n/^x/m,newline=NUL\n    ab\\x00xy\n\n/'#comment' 0d 0a 00 '^x\\' 0a 'y'/x,newline=nul,hex\n    x\\nyz\n\n/(*NUL)^X\\NY/\n    X\\nY\n    X\\rY\n\\= Expect no match\n    X\\x00Y\n\n/a\\Rb/I,bsr=anycrlf\n    a\\rb\n    a\\nb\n    a\\r\\nb\n\\= Expect no match\n    a\\x85b\n    a\\x0bb\n\n/a\\Rb/I,bsr=unicode\n    a\\rb\n    a\\nb\n    a\\r\\nb\n    a\\x85b\n    a\\x0bb\n\n/a\\R?b/I,bsr=anycrlf\n    a\\rb\n    a\\nb\n    a\\r\\nb\n\\= Expect no match\n    a\\x85b\n    a\\x0bb\n\n/a\\R?b/I,bsr=unicode\n    a\\rb\n    a\\nb\n    a\\r\\nb\n    a\\x85b\n    a\\x0bb\n\n/a\\R{2,4}b/I,bsr=anycrlf\n    a\\r\\n\\nb\n    a\\n\\r\\rb\n    a\\r\\n\\r\\n\\r\\n\\r\\nb\n\\= Expect no match\n    a\\x85\\x85b\n    a\\x0b\\x0bb\n\n/a\\R{2,4}b/I,bsr=unicode\n    a\\r\\rb\n    a\\n\\n\\nb\n    a\\r\\n\\n\\r\\rb\n    a\\x85\\x85b\n    a\\x0b\\x0bb\n\\= Expect no match\n    a\\r\\r\\r\\r\\rb\n\n/(*BSR_ANYCRLF)a\\Rb/I\n    a\\nb\n    a\\rb\n\n/(*BSR_UNICODE)a\\Rb/I\n    a\\x85b\n\n/(*BSR_ANYCRLF)(*CRLF)a\\Rb/I\n    a\\nb\n    a\\rb\n\n/(*CRLF)(*BSR_UNICODE)a\\Rb/I\n    a\\x85b\n\n/(*CRLF)(*BSR_ANYCRLF)(*CR)ab/I\n\n/(?<a>)(?&)/\n\n/(?<abc>)(?&a)/\n\n/(?<a>)(?&aaaaaaaaaaaaaaaaaaaaaaa)/\n\n/(?+-a)/\n\n/(?-+a)/\n\n/(?(-1))/\n\n/(?(+10))/\n\n/(?(10))/\n\n/(?(+2))()()/\n\n/(?(2))()()/\n\n/\\k''/\n\n/\\k<>/\n\n/\\k{}/\n\n/\\k/\n\n/\\kabc/\n\n/(?P=)/\n\n/(?P>)/\n\n/[[:foo:]]/\n\n/[[:1234:]]/\n\n/[[:f\\oo:]]/\n\n/[[: :]]/\n\n/[[:...:]]/\n\n/[[:l\\ower:]]/\n\n/[[:abc\\:]]/\n\n/[abc[:x\\]pqr:]]/\n\n/[[:a\\dz:]]/\n\n/(^(a|b\\g<-1'c))/\n\n/^(?+1)(?<a>x|y){0}z/\n    xzxx\n    yzyy\n\\= Expect no match\n    xxz\n\n/(\\3)(\\1)(a)/\n\\= Expect no match\n    cat\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n\n/TA]/\n    The ACTA] comes\n\n/TA]/allow_empty_class,match_unset_backref,dupnames\n    The ACTA] comes\n\n/(?2)[]a()b](abc)/\n    abcbabc\n\n/(?2)[^]a()b](abc)/\n    abcbabc\n\n/(?1)[]a()b](abc)/\n    abcbabc\n\\= Expect no match\n    abcXabc\n\n/(?1)[^]a()b](abc)/\n    abcXabc\n\\= Expect no match\n    abcbabc\n\n/(?2)[]a()b](abc)(xyz)/\n    xyzbabcxyz\n\n/(?&N)[]a(?<N>)](?<M>abc)/\n   abc<abc\n\n/(?&N)[]a(?<N>)](abc)/\n   abc<abc\n\n/a[]b/\n\n/a[^]b/\n\n/a[]b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\n\n/a[]+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\n\n/a[]*+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\n\n/a[^]b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n    a\\nb\n\\= Expect no match\n    ab\n\n/a[^]+b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n    a\\nX\\nXb\n\\= Expect no match\n    ab\n\n/a(?!)b/B\n\n/(?!)?a/B\n    ab\n\n/a(*FAIL)+b/\n\n/(abc|pqr|123){0}[xyz]/I\n\n/(?(?=.*b)b|^)/I,auto_callout\n   adc\n   abc\n\n/(?(?=b).*b|^d)/I\n\n/(?(?=.*b).*b|^d)/I\n\n/xyz/auto_callout\n  xyz\n  abcxyz\n\\= Expect no match\n  abc\n  abcxypqr\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n\\= Expect no match\n  abc\n  abcxypqr\n\n/(*NO_START_OPT)xyz/auto_callout\n  abcxyz\n\n/(*NO_AUTO_POSSESS)a+b/B\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n\n/^\"((?(?=[a])[^\"])|b)*\"$/auto_callout\n    \"ab\"\n\n/^\"((?(?=[a])[^\"])|b)*\"$/\n    \"ab\"\n\n/^X(?5)(a)(?|(b)|(q))(c)(d)Y/\n    XYabcdY\n\n/^X(?&N)(a)(?|(b)|(q))(c)(d)(?<N>Y)/\n    XYabcdY\n\n/Xa{2,4}b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/Xa{2,4}?b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/Xa{2,4}+b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X\\d{2,4}b/\n    X\\=ps\n    X3\\=ps\n    X33\\=ps\n    X333\\=ps\n    X3333\\=ps\n\n/X\\d{2,4}?b/\n    X\\=ps\n    X3\\=ps\n    X33\\=ps\n    X333\\=ps\n    X3333\\=ps\n\n/X\\d{2,4}+b/\n    X\\=ps\n    X3\\=ps\n    X33\\=ps\n    X333\\=ps\n    X3333\\=ps\n\n/X\\D{2,4}b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X\\D{2,4}?b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X\\D{2,4}+b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[abc]{2,4}b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[abc]{2,4}?b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[abc]{2,4}+b/\n    X\\=ps\n    Xa\\=ps\n    Xaa\\=ps\n    Xaaa\\=ps\n    Xaaaa\\=ps\n\n/X[^a]{2,4}b/\n    X\\=ps\n    Xz\\=ps\n    Xzz\\=ps\n    Xzzz\\=ps\n    Xzzzz\\=ps\n\n/X[^a]{2,4}?b/\n    X\\=ps\n    Xz\\=ps\n    Xzz\\=ps\n    Xzzz\\=ps\n    Xzzzz\\=ps\n\n/X[^a]{2,4}+b/\n    X\\=ps\n    Xz\\=ps\n    Xzz\\=ps\n    Xzzz\\=ps\n    Xzzzz\\=ps\n\n/(Y)X\\1{2,4}b/\n    YX\\=ps\n    YXY\\=ps\n    YXYY\\=ps\n    YXYYY\\=ps\n    YXYYYY\\=ps\n\n/(Y)X\\1{2,4}?b/\n    YX\\=ps\n    YXY\\=ps\n    YXYY\\=ps\n    YXYYY\\=ps\n    YXYYYY\\=ps\n\n/(Y)X\\1{2,4}+b/\n    YX\\=ps\n    YXY\\=ps\n    YXYY\\=ps\n    YXYYY\\=ps\n    YXYYYY\\=ps\n\n/\\++\\KZ|\\d+X|9+Y/startchar\n    ++++123999\\=ps\n    ++++123999Y\\=ps\n    ++++Z1234\\=ps\n\n/Z(*F)/\n\\= Expect no match\n    Z\\=ps\n    ZA\\=ps\n\n/Z(?!)/\n\\= Expect no match\n    Z\\=ps\n    ZA\\=ps\n\n/dog(sbody)?/\n    dogs\\=ps\n    dogs\\=ph\n\n/dog(sbody)??/\n    dogs\\=ps\n    dogs\\=ph\n\n/dog|dogsbody/\n    dogs\\=ps\n    dogs\\=ph\n\n/dogsbody|dog/\n    dogs\\=ps\n    dogs\\=ph\n\n/\\bthe cat\\b/\n    the cat\\=ps\n    the cat\\=ph\n\n/abc/\n   abc\\=ps\n   abc\\=ph\n\n/abc\\K123/startchar\n    xyzabc123pqr\n    xyzabc12\\=ps\n    xyzabc12\\=ph\n\n/(?<=abc)123/\n    xyzabc123pqr\n    xyzabc12\\=ps\n    xyzabc12\\=ph\n\n/\\babc\\b/\n    +++abc+++\n    +++ab\\=ps\n    +++ab\\=ph\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^m][^>]>[^<])(?<word>\\w*+))/B\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^\\d][^>]>[^<])(?<word>\\w*+))/B\n\n/(ab)(x(y)z(cd(*ACCEPT)))pq/B\n\n/abc\\K/aftertext,startchar\n    abcdef\n    abcdef\\=notempty_atstart\n    xyzabcdef\\=notempty_atstart\n\\= Expect no match\n    abcdef\\=notempty\n    xyzabcdef\\=notempty\n\n/^(?:(?=abc)|abc\\K)/aftertext,startchar\n    abcdef\n    abcdef\\=notempty_atstart\n\\= Expect no match\n    abcdef\\=notempty\n\n/a?b?/aftertext\n    xyz\n    xyzabc\n    xyzabc\\=notempty\n    xyzabc\\=notempty_atstart\n    xyz\\=notempty_atstart\n\\= Expect no match\n    xyz\\=notempty\n\n/^a?b?/aftertext\n    xyz\n    xyzabc\n\\= Expect no match\n    xyzabc\\=notempty\n    xyzabc\\=notempty_atstart\n    xyz\\=notempty_atstart\n    xyz\\=notempty\n\n/^(?<name>a|b\\g<name>c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(?<name>a|b\\g'name'c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(a|b\\g<1>c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(a|b\\g'1'c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/^(a|b\\g'-1'c)/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/(^(a|b\\g<-1>c))/\n    aaaa\n    bacxxx\n    bbaccxxx\n    bbbacccxx\n\n/(?-i:\\g<name>)(?i:(?<name>a))/\n    XaaX\n    XAAX\n\n/(?i:\\g<name>)(?-i:(?<name>a))/\n    XaaX\n\\= Expect no match\n    XAAX\n\n/(?-i:\\g<+1>)(?i:(a))/\n    XaaX\n    XAAX\n\n/(?=(?<regex>(?#simplesyntax)\\$(?<name>[a-zA-Z_\\x{7f}-\\x{ff}][a-zA-Z0-9_\\x{7f}-\\x{ff}]*)(?:\\[(?<index>[a-zA-Z0-9_\\x{7f}-\\x{ff}]+|\\$\\g<name>)\\]|->\\g<name>(\\(.*?\\))?)?|(?#simple syntax withbraces)\\$\\{(?:\\g<name>(?<indices>\\[(?:\\g<index>|'(?:\\\\.|[^'\\\\])*'|\"(?:\\g<regex>|\\\\.|[^\"\\\\])*\")\\])?|\\g<complex>|\\$\\{\\g<complex>\\})\\}|(?#complexsyntax)\\{(?<complex>\\$(?<segment>\\g<name>(\\g<indices>*|\\(.*?\\))?)(?:->\\g<segment>)*|\\$\\g<complex>|\\$\\{\\g<complex>\\})\\}))\\{/\n\n/(?<n>a|b|c)\\g<n>*/\n   abc\n   accccbbb\n\n/^X(?7)(a)(?|(b)|(q)(r)(s))(c)(d)(Y)/\n    XYabcdY\n\n/(?<=b(?1)|zzz)(a)/\n    xbaax\n    xzzzax\n\n/(a)(?<=b\\1)/\n\n/(a)(?<=b+(?1))/\n\n/(a+)(?<=b(?1))/\n\n/(a(?<=b(?1)))/\n\n/(?<=b(?1))xyz/\n\n/(?<=b(?1))xyz(b+)pqrstuvew/\n\n/(a|bc)\\1/I\n\n/(a|bc)\\1{2,3}/I\n\n/(a|bc)(?1)/I\n\n/(a|b\\1)(a|b\\1)/I\n\n/(a|b\\1){2}/I\n\n/(a|bbbb\\1)(a|bbbb\\1)/I\n\n/(a|bbbb\\1){2}/I\n\n/^From +([^ ]+) +[a-zA-Z][a-zA-Z][a-zA-Z] +[a-zA-Z][a-zA-Z][a-zA-Z] +[0-9]?[0-9] +[0-9][0-9]:[0-9][0-9]/I\n\n/<tr([\\w\\W\\s\\d][^<>]{0,})><TD([\\w\\W\\s\\d][^<>]{0,})>([\\d]{0,}\\.)(.*)((<BR>([\\w\\W\\s\\d][^<>]{0,})|[\\s]{0,}))<\\/a><\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><\\/TR>/Iis\n\n\"(?>.*/)foo\"I\n\n/(?(?=[^a-z]+[a-z])  \\d{2}-[a-z]{3}-\\d{2}  |  \\d{2}-\\d{2}-\\d{2} ) /Ix\n\n/(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))/Ii\n\n/(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))/I\n\n/<a[\\s]+href[\\s]*=[\\s]*          # find <a href=\n ([\\\"\\'])?                       # find single or double quote\n (?(1) (.*?)\\1 | ([^\\s]+))       # if quote found, match up to next matching\n                                 # quote, otherwise match up to next space\n/Iisx\n\n/^(?!:)                       # colon disallowed at start\n  (?:                         # start of item\n    (?: [0-9a-f]{1,4} |       # 1-4 hex digits or\n    (?(1)0 | () ) )           # if null previously matched, fail; else null\n    :                         # followed by colon\n  ){1,7}                      # end item; 1-7 of them required\n  [0-9a-f]{1,4} $             # final hex number at end of string\n  (?(1)|.)                    # check that there was an empty component\n  /Iix\n\n/(?|(?<a>A)|(?<a>B))/I\n    AB\\=copy=a\n    BA\\=copy=a\n\n/(?|(?<a>A)|(?<b>B))/\n\n/(?:a(?<quote> (?<apostrophe>')|(?<realquote>\")) |\n    b(?<quote> (?<apostrophe>')|(?<realquote>\")) )\n    (?('quote')[a-z]+|[0-9]+)/Ix,dupnames\n    a\"aaaaa\n    b\"aaaaa\n\\= Expect no match\n    b\"11111\n    a\"11111\n\n/^(?|(a)(b)(c)(?<D>d)|(?<D>e)) (?('D')X|Y)/IBx,dupnames\n    abcdX\n    eX\n\\= Expect no match\n    abcdY\n    ey\n\n/(?<A>a) (b)(c)  (?<A>d  (?(R&A)$ | (?4)) )/IBx,dupnames\n    abcdd\n\\= Expect no match\n    abcdde\n\n/abcd*/\n    xxxxabcd\\=ps\n    xxxxabcd\\=ph\n\n/abcd*/i\n    xxxxabcd\\=ps\n    xxxxabcd\\=ph\n    XXXXABCD\\=ps\n    XXXXABCD\\=ph\n\n/abc\\d*/\n    xxxxabc1\\=ps\n    xxxxabc1\\=ph\n\n/(a)bc\\1*/\n    xxxxabca\\=ps\n    xxxxabca\\=ph\n\n/abc[de]*/\n    xxxxabcde\\=ps\n    xxxxabcde\\=ph\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n\n/(\\3)(\\1)(a)/I,allow_empty_class,match_unset_backref,dupnames\n    cat\n\n/(\\3)(\\1)(a)/I\n\\= Expect no match\n    cat\n\n/i(?(DEFINE)(?<s>a))/I\n    i\n\n/()i(?(1)a)/I\n    ia\n\n/(?i)a(?-i)b|c/B\n    XabX\n    XAbX\n    CcC\n\\= Expect no match\n    XABX\n\n/(?i)a(?s)b|c/B\n\n/(?i)a(?s-i)b|c/B\n\n/^(ab(c\\1)d|x){2}$/B\n    xabcxd\n\n/^(?&t)*+(?(DEFINE)(?<t>.))$/B\n\n/^(?&t)*(?(DEFINE)(?<t>.))$/B\n\n# This one is here because Perl gives the match as \"b\" rather than \"ab\". I\n# believe this to be a Perl bug.\n\n/(?>a\\Kb)z|(ab)/\n    ab\\=startchar\n\n/(?P<L1>(?P<L2>0|)|(?P>L2)(?P>L1))/\n    abcd\n    0abc\n\n/abc(*MARK:)pqr/\n\n/abc(*:)pqr/\n\n/(*COMMIT:X)/B\n\n# This should, and does, fail. In Perl, it does not, which I think is a\n# bug because replacing the B in the pattern by (B|D) does make it fail.\n# Turning off Perl's optimization by inserting (??{\"\"}) also makes it fail.\n\n/A(*COMMIT)B/aftertext,mark\n\\= Expect no match\n    ACABX\n\n# These should be different, but in Perl they are not, which I think\n# is a bug in Perl.\n\n/A(*THEN)B|A(*THEN)C/mark\n    AC\n\n/A(*PRUNE)B|A(*PRUNE)C/mark\n\\= Expect no match\n    AC\n\n# Mark names can be duplicated. Perl doesn't give a mark for this one,\n# though PCRE2 does.\n\n/^A(*:A)B|^X(*:A)Y/mark\n\\= Expect no match\n    XAQQ\n\n# COMMIT at the start of a pattern should be the same as an anchor. Perl\n# optimizations defeat this. So does the PCRE2 optimization unless we disable\n# it.\n\n/(*COMMIT)ABC/\n    ABCDEFG\n\n/(*COMMIT)ABC/no_start_optimize\n\\= Expect no match\n    DEFGABC\n\n/^(ab (c+(*THEN)cd) | xyz)/x\n\\= Expect no match\n    abcccd\n\n/^(ab (c+(*PRUNE)cd) | xyz)/x\n\\= Expect no match\n    abcccd\n\n/^(ab (c+(*FAIL)cd) | xyz)/x\n\\= Expect no match\n    abcccd\n\n# Perl gets some of these wrong\n\n/(?>.(*ACCEPT))*?5/\n    abcde\n\n/(.(*ACCEPT))*?5/\n    abcde\n\n/(.(*ACCEPT))5/\n    abcde\n\n/(.(*ACCEPT))*5/\n    abcde\n\n/A\\NB./B\n    ACBD\n\\= Expect no match\n    A\\nB\n    ACB\\n\n\n/A\\NB./Bs\n    ACBD\n    ACB\\n\n\\= Expect no match\n    A\\nB\n\n/A\\NB/newline=crlf\n    A\\nB\n    A\\rB\n\\= Expect no match\n    A\\r\\nB\n\n/\\R+b/B\n\n/\\R+\\n/B\n\n/\\R+\\d/B\n\n/\\d*\\R/B\n\n/\\s*\\R/B\n    \\x20\\x0a\n    \\x20\\x0d\n    \\x20\\x0d\\x0a\n\n/\\S*\\R/B\n    a\\x0a\n\n/X\\h*\\R/B\n    X\\x20\\x0a\n\n/X\\H*\\R/B\n    X\\x0d\\x0a\n\n/X\\H+\\R/B\n    X\\x0d\\x0a\n\n/X\\H++\\R/B\n\\= Expect no match\n    X\\x0d\\x0a\n\n/(?<=abc)def/\n    abc\\=ph\n\n/abc$/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc$/m\n    abc\n    abc\\n\n    abc\\=ph\n    abc\\n\\=ph\n    abc\\=ps\n    abc\\n\\=ps\n\n/abc\\z/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc\\Z/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc\\b/\n    abc\n    abc\\=ps\n    abc\\=ph\n\n/abc\\B/\n    abc\\=ps\n    abc\\=ph\n\\= Expect no match\n    abc\n\n/.+/\n\\= Bad offsets\n    abc\\=offset=4\n    abc\\=offset=-4\n\\= Valid data\n    abc\\=offset=0\n    abc\\=offset=1\n    abc\\=offset=2\n\\= Expect no match\n    abc\\=offset=3\n\n/^\\c\u0123/\n\n/(?P<abn>(?P=abn)xxx)/B\n\n/(a\\1z)/B\n\n/(?P<abn>(?P=abn)(?<badstufxxx)/B\n\n/(?P<abn>(?P=axn)xxx)/B\n\n/(?P<abn>(?P=axn)xxx)(?<axn>yy)/B\n\n# These tests are here because Perl gets the first one wrong.\n\n/(\\R*)(.)/s\n    \\r\\n\n    \\r\\r\\n\\n\\r\n    \\r\\r\\n\\n\\r\\n\n\n/(\\R)*(.)/s\n    \\r\\n\n    \\r\\r\\n\\n\\r\n    \\r\\r\\n\\n\\r\\n\n\n/((?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)*)(.)/s\n    \\r\\n\n    \\r\\r\\n\\n\\r\n    \\r\\r\\n\\n\\r\\n\n\n# -------------\n\n/^abc$/B\n\n/^abc$/Bm\n\n/^(a)*+(\\w)/\n    aaaaX\n\\= Expect no match\n    aaaa\n\n/^(?:a)*+(\\w)/\n    aaaaX\n\\= Expect no match\n    aaaa\n\n/(a)++1234/IB\n\n/([abc])++1234/I\n\n/(?<=(abc)+)X/\n\n/(^ab)/I\n\n/(^ab)++/I\n\n/(^ab|^)+/I\n\n/(^ab|^)++/I\n\n/(?:^ab)/I\n\n/(?:^ab)++/I\n\n/(?:^ab|^)+/I\n\n/(?:^ab|^)++/I\n\n/(.*ab)/I\n\n/(.*ab)++/I\n\n/(.*ab|.*)+/I\n\n/(.*ab|.*)++/I\n\n/(?:.*ab)/I\n\n/(?:.*ab)++/I\n\n/(?:.*ab|.*)+/I\n\n/(?:.*ab|.*)++/I\n\n/(?=a)[bcd]/I\n\n/((?=a))[bcd]/I\n\n/((?=a))+[bcd]/I\n\n/((?=a))++[bcd]/I\n\n/(?=a+)[bcd]/Ii\n\n/(?=a+?)[bcd]/Ii\n\n/(?=a++)[bcd]/Ii\n\n/(?=a{3})[bcd]/Ii\n\n/(abc)\\1+/\n\n# Perl doesn't get these right IMO (the 3rd is PCRE2-specific)\n\n/(?1)(?:(b(*ACCEPT))){0}/\n    b\n\n/(?1)(?:(b(*ACCEPT))){0}c/\n    bc\n\\= Expect no match\n    b\n\n/(?1)(?:((*ACCEPT))){0}c/\n    c\n    c\\=notempty\n\n/^.*?(?(?=a)a|b(*THEN)c)/\n\\= Expect no match\n    ba\n\n/^.*?(?(?=a)a|bc)/\n    ba\n\n/^.*?(?(?=a)a(*THEN)b|c)/\n\\= Expect no match\n    ac\n\n/^.*?(?(?=a)a(*THEN)b)c/\n\\= Expect no match\n    ac\n\n/^.*?(a(*THEN)b)c/\n\\= Expect no match\n    aabc\n\n/^.*? (?1) c (?(DEFINE)(a(*THEN)b))/x\n    aabc\n\n/^.*?(a(*THEN)b|z)c/\n    aabc\n\n/^.*?(z|a(*THEN)b)c/\n    aabc\n\n# These are here because they are not Perl-compatible; the studying means the\n# mark is not seen.\n\n/(*MARK:A)(*SKIP:B)(C|X)/mark\n    C\n\\= Expect no match\n    D\n\n/(*:A)A+(*SKIP:A)(B|Z)/mark\n\\= Expect no match\n    AAAC\n\n# ----------------------------\n\n\"(?=a*(*ACCEPT)b)c\"\n    c\n    c\\=notempty\n\n/(?1)c(?(DEFINE)((*ACCEPT)b))/\n    c\n    c\\=notempty\n\n/(?>(*ACCEPT)b)c/\n    c\n\\= Expect no match\n    c\\=notempty\n\n/(?:(?>(a)))+a%/allaftertext\n    %aa%\n\n/(a)b|ac/allaftertext\n    ac\\=ovector=1\n\n/(a)(b)x|abc/allaftertext\n     abc\\=ovector=2\n\n/(a)bc|(a)(b)\\2/\n    abc\\=ovector=1\n    abc\\=ovector=2\n    aba\\=ovector=1\n    aba\\=ovector=2\n    aba\\=ovector=3\n    aba\\=ovector=4\n\n/(?(DEFINE)(a(?2)|b)(b(?1)|a))(?:(?1)|(?2))/I\n\n/(a(?2)|b)(b(?1)|a)(?:(?1)|(?2))/I\n\n/(a(?2)|b)(b(?1)|a)(?1)(?2)/I\n\n/(abc)(?1)/I\n\n/(?:(foo)|(bar)|(baz))X/allcaptures\n    bazfooX\n    foobazbarX\n    barfooX\n    bazX\n    foobarbazX\n    bazfooX\\=ovector=0\n    bazfooX\\=ovector=1\n    bazfooX\\=ovector=2\n    bazfooX\\=ovector=3\n\n/(?=abc){3}abc/B\n\n/(?=abc)+abc/B\n\n/(?=abc)++abc/B\n\n/(?=abc){0}xyz/B\n\n/(?=(a))?./B\n\n/(?=(a))??./B\n\n/^(?=(a)){0}b(?1)/B\n\n/(?(DEFINE)(a))?b(?1)/B\n\n/^(?=(?1))?[az]([abc])d/B\n\n/^(?!a){0}\\w+/B\n\n/(?<=(abc))?xyz/B\n\n/[:a[:abc]b:]/B\n\n/^(a(*:A)(d|e(*:B))z|aeq)/auto_callout\n    adz\n    aez\n    aeqwerty\n\n/.(*F)/\n\\= Expect no match\n    abc\\=ph\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b/I\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b|\\burl\\b\\W*?\\bshell:|<input\\b.*?\\btype\\b\\W*?\\bimage\\b|\\bonkeyup\\b\\W*?\\=/I\n\n/a(*SKIP)c|b(*ACCEPT)|/I,aftertext\n    a\n\n/a(*SKIP)c|b(*ACCEPT)cd(*ACCEPT)|x/I\n    ax\n\n'a*(*ACCEPT)b'aftertext\n    abc\\=notempty_atstart\n    bbb\\=notempty_atstart\n\\= Expect no match\n    \\=notempty_atstart\n\n/(*ACCEPT)a/I,aftertext\n    bax\n\n/z(*ACCEPT)a/I,aftertext\n    baxzbx\n\n/^(?>a+)(?>(z+))\\w/B\n    aaaazzzzb\n\\= Expect no match\n    aazz\n\n/(.)(\\1|a(?2))/\n    bab\n\n/\\1|(.)(?R)\\1/\n    cbbbc\n\n/(.)((?(1)c|a)|a(?2))/\n\\= Expect no match\n    baa\n\n/(?P<abn>(?P=abn)xxx)/B\n\n/(a\\1z)/B\n\n/^a\\x41z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\\= Expect no match\n    ax41z\n\n/^a[m\\x41]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\n/^a\\x1z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    ax1z\n\n/^a\\u0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\\= Expect no match\n    au0041z\n\n/^a[m\\u0041]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n\n/^a\\u041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    au041z\n\\= Expect no match\n    aAz\n\n/^a\\U0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aU0041z\n\\= Expect no match\n    aAz\n    \n/^\\u{7a}/alt_bsux\n    u{7a}\n\\= Expect no match\n    zoo \n\n/^\\u{7a}/extra_alt_bsux\n    zoo \n\n/(?(?=c)c|d)++Y/B\n\n/(?(?=c)c|d)*+Y/B\n\n/a[\\NB]c/\n    aNc\n\n/a[B-\\Nc]/\n\n/a[B\\Nc]/\n\n/(a)(?2){0,1999}?(b)/\n\n/(a)(?(DEFINE)(b))(?2){0,1999}?(?2)/\n\n# This test, with something more complicated than individual letters, causes\n# different behaviour in Perl. Perhaps it disables some optimization; no tag is\n# passed back for the failures, whereas in PCRE2 there is a tag.\n\n/(A|P)(*:A)(B|P) | (X|P)(X|P)(*:B)(Y|P)/x,mark\n    AABC\n    XXYZ\n\\= Expect no match\n    XAQQ\n    XAQQXZZ\n    AXQQQ\n    AXXQQQ\n\n# Perl doesn't give marks for these, though it does if the alternatives are\n# replaced by single letters.\n\n/(b|q)(*:m)f|a(*:n)w/mark\n    aw\n\\= Expect no match\n    abc\n\n/(q|b)(*:m)f|a(*:n)w/mark\n    aw\n\\= Expect no match\n    abc\n\n# After a partial match, the behaviour is as for a failure.\n\n/^a(*:X)bcde/mark\n   abc\\=ps\n\n# These are here because Perl doesn't return a mark, except for the first.\n\n/(?=(*:x))(q|)/aftertext,mark\n    abc\n\n/(?=(*:x))((*:y)q|)/aftertext,mark\n    abc\n\n/(?=(*:x))(?:(*:y)q|)/aftertext,mark\n    abc\n\n/(?=(*:x))(?>(*:y)q|)/aftertext,mark\n    abc\n\n/(?=a(*:x))(?!a(*:y)c)/aftertext,mark\n    ab\n\n/(?=a(*:x))(?=a(*:y)c|)/aftertext,mark\n    ab\n\n/(..)\\1/\n    ab\\=ps\n    aba\\=ps\n    abab\\=ps\n\n/(..)\\1/i\n    ab\\=ps\n    abA\\=ps\n    aBAb\\=ps\n\n/(..)\\1{2,}/\n    ab\\=ps\n    aba\\=ps\n    abab\\=ps\n    ababa\\=ps\n    ababab\\=ps\n    ababab\\=ph\n    abababa\\=ps\n    abababa\\=ph\n\n/(..)\\1{2,}/i\n    ab\\=ps\n    aBa\\=ps\n    aBAb\\=ps\n    AbaBA\\=ps\n    abABAb\\=ps\n    aBAbaB\\=ph\n    abABabA\\=ps\n    abaBABa\\=ph\n\n/(..)\\1{2,}?x/i\n    ab\\=ps\n    abA\\=ps\n    aBAb\\=ps\n    abaBA\\=ps\n    abAbaB\\=ps\n    abaBabA\\=ps\n    abAbABaBx\\=ps\n\n/^(..)\\1/\n    aba\\=ps\n\n/^(..)\\1{2,3}x/\n    aba\\=ps\n    ababa\\=ps\n    ababa\\=ph\n    abababx\n    ababababx\n\n/^(..)\\1{2,3}?x/\n    aba\\=ps\n    ababa\\=ps\n    ababa\\=ph\n    abababx\n    ababababx\n\n/^(..)(\\1{2,3})ab/\n    abababab\n\n/^\\R/\n    \\r\\=ps\n    \\r\\=ph\n\n/^\\R{2,3}x/\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n    \\r\\rx\n    \\r\\r\\rx\n\n/^\\R{2,3}?x/\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n    \\r\\rx\n    \\r\\r\\rx\n\n/^\\R?x/\n    \\r\\=ps\n    \\r\\=ph\n    x\n    \\rx\n\n/^\\R+x/\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\n\\=ps\n    \\r\\n\\=ph\n    \\rx\n\n/^a$/newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/^a$/m,newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/^(a$|a\\r)/newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/^(a$|a\\r)/m,newline=crlf\n    a\\r\\=ps\n    a\\r\\=ph\n\n/./newline=crlf\n    \\r\\=ps\n    \\r\\=ph\n\n/.{2,3}/newline=crlf\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n\n/.{2,3}?/newline=crlf\n    \\r\\=ps\n    \\r\\=ph\n    \\r\\r\\=ps\n    \\r\\r\\=ph\n    \\r\\r\\r\\=ps\n    \\r\\r\\r\\=ph\n\n\"AB(C(D))(E(F))?(?(?=\\2)(?=\\4))\"\n    ABCDGHI\\=ovector=01\n\n# These are all run as real matches in test 1; here we are just checking the\n# settings of the anchored and startline bits.\n\n/(?>.*?a)(?<=ba)/I\n\n/(?:.*?a)(?<=ba)/I\n\n/.*?a(*PRUNE)b/I\n\n/.*?a(*PRUNE)b/Is\n\n/^a(*PRUNE)b/Is\n\n/.*?a(*SKIP)b/I\n\n/(?>.*?a)b/Is\n\n/(?>.*?a)b/I\n\n/(?>^a)b/Is\n\n/(?>.*?)(?<=(abcd)|(wxyz))/I\n\n/(?>.*)(?<=(abcd)|(wxyz))/I\n\n\"(?>.*)foo\"I\n\n\"(?>.*?)foo\"I\n\n/(?>^abc)/Im\n\n/(?>.*abc)/Im\n\n/(?:.*abc)/Im\n\n/(?:(a)+(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\n\n/(?:(a)++(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\n\n/(?:(?>(a))(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\n\n/(?:(?1)(?C1)x|ab(?C2))((a)){0}/\n    aab\\=callout_capture\n\n/(?1)(?C1)((a)(?C2)){0}/\n    aab\\=callout_capture\n\n/(?:(a)+(?C1)bb|aa(?C2)b)++/\n    aab\\=callout_capture\n    aab\\=callout_capture,ovector=1\n\n/(ab)x|ab/\n    ab\\=ovector=0\n    ab\\=ovector=1\n\n/(?<=123)(*MARK:xx)abc/mark\n    xxxx123a\\=ph\n    xxxx123a\\=ps\n\n/123\\Kabc/startchar\n    xxxx123a\\=ph\n    xxxx123a\\=ps\n\n/^(?(?=a)aa|bb)/auto_callout\n    bb\n\n/(?C1)^(?C2)(?(?C99)(?=(?C3)a(?C4))(?C5)a(?C6)a(?C7)|(?C8)b(?C9)b(?C10))(?C11)/\n    bb\n\n# Perl seems to have a bug with this one.\n\n/aaaaa(*COMMIT)(*PRUNE)b|a+c/\n    aaaaaac\n\n# Here are some that Perl treats differently because of the way it handles\n# backtracking verbs.\n\n/(?!a(*COMMIT)b)ac|ad/\n     ac\n     ad\n\n/^(?!a(*THEN)b|ac)../\n     ad\n\\= Expect no match\n     ac\n\n/^(?=a(*THEN)b|ac)/\n    ac\n\n/\\A.*?(?:a|b(*THEN)c)/\n    ba\n\n/\\A.*?(?:a|b(*THEN)c)++/\n    ba\n\n/\\A.*?(?:a|b(*THEN)c|d)/\n    ba\n\n/(?:(a(*MARK:X)a+(*SKIP:X)b)){0}(?:(?1)|aac)/\n    aac\n\n/\\A.*?(a|b(*THEN)c)/\n    ba\n\n/^(A(*THEN)B|A(*THEN)D)/\n    AD\n\n/(?!b(*THEN)a)bn|bnn/\n    bnn\n\n/(?(?=b(*SKIP)a)bn|bnn)/\n    bnn\n\n/(?=b(*THEN)a|)bn|bnn/\n    bnn\n\n# This test causes a segfault with Perl 5.18.0\n\n/^(?=(a)){0}b(?1)/\n    backgammon\n\n/(?|(?<n>f)|(?<n>b))/I,dupnames\n\n/(?<a>abc)(?<a>z)\\k<a>()/IB,dupnames\n\n/a*[bcd]/B\n\n/[bcd]*a/B\n\n# A complete set of tests for auto-possessification of character types, but\n# omitting \\C because it might be disabled (it has its own tests).\n\n/\\D+\\D \\D+\\d \\D+\\S \\D+\\s \\D+\\W \\D+\\w \\D+. \\D+\\R \\D+\\H \\D+\\h \\D+\\V \\D+\\v \\D+\\Z \\D+\\z \\D+$/Bx\n\n/\\d+\\D \\d+\\d \\d+\\S \\d+\\s \\d+\\W \\d+\\w \\d+. \\d+\\R \\d+\\H \\d+\\h \\d+\\V \\d+\\v \\d+\\Z \\d+\\z \\d+$/Bx\n\n/\\S+\\D \\S+\\d \\S+\\S \\S+\\s \\S+\\W \\S+\\w \\S+. \\S+\\R \\S+\\H \\S+\\h \\S+\\V \\S+\\v \\S+\\Z \\S+\\z \\S+$/Bx\n\n/\\s+\\D \\s+\\d \\s+\\S \\s+\\s \\s+\\W \\s+\\w \\s+. \\s+\\R \\s+\\H \\s+\\h \\s+\\V \\s+\\v \\s+\\Z \\s+\\z \\s+$/Bx\n\n/\\W+\\D \\W+\\d \\W+\\S \\W+\\s \\W+\\W \\W+\\w \\W+. \\W+\\R \\W+\\H \\W+\\h \\W+\\V \\W+\\v \\W+\\Z \\W+\\z \\W+$/Bx\n\n/\\w+\\D \\w+\\d \\w+\\S \\w+\\s \\w+\\W \\w+\\w \\w+. \\w+\\R \\w+\\H \\w+\\h \\w+\\V \\w+\\v \\w+\\Z \\w+\\z \\w+$/Bx\n\n/\\R+\\D \\R+\\d \\R+\\S \\R+\\s \\R+\\W \\R+\\w \\R+. \\R+\\R \\R+\\H \\R+\\h \\R+\\V \\R+\\v \\R+\\Z \\R+\\z \\R+$/Bx\n\n/\\H+\\D \\H+\\d \\H+\\S \\H+\\s \\H+\\W \\H+\\w \\H+. \\H+\\R \\H+\\H \\H+\\h \\H+\\V \\H+\\v \\H+\\Z \\H+\\z \\H+$/Bx\n\n/\\h+\\D \\h+\\d \\h+\\S \\h+\\s \\h+\\W \\h+\\w \\h+. \\h+\\R \\h+\\H \\h+\\h \\h+\\V \\h+\\v \\h+\\Z \\h+\\z \\h+$/Bx\n\n/\\V+\\D \\V+\\d \\V+\\S \\V+\\s \\V+\\W \\V+\\w \\V+. \\V+\\R \\V+\\H \\V+\\h \\V+\\V \\V+\\v \\V+\\Z \\V+\\z \\V+$/Bx\n\n/\\v+\\D \\v+\\d \\v+\\S \\v+\\s \\v+\\W \\v+\\w \\v+. \\v+\\R \\v+\\H \\v+\\h \\v+\\V \\v+\\v \\v+\\Z \\v+\\z \\v+$/Bx\n\n/ a+\\D  a+\\d  a+\\S  a+\\s  a+\\W  a+\\w  a+.  a+\\R  a+\\H  a+\\h  a+\\V  a+\\v  a+\\Z  a+\\z  a+$/Bx\n\n/\\n+\\D \\n+\\d \\n+\\S \\n+\\s \\n+\\W \\n+\\w \\n+. \\n+\\R \\n+\\H \\n+\\h \\n+\\V \\n+\\v \\n+\\Z \\n+\\z \\n+$/Bx\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bx\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bsx\n\n/ \\D+$  \\d+$  \\S+$  \\s+$  \\W+$  \\w+$  \\R+$  \\H+$  \\h+$  \\V+$ \\v+$  a+$   \\n+$  .+$  .+$/Bmx\n\n/(?=a+)a(a+)++a/B\n\n/a+(bb|cc)a+(?:bb|cc)a+(?>bb|cc)a+(?:bb|cc)+a+(aa)a+(?:bb|aa)/B\n\n/a+(bb|cc)?#a+(?:bb|cc)??#a+(?:bb|cc)?+#a+(?:bb|cc)*#a+(bb|cc)?a#a+(?:aa)?/B\n\n/a+(?:bb)?a#a+(?:|||)#a+(?:|b)a#a+(?:|||)?a/B\n\n/[ab]*/B\n    aaaa\n\n/[ab]*?/B\n    aaaa\n\n/[ab]?/B\n    aaaa\n\n/[ab]??/B\n    aaaa\n\n/[ab]+/B\n    aaaa\n\n/[ab]+?/B\n    aaaa\n\n/[ab]{2,3}/B\n    aaaa\n\n/[ab]{2,3}?/B\n    aaaa\n\n/[ab]{2,}/B\n    aaaa\n\n/[ab]{2,}?/B\n    aaaa\n\n/\\d+\\s{0,5}=\\s*\\S?=\\w{0,4}\\W*/B\n\n/[a-d]{5,12}[e-z0-9]*#[^a-z]+[b-y]*a[2-7]?[^0-9a-z]+/B\n\n/[a-z]*\\s#[ \\t]?\\S#[a-c]*\\S#[C-G]+?\\d#[4-8]*\\D#[4-9,]*\\D#[!$]{0,5}\\w#[M-Xf-l]+\\W#[a-c,]?\\W/B\n\n/a+(aa|bb)*c#a*(bb|cc)*a#a?(bb|cc)*d#[a-f]*(g|hh)*f/B\n\n/[a-f]*(g|hh|i)*i#[a-x]{4,}(y{0,6})*y#[a-k]+(ll|mm)+n/B\n\n/[a-f]*(?>gg|hh)+#[a-f]*(?>gg|hh)?#[a-f]*(?>gg|hh)*a#[a-f]*(?>gg|hh)*h/B\n\n/[a-c]*d/IB\n\n/[a-c]+d/IB\n\n/[a-c]?d/IB\n\n/[a-c]{4,6}d/IB\n\n/[a-c]{0,6}d/IB\n\n# End of special auto-possessive tests\n\n/^A\\o{1239}B/\n    A\\123B\n\n/^A\\oB/\n\n/^A\\x{zz}B/\n\n/^A\\x{12Z/\n\n/^A\\x{/\n\n/[ab]++/B,no_auto_possess\n\n/[^ab]*+/B,no_auto_possess\n\n/a{4}+/B,no_auto_possess\n\n/a{4}+/Bi,no_auto_possess\n\n/[a-[:digit:]]+/\n\n/[A-[:digit:]]+/\n\n/[a-[.xxx.]]+/\n\n/[a-[=xxx=]]+/\n\n/[a-[!xxx!]]+/\n\n/[A-[!xxx!]]+/\n    A]]]\n\n/[a-\\d]+/\n\n/(?<0abc>xx)/\n\n/(?&1abc)xx(?<1abc>y)/\n\n/(?<ab-cd>xx)/\n\n/(?'0abc'xx)/\n\n/(?P<0abc>xx)/\n\n/\\k<5ghj>/\n\n/\\k'5ghj'/\n\n/\\k{2fgh}/\n\n/(?P=8yuki)/\n\n/\\g{4df}/\n\n/(?&1abc)xx(?<1abc>y)/\n\n/(?P>1abc)xx(?<1abc>y)/\n\n/\\g'3gh'/\n\n/\\g<5fg>/\n\n/(?(<4gh>)abc)/\n\n/(?('4gh')abc)/\n\n/(?(4gh)abc)/\n\n/(?(R&6yh)abc)/\n\n/(((a\\2)|(a*)\\g<-1>))*a?/B\n\n# Test the ugly \"start or end of word\" compatibility syntax.\n\n/[[:<:]]red[[:>:]]/B\n    little red riding hood\n    a /red/ thing\n    red is a colour\n    put it all on red\n\\= Expect no match\n    no reduction\n    Alfred Winifred\n\n/[a[:<:]] should give error/\n\n/(?=ab\\K)/aftertext,allow_lookaround_bsk\n    abcd\\=startchar\n\n/abcd/newline=lf,firstline\n\\= Expect no match\n    xx\\nxabcd\n\n# Test stack guard external calls.\n\n/(((a)))/stackguard=1\n\n/(((a)))/stackguard=2\n\n/(((a)))/stackguard=3\n\n/(((((a)))))/\n\n# End stack guard tests\n\n/^\\w+(?>\\s*)(?<=\\w)/B\n\n/\\othing/\n\n/\\o{}/\n\n/\\o{whatever}/\n\n/\\xthing/\n\n/\\x{}/\n\n/\\x{whatever}/\n\n/A\\8B/\n\n/A\\9B/\n\n# This one is here because Perl fails to match \"12\" for this pattern when the $\n# is present.\n\n/^(?(?=abc)\\w{3}:|\\d\\d)$/\n    abc:\n    12\n\\= Expect no match\n    123\n    xyz\n\n# Perl gets this one wrong, giving \"a\" as the after text for ca and failing to\n# match for cd.\n\n/(?(?=ab)ab)/aftertext\n    abxxx\n    ca\n    cd\n\n# This should test both paths for processing OP_RECURSE.\n\n/(?(R)a+|(?R)b)/\n    aaaabcde\n    aaaabcde\\=ovector=100\n\n/a*?b*?/\n    ab\n\n/(*NOTEMPTY)a*?b*?/\n    ab\n    ba\n    cb\n\n/(*NOTEMPTY_ATSTART)a*?b*?/aftertext\n    ab\n    cdab\n\n/(?(VERSION>=10.0)yes|no)/I\n    yesno\n\n/(?(VERSION>=10.04)yes|no)/\n    yesno\n\n/(?(VERSION=8)yes){3}/BI,aftertext\n    yesno\n\n/(?(VERSION=8)yes|no){3}/I\n    yesnononoyes\n\\= Expect no match\n    yesno\n\n/(?:(?<VERSION>abc)|xyz)(?(VERSION)yes|no)/I\n    abcyes\n    xyzno\n\\= Expect no match\n    abcno\n    xyzyes\n\n/(?(VERSION<10)yes|no)/\n\n/(?(VERSION>10)yes|no)/\n\n/(?(VERSION>=10.0.0)yes|no)/\n\n/(?(VERSION=10.101)yes|no)/\n\n/abcd/I\n\n/abcd/I,no_start_optimize\n\n/(|ab)*?d/I\n   abd\n   xyd\n\n/(|ab)*?d/I,no_start_optimize\n   abd\n   xyd\n\n/\\k<A>*(?<A>aa)(?<A>bb)/match_unset_backref,dupnames\n    aabb\n\n/(((((a)))))/parens_nest_limit=2\n\n/abc/replace=XYZ\n    123123\n    123abc123\n    123abc123abc123\n    123123\\=zero_terminate\n    123abc123\\=zero_terminate\n    123abc123abc123\\=zero_terminate\n\n/abc/g,replace=XYZ\n    123abc123\n    123abc123abc123\n\n/abc/replace=X$$Z\n    123abc123\n\n/abc/g,replace=X$$Z\n    123abc123abc123\n\n/a(b)c(d)e/replace=X$1Y${2}Z\n    \"abcde\"\n\n/a(b)c(d)e/replace=X$1Y${2}Z,global\n    \"abcde-abcde\"\n\n/a(?<ONE>b)c(?<TWO>d)e/replace=X$ONE+${TWO}Z\n    \"abcde\"\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z\n    \"abcde-abcde-\"\n\n/abc/replace=a$++\n    123abc\n\n/abc/replace=a$bad\n    123abc\n\n/abc/replace=a${A234567890123456789_123456789012}z\n    123abc\n\n/abc/replace=a${A23456789012345678901234567890123}z\n    123abc\n\n/abc/replace=a${bcd\n    123abc\n\n/abc/replace=a${b+d}z\n    123abc\n\n/abc/replace=[10]XYZ\n    123abc123\n\n/abc/replace=[9]XYZ\n    123abc123\n\n/abc/replace=xyz\n    1abc2\\=partial_hard\n\n/abc/replace=xyz\n    123abc456\n    123abc456\\=replace=pqr\n    123abc456abc789\n    123abc456abc789\\=g\n\n/(?<=abc)(|def)/g,replace=<$0>\n    123abcxyzabcdef789abcpqr\n\n/./replace=$0\n    a\n\n/(.)(.)/replace=$2+$1\n    abc\n\n/(?<A>.)(?<B>.)/replace=$B+$A\n    abc\n\n/(.)(.)/g,replace=$2$1\n    abcdefgh\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=${*MARK}\n    apple lemon blackberry\n    apple strudel\n    fruitless\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/replace=${*MARK} sauce,\n    apple lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARK>\n    apple lemon blackberry\n    apple strudel\n    fruitless\n\n/(*:pear)apple/g,replace=${*MARKING}\n    apple lemon blackberry\n\n/(*:pear)apple/g,replace=${*MARK-time\n    apple lemon blackberry\n\n/(*:pear)apple/g,replace=${*mark}\n    apple lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARKET>\n    apple lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[22]${*MARK}\n    apple lemon blackberry\n    apple lemon blackberry\\=substitute_overflow_length\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[23]${*MARK}\n    apple lemon blackberry\n\n/abc/\n    123abc123\\=replace=[9]XYZ\n    123abc123\\=substitute_overflow_length,replace=[9]XYZ\n    123abc123\\=substitute_overflow_length,replace=[6]XYZ\n    123abc123\\=substitute_overflow_length,replace=[1]XYZ\n    123abc123\\=substitute_overflow_length,replace=[0]XYZ\n\n/a(b)c/\n    123abc123\\=replace=[9]x$1z\n    123abc123\\=substitute_overflow_length,replace=[9]x$1z\n    123abc123\\=substitute_overflow_length,replace=[6]x$1z\n    123abc123\\=substitute_overflow_length,replace=[1]x$1z\n    123abc123\\=substitute_overflow_length,replace=[0]x$1z\n\n\"((?=(?(?=(?(?=(?(?=()))))))))\"\n    a\n\n\"(?(?=)==)(((((((((?=)))))))))\"\n\\= Expect no match\n    a\n\n/(a)(b)|(c)/\n    XcX\\=ovector=2,get=1,get=2,get=3,get=4,getall\n\n/x(?=ab\\K)/allow_lookaround_bsk\n    xab\\=get=0\n    xab\\=copy=0\n    xab\\=getall\n\n/(?<A>a)|(?<A>b)/dupnames\n    a\\=ovector=1,copy=A,get=A,get=2\n    a\\=ovector=2,copy=A,get=A,get=2\n    b\\=ovector=2,copy=A,get=A,get=2\n\n/a(b)c(d)/\n    abc\\=ph,copy=0,copy=1,getall\n\n/^abc/info\n\n/^abc/info,no_dotstar_anchor\n\n/.*\\d/info,auto_callout\n\\= Expect no match\n    aaa\n\n/.*\\d/info,no_dotstar_anchor,auto_callout\n\\= Expect no match\n    aaa\n\n/.*\\d/dotall,info\n\n/.*\\d/dotall,no_dotstar_anchor,info\n\n/(*NO_DOTSTAR_ANCHOR)(?s).*\\d/info\n\n'^(?:(a)|b)(?(1)A|B)'\n    aA123\\=ovector=1\n    aA123\\=ovector=2\n\n'^(?:(?<AA>a)|b)(?(<AA>)A|B)'\n    aA123\\=ovector=1\n    aA123\\=ovector=2\n\n'^(?<AA>)(?:(?<AA>a)|b)(?(<AA>)A|B)'dupnames\n    aA123\\=ovector=1\n    aA123\\=ovector=2\n    aA123\\=ovector=3\n\n'^(?:(?<AA>X)|)(?:(?<AA>a)|b)\\k{AA}'dupnames\n    aa123\\=ovector=1\n    aa123\\=ovector=2\n    aa123\\=ovector=3\n\n/(?<N111>(?J)(?<N111>1(111111)11|)1|1|)(?(<N111>)1)/\n\n/(?<N>(?J)(?<N>))(?-J)\\k<N>/\n\n# Quantifiers are not allowed on condition assertions, but are otherwise\n# OK in conditions.\n\n/(?(?=0)?)+/\n\n/(?(?=0)(?=00)?00765)/\n     00765\n\n/(?(?=0)(?=00)?00765|(?!3).56)/\n     00765\n     456\n\\= Expect no match\n     356\n\n'^(a)*+(\\w)'\n    g\n    g\\=ovector=1\n\n'^(?:a)*+(\\w)'\n    g\n    g\\=ovector=1\n\n# These two pattern showeds up compile-time bugs\n\n\"((?2){0,1999}())?\"\n\n/((?+1)(\\1))/B\n\n# Callouts with string arguments\n\n/a(?C\"/\n\n/a(?C\"a/\n\n/a(?C\"a\"/\n\n/a(?C\"a\"bcde(?C\"b\")xyz/\n\n/a(?C\"a)b\"\"c\")/B\n\n/ab(?C\" any text with spaces \")cde/B\n    abcde\n    12abcde\n\n/^a(b)c(?C1)def/\n      abcdef\n\n/^a(b)c(?C\"AB\")def/\n      abcdef\n\n/^a(b)c(?C1)def/\n      abcdef\\=callout_capture\n\n/^a(b)c(?C{AB})def/B\n      abcdef\\=callout_capture\n\n/(?C`a``b`)(?C'a''b')(?C\"a\"\"b\")(?C^a^^b^)(?C%a%%b%)(?C#a##b#)(?C$a$$b$)(?C{a}}b})/B,callout_info\n\n/(?:a(?C`code`)){3}/B\n\n/^(?(?C25)(?=abc)abcd|xyz)/B,callout_info\n    abcdefg\n    xyz123\n\n/^(?(?C$abc$)(?=abc)abcd|xyz)/B\n    abcdefg\n    xyz123\n\n/^ab(?C'first')cd(?C\"second\")ef/\n    abcdefg\n\n/(?:a(?C`code`)){3}X/\n    aaaXY\n\n# Binary zero in callout string\n#  a  (  ?  C  '  x     z  '  )  b\n/ 61 28 3f 43 27 78 00 7a 27 29 62/hex,callout_info\n    abcdefgh\n\n/(?(?!)^)/\n\n/(?(?!)a|b)/\n    bbb\n\\= Expect no match\n    aaa\n\n# JIT gives a different error message for the infinite recursion\n\n\"(*NO_JIT)((?2)+)((?1)){\"\n    abcd{\n\n# Perl fails to diagnose the absence of an assertion\n\n\"(?(?<E>.*!.*)?)\"\n\n\"X((?2)()*+){2}+\"B\n\n\"X((?2)()*+){2}\"B\n\n/(?<=\\bABQ(3(?-7)))/\n\n/(?<=\\bABQ(3(?+7)))/\n\n\";(?<=()((?3))((?2)))\"\n\n# Perl loops on this (PCRE2 used to!)\n\n/(?<=\\Ka)/g,aftertext,allow_lookaround_bsk\n    aaaaa\n\n/(?<=\\Ka)/altglobal,aftertext,allow_lookaround_bsk\n    aaaaa\n\n/((?2){73}(?2))((?1))/info\n\n/abc/\n\\= Expect no match\n    \\[9x!xxx(]{9999}\n\n/(abc)*/\n    \\[abc]{5}\n\n/^/gm\n    \\n\\n\\n\n\n/^/gm,alt_circumflex\n    \\n\\n\\n\n\n/((((((((x))))))))\\81/\n    xx1\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\\80/\n    xx\n\n/\\80/\n\n/A\\8B\\9C/\n    A8B9C\n\n/(?x:((?'a')) # comment (with parentheses) and | vertical\n(?-x:#not a comment (?'b')) # this is a comment ()\n(?'c')) # not a comment (?'d')/info\n\n/(?|(?'a')(2)(?'b')|(?'a')(?'a')(3))/I,dupnames\n    A23B\n    B32A\n\n# These are some patterns that used to cause buffer overflows or other errors\n# while compiling.\n\n/.((?2)(?R)|\\1|$)()/B\n\n/.((?3)(?R)()(?2)|\\1|$)()/B\n\n/(\\9*+(?2);\\3++()2|)++{/\n\n/\\V\\x85\\9*+((?2)\\3++()2)*:2/\n\n/(((?(R)){0,2}) (?'x'((?'R')((?'R')))))/dupnames\n\n/(((?(X)){0,2}) (?'x'((?'X')((?'X')))))/dupnames\n\n/(((?(R)){0,2}) (?'x'((?'X')((?'R')))))/\n\n\"(?J)(?'d'(?'d'\\g{d}))\"\n\n\"(?=!((?2)(?))({8(?<=(?1){29}8bbbb\\x16\\xd\\xc6^($(\\xa9H4){4}h}?1)B))\\x15')\"\n\n/A(?'')Z/\n\n\"(?J:(?|(?'R')(\\k'R')|((?'R'))))\"\n\n/(?<=|(\\,\\$(?73591620449005828816)\\xa8.{7}){6}\\x09)/\n\n/^(?:(?(1)x|)+)+$()/B\n\n/[[:>:]](?<)/\n\n/((?x)(*:0))#(?'/\n\n/(?C$[$)(?<]/\n\n/(?C$)$)(?<]/\n\n/(?(R))*+/B\n    abcd\n\n/((?x)(?#))#(?'/\n\n/((?x)(?#))#(?'abc')/I\n\n/[[:\\\\](?<[::]/\n\n/[[:\\\\](?'abc')[a:]/I\n\n\"[[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[:::::::::::::::::[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[[[:::E[[[:[:[[:[:::[[:::E[[[:[:[[:'[:::::E[[[:[::::::[[[:[[[[[[[::E[[[:[::::::[[[:[[[[[[[[:[[::[::::[[:::::::[[:[[[[[[[:[[::[:[[:[~\"\n\n/()(?(R)0)*+/B\n\n/(?R-:(?</\n\n/(?R-:(?<)/\n\n/(?(?C{\\Q})(?!(?'/\n\n/(?(?C{\\Q})(?!(?'abc')))/I\n\n/(?1){3918}(((((0(\\k'R'))))(?J)(?'R'(?'R'\\3){99})))/I\n\n/(?|(aaa)|(b))\\g{1}/I\n\n/(?|(aaa)|(b))(?1)/I\n\n/(?|(aaa)|(b))/I\n\n/(?|(?'a'aaa)|(?'a'b))\\k'a'/I\n\n/(?|(?'a'aaa)|(?'a'b))(?'a'cccc)\\k'a'/I,dupnames\n\n/ab{3cd/\n    ab{3cd\n\n/ab{3,cd/\n    ab{3,cd\n\n/ab{3,4a}cd/\n    ab{3,4a}cd\n\n/{4,5a}bc/\n    {4,5a}bc\n\n/\\x0{ab}/\n    \\0{ab}\n\n/^(a(b))\\1\\g1\\g{1}\\g-1\\g{-1}\\g{-02}Z/\n    ababababbbabZXXXX\n\n/.*?a(*PRUNE)b/\n    aab\n\n/.*?a(*PRUNE)b/s\n    aab\n\n/^a(*PRUNE)b/s\n\\= Expect no match\n    aab\n\n/.*?a(*SKIP)b/\n    aab\n\n/(?(8000000000/\n\n/((?(R8000000000)))/\n\n/0(?0)|(1)(*THEN)(*SKIP:0)(*FAIL)/\n\\= Expect no match\n    01\n\n/(?(1)()\\983040\\2)/\n\n/(*LIMIT_MATCH=)abc/\n\n/(*CRLF)(*LIMIT_MATCH=)abc/\n\n/(?:ab)?(?:ab)(?:ab)/\n    abab\n    ababab\n\\= Expect no match\n    aba\n\n/((*MARK:A))++a(*SKIP:B)b/\n\\= Expect no match\n    aacb\n\n/(*MARK:a\\zb)z/alt_verbnames\n\n/(*:ab\\t(d\\)c)xxx/\n\n/(*:ab\\t(d\\)c)xxx/alt_verbnames,mark\n    cxxxz\n\n/(*:A\\Qxx)x\\EB)x/alt_verbnames,mark\n    x\n\n/(*:A\\ExxxB)x/alt_verbnames,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/x,alt_verbnames,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/alt_verbnames,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/x,mark\n    x\n\n/(*: A \\ and #comment\n     \\ B)x/mark\n    x\n\n/(*:A\nB)x/alt_verbnames,mark\n    x\n\n/(*:abc\\Qpqr)/alt_verbnames\n\n/abc/use_offset_limit\n    1234abcde\\=offset_limit=100\n    1234abcde\\=offset_limit=9\n    1234abcde\\=offset_limit=4\n    1234abcde\\=offset_limit=4,offset=4\n\\= Expect no match\n    1234abcde\\=offset_limit=4,offset=5\n    1234abcde\\=offset_limit=3\n\n/(?<=abc)/use_offset_limit\n    1234abc\\=offset_limit=7\n\\= Expect no match\n    1234abc\\=offset_limit=6\n\n/A/g,replace=-,use_offset_limit\n    XAXAXAXAXA\\=offset_limit=4\n\n/abc/\n\\= Expect error\n    1234abcde\\=offset_limit=4\n\n/^\\w/m,use_offset_limit\n    \\n..\\naa\\=offset_limit=3\n    \\n..\\naa\\=offset_limit=4\n\n/abcd/null_context\n    abcd\\=null_context\n\\= Expect error - not allowed together\n    abcd\\=null_context,find_limits\n    abcd\\=allusedtext,startchar\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended\n    abcd\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended,substitute_literal\n    >>abcd<<\n    \n/abcd/g,replace=\\$1$2\\,substitute_literal\n    XabcdYabcdZ\n\n/a(bc)(DE)/replace=a\\u$1\\U$1\\E$1\\l$2\\L$2\\Eab\\Uab\\LYZ\\EDone,substitute_extended\n    abcDE\n\n/abcd/replace=xy\\kz,substitute_extended\n    abcd\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:+1:-1}X${2:+2:-2}\n    ab\n    ac\n    ab\\=replace=${1:+$1\\:$1:$2}\n    ac\\=replace=${1:+$1\\:$1:$2}\n    >>ac<<\\=replace=${1:+$1\\:$1:$2},substitute_literal\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:-1:-1}X${2:-2:-2}\n    ab\n    ac\n\n/(a)/substitute_extended,replace=>${1:+\\Q$1:{}$$\\E+\\U$1}<\n    a\n\n/X(b)Y/substitute_extended\n    XbY\\=replace=x${1:+$1\\U$1}y\n    XbY\\=replace=\\Ux${1:+$1$1}y\n\n/a/substitute_extended,replace=${*MARK:+a:b}\n    a\n\n/(abcd)/replace=${1:+xy\\kz},substitute_extended\n    abcd\n\n/(abcd)/\n    abcd\\=replace=${1:+xy\\kz},substitute_extended\n\n/abcd/substitute_extended,replace=>$1<\n    abcd\n\n/abcd/substitute_extended,replace=>xxx${xyz}<<<\n    abcd\n\n/(?J)(?:(?<A>a)|(?<A>b))/replace=<$A>\n    [a]\n    [b]\n\\= Expect error\n    (a)\\=ovector=1\n\n/(a)|(b)/replace=<$1>\n\\= Expect error\n    b\n\n/(aa)(BB)/substitute_extended,replace=\\U$1\\L$2\\E$1..\\U$1\\l$2$1\n    aaBB\n    \n/abcd/replace=wxyz,substitute_matched\n    abcd\n    pqrs \n\n/abcd/g\n    >abcd1234abcd5678<\\=replace=wxyz,substitute_matched\n\n/^(o(\\1{72}{\\\"{\\\\{00000059079}\\d*){74}}){19}/I\n\n/((p(?'K/\n\n/((p(?'K/no_auto_capture\n\n/abc/replace=A$3123456789Z\n    abc\n\n/(?<!a{65535}a{5})x/I\n\n/(?<!a{65535})x/I\n\n/(?=a\\K)/replace=z,allow_lookaround_bsk\n    BaCaD\n    \n/(?<=\\K.)/g,replace=-,allow_lookaround_bsk\n    ab\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEFG'toolong)/\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEF'justright)/\n\n# These two use zero-termination\n/abcd/max_pattern_length=3\n\n/abc/max_pattern_length=3\n\n# These two, being hex, pass the length\n/abcdefab/hex,max_pattern_length=3\n\n/abcdef/hex,max_pattern_length=3\n\n# These patterns used to take a long time to compile\n\n\"(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\n\n\"(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\n\n\"(?|()|())(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\n\n\"(?|()|())(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\n\n# Test the use of malloc for caching group information when there are more\n# groups than fit into the on-stack workspace.\n\n/\\[()]{1024}/I,expand\n\n# Test minlength capped at 65535\n\n/(A{65000})\\1{65000}/I\n\n# Test group scans when numbers are not unique\n\n/(?|()+|(a)+)/BI\n\n/(?|(a)+|()+)/BI\n\n/(?|()|(a))/BI\n\n/(?|(a)|())/BI\n\n# Test CRLF handling in empty string substitutions\n\n/^$/gm,newline=anycrlf,replace=-\n    X\\r\\n\\r\\nY\n\n/^$/gm,newline=crlf,replace=-\n    X\\r\\n\\r\\nY\n\n/^$/gm,newline=any,replace=-\n    X\\r\\n\\r\\nY\n\n\"(*ANYCRLF)(?m)^(.*[^0-9\\r\\n].*|)$\"g,replace=NaN\n    15\\r\\nfoo\\r\\n20\\r\\nbar\\r\\nbaz\\r\\n\\r\\n20\n\n/a[[:punct:]b]/bincode\n\n/a[b[:punct:]]/bincode\n\n/L(?#(|++<!(2)?/B\n\n/L(?#(|++<!(2)?/B,no_auto_possess\n\n/L(?#(|++<!(2)?/B,auto_callout\n\n/L(?#(|++<!(2)?/B,no_auto_possess,auto_callout\n\n/(A*)\\E+/B,auto_callout\n\n/()\\Q\\E*]/B,auto_callout\n    a[bc]d\n\n/\\x8a+f|;T?(*:;.'?`(\\xeap ){![^()!y*''C*(?';]{1;(\\x08)/B,alt_verbnames,dupnames,extended\n\n# Tests for NULL characters in comments and verb \"names\" and callouts\n\n# /A#B\\x00C\\x0aZ/\n/41 23 42 00 43 0a 5a/Bx,hex\n\n# /A+#B\\x00C\\x0a+/\n/41 2b 23 42 00 43 0a 2b/Bx,hex\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex,alt_verbnames\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex\n\n# /A(?C{X\\x00Y})B/\n/41 28 3f 43 7b 58 00 59 7d 29 42/B,hex\n\n# /A(?#X\\x00Y)B/\n/41 28 3f 23 7b 00 7d 29 42/B,hex\n\n# Tests for leading comment in extended patterns\n\n/ (?-x):?/extended\n\n/\u000b(?-x):?/extended\n\n/0b 28 3f 2d 78 29 3a/hex,extended\n\n/#comment\n(?-x):?/extended\n\n/(8(*:6^\\x09x\\xa6l\\)6!|\\xd0:[^:|)\\x09d\\Z\\d{85*m(?'(?<1!)*\\W[*\\xff]!!h\\w]*\\xbe;/alt_bsux,alt_verbnames,allow_empty_class,dollar_endonly,extended,multiline,never_utf,no_dotstar_anchor,no_start_optimize\n\n/a|(b)c/replace=>$1<,substitute_unset_empty\n    cat\n    xbcom\n\n/a|(b)c/\n    cat\\=replace=>$1<\n    cat\\=replace=>$1<,substitute_unset_empty\n    xbcom\\=replace=>$1<,substitute_unset_empty\n\n/a|(b)c/substitute_extended\n    cat\\=replace=>${2:-xx}<\n    cat\\=replace=>${2:-xx}<,substitute_unknown_unset\n    cat\\=replace=>${X:-xx}<,substitute_unknown_unset\n\n/a|(?'X'b)c/replace=>$X<,substitute_unset_empty\n    cat\n    xbcom\n\n/a|(?'X'b)c/replace=>$Y<,substitute_unset_empty\n    cat\n    cat\\=substitute_unknown_unset\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\n\n/a|(b)c/replace=>$2<,substitute_unset_empty\n    cat\n    cat\\=substitute_unknown_unset\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\n\n/()()()/use_offset_limit\n    \\=ovector=11000000000\n    \\=callout_fail=11000000000\n    \\=callout_fail=1:11000000000\n    \\=callout_data=11000000000\n    \\=callout_data=-11000000000\n    \\=offset_limit=1100000000000000000000\n    \\=copy=11000000000\n\n/(*MARK:A\\x00b)/mark\n    abc\n\n/(*MARK:A\\x00b)/mark,alt_verbnames\n    abc\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex\n    abc\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex,alt_verbnames\n    abc\n\n/efg/hex\n\n/eff/hex\n\n/effg/hex\n\n/(?J)(?'a'))(?'a')/\n\n/(?<=((?C)0))/\n    9010\n\\= Expect no match\n    abc\n\n/aaa/\n\\[abc]{10000000000000000000000000000}\n\\[a]{3}\n\n/\\[AB]{6000000000000000000000}/expand\n\n# Hex uses pattern length, not zero-terminated. This tests for overrunning\n# the given length of a pattern.\n\n/'(*U'/hex\n\n/'(*'/hex\n\n/'('/hex\n\n//hex\n\n# These tests are here because Perl never allows a back reference in a\n# lookbehind. PCRE2 supports some limited cases.\n\n/([ab])...(?<=\\1)z/\n    a11az\n    b11bz\n\\= Expect no match\n    b11az\n\n/(?|([ab]))...(?<=\\1)z/\n\n/([ab])(\\1)...(?<=\\2)z/\n    aa11az\n\n/(a\\2)(b\\1)(?<=\\2)/\n\n/(?<A>[ab])...(?<=\\k'A')z/\n    a11az\n    b11bz\n\\= Expect no match\n    b11az\n\n/(?<A>[ab])...(?<=\\k'A')(?<A>)z/dupnames\n\n# Perl does not support \\g+n\n\n/((\\g+1X)?([ab]))+/\n    aaXbbXa\n\n/ab(?C1)c/auto_callout\n    abc\n\n/'ab(?C1)c'/hex,auto_callout\n    abc\n\n# Perl accepts these, but gives a warning. We can't warn, so give an error.\n\n/[a-[:digit:]]+/\n    a-a9-a\n\n/[A-[:digit:]]+/\n    A-A9-A\n\n/[a-\\d]+/\n    a-a9-a\n\n/(?<RA>abc)(?(R)xyz)/B\n\n/(?<R>abc)(?(R)xyz)/B\n\n/(?=.*[A-Z])/I\n\n/()(?<=(?0))/\n\n/(?<!|!(?<!))/\n\n/(?<!|!|!||||||(?<!)||(?<!)!|!||(?<!)!|!(?<!)!|!|!|!||||!!|<!)!|!||||!|/\n\n/{2,2{2,2/use_length\n\n/.>*?\\g'0/use_length\n\n/.>*?\\g'0/\n\n/{\ufffd\u0344\ufffd\u0344\ufffd{'{22{2{{2{'{22{\u0012{22{2{'{22{2{{2{{222{{2{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{222{2\u0104\u0344\ufffd\u0344\ufffd{'{22{2{{2{'{22{\u0012{11{2{'{22{2{{2{{'{22{2{{2{'{22{\u0012{22{1{'{22{2{{2{{222{{2{'{22{2{22{2{'{/auto_callout\n\n//\n\\=get=i00000000000000000000000000000000\n\\=get=i2345678901234567890123456789012,get=i1245678901234567890123456789012\n\n\"(?(?C))\"\n\n/(?(?(?(?(?(?))))))/\n\n/(?<=(?1))((?s))/anchored\n\n/(*:ab)*/\n\n%(*:\u001e(:\u0011(\u001fsvvvvvvvvvv:]*[   Z!*;[]*[^[]*!^[\u0019+.+{{2,7}'      _\\\\\\\\\\\\\\\\\\\\\\\\\\)?.:..    *w////\\\\\\Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\T\\\\\\\\\\+/?/////'+\\\\\\EEE?/////'+/*+/[^K]?]//(w)%never_backslash_c,alt_verbnames,auto_callout\n\n/./newline=crlf\n    \\=ph\n\n/(\\x0e00\\000000\\xc)/replace=\\P,substitute_extended\n    \\x0e00\\000000\\xc\n\n//replace=0\n    \\=offset=7\n\n/(?<=\\G.)/g,replace=+\n    abc\n\n\".+\\QX\\E+\"B,no_auto_possess\n\n\".+\\QX\\E+\"B,auto_callout,no_auto_possess\n\n# This one is here because Perl gives an 'unmatched )' error which goes away\n# if one of the \\) sequences is removed - which is weird. PCRE finds it too\n# complicated to find a minimum matching length.\n\n\"()X|((((((((()))))))((((())))))\\2())((((((\\2\\2)))\\2)(\\22((((\\2\\2)2))\\2)))(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z+:)Z|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z((Z*(\\2(Z\\':))\\0)i|||||||||||||||loZ\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0nte!rnal errpr\\2\\\\21r(2\\ZZZ)+:)Z!|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZernZal ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\))\\ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)))\\2))))((((((\\2\\2))))))\"I\n\n# This checks that new code for handling groups that may match an empty string\n# works on a very large number of alternatives. This pattern used to provoke a\n# complaint that it was too complicated.\n\n/(?:\\[A|B|C|D|E|F|G|H|I|J|]{200}Z)/expand\n\n# This one used to compile rubbish instead of a compile error, and then\n# behave unpredictably at match time.\n\n/.+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X/\n    .+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X\n\n/[:[:alnum:]-[[a:lnum:]+/\n\n/((?(?C'')\\QX\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\n\n/((?(?C'')\\Q\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\n\n/abcd/auto_callout\n    abcd\\=callout_error=255:2\n\n/()(\\g+65534)/\n\n/()(\\g+65533)/\n\n/\ufffd\\x00\\x00\\x00\u0017\ufffd(\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\x00k\\d+\\x00\u200e\\x00\\x00\\x00\\x00\\x00\\2*\\x00\\x00\\1*.){36}int^\\x00\\x00\b\ufffd\ufffd\\x00\ufffd(\\1{50779}?)J\\w2/I\n\n/(a)(b)\\2\\1\\1\\1\\1/I\n\n/(?<a>a)(?<b>b)\\g{b}\\g{a}\\g{a}\\g{a}\\g{a}(?<a>xx)(?<b>zz)/I,dupnames\n\n//\n    \\=ovector=7777777777\n\n# This is here because Perl matches, even though a COMMIT is encountered\n# outside of the recursion.\n\n/(?1)(A(*COMMIT)|B)D/\n    BAXBAD\n\n\"(?1){2}(a)\"B\n\n\"(?1){2,4}(a)\"B\n\n# This test differs from Perl for the first subject. Perl ends up with\n# $1 set to 'B'; PCRE2 has it unset (which I think is right).\n\n/^(?:\n(?:A| (?:B|B(*ACCEPT)) (?<=(.)) D)\n(Z)\n)+$/x\n    AZB\n    AZBDZ\n\n# The first of these, when run by Perl, gives the mark 'aa', which is wrong.\n\n'(?>a(*:aa))b|ac' mark\n    ac\n\n'(?:a(*:aa))b|ac' mark\n    ac\n\n/(R?){65}/\n    (R?){65}\n\n/\\[(a)]{60}/expand\n    aaaa\n\n/(?<!\\1((?U)1((?U))))(*F)/never_backslash_c,alt_bsux,anchored,extended\n\n/\\g{3/\n\n/(a(?C1)(b)(c)d)+/\n  abcdabcd\\=callout_capture\n\n# Perl matches this one, but PCRE does not because (*ACCEPT) clears out any\n# pending backtracks in the recursion.\n\n/^ (?(DEFINE) (..(*ACCEPT)|...) ) (?1)$/x\n\\= Expect no match\n    abc\n\n# Perl gives no match for this one\n\n/(a(*MARK:m)(*ACCEPT)){0}(?1)/mark\n    abc\n\n/abc/endanchored\n    xyzabc\n\\= Expect no match\n    xyzabcdef\n\\= Expect error\n    xyzabc\\=ph\n\n/abc/\n    xyzabc\\=endanchored\n\\= Expect no match\n    xyzabcdef\\=endanchored\n\\= Expect error\n    xyzabc\\=ps,endanchored\n\n/abc(*ACCEPT)d/endanchored\n    xyzabc\n\\= Expect no match\n    xyzabcdef\n\n/abc|bcd/endanchored\n    xyzabcd\n\\= Expect no match\n    xyzabcdef\n\n/a(*ACCEPT)x|aa/endanchored\n    aaa\n\n# Check auto-anchoring when there is a group that is never obeyed at\n# the start of a branch.\n\n/(?(DEFINE)(a))^bc/I\n\n/(a){0}.*bc/sI\n\n# This should be anchored, as the condition is always false and there is\n# no alternative branch.\n\n/(?(VERSION>=999)yes)^bc/I\n\n# This should not be anchored.\n\n/(?(VERSION>=999)yes|no)^bc/I\n\n/(*LIMIT_HEAP=0)xxx/I\n\n/\\d{0,3}(*:abc)(?C1)xxx/callout_info\n\n# ----------------------------------------------------------------------\n\n# These are a whole pile of tests that touch lines of code that are not\n# used by any other tests (at least when these were created).\n\n/^a+?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aaa\n\n/^[^a]{3,}?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    bbb\n    cc\n\n/^X\\S/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\W/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\H/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\n\n/^X.+?/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\R+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\n\n/^X\\H+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\h+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n\n/^X\\V+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    X\\n\n\n/^X\\D+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    X9\n\n/^X\\S+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    X\\n\n\n/^X\\W+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\n    XX\n\n/^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n\n/(*CRLF)^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\r\\=ps\n\n/^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\n    X\\n\\r\\n\n    X\\n\\rY\n    X\\n\\nY\n    X\\n\\x{0c}Y\n\n/(*BSR_ANYCRLF)^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\n    X\\n\\r\\n\n    X\\n\\rY\n    X\\n\\nY\n    X\\n\\x{0c}Y\n\n/^X\\H+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\t\n    XYY\n\n/^X\\h+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\n    X\\tY\n\n/^X\\V+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n    XYY\n\n/^X\\v+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\n    X\\nY\n\n/^X\\D+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY9\n    XYY\n\n/^X\\d+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X99\n    X9Y\n\n/^X\\S+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n    XYY\n\n/^X\\s+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\n    X\\nY\n\n/^X\\W+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X.A\n    X++\n\n/^X\\w+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.\n    Xaa\n\n/^X.{1,3}Z/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.bd\n\n/^X\\h+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\n    X\\tY\n\n/^X\\V+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\n    XYY\n\n/^(X(*THEN)Y|AB){0}(?1)/\n    ABX\n\\= Expect no match\n    XAB\n\n/^(?!A(?C1)B)C/\n    ABC\\=callout_error=1,no_jit\n\n/^(?!A(?C1)B)C/no_start_optimize\n    ABC\\=callout_error=1\n\n/^(?(?!A(?C1)B)C)/\n    ABC\\=callout_error=1\n\n# ----------------------------------------------------------------------\n\n/[a b c]/BxxI\n\n/[a b c]/BxxxI\n\n/[a b c]/B,extended_more\n\n/[ a b c ]/B,extended_more\n\n/[a b](?xx: [ 12 ] (?-xx:[ 34 ]) )y z/B\n\n# Unsetting /x also unsets /xx\n\n/[a b](?xx: [ 12 ] (?-x:[ 34 ]) )y z/B\n\n/(a)(?-n:(b))(c)/nB\n\n# ----------------------------------------------------------------------\n# These test the dangerous PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL option.\n\n/\\j\\x{z}\\o{82}\\L\\uabcd\\u\\U\\g{\\g/B,\\bad_escape_is_literal\n\n/\\N{\\c/IB,bad_escape_is_literal\n\n/[\\j\\x{z}\\o\\gAb\\g]/B,bad_escape_is_literal\n\n/[Q-\\N]/B,bad_escape_is_literal\n\n/[\\s-_]/bad_escape_is_literal\n\n/[_-\\s]/bad_escape_is_literal\n\n/[\\B\\R\\X]/B\n\n/[\\B\\R\\X]/B,bad_escape_is_literal\n\n/[A-\\BP-\\RV-\\X]/B\n\n/[A-\\BP-\\RV-\\X]/B,bad_escape_is_literal\n\n# ----------------------------------------------------------------------\n\n/a\\b(c/literal\n    a\\\\b(c\n\n/a\\b(c/literal,caseless\n    a\\\\b(c\n    a\\\\B(c\n\n/a\\b(c/literal,firstline\n    XYYa\\\\b(c\n\\= Expect no match\n    X\\na\\\\b(c\n\n/a\\b?c/literal,use_offset_limit\n    XXXXa\\\\b?c\\=offset_limit=4\n\\= Expect no match\n    XXXXa\\\\b?c\\=offset_limit=3\n\n/a\\b(c/literal,anchored,endanchored\n    a\\\\b(c\n\\= Expect no match\n    Xa\\\\b(c\n    a\\\\b(cX\n    Xa\\\\b(cX\n\n//literal,extended\n\n/a\\b(c/literal,auto_callout,no_start_optimize\n    XXXXa\\\\b(c\n\n/a\\b(c/literal,auto_callout\n    XXXXa\\\\b(c\n\n/(*CR)abc/literal\n    (*CR)abc\n\n/cat|dog/I,match_word\n    the cat sat\n\\= Expect no match\n    caterpillar\n    snowcat\n    syndicate\n\n/(cat)|dog/I,match_line,literal\n    (cat)|dog\n\\= Expect no match\n    the cat sat\n    caterpillar\n    snowcat\n    syndicate\n\n/a whole line/match_line,multiline\n    Rhubarb \\na whole line\\n custard\n\\= Expect no match\n    Not a whole line\n\n# Perl gets this wrong, failing to capture 'b' in group 1.\n\n/^(b+|a){1,2}?bc/\n    bbc\n    \n# And again here, for the \"babc\" subject string. \n\n/^(b*|ba){1,2}?bc/\n    babc\n    bbabc\n    bababc\n\\= Expect no match\n    bababbc\n    babababc\n\n/[[:digit:]-a]/\n\n/[[:digit:]-[:print:]]/\n\n/[\\d-a]/\n\n/[\\H-z]/\n\n/[\\d-[:print:]]/\n\n# Perl gets the second of these wrong, giving no match.\n\n\"(?<=(a))\\1?b\"I\n    ab\n    aaab \n\n\"(?=(a))\\1?b\"I\n    ab\n    aaab\n    \n# JIT does not support callout_extra  \n    \n/(*NO_JIT)(a+)b/auto_callout,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \n    \n/(*NO_JIT)a+(?C'XXX')b/no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \n\n/\\n/firstline\n    xyz\\nabc\n\n/\\nabc/firstline\n    xyz\\nabc\n\n/\\x{0a}abc/firstline,newline=crlf\n\\= Expect no match\n    xyz\\r\\nabc\n\n/[abc]/firstline\n\\= Expect no match\n    \\na\n    \n# These tests are matched in test 1 as they are Perl compatible. Here we are\n# looking at what does and does not get auto-possessified. \n\n/(?(DEFINE)(?<optional_a>a?))^(?&optional_a)a$/B\n\n/(?(DEFINE)(?<optional_a>a?)X)^(?&optional_a)a$/B\n    \n/^(a?)b(?1)a/B\n\n/^(a?)+b(?1)a/B\n\n/^(a?)++b(?1)a/B\n\n/^(a?)+b/B\n\n/(?=a+)a(a+)++b/B\n\n/(?<=(?=.){4,5}x)/B\n\n# Perl behaves differently with these when optimization is turned off\n\n/a(*PRUNE:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\n\n/a(*THEN:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\n\n/(?^x-i)AB/ \n\n/(?^-i)AB/ \n\n/(?x-i-i)/\n\n/(?(?=^))b/I\n    abc\n\n/(?(?=^)|)b/I\n    abc\n\n/(?(?=^)|^)b/I\n    bbc\n\\= Expect no match\n    abc     \n\n/(?(1)^|^())/I\n\n/(?(1)^())b/I\n\n/(?(1)^())+b/I,aftertext\n    abc\n\n/(?(1)^()|^)+b/I,aftertext\n    bbc \n\\= Expect no match     \n    abc\n\n/(?(1)^()|^)*b/I,aftertext\n    bbc \n    abc\n    xbc \n\n/(?(1)^())+b/I,aftertext\n    abc\n\n/(?(1)^a()|^a)+b/I,aftertext\n    abc \n\\= Expect no match     \n    bbc\n\n/(?(1)^|^(a))+b/I,aftertext\n    abc \n\\= Expect no match     \n    bbc\n\n/(?(1)^a()|^a)*b/I,aftertext\n    abc \n    bbc\n    xbc \n\n/a(b)c|xyz/g,allvector,replace=<$0>\n    abcdefabcpqr\\=ovector=4\n    abxyz\\=ovector=4\n    abcdefxyz\\=ovector=4\n    \n/a(b)c|xyz/allvector\n    abcdef\\=ovector=4\n    abxyz\\=ovector=4\n\n/a(b)c|xyz/g,replace=<$0>,substitute_callout\n    abcdefabcpqr\n    abxyzpqrabcxyz\n    12abc34xyz99abc55\\=substitute_stop=2\n    12abc34xyz99abc55\\=substitute_skip=1\n    12abc34xyz99abc55\\=substitute_skip=2\n\n/a(b)c|xyz/g,replace=<$0>\n    abcdefabcpqr\n    abxyzpqrabcxyz\n    12abc34xyz\\=substitute_stop=2\n    12abc34xyz\\=substitute_skip=1\n\n/a(b)c|xyz/replace=<$0>\n    abcdefabcpqr\n    12abc34xyz\\=substitute_skip=1\n    12abc34xyz\\=substitute_stop=1\n\n/abc\\rdef/\n    abc\\ndef\n\n/abc\\rdef\\x{0d}xyz/escaped_cr_is_lf\n    abc\\ndef\\rxyz\n\\= Expect no match     \n    abc\\ndef\\nxyz\n\n/(?(*ACCEPT)xxx)/\n\n/(?(*atomic:xx)xxx)/\n\n/(?(*script_run:xxx)zzz)/\n\n/foobar/\n    the foobar thing\\=copy_matched_subject\n    the foobar thing\\=copy_matched_subject,zero_terminate\n\n/foobar/g\n    the foobar thing foobar again\\=copy_matched_subject\n\n/(*:XX)^abc/I\n\n/(*COMMIT:XX)^abc/I\n\n/(*ACCEPT:XX)^abc/I\n\n/abc/replace=xyz\n    abc\\=null_context\n\n/abc/replace=xyz,substitute_callout\n    abc \n\\= Expect error message\n    abc\\=null_context\n\n/\\[()]{65535}()/expand\n\n/\\[()]{65535}(?<A>)/expand\n\n/a(?:(*ACCEPT))??bc/\n    abc\n    axy\n\n/a(*ACCEPT)??bc/\n    abc\n    axy\n\n/a(*ACCEPT:XX)??bc/mark\n    abc\n    axy\n\n/(*:\\)?/\n\n/(*:\\Q \\E){5}/alt_verbnames\n\n/(?=abc)/I\n\n/(?|(X)|(XY))\\1abc/I\n\n/(?|(a)|(bcde))(c)\\2/I\n\n/(?|(a)|(bcde))(c)\\1/I\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'B'(?'A')/I,dupnames\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'A'(?'A')/I,dupnames\n\n/((a|)+)+Z/I\n\n/((?=a))[abcd]/I\n\n/A(?:(*ACCEPT))?B/info\n\n/(A(*ACCEPT)??B)C/\n    ABC\n    AXY \n\n/(?<=(?<=a)b)c.*/I\n    abc\\=ph\n\\= Expect no match\n    xbc\\=ph\n\n/(?<=ab)c.*/I\n    abc\\=ph\n\\= Expect no match\n    xbc\\=ph\n\n/(?<=a(?<=a|a)c)/I\n\n/(?<=a(?<=a|ba)c)/I\n\n/(?<=(?<=a)b)(?<!abcd)/I\n\n/(?<=(?<=a)b)(?<!abcd)(?<=(?<=a)bcde)/I\n\n# Addition overflow\n/( {32742} {42})(?<!\\1{65481})/\n\n# Multiplication overflow\n/(X{65535})(?<=\\1{32770})/\n\n# ---- Non-atomic assertion tests ----\n\n# Expect error: not allowed as a condition\n/(?(*napla:xx)bc)/\n\n/\\A(*pla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n\n/\\A(*napla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n\n/\\A(?*.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n\n/(*plb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n    abcda\\=offset=4 \n\n/(*naplb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n    abcda\\=offset=4 \n    \n/(?<*(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n    abcda\\=offset=4 \n    \n/(*non_atomic_positive_lookahead:ab)/B\n \n/(*non_atomic_positive_lookbehind:ab)/B \n\n/(*pla:ab+)/B\n\n/(*napla:ab+)/B\n\n/(*napla:)+/\n\n/(*naplb:)+/\n\n/(*napla:^x|^y)/I\n\n/(*napla:abc|abd)/I\n\n/(*napla:a|(.)(*ACCEPT)zz)\\1../\n    abcd\n    \n/(*napla:a(*ACCEPT)zz|(.))\\1../\n    abcd\n    \n/(*napla:a|(*COMMIT)(.))\\1\\1/\n    aabc\n\\= Expect no match     \n    abbc   \n\n/(*napla:a|(.))\\1\\1/\n    aabc\n    abbc   \n\n# ----\n\n# Expect error (recursion => not fixed length)\n/(\\2)((?=(?<=\\1)))/\n\n/c*+(?<=[bc])/\n    abc\\=ph\n    ab\\=ph\n    abc\\=ps\n    ab\\=ps\n\n/c++(?<=[bc])/\n    abc\\=ph\n    ab\\=ph\n\n/(?<=(?=.(?<=x)))/\n    abx\n    ab\\=ph\n    bxyz \n    xyz\n    \n/\\z/\n   abc\\=ph\n   abc\\=ps \n   \n/\\Z/\n   abc\\=ph\n   abc\\=ps \n   abc\\n\\=ph\n   abc\\n\\=ps\n\n/(?![ab]).*/\n    ab\\=ph\n\n/c*+/\n    ab\\=ph,offset=2\n\n/\\A\\s*(a|(?:[^`]{28500}){4})/I\n    a\n\n/\\A\\s*((?:[^`]{28500}){4})/I\n\n/\\A\\s*((?:[^`]{28500}){4}|a)/I\n    a\n\n/(?<A>a)(?(<A>)b)((?<=b).*)/B\n\n/(?(1)b)((?<=b).*)/B\n\n/(?(R1)b)((?<=b).*)/B\n\n/(?(DEFINE)b)((?<=b).*)/B\n\n/(?(VERSION=10.3)b)((?<=b).*)/B\n\n/[aA]b[cC]/IB\n\n/[cc]abcd/I\n\n/[Cc]abcd/I\n\n/[c]abcd/I\n\n/(?:c|C)abcd/I\n\n/(a)?a/I\n    manm\n\n/^(?|(\\*)(*napla:\\S*_(\\2?+.+))|(\\w)(?=\\S*_(\\2?+\\1)))+_\\2$/\n    *abc_12345abc\n\n/^(?|(\\*)(*napla:\\S*_(\\3?+.+))|(\\w)(?=\\S*_((\\2?+\\1))))+_\\2$/\n    *abc_12345abc\n\n/^((\\1+)(?C)|\\d)+133X$/\n    111133X\\=callout_capture\n\n/abc/replace=xyz,substitute_replacement_only\n    123abc456\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z,substitute_replacement_only\n    \"abcde-abcde-\"\n     \n/a(b)c|xyz/g,replace=<$0>,substitute_callout,substitute_replacement_only\n    abcdefabcpqr                \n    abxyzpqrabcxyz              \n    12abc34xyz99abc55\\=substitute_stop=2                          \n    12abc34xyz99abc55\\=substitute_skip=1\n    12abc34xyz99abc55\\=substitute_skip=2\n\n/a(..)d/replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\n\n/a(..)d/g,replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\n    xyzabcdxyzabcdxyz\\=ovector=1,substitute_unset_empty\n\n/55|a(..)d/g,replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n\\= Expect error     \n    xyz55abcdxyzabcdxyz\\=ovector=2\n\n/55|a(..)d/replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n\n/55|a(..)d/replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n\n/55|a(..)d/g,replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n    \n/abc/replace=,caseless\n    XabcY\n    XABCY \n\n/abc/replace=[4],caseless\n    XabcY\n    XABCY \n\n/abc/replace=*,caseless\n    XabcY\n    XABCY\n    XabcY\\=replace=  \n\n# Expect non-fixed-length error\n\n\"(?<=X(?(DEFINE)(.*))(?1)).\"\n\n/\\sxxx\\s/tables=1\n\\= Expect no match\n    AB\\x{85}xxx\\x{a0}XYZ\n\n/\\sxxx\\s/tables=2\n    AB\\x{85}xxx\\x{a0}XYZ\n\n/^\\w+/tables=2\n    \u00c9cole\n\n/^\\w+/tables=3\n    \u00c9cole\n\n#loadtables ./testbtables\n\n/^\\w+/tables=3\n    \u00c9cole\n\n/\"(*MARK:>\" 00 \"<)..\"/hex,mark,no_start_optimize\n    AB\n    A\\=ph \n\\= Expect no match\n    A\n\n/\"(*MARK:>\" 00 \"<).(?C1).\"/hex,mark,no_start_optimize\n    AB\n\n/(?(VERSION=0.0/\n\n# Perl has made \\K in lookarounds an error. PCRE2 now rejects as well, unless\n# explicitly authorized.\n\n/(?=a\\Kb)ab/\n\n/(?=a\\Kb)ab/allow_lookaround_bsk\n    ab \n\n/(?!a\\Kb)ac/\n\n/(?!a\\Kb)ac/allow_lookaround_bsk\n    ac \n    \n/^abc(?<=b\\Kc)d/\n\n/^abc(?<=b\\Kc)d/allow_lookaround_bsk\n    abcd\n\n/^abc(?<!b\\Kq)d/\n\n/^abc(?<!b\\Kq)d/,allow_lookaround_bsk\n    abcd\n    \n# --------- \n\n# Tests for zero-length NULL to be treated as an empty string.\n\n//\n    \\=null_subject\n\\= Expect error     \n    abc\\=null_subject\n\n//replace=[20]\n    abc\\=null_replacement\n    \\=null_subject\n    \\=null_replacement\n\n/X*/g,replace=xy\n\\= Expect error\n    >X<\\=null_replacement\n\n/X+/replace=[20]\n    >XX<\\=null_replacement\n\n# --------- \n\n/[Aa]{2}/BI\n    aabcd\n\n/A{2}/iBI\n    aabcd\n\n/[Aa]{2,3}/BI\n    aabcd\n\n--\n    \\[X]{-10}\n\n# End of testinput2\n", "# This set of tests is not Perl-compatible. It checks on special features\n# of PCRE2's API, error diagnostics, and the compiled code of some patterns.\n# It also checks the non-Perl syntax that PCRE2 supports (Python, .NET,\n# Oniguruma). There are also some tests where PCRE2 and Perl differ,\n# either because PCRE2 can't be compatible, or there is a possible Perl\n# bug.\n\n# NOTE: This is a non-UTF set of tests. When UTF support is needed, use\n# test 5.\n\n#forbid_utf\n#newline_default lf any anycrlf\n\n# Test binary zeroes in the pattern\n\n# /a\\0B/ where 0 is a binary zero\n/61 5c 00 62/B,hex\n------------------------------------------------------------------\n        Bra\n        a\\x00b\n        Ket\n        End\n------------------------------------------------------------------\n    a\\x{0}b\n 0: a\\x00b\n\n# /a0b/ where 0 is a binary zero\n/61 00 62/B,hex\n------------------------------------------------------------------\n        Bra\n        a\\x00b\n        Ket\n        End\n------------------------------------------------------------------\n    a\\x{0}b\n 0: a\\x00b\n\n# /(?#B0C)DE/ where 0 is a binary zero\n/28 3f 23 42 00 43 29 44 45/B,hex\n------------------------------------------------------------------\n        Bra\n        DE\n        Ket\n        End\n------------------------------------------------------------------\n    DE\n 0: DE\n\n/(a)b|/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/abc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n    abc\n 0: abc\n    defabc\n 0: abc\n    abc\\=anchored\n 0: abc\n\\= Expect no match\n    defabc\\=anchored\nNo match\n    ABC\nNo match\n\n/^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n    abc\n 0: abc\n    abc\\=anchored\n 0: abc\n\\= Expect no match\n    defabc\nNo match\n    defabc\\=anchored\nNo match\n\n/a+bc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/a*bc/I\nCapture group count = 0\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/a{3}bc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 5\n\n/(abc|a+z)/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/^abc$/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n    abc\n 0: abc\n\\= Expect no match\n    def\\nabc\nNo match\n\n/ab\\idef/\nFailed: error 103 at offset 3: unrecognized character follows \\\n\n/(?X)ab\\idef/\nFailed: error 111 at offset 2: unrecognized character after (? or (?-\n\n/x{5,4}/\nFailed: error 104 at offset 5: numbers out of order in {} quantifier\n\n/z{65536}/\nFailed: error 105 at offset 7: number too big in {} quantifier\n\n/[abcd/\nFailed: error 106 at offset 5: missing terminating ] for character class\n\n/[\\B]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[\\R]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[\\X]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[z-a]/\nFailed: error 108 at offset 3: range out of order in character class\n\n/^*/\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/(abc/\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/(?# abc/\nFailed: error 118 at offset 7: missing ) after (?# comment\n\n/(?z)abc/\nFailed: error 111 at offset 2: unrecognized character after (? or (?-\n\n/.*b/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/.*?b/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/cat|dog|elephant/I\nCapture group count = 0\nStarting code units: c d e \nSubject length lower bound = 3\n    this sentence eventually mentions a cat\n 0: cat\n    this sentences rambles on and on for a while and then reaches elephant\n 0: elephant\n\n/cat|dog|elephant/I\nCapture group count = 0\nStarting code units: c d e \nSubject length lower bound = 3\n    this sentence eventually mentions a cat\n 0: cat\n    this sentences rambles on and on for a while and then reaches elephant\n 0: elephant\n\n/cat|dog|elephant/Ii\nCapture group count = 0\nOptions: caseless\nStarting code units: C D E c d e \nSubject length lower bound = 3\n    this sentence eventually mentions a CAT cat\n 0: CAT\n    this sentences rambles on and on for a while to elephant ElePhant\n 0: elephant\n\n/a|[bcd]/I\nCapture group count = 0\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a|[^\\dZ])/I\nCapture group count = 1\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / : ; < = > \n  ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y [ \\ ] ^ _ ` a b c d \n  e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \n  \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \n  \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \n  \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \n  \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \n  \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \n  \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \n  \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \n  \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \n  \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/(a|b)*[\\s]/I\nCapture group count = 1\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 a b \nSubject length lower bound = 1\n\n/(ab\\2)/\nFailed: error 115 at offset 4: reference to non-existent subpattern\n\n/{4,5}abc/\nFailed: error 109 at offset 4: quantifier does not follow a repeatable item\n\n/(a)(b)(c)\\2/I\nCapture group count = 3\nMax back reference = 2\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 4\n    abcb\n 0: abcb\n 1: a\n 2: b\n 3: c\n    abcb\\=ovector=0\n 0: abcb\n 1: a\n 2: b\n 3: c\n    abcb\\=ovector=1\nMatched, but too many substrings\n 0: abcb\n    abcb\\=ovector=2\nMatched, but too many substrings\n 0: abcb\n 1: a\n    abcb\\=ovector=3\nMatched, but too many substrings\n 0: abcb\n 1: a\n 2: b\n    abcb\\=ovector=4\n 0: abcb\n 1: a\n 2: b\n 3: c\n\n/(a)bc|(a)(b)\\2/I\nCapture group count = 3\nMax back reference = 2\nFirst code unit = 'a'\nSubject length lower bound = 3\n    abc\n 0: abc\n 1: a\n    abc\\=ovector=0\n 0: abc\n 1: a\n    abc\\=ovector=1\nMatched, but too many substrings\n 0: abc\n    abc\\=ovector=2\n 0: abc\n 1: a\n    aba\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n    aba\\=ovector=0\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n    aba\\=ovector=1\nMatched, but too many substrings\n 0: aba\n    aba\\=ovector=2\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n    aba\\=ovector=3\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n 2: a\n    aba\\=ovector=4\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n\n/abc$/I,dollar_endonly\nCapture group count = 0\nOptions: dollar_endonly\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n    abc\n 0: abc\n\\= Expect no match\n    abc\\n\nNo match\n    abc\\ndef\nNo match\n\n/(a)(b)(c)(d)(e)\\6/\nFailed: error 115 at offset 16: reference to non-existent subpattern\n\n/the quick brown fox/I\nCapture group count = 0\nFirst code unit = 't'\nLast code unit = 'x'\nSubject length lower bound = 19\n    the quick brown fox\n 0: the quick brown fox\n    this is a line with the quick brown fox\n 0: the quick brown fox\n\n/the quick brown fox/I,anchored\nCapture group count = 0\nOptions: anchored\nFirst code unit = 't'\nSubject length lower bound = 19\n    the quick brown fox\n 0: the quick brown fox\n\\= Expect no match\n    this is a line with the quick brown fox\nNo match\n\n/ab(?z)cd/\nFailed: error 111 at offset 4: unrecognized character after (? or (?-\n\n/^abc|def/I\nCapture group count = 0\nStarting code units: a d \nSubject length lower bound = 3\n    abcdef\n 0: abc\n    abcdef\\=notbol\n 0: def\n\n/.*((abc)$|(def))/I\nCapture group count = 3\nFirst code unit at start or follows newline\nSubject length lower bound = 3\n    defabc\n 0: defabc\n 1: abc\n 2: abc\n    defabc\\=noteol\n 0: def\n 1: def\n 2: <unset>\n 3: def\n\n/)/\nFailed: error 122 at offset 0: unmatched closing parenthesis\n\n/a[]b/\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/[^aeiou ]{3,}/I\nCapture group count = 0\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 \n  7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \n  \\ ] ^ _ ` b c d f g h j k l m n p q r s t v w x y z { | } ~ \\x7f \\x80 \\x81 \n  \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \n  \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \n  \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \n  \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \n  \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \n  \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \n  \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \n  \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \n  \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 3\n    co-processors, and for\n 0: -pr\n\n/<.*>/I\nCapture group count = 0\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>ghi<klm>\n\n/<.*?>/I\nCapture group count = 0\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>\n\n/<.*>/I,ungreedy\nCapture group count = 0\nOptions: ungreedy\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>\n\n/(?U)<.*>/I\nCapture group count = 0\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>\n\n/<.*?>/I,ungreedy\nCapture group count = 0\nOptions: ungreedy\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    abc<def>ghi<klm>nop\n 0: <def>ghi<klm>\n\n/={3,}/I,ungreedy\nCapture group count = 0\nOptions: ungreedy\nFirst code unit = '='\nLast code unit = '='\nSubject length lower bound = 3\n    abc========def\n 0: ===\n\n/(?U)={3,}?/I\nCapture group count = 0\nFirst code unit = '='\nLast code unit = '='\nSubject length lower bound = 3\n    abc========def\n 0: ========\n\n/(?<!bar|cattle)foo/I\nCapture group count = 0\nMax lookbehind = 6\nFirst code unit = 'f'\nLast code unit = 'o'\nSubject length lower bound = 3\n    foo\n 0: foo\n    catfoo\n 0: foo\n\\= Expect no match\n    the barfoo\nNo match\n    and cattlefoo\nNo match\n\n/abc(?<=a+)b/\nFailed: error 125 at offset 3: lookbehind assertion is not fixed length\n\n/12345(?<=aaa|b{0,3})b/\nFailed: error 125 at offset 5: lookbehind assertion is not fixed length\n\n/(?<!(foo)a\\1)bar/\n\n/(?i)abc/I\nCapture group count = 0\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/(a|(?m)a)/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?i)^1234/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = '1'\nSubject length lower bound = 4\n\n/(^b|(?i)^d)/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nStarting code units: D b d \nSubject length lower bound = 1\n\n/(?s).*/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/[abcd]/I\nCapture group count = 0\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(?i)[abcd]/I\nCapture group count = 0\nStarting code units: A B C D a b c d \nSubject length lower bound = 1\n\n/(?m)[xy]|(b|c)/I\nCapture group count = 1\nStarting code units: b c x y \nSubject length lower bound = 1\n\n/(^a|^b)/Im\nCapture group count = 1\nOptions: multiline\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(?i)(^a|^b)/Im\nCapture group count = 1\nOptions: multiline\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(a)(?(1)a|b|c)/\nFailed: error 127 at offset 3: conditional subpattern contains more than two branches\n\n/(?(?=a)a|b|c)/\nFailed: error 127 at offset 0: conditional subpattern contains more than two branches\n\n/(?(1a)/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/(?(1a))/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/(?(?i))/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/(?(abc))/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/(?(?<ab))/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/((?s)blah)\\s+\\1/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'b'\nLast code unit = 'h'\nSubject length lower bound = 9\n\n/((?i)blah)\\s+\\1/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'b' (caseless)\nLast code unit = 'h' (caseless)\nSubject length lower bound = 9\n\n/((?i)b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n     /i b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'b' (caseless)\nSubject length lower bound = 1\n\n/(a*b|(?i:c*(?-i)d))/I\nCapture group count = 1\nStarting code units: C a b c d \nSubject length lower bound = 1\n\n/a$/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n    a\n 0: a\n    a\\n\n 0: a\n\\= Expect no match\n    a\\=noteol\nNo match\n    a\\n\\=noteol\nNo match\n\n/a$/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit = 'a'\nSubject length lower bound = 1\n    a\n 0: a\n    a\\n\n 0: a\n    a\\n\\=noteol\n 0: a\n\\= Expect no match\n    a\\=noteol\nNo match\n\n/\\Aabc/Im\nCapture group count = 0\nMax lookbehind = 1\nCompile options: multiline\nOverall options: anchored multiline\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/^abc/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/I\nCapture group count = 5\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n  aaaaabbbbbcccccdef\n 0: aaaaabbbbbcccccdef\n 1: aaaaabbbbbcccccdef\n 2: aaaaa\n 3: b\n 4: bbbbccccc\n 5: def\n\n/(?<=foo)[ab]/I\nCapture group count = 0\nMax lookbehind = 3\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?<!foo)(alpha|omega)/I\nCapture group count = 1\nMax lookbehind = 3\nStarting code units: a o \nLast code unit = 'a'\nSubject length lower bound = 5\n\n/(?!alphabet)[ab]/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?<=foo\\n)^bar/Im\nCapture group count = 0\nMax lookbehind = 4\nContains explicit CR or LF match\nOptions: multiline\nLast code unit = 'r'\nSubject length lower bound = 3\n    foo\\nbarbar\n 0: bar\n\\= Expect no match\n    rhubarb\nNo match\n    barbell\nNo match\n    abc\\nbarton\nNo match\n\n/^(?<=foo\\n)bar/Im\nCapture group count = 0\nMax lookbehind = 4\nContains explicit CR or LF match\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'r'\nSubject length lower bound = 3\n    foo\\nbarbar\n 0: bar\n\\= Expect no match\n    rhubarb\nNo match\n    barbell\nNo match\n    abc\\nbarton\nNo match\n\n/(?>^abc)/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    abc\n 0: abc\n    def\\nabc\n 0: abc\n\\= Expect no match\n    defabc\nNo match\n\n/(?<=ab(c+)d)ef/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/(?<=ab(?<=c+)d)ef/\nFailed: error 125 at offset 6: lookbehind assertion is not fixed length\n\n/(?<=ab(c|de)f)g/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/The next three are in testinput2 because they have variable length branches/\n\n/(?<=bullock|donkey)-cart/I\nCapture group count = 0\nMax lookbehind = 7\nFirst code unit = '-'\nLast code unit = 't'\nSubject length lower bound = 5\n    the bullock-cart\n 0: -cart\n    a donkey-cart race\n 0: -cart\n\\= Expect no match\n    cart\nNo match\n    horse-and-cart\nNo match\n\n/(?<=ab(?i)x|y|z)/I\nCapture group count = 0\nMax lookbehind = 3\nMay match empty string\nSubject length lower bound = 0\n\n/(?>.*)(?<=(abcd)|(xyz))/I\nCapture group count = 2\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n    alphabetabcd\n 0: alphabetabcd\n 1: abcd\n    endingxyz\n 0: endingxyz\n 1: <unset>\n 2: xyz\n\n/(?<=ab(?i)x(?-i)y|(?i)z|b)ZZ/I\nCapture group count = 0\nMax lookbehind = 4\nFirst code unit = 'Z'\nLast code unit = 'Z'\nSubject length lower bound = 2\n    abxyZZ\n 0: ZZ\n    abXyZZ\n 0: ZZ\n    ZZZ\n 0: ZZ\n    zZZ\n 0: ZZ\n    bZZ\n 0: ZZ\n    BZZ\n 0: ZZ\n\\= Expect no match\n    ZZ\nNo match\n    abXYZZ\nNo match\n    zzz\nNo match\n    bzz\nNo match\n\n/(?<!(foo)a)bar/I\nCapture group count = 1\nMax lookbehind = 4\nFirst code unit = 'b'\nLast code unit = 'r'\nSubject length lower bound = 3\n    bar\n 0: bar\n    foobbar\n 0: bar\n\\= Expect no match\n    fooabar\nNo match\n\n# Perl does not fail these two for the final subjects.\n\n/^(xa|=?\\1a){2}$/\n    xa=xaa\n 0: xa=xaa\n 1: =xaa\n\\= Expect no match\n    xa=xaaa\nNo match\n\n/^(xa|=?\\1a)+$/\n    xa=xaa\n 0: xa=xaa\n 1: =xaa\n\\= Expect no match\n    xa=xaaa\nNo match\n\n# These are syntax tests from Perl 5.005\n\n/a[b-a]/\nFailed: error 108 at offset 4: range out of order in character class\n\n/a[]b/\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/a[/\nFailed: error 106 at offset 2: missing terminating ] for character class\n\n/*a/\nFailed: error 109 at offset 0: quantifier does not follow a repeatable item\n\n/(*)b/\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/abc)/\nFailed: error 122 at offset 3: unmatched closing parenthesis\n\n/(abc/\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/a**/\nFailed: error 109 at offset 2: quantifier does not follow a repeatable item\n\n/)(/\nFailed: error 122 at offset 0: unmatched closing parenthesis\n\n/\\1/\nFailed: error 115 at offset 1: reference to non-existent subpattern\n\n/\\2/\nFailed: error 115 at offset 1: reference to non-existent subpattern\n\n/(a)|\\2/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/a[b-a]/Ii\nFailed: error 108 at offset 4: range out of order in character class\n\n/a[]b/Ii\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/a[/Ii\nFailed: error 106 at offset 2: missing terminating ] for character class\n\n/*a/Ii\nFailed: error 109 at offset 0: quantifier does not follow a repeatable item\n\n/(*)b/Ii\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/abc)/Ii\nFailed: error 122 at offset 3: unmatched closing parenthesis\n\n/(abc/Ii\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/a**/Ii\nFailed: error 109 at offset 2: quantifier does not follow a repeatable item\n\n/)(/Ii\nFailed: error 122 at offset 0: unmatched closing parenthesis\n\n/:(?:/\nFailed: error 114 at offset 4: missing closing parenthesis\n\n/(?<%)b/\nFailed: error 162 at offset 3: subpattern name expected\n\n/a(?{)b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{{})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{}})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{\"{\"})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/a(?{\"{\"}})b/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/(?(1?)a|b)/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/[a[:xyz:/\nFailed: error 106 at offset 8: missing terminating ] for character class\n\n/(?<=x+)y/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/a{37,17}/\nFailed: error 104 at offset 7: numbers out of order in {} quantifier\n\n/abc/\\\nFailed: error 101 at offset 4: \\ at end of pattern\n\n/abc/\\i\nFailed: error 101 at offset 4: \\ at end of pattern\n\n/(a)bc(d)/I\nCapture group count = 2\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n    abcd\n 0: abcd\n 1: a\n 2: d\n    abcd\\=copy=2\n 0: abcd\n 1: a\n 2: d\n 2C d (1)\n    abcd\\=copy=5\n 0: abcd\n 1: a\n 2: d\nCopy substring 5 failed (-49): unknown substring\n\n/(.{20})/I\nCapture group count = 1\nSubject length lower bound = 20\n    abcdefghijklmnopqrstuvwxyz\n 0: abcdefghijklmnopqrst\n 1: abcdefghijklmnopqrst\n    abcdefghijklmnopqrstuvwxyz\\=copy=1\n 0: abcdefghijklmnopqrst\n 1: abcdefghijklmnopqrst\n 1C abcdefghijklmnopqrst (20)\n    abcdefghijklmnopqrstuvwxyz\\=get=1\n 0: abcdefghijklmnopqrst\n 1: abcdefghijklmnopqrst\n 1G abcdefghijklmnopqrst (20)\n\n/(.{15})/I\nCapture group count = 1\nSubject length lower bound = 15\n    abcdefghijklmnopqrstuvwxyz\n 0: abcdefghijklmno\n 1: abcdefghijklmno\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1\n 0: abcdefghijklmno\n 1: abcdefghijklmno\n 1C abcdefghijklmno (15)\n 1G abcdefghijklmno (15)\n\n/(.{16})/I\nCapture group count = 1\nSubject length lower bound = 16\n    abcdefghijklmnopqrstuvwxyz\n 0: abcdefghijklmnop\n 1: abcdefghijklmnop\n    abcdefghijklmnopqrstuvwxyz\\=copy=1,get=1,getall\n 0: abcdefghijklmnop\n 1: abcdefghijklmnop\n 1C abcdefghijklmnop (16)\n 1G abcdefghijklmnop (16)\n 0L abcdefghijklmnop\n 1L abcdefghijklmnop\n\n/^(a|(bc))de(f)/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nSubject length lower bound = 4\n    adef\\=get=1,get=2,get=3,get=4,getall\n 0: adef\n 1: a\n 2: <unset>\n 3: f\n 1G a (1)\nGet substring 2 failed (-55): requested value is not set\n 3G f (1)\nGet substring 4 failed (-49): unknown substring\n 0L adef\n 1L a\n 2L \n 3L f\n    bcdef\\=get=1,get=2,get=3,get=4,getall\n 0: bcdef\n 1: bc\n 2: bc\n 3: f\n 1G bc (2)\n 2G bc (2)\n 3G f (1)\nGet substring 4 failed (-49): unknown substring\n 0L bcdef\n 1L bc\n 2L bc\n 3L f\n    adefghijk\\=copy=0\n 0: adef\n 1: a\n 2: <unset>\n 3: f\n 0C adef (4)\n\n/^abc\\00def/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 7\n    abc\\00def\\=copy=0,getall\n 0: abc\\x00def\n 0C abc\\x00def (7)\n 0L abc\\x00def\n\n/word ((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+\n)?)?)?)?)?)?)?)?)?otherword/I\nCapture group count = 8\nContains explicit CR or LF match\nFirst code unit = 'w'\nLast code unit = 'd'\nSubject length lower bound = 14\n\n/.*X/IB\n------------------------------------------------------------------\n        Bra\n        Any*\n        X\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'X'\nSubject length lower bound = 1\n\n/.*X/IBs\n------------------------------------------------------------------\n        Bra\n        AllAny*\n        X\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'X'\nSubject length lower bound = 1\n\n/(.*X|^B)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Any*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(.*X|^B)/IBs\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        AllAny*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 1\n\n/(?s)(.*X|^B)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        AllAny*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n\n/(?s:.*X|^B)/IB\n------------------------------------------------------------------\n        Bra\n        Bra\n        AllAny*\n        X\n        Alt\n        ^\n        B\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n\n/\\Biss\\B/I,aftertext\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n\n/iss/I,aftertext,altglobal\nCapture group count = 0\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n 0: iss\n 0+ ippi\n\n/\\Biss\\B/I,aftertext,altglobal\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n\n/\\Biss\\B/Ig,aftertext\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n 0: iss\n 0+ ippi\n\\= Expect no match\n    Mississippi\\=anchored\nNo match\n\n/(?<=[Ms])iss/Ig,aftertext\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n 0: iss\n 0+ ippi\n\n/(?<=[Ms])iss/I,aftertext,altglobal\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'i'\nLast code unit = 's'\nSubject length lower bound = 3\n    Mississippi\n 0: iss\n 0+ issippi\n\n/^iss/Ig,aftertext\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'i'\nSubject length lower bound = 3\n    ississippi\n 0: iss\n 0+ issippi\n\n/.*iss/Ig,aftertext\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 's'\nSubject length lower bound = 3\n    abciss\\nxyzisspqr\n 0: abciss\n 0+ \\x0axyzisspqr\n 0: xyziss\n 0+ pqr\n\n/.i./Ig,aftertext\nCapture group count = 0\nLast code unit = 'i'\nSubject length lower bound = 3\n    Mississippi\n 0: Mis\n 0+ sissippi\n 0: sis\n 0+ sippi\n 0: sip\n 0+ pi\n    Mississippi\\=anchored\n 0: Mis\n 0+ sissippi\n 0: sis\n 0+ sippi\n 0: sip\n 0+ pi\n    Missouri river\n 0: Mis\n 0+ souri river\n 0: ri \n 0+ river\n 0: riv\n 0+ er\n    Missouri river\\=anchored\n 0: Mis\n 0+ souri river\n\n/^.is/Ig,aftertext\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 3\n    Mississippi\n 0: Mis\n 0+ sissippi\n\n/^ab\\n/Ig,aftertext\nCapture group count = 0\nContains explicit CR or LF match\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n    ab\\nab\\ncd\n 0: ab\\x0a\n 0+ ab\\x0acd\n\n/^ab\\n/Igm,aftertext\nCapture group count = 0\nContains explicit CR or LF match\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = \\x0a\nSubject length lower bound = 3\n    ab\\nab\\ncd\n 0: ab\\x0a\n 0+ ab\\x0acd\n 0: ab\\x0a\n 0+ cd\n\n/^/gm,newline=any\n    a\\rb\\nc\\r\\nxyz\\=aftertext\n 0: \n 0+ a\\x0db\\x0ac\\x0d\\x0axyz\n 0: \n 0+ b\\x0ac\\x0d\\x0axyz\n 0: \n 0+ c\\x0d\\x0axyz\n 0: \n 0+ xyz\n\n/abc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/abc|bac/I\nCapture group count = 0\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(abc|bac)/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(abc|(c|dc))/I\nCapture group count = 2\nStarting code units: a c d \nLast code unit = 'c'\nSubject length lower bound = 1\n\n/(abc|(d|de)c)/I\nCapture group count = 2\nStarting code units: a d \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/a*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/a+/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(baa|a+)/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'a'\nSubject length lower bound = 1\n\n/a{0,3}/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/baa{3,}/I\nCapture group count = 0\nFirst code unit = 'b'\nLast code unit = 'a'\nSubject length lower bound = 5\n\n/\"([^\\\\\"]+|\\\\.)*\"/I\nCapture group count = 1\nFirst code unit = '\"'\nLast code unit = '\"'\nSubject length lower bound = 2\n\n/(abc|ab[cd])/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(a|.)/I\nCapture group count = 1\nSubject length lower bound = 1\n\n/a|ba|\\w/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/abc(?=pqr)/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'r'\nSubject length lower bound = 3\n\n/...(?<=abc)/I\nCapture group count = 0\nMax lookbehind = 3\nSubject length lower bound = 3\n\n/abc(?!pqr)/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/ab./I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/ab[xyz]/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/abc*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/ab.c*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/a.c*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/.c*/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/ac*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(a.c*|b.c*)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/a.c*|aba/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/.+a/I\nCapture group count = 0\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/(?=abcda)a.*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/(?=a)a.*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/a(b)*/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/a\\d*/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/ab\\d*/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/a(\\d)*/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/abcde{0,0}/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n\n/ab\\d+/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/a(?(1)b)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/a(?(1)bag|big)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'g'\nSubject length lower bound = 5\n\n/a(?(1)bag|big)*(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/a(?(1)bag|big)+(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'g'\nSubject length lower bound = 5\n\n/a(?(1)b..|b..)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 5\n\n/ab\\d{0}e/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 3\n\n/a?b?/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    a\n 0: a\n    b\n 0: b\n    ab\n 0: ab\n    \\\n 0: \n\\= Expect no match\n    \\=notempty\nNo match\n\n/|-/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    abcd\n 0: \n    -abc\n 0: \n    ab-c\\=notempty\n 0: -\n\\= Expect no match\n    abc\\=notempty\nNo match\n\n/^.?abcd/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nLast code unit = 'd'\nSubject length lower bound = 4\n\n/\\(             # ( at start\n  (?:           # Non-capturing bracket\n  (?>[^()]+)    # Either a sequence of non-brackets (no backtracking)\n  |             # Or\n  (?R)          # Recurse - i.e. nested bracketed string\n  )*            # Zero or more contents\n  \\)            # Closing )\n  /Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (abcd)\n 0: (abcd)\n    (abcd)xyz\n 0: (abcd)\n    xyz(abcd)\n 0: (abcd)\n    (ab(xy)cd)pqr\n 0: (ab(xy)cd)\n    (ab(xycd)pqr\n 0: (xycd)\n    () abc ()\n 0: ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n 0: (abcde(fsh)xyz(foo(bar))lmno)\n\\= Expect no match\n    abcd\nNo match\n    abcd)\nNo match\n    (abcd\nNo match\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Igx\nCapture group count = 1\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)pqr\n 0: (ab(xy)cd)\n 1: cd\n    1(abcd)(x(y)z)pqr\n 0: (abcd)\n 1: abcd\n 0: (x(y)z)\n 1: z\n\n/\\(  (?: (?>[^()]+) | (?R) ) \\) /Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 3\n    (abcd)\n 0: (abcd)\n    (ab(xy)cd)\n 0: (xy)\n    (a(b(c)d)e)\n 0: (c)\n    ((ab))\n 0: ((ab))\n\\= Expect no match\n    ()\nNo match\n\n/\\(  (?: (?>[^()]+) | (?R) )? \\) /Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    ()\n 0: ()\n    12(abcde(fsh)xyz(foo(bar))lmno)89\n 0: (fsh)\n\n/\\(  ( (?>[^()]+) | (?R) )* \\) /Ix\nCapture group count = 1\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: cd\n\n/\\( ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\nCapture group count = 2\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: ab(xy)cd\n 2: cd\n\n/\\( (123)? ( ( (?>[^()]+) | (?R) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: <unset>\n 2: ab(xy)cd\n 3: cd\n    (123ab(xy)cd)\n 0: (123ab(xy)cd)\n 1: 123\n 2: ab(xy)cd\n 3: cd\n\n/\\( ( (123)? ( (?>[^()]+) | (?R) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: ab(xy)cd\n 2: <unset>\n 3: cd\n    (123ab(xy)cd)\n 0: (123ab(xy)cd)\n 1: 123ab(xy)cd\n 2: 123\n 3: cd\n\n/\\( (((((((((( ( (?>[^()]+) | (?R) )* )))))))))) \\) /Ix\nCapture group count = 11\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(xy)cd)\n 0: (ab(xy)cd)\n 1: ab(xy)cd\n 2: ab(xy)cd\n 3: ab(xy)cd\n 4: ab(xy)cd\n 5: ab(xy)cd\n 6: ab(xy)cd\n 7: ab(xy)cd\n 8: ab(xy)cd\n 9: ab(xy)cd\n10: ab(xy)cd\n11: cd\n\n/\\( ( ( (?>[^()<>]+) | ((?>[^()]+)) | (?R) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (abcd(xyz<p>qrs)123)\n 0: (abcd(xyz<p>qrs)123)\n 1: abcd(xyz<p>qrs)123\n 2: 123\n\n/\\( ( ( (?>[^()]+) | ((?R)) )* ) \\) /Ix\nCapture group count = 3\nOptions: extended\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 2\n    (ab(cd)ef)\n 0: (ab(cd)ef)\n 1: ab(cd)ef\n 2: ef\n 3: (cd)\n    (ab(cd(ef)gh)ij)\n 0: (ab(cd(ef)gh)ij)\n 1: ab(cd(ef)gh)ij\n 2: ij\n 3: (cd(ef)gh)\n\n/^[[:alnum:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9A-Za-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:^alnum:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-/:-@[-`{-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / : ; < = > \n  ? @ [ \\ ] ^ _ ` { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \n  \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \n  \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \n  \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \n  \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \n  \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \n  \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \n  \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \n  \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[[:alpha:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [A-Za-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:^alpha:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-@[-`{-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 \n  5 6 7 8 9 : ; < = > ? @ [ \\ ] ^ _ ` { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \\x84 \n  \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \n  \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \n  \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \n  \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \n  \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \n  \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \n  \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \n  \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \n  \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/[_[:alpha:]]/I\nCapture group count = 0\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:ascii:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x7f]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 \n  5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y \n  Z [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \n  \\x7f \nSubject length lower bound = 1\n\n/^[[:^ascii:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x80-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x80 \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \n  \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \n  \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \n  \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \n  \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \n  \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \n  \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \n  \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \n  \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[[:blank:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x09 ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x09 \\x20 \nSubject length lower bound = 1\n\n/^[[:^blank:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x08\\x0a-\\x1f!-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x0a \\x0b \n  \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \n  \\x1b \\x1c \\x1d \\x1e \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 \n  : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ \n  _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \n  \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \n  \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \n  \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \n  \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \n  \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \n  \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \n  \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \n  \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \n  \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/[\\n\\x0b\\x0c\\x0d[:blank:]]/I\nCapture group count = 0\nContains explicit CR or LF match\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/^[[:cntrl:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x1f\\x7f]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x7f \nSubject length lower bound = 1\n\n/^[[:digit:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 1\n\n/^[[:graph:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [!-~]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : \n  ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ \n  ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \nSubject length lower bound = 1\n\n/^[[:lower:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [a-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:print:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [ -~]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 \n  9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] \n  ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \nSubject length lower bound = 1\n\n/^[[:punct:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [!-/:-@[-`{-~]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: ! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ \n  _ ` { | } ~ \nSubject length lower bound = 1\n\n/^[[:space:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/^[[:upper:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [A-Z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \nSubject length lower bound = 1\n\n/^[[:xdigit:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9A-Fa-f]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f \nSubject length lower bound = 1\n\n/^[[:word:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [0-9A-Z_a-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/^[[:^cntrl:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [ -~\\x80-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x20 ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 \n  9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] \n  ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x80 \\x81 \n  \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \n  \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \n  \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \n  \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \n  \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \n  \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \n  \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \n  \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \n  \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[12[:^digit:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-/12:-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( ) * + , - . / 1 2 : ; < \n  = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a \n  b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \\x81 \\x82 \n  \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \n  \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \n  \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \n  \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \n  \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \n  \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \n  \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \n  \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \n  \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/^[[:^blank:]]/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\x00-\\x08\\x0a-\\x1f!-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x0a \\x0b \n  \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \n  \\x1b \\x1c \\x1d \\x1e \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 \n  : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ \n  _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \n  \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \n  \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \n  \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \n  \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \n  \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \n  \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \n  \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \n  \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \n  \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/[01[:alpha:]%]/IB\n------------------------------------------------------------------\n        Bra\n        [%01A-Za-z]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: % 0 1 A B C D E F G H I J K L M N O P Q R S T U V W \n  X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\n/[[.ch.]]/I\nFailed: error 113 at offset 1: POSIX collating elements are not supported\n\n/[[=ch=]]/I\nFailed: error 113 at offset 1: POSIX collating elements are not supported\n\n/[[:rhubarb:]]/I\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:upper:]]/Ii\nCapture group count = 0\nOptions: caseless\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n    A\n 0: A\n    a\n 0: a\n\n/[[:lower:]]/Ii\nCapture group count = 0\nOptions: caseless\nStarting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n    A\n 0: A\n    a\n 0: a\n\n/((?-i)[[:lower:]])[[:lower:]]/Ii\nCapture group count = 1\nOptions: caseless\nStarting code units: a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 2\n    ab\n 0: ab\n 1: a\n    aB\n 0: aB\n 1: a\n\\= Expect no match\n    Ab\nNo match\n    AB\nNo match\n\n/[\\200-\\110]/I\nFailed: error 108 at offset 9: range out of order in character class\n\n/^(?(0)f|b)oo/I\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n# This one's here because of the large output vector needed\n\n/(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\d+(?:\\s|$))(\\w+)\\s+(\\270)/I\nCapture group count = 271\nMax back reference = 270\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 1\n     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\\=ovector=300\n 0: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\n 1: 1 \n 2: 2 \n 3: 3 \n 4: 4 \n 5: 5 \n 6: 6 \n 7: 7 \n 8: 8 \n 9: 9 \n10: 10 \n11: 11 \n12: 12 \n13: 13 \n14: 14 \n15: 15 \n16: 16 \n17: 17 \n18: 18 \n19: 19 \n20: 20 \n21: 21 \n22: 22 \n23: 23 \n24: 24 \n25: 25 \n26: 26 \n27: 27 \n28: 28 \n29: 29 \n30: 30 \n31: 31 \n32: 32 \n33: 33 \n34: 34 \n35: 35 \n36: 36 \n37: 37 \n38: 38 \n39: 39 \n40: 40 \n41: 41 \n42: 42 \n43: 43 \n44: 44 \n45: 45 \n46: 46 \n47: 47 \n48: 48 \n49: 49 \n50: 50 \n51: 51 \n52: 52 \n53: 53 \n54: 54 \n55: 55 \n56: 56 \n57: 57 \n58: 58 \n59: 59 \n60: 60 \n61: 61 \n62: 62 \n63: 63 \n64: 64 \n65: 65 \n66: 66 \n67: 67 \n68: 68 \n69: 69 \n70: 70 \n71: 71 \n72: 72 \n73: 73 \n74: 74 \n75: 75 \n76: 76 \n77: 77 \n78: 78 \n79: 79 \n80: 80 \n81: 81 \n82: 82 \n83: 83 \n84: 84 \n85: 85 \n86: 86 \n87: 87 \n88: 88 \n89: 89 \n90: 90 \n91: 91 \n92: 92 \n93: 93 \n94: 94 \n95: 95 \n96: 96 \n97: 97 \n98: 98 \n99: 99 \n100: 100 \n101: 101 \n102: 102 \n103: 103 \n104: 104 \n105: 105 \n106: 106 \n107: 107 \n108: 108 \n109: 109 \n110: 110 \n111: 111 \n112: 112 \n113: 113 \n114: 114 \n115: 115 \n116: 116 \n117: 117 \n118: 118 \n119: 119 \n120: 120 \n121: 121 \n122: 122 \n123: 123 \n124: 124 \n125: 125 \n126: 126 \n127: 127 \n128: 128 \n129: 129 \n130: 130 \n131: 131 \n132: 132 \n133: 133 \n134: 134 \n135: 135 \n136: 136 \n137: 137 \n138: 138 \n139: 139 \n140: 140 \n141: 141 \n142: 142 \n143: 143 \n144: 144 \n145: 145 \n146: 146 \n147: 147 \n148: 148 \n149: 149 \n150: 150 \n151: 151 \n152: 152 \n153: 153 \n154: 154 \n155: 155 \n156: 156 \n157: 157 \n158: 158 \n159: 159 \n160: 160 \n161: 161 \n162: 162 \n163: 163 \n164: 164 \n165: 165 \n166: 166 \n167: 167 \n168: 168 \n169: 169 \n170: 170 \n171: 171 \n172: 172 \n173: 173 \n174: 174 \n175: 175 \n176: 176 \n177: 177 \n178: 178 \n179: 179 \n180: 180 \n181: 181 \n182: 182 \n183: 183 \n184: 184 \n185: 185 \n186: 186 \n187: 187 \n188: 188 \n189: 189 \n190: 190 \n191: 191 \n192: 192 \n193: 193 \n194: 194 \n195: 195 \n196: 196 \n197: 197 \n198: 198 \n199: 199 \n200: 200 \n201: 201 \n202: 202 \n203: 203 \n204: 204 \n205: 205 \n206: 206 \n207: 207 \n208: 208 \n209: 209 \n210: 210 \n211: 211 \n212: 212 \n213: 213 \n214: 214 \n215: 215 \n216: 216 \n217: 217 \n218: 218 \n219: 219 \n220: 220 \n221: 221 \n222: 222 \n223: 223 \n224: 224 \n225: 225 \n226: 226 \n227: 227 \n228: 228 \n229: 229 \n230: 230 \n231: 231 \n232: 232 \n233: 233 \n234: 234 \n235: 235 \n236: 236 \n237: 237 \n238: 238 \n239: 239 \n240: 240 \n241: 241 \n242: 242 \n243: 243 \n244: 244 \n245: 245 \n246: 246 \n247: 247 \n248: 248 \n249: 249 \n250: 250 \n251: 251 \n252: 252 \n253: 253 \n254: 254 \n255: 255 \n256: 256 \n257: 257 \n258: 258 \n259: 259 \n260: 260 \n261: 261 \n262: 262 \n263: 263 \n264: 264 \n265: 265 \n266: 266 \n267: 267 \n268: 268 \n269: 269 \n270: ABC\n271: ABC\n\n# This one's here because Perl does this differently and PCRE2 can't at present\n\n/(main(O)?)+/I\nCapture group count = 2\nFirst code unit = 'm'\nLast code unit = 'n'\nSubject length lower bound = 4\n    mainmain\n 0: mainmain\n 1: main\n    mainOmain\n 0: mainOmain\n 1: main\n 2: O\n\n# These are all cases where Perl does it differently (nested captures)\n\n/^(a(b)?)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 1\n    aba\n 0: aba\n 1: a\n 2: b\n\n/^(aa(bb)?)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n\n/^(aa|aa(bb))+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n\n/^(aa(bb)??)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n\n/^(?:aa(bb)?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: bb\n\n/^(aa(b(b))?)+$/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: aa\n 2: bb\n 3: b\n\n/^(?:aa(b(b))?)+$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: bb\n 2: b\n\n/^(?:aa(b(?:b))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: bb\n\n/^(?:aa(bb(?:b))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: bbb\n\n/^(?:aa(b(?:bb))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: bbb\n\n/^(?:aa(?:b(b))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbaa\n 0: aabbaa\n 1: b\n\n/^(?:aa(?:b(bb))?)+$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: bb\n\n/^(aa(b(bb))?)+$/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbaa\n 0: aabbbaa\n 1: aa\n 2: bbb\n 3: bb\n\n/^(aa(bb(bb))?)+$/I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n    aabbbbaa\n 0: aabbbbaa\n 1: aa\n 2: bbbb\n 3: bb\n\n# ----------------\n\n/#/IBx\n------------------------------------------------------------------\n        Bra\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nOptions: extended\nSubject length lower bound = 0\n\n/a#/IBx\n------------------------------------------------------------------\n        Bra\n        a\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/[\\s]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/[\\S]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x00-\\x08\\x0e-\\x1f!-\\xff] (neg)\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x0e \\x0f \n  \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \\x1b \\x1c \\x1d \\x1e \n  \\x1f ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C \n  D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a b c d e f g h \n  i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \\x80 \\x81 \\x82 \\x83 \\x84 \n  \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \\x8f \\x90 \\x91 \\x92 \\x93 \n  \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \\x9e \\x9f \\xa0 \\xa1 \\xa2 \n  \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \\xad \\xae \\xaf \\xb0 \\xb1 \n  \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \\xbc \\xbd \\xbe \\xbf \\xc0 \n  \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \\xcb \\xcc \\xcd \\xce \\xcf \n  \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \\xda \\xdb \\xdc \\xdd \\xde \n  \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \\xe9 \\xea \\xeb \\xec \\xed \n  \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \\xf8 \\xf9 \\xfa \\xfb \\xfc \n  \\xfd \\xfe \\xff \nSubject length lower bound = 1\n\n/a(?i)b/IB\n------------------------------------------------------------------\n        Bra\n        a\n     /i b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b' (caseless)\nSubject length lower bound = 2\n    ab\n 0: ab\n    aB\n 0: aB\n\\= Expect no match\n    AB\nNo match\n\n/(a(?i)b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n     /i b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b' (caseless)\nSubject length lower bound = 2\n    ab\n 0: ab\n 1: ab\n    aB\n 0: aB\n 1: aB\n\\= Expect no match\n    AB\nNo match\n\n/   (?i)abc/IBx\n------------------------------------------------------------------\n        Bra\n     /i abc\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/#this is a comment\n  (?i)abc/IBx\n------------------------------------------------------------------\n        Bra\n     /i abc\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n------------------------------------------------------------------\n        Bra\n        123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = '1'\nLast code unit = '0'\nSubject length lower bound = 300\n\n/\\Q123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB\n------------------------------------------------------------------\n        Bra\n        123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = '1'\nLast code unit = '0'\nSubject length lower bound = 300\n\n/\\Q\\E/IB\n------------------------------------------------------------------\n        Bra\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    \\\n 0: \n\n/\\Q\\Ex/IB\n------------------------------------------------------------------\n        Bra\n        x\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nSubject length lower bound = 1\n\n/ \\Q\\E/IB\n------------------------------------------------------------------\n        Bra\n         \n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = ' '\nSubject length lower bound = 1\n\n/a\\Q\\E/IB\n------------------------------------------------------------------\n        Bra\n        a\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n  abc\n 0: a\n  bca\n 0: a\n  bac\n 0: a\n\n/a\\Q\\Eb/IB\n------------------------------------------------------------------\n        Bra\n        ab\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n  abc\n 0: ab\n\n/\\Q\\Eabc/IB\n------------------------------------------------------------------\n        Bra\n        abc\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/x*+\\w/IB\n------------------------------------------------------------------\n        Bra\n        x*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nSubject length lower bound = 1\n\\= Expect no match\n    xxxxx\nNo match\n\n/x?+/IB\n------------------------------------------------------------------\n        Bra\n        x?+\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/x++/IB\n------------------------------------------------------------------\n        Bra\n        x++\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nSubject length lower bound = 1\n\n/x{1,3}+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        x\n        x{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/x{1,3}+/Bi,no_auto_possess\n------------------------------------------------------------------\n        Bra\n     /i x\n     /i x{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^x]{1,3}+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        [^x]\n        [^x]{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^x]{1,3}+/Bi,no_auto_possess\n------------------------------------------------------------------\n        Bra\n     /i [^x]\n     /i [^x]{0,2}+\n        Ket\n        End\n------------------------------------------------------------------\n\n/(x)*+/IB\n------------------------------------------------------------------\n        Bra\n        Braposzero\n        CBraPos 1\n        x\n        KetRpos\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/^(\\w++|\\s++)*$/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n    now is the time for all good men to come to the aid of the party\n 0: now is the time for all good men to come to the aid of the party\n 1: party\n\\= Expect no match\n    this is not a line with only words and spaces!\nNo match\n\n/(\\d++)(\\w)/I\nCapture group count = 2\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 2\n    12345a\n 0: 12345a\n 1: 12345\n 2: a\n\\= Expect no match\n    12345+\nNo match\n\n/a++b/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    aaab\n 0: aaab\n\n/(a++b)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    aaab\n 0: aaab\n 1: aaab\n\n/(a++)b/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    aaab\n 0: aaab\n 1: aaa\n\n/([^()]++|\\([^()]*\\))+/I\nCapture group count = 1\nStarting code units: \\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\x09 \\x0a \n  \\x0b \\x0c \\x0d \\x0e \\x0f \\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \n  \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f \\x20 ! \" # $ % & ' ( * + , - . / 0 1 2 3 4 5 \n  6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n  [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \\x7f \n  \\x80 \\x81 \\x82 \\x83 \\x84 \\x85 \\x86 \\x87 \\x88 \\x89 \\x8a \\x8b \\x8c \\x8d \\x8e \n  \\x8f \\x90 \\x91 \\x92 \\x93 \\x94 \\x95 \\x96 \\x97 \\x98 \\x99 \\x9a \\x9b \\x9c \\x9d \n  \\x9e \\x9f \\xa0 \\xa1 \\xa2 \\xa3 \\xa4 \\xa5 \\xa6 \\xa7 \\xa8 \\xa9 \\xaa \\xab \\xac \n  \\xad \\xae \\xaf \\xb0 \\xb1 \\xb2 \\xb3 \\xb4 \\xb5 \\xb6 \\xb7 \\xb8 \\xb9 \\xba \\xbb \n  \\xbc \\xbd \\xbe \\xbf \\xc0 \\xc1 \\xc2 \\xc3 \\xc4 \\xc5 \\xc6 \\xc7 \\xc8 \\xc9 \\xca \n  \\xcb \\xcc \\xcd \\xce \\xcf \\xd0 \\xd1 \\xd2 \\xd3 \\xd4 \\xd5 \\xd6 \\xd7 \\xd8 \\xd9 \n  \\xda \\xdb \\xdc \\xdd \\xde \\xdf \\xe0 \\xe1 \\xe2 \\xe3 \\xe4 \\xe5 \\xe6 \\xe7 \\xe8 \n  \\xe9 \\xea \\xeb \\xec \\xed \\xee \\xef \\xf0 \\xf1 \\xf2 \\xf3 \\xf4 \\xf5 \\xf6 \\xf7 \n  \\xf8 \\xf9 \\xfa \\xfb \\xfc \\xfd \\xfe \\xff \nSubject length lower bound = 1\n    ((abc(ade)ufh()()x\n 0: abc(ade)ufh()()x\n 1: x\n\n/\\(([^()]++|\\([^()]+\\))+\\)/I\nCapture group count = 1\nFirst code unit = '('\nLast code unit = ')'\nSubject length lower bound = 3\n    (abc)\n 0: (abc)\n 1: abc\n    (abc(def)xyz)\n 0: (abc(def)xyz)\n 1: xyz\n\\= Expect no match\n    ((()aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nNo match\n\n/(abc){1,3}+/IB\n------------------------------------------------------------------\n        Bra\n        Once\n        CBra 1\n        abc\n        Ket\n        Brazero\n        Bra\n        CBra 1\n        abc\n        Ket\n        Brazero\n        CBra 1\n        abc\n        Ket\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/a+?+/I\nFailed: error 109 at offset 3: quantifier does not follow a repeatable item\n\n/a{2,3}?+b/I\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/(?U)a+?+/I\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/a{2,3}?+b/I,ungreedy\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/x(?U)a++b/IB\n------------------------------------------------------------------\n        Bra\n        x\n        a++\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n    xaaaab\n 0: xaaaab\n\n/(?U)xa++b/IB\n------------------------------------------------------------------\n        Bra\n        x\n        a++\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n    xaaaab\n 0: xaaaab\n\n/^((a+)(?U)([ab]+)(?-U)([bc]+)(\\w*))/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        CBra 2\n        a+\n        Ket\n        CBra 3\n        [ab]+?\n        Ket\n        CBra 4\n        [bc]+\n        Ket\n        CBra 5\n        \\w*+\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 5\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/^x(?U)a+b/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        x\n        a++\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/^x(?U)(a+)b/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        x\n        CBra 1\n        a+?\n        Ket\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'x'\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/[.x.]/I\nFailed: error 113 at offset 0: POSIX collating elements are not supported\n\n/[=x=]/I\nFailed: error 113 at offset 0: POSIX collating elements are not supported\n\n/[:x:]/I\nFailed: error 112 at offset 0: POSIX named classes are supported only within a class\n\n/\\F/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\l/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\L/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\N{name}/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\u/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/\\U/I\nFailed: error 137 at offset 2: PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\n\n/a{1,3}b/ungreedy\n    ab\n 0: ab\n\n/[/I\nFailed: error 106 at offset 1: missing terminating ] for character class\n\n/[a-/I\nFailed: error 106 at offset 3: missing terminating ] for character class\n\n/[[:space:]/I\nFailed: error 106 at offset 10: missing terminating ] for character class\n\n/[\\s]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/[[:space:]]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d ]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 \nSubject length lower bound = 1\n\n/[[:space:]abcde]/IB\n------------------------------------------------------------------\n        Bra\n        [\\x09-\\x0d a-e]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 a b c d e \nSubject length lower bound = 1\n\n/< (?: (?(R) \\d++  | [^<>]*+) | (?R)) * >/Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    <>\n 0: <>\n    <abcd>\n 0: <abcd>\n    <abc <123> hij>\n 0: <abc <123> hij>\n    <abc <def> hij>\n 0: <def>\n    <abc<>def>\n 0: <abc<>def>\n    <abc<>\n 0: <>\n\\= Expect no match\n    <abc\nNo match\n\n/8J\\$WE\\<\\.rX\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n------------------------------------------------------------------\n        Bra\n        8J$WE<.rX+ix[d1b!H#?vV0vrK:ZH1=2M>iV;?aPhFB<*vW@QW@sO9}cfZA-i'w%hKd6gt1UJP,15_#QY$M^Mss_U/]&LK9[5vQub^w[KDD<EjmhUZ?.akp2dF>qmj;2}YWFdYx.Ap]hjCPTP(n28k+3;o&WXqs/gOXdr$:r'do0;b4c(f_Gr=\"\\4)[01T7ajQJvL$W~mL_sS/4h:x*[ZN=KLs&L5zX//>it,o:aU(;Z>pW&T7oP'2K^E:x9'c[%z-,64JQ5AeH_G#KijUKghQw^\\vea3a?kka_G$8#`*kynsxzBLru']k_[7FrVx}^=$blx>s-N%j;D*aZDnsw:YKZ%Q.Kne9#hP?+b3(SOvL,^;&u5@?5C5Bhb=m-vEh_L15Jl]U)0RP6{q%L^_z5E'Dw6X\n        \\b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = '8'\nLast code unit = 'X'\nSubject length lower bound = 409\n\n/\\$\\<\\.X\\+ix\\[d1b\\!H\\#\\?vV0vrK\\:ZH1\\=2M\\>iV\\;\\?aPhFB\\<\\*vW\\@QW\\@sO9\\}cfZA\\-i\\'w\\%hKd6gt1UJP\\,15_\\#QY\\$M\\^Mss_U\\/\\]\\&LK9\\[5vQub\\^w\\[KDD\\<EjmhUZ\\?\\.akp2dF\\>qmj\\;2\\}YWFdYx\\.Ap\\]hjCPTP\\(n28k\\+3\\;o\\&WXqs\\/gOXdr\\$\\:r\\'do0\\;b4c\\(f_Gr\\=\\\"\\\\4\\)\\[01T7ajQJvL\\$W\\~mL_sS\\/4h\\:x\\*\\[ZN\\=KLs\\&L5zX\\/\\/\\>it\\,o\\:aU\\(\\;Z\\>pW\\&T7oP\\'2K\\^E\\:x9\\'c\\[\\%z\\-\\,64JQ5AeH_G\\#KijUKghQw\\^\\\\vea3a\\?kka_G\\$8\\#\\`\\*kynsxzBLru\\'\\]k_\\[7FrVx\\}\\^\\=\\$blx\\>s\\-N\\%j\\;D\\*aZDnsw\\:YKZ\\%Q\\.Kne9\\#hP\\?\\+b3\\(SOvL\\,\\^\\;\\&u5\\@\\?5C5Bhb\\=m\\-vEh_L15Jl\\]U\\)0RP6\\{q\\%L\\^_z5E\\'Dw6X\\b/IB\n------------------------------------------------------------------\n        Bra\n        $<.X+ix[d1b!H#?vV0vrK:ZH1=2M>iV;?aPhFB<*vW@QW@sO9}cfZA-i'w%hKd6gt1UJP,15_#QY$M^Mss_U/]&LK9[5vQub^w[KDD<EjmhUZ?.akp2dF>qmj;2}YWFdYx.Ap]hjCPTP(n28k+3;o&WXqs/gOXdr$:r'do0;b4c(f_Gr=\"\\4)[01T7ajQJvL$W~mL_sS/4h:x*[ZN=KLs&L5zX//>it,o:aU(;Z>pW&T7oP'2K^E:x9'c[%z-,64JQ5AeH_G#KijUKghQw^\\vea3a?kka_G$8#`*kynsxzBLru']k_[7FrVx}^=$blx>s-N%j;D*aZDnsw:YKZ%Q.Kne9#hP?+b3(SOvL,^;&u5@?5C5Bhb=m-vEh_L15Jl]U)0RP6{q%L^_z5E'Dw6X\n        \\b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = '$'\nLast code unit = 'X'\nSubject length lower bound = 404\n\n/(.*)\\d+\\1/I\nCapture group count = 1\nMax back reference = 1\nSubject length lower bound = 1\n\n/(.*)\\d+/I\nCapture group count = 1\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\n/(.*)\\d+\\1/Is\nCapture group count = 1\nMax back reference = 1\nOptions: dotall\nSubject length lower bound = 1\n\n/(.*)\\d+/Is\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 1\n\n/(.*(xyz))\\d+\\2/I\nCapture group count = 2\nMax back reference = 2\nFirst code unit at start or follows newline\nLast code unit = 'z'\nSubject length lower bound = 7\n\n/((.*))\\d+\\1/I\nCapture group count = 2\nMax back reference = 1\nSubject length lower bound = 1\n    abc123bc\n 0: bc123bc\n 1: bc\n 2: bc\n\n/a[b]/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?=a).*/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?=abc).xyz/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nLast code unit = 'z' (caseless)\nSubject length lower bound = 4\n\n/(?=abc)(?i).xyz/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'z' (caseless)\nSubject length lower bound = 4\n\n/(?=a)(?=b)/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?=.)a/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=abcda)a)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/((?=abcda)ab)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/()a/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?:(?=.)|(?<!x))a/I\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?(1)ab|ac)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(?(1)abz|acz)(.)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(?(1)abz)(.)/I\nCapture group count = 1\nMax back reference = 1\nSubject length lower bound = 1\n\n/(?(1)abz)(1)23/I\nCapture group count = 1\nMax back reference = 1\nLast code unit = '3'\nSubject length lower bound = 3\n\n/(a)+/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(a){2,3}/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 2\n\n/(a)*/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/[a]/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/[ab]/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/[ab]/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/[^a]/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/\\d456/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '6'\nSubject length lower bound = 4\n\n/\\d456/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '6'\nSubject length lower bound = 4\n\n/a^b/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'a'\nSubject length lower bound = 1\n  abcde\n 0: a\n  xy\\nabc\n 0: a\n\\= Expect no match\n  xyabc\nNo match\n\n/c|abc/I\nCapture group count = 0\nStarting code units: a c \nLast code unit = 'c'\nSubject length lower bound = 1\n\n/(?i)[ab]/I\nCapture group count = 0\nStarting code units: A B a b \nSubject length lower bound = 1\n\n/[ab](?i)cd/I\nCapture group count = 0\nStarting code units: a b \nLast code unit = 'd' (caseless)\nSubject length lower bound = 3\n\n/abc(?C)def/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    abcdef\n--->abcdef\n  0 ^  ^       d\n 0: abcdef\n    1234abcdef\n--->1234abcdef\n  0     ^  ^       d\n 0: abcdef\n\\= Expect no match\n    abcxyz\nNo match\n    abcxyzf\n--->abcxyzf\n  0 ^  ^        d\nNo match\n\n/abc(?C)de(?C1)f/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    123abcdef\n--->123abcdef\n  0    ^  ^       d\n  1    ^    ^     f\n 0: abcdef\n\n/(?C1)\\dabc(?C2)def/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'f'\nSubject length lower bound = 7\n    1234abcdef\n--->1234abcdef\n  1 ^              \\d\n  1  ^             \\d\n  1   ^            \\d\n  1    ^           \\d\n  2    ^   ^       d\n 0: 4abcdef\n\\= Expect no match\n    abcdef\nNo match\n\n/(?C1)\\dabc(?C2)def/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'f'\nSubject length lower bound = 7\n    1234abcdef\n--->1234abcdef\n  1 ^              \\d\n  1  ^             \\d\n  1   ^            \\d\n  1    ^           \\d\n  2    ^   ^       d\n 0: 4abcdef\n\\= Expect no match\n    abcdef\nNo match\n\n/(?C255)ab/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?C256)ab/I\nFailed: error 138 at offset 6: number after (?C is greater than 255\n\n/(?Cab)xx/I\nFailed: error 182 at offset 3: unrecognized string delimiter follows (?C\n\n/(?C12vr)x/I\nFailed: error 139 at offset 5: closing parenthesis for (?C expected\n\n/abc(?C)def/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    \\x83\\x0\\x61bcdef\n--->\\x83\\x00abcdef\n  0         ^  ^       d\n 0: abcdef\n\n/(abc)(?C)de(?C1)f/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    123abcdef\n--->123abcdef\n  0    ^  ^       d\n  1    ^    ^     f\n 0: abcdef\n 1: abc\n    123abcdef\\=callout_capture\nCallout 0: last capture = 1\n 1: abc\n--->123abcdef\n       ^  ^       d\nCallout 1: last capture = 1\n 1: abc\n--->123abcdef\n       ^    ^     f\n 0: abcdef\n 1: abc\n    123abcdefC-\\=callout_none\n 0: abcdef\n 1: abc\n\\= Expect no match\n    123abcdef\\=callout_fail=1\n--->123abcdef\n  0    ^  ^       d\n  1    ^    ^     f\nNo match\n\n/(?C0)(abc(?C1))*/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n    abcabcabc\n--->abcabcabc\n  0 ^             (\n  1 ^  ^          )*\n  1 ^     ^       )*\n  1 ^        ^    )*\n 0: abcabcabc\n 1: abc\n    abcabc\\=callout_fail=1:4\n--->abcabc\n  0 ^          (\n  1 ^  ^       )*\n  1 ^     ^    )*\n 0: abcabc\n 1: abc\n    abcabcabc\\=callout_fail=1:4\n--->abcabcabc\n  0 ^             (\n  1 ^  ^          )*\n  1 ^     ^       )*\n  1 ^        ^    )*\n 0: abcabc\n 1: abc\n\n/(\\d{3}(?C))*/I\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n    123\\=callout_capture\nCallout 0: last capture = 0\n--->123\n    ^  ^    )*\n 0: 123\n 1: 123\n    123456\\=callout_capture\nCallout 0: last capture = 0\n--->123456\n    ^  ^       )*\nCallout 0: last capture = 1\n 1: 123\n--->123456\n    ^     ^    )*\n 0: 123456\n 1: 456\n    123456789\\=callout_capture\nCallout 0: last capture = 0\n--->123456789\n    ^  ^          )*\nCallout 0: last capture = 1\n 1: 123\n--->123456789\n    ^     ^       )*\nCallout 0: last capture = 1\n 1: 456\n--->123456789\n    ^        ^    )*\n 0: 123456789\n 1: 789\n\n/((xyz)(?C)p|(?C1)xyzabc)/I\nCapture group count = 2\nFirst code unit = 'x'\nSubject length lower bound = 4\n    xyzabc\\=callout_capture\nCallout 0: last capture = 2\n 1: <unset>\n 2: xyz\n--->xyzabc\n    ^  ^       p\nCallout 1: last capture = 0\n--->xyzabc\n    ^          x\n 0: xyzabc\n 1: xyzabc\n\n/(X)((xyz)(?C)p|(?C1)xyzabc)/I\nCapture group count = 3\nFirst code unit = 'X'\nLast code unit = 'x'\nSubject length lower bound = 5\n    Xxyzabc\\=callout_capture\nCallout 0: last capture = 3\n 1: X\n 2: <unset>\n 3: xyz\n--->Xxyzabc\n    ^   ^       p\nCallout 1: last capture = 1\n 1: X\n--->Xxyzabc\n    ^^          x\n 0: Xxyzabc\n 1: X\n 2: xyzabc\n\n/(?=(abc))(?C)abcdef/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n    abcdef\\=callout_capture\nCallout 0: last capture = 1\n 1: abc\n--->abcdef\n    ^          a\n 0: abcdef\n 1: abc\n\n/(?!(abc)(?C1)d)(?C2)abcxyz/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 6\n    abcxyz\\=callout_capture\nCallout 1: last capture = 1\n 1: abc\n--->abcxyz\n    ^  ^       d\nCallout 2: last capture = 0\n--->abcxyz\n    ^          a\n 0: abcxyz\n\n/(?<=(abc)(?C))xyz/I\nCapture group count = 1\nMax lookbehind = 3\nFirst code unit = 'x'\nLast code unit = 'z'\nSubject length lower bound = 3\n   abcxyz\\=callout_capture\nCallout 0: last capture = 1\n 1: abc\n--->abcxyz\n       ^       )\n 0: xyz\n 1: abc\n\n/a(b+)(c*)(?C1)/I\nCapture group count = 2\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n--->abbbbbccc\n  1 ^        ^    End of pattern\nCallout data = 1\nNo match\n\n/a(b+?)(c*?)(?C1)/I\nCapture group count = 2\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\\= Expect no match\n    abbbbbccc\\=callout_data=1\n--->abbbbbccc\n  1 ^ ^           End of pattern\nCallout data = 1\n  1 ^  ^          End of pattern\nCallout data = 1\n  1 ^   ^         End of pattern\nCallout data = 1\n  1 ^    ^        End of pattern\nCallout data = 1\n  1 ^     ^       End of pattern\nCallout data = 1\n  1 ^      ^      End of pattern\nCallout data = 1\n  1 ^       ^     End of pattern\nCallout data = 1\n  1 ^        ^    End of pattern\nCallout data = 1\nNo match\n\n/(?C)abc/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?C)^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(?C)a|b/I\nCapture group count = 0\nStarting code units: a b \nSubject length lower bound = 1\n\n/a|(b)(?C)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 1\n    b\n--->b\n  0 ^^    End of pattern\n 0: b\n 1: b\n\n/x(ab|(bc|(de|(?R))))/I\nCapture group count = 3\nFirst code unit = 'x'\nSubject length lower bound = 3\n    xab\n 0: xab\n 1: ab\n    xbc\n 0: xbc\n 1: bc\n 2: bc\n    xde\n 0: xde\n 1: de\n 2: de\n 3: de\n    xxab\n 0: xxab\n 1: xab\n 2: xab\n 3: xab\n    xxxab\n 0: xxxab\n 1: xxab\n 2: xxab\n 3: xxab\n\\= Expect no match\n    xyab\nNo match\n\n/^([^()]|\\((?1)*\\))*$/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n    abc\n 0: abc\n 1: c\n    a(b)c\n 0: a(b)c\n 1: c\n    a(b(c))d\n 0: a(b(c))d\n 1: d\n\\= Expect no match)\n    a(b(c)d\nNo match\n\n/^>abc>([^()]|\\((?1)*\\))*<xyz<$/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = '>'\nLast code unit = '<'\nSubject length lower bound = 10\n   >abc>123<xyz<\n 0: >abc>123<xyz<\n 1: 3\n   >abc>1(2)3<xyz<\n 0: >abc>1(2)3<xyz<\n 1: 3\n   >abc>(1(2)3)<xyz<\n 0: >abc>(1(2)3)<xyz<\n 1: (1(2)3)\n\n/(a(?1)b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Recurse\n        b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(a(?1)+b)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        SBra\n        Recurse\n        KetRmax\n        b\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^(\\d+|\\((?1)([+*-])(?1)\\)|-(?1))$/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nStarting code units: ( - 0 1 2 3 4 5 6 7 8 9 \nSubject length lower bound = 1\n    12\n 0: 12\n 1: 12\n    (((2+2)*-3)-7)\n 0: (((2+2)*-3)-7)\n 1: (((2+2)*-3)-7)\n 2: -\n    -12\n 0: -12\n 1: -12\n\\= Expect no match\n    ((2+2)*-3)-7)\nNo match\n\n/^(x(y|(?1){2})z)/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'x'\nSubject length lower bound = 3\n    xyz\n 0: xyz\n 1: xyz\n 2: y\n    xxyzxyzz\n 0: xxyzxyzz\n 1: xxyzxyzz\n 2: xyzxyz\n\\= Expect no match\n    xxyzz\nNo match\n    xxyzxyzxyzz\nNo match\n\n/((< (?: (?(R) \\d++  | [^<>]*+) | (?2)) * >))/Ix\nCapture group count = 2\nOptions: extended\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 2\n    <>\n 0: <>\n 1: <>\n 2: <>\n    <abcd>\n 0: <abcd>\n 1: <abcd>\n 2: <abcd>\n    <abc <123> hij>\n 0: <abc <123> hij>\n 1: <abc <123> hij>\n 2: <abc <123> hij>\n    <abc <def> hij>\n 0: <def>\n 1: <def>\n 2: <def>\n    <abc<>def>\n 0: <abc<>def>\n 1: <abc<>def>\n 2: <abc<>def>\n    <abc<>\n 0: <>\n 1: <>\n 2: <>\n\\= Expect no match\n    <abc\nNo match\n\n/(?1)/I\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/((?2)(abc)/I\nFailed: error 114 at offset 10: missing closing parenthesis\n\n/^(abc)def(?1)/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 9\n    abcdefabc\n 0: abcdefabc\n 1: abc\n\n/^(a|b|c)=(?1)+/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b c \nSubject length lower bound = 2\n    a=a\n 0: a=a\n 1: a\n    a=b\n 0: a=b\n 1: a\n    a=bc\n 0: a=bc\n 1: a\n\n/^(a|b|c)=((?1))+/I\nCapture group count = 2\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b c \nSubject length lower bound = 2\n    a=a\n 0: a=a\n 1: a\n 2: a\n    a=b\n 0: a=b\n 1: a\n 2: b\n    a=bc\n 0: a=bc\n 1: a\n 2: c\n\n/a(?P<name1>b|c)d(?P<longername2>e)/IB\n------------------------------------------------------------------\n        Bra\n        a\n        CBra 1\n        b\n        Alt\n        c\n        Ket\n        d\n        CBra 2\n        e\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nNamed capture groups:\n  longername2   2\n  name1         1\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 4\n    abde\n 0: abde\n 1: b\n 2: e\n    acde\n 0: acde\n 1: c\n 2: e\n\n/(?:a(?P<c>c(?P<d>d)))(?P<a>a)/IB\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        CBra 1\n        c\n        CBra 2\n        d\n        Ket\n        Ket\n        Ket\n        CBra 3\n        a\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 3\nNamed capture groups:\n  a   3\n  c   1\n  d   2\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 4\n\n/(?P<a>a)...(?P=a)bbb(?P>a)d/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        Any\n        Any\n        Any\n        \\1\n        bbb\n        Recurse\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  a   1\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 10\n\n/^\\W*(?:(?P<one>(?P<two>.)\\W*(?P>one)\\W*(?P=two)|)|(?P<three>(?P<four>.)\\W*(?P>three)\\W*(?P=four)|\\W*.\\W*))\\W*$/Ii\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  four    4\n  one     1\n  three   3\n  two     2\nMay match empty string\nCompile options: caseless\nOverall options: anchored caseless\nSubject length lower bound = 0\n    1221\n 0: 1221\n 1: 1221\n 2: 1\n    Satan, oscillate my metallic sonatas!\n 0: Satan, oscillate my metallic sonatas!\n 1: <unset>\n 2: <unset>\n 3: Satan, oscillate my metallic sonatas\n 4: S\n    A man, a plan, a canal: Panama!\n 0: A man, a plan, a canal: Panama!\n 1: <unset>\n 2: <unset>\n 3: A man, a plan, a canal: Panama\n 4: A\n    Able was I ere I saw Elba.\n 0: Able was I ere I saw Elba.\n 1: <unset>\n 2: <unset>\n 3: Able was I ere I saw Elba\n 4: A\n\\= Expect no match\n    The quick brown fox\nNo match\n\n/((?(R)a|b))\\1(?1)?/I\nCapture group count = 1\nMax back reference = 1\nSubject length lower bound = 2\n  bb\n 0: bb\n 1: b\n  bbaa\n 0: bba\n 1: b\n\n/(.*)a/Is\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/(.*)a\\1/Is\nCapture group count = 1\nMax back reference = 1\nOptions: dotall\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/(.*)a(b)\\2/Is\nCapture group count = 2\nMax back reference = 2\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'b'\nSubject length lower bound = 3\n\n/((.*)a|(.*)b)z/Is\nCapture group count = 3\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/((.*)a|(.*)b)z\\1/Is\nCapture group count = 3\nMax back reference = 1\nOptions: dotall\nLast code unit = 'z'\nSubject length lower bound = 3\n\n/((.*)a|(.*)b)z\\2/Is\nCapture group count = 3\nMax back reference = 2\nOptions: dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/((.*)a|(.*)b)z\\3/Is\nCapture group count = 3\nMax back reference = 3\nOptions: dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/((.*)a|^(.*)b)z\\3/Is\nCapture group count = 3\nMax back reference = 3\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'z'\nSubject length lower bound = 2\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a/Is\nCapture group count = 31\nMay match empty string\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 0\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\31/Is\nCapture group count = 31\nMax back reference = 31\nMay match empty string\nOptions: dotall\nSubject length lower bound = 0\n\n/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\\32/Is\nCapture group count = 32\nMax back reference = 32\nMay match empty string\nOptions: dotall\nSubject length lower bound = 0\n\n/(a)(bc)/IB,no_auto_capture\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        Ket\n        Bra\n        bc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: no_auto_capture\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n  abc\n 0: abc\n\n/(?P<one>a)(bc)/IB,no_auto_capture\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        Bra\n        bc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nNamed capture groups:\n  one   1\nOptions: no_auto_capture\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n  abc\n 0: abc\n 1: a\n\n/(a)(?P<named>bc)/IB,no_auto_capture\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        Ket\n        CBra 1\n        bc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nNamed capture groups:\n  named   1\nOptions: no_auto_capture\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(aaa(?C1)bbb|ab)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n   aaabbb\n--->aaabbb\n  1 ^  ^       b\n 0: aaabbb\n 1: aaabbb\n   aaabbb\\=callout_data=0\n--->aaabbb\n  1 ^  ^       b\n 0: aaabbb\n 1: aaabbb\n   aaabbb\\=callout_data=1\n--->aaabbb\n  1 ^  ^       b\nCallout data = 1\n 0: ab\n 1: ab\n\\= Expect no match\n   aaabbb\\=callout_data=-1\n--->aaabbb\n  1 ^  ^       b\nCallout data = -1\nNo match\n\n/ab(?P<one>cd)ef(?P<two>gh)/I\nCapture group count = 2\nNamed capture groups:\n  one   1\n  two   2\nFirst code unit = 'a'\nLast code unit = 'h'\nSubject length lower bound = 8\n    abcdefgh\n 0: abcdefgh\n 1: cd\n 2: gh\n    abcdefgh\\=copy=1,get=two\n 0: abcdefgh\n 1: cd\n 2: gh\n 1C cd (2)\n  G gh (2) two (group 2)\n    abcdefgh\\=copy=one,copy=two\n 0: abcdefgh\n 1: cd\n 2: gh\n  C cd (2) one (group 1)\n  C gh (2) two (group 2)\n    abcdefgh\\=copy=three\n 0: abcdefgh\n 1: cd\n 2: gh\nNumber not found for group 'three'\nCopy substring 'three' failed (-49): unknown substring\n\n/(?P<Tes>)(?P<Test>)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        CBra 2\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nNamed capture groups:\n  Tes    1\n  Test   2\nMay match empty string\nSubject length lower bound = 0\n\n/(?P<Test>)(?P<Tes>)/IB\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        CBra 2\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nNamed capture groups:\n  Tes    2\n  Test   1\nMay match empty string\nSubject length lower bound = 0\n\n/(?P<Z>zz)(?P<A>aa)/I\nCapture group count = 2\nNamed capture groups:\n  A   2\n  Z   1\nFirst code unit = 'z'\nLast code unit = 'a'\nSubject length lower bound = 4\n    zzaa\\=copy=Z\n 0: zzaa\n 1: zz\n 2: aa\n  C zz (2) Z (group 1)\n    zzaa\\=copy=A\n 0: zzaa\n 1: zz\n 2: aa\n  C aa (2) A (group 2)\n\n/(?P<x>eks)(?P<x>eccs)/I\nFailed: error 143 at offset 16: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n/(?P<abc>abc(?P<def>def)(?P<abc>xyz))/I\nFailed: error 143 at offset 31: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)\\]\"I\nCapture group count = 3\nNamed capture groups:\n  elem   2\nFirst code unit = '['\nLast code unit = ']'\nSubject length lower bound = 3\n    [10,20,30,5,5,4,4,2,43,23,4234]\n 0: [10,20,30,5,5,4,4,2,43,23,4234]\n 1: 10,20,30,5,5,4,4,2,43,23,4234\n 2: 10\n 3: ,4234\n\\= Expect no match\n    []\nNo match\n\n\"\\[((?P<elem>\\d+)(,(?P>elem))*)?\\]\"I\nCapture group count = 3\nNamed capture groups:\n  elem   2\nFirst code unit = '['\nLast code unit = ']'\nSubject length lower bound = 2\n    [10,20,30,5,5,4,4,2,43,23,4234]\n 0: [10,20,30,5,5,4,4,2,43,23,4234]\n 1: 10,20,30,5,5,4,4,2,43,23,4234\n 2: 10\n 3: ,4234\n    []\n 0: []\n\n/(a(b(?2)c))?/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(a(b(?2)c))*/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        KetRmax\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(a(b(?2)c)){0,2}/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Bra\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        Ket\n        Brazero\n        CBra 1\n        a\n        CBra 2\n        b\n        Recurse\n        c\n        Ket\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/[ab]{1}+/B\n------------------------------------------------------------------\n        Bra\n        [ab]\n        Ket\n        End\n------------------------------------------------------------------\n\n/()(?1){1}/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/()(?1)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\nCapture group count = 3\nOptions: caseless\nLast code unit = 'g' (caseless)\nSubject length lower bound = 8\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n 0: Baby Bjorn Active Carrier - With free SHIPPING!!\n 1: Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/((w\\/|-|with)*(free|immediate)*.*?shipping\\s*[!.-]*)/Ii\nCapture group count = 3\nOptions: caseless\nLast code unit = 'g' (caseless)\nSubject length lower bound = 8\n     Baby Bjorn Active Carrier - With free SHIPPING!!\n 0: Baby Bjorn Active Carrier - With free SHIPPING!!\n 1: Baby Bjorn Active Carrier - With free SHIPPING!!\n\n/a*.*b/IB\n------------------------------------------------------------------\n        Bra\n        a*\n        Any*\n        b\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/(a|b)*.?c/IB\n------------------------------------------------------------------\n        Bra\n        Brazero\n        CBra 1\n        a\n        Alt\n        b\n        KetRmax\n        Any?\n        c\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nLast code unit = 'c'\nSubject length lower bound = 1\n\n/abc(?C255)de(?C)f/IB\n------------------------------------------------------------------\n        Bra\n        abc\n        Callout 255 10 1\n        de\n        Callout 0 16 1\n        f\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'f'\nSubject length lower bound = 6\n\n/abcde/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        a\n        Callout 255 1 1\n        b\n        Callout 255 2 1\n        c\n        Callout 255 3 1\n        d\n        Callout 255 4 1\n        e\n        Callout 255 5 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 5\n  abcde\n--->abcde\n +0 ^         a\n +1 ^^        b\n +2 ^ ^       c\n +3 ^  ^      d\n +4 ^   ^     e\n +5 ^    ^    End of pattern\n 0: abcde\n\\= Expect no match\n  abcdfe\n--->abcdfe\n +0 ^          a\n +1 ^^         b\n +2 ^ ^        c\n +3 ^  ^       d\n +4 ^   ^      e\nNo match\n\n/a*b/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 2\n        a*+\n        Callout 255 2 1\n        b\n        Callout 255 3 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 1\n  ab\n--->ab\n +0 ^      a*\n +2 ^^     b\n +3 ^ ^    End of pattern\n 0: ab\n  aaaab\n--->aaaab\n +0 ^         a*\n +2 ^   ^     b\n +3 ^    ^    End of pattern\n 0: aaaab\n  aaaacb\n--->aaaacb\n +0 ^          a*\n +2 ^   ^      b\n +0  ^         a*\n +2  ^  ^      b\n +0   ^        a*\n +2   ^ ^      b\n +0    ^       a*\n +2    ^^      b\n +0      ^     a*\n +2      ^     b\n +3      ^^    End of pattern\n 0: b\n\n/a*b/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 2\n        a*+\n        Callout 255 2 1\n        b\n        Callout 255 3 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 1\n  ab\n--->ab\n +0 ^      a*\n +2 ^^     b\n +3 ^ ^    End of pattern\n 0: ab\n  aaaab\n--->aaaab\n +0 ^         a*\n +2 ^   ^     b\n +3 ^    ^    End of pattern\n 0: aaaab\n  aaaacb\n--->aaaacb\n +0 ^          a*\n +2 ^   ^      b\n +0  ^         a*\n +2  ^  ^      b\n +0   ^        a*\n +2   ^ ^      b\n +0    ^       a*\n +2    ^^      b\n +0      ^     a*\n +2      ^     b\n +3      ^^    End of pattern\n 0: b\n\n/a+b/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 2\n        a++\n        Callout 255 2 1\n        b\n        Callout 255 3 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: auto_callout\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n  ab\n--->ab\n +0 ^      a+\n +2 ^^     b\n +3 ^ ^    End of pattern\n 0: ab\n  aaaab\n--->aaaab\n +0 ^         a+\n +2 ^   ^     b\n +3 ^    ^    End of pattern\n 0: aaaab\n\\= Expect no match\n  aaaacb\n--->aaaacb\n +0 ^          a+\n +2 ^   ^      b\n +0  ^         a+\n +2  ^  ^      b\n +0   ^        a+\n +2   ^ ^      b\n +0    ^       a+\n +2    ^^      b\nNo match\n\n/(abc|def)x/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 1\n        a\n        Callout 255 2 1\n        b\n        Callout 255 3 1\n        c\n        Callout 255 4 1\n        Alt\n        Callout 255 5 1\n        d\n        Callout 255 6 1\n        e\n        Callout 255 7 1\n        f\n        Callout 255 8 1\n        Ket\n        Callout 255 9 1\n        x\n        Callout 255 10 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a d \nLast code unit = 'x'\nSubject length lower bound = 4\n  abcx\n--->abcx\n +0 ^        (\n +1 ^        a\n +2 ^^       b\n +3 ^ ^      c\n +4 ^  ^     |\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: abcx\n 1: abc\n  defx\n--->defx\n +0 ^        (\n +1 ^        a\n +5 ^        d\n +6 ^^       e\n +7 ^ ^      f\n +8 ^  ^     )\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: defx\n 1: def\n\\= Expect no match\n  abcdefzx\n--->abcdefzx\n +0 ^            (\n +1 ^            a\n +2 ^^           b\n +3 ^ ^          c\n +4 ^  ^         |\n +9 ^  ^         x\n +5 ^            d\n +0    ^         (\n +1    ^         a\n +5    ^         d\n +6    ^^        e\n +7    ^ ^       f\n +8    ^  ^      )\n +9    ^  ^      x\nNo match\n\n/(abc|def)x/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 1\n        a\n        Callout 255 2 1\n        b\n        Callout 255 3 1\n        c\n        Callout 255 4 1\n        Alt\n        Callout 255 5 1\n        d\n        Callout 255 6 1\n        e\n        Callout 255 7 1\n        f\n        Callout 255 8 1\n        Ket\n        Callout 255 9 1\n        x\n        Callout 255 10 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a d \nLast code unit = 'x'\nSubject length lower bound = 4\n  abcx\n--->abcx\n +0 ^        (\n +1 ^        a\n +2 ^^       b\n +3 ^ ^      c\n +4 ^  ^     |\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: abcx\n 1: abc\n  defx\n--->defx\n +0 ^        (\n +1 ^        a\n +5 ^        d\n +6 ^^       e\n +7 ^ ^      f\n +8 ^  ^     )\n +9 ^  ^     x\n+10 ^   ^    End of pattern\n 0: defx\n 1: def\n\\= Expect no match\n  abcdefzx\n--->abcdefzx\n +0 ^            (\n +1 ^            a\n +2 ^^           b\n +3 ^ ^          c\n +4 ^  ^         |\n +9 ^  ^         x\n +5 ^            d\n +0    ^         (\n +1    ^         a\n +5    ^         d\n +6    ^^        e\n +7    ^ ^       f\n +8    ^  ^      )\n +9    ^  ^      x\nNo match\n\n/(ab|cd){3,4}/I,auto_callout\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a c \nSubject length lower bound = 6\n  ababab\n--->ababab\n +0 ^          (\n +1 ^          a\n +2 ^^         b\n +3 ^ ^        |\n +1 ^ ^        a\n +2 ^  ^       b\n +3 ^   ^      |\n +1 ^   ^      a\n +2 ^    ^     b\n +3 ^     ^    |\n +1 ^     ^    a\n +4 ^     ^    c\n+12 ^     ^    End of pattern\n 0: ababab\n 1: ab\n  abcdabcd\n--->abcdabcd\n +0 ^            (\n +1 ^            a\n +2 ^^           b\n +3 ^ ^          |\n +1 ^ ^          a\n +4 ^ ^          c\n +5 ^  ^         d\n +6 ^   ^        ){3,4}\n +1 ^   ^        a\n +2 ^    ^       b\n +3 ^     ^      |\n +1 ^     ^      a\n +4 ^     ^      c\n +5 ^      ^     d\n +6 ^       ^    ){3,4}\n+12 ^       ^    End of pattern\n 0: abcdabcd\n 1: cd\n  abcdcdcdcdcd\n--->abcdcdcdcdcd\n +0 ^                (\n +1 ^                a\n +2 ^^               b\n +3 ^ ^              |\n +1 ^ ^              a\n +4 ^ ^              c\n +5 ^  ^             d\n +6 ^   ^            ){3,4}\n +1 ^   ^            a\n +4 ^   ^            c\n +5 ^    ^           d\n +6 ^     ^          ){3,4}\n +1 ^     ^          a\n +4 ^     ^          c\n +5 ^      ^         d\n +6 ^       ^        ){3,4}\n+12 ^       ^        End of pattern\n 0: abcdcdcd\n 1: cd\n\n/([ab]{,4}c|xy)/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 4\n        [ab]\n        Callout 255 5 1\n        {\n        Callout 255 6 1\n        ,\n        Callout 255 7 1\n        4\n        Callout 255 8 1\n        }\n        Callout 255 9 1\n        c\n        Callout 255 10 1\n        Alt\n        Callout 255 11 1\n        x\n        Callout 255 12 1\n        y\n        Callout 255 13 1\n        Ket\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a b x \nSubject length lower bound = 2\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n--->Note: that { does NOT introduce a quantifier\n +0         ^                                        (\n +1         ^                                        [ab]\n +5         ^^                                       {\n+11         ^                                        x\n +0                                 ^                (\n +1                                 ^                [ab]\n +5                                 ^^               {\n+11                                 ^                x\n +0                                     ^            (\n +1                                     ^            [ab]\n +5                                     ^^           {\n+11                                     ^            x\nNo match\n\n/([ab]{,4}c|xy)/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 4\n        [ab]\n        Callout 255 5 1\n        {\n        Callout 255 6 1\n        ,\n        Callout 255 7 1\n        4\n        Callout 255 8 1\n        }\n        Callout 255 9 1\n        c\n        Callout 255 10 1\n        Alt\n        Callout 255 11 1\n        x\n        Callout 255 12 1\n        y\n        Callout 255 13 1\n        Ket\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a b x \nSubject length lower bound = 2\n\\= Expect no match\n    Note: that { does NOT introduce a quantifier\n--->Note: that { does NOT introduce a quantifier\n +0         ^                                        (\n +1         ^                                        [ab]\n +5         ^^                                       {\n+11         ^                                        x\n +0                                 ^                (\n +1                                 ^                [ab]\n +5                                 ^^               {\n+11                                 ^                x\n +0                                     ^            (\n +1                                     ^            [ab]\n +5                                     ^^           {\n+11                                     ^            x\nNo match\n\n/([ab]{1,4}c|xy){4,5}?123/IB,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        Braminzero\n        CBra 1\n        Callout 255 1 9\n        [ab]{1,4}+\n        Callout 255 10 1\n        c\n        Callout 255 11 1\n        Alt\n        Callout 255 12 1\n        x\n        Callout 255 13 1\n        y\n        Callout 255 14 7\n        Ket\n        Callout 255 21 1\n        1\n        Callout 255 22 1\n        2\n        Callout 255 23 1\n        3\n        Callout 255 24 0\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nOptions: auto_callout\nStarting code units: a b x \nLast code unit = '3'\nSubject length lower bound = 11\n    aacaacaacaacaac123\n--->aacaacaacaacaac123\n +0 ^                      (\n +1 ^                      [ab]{1,4}\n+10 ^ ^                    c\n+11 ^  ^                   |\n +1 ^  ^                   [ab]{1,4}\n+10 ^    ^                 c\n+11 ^     ^                |\n +1 ^     ^                [ab]{1,4}\n+10 ^       ^              c\n+11 ^        ^             |\n +1 ^        ^             [ab]{1,4}\n+10 ^          ^           c\n+11 ^           ^          |\n+21 ^           ^          1\n +1 ^           ^          [ab]{1,4}\n+10 ^             ^        c\n+11 ^              ^       |\n+21 ^              ^       1\n+22 ^               ^      2\n+23 ^                ^     3\n+24 ^                 ^    End of pattern\n 0: aacaacaacaacaac123\n 1: aac\n\n/\\b.*/I\nCapture group count = 0\nMax lookbehind = 1\nMay match empty string\nSubject length lower bound = 0\n  ab cd\\=offset=1\n 0:  cd\n\n/\\b.*/Is\nCapture group count = 0\nMax lookbehind = 1\nMay match empty string\nOptions: dotall\nSubject length lower bound = 0\n  ab cd\\=startoffset=1\n 0:  cd\n\n/(?!.bcd).*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n  Xbcd12345\n 0: bcd12345\n\n/abcde/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'e'\nSubject length lower bound = 5\n    ab\\=ps\nPartial match: ab\n    abc\\=ps\nPartial match: abc\n    abcd\\=ps\nPartial match: abcd\n    abcde\\=ps\n 0: abcde\n    the quick brown abc\\=ps\nPartial match: abc\n\\= Expect no match\\=ps\n    the quick brown abxyz fox\\=ps\nNo match\n\n\"^(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/(20)?\\d\\d$\"I\nCapture group count = 3\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '/'\nSubject length lower bound = 6\n    13/05/04\\=ps\n 0: 13/05/04\n 1: 13\n 2: 05\n    13/5/2004\\=ps\n 0: 13/5/2004\n 1: 13\n 2: 5\n 3: 20\n    02/05/09\\=ps\n 0: 02/05/09\n 1: 02\n 2: 05\n    1\\=ps\nPartial match: 1\n    1/2\\=ps\nPartial match: 1/2\n    1/2/0\\=ps\nPartial match: 1/2/0\n    1/2/04\\=ps\n 0: 1/2/04\n 1: 1\n 2: 2\n    0\\=ps\nPartial match: 0\n    02/\\=ps\nPartial match: 02/\n    02/0\\=ps\nPartial match: 02/0\n    02/1\\=ps\nPartial match: 02/1\n\\= Expect no match\\=ps\n    \\=ps\nNo match\n    123\\=ps\nNo match\n    33/4/04\\=ps\nNo match\n    3/13/04\\=ps\nNo match\n    0/1/2003\\=ps\nNo match\n    0/\\=ps\nNo match\n    02/0/\\=ps\nNo match\n    02/13\\=ps\nNo match\n\n/0{0,2}ABC/I\nCapture group count = 0\nStarting code units: 0 A \nLast code unit = 'C'\nSubject length lower bound = 3\n\n/\\d{3,}ABC/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'C'\nSubject length lower bound = 6\n\n/\\d*ABC/I\nCapture group count = 0\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A \nLast code unit = 'C'\nSubject length lower bound = 3\n\n/[abc]+DE/I\nCapture group count = 0\nStarting code units: a b c \nLast code unit = 'E'\nSubject length lower bound = 3\n\n/[abc]?123/I\nCapture group count = 0\nStarting code units: 1 a b c \nLast code unit = '3'\nSubject length lower bound = 3\n    123\\=ps\n 0: 123\n    a\\=ps\nPartial match: a\n    b\\=ps\nPartial match: b\n    c\\=ps\nPartial match: c\n    c12\\=ps\nPartial match: c12\n    c123\\=ps\n 0: c123\n\n/^(?:\\d){3,5}X/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = 'X'\nSubject length lower bound = 4\n    1\\=ps\nPartial match: 1\n    123\\=ps\nPartial match: 123\n    123X\n 0: 123X\n    1234\\=ps\nPartial match: 1234\n    1234X\n 0: 1234X\n    12345\\=ps\nPartial match: 12345\n    12345X\n 0: 12345X\n\\= Expect no match\n    1X\nNo match\n    123456\\=ps\nNo match\n\n\"<(\\w+)/?>(.)*</(\\1)>\"Igms\nCapture group count = 3\nMax back reference = 1\nOptions: dotall multiline\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 7\n    <!DOCTYPE seite SYSTEM \"http://www.lco.lineas.de/xmlCms.dtd\">\\n<seite>\\n<dokumenteninformation>\\n<seitentitel>Partner der LCO</seitentitel>\\n<sprache>de</sprache>\\n<seitenbeschreibung>Partner der LINEAS Consulting\\nGmbH</seitenbeschreibung>\\n<schluesselworte>LINEAS Consulting GmbH Hamburg\\nPartnerfirmen</schluesselworte>\\n<revisit>30 days</revisit>\\n<robots>index,follow</robots>\\n<menueinformation>\\n<aktiv>ja</aktiv>\\n<menueposition>3</menueposition>\\n<menuetext>Partner</menuetext>\\n</menueinformation>\\n<lastedited>\\n<autor>LCO</autor>\\n<firma>LINEAS Consulting</firma>\\n<datum>15.10.2003</datum>\\n</lastedited>\\n</dokumenteninformation>\\n<inhalt>\\n\\n<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\\nGmbH</absatzueberschrift>\\n\\n<absatz><link ziel=\"http://www.ca.com/\" zielfenster=\"_blank\">\\n<bild name=\"logo_ca.gif\" rahmen=\"no\"/></link> <link\\nziel=\"http://www.ey.com/\" zielfenster=\"_blank\"><bild\\nname=\"logo_euy.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.cisco.de/\" zielfenster=\"_blank\">\\n<bild name=\"logo_cisco.gif\" rahmen=\"ja\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.atelion.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_atelion.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><link ziel=\"http://www.line-information.de/\"\\nzielfenster=\"_blank\">\\n<bild name=\"logo_line_information.gif\" rahmen=\"no\"/></link>\\n</absatz>\\n\\n<absatz><bild name=\"logo_aw.gif\" rahmen=\"no\"/></absatz>\\n\\n<absatz><link ziel=\"http://www.incognis.de/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_incognis.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.addcraft.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_addcraft.gif\" rahmen=\"no\"/></link></absatz>\\n\\n<absatz><link ziel=\"http://www.comendo.com/\"\\nzielfenster=\"_blank\"><bild\\nname=\"logo_comendo.gif\" rahmen=\"no\"/></link></absatz>\\n\\n</inhalt>\\n</seite>\\=jitstack=1024\n 0: <seite>\\x0a<dokumenteninformation>\\x0a<seitentitel>Partner der LCO</seitentitel>\\x0a<sprache>de</sprache>\\x0a<seitenbeschreibung>Partner der LINEAS Consulting\\x0aGmbH</seitenbeschreibung>\\x0a<schluesselworte>LINEAS Consulting GmbH Hamburg\\x0aPartnerfirmen</schluesselworte>\\x0a<revisit>30 days</revisit>\\x0a<robots>index,follow</robots>\\x0a<menueinformation>\\x0a<aktiv>ja</aktiv>\\x0a<menueposition>3</menueposition>\\x0a<menuetext>Partner</menuetext>\\x0a</menueinformation>\\x0a<lastedited>\\x0a<autor>LCO</autor>\\x0a<firma>LINEAS Consulting</firma>\\x0a<datum>15.10.2003</datum>\\x0a</lastedited>\\x0a</dokumenteninformation>\\x0a<inhalt>\\x0a\\x0a<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\\x0aGmbH</absatzueberschrift>\\x0a\\x0a<absatz><link ziel=\"http://www.ca.com/\" zielfenster=\"_blank\">\\x0a<bild name=\"logo_ca.gif\" rahmen=\"no\"/></link> <link\\x0aziel=\"http://www.ey.com/\" zielfenster=\"_blank\"><bild\\x0aname=\"logo_euy.gif\" rahmen=\"no\"/></link>\\x0a</absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.cisco.de/\" zielfenster=\"_blank\">\\x0a<bild name=\"logo_cisco.gif\" rahmen=\"ja\"/></link></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.atelion.de/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_atelion.gif\" rahmen=\"no\"/></link>\\x0a</absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.line-information.de/\"\\x0azielfenster=\"_blank\">\\x0a<bild name=\"logo_line_information.gif\" rahmen=\"no\"/></link>\\x0a</absatz>\\x0a\\x0a<absatz><bild name=\"logo_aw.gif\" rahmen=\"no\"/></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.incognis.de/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_incognis.gif\" rahmen=\"no\"/></link></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.addcraft.com/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_addcraft.gif\" rahmen=\"no\"/></link></absatz>\\x0a\\x0a<absatz><link ziel=\"http://www.comendo.com/\"\\x0azielfenster=\"_blank\"><bild\\x0aname=\"logo_comendo.gif\" rahmen=\"no\"/></link></absatz>\\x0a\\x0a</inhalt>\\x0a</seite>\n 1: seite\n 2: \\x0a\n 3: seite\n\n/line\\nbreak/I\nCapture group count = 0\nContains explicit CR or LF match\nFirst code unit = 'l'\nLast code unit = 'k'\nSubject length lower bound = 10\n    this is a line\\nbreak\n 0: line\\x0abreak\n    line one\\nthis is a line\\nbreak in the second line\n 0: line\\x0abreak\n\n/line\\nbreak/I,firstline\nCapture group count = 0\nContains explicit CR or LF match\nOptions: firstline\nFirst code unit = 'l'\nLast code unit = 'k'\nSubject length lower bound = 10\n    this is a line\\nbreak\n 0: line\\x0abreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\nNo match\n\n/line\\nbreak/Im,firstline\nCapture group count = 0\nContains explicit CR or LF match\nOptions: firstline multiline\nFirst code unit = 'l'\nLast code unit = 'k'\nSubject length lower bound = 10\n    this is a line\\nbreak\n 0: line\\x0abreak\n\\= Expect no match\n    line one\\nthis is a line\\nbreak in the second line\nNo match\n\n/(?i)(?-i)AbCd/I\nCapture group count = 0\nFirst code unit = 'A'\nLast code unit = 'd'\nSubject length lower bound = 4\n    AbCd\n 0: AbCd\n\\= Expect no match\n    abcd\nNo match\n\n/a{11111111111111111111}/I\nFailed: error 105 at offset 8: number too big in {} quantifier\n\n/(){64294967295}/I\nFailed: error 105 at offset 9: number too big in {} quantifier\n\n/(){2,4294967295}/I\nFailed: error 105 at offset 11: number too big in {} quantifier\n\n\"(?i:a)(?i:b)(?i:c)(?i:d)(?i:e)(?i:f)(?i:g)(?i:h)(?i:i)(?i:j)(k)(?i:l)A\\1B\"I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a' (caseless)\nLast code unit = 'B'\nSubject length lower bound = 15\n    abcdefghijklAkB\n 0: abcdefghijklAkB\n 1: k\n\n\"(?P<n0>a)(?P<n1>b)(?P<n2>c)(?P<n3>d)(?P<n4>e)(?P<n5>f)(?P<n6>g)(?P<n7>h)(?P<n8>i)(?P<n9>j)(?P<n10>k)(?P<n11>l)A\\11B\"I\nCapture group count = 12\nMax back reference = 11\nNamed capture groups:\n  n0    1\n  n1    2\n  n10  11\n  n11  12\n  n2    3\n  n3    4\n  n4    5\n  n5    6\n  n6    7\n  n7    8\n  n8    9\n  n9   10\nFirst code unit = 'a'\nLast code unit = 'B'\nSubject length lower bound = 15\n    abcdefghijklAkB\n 0: abcdefghijklAkB\n 1: a\n 2: b\n 3: c\n 4: d\n 5: e\n 6: f\n 7: g\n 8: h\n 9: i\n10: j\n11: k\n12: l\n\n\"(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)A\\11B\"I\nCapture group count = 12\nMax back reference = 11\nFirst code unit = 'a'\nLast code unit = 'B'\nSubject length lower bound = 15\n    abcdefghijklAkB\n 0: abcdefghijklAkB\n 1: a\n 2: b\n 3: c\n 4: d\n 5: e\n 6: f\n 7: g\n 8: h\n 9: i\n10: j\n11: k\n12: l\n\n\"(?P<name0>a)(?P<name1>a)(?P<name2>a)(?P<name3>a)(?P<name4>a)(?P<name5>a)(?P<name6>a)(?P<name7>a)(?P<name8>a)(?P<name9>a)(?P<name10>a)(?P<name11>a)(?P<name12>a)(?P<name13>a)(?P<name14>a)(?P<name15>a)(?P<name16>a)(?P<name17>a)(?P<name18>a)(?P<name19>a)(?P<name20>a)(?P<name21>a)(?P<name22>a)(?P<name23>a)(?P<name24>a)(?P<name25>a)(?P<name26>a)(?P<name27>a)(?P<name28>a)(?P<name29>a)(?P<name30>a)(?P<name31>a)(?P<name32>a)(?P<name33>a)(?P<name34>a)(?P<name35>a)(?P<name36>a)(?P<name37>a)(?P<name38>a)(?P<name39>a)(?P<name40>a)(?P<name41>a)(?P<name42>a)(?P<name43>a)(?P<name44>a)(?P<name45>a)(?P<name46>a)(?P<name47>a)(?P<name48>a)(?P<name49>a)(?P<name50>a)(?P<name51>a)(?P<name52>a)(?P<name53>a)(?P<name54>a)(?P<name55>a)(?P<name56>a)(?P<name57>a)(?P<name58>a)(?P<name59>a)(?P<name60>a)(?P<name61>a)(?P<name62>a)(?P<name63>a)(?P<name64>a)(?P<name65>a)(?P<name66>a)(?P<name67>a)(?P<name68>a)(?P<name69>a)(?P<name70>a)(?P<name71>a)(?P<name72>a)(?P<name73>a)(?P<name74>a)(?P<name75>a)(?P<name76>a)(?P<name77>a)(?P<name78>a)(?P<name79>a)(?P<name80>a)(?P<name81>a)(?P<name82>a)(?P<name83>a)(?P<name84>a)(?P<name85>a)(?P<name86>a)(?P<name87>a)(?P<name88>a)(?P<name89>a)(?P<name90>a)(?P<name91>a)(?P<name92>a)(?P<name93>a)(?P<name94>a)(?P<name95>a)(?P<name96>a)(?P<name97>a)(?P<name98>a)(?P<name99>a)(?P<name100>a)\"I\nCapture group count = 101\nNamed capture groups:\n  name0     1\n  name1     2\n  name10   11\n  name100 101\n  name11   12\n  name12   13\n  name13   14\n  name14   15\n  name15   16\n  name16   17\n  name17   18\n  name18   19\n  name19   20\n  name2     3\n  name20   21\n  name21   22\n  name22   23\n  name23   24\n  name24   25\n  name25   26\n  name26   27\n  name27   28\n  name28   29\n  name29   30\n  name3     4\n  name30   31\n  name31   32\n  name32   33\n  name33   34\n  name34   35\n  name35   36\n  name36   37\n  name37   38\n  name38   39\n  name39   40\n  name4     5\n  name40   41\n  name41   42\n  name42   43\n  name43   44\n  name44   45\n  name45   46\n  name46   47\n  name47   48\n  name48   49\n  name49   50\n  name5     6\n  name50   51\n  name51   52\n  name52   53\n  name53   54\n  name54   55\n  name55   56\n  name56   57\n  name57   58\n  name58   59\n  name59   60\n  name6     7\n  name60   61\n  name61   62\n  name62   63\n  name63   64\n  name64   65\n  name65   66\n  name66   67\n  name67   68\n  name68   69\n  name69   70\n  name7     8\n  name70   71\n  name71   72\n  name72   73\n  name73   74\n  name74   75\n  name75   76\n  name76   77\n  name77   78\n  name78   79\n  name79   80\n  name8     9\n  name80   81\n  name81   82\n  name82   83\n  name83   84\n  name84   85\n  name85   86\n  name86   87\n  name87   88\n  name88   89\n  name89   90\n  name9    10\n  name90   91\n  name91   92\n  name92   93\n  name93   94\n  name94   95\n  name95   96\n  name96   97\n  name97   98\n  name98   99\n  name99  100\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 101\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nMatched, but too many substrings\n 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n 1: a\n 2: a\n 3: a\n 4: a\n 5: a\n 6: a\n 7: a\n 8: a\n 9: a\n10: a\n11: a\n12: a\n13: a\n14: a\n\n\"(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)\"I\nCapture group count = 101\nFirst code unit = 'a'\nLast code unit = 'a'\nSubject length lower bound = 101\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nMatched, but too many substrings\n 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n 1: a\n 2: a\n 3: a\n 4: a\n 5: a\n 6: a\n 7: a\n 8: a\n 9: a\n10: a\n11: a\n12: a\n13: a\n14: a\n\n/[^()]*(?:\\((?R)\\)[^()]*)*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: (this(and)that)\n    (this(and)that)stuff\n 0: (this(and)that)stuff\n\n/[^()]*(?:\\((?>(?R))\\)[^()]*)*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: (this(and)that)\n\n/[^()]*(?:\\((?R)\\))*[^()]*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: (this(and)that)\n\n/(?:\\((?R)\\))*[^()]*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: \n    ((this))\n 0: ((this))\n\n/(?:\\((?R)\\))|[^()]*/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    (this(and)that\n 0: \n    (this(and)that)\n 0: \n    (this)\n 0: (this)\n    ((this))\n 0: ((this))\n\n/\\x{0000ff}/I\nCapture group count = 0\nFirst code unit = \\xff\nSubject length lower bound = 1\n\n/^((?P<A>a1)|(?P<A>a2)b)/I\nFailed: error 143 at offset 18: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  A   2\n  A   3\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    a1b\\=copy=A\n 0: a1\n 1: a1\n 2: a1\n  C a1 (2) A (non-unique)\n    a2b\\=copy=A\n 0: a2b\n 1: a2b\n 2: <unset>\n 3: a2\n  C a2 (2) A (non-unique)\n    a1b\\=copy=Z,copy=A\n 0: a1\n 1: a1\n 2: a1\nNumber not found for group 'Z'\nCopy substring 'Z' failed (-49): unknown substring\n  C a1 (2) A (non-unique)\n\n/(?|(?<a>)(?<b>)(?<a>)|(?<a>)(?<b>)(?<a>))/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  a   1\n  a   3\n  b   2\nMay match empty string\nOptions: dupnames\nSubject length lower bound = 0\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    ab\\=copy=A\n 0: ab\n 1: a\n 2: b\n  C a (1) A (non-unique)\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    ab\\=copy=A\n 0: ab\n 1: a\n 2: b\n  C a (1) A (non-unique)\n    cd\\=copy=A\n 0: cd\nCopy substring 'A' failed (-55): requested value is not set\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\nCapture group count = 4\nNamed capture groups:\n  A   1\n  A   2\n  A   3\n  A   4\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    cdefgh\\=copy=A\n 0: cdefgh\n 1: <unset>\n 2: <unset>\n 3: ef\n 4: gh\n  C ef (2) A (non-unique)\n\n/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  A   2\n  A   3\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    a1b\\=get=A\n 0: a1\n 1: a1\n 2: a1\n  G a1 (2) A (non-unique)\n    a2b\\=get=A\n 0: a2b\n 1: a2b\n 2: <unset>\n 3: a2\n  G a2 (2) A (non-unique)\n    a1b\\=get=Z,get=A\n 0: a1\n 1: a1\n 2: a1\nNumber not found for group 'Z'\nGet substring 'Z' failed (-49): unknown substring\n  G a1 (2) A (non-unique)\n\n/^(?P<A>a)(?P<A>b)/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nCompile options: dupnames\nOverall options: anchored dupnames\nFirst code unit = 'a'\nSubject length lower bound = 2\n    ab\\=get=A\n 0: ab\n 1: a\n 2: b\n  G a (1) A (non-unique)\n\n/^(?P<A>a)(?P<A>b)|cd/I,dupnames\nCapture group count = 2\nNamed capture groups:\n  A   1\n  A   2\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    ab\\=get=A\n 0: ab\n 1: a\n 2: b\n  G a (1) A (non-unique)\n    cd\\=get=A\n 0: cd\nGet substring 'A' failed (-55): requested value is not set\n\n/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames\nCapture group count = 4\nNamed capture groups:\n  A   1\n  A   2\n  A   3\n  A   4\nOptions: dupnames\nStarting code units: a c \nSubject length lower bound = 2\n    cdefgh\\=get=A\n 0: cdefgh\n 1: <unset>\n 2: <unset>\n 3: ef\n 4: gh\n  G ef (2) A (non-unique)\n\n/(?J)^((?P<A>a1)|(?P<A>a2)b)/I\nCapture group count = 3\nNamed capture groups:\n  A   2\n  A   3\nCompile options: <none>\nOverall options: anchored\nDuplicate name status changes\nFirst code unit = 'a'\nSubject length lower bound = 2\n    a1b\\=copy=A\n 0: a1\n 1: a1\n 2: a1\n  C a1 (2) A (non-unique)\n    a2b\\=copy=A\n 0: a2b\n 1: a2b\n 2: <unset>\n 3: a2\n  C a2 (2) A (non-unique)\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<A>d)/I\nFailed: error 143 at offset 38: two named subpatterns have the same name (PCRE2_DUPNAMES not set)\n\n# In this next test, J is not set at the outer level; consequently it isn't set\n# in the pattern's options; consequently pcre2_substring_get_byname() produces\n# a random value.\n\n/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<C>d)/I\nCapture group count = 4\nNamed capture groups:\n  A   1\n  B   2\n  B   3\n  C   4\nCompile options: <none>\nOverall options: anchored\nDuplicate name status changes\nFirst code unit = 'a'\nSubject length lower bound = 6\n    a bc d\\=copy=A,copy=B,copy=C\n 0: a bc d\n 1: a\n 2: b\n 3: c\n 4: d\n  C a (1) A (group 1)\n  C b (1) B (non-unique)\n  C d (1) C (group 4)\n\n/^(?P<A>a)?(?(A)a|b)/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  A   1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n    aabc\n 0: aa\n 1: a\n    bc\n 0: b\n\\= Expect no match\n    abc\nNo match\n\n/(?:(?(ZZ)a|b)(?P<ZZ>X))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  ZZ   1\nLast code unit = 'X'\nSubject length lower bound = 2\n    bXaX\n 0: bXaX\n 1: X\n\n/(?:(?(2y)a|b)(X))+/I\nFailed: error 124 at offset 7: missing closing parenthesis for condition\n\n/(?:(?(ZA)a|b)(?P<ZZ>X))+/I\nFailed: error 115 at offset 6: reference to non-existent subpattern\n\n/(?:(?(ZZ)a|b)(?(ZZ)a|b)(?P<ZZ>X))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  ZZ   1\nLast code unit = 'X'\nSubject length lower bound = 3\n    bbXaaX\n 0: bbXaaX\n 1: X\n\n/(?:(?(ZZ)a|\\(b\\))\\\\(?P<ZZ>X))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  ZZ   1\nLast code unit = 'X'\nSubject length lower bound = 3\n    (b)\\\\Xa\\\\X\n 0: (b)\\Xa\\X\n 1: X\n\n/(?P<ABC/I\nFailed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)\n\n/(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  A   1\nSubject length lower bound = 2\n    bXXaYYaY\n 0: bXXaYYaY\n 1: Y\n    bXYaXXaX\n 0: bX\n 1: X\n\n/()()()()()()()()()(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I\nCapture group count = 10\nMax back reference = 10\nNamed capture groups:\n  A  10\nSubject length lower bound = 2\n    bXXaYYaY\n 0: bXXaYYaY\n 1: \n 2: \n 3: \n 4: \n 5: \n 6: \n 7: \n 8: \n 9: \n10: Y\n\n/\\s*,\\s*/I\nCapture group count = 0\nStarting code units: \\x09 \\x0a \\x0b \\x0c \\x0d \\x20 , \nLast code unit = ','\nSubject length lower bound = 1\n    \\x0b,\\x0b\n 0: \\x0b,\\x0b\n    \\x0c,\\x0d\n 0: \\x0c,\\x0d\n\n/^abc/Im,newline=lf\nCapture group count = 0\nOptions: multiline\nForced newline is LF\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    xyz\\nabc\n 0: abc\n    xyz\\r\\nabc\n 0: abc\n\\= Expect no match\n    xyz\\rabc\nNo match\n    xyzabc\\r\nNo match\n    xyzabc\\rpqr\nNo match\n    xyzabc\\r\\n\nNo match\n    xyzabc\\r\\npqr\nNo match\n\n/^abc/Im,newline=crlf\nCapture group count = 0\nOptions: multiline\nForced newline is CRLF\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    xyz\\r\\nabclf>\n 0: abc\n\\= Expect no match\n    xyz\\nabclf\nNo match\n    xyz\\rabclf\nNo match\n\n/^abc/Im,newline=cr\nCapture group count = 0\nOptions: multiline\nForced newline is CR\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n    xyz\\rabc\n 0: abc\n\\= Expect no match\n    xyz\\nabc\nNo match\n    xyz\\r\\nabc\nNo match\n\n/^abc/Im,newline=bad\n** Invalid value in 'newline=bad'\n\n/.*/I,newline=lf\nCapture group count = 0\nMay match empty string\nForced newline is LF\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n    abc\\ndef\n 0: abc\n    abc\\rdef\n 0: abc\\x0ddef\n    abc\\r\\ndef\n 0: abc\\x0d\n\n/.*/I,newline=cr\nCapture group count = 0\nMay match empty string\nForced newline is CR\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n    abc\\ndef\n 0: abc\\x0adef\n    abc\\rdef\n 0: abc\n    abc\\r\\ndef\n 0: abc\n\n/.*/I,newline=crlf\nCapture group count = 0\nMay match empty string\nForced newline is CRLF\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n    abc\\ndef\n 0: abc\\x0adef\n    abc\\rdef\n 0: abc\\x0ddef\n    abc\\r\\ndef\n 0: abc\n\n/\\w+(.)(.)?def/Is\nCapture group count = 2\nOptions: dotall\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nLast code unit = 'f'\nSubject length lower bound = 5\n    abc\\ndef\n 0: abc\\x0adef\n 1: \\x0a\n    abc\\rdef\n 0: abc\\x0ddef\n 1: \\x0d\n    abc\\r\\ndef\n 0: abc\\x0d\\x0adef\n 1: \\x0d\n 2: \\x0a\n\n/(?P<B>25[0-5]|2[0-4]\\d|[01]?\\d?\\d)(?:\\.(?P>B)){3}/I\nCapture group count = 1\nNamed capture groups:\n  B   1\nStarting code units: 0 1 2 3 4 5 6 7 8 9 \nLast code unit = '.'\nSubject length lower bound = 7\n\n/()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n ()()()()()()()()()()()()()()()()()()()()\n (.(.))/Ix\nCapture group count = 102\nOptions: extended\nSubject length lower bound = 2\n    XY\\=ovector=133\n 0: XY\n 1: \n 2: \n 3: \n 4: \n 5: \n 6: \n 7: \n 8: \n 9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n18: \n19: \n20: \n21: \n22: \n23: \n24: \n25: \n26: \n27: \n28: \n29: \n30: \n31: \n32: \n33: \n34: \n35: \n36: \n37: \n38: \n39: \n40: \n41: \n42: \n43: \n44: \n45: \n46: \n47: \n48: \n49: \n50: \n51: \n52: \n53: \n54: \n55: \n56: \n57: \n58: \n59: \n60: \n61: \n62: \n63: \n64: \n65: \n66: \n67: \n68: \n69: \n70: \n71: \n72: \n73: \n74: \n75: \n76: \n77: \n78: \n79: \n80: \n81: \n82: \n83: \n84: \n85: \n86: \n87: \n88: \n89: \n90: \n91: \n92: \n93: \n94: \n95: \n96: \n97: \n98: \n99: \n100: \n101: XY\n102: Y\n\n/(a*b|(?i:c*(?-i)d))/I\nCapture group count = 1\nStarting code units: C a b c d \nSubject length lower bound = 1\n\n/()[ab]xyz/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(|)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(|c)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(|c?)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(d?|c?)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c d \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/(d?|c)[ab]xyz/I\nCapture group count = 1\nStarting code units: a b c d \nLast code unit = 'z'\nSubject length lower bound = 4\n\n/^a*b\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a*+\n        b\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a*+b\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a*+\n        b\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a*?b\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a*+\n        b\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nStarting code units: a b \nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a+A\\d/IB\n------------------------------------------------------------------\n        Bra\n        ^\n        a++\n        A\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nLast code unit = 'A'\nSubject length lower bound = 3\n    aaaA5\n 0: aaaA5\n\\= Expect no match\n    aaaa5\nNo match\n\n/^a*A\\d/IBi\n------------------------------------------------------------------\n        Bra\n        ^\n     /i a*\n     /i A\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nCompile options: caseless\nOverall options: anchored caseless\nStarting code units: A a \nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aaaA5\n 0: aaaA5\n    aaaa5\n 0: aaaa5\n    a5 \n 0: a5\n\n/(a*|b*)[cd]/I\nCapture group count = 1\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a+|b*)[cd]/I\nCapture group count = 1\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a*|b+)[cd]/I\nCapture group count = 1\nStarting code units: a b c d \nSubject length lower bound = 1\n\n/(a+|b+)[cd]/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n (((\n a\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n )))\n/Ix\nCapture group count = 203\nOptions: extended\nFirst code unit = 'a'\nSubject length lower bound = 1\n  large nest\nMatched, but too many substrings\n 0: a\n 1: a\n 2: a\n 3: a\n 4: a\n 5: a\n 6: a\n 7: a\n 8: a\n 9: a\n10: a\n11: a\n12: a\n13: a\n14: a\n\n/a*\\d/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\D/B\n------------------------------------------------------------------\n        Bra\n        a*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/0*\\d/B\n------------------------------------------------------------------\n        Bra\n        0*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/0*\\D/B\n------------------------------------------------------------------\n        Bra\n        0*+\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\s/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\S/B\n------------------------------------------------------------------\n        Bra\n        a*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/ *\\s/B\n------------------------------------------------------------------\n        Bra\n         *\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/ *\\S/B\n------------------------------------------------------------------\n        Bra\n         *+\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\w/B\n------------------------------------------------------------------\n        Bra\n        a*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*\\W/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/=*\\w/B\n------------------------------------------------------------------\n        Bra\n        =*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/=*\\W/B\n------------------------------------------------------------------\n        Bra\n        =*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*a/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*2/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\d*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*a/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*2/B\n------------------------------------------------------------------\n        Bra\n        \\D*+\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\D*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\D*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\D*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*a/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*2/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\s*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*a/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*2/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\S*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\S*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*a/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*2/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\w*+\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\w*\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\w*+\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*a/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*2/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        2\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\d/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\D/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\D\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\s/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\s\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\S/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\S\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\w/B\n------------------------------------------------------------------\n        Bra\n        \\W*+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W*\\W/B\n------------------------------------------------------------------\n        Bra\n        \\W*\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+a/B\n------------------------------------------------------------------\n        Bra\n        [^a]++\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+a/Bi\n------------------------------------------------------------------\n        Bra\n     /i [^a]++\n     /i a\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+A/Bi\n------------------------------------------------------------------\n        Bra\n     /i [^a]++\n     /i A\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+b/B\n------------------------------------------------------------------\n        Bra\n        [^a]+\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^a]+\\d/B\n------------------------------------------------------------------\n        Bra\n        [^a]+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/a*[^a]/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        [^a]\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?P<abc>x)(?P<xyz>y)/I\nCapture group count = 2\nNamed capture groups:\n  abc   1\n  xyz   2\nFirst code unit = 'x'\nLast code unit = 'y'\nSubject length lower bound = 2\n    xy\\=copy=abc,copy=xyz\n 0: xy\n 1: x\n 2: y\n  C x (1) abc (group 1)\n  C y (1) xyz (group 2)\n\n/(?<abc>x)(?'xyz'y)/I\nCapture group count = 2\nNamed capture groups:\n  abc   1\n  xyz   2\nFirst code unit = 'x'\nLast code unit = 'y'\nSubject length lower bound = 2\n    xy\\=copy=abc,copy=xyz\n 0: xy\n 1: x\n 2: y\n  C x (1) abc (group 1)\n  C y (1) xyz (group 2)\n\n/(?<abc'x)(?'xyz'y)/I\nFailed: error 142 at offset 6: syntax error in subpattern name (missing terminator?)\n\n/(?<abc>x)(?'xyz>y)/I\nFailed: error 142 at offset 15: syntax error in subpattern name (missing terminator?)\n\n/(?P'abc'x)(?P<xyz>y)/I\nFailed: error 141 at offset 3: unrecognized character after (?P\n\n/^(?:(?(ZZ)a|b)(?<ZZ>X))+/\n    bXaX\n 0: bXaX\n 1: X\n    bXbX\n 0: bX\n 1: X\n\\= Expect no match\n    aXaX\nNo match\n    aXbX\nNo match\n\n/^(?P>abc)(?<abcd>xxx)/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/^(?P>abc)(?<abc>x|y)/\n    xx\n 0: xx\n 1: x\n    xy\n 0: xy\n 1: y\n    yy\n 0: yy\n 1: y\n    yx\n 0: yx\n 1: x\n\n/^(?P>abc)(?P<abc>x|y)/\n    xx\n 0: xx\n 1: x\n    xy\n 0: xy\n 1: y\n    yy\n 0: yy\n 1: y\n    yx\n 0: yx\n 1: x\n\n/^((?(abc)a|b)(?<abc>x|y))+/\n    bxay\n 0: bxay\n 1: ay\n 2: y\n    bxby\n 0: bx\n 1: bx\n 2: x\n\\= Expect no match\n    axby\nNo match\n\n/^(((?P=abc)|X)(?<abc>x|y))+/\n    XxXxxx\n 0: XxXxxx\n 1: xx\n 2: x\n 3: x\n    XxXyyx\n 0: XxXyyx\n 1: yx\n 2: y\n 3: x\n    XxXyxx\n 0: XxXy\n 1: Xy\n 2: X\n 3: y\n\\= Expect no match\n    x\nNo match\n\n/^(?1)(abc)/\n    abcabc\n 0: abcabc\n 1: abc\n\n/^(?:(?:\\1|X)(a|b))+/\n    Xaaa\n 0: Xaaa\n 1: a\n    Xaba\n 0: Xa\n 1: a\n\n/^[\\E\\Qa\\E-\\Qz\\E]+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        [a-z]++\n        Ket\n        End\n------------------------------------------------------------------\n\n/^[a\\Q]bc\\E]/B\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\]a-c]\n        Ket\n        End\n------------------------------------------------------------------\n\n/^[a-\\Q\\E]/B\n------------------------------------------------------------------\n        Bra\n        ^\n        [\\-a]\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?P>abc)[()](?<abc>)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        [()]\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^((?(abc)y)[()](?P<abc>x))+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        Cond\n      2 Cond ref\n        y\n        Ket\n        [()]\n        CBra 2\n        x\n        Ket\n        KetRmax\n        Ket\n        End\n------------------------------------------------------------------\n    (xy)x\n 0: (xy)x\n 1: y)x\n 2: x\n\n/^(?P>abc)\\Q()\\E(?<abc>)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        ()\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?P>abc)[a\\Q(]\\E(](?<abc>)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        [(\\]a]\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?P>abc) # this is (a comment)\n  (?<abc>)/Bx\n------------------------------------------------------------------\n        Bra\n        ^\n        Recurse\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^\\W*(?:(?<one>(?<two>.)\\W*(?&one)\\W*\\k<two>|)|(?<three>(?<four>.)\\W*(?&three)\\W*\\k'four'|\\W*.\\W*))\\W*$/Ii\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  four    4\n  one     1\n  three   3\n  two     2\nMay match empty string\nCompile options: caseless\nOverall options: anchored caseless\nSubject length lower bound = 0\n    1221\n 0: 1221\n 1: 1221\n 2: 1\n    Satan, oscillate my metallic sonatas!\n 0: Satan, oscillate my metallic sonatas!\n 1: <unset>\n 2: <unset>\n 3: Satan, oscillate my metallic sonatas\n 4: S\n    A man, a plan, a canal: Panama!\n 0: A man, a plan, a canal: Panama!\n 1: <unset>\n 2: <unset>\n 3: A man, a plan, a canal: Panama\n 4: A\n    Able was I ere I saw Elba.\n 0: Able was I ere I saw Elba.\n 1: <unset>\n 2: <unset>\n 3: Able was I ere I saw Elba\n 4: A\n\\= Expect no match\n    The quick brown fox\nNo match\n\n/(?=(\\w+))\\1:/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nLast code unit = ':'\nSubject length lower bound = 2\n    abcd:\n 0: abcd:\n 1: abcd\n\n/(?=(?'abc'\\w+))\\k<abc>:/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  abc   1\nStarting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P \n  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z \nLast code unit = ':'\nSubject length lower bound = 2\n    abcd:\n 0: abcd:\n 1: abcd\n\n/(?'abc'a|b)(?<abc>d|e)\\k<abc>{2}/dupnames\n    adaa\n 0: adaa\n 1: a\n 2: d\n\\= Expect no match\n    addd\nNo match\n    adbb\nNo match\n\n/(?'abc'a|b)(?<abc>d|e)(?&abc){2}/dupnames\n    bdaa\n 0: bdaa\n 1: b\n 2: d\n    bdab\n 0: bdab\n 1: b\n 2: d\n\\= Expect no match\n    bddd\nNo match\n\n/(?(<bc))/\nFailed: error 142 at offset 6: syntax error in subpattern name (missing terminator?)\n\n/(?(''))/\nFailed: error 162 at offset 4: subpattern name expected\n\n/(?('R')stuff)/\nFailed: error 115 at offset 4: reference to non-existent subpattern\n\n/((abc (?(R) (?(R1)1) (?(R2)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n 0: abcabc1Xabc2XabcX\n 1: abcabc1Xabc2XabcX\n 2: abcabc1Xabc2XabcX\n\n/(?<A> (?'B' abc (?(R) (?(R&A)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\n    abcabc1Xabc2XabcXabcabc\n 0: abcabc1Xabc2XabcX\n 1: abcabc1Xabc2XabcX\n 2: abcabc1Xabc2XabcX\n\n/(?<A> (?'B' abc (?(R) (?(R&C)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x\nFailed: error 115 at offset 27: reference to non-existent subpattern\n\n/^(?(DEFINE) abc | xyz ) /x\nFailed: error 154 at offset 4: DEFINE subpattern contains more than one branch\n\n/(?(DEFINE) abc) xyz/Ix\nCapture group count = 0\nOptions: extended\nFirst code unit = 'x'\nLast code unit = 'z'\nSubject length lower bound = 3\n\n/(a|)*\\d/\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\\=ovector=0\n 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\n 1: \n\\= Expect no match\n  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\=ovector=0\nNo match\n\n/^a.b/newline=lf\n    a\\rb\n 0: a\\x0db\n\\= Expect no match\n    a\\nb\nNo match\n\n/^a.b/newline=cr\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\rb\nNo match\n\n/^a.b/newline=anycrlf\n    a\\x85b\n 0: a\\x85b\n\\= Expect no match\n    a\\rb\nNo match\n\n/^a.b/newline=any\n\\= Expect no match\n    a\\nb\nNo match\n    a\\rb\nNo match\n    a\\x85b\nNo match\n\n/^abc./gmx,newline=any\n    abc1 \\x0aabc2 \\x0babc3xx \\x0cabc4 \\x0dabc5xx \\x0d\\x0aabc6 \\x85abc7 JUNK\n 0: abc1\n 0: abc2\n 0: abc3\n 0: abc4\n 0: abc5\n 0: abc6\n 0: abc7\n\n/abc.$/gmx,newline=any\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc7 abc9\n 0: abc1\n 0: abc2\n 0: abc3\n 0: abc4\n 0: abc5\n 0: abc6\n 0: abc9\n\n/^a\\Rb/bsr=unicode\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x0bb\n 0: a\\x0bb\n    a\\x0cb\n 0: a\\x0cb\n    a\\x85b\n 0: a\\x85b\n\\= Expect no match\n    a\\n\\rb\nNo match\n\n/^a\\R*b/bsr=unicode\n    ab\n 0: ab\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x0bb\n 0: a\\x0bb\n    a\\x0cb\n 0: a\\x0cb\n    a\\x85b\n 0: a\\x85b\n    a\\n\\rb\n 0: a\\x0a\\x0db\n    a\\n\\r\\x85\\x0cb\n 0: a\\x0a\\x0d\\x85\\x0cb\n\n/^a\\R+b/bsr=unicode\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x0bb\n 0: a\\x0bb\n    a\\x0cb\n 0: a\\x0cb\n    a\\x85b\n 0: a\\x85b\n    a\\n\\rb\n 0: a\\x0a\\x0db\n    a\\n\\r\\x85\\x0cb\n 0: a\\x0a\\x0d\\x85\\x0cb\n\\= Expect no match\n    ab\nNo match\n\n/^a\\R{1,3}b/bsr=unicode\n    a\\nb\n 0: a\\x0ab\n    a\\n\\rb\n 0: a\\x0a\\x0db\n    a\\n\\r\\x85b\n 0: a\\x0a\\x0d\\x85b\n    a\\r\\n\\r\\nb\n 0: a\\x0d\\x0a\\x0d\\x0ab\n    a\\r\\n\\r\\n\\r\\nb\n 0: a\\x0d\\x0a\\x0d\\x0a\\x0d\\x0ab\n    a\\n\\r\\n\\rb\n 0: a\\x0a\\x0d\\x0a\\x0db\n    a\\n\\n\\r\\nb\n 0: a\\x0a\\x0a\\x0d\\x0ab\n\\= Expect no match\n    a\\n\\n\\n\\rb\nNo match\n    a\\r\nNo match\n\n/(?&abc)X(?<abc>P)/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nLast code unit = 'P'\nSubject length lower bound = 3\n    abcPXP123\n 0: PXP\n 1: P\n\n/(?1)X(?<abc>P)/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nLast code unit = 'P'\nSubject length lower bound = 3\n    abcPXP123\n 0: PXP\n 1: P\n\n/(?:a(?&abc)b)*(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n    123axbaxbaxb456\n 0: x\n 1: x\n\n/(?:a(?&abc)b){1,5}(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n\n/(?:a(?&abc)b){2,5}(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n\n/(?:a(?&abc)b){2,}(?<abc>x)/\n    123axbaxbaxbx456\n 0: axbaxbaxbx\n 1: x\n\n/(abc)(?i:(?1))/\n    defabcabcxyz\n 0: abcabc\n 1: abc\n\\= Expect no match\n    DEFabcABCXYZ\nNo match\n\n/(abc)(?:(?i)(?1))/\n    defabcabcxyz\n 0: abcabc\n 1: abc\n\\= Expect no match\n    DEFabcABCXYZ\nNo match\n\n/^(a)\\g-2/\nFailed: error 115 at offset 8: reference to non-existent subpattern\n\n/^(a)\\g/\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/^(a)\\g{0}/\nFailed: error 115 at offset 9: reference to non-existent subpattern\n\n/^(a)\\g{3/\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/^(a)\\g{aa}/\nFailed: error 115 at offset 7: reference to non-existent subpattern\n\n/^a.b/newline=lf\n    a\\rb\n 0: a\\x0db\n\\= Expect no match\n    a\\nb\nNo match\n\n/.+foo/\n    afoo\n 0: afoo\n\\= Expect no match\n    \\r\\nfoo\nNo match\n    \\nfoo\nNo match\n\n/.+foo/newline=crlf\n    afoo\n 0: afoo\n    \\nfoo\n 0: \\x0afoo\n\\= Expect no match\n    \\r\\nfoo\nNo match\n\n/.+foo/newline=any\n    afoo\n 0: afoo\n\\= Expect no match\n    \\nfoo\nNo match\n    \\r\\nfoo\nNo match\n\n/.+foo/s\n    afoo\n 0: afoo\n    \\r\\nfoo\n 0: \\x0d\\x0afoo\n    \\nfoo\n 0: \\x0afoo\n\n/^$/gm,newline=any\n    abc\\r\\rxyz\n 0: \n    abc\\n\\rxyz\n 0: \n\\= Expect no match\n    abc\\r\\nxyz\nNo match\n\n/(?m)^$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n 0: \n 0+ \\x0d\\x0a\n\n/(?m)^$|^\\r\\n/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n 0: \n 0+ \\x0d\\x0a\n 0: \\x0d\\x0a\n 0+ \n\n/(?m)$/g,newline=any,aftertext\n    abc\\r\\n\\r\\n\n 0: \n 0+ \\x0d\\x0a\\x0d\\x0a\n 0: \n 0+ \\x0d\\x0a\n 0: \n 0+ \n\n/abc.$/gmx,newline=anycrlf\n    abc1\\x0a abc2\\x0b abc3\\x0c abc4\\x0d abc5\\x0d\\x0a abc6\\x85 abc9\n 0: abc1\n 0: abc4\n 0: abc5\n 0: abc9\n\n/^X/m\n    XABC\n 0: X\n\\= Expect no match\n    XABC\\=notbol\nNo match\n\n/(ab|c)(?-1)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        ab\n        Alt\n        c\n        Ket\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n    abc\n 0: abc\n 1: ab\n\n/xy(?+1)(abc)/B\n------------------------------------------------------------------\n        Bra\n        xy\n        Recurse\n        CBra 1\n        abc\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    xyabcabc\n 0: xyabcabc\n 1: abc\n\\= Expect no match\n    xyabc\nNo match\n\n/x(?-0)y/\nFailed: error 126 at offset 5: a relative value of zero is not allowed\n\n/x(?-1)y/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/x(?+0)y/\nFailed: error 126 at offset 5: a relative value of zero is not allowed\n\n/x(?+1)y/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/^(abc)?(?(-1)X|Y)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Brazero\n        CBra 1\n        abc\n        Ket\n        Cond\n      1 Cond ref\n        X\n        Alt\n        Y\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    abcX\n 0: abcX\n 1: abc\n    Y\n 0: Y\n\\= Expect no match\n    abcY\nNo match\n\n/^((?(+1)X|Y)(abc))+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        Cond\n      2 Cond ref\n        X\n        Alt\n        Y\n        Ket\n        CBra 2\n        abc\n        Ket\n        KetRmax\n        Ket\n        End\n------------------------------------------------------------------\n    YabcXabc\n 0: YabcXabc\n 1: Xabc\n 2: abc\n    YabcXabcXabc\n 0: YabcXabcXabc\n 1: Xabc\n 2: abc\n\\= Expect no match\n    XabcXabc\nNo match\n\n/(?(-1)a)/B\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/((?(-1)a))/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Cond\n      1 Cond ref\n        a\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/((?(-2)a))/B\nFailed: error 115 at offset 6: reference to non-existent subpattern\n\n/^(?(+1)X|Y)(.)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Cond\n      1 Cond ref\n        X\n        Alt\n        Y\n        Ket\n        CBra 1\n        Any\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    Y!\n 0: Y!\n 1: !\n\n/(?<A>tom|bon)-\\k{A}/\n    tom-tom\n 0: tom-tom\n 1: tom\n    bon-bon\n 0: bon-bon\n 1: bon\n\\= Expect no match\n    tom-bon\nNo match\n\n/\\g{A/\nFailed: error 142 at offset 4: syntax error in subpattern name (missing terminator?)\n\n/(?|(abc)|(xyz))/B\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        abc\n        Ket\n        Alt\n        CBra 1\n        xyz\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n   >abc<\n 0: abc\n 1: abc\n   >xyz<\n 0: xyz\n 1: xyz\n\n/(x)(?|(abc)|(xyz))(x)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        x\n        Ket\n        Bra\n        CBra 2\n        abc\n        Ket\n        Alt\n        CBra 2\n        xyz\n        Ket\n        Ket\n        CBra 3\n        x\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    xabcx\n 0: xabcx\n 1: x\n 2: abc\n 3: x\n    xxyzx\n 0: xxyzx\n 1: x\n 2: xyz\n 3: x\n\n/(x)(?|(abc)(pqr)|(xyz))(x)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        x\n        Ket\n        Bra\n        CBra 2\n        abc\n        Ket\n        CBra 3\n        pqr\n        Ket\n        Alt\n        CBra 2\n        xyz\n        Ket\n        Ket\n        CBra 4\n        x\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    xabcpqrx\n 0: xabcpqrx\n 1: x\n 2: abc\n 3: pqr\n 4: x\n    xxyzx\n 0: xxyzx\n 1: x\n 2: xyz\n 3: <unset>\n 4: x\n\n/\\H++X/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n        X\n        Ket\n        End\n------------------------------------------------------------------\n\\= Expect no match\n    XXXX\nNo match\n\n/\\H+\\hY/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n        \\h\n        Y\n        Ket\n        End\n------------------------------------------------------------------\n    XXXX Y\n 0: XXXX Y\n\n/\\H+ Y/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n         Y\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\h+A/B\n------------------------------------------------------------------\n        Bra\n        \\h++\n        A\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\v*B/B\n------------------------------------------------------------------\n        Bra\n        \\v*+\n        B\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\V+\\x0a/B\n------------------------------------------------------------------\n        Bra\n        \\V++\n        \\x0a\n        Ket\n        End\n------------------------------------------------------------------\n\n/A+\\h/B\n------------------------------------------------------------------\n        Bra\n        A++\n        \\h\n        Ket\n        End\n------------------------------------------------------------------\n\n/ *\\H/B\n------------------------------------------------------------------\n        Bra\n         *+\n        \\H\n        Ket\n        End\n------------------------------------------------------------------\n\n/A*\\v/B\n------------------------------------------------------------------\n        Bra\n        A*+\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\x0b*\\V/B\n------------------------------------------------------------------\n        Bra\n        \\x0b*+\n        \\V\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d+\\h/B\n------------------------------------------------------------------\n        Bra\n        \\d++\n        \\h\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\v/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/S+\\h\\S+\\v/B\n------------------------------------------------------------------\n        Bra\n        S++\n        \\h\n        \\S++\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w{3,}\\h\\w+\\v/B\n------------------------------------------------------------------\n        Bra\n        \\w{3}\n        \\w*+\n        \\h\n        \\w++\n        \\v\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\h+\\d\\h+\\w\\h+\\S\\h+\\H/B\n------------------------------------------------------------------\n        Bra\n        \\h++\n        \\d\n        \\h++\n        \\w\n        \\h++\n        \\S\n        \\h++\n        \\H\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\v+\\d\\v+\\w\\v+\\S\\v+\\V/B\n------------------------------------------------------------------\n        Bra\n        \\v++\n        \\d\n        \\v++\n        \\w\n        \\v++\n        \\S\n        \\v++\n        \\V\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\H+\\h\\H+\\d/B\n------------------------------------------------------------------\n        Bra\n        \\H++\n        \\h\n        \\H+\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\V+\\v\\V+\\w/B\n------------------------------------------------------------------\n        Bra\n        \\V++\n        \\v\n        \\V+\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\( (?: [^()]* | (?R) )* \\)/x\n(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\\=jitstack=1024\n 0: (0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\n\n/[\\E]AAA/\nFailed: error 106 at offset 7: missing terminating ] for character class\n\n/[\\Q\\E]AAA/\nFailed: error 106 at offset 9: missing terminating ] for character class\n\n/[^\\E]AAA/\nFailed: error 106 at offset 8: missing terminating ] for character class\n\n/[^\\Q\\E]AAA/\nFailed: error 106 at offset 10: missing terminating ] for character class\n\n/[\\E^]AAA/\nFailed: error 106 at offset 8: missing terminating ] for character class\n\n/[\\Q\\E^]AAA/\nFailed: error 106 at offset 10: missing terminating ] for character class\n\n/A(*PRUNE)B(*SKIP)C(*THEN)D(*COMMIT)E(*F)F(*FAIL)G(?!)H(*ACCEPT)I/B\n------------------------------------------------------------------\n        Bra\n        A\n        *PRUNE\n        B\n        *SKIP\n        C\n        *THEN\n        D\n        *COMMIT\n        E\n        *FAIL\n        F\n        *FAIL\n        G\n        *FAIL\n        H\n        *ACCEPT\n        I\n        Ket\n        End\n------------------------------------------------------------------\n\n/^a+(*FAIL)/auto_callout\n\\= Expect no match\n    aaaaaa\n--->aaaaaa\n +0 ^          ^\n +1 ^          a+\n +3 ^     ^    (*FAIL)\n +3 ^    ^     (*FAIL)\n +3 ^   ^      (*FAIL)\n +3 ^  ^       (*FAIL)\n +3 ^ ^        (*FAIL)\n +3 ^^         (*FAIL)\nNo match\n\n/a+b?c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       c+\n +6 ^      ^    (*FAIL)\n +6 ^     ^     (*FAIL)\n +6 ^    ^      (*FAIL)\n +0  ^          a+\n +2  ^ ^        b?\n +4  ^  ^       c+\n +6  ^     ^    (*FAIL)\n +6  ^    ^     (*FAIL)\n +6  ^   ^      (*FAIL)\n +0   ^         a+\n +2   ^^        b?\n +4   ^ ^       c+\n +6   ^    ^    (*FAIL)\n +6   ^   ^     (*FAIL)\n +6   ^  ^      (*FAIL)\nNo match\n\n/a+b?(*PRUNE)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       (*PRUNE)\n+12 ^   ^       c+\n+14 ^      ^    (*FAIL)\n+14 ^     ^     (*FAIL)\n+14 ^    ^      (*FAIL)\n +0  ^          a+\n +2  ^ ^        b?\n +4  ^  ^       (*PRUNE)\n+12  ^  ^       c+\n+14  ^     ^    (*FAIL)\n+14  ^    ^     (*FAIL)\n+14  ^   ^      (*FAIL)\n +0   ^         a+\n +2   ^^        b?\n +4   ^ ^       (*PRUNE)\n+12   ^ ^       c+\n+14   ^    ^    (*FAIL)\n+14   ^   ^     (*FAIL)\n+14   ^  ^      (*FAIL)\nNo match\n\n/a+b?(*COMMIT)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       (*COMMIT)\n+13 ^   ^       c+\n+15 ^      ^    (*FAIL)\n+15 ^     ^     (*FAIL)\n+15 ^    ^      (*FAIL)\nNo match\n\n/a+b?(*SKIP)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabcccaaabccc\n--->aaabcccaaabccc\n +0 ^                  a+\n +2 ^  ^               b?\n +4 ^   ^              (*SKIP)\n+11 ^   ^              c+\n+13 ^      ^           (*FAIL)\n+13 ^     ^            (*FAIL)\n+13 ^    ^             (*FAIL)\n +0        ^           a+\n +2        ^  ^        b?\n +4        ^   ^       (*SKIP)\n+11        ^   ^       c+\n+13        ^      ^    (*FAIL)\n+13        ^     ^     (*FAIL)\n+13        ^    ^      (*FAIL)\nNo match\n\n/a+b?(*THEN)c+(*FAIL)/auto_callout\n\\= Expect no match\n    aaabccc\n--->aaabccc\n +0 ^           a+\n +2 ^  ^        b?\n +4 ^   ^       (*THEN)\n+11 ^   ^       c+\n+13 ^      ^    (*FAIL)\n+13 ^     ^     (*FAIL)\n+13 ^    ^      (*FAIL)\n +0  ^          a+\n +2  ^ ^        b?\n +4  ^  ^       (*THEN)\n+11  ^  ^       c+\n+13  ^     ^    (*FAIL)\n+13  ^    ^     (*FAIL)\n+13  ^   ^      (*FAIL)\n +0   ^         a+\n +2   ^^        b?\n +4   ^ ^       (*THEN)\n+11   ^ ^       c+\n+13   ^    ^    (*FAIL)\n+13   ^   ^     (*FAIL)\n+13   ^  ^      (*FAIL)\nNo match\n\n/a(*MARK)b/\nFailed: error 166 at offset 7: (*MARK) must have an argument\n\n/\\g6666666666/\nFailed: error 161 at offset 7: subpattern number is too big\n\n/[\\g6666666666]/B\n------------------------------------------------------------------\n        Bra\n        [6g]\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?1)\\c[/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/.+A/newline=crlf\n\\= Expect no match\n    \\r\\nA\nNo match\n\n/\\nA/newline=crlf\n    \\r\\nA\n 0: \\x0aA\n\n/[\\r\\n]A/newline=crlf\n    \\r\\nA\n 0: \\x0aA\n\n/(\\r|\\n)A/newline=crlf\n    \\r\\nA\n 0: \\x0aA\n 1: \\x0a\n\n/a(*CR)b/\nFailed: error 160 at offset 5: (*VERB) not recognized or malformed\n\n/(*CR)a.b/\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\rb\nNo match\n\n/(*CR)a.b/newline=lf\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\rb\nNo match\n\n/(*LF)a.b/newline=CRLF\n    a\\rb\n 0: a\\x0db\n\\= Expect no match\n    a\\nb\nNo match\n\n/(*CRLF)a.b/\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    a\\r\\nb\nNo match\n\n/(*ANYCRLF)a.b/newline=CR\n\\= Expect no match\n    a\\rb\nNo match\n    a\\nb\nNo match\n    a\\r\\nb\nNo match\n\n/(*ANY)a.b/newline=cr\n\\= Expect no match\n    a\\rb\nNo match\n    a\\nb\nNo match\n    a\\r\\nb\nNo match\n    a\\x85b\nNo match\n\n/(*ANY).*/g\n    abc\\r\\ndef\n 0: abc\n 0: \n 0: def\n 0: \n\n/(*ANYCRLF).*/g\n    abc\\r\\ndef\n 0: abc\n 0: \n 0: def\n 0: \n\n/(*CRLF).*/g\n    abc\\r\\ndef\n 0: abc\n 0: \n 0: def\n 0: \n\n/(*NUL)^.*/\n    a\\nb\\x00ccc\n 0: a\\x0ab\n\n/(*NUL)^.*/s\n    a\\nb\\x00ccc\n 0: a\\x0ab\\x00ccc\n\n/^x/m,newline=NUL\n    ab\\x00xy\n 0: x\n\n/'#comment' 0d 0a 00 '^x\\' 0a 'y'/x,newline=nul,hex\n    x\\nyz\n 0: x\\x0ay\n\n/(*NUL)^X\\NY/\n    X\\nY\n 0: X\\x0aY\n    X\\rY\n 0: X\\x0dY\n\\= Expect no match\n    X\\x00Y\nNo match\n\n/a\\Rb/I,bsr=anycrlf\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n\\= Expect no match\n    a\\x85b\nNo match\n    a\\x0bb\nNo match\n\n/a\\Rb/I,bsr=unicode\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x85b\n 0: a\\x85b\n    a\\x0bb\n 0: a\\x0bb\n\n/a\\R?b/I,bsr=anycrlf\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n\\= Expect no match\n    a\\x85b\nNo match\n    a\\x0bb\nNo match\n\n/a\\R?b/I,bsr=unicode\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    a\\rb\n 0: a\\x0db\n    a\\nb\n 0: a\\x0ab\n    a\\r\\nb\n 0: a\\x0d\\x0ab\n    a\\x85b\n 0: a\\x85b\n    a\\x0bb\n 0: a\\x0bb\n\n/a\\R{2,4}b/I,bsr=anycrlf\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 4\n    a\\r\\n\\nb\n 0: a\\x0d\\x0a\\x0ab\n    a\\n\\r\\rb\n 0: a\\x0a\\x0d\\x0db\n    a\\r\\n\\r\\n\\r\\n\\r\\nb\n 0: a\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\\x0d\\x0ab\n\\= Expect no match\n    a\\x85\\x85b\nNo match\n    a\\x0b\\x0bb\nNo match\n\n/a\\R{2,4}b/I,bsr=unicode\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 4\n    a\\r\\rb\n 0: a\\x0d\\x0db\n    a\\n\\n\\nb\n 0: a\\x0a\\x0a\\x0ab\n    a\\r\\n\\n\\r\\rb\n 0: a\\x0d\\x0a\\x0a\\x0d\\x0db\n    a\\x85\\x85b\n 0: a\\x85\\x85b\n    a\\x0b\\x0bb\n 0: a\\x0b\\x0bb\n\\= Expect no match\n    a\\r\\r\\r\\r\\rb\nNo match\n\n/(*BSR_ANYCRLF)a\\Rb/I\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n\n/(*BSR_UNICODE)a\\Rb/I\nCapture group count = 0\n\\R matches any Unicode newline\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\x85b\n 0: a\\x85b\n\n/(*BSR_ANYCRLF)(*CRLF)a\\Rb/I\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nForced newline is CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\nb\n 0: a\\x0ab\n    a\\rb\n 0: a\\x0db\n\n/(*CRLF)(*BSR_UNICODE)a\\Rb/I\nCapture group count = 0\n\\R matches any Unicode newline\nForced newline is CRLF\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 3\n    a\\x85b\n 0: a\\x85b\n\n/(*CRLF)(*BSR_ANYCRLF)(*CR)ab/I\nCapture group count = 0\n\\R matches CR, LF, or CRLF\nForced newline is CR\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?<a>)(?&)/\nFailed: error 162 at offset 9: subpattern name expected\n\n/(?<abc>)(?&a)/\nFailed: error 115 at offset 11: reference to non-existent subpattern\n\n/(?<a>)(?&aaaaaaaaaaaaaaaaaaaaaaa)/\nFailed: error 115 at offset 9: reference to non-existent subpattern\n\n/(?+-a)/\nFailed: error 129 at offset 2: digit expected after (?+ or (?-\n\n/(?-+a)/\nFailed: error 111 at offset 3: unrecognized character after (? or (?-\n\n/(?(-1))/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n\n/(?(+10))/\nFailed: error 115 at offset 4: reference to non-existent subpattern\n\n/(?(10))/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n\n/(?(+2))()()/\n\n/(?(2))()()/\n\n/\\k''/\nFailed: error 162 at offset 3: subpattern name expected\n\n/\\k<>/\nFailed: error 162 at offset 3: subpattern name expected\n\n/\\k{}/\nFailed: error 162 at offset 3: subpattern name expected\n\n/\\k/\nFailed: error 169 at offset 2: \\k is not followed by a braced, angle-bracketed, or quoted name\n\n/\\kabc/\nFailed: error 169 at offset 2: \\k is not followed by a braced, angle-bracketed, or quoted name\n\n/(?P=)/\nFailed: error 162 at offset 4: subpattern name expected\n\n/(?P>)/\nFailed: error 162 at offset 4: subpattern name expected\n\n/[[:foo:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:1234:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:f\\oo:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[: :]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:...:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:l\\ower:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[[:abc\\:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/[abc[:x\\]pqr:]]/\nFailed: error 130 at offset 6: unknown POSIX class name\n\n/[[:a\\dz:]]/\nFailed: error 130 at offset 3: unknown POSIX class name\n\n/(^(a|b\\g<-1'c))/\nFailed: error 157 at offset 8: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/^(?+1)(?<a>x|y){0}z/\n    xzxx\n 0: xz\n    yzyy\n 0: yz\n\\= Expect no match\n    xxz\nNo match\n\n/(\\3)(\\1)(a)/\n\\= Expect no match\n    cat\nNo match\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n 0: a\n 1: \n 2: \n 3: a\n\n/TA]/\n    The ACTA] comes\n 0: TA]\n\n/TA]/allow_empty_class,match_unset_backref,dupnames\n    The ACTA] comes\n 0: TA]\n\n/(?2)[]a()b](abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n    abcbabc\n\n/(?2)[^]a()b](abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n    abcbabc\n\n/(?1)[]a()b](abc)/\n    abcbabc\n 0: abcbabc\n 1: abc\n\\= Expect no match\n    abcXabc\nNo match\n\n/(?1)[^]a()b](abc)/\n    abcXabc\n 0: abcXabc\n 1: abc\n\\= Expect no match\n    abcbabc\nNo match\n\n/(?2)[]a()b](abc)(xyz)/\n    xyzbabcxyz\n 0: xyzbabcxyz\n 1: abc\n 2: xyz\n\n/(?&N)[]a(?<N>)](?<M>abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n   abc<abc\n\n/(?&N)[]a(?<N>)](abc)/\nFailed: error 115 at offset 3: reference to non-existent subpattern\n   abc<abc\n\n/a[]b/\nFailed: error 106 at offset 4: missing terminating ] for character class\n\n/a[^]b/\nFailed: error 106 at offset 5: missing terminating ] for character class\n\n/a[]b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\nNo match\n\n/a[]+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\nNo match\n\n/a[]*+b/allow_empty_class,match_unset_backref,dupnames\n\\= Expect no match\n    ab\nNo match\n\n/a[^]b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n 0: aXb\n    a\\nb\n 0: a\\x0ab\n\\= Expect no match\n    ab\nNo match\n\n/a[^]+b/allow_empty_class,match_unset_backref,dupnames\n    aXb\n 0: aXb\n    a\\nX\\nXb\n 0: a\\x0aX\\x0aXb\n\\= Expect no match\n    ab\nNo match\n\n/a(?!)b/B\n------------------------------------------------------------------\n        Bra\n        a\n        *FAIL\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?!)?a/B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Assert not\n        Ket\n        a\n        Ket\n        End\n------------------------------------------------------------------\n    ab\n 0: a\n\n/a(*FAIL)+b/\nFailed: error 109 at offset 8: quantifier does not follow a repeatable item\n\n/(abc|pqr|123){0}[xyz]/I\nCapture group count = 1\nStarting code units: x y z \nSubject length lower bound = 1\n\n/(?(?=.*b)b|^)/I,auto_callout\nCapture group count = 0\nMay match empty string\nOptions: auto_callout\nSubject length lower bound = 0\n   adc\n--->adc\n +0 ^       (?\n +2 ^       (?=\n +5 ^       .*\n +7 ^  ^    b\n +7 ^ ^     b\n +7 ^^      b\n +7 ^       b\n+11 ^       ^\n+12 ^       )\n+13 ^       End of pattern\n 0: \n   abc\n--->abc\n +0 ^       (?\n +2 ^       (?=\n +5 ^       .*\n +7 ^  ^    b\n +7 ^ ^     b\n +7 ^^      b\n +8 ^ ^     )\n +9 ^       b\n +0  ^      (?\n +2  ^      (?=\n +5  ^      .*\n +7  ^ ^    b\n +7  ^^     b\n +7  ^      b\n +8  ^^     )\n +9  ^      b\n+10  ^^     |\n+13  ^^     End of pattern\n 0: b\n\n/(?(?=b).*b|^d)/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/(?(?=.*b).*b|^d)/I\nCapture group count = 0\nSubject length lower bound = 1\n\n/xyz/auto_callout\n  xyz\n--->xyz\n +0 ^       x\n +1 ^^      y\n +2 ^ ^     z\n +3 ^  ^    End of pattern\n 0: xyz\n  abcxyz\n--->abcxyz\n +0    ^       x\n +1    ^^      y\n +2    ^ ^     z\n +3    ^  ^    End of pattern\n 0: xyz\n\\= Expect no match\n  abc\nNo match\n  abcxypqr\nNo match\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n--->abcxyz\n +0 ^          x\n +0  ^         x\n +0   ^        x\n +0    ^       x\n +1    ^^      y\n +2    ^ ^     z\n +3    ^  ^    End of pattern\n 0: xyz\n\\= Expect no match\n  abc\n--->abc\n +0 ^       x\n +0  ^      x\n +0   ^     x\n +0    ^    x\nNo match\n  abcxypqr\n--->abcxypqr\n +0 ^            x\n +0  ^           x\n +0   ^          x\n +0    ^         x\n +1    ^^        y\n +2    ^ ^       z\n +0     ^        x\n +0      ^       x\n +0       ^      x\n +0        ^     x\n +0         ^    x\nNo match\n\n/(*NO_START_OPT)xyz/auto_callout\n  abcxyz\n--->abcxyz\n+15 ^          x\n+15  ^         x\n+15   ^        x\n+15    ^       x\n+16    ^^      y\n+17    ^ ^     z\n+18    ^  ^    End of pattern\n 0: xyz\n\n/(*NO_AUTO_POSSESS)a+b/B\n------------------------------------------------------------------\n        Bra\n        a+\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/xyz/auto_callout,no_start_optimize\n  abcxyz\n--->abcxyz\n +0 ^          x\n +0  ^         x\n +0   ^        x\n +0    ^       x\n +1    ^^      y\n +2    ^ ^     z\n +3    ^  ^    End of pattern\n 0: xyz\n\n/^\"((?(?=[a])[^\"])|b)*\"$/auto_callout\n    \"ab\"\n--->\"ab\"\n +0 ^        ^\n +1 ^        \"\n +2 ^^       (\n +3 ^^       (?\n +5 ^^       (?=\n +8 ^^       [a]\n+11 ^ ^      )\n+12 ^^       [^\"]\n+16 ^ ^      )\n+17 ^ ^      |\n +3 ^ ^      (?\n +5 ^ ^      (?=\n +8 ^ ^      [a]\n+17 ^ ^      |\n+21 ^ ^      \"\n+18 ^ ^      b\n+19 ^  ^     )*\n +3 ^  ^     (?\n +5 ^  ^     (?=\n +8 ^  ^     [a]\n+17 ^  ^     |\n+21 ^  ^     \"\n+22 ^   ^    $\n+23 ^   ^    End of pattern\n 0: \"ab\"\n 1: \n\n/^\"((?(?=[a])[^\"])|b)*\"$/\n    \"ab\"\n 0: \"ab\"\n 1: \n\n/^X(?5)(a)(?|(b)|(q))(c)(d)Y/\nFailed: error 115 at offset 5: reference to non-existent subpattern\n    XYabcdY\n\n/^X(?&N)(a)(?|(b)|(q))(c)(d)(?<N>Y)/\n    XYabcdY\n 0: XYabcdY\n 1: a\n 2: b\n 3: c\n 4: d\n 5: Y\n\n/Xa{2,4}b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/Xa{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/Xa{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X\\d{2,4}b/\n    X\\=ps\nPartial match: X\n    X3\\=ps\nPartial match: X3\n    X33\\=ps\nPartial match: X33\n    X333\\=ps\nPartial match: X333\n    X3333\\=ps\nPartial match: X3333\n\n/X\\d{2,4}?b/\n    X\\=ps\nPartial match: X\n    X3\\=ps\nPartial match: X3\n    X33\\=ps\nPartial match: X33\n    X333\\=ps\nPartial match: X333\n    X3333\\=ps\nPartial match: X3333\n\n/X\\d{2,4}+b/\n    X\\=ps\nPartial match: X\n    X3\\=ps\nPartial match: X3\n    X33\\=ps\nPartial match: X33\n    X333\\=ps\nPartial match: X333\n    X3333\\=ps\nPartial match: X3333\n\n/X\\D{2,4}b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X\\D{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X\\D{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[abc]{2,4}b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[abc]{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[abc]{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xa\\=ps\nPartial match: Xa\n    Xaa\\=ps\nPartial match: Xaa\n    Xaaa\\=ps\nPartial match: Xaaa\n    Xaaaa\\=ps\nPartial match: Xaaaa\n\n/X[^a]{2,4}b/\n    X\\=ps\nPartial match: X\n    Xz\\=ps\nPartial match: Xz\n    Xzz\\=ps\nPartial match: Xzz\n    Xzzz\\=ps\nPartial match: Xzzz\n    Xzzzz\\=ps\nPartial match: Xzzzz\n\n/X[^a]{2,4}?b/\n    X\\=ps\nPartial match: X\n    Xz\\=ps\nPartial match: Xz\n    Xzz\\=ps\nPartial match: Xzz\n    Xzzz\\=ps\nPartial match: Xzzz\n    Xzzzz\\=ps\nPartial match: Xzzzz\n\n/X[^a]{2,4}+b/\n    X\\=ps\nPartial match: X\n    Xz\\=ps\nPartial match: Xz\n    Xzz\\=ps\nPartial match: Xzz\n    Xzzz\\=ps\nPartial match: Xzzz\n    Xzzzz\\=ps\nPartial match: Xzzzz\n\n/(Y)X\\1{2,4}b/\n    YX\\=ps\nPartial match: YX\n    YXY\\=ps\nPartial match: YXY\n    YXYY\\=ps\nPartial match: YXYY\n    YXYYY\\=ps\nPartial match: YXYYY\n    YXYYYY\\=ps\nPartial match: YXYYYY\n\n/(Y)X\\1{2,4}?b/\n    YX\\=ps\nPartial match: YX\n    YXY\\=ps\nPartial match: YXY\n    YXYY\\=ps\nPartial match: YXYY\n    YXYYY\\=ps\nPartial match: YXYYY\n    YXYYYY\\=ps\nPartial match: YXYYYY\n\n/(Y)X\\1{2,4}+b/\n    YX\\=ps\nPartial match: YX\n    YXY\\=ps\nPartial match: YXY\n    YXYY\\=ps\nPartial match: YXYY\n    YXYYY\\=ps\nPartial match: YXYYY\n    YXYYYY\\=ps\nPartial match: YXYYYY\n\n/\\++\\KZ|\\d+X|9+Y/startchar\n    ++++123999\\=ps\nPartial match: 123999\n    ++++123999Y\\=ps\n 0: 999Y\n    ++++Z1234\\=ps\n 0: ++++Z\n    ^^^^\n\n/Z(*F)/\n\\= Expect no match\n    Z\\=ps\nNo match\n    ZA\\=ps\nNo match\n\n/Z(?!)/\n\\= Expect no match\n    Z\\=ps\nNo match\n    ZA\\=ps\nNo match\n\n/dog(sbody)?/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\nPartial match: dogs\n\n/dog(sbody)??/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\n 0: dog\n\n/dog|dogsbody/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\n 0: dog\n\n/dogsbody|dog/\n    dogs\\=ps\n 0: dog\n    dogs\\=ph\nPartial match: dogs\n\n/\\bthe cat\\b/\n    the cat\\=ps\n 0: the cat\n    the cat\\=ph\nPartial match: the cat\n\n/abc/\n   abc\\=ps\n 0: abc\n   abc\\=ph\n 0: abc\n\n/abc\\K123/startchar\n    xyzabc123pqr\n 0: abc123\n    ^^^\n    xyzabc12\\=ps\nPartial match: abc12\n    xyzabc12\\=ph\nPartial match: abc12\n\n/(?<=abc)123/\n    xyzabc123pqr\n 0: 123\n    xyzabc12\\=ps\nPartial match: 12\n    xyzabc12\\=ph\nPartial match: 12\n\n/\\babc\\b/\n    +++abc+++\n 0: abc\n    +++ab\\=ps\nPartial match: ab\n    +++ab\\=ph\nPartial match: ab\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^m][^>]>[^<])(?<word>\\w*+))/B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        Cond\n        Cond false\n        CBra 1\n        <\n        [^m]\n        [^>]\n        >\n        [^<]\n        Ket\n        CBra 2\n        \\w*+\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?&word)(?&element)(?(DEFINE)(?<element><[^\\d][^>]>[^<])(?<word>\\w*+))/B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        Cond\n        Cond false\n        CBra 1\n        <\n        [\\x00-/:-\\xff] (neg)\n        [^>]\n        >\n        [^<]\n        Ket\n        CBra 2\n        \\w*+\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(ab)(x(y)z(cd(*ACCEPT)))pq/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        ab\n        Ket\n        CBra 2\n        x\n        CBra 3\n        y\n        Ket\n        z\n        CBra 4\n        cd\n        Close 4\n        Close 2\n        *ACCEPT\n        Ket\n        Ket\n        pq\n        Ket\n        End\n------------------------------------------------------------------\n\n/abc\\K/aftertext,startchar\n    abcdef\n 0: abc\n    ^^^\n 0+ def\n    abcdef\\=notempty_atstart\n 0: abc\n    ^^^\n 0+ def\n    xyzabcdef\\=notempty_atstart\n 0: abc\n    ^^^\n 0+ def\n\\= Expect no match\n    abcdef\\=notempty\nNo match\n    xyzabcdef\\=notempty\nNo match\n\n/^(?:(?=abc)|abc\\K)/aftertext,startchar\n    abcdef\n 0: \n 0+ abcdef\n    abcdef\\=notempty_atstart\n 0: abc\n    ^^^\n 0+ def\n\\= Expect no match\n    abcdef\\=notempty\nNo match\n\n/a?b?/aftertext\n    xyz\n 0: \n 0+ xyz\n    xyzabc\n 0: \n 0+ xyzabc\n    xyzabc\\=notempty\n 0: ab\n 0+ c\n    xyzabc\\=notempty_atstart\n 0: \n 0+ yzabc\n    xyz\\=notempty_atstart\n 0: \n 0+ yz\n\\= Expect no match\n    xyz\\=notempty\nNo match\n\n/^a?b?/aftertext\n    xyz\n 0: \n 0+ xyz\n    xyzabc\n 0: \n 0+ xyzabc\n\\= Expect no match\n    xyzabc\\=notempty\nNo match\n    xyzabc\\=notempty_atstart\nNo match\n    xyz\\=notempty_atstart\nNo match\n    xyz\\=notempty\nNo match\n\n/^(?<name>a|b\\g<name>c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(?<name>a|b\\g'name'c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(a|b\\g<1>c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(a|b\\g'1'c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/^(a|b\\g'-1'c)/\n    aaaa\n 0: a\n 1: a\n    bacxxx\n 0: bac\n 1: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n\n/(^(a|b\\g<-1>c))/\n    aaaa\n 0: a\n 1: a\n 2: a\n    bacxxx\n 0: bac\n 1: bac\n 2: bac\n    bbaccxxx\n 0: bbacc\n 1: bbacc\n 2: bbacc\n    bbbacccxx\n 0: bbbaccc\n 1: bbbaccc\n 2: bbbaccc\n\n/(?-i:\\g<name>)(?i:(?<name>a))/\n    XaaX\n 0: aa\n 1: a\n    XAAX\n 0: AA\n 1: A\n\n/(?i:\\g<name>)(?-i:(?<name>a))/\n    XaaX\n 0: aa\n 1: a\n\\= Expect no match\n    XAAX\nNo match\n\n/(?-i:\\g<+1>)(?i:(a))/\n    XaaX\n 0: aa\n 1: a\n    XAAX\n 0: AA\n 1: A\n\n/(?=(?<regex>(?#simplesyntax)\\$(?<name>[a-zA-Z_\\x{7f}-\\x{ff}][a-zA-Z0-9_\\x{7f}-\\x{ff}]*)(?:\\[(?<index>[a-zA-Z0-9_\\x{7f}-\\x{ff}]+|\\$\\g<name>)\\]|->\\g<name>(\\(.*?\\))?)?|(?#simple syntax withbraces)\\$\\{(?:\\g<name>(?<indices>\\[(?:\\g<index>|'(?:\\\\.|[^'\\\\])*'|\"(?:\\g<regex>|\\\\.|[^\"\\\\])*\")\\])?|\\g<complex>|\\$\\{\\g<complex>\\})\\}|(?#complexsyntax)\\{(?<complex>\\$(?<segment>\\g<name>(\\g<indices>*|\\(.*?\\))?)(?:->\\g<segment>)*|\\$\\g<complex>|\\$\\{\\g<complex>\\})\\}))\\{/\n\n/(?<n>a|b|c)\\g<n>*/\n   abc\n 0: abc\n 1: a\n   accccbbb\n 0: accccbbb\n 1: a\n\n/^X(?7)(a)(?|(b)|(q)(r)(s))(c)(d)(Y)/\n    XYabcdY\n 0: XYabcdY\n 1: a\n 2: b\n 3: <unset>\n 4: <unset>\n 5: c\n 6: d\n 7: Y\n\n/(?<=b(?1)|zzz)(a)/\n    xbaax\n 0: a\n 1: a\n    xzzzax\n 0: a\n 1: a\n\n/(a)(?<=b\\1)/\n\n/(a)(?<=b+(?1))/\nFailed: error 125 at offset 3: lookbehind assertion is not fixed length\n\n/(a+)(?<=b(?1))/\nFailed: error 125 at offset 4: lookbehind assertion is not fixed length\n\n/(a(?<=b(?1)))/\nFailed: error 125 at offset 2: lookbehind assertion is not fixed length\n\n/(?<=b(?1))xyz/\nFailed: error 115 at offset 8: reference to non-existent subpattern\n\n/(?<=b(?1))xyz(b+)pqrstuvew/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/(a|bc)\\1/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|bc)\\1{2,3}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 3\n\n/(a|bc)(?1)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|b\\1)(a|b\\1)/I\nCapture group count = 2\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|b\\1){2}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|bbbb\\1)(a|bbbb\\1)/I\nCapture group count = 2\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/(a|bbbb\\1){2}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 2\n\n/^From +([^ ]+) +[a-zA-Z][a-zA-Z][a-zA-Z] +[a-zA-Z][a-zA-Z][a-zA-Z] +[0-9]?[0-9] +[0-9][0-9]:[0-9][0-9]/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'F'\nLast code unit = ':'\nSubject length lower bound = 22\n\n/<tr([\\w\\W\\s\\d][^<>]{0,})><TD([\\w\\W\\s\\d][^<>]{0,})>([\\d]{0,}\\.)(.*)((<BR>([\\w\\W\\s\\d][^<>]{0,})|[\\s]{0,}))<\\/a><\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><TD([\\w\\W\\s\\d][^<>]{0,})>([\\w\\W\\s\\d][^<>]{0,})<\\/TD><\\/TR>/Iis\nCapture group count = 11\nOptions: caseless dotall\nFirst code unit = '<'\nLast code unit = '>'\nSubject length lower bound = 47\n\n\"(?>.*/)foo\"I\nCapture group count = 0\nLast code unit = 'o'\nSubject length lower bound = 4\n\n/(?(?=[^a-z]+[a-z])  \\d{2}-[a-z]{3}-\\d{2}  |  \\d{2}-\\d{2}-\\d{2} ) /Ix\nCapture group count = 0\nOptions: extended\nLast code unit = '-'\nSubject length lower bound = 8\n\n/(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))/Ii\nCapture group count = 1\nOptions: caseless\nStarting code units: A B C a b c \nSubject length lower bound = 1\n\n/(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))/I\nCapture group count = 0\nStarting code units: c d \nLast code unit = 'b'\nSubject length lower bound = 41\n\n/<a[\\s]+href[\\s]*=[\\s]*          # find <a href=\n ([\\\"\\'])?                       # find single or double quote\n (?(1) (.*?)\\1 | ([^\\s]+))       # if quote found, match up to next matching\n                                 # quote, otherwise match up to next space\n/Iisx\nCapture group count = 3\nMax back reference = 1\nOptions: caseless dotall extended\nFirst code unit = '<'\nLast code unit = '='\nSubject length lower bound = 9\n\n/^(?!:)                       # colon disallowed at start\n  (?:                         # start of item\n    (?: [0-9a-f]{1,4} |       # 1-4 hex digits or\n    (?(1)0 | () ) )           # if null previously matched, fail; else null\n    :                         # followed by colon\n  ){1,7}                      # end item; 1-7 of them required\n  [0-9a-f]{1,4} $             # final hex number at end of string\n  (?(1)|.)                    # check that there was an empty component\n  /Iix\nCapture group count = 1\nMax back reference = 1\nCompile options: caseless extended\nOverall options: anchored caseless extended\nLast code unit = ':'\nSubject length lower bound = 2\n\n/(?|(?<a>A)|(?<a>B))/I\nCapture group count = 1\nNamed capture groups:\n  a   1\nStarting code units: A B \nSubject length lower bound = 1\n    AB\\=copy=a\n 0: A\n 1: A\n  C A (1) a (group 1)\n    BA\\=copy=a\n 0: B\n 1: B\n  C B (1) a (group 1)\n\n/(?|(?<a>A)|(?<b>B))/\nFailed: error 165 at offset 16: different names for subpatterns of the same number are not allowed\n\n/(?:a(?<quote> (?<apostrophe>')|(?<realquote>\")) |\n    b(?<quote> (?<apostrophe>')|(?<realquote>\")) )\n    (?('quote')[a-z]+|[0-9]+)/Ix,dupnames\nCapture group count = 6\nMax back reference = 4\nNamed capture groups:\n  apostrophe   2\n  apostrophe   5\n  quote        1\n  quote        4\n  realquote    3\n  realquote    6\nOptions: dupnames extended\nStarting code units: a b \nSubject length lower bound = 3\n    a\"aaaaa\n 0: a\"aaaaa\n 1: \"\n 2: <unset>\n 3: \"\n    b\"aaaaa\n 0: b\"aaaaa\n 1: <unset>\n 2: <unset>\n 3: <unset>\n 4: \"\n 5: <unset>\n 6: \"\n\\= Expect no match\n    b\"11111\nNo match\n    a\"11111\nNo match\n\n/^(?|(a)(b)(c)(?<D>d)|(?<D>e)) (?('D')X|Y)/IBx,dupnames\n------------------------------------------------------------------\n        Bra\n        ^\n        Bra\n        CBra 1\n        a\n        Ket\n        CBra 2\n        b\n        Ket\n        CBra 3\n        c\n        Ket\n        CBra 4\n        d\n        Ket\n        Alt\n        CBra 1\n        e\n        Ket\n        Ket\n        Cond\n        Cond ref <D>2\n        X\n        Alt\n        Y\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  D   4\n  D   1\nCompile options: dupnames extended\nOverall options: anchored dupnames extended\nStarting code units: a e \nSubject length lower bound = 2\n    abcdX\n 0: abcdX\n 1: a\n 2: b\n 3: c\n 4: d\n    eX\n 0: eX\n 1: e\n\\= Expect no match\n    abcdY\nNo match\n    ey\nNo match\n\n/(?<A>a) (b)(c)  (?<A>d  (?(R&A)$ | (?4)) )/IBx,dupnames\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        CBra 2\n        b\n        Ket\n        CBra 3\n        c\n        Ket\n        CBra 4\n        d\n        Cond\n        Cond recurse <A>2\n        $\n        Alt\n        Recurse\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  A   1\n  A   4\nOptions: dupnames extended\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n    abcdd\n 0: abcdd\n 1: a\n 2: b\n 3: c\n 4: dd\n\\= Expect no match\n    abcdde\nNo match\n\n/abcd*/\n    xxxxabcd\\=ps\n 0: abcd\n    xxxxabcd\\=ph\nPartial match: abcd\n\n/abcd*/i\n    xxxxabcd\\=ps\n 0: abcd\n    xxxxabcd\\=ph\nPartial match: abcd\n    XXXXABCD\\=ps\n 0: ABCD\n    XXXXABCD\\=ph\nPartial match: ABCD\n\n/abc\\d*/\n    xxxxabc1\\=ps\n 0: abc1\n    xxxxabc1\\=ph\nPartial match: abc1\n\n/(a)bc\\1*/\n    xxxxabca\\=ps\n 0: abca\n 1: a\n    xxxxabca\\=ph\nPartial match: abca\n\n/abc[de]*/\n    xxxxabcde\\=ps\n 0: abcde\n    xxxxabcde\\=ph\nPartial match: abcde\n\n/(\\3)(\\1)(a)/allow_empty_class,match_unset_backref,dupnames\n    cat\n 0: a\n 1: \n 2: \n 3: a\n\n/(\\3)(\\1)(a)/I,allow_empty_class,match_unset_backref,dupnames\nCapture group count = 3\nMax back reference = 3\nOptions: allow_empty_class dupnames match_unset_backref\nLast code unit = 'a'\nSubject length lower bound = 1\n    cat\n 0: a\n 1: \n 2: \n 3: a\n\n/(\\3)(\\1)(a)/I\nCapture group count = 3\nMax back reference = 3\nLast code unit = 'a'\nSubject length lower bound = 3\n\\= Expect no match\n    cat\nNo match\n\n/i(?(DEFINE)(?<s>a))/I\nCapture group count = 1\nNamed capture groups:\n  s   1\nFirst code unit = 'i'\nSubject length lower bound = 1\n    i\n 0: i\n\n/()i(?(1)a)/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'i'\nSubject length lower bound = 1\n    ia\n 0: ia\n 1: \n\n/(?i)a(?-i)b|c/B\n------------------------------------------------------------------\n        Bra\n     /i a\n        b\n        Alt\n        c\n        Ket\n        End\n------------------------------------------------------------------\n    XabX\n 0: ab\n    XAbX\n 0: Ab\n    CcC\n 0: c\n\\= Expect no match\n    XABX\nNo match\n\n/(?i)a(?s)b|c/B\n------------------------------------------------------------------\n        Bra\n     /i ab\n        Alt\n     /i c\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?i)a(?s-i)b|c/B\n------------------------------------------------------------------\n        Bra\n     /i a\n        b\n        Alt\n        c\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(ab(c\\1)d|x){2}$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        ab\n        CBra 2\n        c\n        \\1\n        Ket\n        d\n        Alt\n        x\n        Ket\n        CBra 1\n        ab\n        CBra 2\n        c\n        \\1\n        Ket\n        d\n        Alt\n        x\n        Ket\n        $\n        Ket\n        End\n------------------------------------------------------------------\n    xabcxd\n 0: xabcxd\n 1: abcxd\n 2: cx\n\n/^(?&t)*+(?(DEFINE)(?<t>.))$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Braposzero\n        SBraPos\n        Recurse\n        KetRpos\n        Cond\n        Cond false\n        CBra 1\n        Any\n        Ket\n        Ket\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?&t)*(?(DEFINE)(?<t>.))$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Brazero\n        SBra\n        Recurse\n        KetRmax\n        Cond\n        Cond false\n        CBra 1\n        Any\n        Ket\n        Ket\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n# This one is here because Perl gives the match as \"b\" rather than \"ab\". I\n# believe this to be a Perl bug.\n\n/(?>a\\Kb)z|(ab)/\n    ab\\=startchar\n 0: ab\n 1: ab\n\n/(?P<L1>(?P<L2>0|)|(?P>L2)(?P>L1))/\n    abcd\n 0: \n 1: \n 2: \n    0abc\n 0: 0\n 1: 0\n 2: 0\n\n/abc(*MARK:)pqr/\nFailed: error 166 at offset 10: (*MARK) must have an argument\n\n/abc(*:)pqr/\nFailed: error 166 at offset 6: (*MARK) must have an argument\n\n/(*COMMIT:X)/B\n------------------------------------------------------------------\n        Bra\n        *COMMIT X\n        Ket\n        End\n------------------------------------------------------------------\n\n# This should, and does, fail. In Perl, it does not, which I think is a\n# bug because replacing the B in the pattern by (B|D) does make it fail.\n# Turning off Perl's optimization by inserting (??{\"\"}) also makes it fail.\n\n/A(*COMMIT)B/aftertext,mark\n\\= Expect no match\n    ACABX\nNo match\n\n# These should be different, but in Perl they are not, which I think\n# is a bug in Perl.\n\n/A(*THEN)B|A(*THEN)C/mark\n    AC\n 0: AC\n\n/A(*PRUNE)B|A(*PRUNE)C/mark\n\\= Expect no match\n    AC\nNo match\n\n# Mark names can be duplicated. Perl doesn't give a mark for this one,\n# though PCRE2 does.\n\n/^A(*:A)B|^X(*:A)Y/mark\n\\= Expect no match\n    XAQQ\nNo match, mark = A\n\n# COMMIT at the start of a pattern should be the same as an anchor. Perl\n# optimizations defeat this. So does the PCRE2 optimization unless we disable\n# it.\n\n/(*COMMIT)ABC/\n    ABCDEFG\n 0: ABC\n\n/(*COMMIT)ABC/no_start_optimize\n\\= Expect no match\n    DEFGABC\nNo match\n\n/^(ab (c+(*THEN)cd) | xyz)/x\n\\= Expect no match\n    abcccd\nNo match\n\n/^(ab (c+(*PRUNE)cd) | xyz)/x\n\\= Expect no match\n    abcccd\nNo match\n\n/^(ab (c+(*FAIL)cd) | xyz)/x\n\\= Expect no match\n    abcccd\nNo match\n\n# Perl gets some of these wrong\n\n/(?>.(*ACCEPT))*?5/\n    abcde\n 0: a\n\n/(.(*ACCEPT))*?5/\n    abcde\n 0: a\n 1: a\n\n/(.(*ACCEPT))5/\n    abcde\n 0: a\n 1: a\n\n/(.(*ACCEPT))*5/\n    abcde\n 0: a\n 1: a\n\n/A\\NB./B\n------------------------------------------------------------------\n        Bra\n        A\n        Any\n        B\n        Any\n        Ket\n        End\n------------------------------------------------------------------\n    ACBD\n 0: ACBD\n\\= Expect no match\n    A\\nB\nNo match\n    ACB\\n\nNo match\n\n/A\\NB./Bs\n------------------------------------------------------------------\n        Bra\n        A\n        Any\n        B\n        AllAny\n        Ket\n        End\n------------------------------------------------------------------\n    ACBD\n 0: ACBD\n    ACB\\n\n 0: ACB\\x0a\n\\= Expect no match\n    A\\nB\nNo match\n\n/A\\NB/newline=crlf\n    A\\nB\n 0: A\\x0aB\n    A\\rB\n 0: A\\x0dB\n\\= Expect no match\n    A\\r\\nB\nNo match\n\n/\\R+b/B\n------------------------------------------------------------------\n        Bra\n        \\R++\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\R+\\n/B\n------------------------------------------------------------------\n        Bra\n        \\R+\n        \\x0a\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\R+\\d/B\n------------------------------------------------------------------\n        Bra\n        \\R++\n        \\d\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d*\\R/B\n------------------------------------------------------------------\n        Bra\n        \\d*+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s*\\R/B\n------------------------------------------------------------------\n        Bra\n        \\s*\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    \\x20\\x0a\n 0:  \\x0a\n    \\x20\\x0d\n 0:  \\x0d\n    \\x20\\x0d\\x0a\n 0:  \\x0d\\x0a\n\n/\\S*\\R/B\n------------------------------------------------------------------\n        Bra\n        \\S*+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    a\\x0a\n 0: a\\x0a\n\n/X\\h*\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\h*+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    X\\x20\\x0a\n 0: X \\x0a\n\n/X\\H*\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\H*\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    X\\x0d\\x0a\n 0: X\\x0d\\x0a\n\n/X\\H+\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\H+\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n    X\\x0d\\x0a\n 0: X\\x0d\\x0a\n\n/X\\H++\\R/B\n------------------------------------------------------------------\n        Bra\n        X\n        \\H++\n        \\R\n        Ket\n        End\n------------------------------------------------------------------\n\\= Expect no match\n    X\\x0d\\x0a\nNo match\n\n/(?<=abc)def/\n    abc\\=ph\nPartial match: \n\n/abc$/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc$/m\n    abc\n 0: abc\n    abc\\n\n 0: abc\n    abc\\=ph\nPartial match: abc\n    abc\\n\\=ph\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\n\\=ps\n 0: abc\n\n/abc\\z/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc\\Z/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc\\b/\n    abc\n 0: abc\n    abc\\=ps\n 0: abc\n    abc\\=ph\nPartial match: abc\n\n/abc\\B/\n    abc\\=ps\nPartial match: abc\n    abc\\=ph\nPartial match: abc\n\\= Expect no match\n    abc\nNo match\n\n/.+/\n\\= Bad offsets\n    abc\\=offset=4\nFailed: error -33: bad offset value\n    abc\\=offset=-4\n** Invalid value in 'offset=-4'\n\\= Valid data\n    abc\\=offset=0\n 0: abc\n    abc\\=offset=1\n 0: bc\n    abc\\=offset=2\n 0: c\n\\= Expect no match\n    abc\\=offset=3\nNo match\n\n/^\\c\u00c4\u0141/\nFailed: error 168 at offset 3: \\c must be followed by a printable ASCII character\n\n/(?P<abn>(?P=abn)xxx)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        \\1\n        xxx\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(a\\1z)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        \\1\n        z\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?P<abn>(?P=abn)(?<badstufxxx)/B\nFailed: error 142 at offset 29: syntax error in subpattern name (missing terminator?)\n\n/(?P<abn>(?P=axn)xxx)/B\nFailed: error 115 at offset 12: reference to non-existent subpattern\n\n/(?P<abn>(?P=axn)xxx)(?<axn>yy)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        \\2\n        xxx\n        Ket\n        CBra 2\n        yy\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# These tests are here because Perl gets the first one wrong.\n\n/(\\R*)(.)/s\n    \\r\\n\n 0: \\x0d\n 1: \n 2: \\x0d\n    \\r\\r\\n\\n\\r\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n    \\r\\r\\n\\n\\r\\n\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n\n/(\\R)*(.)/s\n    \\r\\n\n 0: \\x0d\n 1: <unset>\n 2: \\x0d\n    \\r\\r\\n\\n\\r\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0a\n 2: \\x0d\n    \\r\\r\\n\\n\\r\\n\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0a\n 2: \\x0d\n\n/((?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)*)(.)/s\n    \\r\\n\n 0: \\x0d\n 1: \n 2: \\x0d\n    \\r\\r\\n\\n\\r\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n    \\r\\r\\n\\n\\r\\n\n 0: \\x0d\\x0d\\x0a\\x0a\\x0d\n 1: \\x0d\\x0d\\x0a\\x0a\n 2: \\x0d\n\n# -------------\n\n/^abc$/B\n------------------------------------------------------------------\n        Bra\n        ^\n        abc\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/^abc$/Bm\n------------------------------------------------------------------\n        Bra\n     /m ^\n        abc\n     /m $\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a)*+(\\w)/\n    aaaaX\n 0: aaaaX\n 1: a\n 2: X\n\\= Expect no match\n    aaaa\nNo match\n\n/^(?:a)*+(\\w)/\n    aaaaX\n 0: aaaaX\n 1: X\n\\= Expect no match\n    aaaa\nNo match\n\n/(a)++1234/IB\n------------------------------------------------------------------\n        Bra\n        CBraPos 1\n        a\n        KetRpos\n        1234\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = '4'\nSubject length lower bound = 5\n\n/([abc])++1234/I\nCapture group count = 1\nStarting code units: a b c \nLast code unit = '4'\nSubject length lower bound = 5\n\n/(?<=(abc)+)X/\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/(^ab)/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(^ab)++/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(^ab|^)+/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(^ab|^)++/I\nCapture group count = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(?:^ab)/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(?:^ab)++/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(?:^ab|^)+/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(?:^ab|^)++/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(.*ab)/I\nCapture group count = 1\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(.*ab)++/I\nCapture group count = 1\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(.*ab|.*)+/I\nCapture group count = 1\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(.*ab|.*)++/I\nCapture group count = 1\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(?:.*ab)/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?:.*ab)++/I\nCapture group count = 0\nFirst code unit at start or follows newline\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?:.*ab|.*)+/I\nCapture group count = 0\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(?:.*ab|.*)++/I\nCapture group count = 0\nMay match empty string\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n/(?=a)[bcd]/I\nCapture group count = 0\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=a))[bcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=a))+[bcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/((?=a))++[bcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(?=a+)[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nSubject length lower bound = 1\n\n/(?=a+?)[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nSubject length lower bound = 1\n\n/(?=a++)[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nSubject length lower bound = 1\n\n/(?=a{3})[bcd]/Ii\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'a' (caseless)\nLast code unit = 'a' (caseless)\nSubject length lower bound = 2\n\n/(abc)\\1+/\n\n# Perl doesn't get these right IMO (the 3rd is PCRE2-specific)\n\n/(?1)(?:(b(*ACCEPT))){0}/\n    b\n 0: b\n\n/(?1)(?:(b(*ACCEPT))){0}c/\n    bc\n 0: bc\n\\= Expect no match\n    b\nNo match\n\n/(?1)(?:((*ACCEPT))){0}c/\n    c\n 0: c\n    c\\=notempty\n 0: c\n\n/^.*?(?(?=a)a|b(*THEN)c)/\n\\= Expect no match\n    ba\nNo match\n\n/^.*?(?(?=a)a|bc)/\n    ba\n 0: ba\n\n/^.*?(?(?=a)a(*THEN)b|c)/\n\\= Expect no match\n    ac\nNo match\n\n/^.*?(?(?=a)a(*THEN)b)c/\n\\= Expect no match\n    ac\nNo match\n\n/^.*?(a(*THEN)b)c/\n\\= Expect no match\n    aabc\nNo match\n\n/^.*? (?1) c (?(DEFINE)(a(*THEN)b))/x\n    aabc\n 0: aabc\n\n/^.*?(a(*THEN)b|z)c/\n    aabc\n 0: aabc\n 1: ab\n\n/^.*?(z|a(*THEN)b)c/\n    aabc\n 0: aabc\n 1: ab\n\n# These are here because they are not Perl-compatible; the studying means the\n# mark is not seen.\n\n/(*MARK:A)(*SKIP:B)(C|X)/mark\n    C\n 0: C\n 1: C\nMK: A\n\\= Expect no match\n    D\nNo match, mark = A\n\n/(*:A)A+(*SKIP:A)(B|Z)/mark\n\\= Expect no match\n    AAAC\nNo match, mark = A\n\n# ----------------------------\n\n\"(?=a*(*ACCEPT)b)c\"\n    c\n 0: c\n    c\\=notempty\n 0: c\n\n/(?1)c(?(DEFINE)((*ACCEPT)b))/\n    c\n 0: c\n    c\\=notempty\n 0: c\n\n/(?>(*ACCEPT)b)c/\n    c\n 0: \n\\= Expect no match\n    c\\=notempty\nNo match\n\n/(?:(?>(a)))+a%/allaftertext\n    %aa%\n 0: aa%\n 0+ \n 1: a\n 1+ a%\n\n/(a)b|ac/allaftertext\n    ac\\=ovector=1\n 0: ac\n 0+ \n\n/(a)(b)x|abc/allaftertext\n     abc\\=ovector=2\n 0: abc\n 0+ \n\n/(a)bc|(a)(b)\\2/\n    abc\\=ovector=1\nMatched, but too many substrings\n 0: abc\n    abc\\=ovector=2\n 0: abc\n 1: a\n    aba\\=ovector=1\nMatched, but too many substrings\n 0: aba\n    aba\\=ovector=2\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n    aba\\=ovector=3\nMatched, but too many substrings\n 0: aba\n 1: <unset>\n 2: a\n    aba\\=ovector=4\n 0: aba\n 1: <unset>\n 2: a\n 3: b\n\n/(?(DEFINE)(a(?2)|b)(b(?1)|a))(?:(?1)|(?2))/I\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(a(?2)|b)(b(?1)|a)(?:(?1)|(?2))/I\nCapture group count = 2\nStarting code units: a b \nSubject length lower bound = 3\n\n/(a(?2)|b)(b(?1)|a)(?1)(?2)/I\nCapture group count = 2\nStarting code units: a b \nSubject length lower bound = 4\n\n/(abc)(?1)/I\nCapture group count = 1\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 6\n\n/(?:(foo)|(bar)|(baz))X/allcaptures\n    bazfooX\n 0: fooX\n 1: foo\n 2: <unset>\n 3: <unset>\n    foobazbarX\n 0: barX\n 1: <unset>\n 2: bar\n 3: <unset>\n    barfooX\n 0: fooX\n 1: foo\n 2: <unset>\n 3: <unset>\n    bazX\n 0: bazX\n 1: <unset>\n 2: <unset>\n 3: baz\n    foobarbazX\n 0: bazX\n 1: <unset>\n 2: <unset>\n 3: baz\n    bazfooX\\=ovector=0\n 0: fooX\n 1: foo\n 2: <unset>\n 3: <unset>\n    bazfooX\\=ovector=1\nMatched, but too many substrings\n 0: fooX\n    bazfooX\\=ovector=2\n 0: fooX\n 1: foo\n    bazfooX\\=ovector=3\n 0: fooX\n 1: foo\n 2: <unset>\n\n/(?=abc){3}abc/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        abc\n        Ket\n        Assert\n        abc\n        Ket\n        Assert\n        abc\n        Ket\n        abc\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=abc)+abc/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        abc\n        Ket\n        Brazero\n        Assert\n        abc\n        Ket\n        abc\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=abc)++abc/B\n------------------------------------------------------------------\n        Bra\n        Once\n        Assert\n        abc\n        Ket\n        Brazero\n        Assert\n        abc\n        Ket\n        Ket\n        abc\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=abc){0}xyz/B\n------------------------------------------------------------------\n        Bra\n        Skip zero\n        Assert\n        abc\n        Ket\n        xyz\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=(a))?./B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Assert\n        CBra 1\n        a\n        Ket\n        Ket\n        Any\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=(a))??./B\n------------------------------------------------------------------\n        Bra\n        Braminzero\n        Assert\n        CBra 1\n        a\n        Ket\n        Ket\n        Any\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?=(a)){0}b(?1)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Skip zero\n        Assert\n        CBra 1\n        a\n        Ket\n        Ket\n        b\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(DEFINE)(a))?b(?1)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        CBra 1\n        a\n        Ket\n        Ket\n        b\n        Recurse\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?=(?1))?[az]([abc])d/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Brazero\n        Assert\n        Recurse\n        Ket\n        [az]\n        CBra 1\n        [a-c]\n        Ket\n        d\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?!a){0}\\w+/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Skip zero\n        Assert not\n        a\n        Ket\n        \\w++\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<=(abc))?xyz/B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        Assert back\n        Reverse\n        CBra 1\n        abc\n        Ket\n        Ket\n        xyz\n        Ket\n        End\n------------------------------------------------------------------\n\n/[:a[:abc]b:]/B\n------------------------------------------------------------------\n        Bra\n        [:[a-c]\n        b:]\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a(*:A)(d|e(*:B))z|aeq)/auto_callout\n    adz\n--->adz\n +0 ^       ^\n +1 ^       (\n +2 ^       a\n +3 ^^      (*:A)\n +8 ^^      (\nLatest Mark: A\n +9 ^^      d\n+10 ^ ^     |\n+18 ^ ^     z\n+19 ^  ^    |\n+24 ^  ^    End of pattern\n 0: adz\n 1: adz\n 2: d\n    aez\n--->aez\n +0 ^       ^\n +1 ^       (\n +2 ^       a\n +3 ^^      (*:A)\n +8 ^^      (\nLatest Mark: A\n +9 ^^      d\n+11 ^^      e\n+12 ^ ^     (*:B)\n+17 ^ ^     )\nLatest Mark: B\n+18 ^ ^     z\n+19 ^  ^    |\n+24 ^  ^    End of pattern\n 0: aez\n 1: aez\n 2: e\n    aeqwerty\n--->aeqwerty\n +0 ^            ^\n +1 ^            (\n +2 ^            a\n +3 ^^           (*:A)\n +8 ^^           (\nLatest Mark: A\n +9 ^^           d\n+11 ^^           e\n+12 ^ ^          (*:B)\n+17 ^ ^          )\nLatest Mark: B\n+18 ^ ^          z\n+20 ^            a\n+21 ^^           e\n+22 ^ ^          q\n+23 ^  ^         )\n+24 ^  ^         End of pattern\n 0: aeq\n 1: aeq\n\n/.(*F)/\n\\= Expect no match\n    abc\\=ph\nNo match\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b/I\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 't'\nLast code unit = 't'\nSubject length lower bound = 18\n\n/\\btype\\b\\W*?\\btext\\b\\W*?\\bjavascript\\b|\\burl\\b\\W*?\\bshell:|<input\\b.*?\\btype\\b\\W*?\\bimage\\b|\\bonkeyup\\b\\W*?\\=/I\nCapture group count = 0\nMax lookbehind = 1\nStarting code units: < o t u \nSubject length lower bound = 8\n\n/a(*SKIP)c|b(*ACCEPT)|/I,aftertext\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    a\n 0: \n 0+ \n\n/a(*SKIP)c|b(*ACCEPT)cd(*ACCEPT)|x/I\nCapture group count = 0\nStarting code units: a b x \nSubject length lower bound = 1\n    ax\n 0: x\n\n'a*(*ACCEPT)b'aftertext\n    abc\\=notempty_atstart\n 0: a\n 0+ bc\n    bbb\\=notempty_atstart\n 0: \n 0+ bb\n\\= Expect no match\n    \\=notempty_atstart\nNo match\n\n/(*ACCEPT)a/I,aftertext\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    bax\n 0: \n 0+ bax\n\n/z(*ACCEPT)a/I,aftertext\nCapture group count = 0\nFirst code unit = 'z'\nSubject length lower bound = 1\n    baxzbx\n 0: z\n 0+ bx\n\n/^(?>a+)(?>(z+))\\w/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Once\n        a++\n        Ket\n        Once\n        CBra 1\n        z++\n        Ket\n        Ket\n        \\w\n        Ket\n        End\n------------------------------------------------------------------\n    aaaazzzzb\n 0: aaaazzzzb\n 1: zzzz\n\\= Expect no match\n    aazz\nNo match\n\n/(.)(\\1|a(?2))/\n    bab\n 0: bab\n 1: b\n 2: ab\n\n/\\1|(.)(?R)\\1/\n    cbbbc\n 0: cbbbc\n 1: c\n\n/(.)((?(1)c|a)|a(?2))/\n\\= Expect no match\n    baa\nNo match\n\n/(?P<abn>(?P=abn)xxx)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        \\1\n        xxx\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(a\\1z)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        \\1\n        z\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^a\\x41z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\\= Expect no match\n    ax41z\nNo match\n\n/^a[m\\x41]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\n/^a\\x1z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    ax1z\n 0: ax1z\n\n/^a\\u0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\\= Expect no match\n    au0041z\nNo match\n\n/^a[m\\u0041]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aAz\n 0: aAz\n\n/^a\\u041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    au041z\n 0: au041z\n\\= Expect no match\n    aAz\nNo match\n\n/^a\\U0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames\n    aU0041z\n 0: aU0041z\n\\= Expect no match\n    aAz\nNo match\n    \n/^\\u{7a}/alt_bsux\n    u{7a}\n 0: u{7a}\n\\= Expect no match\n    zoo \nNo match\n\n/^\\u{7a}/extra_alt_bsux\n    zoo \n 0: z\n\n/(?(?=c)c|d)++Y/B\n------------------------------------------------------------------\n        Bra\n        BraPos\n        Cond\n        Assert\n        c\n        Ket\n        c\n        Alt\n        d\n        Ket\n        KetRpos\n        Y\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(?=c)c|d)*+Y/B\n------------------------------------------------------------------\n        Bra\n        Braposzero\n        BraPos\n        Cond\n        Assert\n        c\n        Ket\n        c\n        Alt\n        d\n        Ket\n        KetRpos\n        Y\n        Ket\n        End\n------------------------------------------------------------------\n\n/a[\\NB]c/\nFailed: error 171 at offset 4: \\N is not supported in a class\n    aNc\n\n/a[B-\\Nc]/\nFailed: error 150 at offset 6: invalid range in character class\n\n/a[B\\Nc]/\nFailed: error 171 at offset 5: \\N is not supported in a class\n\n/(a)(?2){0,1999}?(b)/\n\n/(a)(?(DEFINE)(b))(?2){0,1999}?(?2)/\n\n# This test, with something more complicated than individual letters, causes\n# different behaviour in Perl. Perhaps it disables some optimization; no tag is\n# passed back for the failures, whereas in PCRE2 there is a tag.\n\n/(A|P)(*:A)(B|P) | (X|P)(X|P)(*:B)(Y|P)/x,mark\n    AABC\n 0: AB\n 1: A\n 2: B\nMK: A\n    XXYZ\n 0: XXY\n 1: <unset>\n 2: <unset>\n 3: X\n 4: X\n 5: Y\nMK: B\n\\= Expect no match\n    XAQQ\nNo match, mark = A\n    XAQQXZZ\nNo match, mark = A\n    AXQQQ\nNo match, mark = A\n    AXXQQQ\nNo match, mark = B\n\n# Perl doesn't give marks for these, though it does if the alternatives are\n# replaced by single letters.\n\n/(b|q)(*:m)f|a(*:n)w/mark\n    aw\n 0: aw\nMK: n\n\\= Expect no match\n    abc\nNo match, mark = m\n\n/(q|b)(*:m)f|a(*:n)w/mark\n    aw\n 0: aw\nMK: n\n\\= Expect no match\n    abc\nNo match, mark = m\n\n# After a partial match, the behaviour is as for a failure.\n\n/^a(*:X)bcde/mark\n   abc\\=ps\nPartial match, mark=X: abc\n\n# These are here because Perl doesn't return a mark, except for the first.\n\n/(?=(*:x))(q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\n 1: \nMK: x\n\n/(?=(*:x))((*:y)q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\n 1: \nMK: x\n\n/(?=(*:x))(?:(*:y)q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\nMK: x\n\n/(?=(*:x))(?>(*:y)q|)/aftertext,mark\n    abc\n 0: \n 0+ abc\nMK: x\n\n/(?=a(*:x))(?!a(*:y)c)/aftertext,mark\n    ab\n 0: \n 0+ ab\nMK: x\n\n/(?=a(*:x))(?=a(*:y)c|)/aftertext,mark\n    ab\n 0: \n 0+ ab\nMK: x\n\n/(..)\\1/\n    ab\\=ps\nPartial match: ab\n    aba\\=ps\nPartial match: aba\n    abab\\=ps\n 0: abab\n 1: ab\n\n/(..)\\1/i\n    ab\\=ps\nPartial match: ab\n    abA\\=ps\nPartial match: abA\n    aBAb\\=ps\n 0: aBAb\n 1: aB\n\n/(..)\\1{2,}/\n    ab\\=ps\nPartial match: ab\n    aba\\=ps\nPartial match: aba\n    abab\\=ps\nPartial match: abab\n    ababa\\=ps\nPartial match: ababa\n    ababab\\=ps\n 0: ababab\n 1: ab\n    ababab\\=ph\nPartial match: ababab\n    abababa\\=ps\n 0: ababab\n 1: ab\n    abababa\\=ph\nPartial match: abababa\n\n/(..)\\1{2,}/i\n    ab\\=ps\nPartial match: ab\n    aBa\\=ps\nPartial match: aBa\n    aBAb\\=ps\nPartial match: aBAb\n    AbaBA\\=ps\nPartial match: AbaBA\n    abABAb\\=ps\n 0: abABAb\n 1: ab\n    aBAbaB\\=ph\nPartial match: aBAbaB\n    abABabA\\=ps\n 0: abABab\n 1: ab\n    abaBABa\\=ph\nPartial match: abaBABa\n\n/(..)\\1{2,}?x/i\n    ab\\=ps\nPartial match: ab\n    abA\\=ps\nPartial match: abA\n    aBAb\\=ps\nPartial match: aBAb\n    abaBA\\=ps\nPartial match: abaBA\n    abAbaB\\=ps\nPartial match: abAbaB\n    abaBabA\\=ps\nPartial match: abaBabA\n    abAbABaBx\\=ps\n 0: abAbABaBx\n 1: ab\n\n/^(..)\\1/\n    aba\\=ps\nPartial match: aba\n\n/^(..)\\1{2,3}x/\n    aba\\=ps\nPartial match: aba\n    ababa\\=ps\nPartial match: ababa\n    ababa\\=ph\nPartial match: ababa\n    abababx\n 0: abababx\n 1: ab\n    ababababx\n 0: ababababx\n 1: ab\n\n/^(..)\\1{2,3}?x/\n    aba\\=ps\nPartial match: aba\n    ababa\\=ps\nPartial match: ababa\n    ababa\\=ph\nPartial match: ababa\n    abababx\n 0: abababx\n 1: ab\n    ababababx\n 0: ababababx\n 1: ab\n\n/^(..)(\\1{2,3})ab/\n    abababab\n 0: abababab\n 1: ab\n 2: abab\n\n/^\\R/\n    \\r\\=ps\n 0: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n\n/^\\R{2,3}x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\nPartial match: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\r\\r\\=ph\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\rx\n 0: \\x0d\\x0dx\n    \\r\\r\\rx\n 0: \\x0d\\x0d\\x0dx\n\n/^\\R{2,3}?x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\nPartial match: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\r\\r\\=ph\nPartial match: \\x0d\\x0d\\x0d\n    \\r\\rx\n 0: \\x0d\\x0dx\n    \\r\\r\\rx\n 0: \\x0d\\x0d\\x0dx\n\n/^\\R?x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    x\n 0: x\n    \\rx\n 0: \\x0dx\n\n/^\\R+x/\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\n\\=ps\nPartial match: \\x0d\\x0a\n    \\r\\n\\=ph\nPartial match: \\x0d\\x0a\n    \\rx\n 0: \\x0dx\n\n/^a$/newline=crlf\n    a\\r\\=ps\nPartial match: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/^a$/m,newline=crlf\n    a\\r\\=ps\nPartial match: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/^(a$|a\\r)/newline=crlf\n    a\\r\\=ps\n 0: a\\x0d\n 1: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/^(a$|a\\r)/m,newline=crlf\n    a\\r\\=ps\n 0: a\\x0d\n 1: a\\x0d\n    a\\r\\=ph\nPartial match: a\\x0d\n\n/./newline=crlf\n    \\r\\=ps\n 0: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n\n/.{2,3}/newline=crlf\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\n 0: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\n 0: \\x0d\\x0d\\x0d\n    \\r\\r\\r\\=ph\nPartial match: \\x0d\\x0d\\x0d\n\n/.{2,3}?/newline=crlf\n    \\r\\=ps\nPartial match: \\x0d\n    \\r\\=ph\nPartial match: \\x0d\n    \\r\\r\\=ps\n 0: \\x0d\\x0d\n    \\r\\r\\=ph\nPartial match: \\x0d\\x0d\n    \\r\\r\\r\\=ps\n 0: \\x0d\\x0d\n    \\r\\r\\r\\=ph\n 0: \\x0d\\x0d\n\n\"AB(C(D))(E(F))?(?(?=\\2)(?=\\4))\"\n    ABCDGHI\\=ovector=01\nMatched, but too many substrings\n 0: ABCD\n\n# These are all run as real matches in test 1; here we are just checking the\n# settings of the anchored and startline bits.\n\n/(?>.*?a)(?<=ba)/I\nCapture group count = 0\nMax lookbehind = 2\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/(?:.*?a)(?<=ba)/I\nCapture group count = 0\nMax lookbehind = 2\nFirst code unit at start or follows newline\nLast code unit = 'a'\nSubject length lower bound = 1\n\n/.*?a(*PRUNE)b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/.*?a(*PRUNE)b/Is\nCapture group count = 0\nOptions: dotall\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/^a(*PRUNE)b/Is\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/.*?a(*SKIP)b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?>.*?a)b/Is\nCapture group count = 0\nOptions: dotall\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?>.*?a)b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 2\n\n/(?>^a)b/Is\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nFirst code unit = 'a'\nSubject length lower bound = 2\n\n/(?>.*?)(?<=(abcd)|(wxyz))/I\nCapture group count = 2\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n/(?>.*)(?<=(abcd)|(wxyz))/I\nCapture group count = 2\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n\"(?>.*)foo\"I\nCapture group count = 0\nLast code unit = 'o'\nSubject length lower bound = 3\n\n\"(?>.*?)foo\"I\nCapture group count = 0\nLast code unit = 'o'\nSubject length lower bound = 3\n\n/(?>^abc)/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?>.*abc)/Im\nCapture group count = 0\nOptions: multiline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?:.*abc)/Im\nCapture group count = 0\nOptions: multiline\nFirst code unit at start or follows newline\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?:(a)+(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(?:(a)++(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(?:(?>(a))(?C1)bb|aa(?C2)b)/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(?:(?1)(?C1)x|ab(?C2))((a)){0}/\n    aab\\=callout_capture\nCallout 1: last capture = 0\n--->aab\n    ^^      x\nCallout 1: last capture = 0\n--->aab\n     ^^     x\nCallout 2: last capture = 0\n--->aab\n     ^ ^    )\n 0: ab\n\n/(?1)(?C1)((a)(?C2)){0}/\n    aab\\=callout_capture\nCallout 2: last capture = 2\n 1: <unset>\n 2: a\n--->aab\n    ^^      ){0}\nCallout 1: last capture = 0\n--->aab\n    ^^      (\n 0: a\n\n/(?:(a)+(?C1)bb|aa(?C2)b)++/\n    aab\\=callout_capture\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n    aab\\=callout_capture,ovector=1\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^ ^     b\nCallout 1: last capture = 1\n 1: a\n--->aab\n    ^^      b\nCallout 2: last capture = 0\n--->aab\n    ^ ^     b\n 0: aab\n\n/(ab)x|ab/\n    ab\\=ovector=0\n 0: ab\n    ab\\=ovector=1\n 0: ab\n\n/(?<=123)(*MARK:xx)abc/mark\n    xxxx123a\\=ph\nPartial match, mark=xx: a\n    xxxx123a\\=ps\nPartial match, mark=xx: a\n\n/123\\Kabc/startchar\n    xxxx123a\\=ph\nPartial match: 123a\n    xxxx123a\\=ps\nPartial match: 123a\n\n/^(?(?=a)aa|bb)/auto_callout\n    bb\n--->bb\n +0 ^      ^\n +1 ^      (?\n +3 ^      (?=\n +6 ^      a\n+11 ^      b\n+12 ^^     b\n+13 ^ ^    )\n+14 ^ ^    End of pattern\n 0: bb\n\n/(?C1)^(?C2)(?(?C99)(?=(?C3)a(?C4))(?C5)a(?C6)a(?C7)|(?C8)b(?C9)b(?C10))(?C11)/\n    bb\n--->bb\n  1 ^      ^\n  2 ^      (?\n 99 ^      (?=\n  3 ^      a\n  8 ^      b\n  9 ^^     b\n 10 ^ ^    )\n 11 ^ ^    End of pattern\n 0: bb\n\n# Perl seems to have a bug with this one.\n\n/aaaaa(*COMMIT)(*PRUNE)b|a+c/\n    aaaaaac\n 0: aaaac\n\n# Here are some that Perl treats differently because of the way it handles\n# backtracking verbs.\n\n/(?!a(*COMMIT)b)ac|ad/\n     ac\n 0: ac\n     ad\n 0: ad\n\n/^(?!a(*THEN)b|ac)../\n     ad\n 0: ad\n\\= Expect no match\n     ac\nNo match\n\n/^(?=a(*THEN)b|ac)/\n    ac\n 0: \n\n/\\A.*?(?:a|b(*THEN)c)/\n    ba\n 0: ba\n\n/\\A.*?(?:a|b(*THEN)c)++/\n    ba\n 0: ba\n\n/\\A.*?(?:a|b(*THEN)c|d)/\n    ba\n 0: ba\n\n/(?:(a(*MARK:X)a+(*SKIP:X)b)){0}(?:(?1)|aac)/\n    aac\n 0: aac\n\n/\\A.*?(a|b(*THEN)c)/\n    ba\n 0: ba\n 1: a\n\n/^(A(*THEN)B|A(*THEN)D)/\n    AD\n 0: AD\n 1: AD\n\n/(?!b(*THEN)a)bn|bnn/\n    bnn\n 0: bn\n\n/(?(?=b(*SKIP)a)bn|bnn)/\n    bnn\n 0: bnn\n\n/(?=b(*THEN)a|)bn|bnn/\n    bnn\n 0: bn\n\n# This test causes a segfault with Perl 5.18.0\n\n/^(?=(a)){0}b(?1)/\n    backgammon\n 0: ba\n\n/(?|(?<n>f)|(?<n>b))/I,dupnames\nCapture group count = 1\nNamed capture groups:\n  n   1\nOptions: dupnames\nStarting code units: b f \nSubject length lower bound = 1\n\n/(?<a>abc)(?<a>z)\\k<a>()/IB,dupnames\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        abc\n        Ket\n        CBra 2\n        z\n        Ket\n        \\k<a>2\n        CBra 3\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 3\nMax back reference = 2\nNamed capture groups:\n  a   1\n  a   2\nOptions: dupnames\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 5\n\n/a*[bcd]/B\n------------------------------------------------------------------\n        Bra\n        a*+\n        [b-d]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[bcd]*a/B\n------------------------------------------------------------------\n        Bra\n        [b-d]*+\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n# A complete set of tests for auto-possessification of character types, but\n# omitting \\C because it might be disabled (it has its own tests).\n\n/\\D+\\D \\D+\\d \\D+\\S \\D+\\s \\D+\\W \\D+\\w \\D+. \\D+\\R \\D+\\H \\D+\\h \\D+\\V \\D+\\v \\D+\\Z \\D+\\z \\D+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\D+\n        \\D\n        \\D++\n        \\d\n        \\D+\n        \\S\n        \\D+\n        \\s\n        \\D+\n        \\W\n        \\D+\n        \\w\n        \\D+\n        Any\n        \\D+\n        \\R\n        \\D+\n        \\H\n        \\D+\n        \\h\n        \\D+\n        \\V\n        \\D+\n        \\v\n        \\D+\n        \\Z\n        \\D++\n        \\z\n        \\D+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\d+\\D \\d+\\d \\d+\\S \\d+\\s \\d+\\W \\d+\\w \\d+. \\d+\\R \\d+\\H \\d+\\h \\d+\\V \\d+\\v \\d+\\Z \\d+\\z \\d+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\d++\n        \\D\n        \\d+\n        \\d\n        \\d+\n        \\S\n        \\d++\n        \\s\n        \\d++\n        \\W\n        \\d+\n        \\w\n        \\d+\n        Any\n        \\d++\n        \\R\n        \\d+\n        \\H\n        \\d++\n        \\h\n        \\d+\n        \\V\n        \\d++\n        \\v\n        \\d++\n        \\Z\n        \\d++\n        \\z\n        \\d++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\S+\\D \\S+\\d \\S+\\S \\S+\\s \\S+\\W \\S+\\w \\S+. \\S+\\R \\S+\\H \\S+\\h \\S+\\V \\S+\\v \\S+\\Z \\S+\\z \\S+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\S+\n        \\D\n        \\S+\n        \\d\n        \\S+\n        \\S\n        \\S++\n        \\s\n        \\S+\n        \\W\n        \\S+\n        \\w\n        \\S+\n        Any\n        \\S++\n        \\R\n        \\S+\n        \\H\n        \\S++\n        \\h\n        \\S+\n        \\V\n        \\S++\n        \\v\n        \\S++\n        \\Z\n        \\S++\n        \\z\n        \\S++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\s+\\D \\s+\\d \\s+\\S \\s+\\s \\s+\\W \\s+\\w \\s+. \\s+\\R \\s+\\H \\s+\\h \\s+\\V \\s+\\v \\s+\\Z \\s+\\z \\s+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\s+\n        \\D\n        \\s++\n        \\d\n        \\s++\n        \\S\n        \\s+\n        \\s\n        \\s+\n        \\W\n        \\s++\n        \\w\n        \\s+\n        Any\n        \\s+\n        \\R\n        \\s+\n        \\H\n        \\s+\n        \\h\n        \\s+\n        \\V\n        \\s+\n        \\v\n        \\s+\n        \\Z\n        \\s++\n        \\z\n        \\s+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\W+\\D \\W+\\d \\W+\\S \\W+\\s \\W+\\W \\W+\\w \\W+. \\W+\\R \\W+\\H \\W+\\h \\W+\\V \\W+\\v \\W+\\Z \\W+\\z \\W+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\W+\n        \\D\n        \\W++\n        \\d\n        \\W+\n        \\S\n        \\W+\n        \\s\n        \\W+\n        \\W\n        \\W++\n        \\w\n        \\W+\n        Any\n        \\W+\n        \\R\n        \\W+\n        \\H\n        \\W+\n        \\h\n        \\W+\n        \\V\n        \\W+\n        \\v\n        \\W+\n        \\Z\n        \\W++\n        \\z\n        \\W+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\w+\\D \\w+\\d \\w+\\S \\w+\\s \\w+\\W \\w+\\w \\w+. \\w+\\R \\w+\\H \\w+\\h \\w+\\V \\w+\\v \\w+\\Z \\w+\\z \\w+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\w+\n        \\D\n        \\w+\n        \\d\n        \\w+\n        \\S\n        \\w++\n        \\s\n        \\w++\n        \\W\n        \\w+\n        \\w\n        \\w+\n        Any\n        \\w++\n        \\R\n        \\w+\n        \\H\n        \\w++\n        \\h\n        \\w+\n        \\V\n        \\w++\n        \\v\n        \\w++\n        \\Z\n        \\w++\n        \\z\n        \\w++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\R+\\D \\R+\\d \\R+\\S \\R+\\s \\R+\\W \\R+\\w \\R+. \\R+\\R \\R+\\H \\R+\\h \\R+\\V \\R+\\v \\R+\\Z \\R+\\z \\R+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\R+\n        \\D\n        \\R++\n        \\d\n        \\R+\n        \\S\n        \\R++\n        \\s\n        \\R+\n        \\W\n        \\R++\n        \\w\n        \\R++\n        Any\n        \\R+\n        \\R\n        \\R+\n        \\H\n        \\R++\n        \\h\n        \\R+\n        \\V\n        \\R+\n        \\v\n        \\R+\n        \\Z\n        \\R++\n        \\z\n        \\R+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\H+\\D \\H+\\d \\H+\\S \\H+\\s \\H+\\W \\H+\\w \\H+. \\H+\\R \\H+\\H \\H+\\h \\H+\\V \\H+\\v \\H+\\Z \\H+\\z \\H+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\H+\n        \\D\n        \\H+\n        \\d\n        \\H+\n        \\S\n        \\H+\n        \\s\n        \\H+\n        \\W\n        \\H+\n        \\w\n        \\H+\n        Any\n        \\H+\n        \\R\n        \\H+\n        \\H\n        \\H++\n        \\h\n        \\H+\n        \\V\n        \\H+\n        \\v\n        \\H+\n        \\Z\n        \\H++\n        \\z\n        \\H+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\h+\\D \\h+\\d \\h+\\S \\h+\\s \\h+\\W \\h+\\w \\h+. \\h+\\R \\h+\\H \\h+\\h \\h+\\V \\h+\\v \\h+\\Z \\h+\\z \\h+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\h+\n        \\D\n        \\h++\n        \\d\n        \\h++\n        \\S\n        \\h+\n        \\s\n        \\h+\n        \\W\n        \\h++\n        \\w\n        \\h+\n        Any\n        \\h++\n        \\R\n        \\h++\n        \\H\n        \\h+\n        \\h\n        \\h+\n        \\V\n        \\h++\n        \\v\n        \\h+\n        \\Z\n        \\h++\n        \\z\n        \\h+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\V+\\D \\V+\\d \\V+\\S \\V+\\s \\V+\\W \\V+\\w \\V+. \\V+\\R \\V+\\H \\V+\\h \\V+\\V \\V+\\v \\V+\\Z \\V+\\z \\V+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\V+\n        \\D\n        \\V+\n        \\d\n        \\V+\n        \\S\n        \\V+\n        \\s\n        \\V+\n        \\W\n        \\V+\n        \\w\n        \\V+\n        Any\n        \\V++\n        \\R\n        \\V+\n        \\H\n        \\V+\n        \\h\n        \\V+\n        \\V\n        \\V++\n        \\v\n        \\V+\n        \\Z\n        \\V++\n        \\z\n        \\V+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\v+\\D \\v+\\d \\v+\\S \\v+\\s \\v+\\W \\v+\\w \\v+. \\v+\\R \\v+\\H \\v+\\h \\v+\\V \\v+\\v \\v+\\Z \\v+\\z \\v+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\v+\n        \\D\n        \\v++\n        \\d\n        \\v++\n        \\S\n        \\v+\n        \\s\n        \\v+\n        \\W\n        \\v++\n        \\w\n        \\v+\n        Any\n        \\v+\n        \\R\n        \\v+\n        \\H\n        \\v++\n        \\h\n        \\v++\n        \\V\n        \\v+\n        \\v\n        \\v+\n        \\Z\n        \\v++\n        \\z\n        \\v+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ a+\\D  a+\\d  a+\\S  a+\\s  a+\\W  a+\\w  a+.  a+\\R  a+\\H  a+\\h  a+\\V  a+\\v  a+\\Z  a+\\z  a+$/Bx\n------------------------------------------------------------------\n        Bra\n        a+\n        \\D\n        a++\n        \\d\n        a+\n        \\S\n        a++\n        \\s\n        a++\n        \\W\n        a+\n        \\w\n        a+\n        Any\n        a++\n        \\R\n        a+\n        \\H\n        a++\n        \\h\n        a+\n        \\V\n        a++\n        \\v\n        a++\n        \\Z\n        a++\n        \\z\n        a++\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\n+\\D \\n+\\d \\n+\\S \\n+\\s \\n+\\W \\n+\\w \\n+. \\n+\\R \\n+\\H \\n+\\h \\n+\\V \\n+\\v \\n+\\Z \\n+\\z \\n+$/Bx\n------------------------------------------------------------------\n        Bra\n        \\x0a+\n        \\D\n        \\x0a++\n        \\d\n        \\x0a++\n        \\S\n        \\x0a+\n        \\s\n        \\x0a+\n        \\W\n        \\x0a++\n        \\w\n        \\x0a+\n        Any\n        \\x0a+\n        \\R\n        \\x0a+\n        \\H\n        \\x0a++\n        \\h\n        \\x0a++\n        \\V\n        \\x0a+\n        \\v\n        \\x0a+\n        \\Z\n        \\x0a++\n        \\z\n        \\x0a+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bx\n------------------------------------------------------------------\n        Bra\n        Any+\n        \\D\n        Any+\n        \\d\n        Any+\n        \\S\n        Any+\n        \\s\n        Any+\n        \\W\n        Any+\n        \\w\n        Any+\n        Any\n        Any++\n        \\R\n        Any+\n        \\H\n        Any+\n        \\h\n        Any+\n        \\V\n        Any+\n        \\v\n        Any+\n        \\Z\n        Any++\n        \\z\n        Any+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ .+\\D  .+\\d  .+\\S  .+\\s  .+\\W  .+\\w  .+.  .+\\R  .+\\H  .+\\h  .+\\V  .+\\v  .+\\Z  .+\\z  .+$/Bsx\n------------------------------------------------------------------\n        Bra\n        AllAny+\n        \\D\n        AllAny+\n        \\d\n        AllAny+\n        \\S\n        AllAny+\n        \\s\n        AllAny+\n        \\W\n        AllAny+\n        \\w\n        AllAny+\n        AllAny\n        AllAny+\n        \\R\n        AllAny+\n        \\H\n        AllAny+\n        \\h\n        AllAny+\n        \\V\n        AllAny+\n        \\v\n        AllAny+\n        \\Z\n        AllAny++\n        \\z\n        AllAny+\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/ \\D+$  \\d+$  \\S+$  \\s+$  \\W+$  \\w+$  \\R+$  \\H+$  \\h+$  \\V+$ \\v+$  a+$   \\n+$  .+$  .+$/Bmx\n------------------------------------------------------------------\n        Bra\n        \\D+\n     /m $\n        \\d++\n     /m $\n        \\S++\n     /m $\n        \\s+\n     /m $\n        \\W+\n     /m $\n        \\w++\n     /m $\n        \\R+\n     /m $\n        \\H+\n     /m $\n        \\h+\n     /m $\n        \\V+\n     /m $\n        \\v+\n     /m $\n        a+\n     /m $\n        \\x0a+\n     /m $\n        Any+\n     /m $\n        Any+\n     /m $\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=a+)a(a+)++a/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        a++\n        Ket\n        a\n        CBraPos 1\n        a+\n        KetRpos\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(bb|cc)a+(?:bb|cc)a+(?>bb|cc)a+(?:bb|cc)+a+(aa)a+(?:bb|aa)/B\n------------------------------------------------------------------\n        Bra\n        a++\n        CBra 1\n        bb\n        Alt\n        cc\n        Ket\n        a++\n        Bra\n        bb\n        Alt\n        cc\n        Ket\n        a++\n        Once\n        bb\n        Alt\n        cc\n        Ket\n        a++\n        Bra\n        bb\n        Alt\n        cc\n        KetRmax\n        a+\n        CBra 2\n        aa\n        Ket\n        a+\n        Bra\n        bb\n        Alt\n        aa\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(bb|cc)?#a+(?:bb|cc)??#a+(?:bb|cc)?+#a+(?:bb|cc)*#a+(bb|cc)?a#a+(?:aa)?/B\n------------------------------------------------------------------\n        Bra\n        a++\n        Brazero\n        CBra 1\n        bb\n        Alt\n        cc\n        Ket\n        #\n        a++\n        Braminzero\n        Bra\n        bb\n        Alt\n        cc\n        Ket\n        #\n        a++\n        Once\n        Brazero\n        Bra\n        bb\n        Alt\n        cc\n        Ket\n        Ket\n        #\n        a++\n        Brazero\n        Bra\n        bb\n        Alt\n        cc\n        KetRmax\n        #\n        a+\n        Brazero\n        CBra 2\n        bb\n        Alt\n        cc\n        Ket\n        a#\n        a+\n        Brazero\n        Bra\n        aa\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(?:bb)?a#a+(?:|||)#a+(?:|b)a#a+(?:|||)?a/B\n------------------------------------------------------------------\n        Bra\n        a+\n        Brazero\n        Bra\n        bb\n        Ket\n        a#\n        a++\n        Bra\n        Alt\n        Alt\n        Alt\n        Ket\n        #\n        a+\n        Bra\n        Alt\n        b\n        Ket\n        a#\n        a+\n        Brazero\n        Bra\n        Alt\n        Alt\n        Alt\n        Ket\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/[ab]*/B\n------------------------------------------------------------------\n        Bra\n        [ab]*+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaaa\n\n/[ab]*?/B\n------------------------------------------------------------------\n        Bra\n        [ab]*?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: \n\n/[ab]?/B\n------------------------------------------------------------------\n        Bra\n        [ab]?+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: a\n\n/[ab]??/B\n------------------------------------------------------------------\n        Bra\n        [ab]??\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: \n\n/[ab]+/B\n------------------------------------------------------------------\n        Bra\n        [ab]++\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaaa\n\n/[ab]+?/B\n------------------------------------------------------------------\n        Bra\n        [ab]+?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: a\n\n/[ab]{2,3}/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,3}+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaa\n\n/[ab]{2,3}?/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,3}?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aa\n\n/[ab]{2,}/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,}+\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aaaa\n\n/[ab]{2,}?/B\n------------------------------------------------------------------\n        Bra\n        [ab]{2,}?\n        Ket\n        End\n------------------------------------------------------------------\n    aaaa\n 0: aa\n\n/\\d+\\s{0,5}=\\s*\\S?=\\w{0,4}\\W*/B\n------------------------------------------------------------------\n        Bra\n        \\d++\n        \\s{0,5}+\n        =\n        \\s*+\n        \\S?\n        =\n        \\w{0,4}+\n        \\W*+\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-d]{5,12}[e-z0-9]*#[^a-z]+[b-y]*a[2-7]?[^0-9a-z]+/B\n------------------------------------------------------------------\n        Bra\n        [a-d]{5,12}+\n        [0-9e-z]*+\n        #\n        [\\x00-`{-\\xff] (neg)++\n        [b-y]*+\n        a\n        [2-7]?+\n        [\\x00-/:-`{-\\xff] (neg)++\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-z]*\\s#[ \\t]?\\S#[a-c]*\\S#[C-G]+?\\d#[4-8]*\\D#[4-9,]*\\D#[!$]{0,5}\\w#[M-Xf-l]+\\W#[a-c,]?\\W/B\n------------------------------------------------------------------\n        Bra\n        [a-z]*+\n        \\s\n        #\n        [\\x09 ]?+\n        \\S\n        #\n        [a-c]*\n        \\S\n        #\n        [C-G]++\n        \\d\n        #\n        [4-8]*+\n        \\D\n        #\n        [,4-9]*\n        \\D\n        #\n        [!$]{0,5}+\n        \\w\n        #\n        [M-Xf-l]++\n        \\W\n        #\n        [,a-c]?\n        \\W\n        Ket\n        End\n------------------------------------------------------------------\n\n/a+(aa|bb)*c#a*(bb|cc)*a#a?(bb|cc)*d#[a-f]*(g|hh)*f/B\n------------------------------------------------------------------\n        Bra\n        a+\n        Brazero\n        CBra 1\n        aa\n        Alt\n        bb\n        KetRmax\n        c#\n        a*\n        Brazero\n        CBra 2\n        bb\n        Alt\n        cc\n        KetRmax\n        a#\n        a?+\n        Brazero\n        CBra 3\n        bb\n        Alt\n        cc\n        KetRmax\n        d#\n        [a-f]*\n        Brazero\n        CBra 4\n        g\n        Alt\n        hh\n        KetRmax\n        f\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-f]*(g|hh|i)*i#[a-x]{4,}(y{0,6})*y#[a-k]+(ll|mm)+n/B\n------------------------------------------------------------------\n        Bra\n        [a-f]*+\n        Brazero\n        CBra 1\n        g\n        Alt\n        hh\n        Alt\n        i\n        KetRmax\n        i#\n        [a-x]{4,}\n        Brazero\n        SCBra 2\n        y{0,6}\n        KetRmax\n        y#\n        [a-k]++\n        CBra 3\n        ll\n        Alt\n        mm\n        KetRmax\n        n\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-f]*(?>gg|hh)+#[a-f]*(?>gg|hh)?#[a-f]*(?>gg|hh)*a#[a-f]*(?>gg|hh)*h/B\n------------------------------------------------------------------\n        Bra\n        [a-f]*+\n        Once\n        gg\n        Alt\n        hh\n        KetRmax\n        #\n        [a-f]*+\n        Brazero\n        Once\n        gg\n        Alt\n        hh\n        Ket\n        #\n        [a-f]*\n        Brazero\n        Once\n        gg\n        Alt\n        hh\n        KetRmax\n        a#\n        [a-f]*+\n        Brazero\n        Once\n        gg\n        Alt\n        hh\n        KetRmax\n        h\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-c]*d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]*+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c d \nLast code unit = 'd'\nSubject length lower bound = 1\n\n/[a-c]+d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]++\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c \nLast code unit = 'd'\nSubject length lower bound = 2\n\n/[a-c]?d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]?+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c d \nLast code unit = 'd'\nSubject length lower bound = 1\n\n/[a-c]{4,6}d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]{4,6}+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c \nLast code unit = 'd'\nSubject length lower bound = 5\n\n/[a-c]{0,6}d/IB\n------------------------------------------------------------------\n        Bra\n        [a-c]{0,6}+\n        d\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nStarting code units: a b c d \nLast code unit = 'd'\nSubject length lower bound = 1\n\n# End of special auto-possessive tests\n\n/^A\\o{1239}B/\nFailed: error 164 at offset 8: non-octal character in \\o{} (closing brace missing?)\n    A\\123B\n\n/^A\\oB/\nFailed: error 155 at offset 4: missing opening brace after \\o\n\n/^A\\x{zz}B/\nFailed: error 167 at offset 5: non-hex character in \\x{} (closing brace missing?)\n\n/^A\\x{12Z/\nFailed: error 167 at offset 7: non-hex character in \\x{} (closing brace missing?)\n\n/^A\\x{/\nFailed: error 178 at offset 5: digits missing in \\x{} or \\o{} or \\N{U+}\n\n/[ab]++/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        [ab]++\n        Ket\n        End\n------------------------------------------------------------------\n\n/[^ab]*+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        [\\x00-`c-\\xff] (neg)*+\n        Ket\n        End\n------------------------------------------------------------------\n\n/a{4}+/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        a{4}\n        Ket\n        End\n------------------------------------------------------------------\n\n/a{4}+/Bi,no_auto_possess\n------------------------------------------------------------------\n        Bra\n     /i a{4}\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[A-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[a-[.xxx.]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[a-[=xxx=]]+/\nFailed: error 150 at offset 4: invalid range in character class\n\n/[a-[!xxx!]]+/\nFailed: error 108 at offset 3: range out of order in character class\n\n/[A-[!xxx!]]+/\n    A]]]\n 0: A]]]\n\n/[a-\\d]+/\nFailed: error 150 at offset 5: invalid range in character class\n\n/(?<0abc>xx)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?&1abc)xx(?<1abc>y)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?<ab-cd>xx)/\nFailed: error 142 at offset 5: syntax error in subpattern name (missing terminator?)\n\n/(?'0abc'xx)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?P<0abc>xx)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/\\k<5ghj>/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/\\k'5ghj'/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/\\k{2fgh}/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?P=8yuki)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/\\g{4df}/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/(?&1abc)xx(?<1abc>y)/\nFailed: error 144 at offset 3: subpattern name must start with a non-digit\n\n/(?P>1abc)xx(?<1abc>y)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/\\g'3gh'/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/\\g<5fg>/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/(?(<4gh>)abc)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/(?('4gh')abc)/\nFailed: error 144 at offset 4: subpattern name must start with a non-digit\n\n/(?(4gh)abc)/\nFailed: error 124 at offset 4: missing closing parenthesis for condition\n\n/(?(R&6yh)abc)/\nFailed: error 144 at offset 5: subpattern name must start with a non-digit\n\n/(((a\\2)|(a*)\\g<-1>))*a?/B\n------------------------------------------------------------------\n        Bra\n        Brazero\n        SCBra 1\n        CBra 2\n        CBra 3\n        a\n        \\2\n        Ket\n        Alt\n        CBra 4\n        a*\n        Ket\n        Recurse\n        Ket\n        KetRmax\n        a?+\n        Ket\n        End\n------------------------------------------------------------------\n\n# Test the ugly \"start or end of word\" compatibility syntax.\n\n/[[:<:]]red[[:>:]]/B\n------------------------------------------------------------------\n        Bra\n        \\b\n        Assert\n        \\w\n        Ket\n        red\n        \\b\n        Assert back\n        Reverse\n        \\w\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    little red riding hood\n 0: red\n    a /red/ thing\n 0: red\n    red is a colour\n 0: red\n    put it all on red\n 0: red\n\\= Expect no match\n    no reduction\nNo match\n    Alfred Winifred\nNo match\n\n/[a[:<:]] should give error/\nFailed: error 130 at offset 4: unknown POSIX class name\n\n/(?=ab\\K)/aftertext,allow_lookaround_bsk\n    abcd\\=startchar\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0+ abcd\n\n/abcd/newline=lf,firstline\n\\= Expect no match\n    xx\\nxabcd\nNo match\n\n# Test stack guard external calls.\n\n/(((a)))/stackguard=1\nFailed: error 133 at offset 7: parentheses are too deeply nested (stack check)\n\n/(((a)))/stackguard=2\nFailed: error 133 at offset 7: parentheses are too deeply nested (stack check)\n\n/(((a)))/stackguard=3\n\n/(((((a)))))/\n\n# End stack guard tests\n\n/^\\w+(?>\\s*)(?<=\\w)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        \\w+\n        Once\n        \\s*+\n        Ket\n        Assert back\n        Reverse\n        \\w\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/\\othing/\nFailed: error 155 at offset 2: missing opening brace after \\o\n\n/\\o{}/\nFailed: error 178 at offset 3: digits missing in \\x{} or \\o{} or \\N{U+}\n\n/\\o{whatever}/\nFailed: error 164 at offset 3: non-octal character in \\o{} (closing brace missing?)\n\n/\\xthing/\n\n/\\x{}/\nFailed: error 178 at offset 3: digits missing in \\x{} or \\o{} or \\N{U+}\n\n/\\x{whatever}/\nFailed: error 167 at offset 3: non-hex character in \\x{} (closing brace missing?)\n\n/A\\8B/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n/A\\9B/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n# This one is here because Perl fails to match \"12\" for this pattern when the $\n# is present.\n\n/^(?(?=abc)\\w{3}:|\\d\\d)$/\n    abc:\n 0: abc:\n    12\n 0: 12\n\\= Expect no match\n    123\nNo match\n    xyz\nNo match\n\n# Perl gets this one wrong, giving \"a\" as the after text for ca and failing to\n# match for cd.\n\n/(?(?=ab)ab)/aftertext\n    abxxx\n 0: ab\n 0+ xxx\n    ca\n 0: \n 0+ ca\n    cd\n 0: \n 0+ cd\n\n# This should test both paths for processing OP_RECURSE.\n\n/(?(R)a+|(?R)b)/\n    aaaabcde\n 0: aaaab\n    aaaabcde\\=ovector=100\n 0: aaaab\n\n/a*?b*?/\n    ab\n 0: \n\n/(*NOTEMPTY)a*?b*?/\n    ab\n 0: a\n    ba\n 0: b\n    cb\n 0: b\n\n/(*NOTEMPTY_ATSTART)a*?b*?/aftertext\n    ab\n 0: a\n 0+ b\n    cdab\n 0: \n 0+ dab\n\n/(?(VERSION>=10.0)yes|no)/I\nCapture group count = 0\nSubject length lower bound = 2\n    yesno\n 0: yes\n\n/(?(VERSION>=10.04)yes|no)/\n    yesno\n 0: yes\n\n/(?(VERSION=8)yes){3}/BI,aftertext\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        yes\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n    yesno\n 0: \n 0+ yesno\n\n/(?(VERSION=8)yes|no){3}/I\nCapture group count = 0\nSubject length lower bound = 6\n    yesnononoyes\n 0: nonono\n\\= Expect no match\n    yesno\nNo match\n\n/(?:(?<VERSION>abc)|xyz)(?(VERSION)yes|no)/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  VERSION   1\nStarting code units: a x \nSubject length lower bound = 5\n    abcyes\n 0: abcyes\n 1: abc\n    xyzno\n 0: xyzno\n\\= Expect no match\n    abcno\nNo match\n    xyzyes\nNo match\n\n/(?(VERSION<10)yes|no)/\nFailed: error 179 at offset 10: syntax error or number too big in (?(VERSION condition\n\n/(?(VERSION>10)yes|no)/\nFailed: error 179 at offset 11: syntax error or number too big in (?(VERSION condition\n\n/(?(VERSION>=10.0.0)yes|no)/\nFailed: error 179 at offset 16: syntax error or number too big in (?(VERSION condition\n\n/(?(VERSION=10.101)yes|no)/\nFailed: error 179 at offset 16: syntax error or number too big in (?(VERSION condition\n\n/abcd/I\nCapture group count = 0\nFirst code unit = 'a'\nLast code unit = 'd'\nSubject length lower bound = 4\n\n/abcd/I,no_start_optimize\nCapture group count = 0\nOptions: no_start_optimize\n\n/(|ab)*?d/I\nCapture group count = 1\nStarting code units: a d \nLast code unit = 'd'\nSubject length lower bound = 1\n   abd\n 0: abd\n 1: ab\n   xyd\n 0: d\n\n/(|ab)*?d/I,no_start_optimize\nCapture group count = 1\nOptions: no_start_optimize\n   abd\n 0: abd\n 1: ab\n   xyd\n 0: d\n\n/\\k<A>*(?<A>aa)(?<A>bb)/match_unset_backref,dupnames\n    aabb\n 0: aabb\n 1: aa\n 2: bb\n\n/(((((a)))))/parens_nest_limit=2\nFailed: error 119 at offset 3: parentheses are too deeply nested\n\n/abc/replace=XYZ\n    123123\n 0: 123123\n    123abc123\n 1: 123XYZ123\n    123abc123abc123\n 1: 123XYZ123abc123\n    123123\\=zero_terminate\n 0: 123123\n    123abc123\\=zero_terminate\n 1: 123XYZ123\n    123abc123abc123\\=zero_terminate\n 1: 123XYZ123abc123\n\n/abc/g,replace=XYZ\n    123abc123\n 1: 123XYZ123\n    123abc123abc123\n 2: 123XYZ123XYZ123\n\n/abc/replace=X$$Z\n    123abc123\n 1: 123X$Z123\n\n/abc/g,replace=X$$Z\n    123abc123abc123\n 2: 123X$Z123X$Z123\n\n/a(b)c(d)e/replace=X$1Y${2}Z\n    \"abcde\"\n 1: \"XbYdZ\"\n\n/a(b)c(d)e/replace=X$1Y${2}Z,global\n    \"abcde-abcde\"\n 2: \"XbYdZ-XbYdZ\"\n\n/a(?<ONE>b)c(?<TWO>d)e/replace=X$ONE+${TWO}Z\n    \"abcde\"\n 1: \"Xb+dZ\"\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z\n    \"abcde-abcde-\"\n 2: \"Xb+dZ-Xb+dZ-\"\n\n/abc/replace=a$++\n    123abc\nFailed: error -35 at offset 2 in replacement: invalid replacement string\n\n/abc/replace=a$bad\n    123abc\nFailed: error -49 at offset 5 in replacement: unknown substring\n\n/abc/replace=a${A234567890123456789_123456789012}z\n    123abc\nFailed: error -49 at offset 36 in replacement: unknown substring\n\n/abc/replace=a${A23456789012345678901234567890123}z\n    123abc\nFailed: error -35 at offset 35 in replacement: invalid replacement string\n\n/abc/replace=a${bcd\n    123abc\nFailed: error -58 at offset 6 in replacement: expected closing curly bracket in replacement string\n\n/abc/replace=a${b+d}z\n    123abc\nFailed: error -58 at offset 4 in replacement: expected closing curly bracket in replacement string\n\n/abc/replace=[10]XYZ\n    123abc123\n 1: 123XYZ123\n\n/abc/replace=[9]XYZ\n    123abc123\nFailed: error -48: no more memory\n\n/abc/replace=xyz\n    1abc2\\=partial_hard\nFailed: error -34: bad option value\n\n/abc/replace=xyz\n    123abc456\n 1: 123xyz456\n    123abc456\\=replace=pqr\n 1: 123pqr456\n    123abc456abc789\n 1: 123xyz456abc789\n    123abc456abc789\\=g\n 2: 123xyz456xyz789\n\n/(?<=abc)(|def)/g,replace=<$0>\n    123abcxyzabcdef789abcpqr\n 4: 123abc<>xyzabc<><def>789abc<>pqr\n\n/./replace=$0\n    a\n 1: a\n\n/(.)(.)/replace=$2+$1\n    abc\n 1: b+ac\n\n/(?<A>.)(?<B>.)/replace=$B+$A\n    abc\n 1: b+ac\n\n/(.)(.)/g,replace=$2$1\n    abcdefgh\n 4: badcfehg\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=${*MARK}\n    apple lemon blackberry\n 3: pear orange strawberry\n    apple strudel\n 1: pear strudel\n    fruitless\n 0: fruitless\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/replace=${*MARK} sauce,\n    apple lemon blackberry\n 1: pear sauce lemon blackberry\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARK>\n    apple lemon blackberry\n 3: <pear> <orange> <strawberry>\n    apple strudel\n 1: <pear> strudel\n    fruitless\n 0: fruitless\n\n/(*:pear)apple/g,replace=${*MARKING}\n    apple lemon blackberry\nFailed: error -35 at offset 11 in replacement: invalid replacement string\n\n/(*:pear)apple/g,replace=${*MARK-time\n    apple lemon blackberry\nFailed: error -58 at offset 7 in replacement: expected closing curly bracket in replacement string\n\n/(*:pear)apple/g,replace=${*mark}\n    apple lemon blackberry\nFailed: error -35 at offset 8 in replacement: invalid replacement string\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARKET>\n    apple lemon blackberry\nFailed: error -35 at offset 9 in replacement: invalid replacement string\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[22]${*MARK}\n    apple lemon blackberry\nFailed: error -48: no more memory\n    apple lemon blackberry\\=substitute_overflow_length\nFailed: error -48: no more memory: 23 code units are needed\n\n/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[23]${*MARK}\n    apple lemon blackberry\n 3: pear orange strawberry\n\n/abc/\n    123abc123\\=replace=[9]XYZ\nFailed: error -48: no more memory\n    123abc123\\=substitute_overflow_length,replace=[9]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[6]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[1]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[0]XYZ\nFailed: error -48: no more memory: 10 code units are needed\n\n/a(b)c/\n    123abc123\\=replace=[9]x$1z\nFailed: error -48: no more memory\n    123abc123\\=substitute_overflow_length,replace=[9]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[6]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[1]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n    123abc123\\=substitute_overflow_length,replace=[0]x$1z\nFailed: error -48: no more memory: 10 code units are needed\n\n\"((?=(?(?=(?(?=(?(?=()))))))))\"\n    a\n 0: \n 1: \n 2: \n\n\"(?(?=)==)(((((((((?=)))))))))\"\n\\= Expect no match\n    a\nNo match\n\n/(a)(b)|(c)/\n    XcX\\=ovector=2,get=1,get=2,get=3,get=4,getall\nMatched, but too many substrings\n 0: c\n 1: <unset>\nGet substring 1 failed (-55): requested value is not set\nGet substring 2 failed (-54): requested value is not available\nGet substring 3 failed (-54): requested value is not available\nGet substring 4 failed (-49): unknown substring\n 0L c\n 1L \n\n/x(?=ab\\K)/allow_lookaround_bsk\n    xab\\=get=0\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0G  (0)\n    xab\\=copy=0\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0C  (0)\n    xab\\=getall\nStart of matched string is beyond its end - displaying from end to start.\n 0: ab\n 0L \n\n/(?<A>a)|(?<A>b)/dupnames\n    a\\=ovector=1,copy=A,get=A,get=2\nMatched, but too many substrings\n 0: a\nCopy substring 'A' failed (-54): requested value is not available\nGet substring 2 failed (-54): requested value is not available\nGet substring 'A' failed (-54): requested value is not available\n    a\\=ovector=2,copy=A,get=A,get=2\n 0: a\n 1: a\n  C a (1) A (non-unique)\nGet substring 2 failed (-54): requested value is not available\n  G a (1) A (non-unique)\n    b\\=ovector=2,copy=A,get=A,get=2\nMatched, but too many substrings\n 0: b\n 1: <unset>\nCopy substring 'A' failed (-55): requested value is not set\nGet substring 2 failed (-54): requested value is not available\nGet substring 'A' failed (-55): requested value is not set\n\n/a(b)c(d)/\n    abc\\=ph,copy=0,copy=1,getall\nPartial match: abc\n 0C abc (3)\nCopy substring 1 failed (-2): partial match\nget substring list failed (-2): partial match\n\n/^abc/info\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/^abc/info,no_dotstar_anchor\nCapture group count = 0\nCompile options: no_dotstar_anchor\nOverall options: anchored no_dotstar_anchor\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/.*\\d/info,auto_callout\nCapture group count = 0\nOptions: auto_callout\nFirst code unit at start or follows newline\nSubject length lower bound = 1\n\\= Expect no match\n    aaa\n--->aaa\n +0 ^       .*\n +2 ^  ^    \\d\n +2 ^ ^     \\d\n +2 ^^      \\d\n +2 ^       \\d\nNo match\n\n/.*\\d/info,no_dotstar_anchor,auto_callout\nCapture group count = 0\nOptions: auto_callout no_dotstar_anchor\nSubject length lower bound = 1\n\\= Expect no match\n    aaa\n--->aaa\n +0 ^       .*\n +2 ^  ^    \\d\n +2 ^ ^     \\d\n +2 ^^      \\d\n +2 ^       \\d\n +0  ^      .*\n +2  ^ ^    \\d\n +2  ^^     \\d\n +2  ^      \\d\n +0   ^     .*\n +2   ^^    \\d\n +2   ^     \\d\nNo match\n\n/.*\\d/dotall,info\nCapture group count = 0\nCompile options: dotall\nOverall options: anchored dotall\nSubject length lower bound = 1\n\n/.*\\d/dotall,no_dotstar_anchor,info\nCapture group count = 0\nOptions: dotall no_dotstar_anchor\nSubject length lower bound = 1\n\n/(*NO_DOTSTAR_ANCHOR)(?s).*\\d/info\nCapture group count = 0\nCompile options: <none>\nOverall options: no_dotstar_anchor\nSubject length lower bound = 1\n\n'^(?:(a)|b)(?(1)A|B)'\n    aA123\\=ovector=1\nMatched, but too many substrings\n 0: aA\n    aA123\\=ovector=2\n 0: aA\n 1: a\n\n'^(?:(?<AA>a)|b)(?(<AA>)A|B)'\n    aA123\\=ovector=1\nMatched, but too many substrings\n 0: aA\n    aA123\\=ovector=2\n 0: aA\n 1: a\n\n'^(?<AA>)(?:(?<AA>a)|b)(?(<AA>)A|B)'dupnames\n    aA123\\=ovector=1\nMatched, but too many substrings\n 0: aA\n    aA123\\=ovector=2\nMatched, but too many substrings\n 0: aA\n 1: \n    aA123\\=ovector=3\n 0: aA\n 1: \n 2: a\n\n'^(?:(?<AA>X)|)(?:(?<AA>a)|b)\\k{AA}'dupnames\n    aa123\\=ovector=1\nMatched, but too many substrings\n 0: aa\n    aa123\\=ovector=2\nMatched, but too many substrings\n 0: aa\n 1: <unset>\n    aa123\\=ovector=3\n 0: aa\n 1: <unset>\n 2: a\n\n/(?<N111>(?J)(?<N111>1(111111)11|)1|1|)(?(<N111>)1)/\n\n/(?<N>(?J)(?<N>))(?-J)\\k<N>/\n\n# Quantifiers are not allowed on condition assertions, but are otherwise\n# OK in conditions.\n\n/(?(?=0)?)+/\nFailed: error 109 at offset 7: quantifier does not follow a repeatable item\n\n/(?(?=0)(?=00)?00765)/\n     00765\n 0: 00765\n\n/(?(?=0)(?=00)?00765|(?!3).56)/\n     00765\n 0: 00765\n     456\n 0: 456\n\\= Expect no match\n     356\nNo match\n\n'^(a)*+(\\w)'\n    g\n 0: g\n 1: <unset>\n 2: g\n    g\\=ovector=1\nMatched, but too many substrings\n 0: g\n\n'^(?:a)*+(\\w)'\n    g\n 0: g\n 1: g\n    g\\=ovector=1\nMatched, but too many substrings\n 0: g\n\n# These two pattern showeds up compile-time bugs\n\n\"((?2){0,1999}())?\"\n\n/((?+1)(\\1))/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Recurse\n        CBra 2\n        \\1\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# Callouts with string arguments\n\n/a(?C\"/\nFailed: error 181 at offset 4: missing terminating delimiter for callout with string argument\n\n/a(?C\"a/\nFailed: error 181 at offset 4: missing terminating delimiter for callout with string argument\n\n/a(?C\"a\"/\nFailed: error 139 at offset 7: closing parenthesis for (?C expected\n\n/a(?C\"a\"bcde(?C\"b\")xyz/\nFailed: error 139 at offset 7: closing parenthesis for (?C expected\n\n/a(?C\"a)b\"\"c\")/B\n------------------------------------------------------------------\n        Bra\n        a\n        CalloutStr \"a)b\"c\" 5 13 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/ab(?C\" any text with spaces \")cde/B\n------------------------------------------------------------------\n        Bra\n        ab\n        CalloutStr \" any text with spaces \" 6 30 1\n        cde\n        Ket\n        End\n------------------------------------------------------------------\n    abcde\nCallout (6): \" any text with spaces \"\n--->abcde\n    ^ ^       c\n 0: abcde\n    12abcde\nCallout (6): \" any text with spaces \"\n--->12abcde\n      ^ ^       c\n 0: abcde\n\n/^a(b)c(?C1)def/\n      abcdef\n--->abcdef\n  1 ^  ^       d\n 0: abcdef\n 1: b\n\n/^a(b)c(?C\"AB\")def/\n      abcdef\nCallout (10): \"AB\"\n--->abcdef\n    ^  ^       d\n 0: abcdef\n 1: b\n\n/^a(b)c(?C1)def/\n      abcdef\\=callout_capture\nCallout 1: last capture = 1\n 1: b\n--->abcdef\n    ^  ^       d\n 0: abcdef\n 1: b\n\n/^a(b)c(?C{AB})def/B\n------------------------------------------------------------------\n        Bra\n        ^\n        a\n        CBra 1\n        b\n        Ket\n        c\n        CalloutStr {AB} 10 14 1\n        def\n        Ket\n        End\n------------------------------------------------------------------\n      abcdef\\=callout_capture\nCallout (10): {AB} last capture = 1\n 1: b\n--->abcdef\n    ^  ^       d\n 0: abcdef\n 1: b\n\n/(?C`a``b`)(?C'a''b')(?C\"a\"\"b\")(?C^a^^b^)(?C%a%%b%)(?C#a##b#)(?C$a$$b$)(?C{a}}b})/B,callout_info\n------------------------------------------------------------------\n        Bra\n        CalloutStr `a`b` 4 10 0\n        CalloutStr 'a'b' 14 20 0\n        CalloutStr \"a\"b\" 24 30 0\n        CalloutStr ^a^b^ 34 40 0\n        CalloutStr %a%b% 44 50 0\n        CalloutStr #a#b# 54 60 0\n        CalloutStr $a$b$ 64 70 0\n        CalloutStr {a}b} 74 80 0\n        Ket\n        End\n------------------------------------------------------------------\nCallout `a`b`  (\nCallout 'a'b'  (\nCallout \"a\"b\"  (\nCallout ^a^b^  (\nCallout %a%b%  (\nCallout #a#b#  (\nCallout $a$b$  (\nCallout {a}b}  \n\n/(?:a(?C`code`)){3}/B\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        CalloutStr `code` 8 14 4\n        Ket\n        Bra\n        a\n        CalloutStr `code` 8 14 4\n        Ket\n        Bra\n        a\n        CalloutStr `code` 8 14 4\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(?(?C25)(?=abc)abcd|xyz)/B,callout_info\n------------------------------------------------------------------\n        Bra\n        ^\n        Cond\n        Callout 25 9 3\n        Assert\n        abc\n        Ket\n        abcd\n        Alt\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCallout 25  (?=\n    abcdefg\n--->abcdefg\n 25 ^           (?=\n 0: abcd\n    xyz123\n--->xyz123\n 25 ^          (?=\n 0: xyz\n\n/^(?(?C$abc$)(?=abc)abcd|xyz)/B\n------------------------------------------------------------------\n        Bra\n        ^\n        Cond\n        CalloutStr $abc$ 7 12 3\n        Assert\n        abc\n        Ket\n        abcd\n        Alt\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n    abcdefg\nCallout (7): $abc$\n--->abcdefg\n    ^           (?=\n 0: abcd\n    xyz123\nCallout (7): $abc$\n--->xyz123\n    ^          (?=\n 0: xyz\n\n/^ab(?C'first')cd(?C\"second\")ef/\n    abcdefg\nCallout (7): 'first'\n--->abcdefg\n    ^ ^         c\nCallout (20): \"second\"\n--->abcdefg\n    ^   ^       e\n 0: abcdef\n\n/(?:a(?C`code`)){3}X/\n    aaaXY\nCallout (8): `code`\n--->aaaXY\n    ^^        ){3}\nCallout (8): `code`\n--->aaaXY\n    ^ ^       ){3}\nCallout (8): `code`\n--->aaaXY\n    ^  ^      ){3}\n 0: aaaX\n\n# Binary zero in callout string\n#  a  (  ?  C  '  x     z  '  )  b\n/ 61 28 3f 43 27 78 00 7a 27 29 62/hex,callout_info\nCallout 'x\\x00z'  b\n    abcdefgh\nCallout (5): 'x\\x00z'\n--->abcdefgh\n    ^^           b\n 0: ab\n\n/(?(?!)^)/\n\n/(?(?!)a|b)/\n    bbb\n 0: b\n\\= Expect no match\n    aaa\nNo match\n\n# JIT gives a different error message for the infinite recursion\n\n\"(*NO_JIT)((?2)+)((?1)){\"\n    abcd{\nFailed: error -52: nested recursion at the same subject position\n\n# Perl fails to diagnose the absence of an assertion\n\n\"(?(?<E>.*!.*)?)\"\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n\"X((?2)()*+){2}+\"B\n------------------------------------------------------------------\n        Bra\n        X\n        Once\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n\"X((?2)()*+){2}\"B\n------------------------------------------------------------------\n        Bra\n        X\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        CBra 1\n        Recurse\n        Braposzero\n        SCBraPos 2\n        KetRpos\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<=\\bABQ(3(?-7)))/\nFailed: error 115 at offset 15: reference to non-existent subpattern\n\n/(?<=\\bABQ(3(?+7)))/\nFailed: error 115 at offset 15: reference to non-existent subpattern\n\n\";(?<=()((?3))((?2)))\"\nFailed: error 125 at offset 1: lookbehind assertion is not fixed length\n\n# Perl loops on this (PCRE2 used to!)\n\n/(?<=\\Ka)/g,aftertext,allow_lookaround_bsk\n    aaaaa\n 0: a\n 0+ aaaa\n 0: a\n 0+ aaa\n 0: a\n 0+ aa\n 0: a\n 0+ a\n 0: a\n 0+ \n\n/(?<=\\Ka)/altglobal,aftertext,allow_lookaround_bsk\n    aaaaa\n 0: a\n 0+ aaaa\n 0: a\n 0+ aaa\n 0: a\n 0+ aa\n 0: a\n 0+ a\n 0: a\n 0+ \n\n/((?2){73}(?2))((?1))/info\nCapture group count = 2\nMay match empty string\nSubject length lower bound = 0\n\n/abc/\n\\= Expect no match\n    \\[9x!xxx(]{9999}\nNo match\n\n/(abc)*/\n    \\[abc]{5}\n 0: abcabcabcabcabc\n 1: abc\n\n/^/gm\n    \\n\\n\\n\n 0: \n 0: \n 0: \n\n/^/gm,alt_circumflex\n    \\n\\n\\n\n 0: \n 0: \n 0: \n 0: \n\n/((((((((x))))))))\\81/\nFailed: error 115 at offset 19: reference to non-existent subpattern\n    xx1\n\n/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\\80/\n    xx\nMatched, but too many substrings\n 0: xx\n 1: x\n 2: x\n 3: x\n 4: x\n 5: x\n 6: x\n 7: x\n 8: x\n 9: x\n10: x\n11: x\n12: x\n13: x\n14: x\n\n/\\80/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n/A\\8B\\9C/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n    A8B9C\n\n/(?x:((?'a')) # comment (with parentheses) and | vertical\n(?-x:#not a comment (?'b')) # this is a comment ()\n(?'c')) # not a comment (?'d')/info\nCapture group count = 5\nNamed capture groups:\n  a   2\n  b   3\n  c   4\n  d   5\nFirst code unit = '#'\nLast code unit = ' '\nSubject length lower bound = 32\n\n/(?|(?'a')(2)(?'b')|(?'a')(?'a')(3))/I,dupnames\nCapture group count = 3\nNamed capture groups:\n  a   1\n  a   2\n  b   3\nOptions: dupnames\nStarting code units: 2 3 \nSubject length lower bound = 1\n    A23B\n 0: 2\n 1: \n 2: 2\n 3: \n    B32A\n 0: 3\n 1: \n 2: \n 3: 3\n\n# These are some patterns that used to cause buffer overflows or other errors\n# while compiling.\n\n/.((?2)(?R)|\\1|$)()/B\n------------------------------------------------------------------\n        Bra\n        Any\n        CBra 1\n        Recurse\n        Recurse\n        Alt\n        \\1\n        Alt\n        $\n        Ket\n        CBra 2\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/.((?3)(?R)()(?2)|\\1|$)()/B\n------------------------------------------------------------------\n        Bra\n        Any\n        CBra 1\n        Recurse\n        Recurse\n        CBra 2\n        Ket\n        Recurse\n        Alt\n        \\1\n        Alt\n        $\n        Ket\n        CBra 3\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(\\9*+(?2);\\3++()2|)++{/\nFailed: error 115 at offset 2: reference to non-existent subpattern\n\n/\\V\\x85\\9*+((?2)\\3++()2)*:2/\nFailed: error 115 at offset 7: reference to non-existent subpattern\n\n/(((?(R)){0,2}) (?'x'((?'R')((?'R')))))/dupnames\n\n/(((?(X)){0,2}) (?'x'((?'X')((?'X')))))/dupnames\n\n/(((?(R)){0,2}) (?'x'((?'X')((?'R')))))/\n\n\"(?J)(?'d'(?'d'\\g{d}))\"\n\n\"(?=!((?2)(?))({8(?<=(?1){29}8bbbb\\x16\\xd\\xc6^($(\\xa9H4){4}h}?1)B))\\x15')\"\nFailed: error 125 at offset 16: lookbehind assertion is not fixed length\n\n/A(?'')Z/\nFailed: error 162 at offset 4: subpattern name expected\n\n\"(?J:(?|(?'R')(\\k'R')|((?'R'))))\"\n\n/(?<=|(\\,\\$(?73591620449005828816)\\xa8.{7}){6}\\x09)/\nFailed: error 161 at offset 17: subpattern number is too big\n\n/^(?:(?(1)x|)+)+$()/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SBra\n        SCond\n      1 Cond ref\n        x\n        Alt\n        KetRmax\n        KetRmax\n        $\n        CBra 1\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/[[:>:]](?<)/\nFailed: error 162 at offset 10: subpattern name expected\n\n/((?x)(*:0))#(?'/\nFailed: error 162 at offset 15: subpattern name expected\n\n/(?C$[$)(?<]/\nFailed: error 162 at offset 10: subpattern name expected\n\n/(?C$)$)(?<]/\nFailed: error 162 at offset 10: subpattern name expected\n\n/(?(R))*+/B\n------------------------------------------------------------------\n        Bra\n        Braposzero\n        SBraPos\n        SCond\n        Cond recurse any\n        Ket\n        KetRpos\n        Ket\n        End\n------------------------------------------------------------------\n    abcd\n 0: \n\n/((?x)(?#))#(?'/\nFailed: error 162 at offset 14: subpattern name expected\n\n/((?x)(?#))#(?'abc')/I\nCapture group count = 2\nNamed capture groups:\n  abc   2\nFirst code unit = '#'\nSubject length lower bound = 1\n\n/[[:\\\\](?<[::]/\nFailed: error 162 at offset 9: subpattern name expected\n\n/[[:\\\\](?'abc')[a:]/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nStarting code units: : [ \\ \nSubject length lower bound = 2\n\n\"[[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[:::::::::::::::::[[.\\xe8Nq\\xffq\\xff\\xe0\\x2|||::Nq\\xffq\\xff\\xe0\\x6\\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[[[:::E[[[:[:[[:[:::[[:::E[[[:[:[[:'[:::::E[[[:[::::::[[[:[[[[[[[::E[[[:[::::::[[[:[[[[[[[[:[[::[::::[[:::::::[[:[[[[[[[:[[::[:[[:[~\"\nFailed: error 106 at offset 353: missing terminating ] for character class\n\n/()(?(R)0)*+/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        Ket\n        Braposzero\n        SBraPos\n        SCond\n        Cond recurse any\n        0\n        Ket\n        KetRpos\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?R-:(?</\nFailed: error 158 at offset 3: (?R (recursive pattern call) must be followed by a closing parenthesis\n\n/(?R-:(?<)/\nFailed: error 158 at offset 3: (?R (recursive pattern call) must be followed by a closing parenthesis\n\n/(?(?C{\\Q})(?!(?'/\nFailed: error 162 at offset 16: subpattern name expected\n\n/(?(?C{\\Q})(?!(?'abc')))/I\nCapture group count = 1\nNamed capture groups:\n  abc   1\nMay match empty string\nSubject length lower bound = 0\n\n/(?1){3918}(((((0(\\k'R'))))(?J)(?'R'(?'R'\\3){99})))/I\nCapture group count = 8\nMax back reference = 8\nNamed capture groups:\n  R   7\n  R   8\nDuplicate name status changes\nLast code unit = '0'\nSubject length lower bound = 65535\n\n/(?|(aaa)|(b))\\g{1}/I\nCapture group count = 1\nMax back reference = 1\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?|(aaa)|(b))(?1)/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 4\n\n/(?|(aaa)|(b))/I\nCapture group count = 1\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?|(?'a'aaa)|(?'a'b))\\k'a'/I\nCapture group count = 1\nMax back reference = 1\nNamed capture groups:\n  a   1\nStarting code units: a b \nSubject length lower bound = 1\n\n/(?|(?'a'aaa)|(?'a'b))(?'a'cccc)\\k'a'/I,dupnames\nCapture group count = 2\nMax back reference = 2\nNamed capture groups:\n  a   1\n  a   2\nOptions: dupnames\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 5\n\n/ab{3cd/\n    ab{3cd\n 0: ab{3cd\n\n/ab{3,cd/\n    ab{3,cd\n 0: ab{3,cd\n\n/ab{3,4a}cd/\n    ab{3,4a}cd\n 0: ab{3,4a}cd\n\n/{4,5a}bc/\n    {4,5a}bc\n 0: {4,5a}bc\n\n/\\x0{ab}/\n    \\0{ab}\n 0: \\x00{ab}\n\n/^(a(b))\\1\\g1\\g{1}\\g-1\\g{-1}\\g{-02}Z/\n    ababababbbabZXXXX\n 0: ababababbbabZ\n 1: ab\n 2: b\n\n/.*?a(*PRUNE)b/\n    aab\n 0: ab\n\n/.*?a(*PRUNE)b/s\n    aab\n 0: ab\n\n/^a(*PRUNE)b/s\n\\= Expect no match\n    aab\nNo match\n\n/.*?a(*SKIP)b/\n    aab\n 0: ab\n\n/(?(8000000000/\nFailed: error 161 at offset 8: subpattern number is too big\n\n/((?(R8000000000)))/\nFailed: error 161 at offset 9: subpattern number is too big\n\n/0(?0)|(1)(*THEN)(*SKIP:0)(*FAIL)/\n\\= Expect no match\n    01\nNo match\n\n/(?(1)()\\983040\\2)/\nFailed: error 161 at offset 14: subpattern number is too big\n\n/(*LIMIT_MATCH=)abc/\nFailed: error 160 at offset 14: (*VERB) not recognized or malformed\n\n/(*CRLF)(*LIMIT_MATCH=)abc/\nFailed: error 160 at offset 21: (*VERB) not recognized or malformed\n\n/(?:ab)?(?:ab)(?:ab)/\n    abab\n 0: abab\n    ababab\n 0: ababab\n\\= Expect no match\n    aba\nNo match\n\n/((*MARK:A))++a(*SKIP:B)b/\n\\= Expect no match\n    aacb\nNo match\n\n/(*MARK:a\\zb)z/alt_verbnames\nFailed: error 140 at offset 10: invalid escape sequence in (*VERB) name\n\n/(*:ab\\t(d\\)c)xxx/\nFailed: error 122 at offset 12: unmatched closing parenthesis\n\n/(*:ab\\t(d\\)c)xxx/alt_verbnames,mark\n    cxxxz\n 0: xxx\nMK: ab\\x09(d)c\n\n/(*:A\\Qxx)x\\EB)x/alt_verbnames,mark\n    x\n 0: x\nMK: Axx)xB\n\n/(*:A\\ExxxB)x/alt_verbnames,mark\n    x\n 0: x\nMK: AxxxB\n\n/(*: A \\ and #comment\n     \\ B)x/x,alt_verbnames,mark\n    x\n 0: x\nMK: A and B\n\n/(*: A \\ and #comment\n     \\ B)x/alt_verbnames,mark\n    x\n 0: x\nMK:  A  and #comment\\x0a      B\n\n/(*: A \\ and #comment\n     \\ B)x/x,mark\n    x\n 0: x\nMK:  A \\ and #comment\\x0a     \\ B\n\n/(*: A \\ and #comment\n     \\ B)x/mark\n    x\n 0: x\nMK:  A \\ and #comment\\x0a     \\ B\n\n/(*:A\nB)x/alt_verbnames,mark\n    x\n 0: x\nMK: A\\x0aB\n\n/(*:abc\\Qpqr)/alt_verbnames\nFailed: error 160 at offset 12: (*VERB) not recognized or malformed\n\n/abc/use_offset_limit\n    1234abcde\\=offset_limit=100\n 0: abc\n    1234abcde\\=offset_limit=9\n 0: abc\n    1234abcde\\=offset_limit=4\n 0: abc\n    1234abcde\\=offset_limit=4,offset=4\n 0: abc\n\\= Expect no match\n    1234abcde\\=offset_limit=4,offset=5\nNo match\n    1234abcde\\=offset_limit=3\nNo match\n\n/(?<=abc)/use_offset_limit\n    1234abc\\=offset_limit=7\n 0: \n\\= Expect no match\n    1234abc\\=offset_limit=6\nNo match\n\n/A/g,replace=-,use_offset_limit\n    XAXAXAXAXA\\=offset_limit=4\n 2: X-X-XAXAXA\n\n/abc/\n\\= Expect error\n    1234abcde\\=offset_limit=4\nFailed: error -56: offset limit set without PCRE2_USE_OFFSET_LIMIT\n\n/^\\w/m,use_offset_limit\n    \\n..\\naa\\=offset_limit=3\nNo match\n    \\n..\\naa\\=offset_limit=4\n 0: a\n\n/abcd/null_context\n    abcd\\=null_context\n 0: abcd\n\\= Expect error - not allowed together\n    abcd\\=null_context,find_limits\n** Not allowed together: find_limits null_context\n    abcd\\=allusedtext,startchar\n** Not allowed together: allusedtext startchar\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended\n    abcd\n 1: w\\x0dx\\x82y\\xdbz(12\\$34$$\\x345$)\n\n/abcd/replace=w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$),substitute_extended,substitute_literal\n    >>abcd<<\n 1: >>w\\rx\\x82y\\o{333}z(\\Q12\\$34$$\\x34\\E5$$)<<\n    \n/abcd/g,replace=\\$1$2\\,substitute_literal\n    XabcdYabcdZ\n 2: X\\$1$2\\Y\\$1$2\\Z\n\n/a(bc)(DE)/replace=a\\u$1\\U$1\\E$1\\l$2\\L$2\\Eab\\Uab\\LYZ\\EDone,substitute_extended\n    abcDE\n 1: aBcBCbcdEdeabAByzDone\n\n/abcd/replace=xy\\kz,substitute_extended\n    abcd\nFailed: error -57 at offset 4 in replacement: bad escape sequence in replacement string\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:+1:-1}X${2:+2:-2}\n    ab\n 1: X1X-2\n    ac\n 1: X-1X2\n    ab\\=replace=${1:+$1\\:$1:$2}\n 1: b:b\n    ac\\=replace=${1:+$1\\:$1:$2}\n 1: c\n    >>ac<<\\=replace=${1:+$1\\:$1:$2},substitute_literal\n 1: >>${1:+$1\\:$1:$2}<<\n\n/a(?:(b)|(c))/substitute_extended,replace=X${1:-1:-1}X${2:-2:-2}\n    ab\n 1: XbX2:-2\n    ac\n 1: X1:-1Xc\n\n/(a)/substitute_extended,replace=>${1:+\\Q$1:{}$$\\E+\\U$1}<\n    a\n 1: >$1:{}$$+A<\n\n/X(b)Y/substitute_extended\n    XbY\\=replace=x${1:+$1\\U$1}y\n 1: xbBY\n    XbY\\=replace=\\Ux${1:+$1$1}y\n 1: XBBY\n\n/a/substitute_extended,replace=${*MARK:+a:b}\n    a\nFailed: error -58 at offset 7 in replacement: expected closing curly bracket in replacement string\n\n/(abcd)/replace=${1:+xy\\kz},substitute_extended\n    abcd\nFailed: error -57 at offset 8 in replacement: bad escape sequence in replacement string\n\n/(abcd)/\n    abcd\\=replace=${1:+xy\\kz},substitute_extended\nFailed: error -57 at offset 8 in replacement: bad escape sequence in replacement string\n\n/abcd/substitute_extended,replace=>$1<\n    abcd\nFailed: error -49 at offset 3 in replacement: unknown substring\n\n/abcd/substitute_extended,replace=>xxx${xyz}<<<\n    abcd\nFailed: error -49 at offset 10 in replacement: unknown substring\n\n/(?J)(?:(?<A>a)|(?<A>b))/replace=<$A>\n    [a]\n 1: [<a>]\n    [b]\n 1: [<b>]\n\\= Expect error\n    (a)\\=ovector=1\nFailed: error -54 at offset 3 in replacement: requested value is not available\n\n/(a)|(b)/replace=<$1>\n\\= Expect error\n    b\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/(aa)(BB)/substitute_extended,replace=\\U$1\\L$2\\E$1..\\U$1\\l$2$1\n    aaBB\n 1: AAbbaa..AAbBaa\n    \n/abcd/replace=wxyz,substitute_matched\n    abcd\n 1: wxyz\n    pqrs \n 0: pqrs\n\n/abcd/g\n    >abcd1234abcd5678<\\=replace=wxyz,substitute_matched\n 2: >wxyz1234wxyz5678<\n\n/^(o(\\1{72}{\\\"{\\\\{00000059079}\\d*){74}}){19}/I\nCapture group count = 2\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'o'\nLast code unit = '}'\nSubject length lower bound = 65535\n\n/((p(?'K/\nFailed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)\n\n/((p(?'K/no_auto_capture\nFailed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)\n\n/abc/replace=A$3123456789Z\n    abc\nFailed: error -49 at offset 3 in replacement: unknown substring\n\n/(?<!a{65535}a{5})x/I\nFailed: error 187 at offset 0: lookbehind assertion is too long\n\n/(?<!a{65535})x/I\nCapture group count = 0\nMax lookbehind = 65535\nFirst code unit = 'x'\nSubject length lower bound = 1\n\n/(?=a\\K)/replace=z,allow_lookaround_bsk\n    BaCaD\nFailed: error -60: match with end before start or start moved backwards is not supported\n    \n/(?<=\\K.)/g,replace=-,allow_lookaround_bsk\n    ab\nFailed: error -60: match with end before start or start moved backwards is not supported\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEFG'toolong)/\nFailed: error 148 at offset 36: subpattern name is too long (maximum 32 code units)\n\n/(?'abcdefghijklmnopqrstuvwxyzABCDEF'justright)/\n\n# These two use zero-termination\n/abcd/max_pattern_length=3\nFailed: error 188 at offset 0: pattern string is longer than the limit set by the application\n\n/abc/max_pattern_length=3\n\n# These two, being hex, pass the length\n/abcdefab/hex,max_pattern_length=3\nFailed: error 188 at offset 0: pattern string is longer than the limit set by the application\n\n/abcdef/hex,max_pattern_length=3\n\n# These patterns used to take a long time to compile\n\n\"(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\nCapture group count = 12\nMay match empty string\nOptions: extended\nFirst code unit at start or follows newline\nSubject length lower bound = 0\n\n\"(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\nCapture group count = 12\nMax lookbehind = 2\nMay match empty string\nOptions: extended\nSubject length lower bound = 0\n\n\"(?|()|())(.*)\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\"xI\nCapture group count = 13\nMay match empty string\nOptions: extended\nSubject length lower bound = 0\n\n\"(?|()|())(?<=a()\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\n((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))\na)\"xI\nFailed: error 135 at offset 9: lookbehind is too complicated\n\n# Test the use of malloc for caching group information when there are more\n# groups than fit into the on-stack workspace.\n\n/\\[()]{1024}/I,expand\nExpanded: ()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()\nCapture group count = 1024\nMay match empty string\nSubject length lower bound = 0\n\n# Test minlength capped at 65535\n\n/(A{65000})\\1{65000}/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'A'\nLast code unit = 'A'\nSubject length lower bound = 65535\n\n# Test group scans when numbers are not unique\n\n/(?|()+|(a)+)/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        SCBra 1\n        KetRmax\n        Alt\n        CBra 1\n        a\n        KetRmax\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/(?|(a)+|()+)/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        a\n        KetRmax\n        Alt\n        SCBra 1\n        KetRmax\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/(?|()|(a))/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        Ket\n        Alt\n        CBra 1\n        a\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n/(?|(a)|())/BI\n------------------------------------------------------------------\n        Bra\n        Bra\n        CBra 1\n        a\n        Ket\n        Alt\n        CBra 1\n        Ket\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 1\nMay match empty string\nSubject length lower bound = 0\n\n# Test CRLF handling in empty string substitutions\n\n/^$/gm,newline=anycrlf,replace=-\n    X\\r\\n\\r\\nY\n 1: X\\x0d\\x0a-\\x0d\\x0aY\n\n/^$/gm,newline=crlf,replace=-\n    X\\r\\n\\r\\nY\n 1: X\\x0d\\x0a-\\x0d\\x0aY\n\n/^$/gm,newline=any,replace=-\n    X\\r\\n\\r\\nY\n 1: X\\x0d\\x0a-\\x0d\\x0aY\n\n\"(*ANYCRLF)(?m)^(.*[^0-9\\r\\n].*|)$\"g,replace=NaN\n    15\\r\\nfoo\\r\\n20\\r\\nbar\\r\\nbaz\\r\\n\\r\\n20\n 4: 15\\x0d\\x0aNaN\\x0d\\x0a20\\x0d\\x0aNaN\\x0d\\x0aNaN\\x0d\\x0aNaN\\x0d\\x0a20\n\n/a[[:punct:]b]/bincode\n------------------------------------------------------------------\n        Bra\n        a\n        [!-/:-@[-`b{-~]\n        Ket\n        End\n------------------------------------------------------------------\n\n/a[b[:punct:]]/bincode\n------------------------------------------------------------------\n        Bra\n        a\n        [!-/:-@[-`b{-~]\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B\n------------------------------------------------------------------\n        Bra\n        L?+\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        L?\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 14\n        L?+\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/L(?#(|++<!(2)?/B,no_auto_possess,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 14\n        L?\n        Callout 255 14 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/(A*)\\E+/B,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        SCBra 1\n        Callout 255 1 2\n        A*\n        Callout 255 3 4\n        KetRmax\n        Callout 255 7 0\n        Ket\n        End\n------------------------------------------------------------------\n\n/()\\Q\\E*]/B,auto_callout\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 1\n        Brazero\n        SCBra 1\n        Callout 255 1 6\n        KetRmax\n        Callout 255 7 1\n        ]\n        Callout 255 8 0\n        Ket\n        End\n------------------------------------------------------------------\n    a[bc]d\n--->a[bc]d\n +0     ^      (\n +1     ^      )\\Q\\E*\n +7     ^      ]\n +8     ^^     End of pattern\n 0: ]\n 1: \n\n/\\x8a+f|;T?(*:;.'?`(\\xeap ){![^()!y*''C*(?';]{1;(\\x08)/B,alt_verbnames,dupnames,extended\n------------------------------------------------------------------\n        Bra\n        \\x{8a}++\n        f\n        Alt\n        ;\n        T?\n        *MARK ;.'?`(\\x{ea}p\n        {!\n        [\\x00- \"-&+-:<->@-BD-xz-\\xff] (neg)\n        {1;\n        CBra 1\n        \\x08\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# Tests for NULL characters in comments and verb \"names\" and callouts\n\n# /A#B\\x00C\\x0aZ/\n/41 23 42 00 43 0a 5a/Bx,hex\n------------------------------------------------------------------\n        Bra\n        AZ\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A+#B\\x00C\\x0a+/\n/41 2b 23 42 00 43 0a 2b/Bx,hex\n------------------------------------------------------------------\n        Bra\n        A++\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex,alt_verbnames\n------------------------------------------------------------------\n        Bra\n        A\n        *MARK B\\x{0}WC\n        Z\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(*:B\\x00W#X\\00Y\\x0aC)Z/\n/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex\n------------------------------------------------------------------\n        Bra\n        A\n        *MARK B\\x{0}W#X\\x{0}Y\\x{a}C\n        Z\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(?C{X\\x00Y})B/\n/41 28 3f 43 7b 58 00 59 7d 29 42/B,hex\n------------------------------------------------------------------\n        Bra\n        A\n        CalloutStr {X\\x{0}Y} 5 10 1\n        B\n        Ket\n        End\n------------------------------------------------------------------\n\n# /A(?#X\\x00Y)B/\n/41 28 3f 23 7b 00 7d 29 42/B,hex\n------------------------------------------------------------------\n        Bra\n        AB\n        Ket\n        End\n------------------------------------------------------------------\n\n# Tests for leading comment in extended patterns\n\n/ (?-x):?/extended\n\n/\u000b(?-x):?/extended\n\n/0b 28 3f 2d 78 29 3a/hex,extended\n\n/#comment\n(?-x):?/extended\n\n/(8(*:6^\\x09x\\xa6l\\)6!|\\xd0:[^:|)\\x09d\\Z\\d{85*m(?'(?<1!)*\\W[*\\xff]!!h\\w]*\\xbe;/alt_bsux,alt_verbnames,allow_empty_class,dollar_endonly,extended,multiline,never_utf,no_dotstar_anchor,no_start_optimize\nFailed: error 162 at offset 49: subpattern name expected\n\n/a|(b)c/replace=>$1<,substitute_unset_empty\n    cat\n 1: c><t\n    xbcom\n 1: x>b<om\n\n/a|(b)c/\n    cat\\=replace=>$1<\nFailed: error -55 at offset 3 in replacement: requested value is not set\n    cat\\=replace=>$1<,substitute_unset_empty\n 1: c><t\n    xbcom\\=replace=>$1<,substitute_unset_empty\n 1: x>b<om\n\n/a|(b)c/substitute_extended\n    cat\\=replace=>${2:-xx}<\nFailed: error -49 at offset 9 in replacement: unknown substring\n    cat\\=replace=>${2:-xx}<,substitute_unknown_unset\n 1: c>xx<t\n    cat\\=replace=>${X:-xx}<,substitute_unknown_unset\n 1: c>xx<t\n\n/a|(?'X'b)c/replace=>$X<,substitute_unset_empty\n    cat\n 1: c><t\n    xbcom\n 1: x>b<om\n\n/a|(?'X'b)c/replace=>$Y<,substitute_unset_empty\n    cat\nFailed: error -49 at offset 3 in replacement: unknown substring\n    cat\\=substitute_unknown_unset\n 1: c><t\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/a|(b)c/replace=>$2<,substitute_unset_empty\n    cat\nFailed: error -49 at offset 3 in replacement: unknown substring\n    cat\\=substitute_unknown_unset\n 1: c><t\n    cat\\=substitute_unknown_unset,-substitute_unset_empty\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/()()()/use_offset_limit\n    \\=ovector=11000000000\n** Invalid value in 'ovector=11000000000'\n    \\=callout_fail=11000000000\n** Invalid value in 'callout_fail=11000000000'\n    \\=callout_fail=1:11000000000\n** Invalid value in 'callout_fail=1:11000000000'\n    \\=callout_data=11000000000\n** Invalid value in 'callout_data=11000000000'\n    \\=callout_data=-11000000000\n** Invalid value in 'callout_data=-11000000000'\n    \\=offset_limit=1100000000000000000000\n** Invalid value in 'offset_limit=1100000000000000000000'\n    \\=copy=11000000000\n** Invalid value in 'copy=11000000000'\n\n/(*MARK:A\\x00b)/mark\n    abc\n 0: \nMK: A\\x00b\n\n/(*MARK:A\\x00b)/mark,alt_verbnames\n    abc\n 0: \nMK: A\\x00b\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex\n    abc\n 0: \nMK: A\\x00b\n\n/\"(*MARK:A\" 00 \"b)\"/mark,hex,alt_verbnames\n    abc\n 0: \nMK: A\\x00b\n\n/efg/hex\n** Unexpected non-hex-digit 'g' at offset 2 in hex pattern: quote missing?\n\n/eff/hex\n** Odd number of digits in hex pattern\n\n/effg/hex\n** Unexpected non-hex-digit 'g' at offset 3 in hex pattern: quote missing?\n\n/(?J)(?'a'))(?'a')/\nFailed: error 122 at offset 10: unmatched closing parenthesis\n\n/(?<=((?C)0))/\n    9010\n--->9010\n  0  ^       0\n  0   ^      0\n 0: \n 1: 0\n\\= Expect no match\n    abc\n--->abc\n  0  ^      0\n  0   ^     0\n  0    ^    0\nNo match\n\n/aaa/\n\\[abc]{10000000000000000000000000000}\n** Repeat count too large\n\\[a]{3}\n 0: aaa\n\n/\\[AB]{6000000000000000000000}/expand\n** Pattern repeat count too large\n\n# Hex uses pattern length, not zero-terminated. This tests for overrunning\n# the given length of a pattern.\n\n/'(*U'/hex\nFailed: error 160 at offset 3: (*VERB) not recognized or malformed\n\n/'(*'/hex\nFailed: error 109 at offset 1: quantifier does not follow a repeatable item\n\n/'('/hex\nFailed: error 114 at offset 1: missing closing parenthesis\n\n//hex\n\n# These tests are here because Perl never allows a back reference in a\n# lookbehind. PCRE2 supports some limited cases.\n\n/([ab])...(?<=\\1)z/\n    a11az\n 0: a11az\n 1: a\n    b11bz\n 0: b11bz\n 1: b\n\\= Expect no match\n    b11az\nNo match\n\n/(?|([ab]))...(?<=\\1)z/\nFailed: error 125 at offset 13: lookbehind assertion is not fixed length\n\n/([ab])(\\1)...(?<=\\2)z/\n    aa11az\n 0: aa11az\n 1: a\n 2: a\n\n/(a\\2)(b\\1)(?<=\\2)/\nFailed: error 125 at offset 10: lookbehind assertion is not fixed length\n\n/(?<A>[ab])...(?<=\\k'A')z/\n    a11az\n 0: a11az\n 1: a\n    b11bz\n 0: b11bz\n 1: b\n\\= Expect no match\n    b11az\nNo match\n\n/(?<A>[ab])...(?<=\\k'A')(?<A>)z/dupnames\nFailed: error 125 at offset 13: lookbehind assertion is not fixed length\n\n# Perl does not support \\g+n\n\n/((\\g+1X)?([ab]))+/\n    aaXbbXa\n 0: aaXbbXa\n 1: bXa\n 2: bX\n 3: a\n\n/ab(?C1)c/auto_callout\n    abc\n--->abc\n +0 ^       a\n +1 ^^      b\n  1 ^ ^     c\n +8 ^  ^    End of pattern\n 0: abc\n\n/'ab(?C1)c'/hex,auto_callout\n    abc\n--->abc\n +0 ^       a\n +1 ^^      b\n  1 ^ ^     c\n +8 ^  ^    End of pattern\n 0: abc\n\n# Perl accepts these, but gives a warning. We can't warn, so give an error.\n\n/[a-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n    a-a9-a\n\n/[A-[:digit:]]+/\nFailed: error 150 at offset 4: invalid range in character class\n    A-A9-A\n\n/[a-\\d]+/\nFailed: error 150 at offset 5: invalid range in character class\n    a-a9-a\n\n/(?<RA>abc)(?(R)xyz)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        abc\n        Ket\n        Cond\n        Cond recurse any\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<R>abc)(?(R)xyz)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        abc\n        Ket\n        Cond\n      1 Cond ref\n        xyz\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=.*[A-Z])/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/()(?<=(?0))/\nFailed: error 125 at offset 2: lookbehind assertion is not fixed length\n\n/(?<!|!(?<!))/\n\n/(?<!|!|!||||||(?<!)||(?<!)!|!||(?<!)!|!(?<!)!|!|!|!||||!!|<!)!|!||||!|/\n\n/{2,2{2,2/use_length\n\n/.>*?\\g'0/use_length\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/.>*?\\g'0/\nFailed: error 157 at offset 6: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/{\u201e\u00cd\u201e\u00cd\u00cd\u201e\u00cd{'{22{2{{2{'{22{\u0012{22{2{'{22{2{{2{{222{{2{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{222{2\u00c4\u201e\u00cd\u201e\u00cd\u00cd\u201e\u00cd{'{22{2{{2{'{22{\u0012{11{2{'{22{2{{2{{'{22{2{{2{'{22{\u0012{22{1{'{22{2{{2{{222{{2{'{22{2{22{2{'{/auto_callout\n\n//\n\\=get=i00000000000000000000000000000000\n** Group name in 'get' is too long\n\\=get=i2345678901234567890123456789012,get=i1245678901234567890123456789012\n** Too many characters in named 'get' modifiers\n\n\"(?(?C))\"\nFailed: error 128 at offset 6: assertion expected after (?( or (?(?C)\n\n/(?(?(?(?(?(?))))))/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/(?<=(?1))((?s))/anchored\n\n/(*:ab)*/\nFailed: error 109 at offset 6: quantifier does not follow a repeatable item\n\n%(*:\u001e(:\u0011(\u001fsvvvvvvvvvv:]*[   Z!*;[]*[^[]*!^[\u0019+.+{{2,7}'      _\\\\\\\\\\\\\\\\\\\\\\\\\\)?.:..    *w////\\\\\\Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\T\\\\\\\\\\+/?/////'+\\\\\\EEE?/////'+/*+/[^K]?]//(w)%never_backslash_c,alt_verbnames,auto_callout\n\n/./newline=crlf\n    \\=ph\nNo match\n\n/(\\x0e00\\000000\\xc)/replace=\\P,substitute_extended\n    \\x0e00\\000000\\xc\nFailed: error -57 at offset 2 in replacement: bad escape sequence in replacement string\n\n//replace=0\n    \\=offset=7\nFailed: error -33: bad offset value\n\n/(?<=\\G.)/g,replace=+\n    abc\n 3: a+b+c+\n\n\".+\\QX\\E+\"B,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        Any+\n        X+\n        Ket\n        End\n------------------------------------------------------------------\n\n\".+\\QX\\E+\"B,auto_callout,no_auto_possess\n------------------------------------------------------------------\n        Bra\n        Callout 255 0 4\n        Any+\n        Callout 255 4 4\n        X+\n        Callout 255 8 0\n        Ket\n        End\n------------------------------------------------------------------\n\n# This one is here because Perl gives an 'unmatched )' error which goes away\n# if one of the \\) sequences is removed - which is weird. PCRE finds it too\n# complicated to find a minimum matching length.\n\n\"()X|((((((((()))))))((((())))))\\2())((((((\\2\\2)))\\2)(\\22((((\\2\\2)2))\\2)))(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z+:)Z|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z((Z*(\\2(Z\\':))\\0)i|||||||||||||||loZ\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0nte!rnal errpr\\2\\\\21r(2\\ZZZ)+:)Z!|91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\)\\0(2\\ZZZ)+:)Z^)))int \\)\\0(2\\ZZZ)+:)Z^|91ZiZZnter(ZZernZal ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)2))\\2Z)))int \\))\\ZZ(\\r2Z( or#(\\Z2(Z\\Z(\\2\\2)2))\\2Z)Z(\\22Z((\\Z2(Z\\Z(\\2\\2)))\\2))))((((((\\2\\2))))))\"I\nCapture group count = 108\nMax back reference = 22\nContains explicit CR or LF match\nSubject length lower bound = 1\n\n# This checks that new code for handling groups that may match an empty string\n# works on a very large number of alternatives. This pattern used to provoke a\n# complaint that it was too complicated.\n\n/(?:\\[A|B|C|D|E|F|G|H|I|J|]{200}Z)/expand\n\n# This one used to compile rubbish instead of a compile error, and then\n# behave unpredictably at match time.\n\n/.+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X/\nFailed: error 128 at offset 63: assertion expected after (?( or (?(?C)\n    .+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X\n\n/[:[:alnum:]-[[a:lnum:]+/\nFailed: error 150 at offset 11: invalid range in character class\n\n/((?(?C'')\\QX\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\nFailed: error 128 at offset 11: assertion expected after (?( or (?(?C)\n\n/((?(?C'')\\Q\\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/\n\n/abcd/auto_callout\n    abcd\\=callout_error=255:2\n--->abcd\n +0 ^        a\n +1 ^^       b\nFailed: error -37: callout error code\n\n/()(\\g+65534)/\nFailed: error 161 at offset 11: subpattern number is too big\n\n/()(\\g+65533)/\nFailed: error 115 at offset 10: reference to non-existent subpattern\n\n/\u00c1\\x00\\x00\\x00\u0017\u0161(\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\2*\\x00k\\d+\\x00\u00e2\u20ac\u017d\\x00\\x00\\x00\\x00\\x00\\2*\\x00\\x00\\1*.){36}int^\\x00\\x00\b\u02d9\u02d9\\x00\u0161(\\1{50779}?)J\\w2/I\nCapture group count = 2\nMax back reference = 2\nFirst code unit = \\xc1\nLast code unit = '2'\nSubject length lower bound = 65535\n\n/(a)(b)\\2\\1\\1\\1\\1/I\nCapture group count = 2\nMax back reference = 2\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 7\n\n/(?<a>a)(?<b>b)\\g{b}\\g{a}\\g{a}\\g{a}\\g{a}(?<a>xx)(?<b>zz)/I,dupnames\nCapture group count = 4\nMax back reference = 4\nNamed capture groups:\n  a   1\n  a   3\n  b   2\n  b   4\nOptions: dupnames\nFirst code unit = 'a'\nLast code unit = 'z'\nSubject length lower bound = 11\n\n//\n    \\=ovector=7777777777\n** Invalid value in 'ovector=7777777777'\n\n# This is here because Perl matches, even though a COMMIT is encountered\n# outside of the recursion.\n\n/(?1)(A(*COMMIT)|B)D/\n    BAXBAD\nNo match\n\n\"(?1){2}(a)\"B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        CBra 1\n        a\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n\"(?1){2,4}(a)\"B\n------------------------------------------------------------------\n        Bra\n        Recurse\n        Recurse\n        Brazero\n        Bra\n        Bra\n        Recurse\n        Ket\n        Brazero\n        Bra\n        Recurse\n        Ket\n        Ket\n        CBra 1\n        a\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# This test differs from Perl for the first subject. Perl ends up with\n# $1 set to 'B'; PCRE2 has it unset (which I think is right).\n\n/^(?:\n(?:A| (?:B|B(*ACCEPT)) (?<=(.)) D)\n(Z)\n)+$/x\n    AZB\n 0: AZB\n 1: <unset>\n 2: Z\n    AZBDZ\n 0: AZBDZ\n 1: B\n 2: Z\n\n# The first of these, when run by Perl, gives the mark 'aa', which is wrong.\n\n'(?>a(*:aa))b|ac' mark\n    ac\n 0: ac\n\n'(?:a(*:aa))b|ac' mark\n    ac\n 0: ac\n\n/(R?){65}/\n    (R?){65}\n 0: \n 1: \n\n/\\[(a)]{60}/expand\n    aaaa\nNo match\n\n/(?<!\\1((?U)1((?U))))(*F)/never_backslash_c,alt_bsux,anchored,extended\n\n/\\g{3/\nFailed: error 157 at offset 2: \\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\n\n/(a(?C1)(b)(c)d)+/\n  abcdabcd\\=callout_capture\nCallout 1: last capture = 0\n--->abcdabcd\n    ^^           (\nCallout 1: last capture = 1\n 1: abcd\n 2: b\n 3: c\n--->abcdabcd\n    ^    ^       (\n 0: abcdabcd\n 1: abcd\n 2: b\n 3: c\n\n# Perl matches this one, but PCRE does not because (*ACCEPT) clears out any\n# pending backtracks in the recursion.\n\n/^ (?(DEFINE) (..(*ACCEPT)|...) ) (?1)$/x\n\\= Expect no match\n    abc\nNo match\n\n# Perl gives no match for this one\n\n/(a(*MARK:m)(*ACCEPT)){0}(?1)/mark\n    abc\n 0: a\nMK: m\n\n/abc/endanchored\n    xyzabc\n 0: abc\n\\= Expect no match\n    xyzabcdef\nNo match\n\\= Expect error\n    xyzabc\\=ph\nFailed: error -34: bad option value\n\n/abc/\n    xyzabc\\=endanchored\n 0: abc\n\\= Expect no match\n    xyzabcdef\\=endanchored\nNo match\n\\= Expect error\n    xyzabc\\=ps,endanchored\nFailed: error -34: bad option value\n\n/abc(*ACCEPT)d/endanchored\n    xyzabc\n 0: abc\n\\= Expect no match\n    xyzabcdef\nNo match\n\n/abc|bcd/endanchored\n    xyzabcd\n 0: bcd\n\\= Expect no match\n    xyzabcdef\nNo match\n\n/a(*ACCEPT)x|aa/endanchored\n    aaa\n 0: a\n\n# Check auto-anchoring when there is a group that is never obeyed at\n# the start of a branch.\n\n/(?(DEFINE)(a))^bc/I\nCapture group count = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'b'\nSubject length lower bound = 2\n\n/(a){0}.*bc/sI\nCapture group count = 1\nCompile options: dotall\nOverall options: anchored dotall\nLast code unit = 'c'\nSubject length lower bound = 2\n\n# This should be anchored, as the condition is always false and there is\n# no alternative branch.\n\n/(?(VERSION>=999)yes)^bc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 2\n\n# This should not be anchored.\n\n/(?(VERSION>=999)yes|no)^bc/I\nCapture group count = 0\nLast code unit = 'c'\nSubject length lower bound = 4\n\n/(*LIMIT_HEAP=0)xxx/I\nCapture group count = 0\nHeap limit = 0\nFirst code unit = 'x'\nLast code unit = 'x'\nSubject length lower bound = 3\n\n/\\d{0,3}(*:abc)(?C1)xxx/callout_info\nCallout 1  x\n\n# ----------------------------------------------------------------------\n\n# These are a whole pile of tests that touch lines of code that are not\n# used by any other tests (at least when these were created).\n\n/^a+?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aaa\nNo match\n\n/^[^a]{3,}?x/i,no_start_optimize,no_auto_possess\n\\= Expect no match\n    bbb\nNo match\n    cc\nNo match\n\n/^X\\S/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\W/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\H/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\h/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\nNo match\n\n/^X\\V/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\nNo match\n\n/^X\\v/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\nNo match\n\n/^X.+?/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\R+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XX\nNo match\n\n/^X\\H+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\h+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n\n/^X\\V+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    X\\n\nNo match\n\n/^X\\D+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    X9\nNo match\n\n/^X\\S+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    X\\n\nNo match\n\n/^X\\W+?/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\nNo match\n    XX\nNo match\n\n/^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n\n/(*CRLF)^X.+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\r\\=ps\nPartial match: XY\\x0d\n\n/^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\nNo match\n    X\\n\\r\\n\nNo match\n    X\\n\\rY\nNo match\n    X\\n\\nY\nNo match\n    X\\n\\x{0c}Y\nNo match\n\n/(*BSR_ANYCRLF)^X\\R+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\nX\nNo match\n    X\\n\\r\\n\nNo match\n    X\\n\\rY\nNo match\n    X\\n\\nY\nNo match\n    X\\n\\x{0c}Y\nNo match\n\n/^X\\H+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\t\nNo match\n    XYY\nNo match\n\n/^X\\h+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\nNo match\n    X\\tY\nNo match\n\n/^X\\V+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n    XYY\nNo match\n\n/^X\\v+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\nNo match\n    X\\nY\nNo match\n\n/^X\\D+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY9\nNo match\n    XYY\nNo match\n\n/^X\\d+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X99\nNo match\n    X9Y\nNo match\n\n/^X\\S+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n    XYY\nNo match\n\n/^X\\s+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\n\\n\nNo match\n    X\\nY\nNo match\n\n/^X\\W+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X.A\nNo match\n    X++\nNo match\n\n/^X\\w+?Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.\nNo match\n    Xaa\nNo match\n\n/^X.{1,3}Z/s,no_start_optimize,no_auto_possess\n\\= Expect no match\n    Xa.bd\nNo match\n\n/^X\\h+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    X\\t\\t\nNo match\n    X\\tY\nNo match\n\n/^X\\V+Z/no_start_optimize,no_auto_possess\n\\= Expect no match\n    XY\\n\nNo match\n    XYY\nNo match\n\n/^(X(*THEN)Y|AB){0}(?1)/\n    ABX\n 0: AB\n\\= Expect no match\n    XAB\nNo match\n\n/^(?!A(?C1)B)C/\n    ABC\\=callout_error=1,no_jit\nNo match\n\n/^(?!A(?C1)B)C/no_start_optimize\n    ABC\\=callout_error=1\n--->ABC\n  1 ^^      B\nFailed: error -37: callout error code\n\n/^(?(?!A(?C1)B)C)/\n    ABC\\=callout_error=1\n--->ABC\n  1 ^^      B\nFailed: error -37: callout error code\n\n# ----------------------------------------------------------------------\n\n/[a b c]/BxxI\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended_more\nStarting code units: a b c \nSubject length lower bound = 1\n\n/[a b c]/BxxxI\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: extended extended_more\nStarting code units: a b c \nSubject length lower bound = 1\n\n/[a b c]/B,extended_more\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[ a b c ]/B,extended_more\n------------------------------------------------------------------\n        Bra\n        [a-c]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[a b](?xx: [ 12 ] (?-xx:[ 34 ]) )y z/B\n------------------------------------------------------------------\n        Bra\n        [ ab]\n        Bra\n        [12]\n        Bra\n        [ 34]\n        Ket\n        Ket\n        y z\n        Ket\n        End\n------------------------------------------------------------------\n\n# Unsetting /x also unsets /xx\n\n/[a b](?xx: [ 12 ] (?-x:[ 34 ]) )y z/B\n------------------------------------------------------------------\n        Bra\n        [ ab]\n        Bra\n        [12]\n        Bra\n        [ 34]\n        Ket\n        Ket\n        y z\n        Ket\n        End\n------------------------------------------------------------------\n\n/(a)(?-n:(b))(c)/nB\n------------------------------------------------------------------\n        Bra\n        Bra\n        a\n        Ket\n        Bra\n        CBra 1\n        b\n        Ket\n        Ket\n        Bra\n        c\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# ----------------------------------------------------------------------\n# These test the dangerous PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL option.\n\n/\\j\\x{z}\\o{82}\\L\\uabcd\\u\\U\\g{\\g/B,\\bad_escape_is_literal\n** Unrecognized modifier '\\' in '\\bad_escape_is_literal'\n\n/\\N{\\c/IB,bad_escape_is_literal\n------------------------------------------------------------------\n        Bra\n        N{c\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nExtra options: bad_escape_is_literal\nFirst code unit = 'N'\nLast code unit = 'c'\nSubject length lower bound = 3\n\n/[\\j\\x{z}\\o\\gAb\\g]/B,bad_escape_is_literal\n------------------------------------------------------------------\n        Bra\n        [Abgjoxz{}]\n        Ket\n        End\n------------------------------------------------------------------\n\n/[Q-\\N]/B,bad_escape_is_literal\nFailed: error 150 at offset 5: invalid range in character class\n\n/[\\s-_]/bad_escape_is_literal\nFailed: error 150 at offset 3: invalid range in character class\n\n/[_-\\s]/bad_escape_is_literal\nFailed: error 150 at offset 5: invalid range in character class\n\n/[\\B\\R\\X]/B\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[\\B\\R\\X]/B,bad_escape_is_literal\nFailed: error 107 at offset 2: escape sequence is invalid in character class\n\n/[A-\\BP-\\RV-\\X]/B\nFailed: error 107 at offset 4: escape sequence is invalid in character class\n\n/[A-\\BP-\\RV-\\X]/B,bad_escape_is_literal\nFailed: error 107 at offset 4: escape sequence is invalid in character class\n\n# ----------------------------------------------------------------------\n\n/a\\b(c/literal\n    a\\\\b(c\n 0: a\\b(c\n\n/a\\b(c/literal,caseless\n    a\\\\b(c\n 0: a\\b(c\n    a\\\\B(c\n 0: a\\B(c\n\n/a\\b(c/literal,firstline\n    XYYa\\\\b(c\n 0: a\\b(c\n\\= Expect no match\n    X\\na\\\\b(c\nNo match\n\n/a\\b?c/literal,use_offset_limit\n    XXXXa\\\\b?c\\=offset_limit=4\n 0: a\\b?c\n\\= Expect no match\n    XXXXa\\\\b?c\\=offset_limit=3\nNo match\n\n/a\\b(c/literal,anchored,endanchored\n    a\\\\b(c\n 0: a\\b(c\n\\= Expect no match\n    Xa\\\\b(c\nNo match\n    a\\\\b(cX\nNo match\n    Xa\\\\b(cX\nNo match\n\n//literal,extended\nFailed: error 192 at offset 0: invalid option bits with PCRE2_LITERAL\n\n/a\\b(c/literal,auto_callout,no_start_optimize\n    XXXXa\\\\b(c\n--->XXXXa\\b(c\n +0 ^             a\n +0  ^            a\n +0   ^           a\n +0    ^          a\n +0     ^         a\n +1     ^^        \\\n +2     ^ ^       b\n +3     ^  ^      (\n +4     ^   ^     c\n +5     ^    ^    End of pattern\n 0: a\\b(c\n\n/a\\b(c/literal,auto_callout\n    XXXXa\\\\b(c\n--->XXXXa\\b(c\n +0     ^         a\n +1     ^^        \\\n +2     ^ ^       b\n +3     ^  ^      (\n +4     ^   ^     c\n +5     ^    ^    End of pattern\n 0: a\\b(c\n\n/(*CR)abc/literal\n    (*CR)abc\n 0: (*CR)abc\n\n/cat|dog/I,match_word\nCapture group count = 0\nMax lookbehind = 1\nExtra options: match_word\nStarting code units: c d \nSubject length lower bound = 3\n    the cat sat\n 0: cat\n\\= Expect no match\n    caterpillar\nNo match\n    snowcat\nNo match\n    syndicate\nNo match\n\n/(cat)|dog/I,match_line,literal\nCapture group count = 0\nCompile options: literal\nOverall options: anchored literal\nExtra options: match_line\nFirst code unit = '('\nSubject length lower bound = 9\n    (cat)|dog\n 0: (cat)|dog\n\\= Expect no match\n    the cat sat\nNo match\n    caterpillar\nNo match\n    snowcat\nNo match\n    syndicate\nNo match\n\n/a whole line/match_line,multiline\n    Rhubarb \\na whole line\\n custard\n 0: a whole line\n\\= Expect no match\n    Not a whole line\nNo match\n\n# Perl gets this wrong, failing to capture 'b' in group 1.\n\n/^(b+|a){1,2}?bc/\n    bbc\n 0: bbc\n 1: b\n    \n# And again here, for the \"babc\" subject string. \n\n/^(b*|ba){1,2}?bc/\n    babc\n 0: babc\n 1: ba\n    bbabc\n 0: bbabc\n 1: ba\n    bababc\n 0: bababc\n 1: ba\n\\= Expect no match\n    bababbc\nNo match\n    babababc\nNo match\n\n/[[:digit:]-a]/\nFailed: error 150 at offset 10: invalid range in character class\n\n/[[:digit:]-[:print:]]/\nFailed: error 150 at offset 10: invalid range in character class\n\n/[\\d-a]/\nFailed: error 150 at offset 3: invalid range in character class\n\n/[\\H-z]/\nFailed: error 150 at offset 3: invalid range in character class\n\n/[\\d-[:print:]]/\nFailed: error 150 at offset 3: invalid range in character class\n\n# Perl gets the second of these wrong, giving no match.\n\n\"(?<=(a))\\1?b\"I\nCapture group count = 1\nMax back reference = 1\nMax lookbehind = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    ab\n 0: b\n 1: a\n    aaab \n 0: ab\n 1: a\n\n\"(?=(a))\\1?b\"I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    ab\n 0: ab\n 1: a\n    aaab\n 0: ab\n 1: a\n    \n# JIT does not support callout_extra  \n    \n/(*NO_JIT)(a+)b/auto_callout,no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \nNew match attempt\n--->aac\n +9 ^       (\n+10 ^       a+\n+12 ^ ^     )\n+13 ^ ^     b\nBacktrack\n--->aac\n+12 ^^      )\n+13 ^^      b\nBacktrack\nNo other matching paths\nNew match attempt\n--->aac\n +9  ^      (\n+10  ^      a+\n+12  ^^     )\n+13  ^^     b\nBacktrack\nNo other matching paths\nNew match attempt\n--->aac\n +9   ^     (\n+10   ^     a+\nBacktrack\nNo other matching paths\nNew match attempt\n--->aac\n +9    ^    (\n+10    ^    a+\nNo match\n    \n/(*NO_JIT)a+(?C'XXX')b/no_start_optimize,no_auto_possess\n\\= Expect no match\n    aac\\=callout_extra \nNew match attempt\nCallout (15): 'XXX'\n--->aac\n    ^ ^     b\nBacktrack\nCallout (15): 'XXX'\n--->aac\n    ^^      b\nBacktrack\nNo other matching paths\nNew match attempt\nCallout (15): 'XXX'\n--->aac\n     ^^     b\nNo match\n\n/\\n/firstline\n    xyz\\nabc\n 0: \\x0a\n\n/\\nabc/firstline\n    xyz\\nabc\n 0: \\x0aabc\n\n/\\x{0a}abc/firstline,newline=crlf\n\\= Expect no match\n    xyz\\r\\nabc\nNo match\n\n/[abc]/firstline\n\\= Expect no match\n    \\na\nNo match\n    \n# These tests are matched in test 1 as they are Perl compatible. Here we are\n# looking at what does and does not get auto-possessified. \n\n/(?(DEFINE)(?<optional_a>a?))^(?&optional_a)a$/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        CBra 1\n        a?\n        Ket\n        Ket\n        ^\n        Recurse\n        a\n        $\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(DEFINE)(?<optional_a>a?)X)^(?&optional_a)a$/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        CBra 1\n        a?\n        Ket\n        X\n        Ket\n        ^\n        Recurse\n        a\n        $\n        Ket\n        End\n------------------------------------------------------------------\n    \n/^(a?)b(?1)a/B\n------------------------------------------------------------------\n        Bra\n        ^\n        CBra 1\n        a?\n        Ket\n        b\n        Recurse\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a?)+b(?1)a/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SCBra 1\n        a?\n        KetRmax\n        b\n        Recurse\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a?)++b(?1)a/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SCBraPos 1\n        a?\n        KetRpos\n        b\n        Recurse\n        a\n        Ket\n        End\n------------------------------------------------------------------\n\n/^(a?)+b/B\n------------------------------------------------------------------\n        Bra\n        ^\n        SCBra 1\n        a?\n        KetRmax\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?=a+)a(a+)++b/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        a++\n        Ket\n        a\n        CBraPos 1\n        a++\n        KetRpos\n        b\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?<=(?=.){4,5}x)/B\n------------------------------------------------------------------\n        Bra\n        Assert back\n        Reverse\n        Assert\n        Any\n        Ket\n        Assert\n        Any\n        Ket\n        Assert\n        Any\n        Ket\n        Assert\n        Any\n        Ket\n        Brazero\n        Assert\n        Any\n        Ket\n        x\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n# Perl behaves differently with these when optimization is turned off\n\n/a(*PRUNE:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\nNo match, mark = X\n\n/a(*THEN:X)bc|qq/mark,no_start_optimize\n\\= Expect no match\n    axy\nNo match, mark = X\n\n/(?^x-i)AB/ \nFailed: error 194 at offset 4: invalid hyphen in option setting\n\n/(?^-i)AB/ \nFailed: error 194 at offset 3: invalid hyphen in option setting\n\n/(?x-i-i)/\nFailed: error 194 at offset 5: invalid hyphen in option setting\n\n/(?(?=^))b/I\nCapture group count = 0\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n\n/(?(?=^)|)b/I\nCapture group count = 0\nFirst code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n\n/(?(?=^)|^)b/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'b'\nSubject length lower bound = 1\n    bbc\n 0: b\n\\= Expect no match\n    abc     \nNo match\n\n/(?(1)^|^())/I\nCapture group count = 1\nMax back reference = 1\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 0\n\n/(?(1)^())b/I\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n\n/(?(1)^())+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n 0+ c\n\n/(?(1)^()|^)+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'b'\nSubject length lower bound = 1\n    bbc \n 0: b\n 0+ bc\n\\= Expect no match     \n    abc\nNo match\n\n/(?(1)^()|^)*b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'b'\nSubject length lower bound = 1\n    bbc \n 0: b\n 0+ bc\n    abc\n 0: b\n 0+ c\n    xbc \n 0: b\n 0+ c\n\n/(?(1)^())+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc\n 0: b\n 0+ c\n\n/(?(1)^a()|^a)+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nLast code unit = 'b'\nSubject length lower bound = 2\n    abc \n 0: ab\n 0+ c\n\\= Expect no match     \n    bbc\nNo match\n\n/(?(1)^|^(a))+b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nCompile options: <none>\nOverall options: anchored\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc \n 0: ab\n 0+ c\n 1: a\n\\= Expect no match     \n    bbc\nNo match\n\n/(?(1)^a()|^a)*b/I,aftertext\nCapture group count = 1\nMax back reference = 1\nLast code unit = 'b'\nSubject length lower bound = 1\n    abc \n 0: ab\n 0+ c\n    bbc\n 0: b\n 0+ bc\n    xbc \n 0: b\n 0+ c\n\n/a(b)c|xyz/g,allvector,replace=<$0>\n    abcdefabcpqr\\=ovector=4\n 2: <abc>def<abc>pqr\n 0: 6 9\n 1: 7 8\n 2: <unchanged>\n 3: <unchanged>\n    abxyz\\=ovector=4\n 1: ab<xyz>\n 0: 2 5\n 1: <unset>\n 2: <unchanged>\n 3: <unchanged>\n    abcdefxyz\\=ovector=4\n 2: <abc>def<xyz>\n 0: 6 9\n 1: <unset>\n 2: <unchanged>\n 3: <unchanged>\n    \n/a(b)c|xyz/allvector\n    abcdef\\=ovector=4\n 0: abc\n 1: b\n 2: <unchanged>\n 3: <unchanged>\n    abxyz\\=ovector=4\n 0: xyz\n 1: <unset>\n 2: <unchanged>\n 3: <unchanged>\n\n/a(b)c|xyz/g,replace=<$0>,substitute_callout\n    abcdefabcpqr\n 1(2) Old 0 3 \"abc\" New 0 5 \"<abc>\"\n 2(2) Old 6 9 \"abc\" New 8 13 \"<abc>\"\n 2: <abc>def<abc>pqr\n    abxyzpqrabcxyz\n 1(1) Old 2 5 \"xyz\" New 2 7 \"<xyz>\"\n 2(2) Old 8 11 \"abc\" New 10 15 \"<abc>\"\n 3(1) Old 11 14 \"xyz\" New 15 20 \"<xyz>\"\n 3: ab<xyz>pqr<abc><xyz>\n    12abc34xyz99abc55\\=substitute_stop=2\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 9 14 \"<xyz> STOPPED\"\n 2: 12<abc>34xyz99abc55\n    12abc34xyz99abc55\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> SKIPPED\"\n 2(1) Old 7 10 \"xyz\" New 7 12 \"<xyz>\"\n 3(2) Old 12 15 \"abc\" New 14 19 \"<abc>\"\n 3: 12abc34<xyz>99<abc>55\n    12abc34xyz99abc55\\=substitute_skip=2\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 9 14 \"<xyz> SKIPPED\"\n 3(2) Old 12 15 \"abc\" New 14 19 \"<abc>\"\n 3: 12<abc>34xyz99<abc>55\n\n/a(b)c|xyz/g,replace=<$0>\n    abcdefabcpqr\n 2: <abc>def<abc>pqr\n    abxyzpqrabcxyz\n 3: ab<xyz>pqr<abc><xyz>\n    12abc34xyz\\=substitute_stop=2\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 9 14 \"<xyz> STOPPED\"\n 2: 12<abc>34xyz\n    12abc34xyz\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> SKIPPED\"\n 2(1) Old 7 10 \"xyz\" New 7 12 \"<xyz>\"\n 2: 12abc34<xyz>\n\n/a(b)c|xyz/replace=<$0>\n    abcdefabcpqr\n 1: <abc>defabcpqr\n    12abc34xyz\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> SKIPPED\"\n 1: 12abc34xyz\n    12abc34xyz\\=substitute_stop=1\n 1(2) Old 2 5 \"abc\" New 2 7 \"<abc> STOPPED\"\n 1: 12abc34xyz\n\n/abc\\rdef/\n    abc\\ndef\nNo match\n\n/abc\\rdef\\x{0d}xyz/escaped_cr_is_lf\n    abc\\ndef\\rxyz\n 0: abc\\x0adef\\x0dxyz\n\\= Expect no match     \n    abc\\ndef\\nxyz\nNo match\n\n/(?(*ACCEPT)xxx)/\nFailed: error 128 at offset 2: assertion expected after (?( or (?(?C)\n\n/(?(*atomic:xx)xxx)/\nFailed: error 128 at offset 10: assertion expected after (?( or (?(?C)\n\n/(?(*script_run:xxx)zzz)/\nFailed: error 128 at offset 14: assertion expected after (?( or (?(?C)\n\n/foobar/\n    the foobar thing\\=copy_matched_subject\n 0: foobar\n    the foobar thing\\=copy_matched_subject,zero_terminate\n 0: foobar\n\n/foobar/g\n    the foobar thing foobar again\\=copy_matched_subject\n 0: foobar\n 0: foobar\n\n/(*:XX)^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(*COMMIT:XX)^abc/I\nCapture group count = 0\nCompile options: <none>\nOverall options: anchored\nFirst code unit = 'a'\nSubject length lower bound = 3\n\n/(*ACCEPT:XX)^abc/I\nCapture group count = 0\nMay match empty string\nSubject length lower bound = 0\n\n/abc/replace=xyz\n    abc\\=null_context\n 1: xyz\n\n/abc/replace=xyz,substitute_callout\n    abc \n 1(1) Old 0 3 \"abc\" New 0 3 \"xyz\"\n 1: xyz\n\\= Expect error message\n    abc\\=null_context\n** Replacement callouts are not supported with null_context.\n\n/\\[()]{65535}()/expand\nFailed: error 197 at offset 131071: too many capturing groups (maximum 65535)\n\n/\\[()]{65535}(?<A>)/expand\nFailed: error 197 at offset 131075: too many capturing groups (maximum 65535)\n\n/a(?:(*ACCEPT))??bc/\n    abc\n 0: abc\n    axy\n 0: a\n\n/a(*ACCEPT)??bc/\n    abc\n 0: abc\n    axy\n 0: a\n\n/a(*ACCEPT:XX)??bc/mark\n    abc\n 0: abc\n    axy\n 0: a\nMK: XX\n\n/(*:\\)?/\nFailed: error 109 at offset 5: quantifier does not follow a repeatable item\n\n/(*:\\Q \\E){5}/alt_verbnames\nFailed: error 109 at offset 11: quantifier does not follow a repeatable item\n\n/(?=abc)/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nLast code unit = 'c'\nSubject length lower bound = 2\n\n/(?|(X)|(XY))\\1abc/I\nCapture group count = 1\nMax back reference = 1\nFirst code unit = 'X'\nLast code unit = 'c'\nSubject length lower bound = 4\n\n/(?|(a)|(bcde))(c)\\2/I\nCapture group count = 2\nMax back reference = 2\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?|(a)|(bcde))(c)\\1/I\nCapture group count = 2\nMax back reference = 1\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'B'(?'A')/I,dupnames\nCapture group count = 3\nMax back reference = 2\nNamed capture groups:\n  A   1\n  A   3\n  B   2\nOptions: dupnames\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 3\n\n/(?|(?'A'a)|(?'A'bcde))(?'B'c)\\k'A'(?'A')/I,dupnames\nCapture group count = 3\nMax back reference = 3\nNamed capture groups:\n  A   1\n  A   3\n  B   2\nOptions: dupnames\nStarting code units: a b \nLast code unit = 'c'\nSubject length lower bound = 2\n\n/((a|)+)+Z/I\nCapture group count = 2\nStarting code units: Z a \nLast code unit = 'Z'\nSubject length lower bound = 1\n\n/((?=a))[abcd]/I\nCapture group count = 1\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/A(?:(*ACCEPT))?B/info\nCapture group count = 0\nFirst code unit = 'A'\nSubject length lower bound = 1\n\n/(A(*ACCEPT)??B)C/\n    ABC\n 0: ABC\n 1: AB\n    AXY \n 0: A\n 1: A\n\n/(?<=(?<=a)b)c.*/I\nCapture group count = 0\nMax lookbehind = 1\nFirst code unit = 'c'\nSubject length lower bound = 1\n    abc\\=ph\nPartial match: c\n\\= Expect no match\n    xbc\\=ph\nNo match\n\n/(?<=ab)c.*/I\nCapture group count = 0\nMax lookbehind = 2\nFirst code unit = 'c'\nSubject length lower bound = 1\n    abc\\=ph\nPartial match: c\n\\= Expect no match\n    xbc\\=ph\nNo match\n\n/(?<=a(?<=a|a)c)/I\nCapture group count = 0\nMax lookbehind = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(?<=a(?<=a|ba)c)/I\nCapture group count = 0\nMax lookbehind = 2\nMay match empty string\nSubject length lower bound = 0\n\n/(?<=(?<=a)b)(?<!abcd)/I\nCapture group count = 0\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n/(?<=(?<=a)b)(?<!abcd)(?<=(?<=a)bcde)/I\nCapture group count = 0\nMax lookbehind = 4\nMay match empty string\nSubject length lower bound = 0\n\n# Addition overflow\n/( {32742} {42})(?<!\\1{65481})/\nFailed: error 187 at offset 15: lookbehind assertion is too long\n\n# Multiplication overflow\n/(X{65535})(?<=\\1{32770})/\nFailed: error 187 at offset 10: lookbehind assertion is too long\n\n# ---- Non-atomic assertion tests ----\n\n# Expect error: not allowed as a condition\n/(?(*napla:xx)bc)/\nFailed: error 198 at offset 9: atomic assertion expected after (?( or (?(?C)\n\n/\\A(*pla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\nNo match\n\n/\\A(*napla:.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n 0: word1 word3 word1 word2 word3 word2 word2 word1 word3\n 1: word3\n\n/\\A(?*.*\\b(\\w++))(?>.*?\\b\\1\\b){3}/\n    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4\n 0: word1 word3 word1 word2 word3 word2 word2 word1 word3\n 1: word3\n\n/(*plb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n 0: b\n 1: b\n 2: <unset>\n 3: b\n    abcda\\=offset=4 \nNo match\n\n/(*naplb:(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n 0: b\n 1: b\n 2: <unset>\n 3: b\n    abcda\\=offset=4 \n 0: a\n 1: <unset>\n 2: a\n 3: a\n    \n/(?<*(.)..|(.)...)(\\1|\\2)/\n    abcdb\\=offset=4 \n 0: b\n 1: b\n 2: <unset>\n 3: b\n    abcda\\=offset=4 \n 0: a\n 1: <unset>\n 2: a\n 3: a\n    \n/(*non_atomic_positive_lookahead:ab)/B\n------------------------------------------------------------------\n        Bra\n        Non-atomic assert\n        ab\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n \n/(*non_atomic_positive_lookbehind:ab)/B \n------------------------------------------------------------------\n        Bra\n        Non-atomic assert back\n        Reverse\n        ab\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(*pla:ab+)/B\n------------------------------------------------------------------\n        Bra\n        Assert\n        a\n        b++\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(*napla:ab+)/B\n------------------------------------------------------------------\n        Bra\n        Non-atomic assert\n        a\n        b+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(*napla:)+/\n\n/(*naplb:)+/\n\n/(*napla:^x|^y)/I\nCapture group count = 0\nMay match empty string\nCompile options: <none>\nOverall options: anchored\nStarting code units: x y \nSubject length lower bound = 1\n\n/(*napla:abc|abd)/I\nCapture group count = 0\nMay match empty string\nFirst code unit = 'a'\nSubject length lower bound = 1\n\n/(*napla:a|(.)(*ACCEPT)zz)\\1../\n    abcd\n 0: abc\n 1: a\n    \n/(*napla:a(*ACCEPT)zz|(.))\\1../\n    abcd\n 0: bcd\n 1: b\n    \n/(*napla:a|(*COMMIT)(.))\\1\\1/\n    aabc\n 0: aa\n 1: a\n\\= Expect no match     \n    abbc   \nNo match\n\n/(*napla:a|(.))\\1\\1/\n    aabc\n 0: aa\n 1: a\n    abbc   \n 0: bb\n 1: b\n\n# ----\n\n# Expect error (recursion => not fixed length)\n/(\\2)((?=(?<=\\1)))/\nFailed: error 125 at offset 8: lookbehind assertion is not fixed length\n\n/c*+(?<=[bc])/\n    abc\\=ph\nPartial match: c\n    ab\\=ph\nPartial match: \n    abc\\=ps\n 0: c\n    ab\\=ps\n 0: \n\n/c++(?<=[bc])/\n    abc\\=ph\nPartial match: c\n    ab\\=ph\nPartial match: \n\n/(?<=(?=.(?<=x)))/\n    abx\n 0: \n    ab\\=ph\nPartial match: \n    bxyz \n 0: \n    xyz\n 0: \n    \n/\\z/\n   abc\\=ph\nPartial match: \n   abc\\=ps \n 0: \n   \n/\\Z/\n   abc\\=ph\nPartial match: \n   abc\\=ps \n 0: \n   abc\\n\\=ph\nPartial match: \\x0a\n   abc\\n\\=ps\n 0: \n\n/(?![ab]).*/\n    ab\\=ph\nPartial match: \n\n/c*+/\n    ab\\=ph,offset=2\nPartial match: \n\n/\\A\\s*(a|(?:[^`]{28500}){4})/I\nCapture group count = 1\nMax lookbehind = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n    a\n 0: a\n 1: a\n\n/\\A\\s*((?:[^`]{28500}){4})/I\nCapture group count = 1\nMax lookbehind = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 65535\n\n/\\A\\s*((?:[^`]{28500}){4}|a)/I\nCapture group count = 1\nMax lookbehind = 1\nCompile options: <none>\nOverall options: anchored\nSubject length lower bound = 1\n    a\n 0: a\n 1: a\n\n/(?<A>a)(?(<A>)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        CBra 1\n        a\n        Ket\n        Cond\n      1 Cond ref\n        b\n        Ket\n        CBra 2\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(1)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n      1 Cond ref\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(R1)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond recurse 1\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(DEFINE)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/(?(VERSION=10.3)b)((?<=b).*)/B\n------------------------------------------------------------------\n        Bra\n        Cond\n        Cond false\n        b\n        Ket\n        CBra 1\n        Assert back\n        Reverse\n        b\n        Ket\n        Any*+\n        Ket\n        Ket\n        End\n------------------------------------------------------------------\n\n/[aA]b[cC]/IB\n------------------------------------------------------------------\n        Bra\n     /i a\n        b\n     /i c\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'a' (caseless)\nLast code unit = 'c' (caseless)\nSubject length lower bound = 3\n\n/[cc]abcd/I\nCapture group count = 0\nFirst code unit = 'c'\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/[Cc]abcd/I\nCapture group count = 0\nFirst code unit = 'C' (caseless)\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/[c]abcd/I\nCapture group count = 0\nFirst code unit = 'c'\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/(?:c|C)abcd/I\nCapture group count = 0\nFirst code unit = 'C' (caseless)\nLast code unit = 'd'\nSubject length lower bound = 5\n\n/(a)?a/I\nCapture group count = 1\nStarting code units: a \nLast code unit = 'a'\nSubject length lower bound = 1\n    manm\n 0: a\n\n/^(?|(\\*)(*napla:\\S*_(\\2?+.+))|(\\w)(?=\\S*_(\\2?+\\1)))+_\\2$/\n    *abc_12345abc\n 0: *abc_12345abc\n 1: c\n 2: 12345abc\n\n/^(?|(\\*)(*napla:\\S*_(\\3?+.+))|(\\w)(?=\\S*_((\\2?+\\1))))+_\\2$/\n    *abc_12345abc\n 0: *abc_12345abc\n 1: c\n 2: 12345abc\n 3: 12345abc\n\n/^((\\1+)(?C)|\\d)+133X$/\n    111133X\\=callout_capture\nCallout 0: last capture = 2\n 1: 1\n 2: 111\n--->111133X\n    ^   ^       |\nCallout 0: last capture = 2\n 1: 3\n 2: 3\n--->111133X\n    ^     ^     |\nCallout 0: last capture = 2\n 1: 1\n 2: 11\n--->111133X\n    ^  ^        |\nCallout 0: last capture = 2\n 1: 3\n 2: 3\n--->111133X\n    ^     ^     |\n 0: 111133X\n 1: 11\n 2: 11\n\n/abc/replace=xyz,substitute_replacement_only\n    123abc456\n 1: xyz\n\n/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z,substitute_replacement_only\n    \"abcde-abcde-\"\n 2: Xb+dZXb+dZ\n     \n/a(b)c|xyz/g,replace=<$0>,substitute_callout,substitute_replacement_only\n    abcdefabcpqr                \n 1(2) Old 0 3 \"abc\" New 0 5 \"<abc>\"\n 2(2) Old 6 9 \"abc\" New 5 10 \"<abc>\"\n 2: <abc><abc>\n    abxyzpqrabcxyz              \n 1(1) Old 2 5 \"xyz\" New 0 5 \"<xyz>\"\n 2(2) Old 8 11 \"abc\" New 5 10 \"<abc>\"\n 3(1) Old 11 14 \"xyz\" New 10 15 \"<xyz>\"\n 3: <xyz><abc><xyz>\n    12abc34xyz99abc55\\=substitute_stop=2                          \n 1(2) Old 2 5 \"abc\" New 0 5 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 5 10 \"<xyz> STOPPED\"\n 2: <abc>\n    12abc34xyz99abc55\\=substitute_skip=1\n 1(2) Old 2 5 \"abc\" New 0 5 \"<abc> SKIPPED\"\n 2(1) Old 7 10 \"xyz\" New 0 5 \"<xyz>\"\n 3(2) Old 12 15 \"abc\" New 5 10 \"<abc>\"\n 3: <xyz><abc>\n    12abc34xyz99abc55\\=substitute_skip=2\n 1(2) Old 2 5 \"abc\" New 0 5 \"<abc>\"\n 2(1) Old 7 10 \"xyz\" New 5 10 \"<xyz> SKIPPED\"\n 3(2) Old 12 15 \"abc\" New 5 10 \"<abc>\"\n 3: <abc><abc>\n\n/a(..)d/replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n 1: xyz>bc<xyzabcdxyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n 1: xyz>bc<xyzabcdxyz\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\nFailed: error -54 at offset 3 in replacement: requested value is not available\n\n/a(..)d/g,replace=>$1<,substitute_matched\n    xyzabcdxyzabcdxyz\n 2: xyz>bc<xyz>bc<xyz\n    xyzabcdxyzabcdxyz\\=ovector=2\n 2: xyz>bc<xyz>bc<xyz\n\\= Expect error     \n    xyzabcdxyzabcdxyz\\=ovector=1\nFailed: error -54 at offset 3 in replacement: requested value is not available\n    xyzabcdxyzabcdxyz\\=ovector=1,substitute_unset_empty\nFailed: error -54 at offset 3 in replacement: requested value is not available\n\n/55|a(..)d/g,replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 3: xyz><>bc<xyz>bc<xyz\n\\= Expect error     \n    xyz55abcdxyzabcdxyz\\=ovector=2\nFailed: error -55 at offset 3 in replacement: requested value is not set\n\n/55|a(..)d/replace=>$1<,substitute_matched\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 1: xyz><abcdxyzabcdxyz\n\n/55|a(..)d/replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 1: xyz><abcdxyzabcdxyz\n\n/55|a(..)d/g,replace=>$1<\n    xyz55abcdxyzabcdxyz\\=ovector=2,substitute_unset_empty\n 3: xyz><>bc<xyz>bc<xyz\n    \n/abc/replace=,caseless\n    XabcY\n 0: abc\n    XABCY \n 0: ABC\n\n/abc/replace=[4],caseless\n    XabcY\n 1: XY\n    XABCY \n 1: XY\n\n/abc/replace=*,caseless\n    XabcY\n 1: X*Y\n    XABCY\n 1: X*Y\n    XabcY\\=replace=  \n 0: abc\n\n# Expect non-fixed-length error\n\n\"(?<=X(?(DEFINE)(.*))(?1)).\"\nFailed: error 125 at offset 0: lookbehind assertion is not fixed length\n\n/\\sxxx\\s/tables=1\n\\= Expect no match\n    AB\\x{85}xxx\\x{a0}XYZ\nNo match\n\n/\\sxxx\\s/tables=2\n    AB\\x{85}xxx\\x{a0}XYZ\n 0: \\x85xxx\\xa0\n\n/^\\w+/tables=2\n    \u0102\u2030cole\n 0: \\xc3\n\n/^\\w+/tables=3\n** 'Tables = 3' is invalid: binary tables have not been loaded\n    \u0102\u2030cole\n\n#loadtables ./testbtables\n\n/^\\w+/tables=3\n    \u0102\u2030cole\n 0: \\xc3\n\n/\"(*MARK:>\" 00 \"<)..\"/hex,mark,no_start_optimize\n    AB\n 0: AB\nMK: >\\x00<\n    A\\=ph \nPartial match, mark=>\\x00<: A\n\\= Expect no match\n    A\nNo match, mark = >\\x00<\n\n/\"(*MARK:>\" 00 \"<).(?C1).\"/hex,mark,no_start_optimize\n    AB\n--->AB\n  1 ^^     .\nLatest Mark: >\\x00<\n 0: AB\nMK: >\\x00<\n\n/(?(VERSION=0.0/\nFailed: error 179 at offset 14: syntax error or number too big in (?(VERSION condition\n\n# Perl has made \\K in lookarounds an error. PCRE2 now rejects as well, unless\n# explicitly authorized.\n\n/(?=a\\Kb)ab/\nFailed: error 199 at offset 10: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/(?=a\\Kb)ab/allow_lookaround_bsk\n    ab \n 0: b\n\n/(?!a\\Kb)ac/\nFailed: error 199 at offset 10: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/(?!a\\Kb)ac/allow_lookaround_bsk\n    ac \n 0: ac\n    \n/^abc(?<=b\\Kc)d/\nFailed: error 199 at offset 14: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/^abc(?<=b\\Kc)d/allow_lookaround_bsk\n    abcd\n 0: cd\n\n/^abc(?<!b\\Kq)d/\nFailed: error 199 at offset 14: \\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\n\n/^abc(?<!b\\Kq)d/,allow_lookaround_bsk\n    abcd\n 0: abcd\n    \n# --------- \n\n# Tests for zero-length NULL to be treated as an empty string.\n\n//\n    \\=null_subject\n 0: \n\\= Expect error     \n    abc\\=null_subject\nFailed: error -51: NULL argument passed with non-zero length\n\n//replace=[20]\n    abc\\=null_replacement\n 1: abc\n    \\=null_subject\n 1: \n    \\=null_replacement\n 1: \n\n/X*/g,replace=xy\n\\= Expect error\n    >X<\\=null_replacement\nFailed: error -51: NULL argument passed with non-zero length\n\n/X+/replace=[20]\n    >XX<\\=null_replacement\n 1: ><\n\n# --------- \n\n/[Aa]{2}/BI\n------------------------------------------------------------------\n        Bra\n     /i A{2}\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'A' (caseless)\nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aabcd\n 0: aa\n\n/A{2}/iBI\n------------------------------------------------------------------\n        Bra\n     /i A{2}\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nOptions: caseless\nFirst code unit = 'A' (caseless)\nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aabcd\n 0: aa\n\n/[Aa]{2,3}/BI\n------------------------------------------------------------------\n        Bra\n     /i A{2}\n     /i A?+\n        Ket\n        End\n------------------------------------------------------------------\nCapture group count = 0\nFirst code unit = 'A' (caseless)\nLast code unit = 'A' (caseless)\nSubject length lower bound = 2\n    aabcd\n 0: aa\n\n--\n    \\[X]{-10}\n** Zero or negative repeat not allowed\n\n# End of testinput2\nError -70: PCRE2_ERROR_BADDATA (unknown error number)\nError -62: bad serialized data\nError -2: partial match\nError -1: no match\nError 0: PCRE2_ERROR_BADDATA (unknown error number)\nError 100: no error\nError 101: \\ at end of pattern\nError 191: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not allowed in UTF-16 mode\nError 200: PCRE2_ERROR_BADDATA (unknown error number)\n"], "filenames": ["ChangeLog", "src/pcre2test.c", "testdata/testinput2", "testdata/testoutput2"], "buggy_code_start_loc": [76, 6847, 5936, 17750], "buggy_code_end_loc": [76, 6850, 5936, 17750], "fixing_code_start_loc": [77, 6847, 5937, 17751], "fixing_code_end_loc": [80, 6850, 5940, 17755], "type": "CWE-190", "message": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.", "other": {"cve": {"id": "CVE-2022-41409", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-18T14:15:12.197", "lastModified": "2023-07-27T03:46:09.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pcre:pcre2:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.41", "matchCriteriaId": "BD82E860-EFC8-4692-8EE8-1514A9184D2B"}]}]}], "references": [{"url": "https://github.com/PCRE2Project/pcre2/commit/94e1c001761373b7d9450768aa15d04c25547a35", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/PCRE2Project/pcre2/issues/141", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/PCRE2Project/pcre2/commit/94e1c001761373b7d9450768aa15d04c25547a35"}}