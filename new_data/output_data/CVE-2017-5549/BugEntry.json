{"buggy_code": ["/*\n * KLSI KL5KUSB105 chip RS232 converter driver\n *\n *   Copyright (C) 2010 Johan Hovold <jhovold@gmail.com>\n *   Copyright (C) 2001 Utz-Uwe Haus <haus@uuhaus.de>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n * All information about the device was acquired using SniffUSB ans snoopUSB\n * on Windows98.\n * It was written out of frustration with the PalmConnect USB Serial adapter\n * sold by Palm Inc.\n * Neither Palm, nor their contractor (MCCI) or their supplier (KLSI) provided\n * information that was not already available.\n *\n * It seems that KLSI bought some silicon-design information from ScanLogic,\n * whose SL11R processor is at the core of the KL5KUSB chipset from KLSI.\n * KLSI has firmware available for their devices; it is probable that the\n * firmware differs from that used by KLSI in their products. If you have an\n * original KLSI device and can provide some information on it, I would be\n * most interested in adding support for it here. If you have any information\n * on the protocol used (or find errors in my reverse-engineered stuff), please\n * let me know.\n *\n * The code was only tested with a PalmConnect USB adapter; if you\n * are adventurous, try it with any KLSI-based device and let me know how it\n * breaks so that I can fix it!\n */\n\n/* TODO:\n *\tcheck modem line signals\n *\timplement handshaking or decide that we do not support it\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include \"kl5kusb105.h\"\n\n#define DRIVER_AUTHOR \"Utz-Uwe Haus <haus@uuhaus.de>, Johan Hovold <jhovold@gmail.com>\"\n#define DRIVER_DESC \"KLSI KL5KUSB105 chipset USB->Serial Converter driver\"\n\n\n/*\n * Function prototypes\n */\nstatic int klsi_105_port_probe(struct usb_serial_port *port);\nstatic int klsi_105_port_remove(struct usb_serial_port *port);\nstatic int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void klsi_105_close(struct usb_serial_port *port);\nstatic void klsi_105_set_termios(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port, struct ktermios *old);\nstatic int  klsi_105_tiocmget(struct tty_struct *tty);\nstatic void klsi_105_process_read_urb(struct urb *urb);\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size);\n\n/*\n * All of the device info needed for the KLSI converters.\n */\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(PALMCONNECT_VID, PALMCONNECT_PID) },\n\t{ USB_DEVICE(KLSI_VID, KLSI_KL5KUSB105D_PID) },\n\t{ }\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver kl5kusb105d_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"kl5kusb105d\",\n\t},\n\t.description =\t\t\"KL5KUSB105D / PalmConnect\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.bulk_out_size =\t64,\n\t.open =\t\t\tklsi_105_open,\n\t.close =\t\tklsi_105_close,\n\t.set_termios =\t\tklsi_105_set_termios,\n\t/*.break_ctl =\t\tklsi_105_break_ctl,*/\n\t.tiocmget =\t\tklsi_105_tiocmget,\n\t.port_probe =\t\tklsi_105_port_probe,\n\t.port_remove =\t\tklsi_105_port_remove,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.process_read_urb =\tklsi_105_process_read_urb,\n\t.prepare_write_buffer =\tklsi_105_prepare_write_buffer,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&kl5kusb105d_device, NULL\n};\n\nstruct klsi_105_port_settings {\n\t__u8\tpktlen;\t\t/* always 5, it seems */\n\t__u8\tbaudrate;\n\t__u8\tdatabits;\n\t__u8\tunknown1;\n\t__u8\tunknown2;\n} __attribute__ ((packed));\n\nstruct klsi_105_private {\n\tstruct klsi_105_port_settings\tcfg;\n\tstruct ktermios\t\t\ttermios;\n\tunsigned long\t\t\tline_state; /* modem line settings */\n\tspinlock_t\t\t\tlock;\n};\n\n\n/*\n * Handle vendor specific USB requests\n */\n\n\n#define KLSI_TIMEOUT\t 5000 /* default urb timeout */\n\nstatic int klsi_105_chg_port_settings(struct usb_serial_port *port,\n\t\t\t\t      struct klsi_105_port_settings *settings)\n{\n\tint rc;\n\n\trc = usb_control_msg(port->serial->dev,\n\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\n\t\t\tKL5KUSB105A_SIO_SET_DATA,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_INTERFACE,\n\t\t\t0, /* value */\n\t\t\t0, /* index */\n\t\t\tsettings,\n\t\t\tsizeof(struct klsi_105_port_settings),\n\t\t\tKLSI_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev,\n\t\t\t\"Change port settings failed (error = %d)\\n\", rc);\n\tdev_info(&port->serial->dev->dev,\n\t\t \"%d byte block, baudrate %x, databits %d, u1 %d, u2 %d\\n\",\n\t\t settings->pktlen, settings->baudrate, settings->databits,\n\t\t settings->unknown1, settings->unknown2);\n\treturn rc;\n}\n\n/* translate a 16-bit status value from the device to linux's TIO bits */\nstatic unsigned long klsi_105_status2linestate(const __u16 status)\n{\n\tunsigned long res = 0;\n\n\tres =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)\n\t      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)\n\t      ;\n\n\treturn res;\n}\n\n/*\n * Read line control via vendor command and return result through\n * *line_state_p\n */\n/* It seems that the status buffer has always only 2 bytes length */\n#define KLSI_STATUSBUF_LEN\t2\nstatic int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}\n\n\n/*\n * Driver's tty interface functions\n */\n\nstatic int klsi_105_port_probe(struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv;\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t/* set initial values for control structures */\n\tpriv->cfg.pktlen    = 5;\n\tpriv->cfg.baudrate  = kl5kusb105a_sio_b9600;\n\tpriv->cfg.databits  = kl5kusb105a_dtb_8;\n\tpriv->cfg.unknown1  = 0;\n\tpriv->cfg.unknown2  = 1;\n\n\tpriv->line_state    = 0;\n\n\tspin_lock_init(&priv->lock);\n\n\t/* priv->termios is left uninitialized until port opening */\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic int klsi_105_port_remove(struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tint retval = 0;\n\tint rc;\n\tint i;\n\tunsigned long line_state;\n\tstruct klsi_105_port_settings *cfg;\n\tunsigned long flags;\n\n\t/* Do a defined restart:\n\t * Set up sane default baud rate and send the 'READ_ON'\n\t * vendor command.\n\t * FIXME: set modem line control (how?)\n\t * Then read the modem line control and store values in\n\t * priv->line_state.\n\t */\n\tcfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->pktlen   = 5;\n\tcfg->baudrate = kl5kusb105a_sio_b9600;\n\tcfg->databits = kl5kusb105a_dtb_8;\n\tcfg->unknown1 = 0;\n\tcfg->unknown2 = 1;\n\tklsi_105_chg_port_settings(port, cfg);\n\n\t/* set up termios structure */\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->termios.c_iflag = tty->termios.c_iflag;\n\tpriv->termios.c_oflag = tty->termios.c_oflag;\n\tpriv->termios.c_cflag = tty->termios.c_cflag;\n\tpriv->termios.c_lflag = tty->termios.c_lflag;\n\tfor (i = 0; i < NCCS; i++)\n\t\tpriv->termios.c_cc[i] = tty->termios.c_cc[i];\n\tpriv->cfg.pktlen   = cfg->pktlen;\n\tpriv->cfg.baudrate = cfg->baudrate;\n\tpriv->cfg.databits = cfg->databits;\n\tpriv->cfg.unknown1 = cfg->unknown1;\n\tpriv->cfg.unknown2 = cfg->unknown2;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* READ_ON and urb submission */\n\trc = usb_serial_generic_open(tty, port);\n\tif (rc) {\n\t\tretval = rc;\n\t\tgoto err_free_cfg;\n\t}\n\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_ON,\n\t\t\t     0, /* index */\n\t\t\t     NULL,\n\t\t\t     0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev, \"Enabling read failed (error = %d)\\n\", rc);\n\t\tretval = rc;\n\t\tgoto err_generic_close;\n\t} else\n\t\tdev_dbg(&port->dev, \"%s - enabled reading\\n\", __func__);\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto err_disable_read;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__,\n\t\t\tline_state);\n\n\treturn 0;\n\nerr_disable_read:\n\tusb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0, /* index */\n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\nerr_generic_close:\n\tusb_serial_generic_close(port);\nerr_free_cfg:\n\tkfree(cfg);\n\n\treturn retval;\n}\n\nstatic void klsi_105_close(struct usb_serial_port *port)\n{\n\tint rc;\n\n\t/* send READ_OFF */\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0, /* index */\n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"failed to disable read: %d\\n\", rc);\n\n\t/* shutdown our bulk reads and writes */\n\tusb_serial_generic_close(port);\n}\n\n/* We need to write a complete 64-byte data block and encode the\n * number actually sent in the first double-byte, LSB-order. That\n * leaves at most 62 bytes of payload.\n */\n#define KLSI_HDR_LEN\t\t2\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\tunsigned char *buf = dest;\n\tint count;\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf + KLSI_HDR_LEN, size,\n\t\t\t\t\t\t\t\t&port->lock);\n\tput_unaligned_le16(count, buf);\n\n\treturn count + KLSI_HDR_LEN;\n}\n\n/* The data received is preceded by a length double-byte in LSB-first order.\n */\nstatic void klsi_105_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned len;\n\n\t/* empty urbs seem to happen, we ignore them */\n\tif (!urb->actual_length)\n\t\treturn;\n\n\tif (urb->actual_length <= KLSI_HDR_LEN) {\n\t\tdev_dbg(&port->dev, \"%s - malformed packet\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlen = get_unaligned_le16(data);\n\tif (len > urb->actual_length - KLSI_HDR_LEN) {\n\t\tdev_dbg(&port->dev, \"%s - packet length mismatch\\n\", __func__);\n\t\tlen = urb->actual_length - KLSI_HDR_LEN;\n\t}\n\n\ttty_insert_flip_string(&port->port, data + KLSI_HDR_LEN, len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void klsi_105_set_termios(struct tty_struct *tty,\n\t\t\t\t struct usb_serial_port *port,\n\t\t\t\t struct ktermios *old_termios)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned int iflag = tty->termios.c_iflag;\n\tunsigned int old_iflag = old_termios->c_iflag;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tunsigned int old_cflag = old_termios->c_cflag;\n\tstruct klsi_105_port_settings *cfg;\n\tunsigned long flags;\n\tspeed_t baud;\n\n\tcfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn;\n\n\t/* lock while we are modifying the settings */\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t/*\n\t * Update baud rate\n\t */\n\tbaud = tty_get_baud_rate(tty);\n\n\tif ((cflag & CBAUD) != (old_cflag & CBAUD)) {\n\t\t/* reassert DTR and (maybe) RTS on transition from B0 */\n\t\tif ((old_cflag & CBAUD) == B0) {\n\t\t\tdev_dbg(dev, \"%s: baud was B0\\n\", __func__);\n#if 0\n\t\t\tpriv->control_state |= TIOCM_DTR;\n\t\t\t/* don't set RTS if using hardware flow control */\n\t\t\tif (!(old_cflag & CRTSCTS))\n\t\t\t\tpriv->control_state |= TIOCM_RTS;\n\t\t\tmct_u232_set_modem_ctrl(serial, priv->control_state);\n#endif\n\t\t}\n\t}\n\tswitch (baud) {\n\tcase 0: /* handled below */\n\t\tbreak;\n\tcase 1200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b1200;\n\t\tbreak;\n\tcase 2400:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b2400;\n\t\tbreak;\n\tcase 4800:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b4800;\n\t\tbreak;\n\tcase 9600:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b9600;\n\t\tbreak;\n\tcase 19200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b19200;\n\t\tbreak;\n\tcase 38400:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b38400;\n\t\tbreak;\n\tcase 57600:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b57600;\n\t\tbreak;\n\tcase 115200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b115200;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"unsupported baudrate, using 9600\\n\");\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b9600;\n\t\tbaud = 9600;\n\t\tbreak;\n\t}\n\tif ((cflag & CBAUD) == B0) {\n\t\tdev_dbg(dev, \"%s: baud is B0\\n\", __func__);\n\t\t/* Drop RTS and DTR */\n\t\t/* maybe this should be simulated by sending read\n\t\t * disable and read enable messages?\n\t\t */\n#if 0\n\t\tpriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tmct_u232_set_modem_ctrl(serial, priv->control_state);\n#endif\n\t}\n\ttty_encode_baud_rate(tty, baud, baud);\n\n\tif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\n\t\t/* set the number of data bits */\n\t\tswitch (cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tdev_dbg(dev, \"%s - 5 bits/byte not supported\\n\", __func__);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto err;\n\t\tcase CS6:\n\t\t\tdev_dbg(dev, \"%s - 6 bits/byte not supported\\n\", __func__);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto err;\n\t\tcase CS7:\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_7;\n\t\t\tbreak;\n\t\tcase CS8:\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"CSIZE was not CS5-CS8, using default of 8\\n\");\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Update line control register (LCR)\n\t */\n\tif ((cflag & (PARENB|PARODD)) != (old_cflag & (PARENB|PARODD))\n\t    || (cflag & CSTOPB) != (old_cflag & CSTOPB)) {\n\t\t/* Not currently supported */\n\t\ttty->termios.c_cflag &= ~(PARENB|PARODD|CSTOPB);\n#if 0\n\t\tpriv->last_lcr = 0;\n\n\t\t/* set the parity */\n\t\tif (cflag & PARENB)\n\t\t\tpriv->last_lcr |= (cflag & PARODD) ?\n\t\t\t\tMCT_U232_PARITY_ODD : MCT_U232_PARITY_EVEN;\n\t\telse\n\t\t\tpriv->last_lcr |= MCT_U232_PARITY_NONE;\n\n\t\t/* set the number of stop bits */\n\t\tpriv->last_lcr |= (cflag & CSTOPB) ?\n\t\t\tMCT_U232_STOP_BITS_2 : MCT_U232_STOP_BITS_1;\n\n\t\tmct_u232_set_line_ctrl(serial, priv->last_lcr);\n#endif\n\t}\n\t/*\n\t * Set flow control: well, I do not really now how to handle DTR/RTS.\n\t * Just do what we have seen with SniffUSB on Win98.\n\t */\n\tif ((iflag & IXOFF) != (old_iflag & IXOFF)\n\t    || (iflag & IXON) != (old_iflag & IXON)\n\t    ||  (cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\n\t\t/* Not currently supported */\n\t\ttty->termios.c_cflag &= ~CRTSCTS;\n\t\t/* Drop DTR/RTS if no flow control otherwise assert */\n#if 0\n\t\tif ((iflag & IXOFF) || (iflag & IXON) || (cflag & CRTSCTS))\n\t\t\tpriv->control_state |= TIOCM_DTR | TIOCM_RTS;\n\t\telse\n\t\t\tpriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tmct_u232_set_modem_ctrl(serial, priv->control_state);\n#endif\n\t}\n\tmemcpy(cfg, &priv->cfg, sizeof(*cfg));\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* now commit changes to device */\n\tklsi_105_chg_port_settings(port, cfg);\nerr:\n\tkfree(cfg);\n}\n\n#if 0\nstatic void mct_u232_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tstruct mct_u232_private *priv =\n\t\t\t\t(struct mct_u232_private *)port->private;\n\tunsigned char lcr = priv->last_lcr;\n\n\tdev_dbg(&port->dev, \"%s - state=%d\\n\", __func__, break_state);\n\n\t/* LOCKING */\n\tif (break_state)\n\t\tlcr |= MCT_U232_SET_BREAK;\n\n\tmct_u232_set_line_ctrl(serial, lcr);\n}\n#endif\n\nstatic int klsi_105_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint rc;\n\tunsigned long line_state;\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev,\n\t\t\t\"Reading line control failed (error = %d)\\n\", rc);\n\t\t/* better return value? EAGAIN? */\n\t\treturn rc;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__, line_state);\n\treturn (int)line_state;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * KLSI KL5KUSB105 chip RS232 converter driver\n *\n *   Copyright (C) 2010 Johan Hovold <jhovold@gmail.com>\n *   Copyright (C) 2001 Utz-Uwe Haus <haus@uuhaus.de>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n * All information about the device was acquired using SniffUSB ans snoopUSB\n * on Windows98.\n * It was written out of frustration with the PalmConnect USB Serial adapter\n * sold by Palm Inc.\n * Neither Palm, nor their contractor (MCCI) or their supplier (KLSI) provided\n * information that was not already available.\n *\n * It seems that KLSI bought some silicon-design information from ScanLogic,\n * whose SL11R processor is at the core of the KL5KUSB chipset from KLSI.\n * KLSI has firmware available for their devices; it is probable that the\n * firmware differs from that used by KLSI in their products. If you have an\n * original KLSI device and can provide some information on it, I would be\n * most interested in adding support for it here. If you have any information\n * on the protocol used (or find errors in my reverse-engineered stuff), please\n * let me know.\n *\n * The code was only tested with a PalmConnect USB adapter; if you\n * are adventurous, try it with any KLSI-based device and let me know how it\n * breaks so that I can fix it!\n */\n\n/* TODO:\n *\tcheck modem line signals\n *\timplement handshaking or decide that we do not support it\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include \"kl5kusb105.h\"\n\n#define DRIVER_AUTHOR \"Utz-Uwe Haus <haus@uuhaus.de>, Johan Hovold <jhovold@gmail.com>\"\n#define DRIVER_DESC \"KLSI KL5KUSB105 chipset USB->Serial Converter driver\"\n\n\n/*\n * Function prototypes\n */\nstatic int klsi_105_port_probe(struct usb_serial_port *port);\nstatic int klsi_105_port_remove(struct usb_serial_port *port);\nstatic int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void klsi_105_close(struct usb_serial_port *port);\nstatic void klsi_105_set_termios(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port, struct ktermios *old);\nstatic int  klsi_105_tiocmget(struct tty_struct *tty);\nstatic void klsi_105_process_read_urb(struct urb *urb);\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size);\n\n/*\n * All of the device info needed for the KLSI converters.\n */\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(PALMCONNECT_VID, PALMCONNECT_PID) },\n\t{ USB_DEVICE(KLSI_VID, KLSI_KL5KUSB105D_PID) },\n\t{ }\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver kl5kusb105d_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"kl5kusb105d\",\n\t},\n\t.description =\t\t\"KL5KUSB105D / PalmConnect\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.bulk_out_size =\t64,\n\t.open =\t\t\tklsi_105_open,\n\t.close =\t\tklsi_105_close,\n\t.set_termios =\t\tklsi_105_set_termios,\n\t/*.break_ctl =\t\tklsi_105_break_ctl,*/\n\t.tiocmget =\t\tklsi_105_tiocmget,\n\t.port_probe =\t\tklsi_105_port_probe,\n\t.port_remove =\t\tklsi_105_port_remove,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.process_read_urb =\tklsi_105_process_read_urb,\n\t.prepare_write_buffer =\tklsi_105_prepare_write_buffer,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&kl5kusb105d_device, NULL\n};\n\nstruct klsi_105_port_settings {\n\t__u8\tpktlen;\t\t/* always 5, it seems */\n\t__u8\tbaudrate;\n\t__u8\tdatabits;\n\t__u8\tunknown1;\n\t__u8\tunknown2;\n} __attribute__ ((packed));\n\nstruct klsi_105_private {\n\tstruct klsi_105_port_settings\tcfg;\n\tstruct ktermios\t\t\ttermios;\n\tunsigned long\t\t\tline_state; /* modem line settings */\n\tspinlock_t\t\t\tlock;\n};\n\n\n/*\n * Handle vendor specific USB requests\n */\n\n\n#define KLSI_TIMEOUT\t 5000 /* default urb timeout */\n\nstatic int klsi_105_chg_port_settings(struct usb_serial_port *port,\n\t\t\t\t      struct klsi_105_port_settings *settings)\n{\n\tint rc;\n\n\trc = usb_control_msg(port->serial->dev,\n\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\n\t\t\tKL5KUSB105A_SIO_SET_DATA,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_INTERFACE,\n\t\t\t0, /* value */\n\t\t\t0, /* index */\n\t\t\tsettings,\n\t\t\tsizeof(struct klsi_105_port_settings),\n\t\t\tKLSI_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev,\n\t\t\t\"Change port settings failed (error = %d)\\n\", rc);\n\tdev_info(&port->serial->dev->dev,\n\t\t \"%d byte block, baudrate %x, databits %d, u1 %d, u2 %d\\n\",\n\t\t settings->pktlen, settings->baudrate, settings->databits,\n\t\t settings->unknown1, settings->unknown2);\n\treturn rc;\n}\n\n/* translate a 16-bit status value from the device to linux's TIO bits */\nstatic unsigned long klsi_105_status2linestate(const __u16 status)\n{\n\tunsigned long res = 0;\n\n\tres =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)\n\t      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)\n\t      ;\n\n\treturn res;\n}\n\n/*\n * Read line control via vendor command and return result through\n * *line_state_p\n */\n/* It seems that the status buffer has always only 2 bytes length */\n#define KLSI_STATUSBUF_LEN\t2\nstatic int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}\n\n\n/*\n * Driver's tty interface functions\n */\n\nstatic int klsi_105_port_probe(struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv;\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t/* set initial values for control structures */\n\tpriv->cfg.pktlen    = 5;\n\tpriv->cfg.baudrate  = kl5kusb105a_sio_b9600;\n\tpriv->cfg.databits  = kl5kusb105a_dtb_8;\n\tpriv->cfg.unknown1  = 0;\n\tpriv->cfg.unknown2  = 1;\n\n\tpriv->line_state    = 0;\n\n\tspin_lock_init(&priv->lock);\n\n\t/* priv->termios is left uninitialized until port opening */\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic int klsi_105_port_remove(struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tint retval = 0;\n\tint rc;\n\tint i;\n\tunsigned long line_state;\n\tstruct klsi_105_port_settings *cfg;\n\tunsigned long flags;\n\n\t/* Do a defined restart:\n\t * Set up sane default baud rate and send the 'READ_ON'\n\t * vendor command.\n\t * FIXME: set modem line control (how?)\n\t * Then read the modem line control and store values in\n\t * priv->line_state.\n\t */\n\tcfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->pktlen   = 5;\n\tcfg->baudrate = kl5kusb105a_sio_b9600;\n\tcfg->databits = kl5kusb105a_dtb_8;\n\tcfg->unknown1 = 0;\n\tcfg->unknown2 = 1;\n\tklsi_105_chg_port_settings(port, cfg);\n\n\t/* set up termios structure */\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->termios.c_iflag = tty->termios.c_iflag;\n\tpriv->termios.c_oflag = tty->termios.c_oflag;\n\tpriv->termios.c_cflag = tty->termios.c_cflag;\n\tpriv->termios.c_lflag = tty->termios.c_lflag;\n\tfor (i = 0; i < NCCS; i++)\n\t\tpriv->termios.c_cc[i] = tty->termios.c_cc[i];\n\tpriv->cfg.pktlen   = cfg->pktlen;\n\tpriv->cfg.baudrate = cfg->baudrate;\n\tpriv->cfg.databits = cfg->databits;\n\tpriv->cfg.unknown1 = cfg->unknown1;\n\tpriv->cfg.unknown2 = cfg->unknown2;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* READ_ON and urb submission */\n\trc = usb_serial_generic_open(tty, port);\n\tif (rc) {\n\t\tretval = rc;\n\t\tgoto err_free_cfg;\n\t}\n\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_ON,\n\t\t\t     0, /* index */\n\t\t\t     NULL,\n\t\t\t     0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev, \"Enabling read failed (error = %d)\\n\", rc);\n\t\tretval = rc;\n\t\tgoto err_generic_close;\n\t} else\n\t\tdev_dbg(&port->dev, \"%s - enabled reading\\n\", __func__);\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto err_disable_read;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__,\n\t\t\tline_state);\n\n\treturn 0;\n\nerr_disable_read:\n\tusb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0, /* index */\n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\nerr_generic_close:\n\tusb_serial_generic_close(port);\nerr_free_cfg:\n\tkfree(cfg);\n\n\treturn retval;\n}\n\nstatic void klsi_105_close(struct usb_serial_port *port)\n{\n\tint rc;\n\n\t/* send READ_OFF */\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0, /* index */\n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"failed to disable read: %d\\n\", rc);\n\n\t/* shutdown our bulk reads and writes */\n\tusb_serial_generic_close(port);\n}\n\n/* We need to write a complete 64-byte data block and encode the\n * number actually sent in the first double-byte, LSB-order. That\n * leaves at most 62 bytes of payload.\n */\n#define KLSI_HDR_LEN\t\t2\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\tunsigned char *buf = dest;\n\tint count;\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf + KLSI_HDR_LEN, size,\n\t\t\t\t\t\t\t\t&port->lock);\n\tput_unaligned_le16(count, buf);\n\n\treturn count + KLSI_HDR_LEN;\n}\n\n/* The data received is preceded by a length double-byte in LSB-first order.\n */\nstatic void klsi_105_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned len;\n\n\t/* empty urbs seem to happen, we ignore them */\n\tif (!urb->actual_length)\n\t\treturn;\n\n\tif (urb->actual_length <= KLSI_HDR_LEN) {\n\t\tdev_dbg(&port->dev, \"%s - malformed packet\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlen = get_unaligned_le16(data);\n\tif (len > urb->actual_length - KLSI_HDR_LEN) {\n\t\tdev_dbg(&port->dev, \"%s - packet length mismatch\\n\", __func__);\n\t\tlen = urb->actual_length - KLSI_HDR_LEN;\n\t}\n\n\ttty_insert_flip_string(&port->port, data + KLSI_HDR_LEN, len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void klsi_105_set_termios(struct tty_struct *tty,\n\t\t\t\t struct usb_serial_port *port,\n\t\t\t\t struct ktermios *old_termios)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned int iflag = tty->termios.c_iflag;\n\tunsigned int old_iflag = old_termios->c_iflag;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tunsigned int old_cflag = old_termios->c_cflag;\n\tstruct klsi_105_port_settings *cfg;\n\tunsigned long flags;\n\tspeed_t baud;\n\n\tcfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn;\n\n\t/* lock while we are modifying the settings */\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t/*\n\t * Update baud rate\n\t */\n\tbaud = tty_get_baud_rate(tty);\n\n\tif ((cflag & CBAUD) != (old_cflag & CBAUD)) {\n\t\t/* reassert DTR and (maybe) RTS on transition from B0 */\n\t\tif ((old_cflag & CBAUD) == B0) {\n\t\t\tdev_dbg(dev, \"%s: baud was B0\\n\", __func__);\n#if 0\n\t\t\tpriv->control_state |= TIOCM_DTR;\n\t\t\t/* don't set RTS if using hardware flow control */\n\t\t\tif (!(old_cflag & CRTSCTS))\n\t\t\t\tpriv->control_state |= TIOCM_RTS;\n\t\t\tmct_u232_set_modem_ctrl(serial, priv->control_state);\n#endif\n\t\t}\n\t}\n\tswitch (baud) {\n\tcase 0: /* handled below */\n\t\tbreak;\n\tcase 1200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b1200;\n\t\tbreak;\n\tcase 2400:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b2400;\n\t\tbreak;\n\tcase 4800:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b4800;\n\t\tbreak;\n\tcase 9600:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b9600;\n\t\tbreak;\n\tcase 19200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b19200;\n\t\tbreak;\n\tcase 38400:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b38400;\n\t\tbreak;\n\tcase 57600:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b57600;\n\t\tbreak;\n\tcase 115200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b115200;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"unsupported baudrate, using 9600\\n\");\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b9600;\n\t\tbaud = 9600;\n\t\tbreak;\n\t}\n\tif ((cflag & CBAUD) == B0) {\n\t\tdev_dbg(dev, \"%s: baud is B0\\n\", __func__);\n\t\t/* Drop RTS and DTR */\n\t\t/* maybe this should be simulated by sending read\n\t\t * disable and read enable messages?\n\t\t */\n#if 0\n\t\tpriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tmct_u232_set_modem_ctrl(serial, priv->control_state);\n#endif\n\t}\n\ttty_encode_baud_rate(tty, baud, baud);\n\n\tif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\n\t\t/* set the number of data bits */\n\t\tswitch (cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tdev_dbg(dev, \"%s - 5 bits/byte not supported\\n\", __func__);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto err;\n\t\tcase CS6:\n\t\t\tdev_dbg(dev, \"%s - 6 bits/byte not supported\\n\", __func__);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto err;\n\t\tcase CS7:\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_7;\n\t\t\tbreak;\n\t\tcase CS8:\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"CSIZE was not CS5-CS8, using default of 8\\n\");\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Update line control register (LCR)\n\t */\n\tif ((cflag & (PARENB|PARODD)) != (old_cflag & (PARENB|PARODD))\n\t    || (cflag & CSTOPB) != (old_cflag & CSTOPB)) {\n\t\t/* Not currently supported */\n\t\ttty->termios.c_cflag &= ~(PARENB|PARODD|CSTOPB);\n#if 0\n\t\tpriv->last_lcr = 0;\n\n\t\t/* set the parity */\n\t\tif (cflag & PARENB)\n\t\t\tpriv->last_lcr |= (cflag & PARODD) ?\n\t\t\t\tMCT_U232_PARITY_ODD : MCT_U232_PARITY_EVEN;\n\t\telse\n\t\t\tpriv->last_lcr |= MCT_U232_PARITY_NONE;\n\n\t\t/* set the number of stop bits */\n\t\tpriv->last_lcr |= (cflag & CSTOPB) ?\n\t\t\tMCT_U232_STOP_BITS_2 : MCT_U232_STOP_BITS_1;\n\n\t\tmct_u232_set_line_ctrl(serial, priv->last_lcr);\n#endif\n\t}\n\t/*\n\t * Set flow control: well, I do not really now how to handle DTR/RTS.\n\t * Just do what we have seen with SniffUSB on Win98.\n\t */\n\tif ((iflag & IXOFF) != (old_iflag & IXOFF)\n\t    || (iflag & IXON) != (old_iflag & IXON)\n\t    ||  (cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\n\t\t/* Not currently supported */\n\t\ttty->termios.c_cflag &= ~CRTSCTS;\n\t\t/* Drop DTR/RTS if no flow control otherwise assert */\n#if 0\n\t\tif ((iflag & IXOFF) || (iflag & IXON) || (cflag & CRTSCTS))\n\t\t\tpriv->control_state |= TIOCM_DTR | TIOCM_RTS;\n\t\telse\n\t\t\tpriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tmct_u232_set_modem_ctrl(serial, priv->control_state);\n#endif\n\t}\n\tmemcpy(cfg, &priv->cfg, sizeof(*cfg));\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* now commit changes to device */\n\tklsi_105_chg_port_settings(port, cfg);\nerr:\n\tkfree(cfg);\n}\n\n#if 0\nstatic void mct_u232_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tstruct mct_u232_private *priv =\n\t\t\t\t(struct mct_u232_private *)port->private;\n\tunsigned char lcr = priv->last_lcr;\n\n\tdev_dbg(&port->dev, \"%s - state=%d\\n\", __func__, break_state);\n\n\t/* LOCKING */\n\tif (break_state)\n\t\tlcr |= MCT_U232_SET_BREAK;\n\n\tmct_u232_set_line_ctrl(serial, lcr);\n}\n#endif\n\nstatic int klsi_105_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint rc;\n\tunsigned long line_state;\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev,\n\t\t\t\"Reading line control failed (error = %d)\\n\", rc);\n\t\t/* better return value? EAGAIN? */\n\t\treturn rc;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__, line_state);\n\treturn (int)line_state;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/serial/kl5kusb105.c"], "buggy_code_start_loc": [195], "buggy_code_end_loc": [199], "fixing_code_start_loc": [195], "fixing_code_end_loc": [200], "type": "CWE-532", "message": "The klsi_105_get_line_state function in drivers/usb/serial/kl5kusb105.c in the Linux kernel before 4.9.5 places uninitialized heap-memory contents into a log entry upon a failure to read the line status, which allows local users to obtain sensitive information by reading the log.", "other": {"cve": {"id": "CVE-2017-5549", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-06T06:59:00.623", "lastModified": "2018-08-24T10:29:02.477", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The klsi_105_get_line_state function in drivers/usb/serial/kl5kusb105.c in the Linux kernel before 4.9.5 places uninitialized heap-memory contents into a log entry upon a failure to read the line status, which allows local users to obtain sensitive information by reading the log."}, {"lang": "es", "value": "La funci\u00f3n klsi_105_get_line_state en drivers/usb/serial/kl5kusb105.c en el kernel de Linux en versiones anteriores a 4.9.5 coloca los contenidos de memoria de pila no inicializados en una entrada de registro sobre un fallo para leer el estado de la l\u00ednea, lo que permite a usuarios locales obtener informaci\u00f3n sensible leyendo el registro."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.4", "matchCriteriaId": "7C19DB2D-DE85-4140-817A-D010708EB355"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=146cc8a17a3b4996f6805ee5c080e7101277c410", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3791", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.5", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/21/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95715", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1416114", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/146cc8a17a3b4996f6805ee5c080e7101277c410", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/146cc8a17a3b4996f6805ee5c080e7101277c410"}}