{"buggy_code": ["/*\n *  linux/fs/proc/base.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc base directory handling functions\n *\n *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.\n *  Instead of using magical inumbers to determine the kind of object\n *  we allocate and fill in-core inodes upon lookup. They don't even\n *  go into icache. We cache the reference to task_struct upon lookup too.\n *  Eventually it should become a filesystem in its own. We don't use the\n *  rest of procfs anymore.\n *\n *\n *  Changelog:\n *  17-Jan-2005\n *  Allan Bezerra\n *  Bruna Moreira <bruna.moreira@indt.org.br>\n *  Edjard Mota <edjard.mota@indt.org.br>\n *  Ilias Biris <ilias.biris@indt.org.br>\n *  Mauricio Lin <mauricio.lin@indt.org.br>\n *\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *\n *  A new process specific entry (smaps) included in /proc. It shows the\n *  size of rss for each memory area. The maps entry lacks information\n *  about physical memory size (rss) for each mapped file, i.e.,\n *  rss information for executables and library files.\n *  This additional information is useful for any tools that need to know\n *  about physical memory consumption for a process specific library.\n *\n *  Changelog:\n *  21-Feb-2005\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *  Pud inclusion in the page table walking.\n *\n *  ChangeLog:\n *  10-Mar-2005\n *  10LE Instituto Nokia de Tecnologia - INdT:\n *  A better way to walks through the page table as suggested by Hugh Dickins.\n *\n *  Simo Piiroinen <simo.piiroinen@nokia.com>:\n *  Smaps information related to shared, private, clean and dirty pages.\n *\n *  Paul Mundt <paul.mundt@nokia.com>:\n *  Overall revision about smaps.\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/tracehook.h>\n#include <linux/printk.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/flex_array.h>\n#include <linux/posix-timers.h>\n#ifdef CONFIG_HARDWALL\n#include <asm/hardwall.h>\n#endif\n#include <trace/events/oom.h>\n#include \"internal.h\"\n#include \"fd.h\"\n\n/* NOTE:\n *\tImplementing inode permission operations in /proc is almost\n *\tcertainly an error.  Permission checks need to happen during\n *\teach system call not at open time.  The reason is that most of\n *\twhat we wish to check for permissions in /proc varies at runtime.\n *\n *\tThe classic example of a problem is opening file descriptors\n *\tin /proc for a task before it execs a suid executable.\n */\n\nstruct pid_entry {\n\tconst char *name;\n\tint len;\n\tumode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n\n/*\n * Count the number of hardlinks for the pid_entry table, excluding the .\n * and .. links.\n */\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and maybe\n\t\t * extends into ENVP.\n\t\t */\n\t\tif (len1 + len2 <= *pos)\n\t\t\tgoto skip_argv_envp;\n\t\tif (len1 <= *pos)\n\t\t\tgoto skip_argv;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count, l;\n\t\t\tint nr_read;\n\t\t\tbool final;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\t/*\n\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t */\n\t\t\tfinal = false;\n\t\t\tl = strnlen(page, nr_read);\n\t\t\tif (l < nr_read) {\n\t\t\t\tnr_read = l;\n\t\t\t\tfinal = true;\n\t\t\t}\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\n\t\t\tif (final)\n\t\t\t\tgoto out_free_page;\n\t\t}\nskip_argv:\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tif (len1 <= *pos) {\n\t\t\tp = env_start + *pos - len1;\n\t\t\tlen = len1 + len2 - *pos;\n\t\t} else {\n\t\t\tp = env_start;\n\t\t\tlen = len2;\n\t\t}\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count, l;\n\t\t\tint nr_read;\n\t\t\tbool final;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\t/* Find EOS. */\n\t\t\tfinal = false;\n\t\t\tl = strnlen(page, nr_read);\n\t\t\tif (l < nr_read) {\n\t\t\t\tnr_read = l;\n\t\t\t\tfinal = true;\n\t\t\t}\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\n\t\t\tif (final)\n\t\t\t\tgoto out_free_page;\n\t\t}\nskip_argv_envp:\n\t\t;\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}\n\nstatic const struct file_operations proc_pid_cmdline_ops = {\n\t.read\t= proc_pid_cmdline_read,\n\t.llseek\t= generic_file_llseek,\n};\n\nstatic int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t struct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);\n\tif (mm && !IS_ERR(mm)) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tseq_write(m, mm->saved_auxv, nwords * sizeof(mm->saved_auxv[0]));\n\t\tmmput(mm);\n\t\treturn 0;\n\t} else\n\t\treturn PTR_ERR(mm);\n}\n\n\n#ifdef CONFIG_KALLSYMS\n/*\n * Provides a wchan file via kallsyms in a proper one-value-per-file format.\n * Returns the resolved symbol.  If that fails, simply return the address.\n */\nstatic int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (wchan && ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)\n\t\t\t&& !lookup_symbol_name(wchan, symname))\n\t\tseq_printf(m, \"%s\", symname);\n\telse\n\t\tseq_puts(m, \"0\\n\");\n\n\treturn 0;\n}\n#endif /* CONFIG_KALLSYMS */\n\nstatic int lock_trace(struct task_struct *task)\n{\n\tint err = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint err;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tsave_stack_trace_tsk(task, &trace);\n\n\t\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<%pK>] %pS\\n\",\n\t\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t\t}\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_SCHED_INFO\n/*\n * Provides /proc/PID/schedstat\n */\nstatic int proc_pid_schedstat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t      struct pid *pid, struct task_struct *task)\n{\n\tif (unlikely(!sched_info_on()))\n\t\tseq_printf(m, \"0 0 0\\n\");\n\telse\n\t\tseq_printf(m, \"%llu %llu %lu\\n\",\n\t\t   (unsigned long long)task->se.sum_exec_runtime,\n\t\t   (unsigned long long)task->sched_info.run_delay,\n\t\t   task->sched_info.pcount);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic int proc_oom_score(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long totalpages = totalram_pages + total_swap_pages;\n\tunsigned long points = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (pid_alive(task))\n\t\tpoints = oom_badness(task, NULL, NULL, totalpages) *\n\t\t\t\t\t\t1000 / totalpages;\n\tread_unlock(&tasklist_lock);\n\tseq_printf(m, \"%lu\\n\", points);\n\n\treturn 0;\n}\n\nstruct limit_names {\n\tconst char *name;\n\tconst char *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n/* Display limits for a process */\nstatic int proc_pid_limits(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n       seq_printf(m, \"%-25s %-20s %-20s %-10s\\n\",\n\t\t  \"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-25s %-20s \",\n\t\t\t\t   lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-25s %-20lu \",\n\t\t\t\t   lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-20lu \", rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tseq_printf(m, \"%-10s\\n\", lnames[i].unit);\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\tint res;\n\n\tres = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\tseq_puts(m, \"running\\n\");\n\telse if (nr < 0)\n\t\tseq_printf(m, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\telse\n\t\tseq_printf(m,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n\tunlock_trace(task);\n\n\treturn 0;\n}\n#endif /* CONFIG_HAVE_ARCH_TRACEHOOK */\n\n/************************************************************************/\n/*                       Here the fs part begins                        */\n/************************************************************************/\n\n/* permission checks */\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nint proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\n/*\n * May current process learn task's sched/cmdline info (for hide_pid_min=1)\n * or euid/egid (for hide_pid_min=2)?\n */\nstatic bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n}\n\n\nstatic int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode | PTRACE_MODE_FSCREDS);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}\n\nstatic int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}\n\nstatic int mem_open(struct inode *inode, struct file *file)\n{\n\tint ret = __mem_open(inode, file, PTRACE_MODE_ATTACH);\n\n\t/* OK to pass negative loff_t, we can catch out-of-range */\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\n\treturn ret;\n}\n\nstatic ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}\n\nstatic ssize_t mem_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, buf, count, ppos, 0);\n}\n\nstatic ssize_t mem_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, (char __user*)buf, count, ppos, 1);\n}\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic int mem_release(struct inode *inode, struct file *file)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tif (mm)\n\t\tmmdrop(mm);\n\treturn 0;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n\t.release\t= mem_release,\n};\n\nstatic int environ_open(struct inode *inode, struct file *file)\n{\n\treturn __mem_open(inode, file, PTRACE_MODE_READ);\n}\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.open\t\t= environ_open,\n\t.read\t\t= environ_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= mem_release,\n};\n\nstatic ssize_t oom_adj_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj = OOM_ADJUST_MIN;\n\tsize_t len;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MAX)\n\t\t\toom_adj = OOM_ADJUST_MAX;\n\t\telse\n\t\t\toom_adj = (task->signal->oom_score_adj * -OOM_DISABLE) /\n\t\t\t\t  OOM_SCORE_ADJ_MAX;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\n/*\n * /proc/pid/oom_adj exists solely for backwards compatibility with previous\n * kernels.  The effective policy is defined by oom_score_adj, which has a\n * different scale: oom_adj grew exponentially and oom_score_adj grows linearly.\n * Values written to oom_adj are simply mapped linearly to oom_score_adj.\n * Processes that become oom disabled via oom_adj will still be oom disabled\n * with this implementation.\n *\n * oom_adj cannot be removed since existing userspace binaries use it.\n */\nstatic ssize_t oom_adj_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adj);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adj < OOM_ADJUST_MIN || oom_adj > OOM_ADJUST_MAX) &&\n\t     oom_adj != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\t/*\n\t * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum\n\t * value is always attainable.\n\t */\n\tif (oom_adj == OOM_ADJUST_MAX)\n\t\toom_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\toom_adj = (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;\n\n\tif (oom_adj < task->signal->oom_score_adj &&\n\t    !capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\t/*\n\t * /proc/pid/oom_adj is provided for legacy purposes, ask users to use\n\t * /proc/pid/oom_score_adj instead.\n\t */\n\tpr_warn_once(\"%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t  current->comm, task_pid_nr(current), task_pid_nr(task),\n\t\t  task_pid_nr(task));\n\n\ttask->signal->oom_score_adj = oom_adj;\n\ttrace_oom_score_adj_update(task);\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_adj_operations = {\n\t.read\t\t= oom_adj_read,\n\t.write\t\t= oom_adj_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tshort oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tunsigned long flags;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_score_adj = task->signal->oom_score_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%hd\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif ((short)oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\ttask->signal->oom_score_adj = (short)oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = (short)oom_score_adj;\n\ttrace_oom_score_adj_update(task);\n\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_score_adj_operations = {\n\t.read\t\t= oom_score_adj_read,\n\t.write\t\t= oom_score_adj_write,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_AUDITSYSCALL\n#define TMPBUFLEN 21\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   from_kuid(file->f_cred->user_ns,\n\t\t\t\t     audit_get_loginuid(task)));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tuid_t loginuid;\n\tkuid_t kloginuid;\n\tint rv;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\n\trv = kstrtou32_from_user(buf, count, 10, &loginuid);\n\tif (rv < 0)\n\t\treturn rv;\n\n\t/* is userspace tring to explicitly UNSET the loginuid? */\n\tif (loginuid == AUDIT_UID_UNSET) {\n\t\tkloginuid = INVALID_UID;\n\t} else {\n\t\tkloginuid = make_kuid(file->f_cred->user_ns, loginuid);\n\t\tif (!uid_valid(kloginuid))\n\t\t\treturn -EINVAL;\n\t}\n\n\trv = audit_set_loginuid(kloginuid);\n\tif (rv < 0)\n\t\treturn rv;\n\treturn count;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint make_it_fail;\n\tint rv;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 0, &make_it_fail);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (make_it_fail < 0 || make_it_fail > 1)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Print out various scheduling related per-task fields:\n */\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n#ifdef CONFIG_SCHED_AUTOGROUP\n/*\n * Print out autogroup related information:\n */\nstatic int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = proc_sched_autogroup_set_nice(p, nice);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_autogroup_operations = {\n\t.open\t\t= sched_autogroup_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_autogroup_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif /* CONFIG_SCHED_AUTOGROUP */\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\tconst size_t maxlen = sizeof(buffer) - 1;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (copy_from_user(buffer, buf, count > maxlen ? maxlen : count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_exe_link(struct dentry *dentry, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(d_inode(dentry));\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic const char *proc_pid_get_link(struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct delayed_call *done)\n{\n\tstruct path path;\n\tint error = -EACCES;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\tnd_jump_link(&path);\n\treturn NULL;\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nconst struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.get_link\t= proc_pid_get_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n/* building an inode */\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\nint pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = GLOBAL_ROOT_UID;\n\tstat->gid = GLOBAL_ROOT_GID;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * This doesn't prevent learning whether PID exists,\n\t\t\t * it only makes getattr() consistent with readdir().\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n/* dentry stuff */\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n *\n * Rewrite the inode's ownerships here because the owning task may have\n * performed a setuid(), etc.\n *\n * Before the /proc/pid/status file was created the only way to read\n * the effective uid of a /process was to stat /proc/pid.  Reading\n * /proc/pid/status is slow enough that procps and other packages\n * kept stating /proc/pid.  To keep the rules in /proc simple I have\n * made this apply to all per process world readable and executable\n * directories.\n */\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}\n\nint pid_delete_dentry(const struct dentry *dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn proc_inode_is_dead(d_inode(dentry));\n}\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n/* Lookups */\n\n/*\n * Fill a directory entry.\n *\n * If possible create the dcache entry and derive our inode number and\n * file type from dcache entry.\n *\n * Since all of the proc inode numbers are dynamically generated, the inode\n * numbers do not exist until the inode is cache.  This means creating the\n * the dcache entry in readdir is necessary to keep the inode numbers\n * reported by readdir in sync with the inode numbers reported\n * by stat.\n */\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(d_inode(dir), child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = d_inode(child);\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}\n\n/*\n * dname_to_vma_addr - maps a dentry name into two unsigned longs\n * which represent vma start and end addresses.\n */\nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tbool exact_vma_exists = false;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint status = 0;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_notask;\n\n\tmm = mm_access(task, PTRACE_MODE_READ_FSCREDS);\n\tif (IS_ERR_OR_NULL(mm))\n\t\tgoto out;\n\n\tif (!dname_to_vma_addr(dentry, &vm_start, &vm_end)) {\n\t\tdown_read(&mm->mmap_sem);\n\t\texact_vma_exists = !!find_exact_vma(mm, vm_start, vm_end);\n\t\tup_read(&mm->mmap_sem);\n\t}\n\n\tmmput(mm);\n\n\tif (exact_vma_exists) {\n\t\tif (task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tsecurity_task_to_inode(task, inode);\n\t\tstatus = 1;\n\t}\n\nout:\n\tput_task_struct(task);\n\nout_notask:\n\treturn status;\n}\n\nstatic const struct dentry_operations tid_map_files_dentry_operations = {\n\t.d_revalidate\t= map_files_d_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int map_files_get_link(struct dentry *dentry, struct path *path)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint rc;\n\n\trc = -ENOENT;\n\ttask = get_proc_task(d_inode(dentry));\n\tif (!task)\n\t\tgoto out;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\tgoto out;\n\n\trc = dname_to_vma_addr(dentry, &vm_start, &vm_end);\n\tif (rc)\n\t\tgoto out_mmput;\n\n\trc = -ENOENT;\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (vma && vma->vm_file) {\n\t\t*path = vma->vm_file->f_path;\n\t\tpath_get(path);\n\t\trc = 0;\n\t}\n\tup_read(&mm->mmap_sem);\n\nout_mmput:\n\tmmput(mm);\nout:\n\treturn rc;\n}\n\nstruct map_files_info {\n\tfmode_t\t\tmode;\n\tunsigned long\tlen;\n\tunsigned char\tname[4*sizeof(long)+2]; /* max: %lx-%lx\\0 */\n};\n\n/*\n * Only allow CAP_SYS_ADMIN to follow the links, due to concerns about how the\n * symlinks may be used to bypass permissions on ancestor directories in the\n * path to the file in question.\n */\nstatic const char *\nproc_map_files_get_link(struct dentry *dentry,\n\t\t\tstruct inode *inode,\n\t\t        struct delayed_call *done)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn proc_pid_get_link(dentry, inode, done);\n}\n\n/*\n * Identical to proc_pid_link_inode_operations except for get_link()\n */\nstatic const struct inode_operations proc_map_files_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.get_link\t= proc_map_files_get_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = map_files_get_link;\n\n\tinode->i_op = &proc_map_files_link_inode_operations;\n\tinode->i_size = 64;\n\tinode->i_mode = S_IFLNK;\n\n\tif (mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR;\n\tif (mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\td_add(dentry, inode);\n\n\treturn 0;\n}\n\nstatic struct dentry *proc_map_files_lookup(struct inode *dir,\n\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tint result;\n\tstruct mm_struct *mm;\n\n\tresult = -ENOENT;\n\ttask = get_proc_task(dir);\n\tif (!task)\n\t\tgoto out;\n\n\tresult = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out_put_task;\n\n\tresult = -ENOENT;\n\tif (dname_to_vma_addr(dentry, &vm_start, &vm_end))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (!vma)\n\t\tgoto out_no_vma;\n\n\tif (vma->vm_file)\n\t\tresult = proc_map_files_instantiate(dir, dentry, task,\n\t\t\t\t(void *)(unsigned long)vma->vm_file->f_mode);\n\nout_no_vma:\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}\n\nstatic const struct inode_operations proc_map_files_inode_operations = {\n\t.lookup\t\t= proc_map_files_lookup,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned long nr_files, pos, i;\n\tstruct flex_array *fa = NULL;\n\tstruct map_files_info info;\n\tstruct map_files_info *p;\n\tint ret;\n\n\tret = -ENOENT;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out_put_task;\n\n\tret = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\tdown_read(&mm->mmap_sem);\n\n\tnr_files = 0;\n\n\t/*\n\t * We need two passes here:\n\t *\n\t *  1) Collect vmas of mapped files with mmap_sem taken\n\t *  2) Release mmap_sem and instantiate entries\n\t *\n\t * otherwise we get lockdep complained, since filldir()\n\t * routine might require mmap_sem taken in might_fault().\n\t */\n\n\tfor (vma = mm->mmap, pos = 2; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_file && ++pos > ctx->pos)\n\t\t\tnr_files++;\n\t}\n\n\tif (nr_files) {\n\t\tfa = flex_array_alloc(sizeof(info), nr_files,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!fa || flex_array_prealloc(fa, 0, nr_files,\n\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tif (fa)\n\t\t\t\tflex_array_free(fa);\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\tmmput(mm);\n\t\t\tgoto out_put_task;\n\t\t}\n\t\tfor (i = 0, vma = mm->mmap, pos = 2; vma;\n\t\t\t\tvma = vma->vm_next) {\n\t\t\tif (!vma->vm_file)\n\t\t\t\tcontinue;\n\t\t\tif (++pos <= ctx->pos)\n\t\t\t\tcontinue;\n\n\t\t\tinfo.mode = vma->vm_file->f_mode;\n\t\t\tinfo.len = snprintf(info.name,\n\t\t\t\t\tsizeof(info.name), \"%lx-%lx\",\n\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (flex_array_put(fa, i++, &info, GFP_KERNEL))\n\t\t\t\tBUG();\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_files; i++) {\n\t\tp = flex_array_get(fa, i);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t      p->name, p->len,\n\t\t\t\t      proc_map_files_instantiate,\n\t\t\t\t      task,\n\t\t\t\t      (void *)(unsigned long)p->mode))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\tif (fa)\n\t\tflex_array_free(fa);\n\tmmput(mm);\n\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_map_files_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_map_files_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstruct timers_private {\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tstruct sighand_struct *sighand;\n\tstruct pid_namespace *ns;\n\tunsigned long flags;\n};\n\nstatic void *timers_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\n\ttp->task = get_pid_task(tp->pid, PIDTYPE_PID);\n\tif (!tp->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\ttp->sighand = lock_task_sighand(tp->task, &tp->flags);\n\tif (!tp->sighand)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn seq_list_start(&tp->task->signal->posix_timers, *pos);\n}\n\nstatic void *timers_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\treturn seq_list_next(v, &tp->task->signal->posix_timers, pos);\n}\n\nstatic void timers_stop(struct seq_file *m, void *v)\n{\n\tstruct timers_private *tp = m->private;\n\n\tif (tp->sighand) {\n\t\tunlock_task_sighand(tp->task, &tp->flags);\n\t\ttp->sighand = NULL;\n\t}\n\n\tif (tp->task) {\n\t\tput_task_struct(tp->task);\n\t\ttp->task = NULL;\n\t}\n}\n\nstatic int show_timer(struct seq_file *m, void *v)\n{\n\tstruct k_itimer *timer;\n\tstruct timers_private *tp = m->private;\n\tint notify;\n\tstatic const char * const nstr[] = {\n\t\t[SIGEV_SIGNAL] = \"signal\",\n\t\t[SIGEV_NONE] = \"none\",\n\t\t[SIGEV_THREAD] = \"thread\",\n\t};\n\n\ttimer = list_entry((struct list_head *)v, struct k_itimer, list);\n\tnotify = timer->it_sigev_notify;\n\n\tseq_printf(m, \"ID: %d\\n\", timer->it_id);\n\tseq_printf(m, \"signal: %d/%p\\n\",\n\t\t   timer->sigq->info.si_signo,\n\t\t   timer->sigq->info.si_value.sival_ptr);\n\tseq_printf(m, \"notify: %s/%s.%d\\n\",\n\t\t   nstr[notify & ~SIGEV_THREAD_ID],\n\t\t   (notify & SIGEV_THREAD_ID) ? \"tid\" : \"pid\",\n\t\t   pid_nr_ns(timer->it_pid, tp->ns));\n\tseq_printf(m, \"ClockID: %d\\n\", timer->it_clock);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations proc_timers_seq_ops = {\n\t.start\t= timers_start,\n\t.next\t= timers_next,\n\t.stop\t= timers_stop,\n\t.show\t= show_timer,\n};\n\nstatic int proc_timers_open(struct inode *inode, struct file *file)\n{\n\tstruct timers_private *tp;\n\n\ttp = __seq_open_private(file, &proc_timers_seq_ops,\n\t\t\tsizeof(struct timers_private));\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->pid = proc_pid(inode);\n\ttp->ns = inode->i_sb->s_fs_info;\n\treturn 0;\n}\n\nstatic const struct file_operations proc_timers_operations = {\n\t.open\t\t= proc_timers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_private,\n};\n#endif\n\nstatic ssize_t timerslack_ns_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tu64 slack_ns;\n\tint err;\n\n\terr = kstrtoull_from_user(buf, count, 10, &slack_ns);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (ptrace_may_access(p, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\ttask_lock(p);\n\t\tif (slack_ns == 0)\n\t\t\tp->timer_slack_ns = p->default_timer_slack_ns;\n\t\telse\n\t\t\tp->timer_slack_ns = slack_ns;\n\t\ttask_unlock(p);\n\t} else\n\t\tcount = -EPERM;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int timerslack_ns_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\tint err =  0;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (ptrace_may_access(p, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\ttask_lock(p);\n\t\tseq_printf(m, \"%llu\\n\", p->timer_slack_ns);\n\t\ttask_unlock(p);\n\t} else\n\t\terr = -EPERM;\n\n\tput_task_struct(p);\n\n\treturn err;\n}\n\nstatic int timerslack_ns_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, timerslack_ns_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_timerslack_ns_operations = {\n\t.open\t\t= timerslack_ns_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= timerslack_ns_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}\n\n#ifdef CONFIG_SECURITY\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tvoid *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tkfree(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tREG(\"current\",    S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"prev\",       S_IRUGO,\t   proc_pid_attr_operations),\n\tREG(\"exec\",       S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"fscreate\",   S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"keycreate\",  S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"sockcreate\", S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n};\n\nstatic int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx, \n\t\t\t\t   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_attr_dir_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = kstrtouint_from_user(buf, count, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\tret = 0;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tseq_printf(m,\n\t\t   \"rchar: %llu\\n\"\n\t\t   \"wchar: %llu\\n\"\n\t\t   \"syscr: %llu\\n\"\n\t\t   \"syscw: %llu\\n\"\n\t\t   \"read_bytes: %llu\\n\"\n\t\t   \"write_bytes: %llu\\n\"\n\t\t   \"cancelled_write_bytes: %llu\\n\",\n\t\t   (unsigned long long)acct.rchar,\n\t\t   (unsigned long long)acct.wchar,\n\t\t   (unsigned long long)acct.syscr,\n\t\t   (unsigned long long)acct.syscw,\n\t\t   (unsigned long long)acct.read_bytes,\n\t\t   (unsigned long long)acct.write_bytes,\n\t\t   (unsigned long long)acct.cancelled_write_bytes);\n\tresult = 0;\n\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}\n\nstatic int proc_tid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 1);\n}\n#endif /* CONFIG_TASK_IO_ACCOUNTING */\n\n#ifdef CONFIG_USER_NS\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}\n\nstatic int proc_id_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tput_user_ns(ns);\n\treturn seq_release(inode, file);\n}\n\nstatic int proc_uid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_uid_seq_operations);\n}\n\nstatic int proc_gid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_gid_seq_operations);\n}\n\nstatic int proc_projid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_projid_seq_operations);\n}\n\nstatic const struct file_operations proc_uid_map_operations = {\n\t.open\t\t= proc_uid_map_open,\n\t.write\t\t= proc_uid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic const struct file_operations proc_gid_map_operations = {\n\t.open\t\t= proc_gid_map_open,\n\t.write\t\t= proc_gid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic const struct file_operations proc_projid_map_operations = {\n\t.open\t\t= proc_projid_map_open,\n\t.write\t\t= proc_projid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic int proc_setgroups_open(struct inode *inode, struct file *file)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = -EACCES;\n\t\tif (!ns_capable(ns, CAP_SYS_ADMIN))\n\t\t\tgoto err_put_ns;\n\t}\n\n\tret = single_open(file, &proc_setgroups_show, ns);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}\n\nstatic int proc_setgroups_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tint ret = single_release(inode, file);\n\tput_user_ns(ns);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_setgroups_operations = {\n\t.open\t\t= proc_setgroups_open,\n\t.write\t\t= proc_setgroups_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_setgroups_release,\n};\n#endif /* CONFIG_USER_NS */\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}\n\n/*\n * Thread groups\n */\nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tREG(\"cmdline\",    S_IRUGO, proc_pid_cmdline_ops),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHED_INFO\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n\tREG(\"timerslack_ns\", S_IRUGO|S_IWUGO, proc_pid_set_timerslack_ns_operations),\n};\n\nstatic int proc_tgid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\t/* no ->d_hash() rejects on procfs */\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tif (pid == tgid)\n\t\treturn;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}\n\n/**\n * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.\n * @task: task that should be flushed.\n *\n * When flushing dentries from proc, one needs to flush them from global\n * proc (proc_mnt) and from all the namespaces' procs this task was seen\n * in. This call is supposed to do all of this job.\n *\n * Looks in the dcache for\n * /proc/@pid\n * /proc/@tgid/task/@pid\n * if either directory is present flushes it and all of it'ts children\n * from the dcache.\n *\n * It is safe and reasonable to cache /proc entries for a task until\n * that task exits.  After that they just clog up the dcache with\n * useless entries, possibly causing useful dcache entries to be\n * flushed instead.  This routine is proved to flush those useless\n * dcache entries at process exit time.\n *\n * NOTE: This routine is just an optimization so it does not guarantee\n *       that no dcache entries will exist at process exit time it\n *       just makes it very unlikely that any will persist.\n */\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n}\n\nstatic int proc_pid_instantiate(struct inode *dir,\n\t\t\t\t   struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}\n\n/*\n * Find the first task with tgid >= tgid\n *\n */\nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)\n\n/* for the /proc/ directory itself, after non-process stuff has been done */\nint proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = d_inode(ns->proc_self);\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = d_inode(ns->proc_thread_self);\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\tif (!has_pid_permissions(ns, iter.task, 2))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}\n\n/*\n * Tasks\n */\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tREG(\"cmdline\",   S_IRUGO, proc_pid_cmdline_ops),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_PROC_CHILDREN\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHED_INFO\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(&dentry->d_name);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn ERR_PTR(result);\n}\n\n/*\n * Find the first tid of a thread group to return to user space.\n *\n * Usually this is just the thread group leader, but if the users\n * buffer was too small or there was a seek into the middle of the\n * directory we have more work todo.\n *\n * In the case of a short read we start with find_task_by_pid.\n *\n * In the case of a seek we start with the leader and walk nr\n * threads past it.\n */\nstatic struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t/* 32bit overflow? */\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t/* Attempt to start with the tid of a thread */\n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tpos = task = task->group_leader;\n\tdo {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t} while_each_thread(task, pos);\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n/*\n * Find the next thread in the thread list.\n * Return NULL if there is an error or no next thread.\n *\n * The reference to the input task_struct is released.\n */\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\n/* for the /proc/TGID/task/ directories */\nstatic int proc_task_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *task;\n\tstruct pid_namespace *ns;\n\tint tid;\n\n\tif (proc_inode_is_dead(inode))\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = inode->i_sb->s_fs_info;\n\ttid = (int)file->f_version;\n\tfile->f_version = 0;\n\tfor (task = first_tid(proc_pid(inode), tid, ctx->pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tlen = snprintf(name, sizeof(name), \"%d\", tid);\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL)) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfile->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_task_readdir,\n\t.llseek\t\t= default_llseek,\n};\n"], "fixing_code": ["/*\n *  linux/fs/proc/base.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc base directory handling functions\n *\n *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.\n *  Instead of using magical inumbers to determine the kind of object\n *  we allocate and fill in-core inodes upon lookup. They don't even\n *  go into icache. We cache the reference to task_struct upon lookup too.\n *  Eventually it should become a filesystem in its own. We don't use the\n *  rest of procfs anymore.\n *\n *\n *  Changelog:\n *  17-Jan-2005\n *  Allan Bezerra\n *  Bruna Moreira <bruna.moreira@indt.org.br>\n *  Edjard Mota <edjard.mota@indt.org.br>\n *  Ilias Biris <ilias.biris@indt.org.br>\n *  Mauricio Lin <mauricio.lin@indt.org.br>\n *\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *\n *  A new process specific entry (smaps) included in /proc. It shows the\n *  size of rss for each memory area. The maps entry lacks information\n *  about physical memory size (rss) for each mapped file, i.e.,\n *  rss information for executables and library files.\n *  This additional information is useful for any tools that need to know\n *  about physical memory consumption for a process specific library.\n *\n *  Changelog:\n *  21-Feb-2005\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *  Pud inclusion in the page table walking.\n *\n *  ChangeLog:\n *  10-Mar-2005\n *  10LE Instituto Nokia de Tecnologia - INdT:\n *  A better way to walks through the page table as suggested by Hugh Dickins.\n *\n *  Simo Piiroinen <simo.piiroinen@nokia.com>:\n *  Smaps information related to shared, private, clean and dirty pages.\n *\n *  Paul Mundt <paul.mundt@nokia.com>:\n *  Overall revision about smaps.\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/tracehook.h>\n#include <linux/printk.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/flex_array.h>\n#include <linux/posix-timers.h>\n#ifdef CONFIG_HARDWALL\n#include <asm/hardwall.h>\n#endif\n#include <trace/events/oom.h>\n#include \"internal.h\"\n#include \"fd.h\"\n\n/* NOTE:\n *\tImplementing inode permission operations in /proc is almost\n *\tcertainly an error.  Permission checks need to happen during\n *\teach system call not at open time.  The reason is that most of\n *\twhat we wish to check for permissions in /proc varies at runtime.\n *\n *\tThe classic example of a problem is opening file descriptors\n *\tin /proc for a task before it execs a suid executable.\n */\n\nstruct pid_entry {\n\tconst char *name;\n\tint len;\n\tumode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n\n/*\n * Count the number of hardlinks for the pid_entry table, excluding the .\n * and .. links.\n */\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and maybe\n\t\t * extends into ENVP.\n\t\t */\n\t\tif (len1 + len2 <= *pos)\n\t\t\tgoto skip_argv_envp;\n\t\tif (len1 <= *pos)\n\t\t\tgoto skip_argv;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count, l;\n\t\t\tint nr_read;\n\t\t\tbool final;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\t/*\n\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t */\n\t\t\tfinal = false;\n\t\t\tl = strnlen(page, nr_read);\n\t\t\tif (l < nr_read) {\n\t\t\t\tnr_read = l;\n\t\t\t\tfinal = true;\n\t\t\t}\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\n\t\t\tif (final)\n\t\t\t\tgoto out_free_page;\n\t\t}\nskip_argv:\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tif (len1 <= *pos) {\n\t\t\tp = env_start + *pos - len1;\n\t\t\tlen = len1 + len2 - *pos;\n\t\t} else {\n\t\t\tp = env_start;\n\t\t\tlen = len2;\n\t\t}\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count, l;\n\t\t\tint nr_read;\n\t\t\tbool final;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\t/* Find EOS. */\n\t\t\tfinal = false;\n\t\t\tl = strnlen(page, nr_read);\n\t\t\tif (l < nr_read) {\n\t\t\t\tnr_read = l;\n\t\t\t\tfinal = true;\n\t\t\t}\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\n\t\t\tif (final)\n\t\t\t\tgoto out_free_page;\n\t\t}\nskip_argv_envp:\n\t\t;\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}\n\nstatic const struct file_operations proc_pid_cmdline_ops = {\n\t.read\t= proc_pid_cmdline_read,\n\t.llseek\t= generic_file_llseek,\n};\n\nstatic int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t struct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);\n\tif (mm && !IS_ERR(mm)) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tseq_write(m, mm->saved_auxv, nwords * sizeof(mm->saved_auxv[0]));\n\t\tmmput(mm);\n\t\treturn 0;\n\t} else\n\t\treturn PTR_ERR(mm);\n}\n\n\n#ifdef CONFIG_KALLSYMS\n/*\n * Provides a wchan file via kallsyms in a proper one-value-per-file format.\n * Returns the resolved symbol.  If that fails, simply return the address.\n */\nstatic int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (wchan && ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)\n\t\t\t&& !lookup_symbol_name(wchan, symname))\n\t\tseq_printf(m, \"%s\", symname);\n\telse\n\t\tseq_puts(m, \"0\\n\");\n\n\treturn 0;\n}\n#endif /* CONFIG_KALLSYMS */\n\nstatic int lock_trace(struct task_struct *task)\n{\n\tint err = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint err;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tsave_stack_trace_tsk(task, &trace);\n\n\t\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<%pK>] %pS\\n\",\n\t\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t\t}\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_SCHED_INFO\n/*\n * Provides /proc/PID/schedstat\n */\nstatic int proc_pid_schedstat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t      struct pid *pid, struct task_struct *task)\n{\n\tif (unlikely(!sched_info_on()))\n\t\tseq_printf(m, \"0 0 0\\n\");\n\telse\n\t\tseq_printf(m, \"%llu %llu %lu\\n\",\n\t\t   (unsigned long long)task->se.sum_exec_runtime,\n\t\t   (unsigned long long)task->sched_info.run_delay,\n\t\t   task->sched_info.pcount);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic int proc_oom_score(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long totalpages = totalram_pages + total_swap_pages;\n\tunsigned long points = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (pid_alive(task))\n\t\tpoints = oom_badness(task, NULL, NULL, totalpages) *\n\t\t\t\t\t\t1000 / totalpages;\n\tread_unlock(&tasklist_lock);\n\tseq_printf(m, \"%lu\\n\", points);\n\n\treturn 0;\n}\n\nstruct limit_names {\n\tconst char *name;\n\tconst char *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n/* Display limits for a process */\nstatic int proc_pid_limits(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n       seq_printf(m, \"%-25s %-20s %-20s %-10s\\n\",\n\t\t  \"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-25s %-20s \",\n\t\t\t\t   lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-25s %-20lu \",\n\t\t\t\t   lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-20lu \", rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tseq_printf(m, \"%-10s\\n\", lnames[i].unit);\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\tint res;\n\n\tres = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\tseq_puts(m, \"running\\n\");\n\telse if (nr < 0)\n\t\tseq_printf(m, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\telse\n\t\tseq_printf(m,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n\tunlock_trace(task);\n\n\treturn 0;\n}\n#endif /* CONFIG_HAVE_ARCH_TRACEHOOK */\n\n/************************************************************************/\n/*                       Here the fs part begins                        */\n/************************************************************************/\n\n/* permission checks */\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nint proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\n/*\n * May current process learn task's sched/cmdline info (for hide_pid_min=1)\n * or euid/egid (for hide_pid_min=2)?\n */\nstatic bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n}\n\n\nstatic int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode | PTRACE_MODE_FSCREDS);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}\n\nstatic int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}\n\nstatic int mem_open(struct inode *inode, struct file *file)\n{\n\tint ret = __mem_open(inode, file, PTRACE_MODE_ATTACH);\n\n\t/* OK to pass negative loff_t, we can catch out-of-range */\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\n\treturn ret;\n}\n\nstatic ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}\n\nstatic ssize_t mem_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, buf, count, ppos, 0);\n}\n\nstatic ssize_t mem_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, (char __user*)buf, count, ppos, 1);\n}\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic int mem_release(struct inode *inode, struct file *file)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tif (mm)\n\t\tmmdrop(mm);\n\treturn 0;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n\t.release\t= mem_release,\n};\n\nstatic int environ_open(struct inode *inode, struct file *file)\n{\n\treturn __mem_open(inode, file, PTRACE_MODE_READ);\n}\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\t/* Ensure the process spawned far enough to have an environment. */\n\tif (!mm || !mm->env_end)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.open\t\t= environ_open,\n\t.read\t\t= environ_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= mem_release,\n};\n\nstatic ssize_t oom_adj_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj = OOM_ADJUST_MIN;\n\tsize_t len;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MAX)\n\t\t\toom_adj = OOM_ADJUST_MAX;\n\t\telse\n\t\t\toom_adj = (task->signal->oom_score_adj * -OOM_DISABLE) /\n\t\t\t\t  OOM_SCORE_ADJ_MAX;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\n/*\n * /proc/pid/oom_adj exists solely for backwards compatibility with previous\n * kernels.  The effective policy is defined by oom_score_adj, which has a\n * different scale: oom_adj grew exponentially and oom_score_adj grows linearly.\n * Values written to oom_adj are simply mapped linearly to oom_score_adj.\n * Processes that become oom disabled via oom_adj will still be oom disabled\n * with this implementation.\n *\n * oom_adj cannot be removed since existing userspace binaries use it.\n */\nstatic ssize_t oom_adj_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adj);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adj < OOM_ADJUST_MIN || oom_adj > OOM_ADJUST_MAX) &&\n\t     oom_adj != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\t/*\n\t * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum\n\t * value is always attainable.\n\t */\n\tif (oom_adj == OOM_ADJUST_MAX)\n\t\toom_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\toom_adj = (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;\n\n\tif (oom_adj < task->signal->oom_score_adj &&\n\t    !capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\t/*\n\t * /proc/pid/oom_adj is provided for legacy purposes, ask users to use\n\t * /proc/pid/oom_score_adj instead.\n\t */\n\tpr_warn_once(\"%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t  current->comm, task_pid_nr(current), task_pid_nr(task),\n\t\t  task_pid_nr(task));\n\n\ttask->signal->oom_score_adj = oom_adj;\n\ttrace_oom_score_adj_update(task);\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_adj_operations = {\n\t.read\t\t= oom_adj_read,\n\t.write\t\t= oom_adj_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tshort oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tunsigned long flags;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_score_adj = task->signal->oom_score_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%hd\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif ((short)oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\ttask->signal->oom_score_adj = (short)oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = (short)oom_score_adj;\n\ttrace_oom_score_adj_update(task);\n\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_score_adj_operations = {\n\t.read\t\t= oom_score_adj_read,\n\t.write\t\t= oom_score_adj_write,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_AUDITSYSCALL\n#define TMPBUFLEN 21\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   from_kuid(file->f_cred->user_ns,\n\t\t\t\t     audit_get_loginuid(task)));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tuid_t loginuid;\n\tkuid_t kloginuid;\n\tint rv;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\n\trv = kstrtou32_from_user(buf, count, 10, &loginuid);\n\tif (rv < 0)\n\t\treturn rv;\n\n\t/* is userspace tring to explicitly UNSET the loginuid? */\n\tif (loginuid == AUDIT_UID_UNSET) {\n\t\tkloginuid = INVALID_UID;\n\t} else {\n\t\tkloginuid = make_kuid(file->f_cred->user_ns, loginuid);\n\t\tif (!uid_valid(kloginuid))\n\t\t\treturn -EINVAL;\n\t}\n\n\trv = audit_set_loginuid(kloginuid);\n\tif (rv < 0)\n\t\treturn rv;\n\treturn count;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint make_it_fail;\n\tint rv;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 0, &make_it_fail);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (make_it_fail < 0 || make_it_fail > 1)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Print out various scheduling related per-task fields:\n */\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n#ifdef CONFIG_SCHED_AUTOGROUP\n/*\n * Print out autogroup related information:\n */\nstatic int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = proc_sched_autogroup_set_nice(p, nice);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_autogroup_operations = {\n\t.open\t\t= sched_autogroup_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_autogroup_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif /* CONFIG_SCHED_AUTOGROUP */\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\tconst size_t maxlen = sizeof(buffer) - 1;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (copy_from_user(buffer, buf, count > maxlen ? maxlen : count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_exe_link(struct dentry *dentry, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(d_inode(dentry));\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic const char *proc_pid_get_link(struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct delayed_call *done)\n{\n\tstruct path path;\n\tint error = -EACCES;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\tnd_jump_link(&path);\n\treturn NULL;\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nconst struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.get_link\t= proc_pid_get_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n/* building an inode */\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\nint pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = GLOBAL_ROOT_UID;\n\tstat->gid = GLOBAL_ROOT_GID;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * This doesn't prevent learning whether PID exists,\n\t\t\t * it only makes getattr() consistent with readdir().\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n/* dentry stuff */\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n *\n * Rewrite the inode's ownerships here because the owning task may have\n * performed a setuid(), etc.\n *\n * Before the /proc/pid/status file was created the only way to read\n * the effective uid of a /process was to stat /proc/pid.  Reading\n * /proc/pid/status is slow enough that procps and other packages\n * kept stating /proc/pid.  To keep the rules in /proc simple I have\n * made this apply to all per process world readable and executable\n * directories.\n */\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}\n\nint pid_delete_dentry(const struct dentry *dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn proc_inode_is_dead(d_inode(dentry));\n}\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n/* Lookups */\n\n/*\n * Fill a directory entry.\n *\n * If possible create the dcache entry and derive our inode number and\n * file type from dcache entry.\n *\n * Since all of the proc inode numbers are dynamically generated, the inode\n * numbers do not exist until the inode is cache.  This means creating the\n * the dcache entry in readdir is necessary to keep the inode numbers\n * reported by readdir in sync with the inode numbers reported\n * by stat.\n */\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(d_inode(dir), child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = d_inode(child);\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}\n\n/*\n * dname_to_vma_addr - maps a dentry name into two unsigned longs\n * which represent vma start and end addresses.\n */\nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tbool exact_vma_exists = false;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint status = 0;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_notask;\n\n\tmm = mm_access(task, PTRACE_MODE_READ_FSCREDS);\n\tif (IS_ERR_OR_NULL(mm))\n\t\tgoto out;\n\n\tif (!dname_to_vma_addr(dentry, &vm_start, &vm_end)) {\n\t\tdown_read(&mm->mmap_sem);\n\t\texact_vma_exists = !!find_exact_vma(mm, vm_start, vm_end);\n\t\tup_read(&mm->mmap_sem);\n\t}\n\n\tmmput(mm);\n\n\tif (exact_vma_exists) {\n\t\tif (task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tsecurity_task_to_inode(task, inode);\n\t\tstatus = 1;\n\t}\n\nout:\n\tput_task_struct(task);\n\nout_notask:\n\treturn status;\n}\n\nstatic const struct dentry_operations tid_map_files_dentry_operations = {\n\t.d_revalidate\t= map_files_d_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int map_files_get_link(struct dentry *dentry, struct path *path)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint rc;\n\n\trc = -ENOENT;\n\ttask = get_proc_task(d_inode(dentry));\n\tif (!task)\n\t\tgoto out;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\tgoto out;\n\n\trc = dname_to_vma_addr(dentry, &vm_start, &vm_end);\n\tif (rc)\n\t\tgoto out_mmput;\n\n\trc = -ENOENT;\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (vma && vma->vm_file) {\n\t\t*path = vma->vm_file->f_path;\n\t\tpath_get(path);\n\t\trc = 0;\n\t}\n\tup_read(&mm->mmap_sem);\n\nout_mmput:\n\tmmput(mm);\nout:\n\treturn rc;\n}\n\nstruct map_files_info {\n\tfmode_t\t\tmode;\n\tunsigned long\tlen;\n\tunsigned char\tname[4*sizeof(long)+2]; /* max: %lx-%lx\\0 */\n};\n\n/*\n * Only allow CAP_SYS_ADMIN to follow the links, due to concerns about how the\n * symlinks may be used to bypass permissions on ancestor directories in the\n * path to the file in question.\n */\nstatic const char *\nproc_map_files_get_link(struct dentry *dentry,\n\t\t\tstruct inode *inode,\n\t\t        struct delayed_call *done)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn proc_pid_get_link(dentry, inode, done);\n}\n\n/*\n * Identical to proc_pid_link_inode_operations except for get_link()\n */\nstatic const struct inode_operations proc_map_files_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.get_link\t= proc_map_files_get_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = map_files_get_link;\n\n\tinode->i_op = &proc_map_files_link_inode_operations;\n\tinode->i_size = 64;\n\tinode->i_mode = S_IFLNK;\n\n\tif (mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR;\n\tif (mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\td_add(dentry, inode);\n\n\treturn 0;\n}\n\nstatic struct dentry *proc_map_files_lookup(struct inode *dir,\n\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tint result;\n\tstruct mm_struct *mm;\n\n\tresult = -ENOENT;\n\ttask = get_proc_task(dir);\n\tif (!task)\n\t\tgoto out;\n\n\tresult = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out_put_task;\n\n\tresult = -ENOENT;\n\tif (dname_to_vma_addr(dentry, &vm_start, &vm_end))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (!vma)\n\t\tgoto out_no_vma;\n\n\tif (vma->vm_file)\n\t\tresult = proc_map_files_instantiate(dir, dentry, task,\n\t\t\t\t(void *)(unsigned long)vma->vm_file->f_mode);\n\nout_no_vma:\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}\n\nstatic const struct inode_operations proc_map_files_inode_operations = {\n\t.lookup\t\t= proc_map_files_lookup,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned long nr_files, pos, i;\n\tstruct flex_array *fa = NULL;\n\tstruct map_files_info info;\n\tstruct map_files_info *p;\n\tint ret;\n\n\tret = -ENOENT;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out_put_task;\n\n\tret = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\tdown_read(&mm->mmap_sem);\n\n\tnr_files = 0;\n\n\t/*\n\t * We need two passes here:\n\t *\n\t *  1) Collect vmas of mapped files with mmap_sem taken\n\t *  2) Release mmap_sem and instantiate entries\n\t *\n\t * otherwise we get lockdep complained, since filldir()\n\t * routine might require mmap_sem taken in might_fault().\n\t */\n\n\tfor (vma = mm->mmap, pos = 2; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_file && ++pos > ctx->pos)\n\t\t\tnr_files++;\n\t}\n\n\tif (nr_files) {\n\t\tfa = flex_array_alloc(sizeof(info), nr_files,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!fa || flex_array_prealloc(fa, 0, nr_files,\n\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tif (fa)\n\t\t\t\tflex_array_free(fa);\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\tmmput(mm);\n\t\t\tgoto out_put_task;\n\t\t}\n\t\tfor (i = 0, vma = mm->mmap, pos = 2; vma;\n\t\t\t\tvma = vma->vm_next) {\n\t\t\tif (!vma->vm_file)\n\t\t\t\tcontinue;\n\t\t\tif (++pos <= ctx->pos)\n\t\t\t\tcontinue;\n\n\t\t\tinfo.mode = vma->vm_file->f_mode;\n\t\t\tinfo.len = snprintf(info.name,\n\t\t\t\t\tsizeof(info.name), \"%lx-%lx\",\n\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (flex_array_put(fa, i++, &info, GFP_KERNEL))\n\t\t\t\tBUG();\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_files; i++) {\n\t\tp = flex_array_get(fa, i);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t      p->name, p->len,\n\t\t\t\t      proc_map_files_instantiate,\n\t\t\t\t      task,\n\t\t\t\t      (void *)(unsigned long)p->mode))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\tif (fa)\n\t\tflex_array_free(fa);\n\tmmput(mm);\n\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_map_files_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_map_files_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstruct timers_private {\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tstruct sighand_struct *sighand;\n\tstruct pid_namespace *ns;\n\tunsigned long flags;\n};\n\nstatic void *timers_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\n\ttp->task = get_pid_task(tp->pid, PIDTYPE_PID);\n\tif (!tp->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\ttp->sighand = lock_task_sighand(tp->task, &tp->flags);\n\tif (!tp->sighand)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn seq_list_start(&tp->task->signal->posix_timers, *pos);\n}\n\nstatic void *timers_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\treturn seq_list_next(v, &tp->task->signal->posix_timers, pos);\n}\n\nstatic void timers_stop(struct seq_file *m, void *v)\n{\n\tstruct timers_private *tp = m->private;\n\n\tif (tp->sighand) {\n\t\tunlock_task_sighand(tp->task, &tp->flags);\n\t\ttp->sighand = NULL;\n\t}\n\n\tif (tp->task) {\n\t\tput_task_struct(tp->task);\n\t\ttp->task = NULL;\n\t}\n}\n\nstatic int show_timer(struct seq_file *m, void *v)\n{\n\tstruct k_itimer *timer;\n\tstruct timers_private *tp = m->private;\n\tint notify;\n\tstatic const char * const nstr[] = {\n\t\t[SIGEV_SIGNAL] = \"signal\",\n\t\t[SIGEV_NONE] = \"none\",\n\t\t[SIGEV_THREAD] = \"thread\",\n\t};\n\n\ttimer = list_entry((struct list_head *)v, struct k_itimer, list);\n\tnotify = timer->it_sigev_notify;\n\n\tseq_printf(m, \"ID: %d\\n\", timer->it_id);\n\tseq_printf(m, \"signal: %d/%p\\n\",\n\t\t   timer->sigq->info.si_signo,\n\t\t   timer->sigq->info.si_value.sival_ptr);\n\tseq_printf(m, \"notify: %s/%s.%d\\n\",\n\t\t   nstr[notify & ~SIGEV_THREAD_ID],\n\t\t   (notify & SIGEV_THREAD_ID) ? \"tid\" : \"pid\",\n\t\t   pid_nr_ns(timer->it_pid, tp->ns));\n\tseq_printf(m, \"ClockID: %d\\n\", timer->it_clock);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations proc_timers_seq_ops = {\n\t.start\t= timers_start,\n\t.next\t= timers_next,\n\t.stop\t= timers_stop,\n\t.show\t= show_timer,\n};\n\nstatic int proc_timers_open(struct inode *inode, struct file *file)\n{\n\tstruct timers_private *tp;\n\n\ttp = __seq_open_private(file, &proc_timers_seq_ops,\n\t\t\tsizeof(struct timers_private));\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->pid = proc_pid(inode);\n\ttp->ns = inode->i_sb->s_fs_info;\n\treturn 0;\n}\n\nstatic const struct file_operations proc_timers_operations = {\n\t.open\t\t= proc_timers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_private,\n};\n#endif\n\nstatic ssize_t timerslack_ns_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tu64 slack_ns;\n\tint err;\n\n\terr = kstrtoull_from_user(buf, count, 10, &slack_ns);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (ptrace_may_access(p, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\ttask_lock(p);\n\t\tif (slack_ns == 0)\n\t\t\tp->timer_slack_ns = p->default_timer_slack_ns;\n\t\telse\n\t\t\tp->timer_slack_ns = slack_ns;\n\t\ttask_unlock(p);\n\t} else\n\t\tcount = -EPERM;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int timerslack_ns_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\tint err =  0;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (ptrace_may_access(p, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\ttask_lock(p);\n\t\tseq_printf(m, \"%llu\\n\", p->timer_slack_ns);\n\t\ttask_unlock(p);\n\t} else\n\t\terr = -EPERM;\n\n\tput_task_struct(p);\n\n\treturn err;\n}\n\nstatic int timerslack_ns_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, timerslack_ns_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_timerslack_ns_operations = {\n\t.open\t\t= timerslack_ns_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= timerslack_ns_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}\n\n#ifdef CONFIG_SECURITY\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tvoid *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tkfree(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tREG(\"current\",    S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"prev\",       S_IRUGO,\t   proc_pid_attr_operations),\n\tREG(\"exec\",       S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"fscreate\",   S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"keycreate\",  S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"sockcreate\", S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n};\n\nstatic int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx, \n\t\t\t\t   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_attr_dir_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = kstrtouint_from_user(buf, count, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\tret = 0;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tseq_printf(m,\n\t\t   \"rchar: %llu\\n\"\n\t\t   \"wchar: %llu\\n\"\n\t\t   \"syscr: %llu\\n\"\n\t\t   \"syscw: %llu\\n\"\n\t\t   \"read_bytes: %llu\\n\"\n\t\t   \"write_bytes: %llu\\n\"\n\t\t   \"cancelled_write_bytes: %llu\\n\",\n\t\t   (unsigned long long)acct.rchar,\n\t\t   (unsigned long long)acct.wchar,\n\t\t   (unsigned long long)acct.syscr,\n\t\t   (unsigned long long)acct.syscw,\n\t\t   (unsigned long long)acct.read_bytes,\n\t\t   (unsigned long long)acct.write_bytes,\n\t\t   (unsigned long long)acct.cancelled_write_bytes);\n\tresult = 0;\n\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}\n\nstatic int proc_tid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 1);\n}\n#endif /* CONFIG_TASK_IO_ACCOUNTING */\n\n#ifdef CONFIG_USER_NS\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}\n\nstatic int proc_id_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tput_user_ns(ns);\n\treturn seq_release(inode, file);\n}\n\nstatic int proc_uid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_uid_seq_operations);\n}\n\nstatic int proc_gid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_gid_seq_operations);\n}\n\nstatic int proc_projid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_projid_seq_operations);\n}\n\nstatic const struct file_operations proc_uid_map_operations = {\n\t.open\t\t= proc_uid_map_open,\n\t.write\t\t= proc_uid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic const struct file_operations proc_gid_map_operations = {\n\t.open\t\t= proc_gid_map_open,\n\t.write\t\t= proc_gid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic const struct file_operations proc_projid_map_operations = {\n\t.open\t\t= proc_projid_map_open,\n\t.write\t\t= proc_projid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic int proc_setgroups_open(struct inode *inode, struct file *file)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = -EACCES;\n\t\tif (!ns_capable(ns, CAP_SYS_ADMIN))\n\t\t\tgoto err_put_ns;\n\t}\n\n\tret = single_open(file, &proc_setgroups_show, ns);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}\n\nstatic int proc_setgroups_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tint ret = single_release(inode, file);\n\tput_user_ns(ns);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_setgroups_operations = {\n\t.open\t\t= proc_setgroups_open,\n\t.write\t\t= proc_setgroups_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_setgroups_release,\n};\n#endif /* CONFIG_USER_NS */\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}\n\n/*\n * Thread groups\n */\nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tREG(\"cmdline\",    S_IRUGO, proc_pid_cmdline_ops),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHED_INFO\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n\tREG(\"timerslack_ns\", S_IRUGO|S_IWUGO, proc_pid_set_timerslack_ns_operations),\n};\n\nstatic int proc_tgid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\t/* no ->d_hash() rejects on procfs */\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tif (pid == tgid)\n\t\treturn;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}\n\n/**\n * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.\n * @task: task that should be flushed.\n *\n * When flushing dentries from proc, one needs to flush them from global\n * proc (proc_mnt) and from all the namespaces' procs this task was seen\n * in. This call is supposed to do all of this job.\n *\n * Looks in the dcache for\n * /proc/@pid\n * /proc/@tgid/task/@pid\n * if either directory is present flushes it and all of it'ts children\n * from the dcache.\n *\n * It is safe and reasonable to cache /proc entries for a task until\n * that task exits.  After that they just clog up the dcache with\n * useless entries, possibly causing useful dcache entries to be\n * flushed instead.  This routine is proved to flush those useless\n * dcache entries at process exit time.\n *\n * NOTE: This routine is just an optimization so it does not guarantee\n *       that no dcache entries will exist at process exit time it\n *       just makes it very unlikely that any will persist.\n */\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n}\n\nstatic int proc_pid_instantiate(struct inode *dir,\n\t\t\t\t   struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}\n\n/*\n * Find the first task with tgid >= tgid\n *\n */\nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)\n\n/* for the /proc/ directory itself, after non-process stuff has been done */\nint proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = d_inode(ns->proc_self);\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = d_inode(ns->proc_thread_self);\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\tif (!has_pid_permissions(ns, iter.task, 2))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}\n\n/*\n * Tasks\n */\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tREG(\"cmdline\",   S_IRUGO, proc_pid_cmdline_ops),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_PROC_CHILDREN\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHED_INFO\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(&dentry->d_name);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn ERR_PTR(result);\n}\n\n/*\n * Find the first tid of a thread group to return to user space.\n *\n * Usually this is just the thread group leader, but if the users\n * buffer was too small or there was a seek into the middle of the\n * directory we have more work todo.\n *\n * In the case of a short read we start with find_task_by_pid.\n *\n * In the case of a seek we start with the leader and walk nr\n * threads past it.\n */\nstatic struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t/* 32bit overflow? */\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t/* Attempt to start with the tid of a thread */\n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tpos = task = task->group_leader;\n\tdo {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t} while_each_thread(task, pos);\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n/*\n * Find the next thread in the thread list.\n * Return NULL if there is an error or no next thread.\n *\n * The reference to the input task_struct is released.\n */\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\n/* for the /proc/TGID/task/ directories */\nstatic int proc_task_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *task;\n\tstruct pid_namespace *ns;\n\tint tid;\n\n\tif (proc_inode_is_dead(inode))\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = inode->i_sb->s_fs_info;\n\ttid = (int)file->f_version;\n\tfile->f_version = 0;\n\tfor (task = first_tid(proc_pid(inode), tid, ctx->pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tlen = snprintf(name, sizeof(name), \"%d\", tid);\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL)) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfile->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_task_readdir,\n\t.llseek\t\t= default_llseek,\n};\n"], "filenames": ["fs/proc/base.c"], "buggy_code_start_loc": [958], "buggy_code_end_loc": [959], "fixing_code_start_loc": [958], "fixing_code_end_loc": [960], "type": "CWE-362", "message": "Race condition in the environ_read function in fs/proc/base.c in the Linux kernel before 4.5.4 allows local users to obtain sensitive information from kernel memory by reading a /proc/*/environ file during a process-setup time interval in which environment-variable copying is incomplete.", "other": {"cve": {"id": "CVE-2016-7916", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:11.017", "lastModified": "2017-01-18T02:59:12.610", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the environ_read function in fs/proc/base.c in the Linux kernel before 4.5.4 allows local users to obtain sensitive information from kernel memory by reading a /proc/*/environ file during a process-setup time interval in which environment-variable copying is incomplete."}, {"lang": "es", "value": "La condici\u00f3n de carrera en la funci\u00f3n environ_read en fs / proc / base.c en el kernel de Linux antes de 4.5.4 permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel leyendo un archivo / proc / * / environ durante un intervalo de tiempo de configuraci\u00f3n del proceso cuya copia de variabilidad de entorno es incompleta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.3", "matchCriteriaId": "E7AEB8DD-7C80-4B48-98E0-0502F1575337"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8148a73c9901a8794a50f950083c00ccf97d43b3", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.5.4", "source": "security@android.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/94138", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-3159-1", "source": "security@android.com"}, {"url": "http://www.ubuntu.com/usn/USN-3159-2", "source": "security@android.com"}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=116461", "source": "security@android.com", "tags": ["Issue Tracking"]}, {"url": "https://forums.grsecurity.net/viewtopic.php?f=3&t=4363", "source": "security@android.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/8148a73c9901a8794a50f950083c00ccf97d43b3", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8148a73c9901a8794a50f950083c00ccf97d43b3"}}