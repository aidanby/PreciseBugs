{"buggy_code": ["#include \"ws_decode.h\"\n#include \"base64.h\"\n\n#include <string.h>\n#include <errno.h>\n\n#define WS_HYBI_MASK_LEN 4\n#define WS_HYBI_HEADER_LEN_SHORT 2 + WS_HYBI_MASK_LEN\n#define WS_HYBI_HEADER_LEN_EXTENDED 4 + WS_HYBI_MASK_LEN\n#define WS_HYBI_HEADER_LEN_LONG 10 + WS_HYBI_MASK_LEN\n\n#undef WS_DECODE_DEBUG\n/* set to 1 to produce very fine debugging output */\n#define WS_DECODE_DEBUG 0\n\n#if WS_DECODE_DEBUG == 1\n#define ws_dbg(fmt, ...) rfbLog((fmt), ##__VA_ARGS)\n#else\n#define ws_dbg(fmt, ...)\n#endif\n\n\nstatic inline int\nisControlFrame(ws_ctx_t *wsctx)\n{\n  return 0 != (wsctx->header.opcode & 0x08);\n}\n\nstatic uint64_t\nhybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->header.payloadLen - wsctx->nReadPayload;\n}\n\nstatic void\nhybiDecodeCleanupBasics(ws_ctx_t *wsctx)\n{\n  /* keep opcode, cleanup rest */\n  wsctx->header.opcode = WS_OPCODE_INVALID;\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->header.headerLen = 0;\n  wsctx->header.data = NULL;\n  wsctx->header.nRead = 0;\n  wsctx->nReadPayload = 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n}\n\nstatic void\nhybiDecodeCleanupForContinuation(ws_ctx_t *wsctx)\n{\n  hybiDecodeCleanupBasics(wsctx);\n  ws_dbg(\"clean up frame, but expect continuation with opcode %d\\n\", wsctx->continuation_opcode);\n}\n\nvoid\nhybiDecodeCleanupComplete(ws_ctx_t *wsctx)\n{\n  hybiDecodeCleanupBasics(wsctx);\n  wsctx->continuation_opcode = WS_OPCODE_INVALID;\n  ws_dbg(\"cleaned up wsctx completely\\n\");\n}\n\n\n/**\n * Return payload data that has been decoded/unmasked from\n * a websocket frame.\n *\n * @param[out]     dst destination buffer\n * @param[in]      len bytes to copy to destination buffer\n * @param[in,out]  wsctx internal state of decoding procedure\n * @param[out]     number of bytes actually written to dst buffer\n * @return next hybi decoding state\n */\nstatic int\nhybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n\n  /* if we have something already decoded copy and return */\n  if (wsctx->readlen > 0) {\n    /* simply return what we have */\n    if (wsctx->readlen > len) {\n      ws_dbg(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      ws_dbg(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    ws_dbg(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else {\n    /* it may happen that we read some bytes but could not decode them,\n     * in that case, set errno to EAGAIN and return -1 */\n    nextState = wsctx->hybiDecodeState;\n    errno = EAGAIN;\n    *nWritten = -1;\n  }\n  return nextState;\n}\n\n/**\n * Read an RFC 6455 websocket frame (IETF hybi working group).\n *\n * Internal state is updated according to bytes received and the\n * decoding of header information.\n *\n * @param[in]   cl client ptr with ptr to raw socket and ws_ctx_t ptr\n * @param[out]  sockRet emulated recv return value\n * @param[out]  nPayload number of payload bytes already read\n * @return next hybi decoding state; WS_HYBI_STATE_HEADER_PENDING indicates\n *         that the header was not received completely.\n */\nstatic int\nhybiReadHeader(ws_ctx_t *wsctx, int *sockRet, int *nPayload)\n{\n  int ret;\n  char *headerDst = wsctx->codeBufDecode + wsctx->header.nRead;\n  int n = ((uint64_t)WSHLENMAX) - wsctx->header.nRead;\n\n\n  ws_dbg(\"header_read to %p with len=%d\\n\", headerDst, n);\n  ret = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, headerDst, n);\n  ws_dbg(\"read %d bytes from socket\\n\", ret);\n  if (ret <= 0) {\n    if (-1 == ret) {\n      /* save errno because rfbErr() will tamper it */\n      int olderrno = errno;\n      rfbErr(\"%s: read; %s\\n\", __func__, strerror(errno));\n      errno = olderrno;\n      goto err_cleanup_state;\n    } else {\n      *sockRet = 0;\n      goto err_cleanup_state_sock_closed;\n    }\n  }\n\n  wsctx->header.nRead += ret;\n  if (wsctx->header.nRead < 2) {\n    /* cannot decode header with less than two bytes */\n    goto ret_header_pending;\n  }\n\n  /* first two header bytes received; interpret header data and get rest */\n  wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;\n\n  wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;\n  wsctx->header.fin = (wsctx->header.data->b0 & 0x80) >> 7;\n  if (isControlFrame(wsctx)) {\n    ws_dbg(\"is control frame\\n\");\n    /* is a control frame, leave remembered continuation opcode unchanged;\n     * just check if there is a wrong fragmentation */\n    if (wsctx->header.fin == 0) {\n\n      /* we only accept text/binary continuation frames; RFC6455:\n       * Control frames (see Section 5.5) MAY be injected in the middle of\n       * a fragmented message.  Control frames themselves MUST NOT be\n       * fragmented. */\n      rfbErr(\"control frame with FIN bit cleared received, aborting\\n\");\n      errno = EPROTO;\n      goto err_cleanup_state;\n    }\n  } else {\n    ws_dbg(\"not a control frame\\n\");\n    /* not a control frame, check for continuation opcode */\n    if (wsctx->header.opcode == WS_OPCODE_CONTINUATION) {\n      ws_dbg(\"cont_frame\\n\");\n      /* do we have state (i.e., opcode) for continuation frame? */\n      if (wsctx->continuation_opcode == WS_OPCODE_INVALID) {\n        rfbErr(\"no continuation state\\n\");\n        errno = EPROTO;\n        goto err_cleanup_state;\n      }\n\n      /* otherwise, set opcode = continuation_opcode */\n      wsctx->header.opcode = wsctx->continuation_opcode;\n      ws_dbg(\"set opcode to continuation_opcode: %d\\n\", wsctx->header.opcode);\n    } else {\n      if (wsctx->header.fin == 0) {\n        wsctx->continuation_opcode = wsctx->header.opcode;\n      } else {\n        wsctx->continuation_opcode = WS_OPCODE_INVALID;\n      }\n      ws_dbg(\"set continuation_opcode to %d\\n\", wsctx->continuation_opcode);\n    }\n  }\n\n  wsctx->header.payloadLen = (uint64_t)(wsctx->header.data->b1 & 0x7f);\n  ws_dbg(\"first header bytes received; opcode=%d lenbyte=%d fin=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen, wsctx->header.fin);\n\n  /*\n   * 4.3. Client-to-Server Masking\n   *\n   * The client MUST mask all frames sent to the server.  A server MUST\n   * close the connection upon receiving a frame with the MASK bit set to 0.\n  **/\n  if (!(wsctx->header.data->b1 & 0x80)) {\n    rfbErr(\"%s: got frame without mask; ret=%d\\n\", __func__, ret);\n    errno = EPROTO;\n    goto err_cleanup_state;\n  }\n\n\n  if (wsctx->header.payloadLen < 126 && wsctx->header.nRead >= 6) {\n    wsctx->header.headerLen = WS_HYBI_HEADER_LEN_SHORT;\n    wsctx->header.mask = wsctx->header.data->u.m;\n  } else if (wsctx->header.payloadLen == 126 && 8 <= wsctx->header.nRead) {\n    wsctx->header.headerLen = WS_HYBI_HEADER_LEN_EXTENDED;\n    wsctx->header.payloadLen = WS_NTOH16(wsctx->header.data->u.s16.l16);\n    wsctx->header.mask = wsctx->header.data->u.s16.m16;\n  } else if (wsctx->header.payloadLen == 127 && 14 <= wsctx->header.nRead) {\n    wsctx->header.headerLen = WS_HYBI_HEADER_LEN_LONG;\n    wsctx->header.payloadLen = WS_NTOH64(wsctx->header.data->u.s64.l64);\n    wsctx->header.mask = wsctx->header.data->u.s64.m64;\n  } else {\n    /* Incomplete frame header, try again */\n    rfbErr(\"%s: incomplete frame header; ret=%d\\n\", __func__, ret);\n    goto ret_header_pending;\n  }\n\n  char *h = wsctx->codeBufDecode;\n  int i;\n  ws_dbg(\"Header:\\n\");\n  for (i=0; i <10; i++) {\n    ws_dbg(\"0x%02X\\n\", (unsigned char)h[i]);\n  }\n  ws_dbg(\"\\n\");\n\n  /* while RFC 6455 mandates that lengths MUST be encoded with the minimum\n   * number of bytes, it does not specify for the server how to react on\n   * 'wrongly' encoded frames --- this implementation rejects them*/\n  if ((wsctx->header.headerLen > WS_HYBI_HEADER_LEN_SHORT\n      && wsctx->header.payloadLen < (uint64_t)126)\n      || (wsctx->header.headerLen > WS_HYBI_HEADER_LEN_EXTENDED\n        && wsctx->header.payloadLen < (uint64_t)65536)) {\n    rfbErr(\"%s: invalid length field; headerLen=%d payloadLen=%llu\\n\", __func__, wsctx->header.headerLen, wsctx->header.payloadLen);\n    errno = EPROTO;\n    goto err_cleanup_state;\n  }\n\n  /* update write position for next bytes */\n  wsctx->writePos = wsctx->codeBufDecode + wsctx->header.nRead;\n\n  /* set payload pointer just after header */\n  wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);\n\n  *nPayload = wsctx->header.nRead - wsctx->header.headerLen;\n  wsctx->nReadPayload = *nPayload;\n\n  ws_dbg(\"header complete: state=%d headerlen=%d payloadlen=%llu writeTo=%p nPayload=%d\\n\", wsctx->hybiDecodeState, wsctx->header.headerLen, wsctx->header.payloadLen, wsctx->writePos, *nPayload);\n\n  return WS_HYBI_STATE_DATA_NEEDED;\n\nret_header_pending:\n  errno = EAGAIN;\n  *sockRet = -1;\n  return WS_HYBI_STATE_HEADER_PENDING;\n\nerr_cleanup_state:\n  *sockRet = -1;\nerr_cleanup_state_sock_closed:\n  hybiDecodeCleanupComplete(wsctx);\n  return WS_HYBI_STATE_ERR;\n}\n\nstatic int\nhybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}\n\nstatic char *\nhybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}\n\n\n/**\n * Read the remaining payload bytes from associated raw socket.\n *\n *  - try to read remaining bytes from socket\n *  - unmask all multiples of 4\n *  - if frame incomplete but some bytes are left, these are copied to\n *      the carry buffer\n *  - if opcode is TEXT: Base64-decode all unmasked received bytes\n *  - set state for reading decoded data\n *  - reset write position to begin of buffer (+ header)\n *      --> before we retrieve more data we let the caller clear all bytes\n *          from the reception buffer\n *  - execute return data routine\n *\n *  Sets errno corresponding to what it gets from the underlying\n *  socket or EPROTO if some invalid data is in the received frame\n *  or ECONNRESET if a close reason + message is received. EIO is used if\n *  an internal sanity check fails.\n *\n *  @param[in]  cl client ptr with raw socket reference\n *  @param[out] dst  destination buffer\n *  @param[in]  len  size of destination buffer\n *  @param[out] sockRet emulated recv return value\n *  @param[in]  nInBuf number of undecoded bytes before writePos from header read\n *  @return next hybi decode state\n */\nstatic int\nhybiReadAndDecode(ws_ctx_t *wsctx, char *dst, int len, int *sockRet, int nInBuf)\n{\n  int n;\n  int i;\n  int toReturn; /* number of data bytes to return */\n  int toDecode; /* number of bytes to decode starting at wsctx->writePos */\n  int bufsize;\n  int nextRead;\n  unsigned char *data;\n  uint32_t *data32;\n\n  /* if data was carried over, copy to start of buffer */\n  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n  wsctx->writePos += wsctx->carrylen;\n\n  /* -1 accounts for potential '\\0' terminator for base64 decoding */\n  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;\n  ws_dbg(\"bufsize=%d\\n\", bufsize);\n  if (hybiRemaining(wsctx) > bufsize) {\n    nextRead = bufsize;\n  } else {\n    nextRead = hybiRemaining(wsctx);\n  }\n\n  ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);\n\n  if (nextRead > 0) {\n    /* decode more data */\n    if (-1 == (n = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, wsctx->writePos, nextRead))) {\n      int olderrno = errno;\n      rfbErr(\"%s: read; %s\", __func__, strerror(errno));\n      errno = olderrno;\n      *sockRet = -1;\n      return WS_HYBI_STATE_ERR;\n    } else if (n == 0) {\n      *sockRet = 0;\n      return WS_HYBI_STATE_ERR;\n    } else {\n      ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadPayload);\n    }\n  } else {\n    n = 0;\n  }\n\n  wsctx->nReadPayload += n;\n  wsctx->writePos += n;\n\n  if (hybiRemaining(wsctx) == 0) {\n    wsctx->hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE;\n  }\n\n  /* number of not yet unmasked payload bytes: what we read here + what was\n   * carried over + what was read with the header */\n  toDecode = n + wsctx->carrylen + nInBuf;\n  ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);\n  if (toDecode < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);\n    errno=EIO;\n    *sockRet = -1;\n    return WS_HYBI_STATE_ERR;\n  }\n\n  /* for a possible base64 decoding, we decode multiples of 4 bytes until\n   * the whole frame is received and carry over any remaining bytes in the carry buf*/\n  data = (unsigned char *)(wsctx->writePos - toDecode);\n  data32= (uint32_t *)data;\n\n  for (i = 0; i < (toDecode >> 2); i++) {\n    data32[i] ^= wsctx->header.mask.u;\n  }\n  ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n\n  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n    /* process the remaining bytes (if any) */\n    for (i*=4; i < toDecode; i++) {\n      data[i] ^= wsctx->header.mask.c[i % 4];\n    }\n\n    /* all data is here, no carrying */\n    wsctx->carrylen = 0;\n  } else {\n    /* carry over remaining, non-multiple-of-four bytes */\n    wsctx->carrylen = toDecode - (i * 4);\n    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);\n      *sockRet = -1;\n      errno = EIO;\n      return WS_HYBI_STATE_ERR;\n    }\n    ws_dbg(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);\n    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);\n    wsctx->writePos -= wsctx->carrylen;\n  }\n\n  toReturn = toDecode - wsctx->carrylen;\n\n  switch (wsctx->header.opcode) {\n    case WS_OPCODE_CLOSE:\n      /* this data is not returned as payload data */\n      if (hybiWsFrameComplete(wsctx)) {\n        *(wsctx->writePos) = '\\0';\n        ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(wsctx->writePos - hybiPayloadStart(wsctx)), WS_NTOH16(((uint16_t *)hybiPayloadStart(wsctx))[0]), &hybiPayloadStart(wsctx)[2]);\n        errno = ECONNRESET;\n        *sockRet = -1;\n        return WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(wsctx));\n        *sockRet = -1;\n        errno = EAGAIN;\n        return WS_HYBI_STATE_CLOSE_REASON_PENDING;\n      }\n      break;\n    case WS_OPCODE_TEXT_FRAME:\n      data[toReturn] = '\\0';\n      ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);\n      if (-1 == (wsctx->readlen = rfbBase64PtoN((char *)data, data, bufsize))) {\n        rfbErr(\"%s: Base64 decode error; %s\\n\", __func__, strerror(errno));\n      }\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      break;\n    case WS_OPCODE_BINARY_FRAME:\n      wsctx->readlen = toReturn;\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      ws_dbg(\"set readlen=%d writePos=%p\\n\", wsctx->readlen, wsctx->writePos);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);\n  }\n  wsctx->readPos = data;\n\n  return hybiReturnData(dst, len, wsctx, sockRet);\n}\n\n/**\n * Read function for websocket-socket emulation.\n *\n *    0                   1                   2                   3\n *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *   +-+-+-+-+-------+-+-------------+-------------------------------+\n *   |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n *   |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n *   |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n *   | |1|2|3|       |K|             |                               |\n *   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n *   |     Extended payload length continued, if payload len == 127  |\n *   + - - - - - - - - - - - - - - - +-------------------------------+\n *   |                               |Masking-key, if MASK set to 1  |\n *   +-------------------------------+-------------------------------+\n *   | Masking-key (continued)       |          Payload Data         |\n *   +-------------------------------- - - - - - - - - - - - - - - - +\n *   :                     Payload Data continued ...                :\n *   + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n *   |                     Payload Data continued ...                |\n *   +---------------------------------------------------------------+\n *\n * Using the decode buffer, this function:\n *  - reads the complete header from the underlying socket\n *  - reads any remaining data bytes\n *  - unmasks the payload data using the provided mask\n *  - decodes Base64 encoded text data\n *  - copies len bytes of decoded payload data into dst\n *\n * Emulates a read call on a socket.\n */\nint\nwebSocketsDecodeHybi(ws_ctx_t *wsctx, char *dst, int len)\n{\n    int result = -1;\n    /* int fin; */ /* not used atm */\n\n    ws_dbg(\"%s_enter: len=%d; \"\n                      \"CTX: readlen=%d readPos=%p \"\n                      \"writeTo=%p \"\n                      \"state=%d payloadtoRead=%d payloadRemaining=%llu \"\n                      \" nReadPayload=%d carrylen=%d carryBuf=%p\\n\",\n                      __func__, len,\n                      wsctx->readlen, wsctx->readPos,\n                      wsctx->writePos,\n                      wsctx->hybiDecodeState, wsctx->header.payloadLen, hybiRemaining(wsctx),\n                      wsctx->nReadPayload, wsctx->carrylen, wsctx->carryBuf);\n\n    switch (wsctx->hybiDecodeState){\n      int nInBuf;\n      case WS_HYBI_STATE_HEADER_PENDING:\n        wsctx->hybiDecodeState = hybiReadHeader(wsctx, &result, &nInBuf);\n        if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n          goto spor;\n        }\n        if (wsctx->hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING) {\n\n          /* when header is complete, try to read some more data */\n          wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result, nInBuf);\n        }\n        break;\n      case WS_HYBI_STATE_DATA_AVAILABLE:\n        wsctx->hybiDecodeState = hybiReturnData(dst, len, wsctx, &result);\n        break;\n      case WS_HYBI_STATE_DATA_NEEDED:\n        wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result, 0);\n        break;\n      case WS_HYBI_STATE_CLOSE_REASON_PENDING:\n        wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result, 0);\n        break;\n      default:\n        /* invalid state */\n        rfbErr(\"%s: called with invalid state %d\\n\", wsctx->hybiDecodeState);\n        result = -1;\n        errno = EIO;\n        wsctx->hybiDecodeState = WS_HYBI_STATE_ERR;\n    }\n\n    /* single point of return, if someone has questions :-) */\nspor:\n    if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n      ws_dbg(\"frame received successfully, cleaning up: read=%d hlen=%d plen=%d\\n\", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);\n      if (wsctx->header.fin && !isControlFrame(wsctx)) {\n        /* frame finished, cleanup state */\n        hybiDecodeCleanupComplete(wsctx);\n      } else {\n        /* always retain continuation opcode for unfinished data frames\n         * or control frames, which may interleave with data frames */\n        hybiDecodeCleanupForContinuation(wsctx);\n      }\n    } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n      hybiDecodeCleanupComplete(wsctx);\n    }\n\n    ws_dbg(\"%s_exit: len=%d; \"\n                      \"CTX: readlen=%d readPos=%p \"\n                      \"writePos=%p \"\n                      \"state=%d payloadtoRead=%d payloadRemaining=%d \"\n                      \"nRead=%d carrylen=%d carryBuf=%p \"\n                      \"result=%d \"\n                      \"errno=%d\\n\",\n                      __func__, len,\n                      wsctx->readlen, wsctx->readPos,\n                      wsctx->writePos,\n                      wsctx->hybiDecodeState, wsctx->header.payloadLen, hybiRemaining(wsctx),\n                      wsctx->nReadPayload, wsctx->carrylen, wsctx->carryBuf,\n                      result,\n                      errno);\n    return result;\n}\n"], "fixing_code": ["#include \"ws_decode.h\"\n#include \"base64.h\"\n\n#include <string.h>\n#include <errno.h>\n\n#define WS_HYBI_MASK_LEN 4\n#define WS_HYBI_HEADER_LEN_SHORT 2 + WS_HYBI_MASK_LEN\n#define WS_HYBI_HEADER_LEN_EXTENDED 4 + WS_HYBI_MASK_LEN\n#define WS_HYBI_HEADER_LEN_LONG 10 + WS_HYBI_MASK_LEN\n\n#undef WS_DECODE_DEBUG\n/* set to 1 to produce very fine debugging output */\n#define WS_DECODE_DEBUG 0\n\n#if WS_DECODE_DEBUG == 1\n#define ws_dbg(fmt, ...) rfbLog((fmt), ##__VA_ARGS)\n#else\n#define ws_dbg(fmt, ...)\n#endif\n\n\nstatic inline int\nisControlFrame(ws_ctx_t *wsctx)\n{\n  return 0 != (wsctx->header.opcode & 0x08);\n}\n\nstatic uint64_t\nhybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->header.payloadLen - wsctx->nReadPayload;\n}\n\nstatic void\nhybiDecodeCleanupBasics(ws_ctx_t *wsctx)\n{\n  /* keep opcode, cleanup rest */\n  wsctx->header.opcode = WS_OPCODE_INVALID;\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->header.headerLen = 0;\n  wsctx->header.data = NULL;\n  wsctx->header.nRead = 0;\n  wsctx->nReadPayload = 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n}\n\nstatic void\nhybiDecodeCleanupForContinuation(ws_ctx_t *wsctx)\n{\n  hybiDecodeCleanupBasics(wsctx);\n  ws_dbg(\"clean up frame, but expect continuation with opcode %d\\n\", wsctx->continuation_opcode);\n}\n\nvoid\nhybiDecodeCleanupComplete(ws_ctx_t *wsctx)\n{\n  hybiDecodeCleanupBasics(wsctx);\n  wsctx->continuation_opcode = WS_OPCODE_INVALID;\n  ws_dbg(\"cleaned up wsctx completely\\n\");\n}\n\n\n/**\n * Return payload data that has been decoded/unmasked from\n * a websocket frame.\n *\n * @param[out]     dst destination buffer\n * @param[in]      len bytes to copy to destination buffer\n * @param[in,out]  wsctx internal state of decoding procedure\n * @param[out]     number of bytes actually written to dst buffer\n * @return next hybi decoding state\n */\nstatic int\nhybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n\n  /* if we have something already decoded copy and return */\n  if (wsctx->readlen > 0) {\n    /* simply return what we have */\n    if (wsctx->readlen > len) {\n      ws_dbg(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      ws_dbg(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    ws_dbg(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else {\n    /* it may happen that we read some bytes but could not decode them,\n     * in that case, set errno to EAGAIN and return -1 */\n    nextState = wsctx->hybiDecodeState;\n    errno = EAGAIN;\n    *nWritten = -1;\n  }\n  return nextState;\n}\n\n/**\n * Read an RFC 6455 websocket frame (IETF hybi working group).\n *\n * Internal state is updated according to bytes received and the\n * decoding of header information.\n *\n * @param[in]   cl client ptr with ptr to raw socket and ws_ctx_t ptr\n * @param[out]  sockRet emulated recv return value\n * @param[out]  nPayload number of payload bytes already read\n * @return next hybi decoding state; WS_HYBI_STATE_HEADER_PENDING indicates\n *         that the header was not received completely.\n */\nstatic int\nhybiReadHeader(ws_ctx_t *wsctx, int *sockRet, int *nPayload)\n{\n  int ret;\n  char *headerDst = wsctx->codeBufDecode + wsctx->header.nRead;\n  int n = ((uint64_t)WSHLENMAX) - wsctx->header.nRead;\n\n\n  ws_dbg(\"header_read to %p with len=%d\\n\", headerDst, n);\n  ret = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, headerDst, n);\n  ws_dbg(\"read %d bytes from socket\\n\", ret);\n  if (ret <= 0) {\n    if (-1 == ret) {\n      /* save errno because rfbErr() will tamper it */\n      int olderrno = errno;\n      rfbErr(\"%s: read; %s\\n\", __func__, strerror(errno));\n      errno = olderrno;\n      goto err_cleanup_state;\n    } else {\n      *sockRet = 0;\n      goto err_cleanup_state_sock_closed;\n    }\n  }\n\n  wsctx->header.nRead += ret;\n  if (wsctx->header.nRead < 2) {\n    /* cannot decode header with less than two bytes */\n    goto ret_header_pending;\n  }\n\n  /* first two header bytes received; interpret header data and get rest */\n  wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;\n\n  wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;\n  wsctx->header.fin = (wsctx->header.data->b0 & 0x80) >> 7;\n  if (isControlFrame(wsctx)) {\n    ws_dbg(\"is control frame\\n\");\n    /* is a control frame, leave remembered continuation opcode unchanged;\n     * just check if there is a wrong fragmentation */\n    if (wsctx->header.fin == 0) {\n\n      /* we only accept text/binary continuation frames; RFC6455:\n       * Control frames (see Section 5.5) MAY be injected in the middle of\n       * a fragmented message.  Control frames themselves MUST NOT be\n       * fragmented. */\n      rfbErr(\"control frame with FIN bit cleared received, aborting\\n\");\n      errno = EPROTO;\n      goto err_cleanup_state;\n    }\n  } else {\n    ws_dbg(\"not a control frame\\n\");\n    /* not a control frame, check for continuation opcode */\n    if (wsctx->header.opcode == WS_OPCODE_CONTINUATION) {\n      ws_dbg(\"cont_frame\\n\");\n      /* do we have state (i.e., opcode) for continuation frame? */\n      if (wsctx->continuation_opcode == WS_OPCODE_INVALID) {\n        rfbErr(\"no continuation state\\n\");\n        errno = EPROTO;\n        goto err_cleanup_state;\n      }\n\n      /* otherwise, set opcode = continuation_opcode */\n      wsctx->header.opcode = wsctx->continuation_opcode;\n      ws_dbg(\"set opcode to continuation_opcode: %d\\n\", wsctx->header.opcode);\n    } else {\n      if (wsctx->header.fin == 0) {\n        wsctx->continuation_opcode = wsctx->header.opcode;\n      } else {\n        wsctx->continuation_opcode = WS_OPCODE_INVALID;\n      }\n      ws_dbg(\"set continuation_opcode to %d\\n\", wsctx->continuation_opcode);\n    }\n  }\n\n  wsctx->header.payloadLen = (uint64_t)(wsctx->header.data->b1 & 0x7f);\n  ws_dbg(\"first header bytes received; opcode=%d lenbyte=%d fin=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen, wsctx->header.fin);\n\n  /*\n   * 4.3. Client-to-Server Masking\n   *\n   * The client MUST mask all frames sent to the server.  A server MUST\n   * close the connection upon receiving a frame with the MASK bit set to 0.\n  **/\n  if (!(wsctx->header.data->b1 & 0x80)) {\n    rfbErr(\"%s: got frame without mask; ret=%d\\n\", __func__, ret);\n    errno = EPROTO;\n    goto err_cleanup_state;\n  }\n\n\n  if (wsctx->header.payloadLen < 126 && wsctx->header.nRead >= 6) {\n    wsctx->header.headerLen = WS_HYBI_HEADER_LEN_SHORT;\n    wsctx->header.mask = wsctx->header.data->u.m;\n  } else if (wsctx->header.payloadLen == 126 && 8 <= wsctx->header.nRead) {\n    wsctx->header.headerLen = WS_HYBI_HEADER_LEN_EXTENDED;\n    wsctx->header.payloadLen = WS_NTOH16(wsctx->header.data->u.s16.l16);\n    wsctx->header.mask = wsctx->header.data->u.s16.m16;\n  } else if (wsctx->header.payloadLen == 127 && 14 <= wsctx->header.nRead) {\n    wsctx->header.headerLen = WS_HYBI_HEADER_LEN_LONG;\n    wsctx->header.payloadLen = WS_NTOH64(wsctx->header.data->u.s64.l64);\n    wsctx->header.mask = wsctx->header.data->u.s64.m64;\n  } else {\n    /* Incomplete frame header, try again */\n    rfbErr(\"%s: incomplete frame header; ret=%d\\n\", __func__, ret);\n    goto ret_header_pending;\n  }\n\n  char *h = wsctx->codeBufDecode;\n  int i;\n  ws_dbg(\"Header:\\n\");\n  for (i=0; i <10; i++) {\n    ws_dbg(\"0x%02X\\n\", (unsigned char)h[i]);\n  }\n  ws_dbg(\"\\n\");\n\n  /* while RFC 6455 mandates that lengths MUST be encoded with the minimum\n   * number of bytes, it does not specify for the server how to react on\n   * 'wrongly' encoded frames --- this implementation rejects them*/\n  if ((wsctx->header.headerLen > WS_HYBI_HEADER_LEN_SHORT\n      && wsctx->header.payloadLen < (uint64_t)126)\n      || (wsctx->header.headerLen > WS_HYBI_HEADER_LEN_EXTENDED\n        && wsctx->header.payloadLen < (uint64_t)65536)) {\n    rfbErr(\"%s: invalid length field; headerLen=%d payloadLen=%llu\\n\", __func__, wsctx->header.headerLen, wsctx->header.payloadLen);\n    errno = EPROTO;\n    goto err_cleanup_state;\n  }\n\n  /* update write position for next bytes */\n  wsctx->writePos = wsctx->codeBufDecode + wsctx->header.nRead;\n\n  /* set payload pointer just after header */\n  wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);\n\n  *nPayload = wsctx->header.nRead - wsctx->header.headerLen;\n  wsctx->nReadPayload = *nPayload;\n\n  ws_dbg(\"header complete: state=%d headerlen=%d payloadlen=%llu writeTo=%p nPayload=%d\\n\", wsctx->hybiDecodeState, wsctx->header.headerLen, wsctx->header.payloadLen, wsctx->writePos, *nPayload);\n\n  return WS_HYBI_STATE_DATA_NEEDED;\n\nret_header_pending:\n  errno = EAGAIN;\n  *sockRet = -1;\n  return WS_HYBI_STATE_HEADER_PENDING;\n\nerr_cleanup_state:\n  *sockRet = -1;\nerr_cleanup_state_sock_closed:\n  hybiDecodeCleanupComplete(wsctx);\n  return WS_HYBI_STATE_ERR;\n}\n\nstatic int\nhybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}\n\nstatic char *\nhybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}\n\n\n/**\n * Read the remaining payload bytes from associated raw socket.\n *\n *  - try to read remaining bytes from socket\n *  - unmask all multiples of 4\n *  - if frame incomplete but some bytes are left, these are copied to\n *      the carry buffer\n *  - if opcode is TEXT: Base64-decode all unmasked received bytes\n *  - set state for reading decoded data\n *  - reset write position to begin of buffer (+ header)\n *      --> before we retrieve more data we let the caller clear all bytes\n *          from the reception buffer\n *  - execute return data routine\n *\n *  Sets errno corresponding to what it gets from the underlying\n *  socket or EPROTO if some invalid data is in the received frame\n *  or ECONNRESET if a close reason + message is received. EIO is used if\n *  an internal sanity check fails.\n *\n *  @param[in]  cl client ptr with raw socket reference\n *  @param[out] dst  destination buffer\n *  @param[in]  len  size of destination buffer\n *  @param[out] sockRet emulated recv return value\n *  @param[in]  nInBuf number of undecoded bytes before writePos from header read\n *  @return next hybi decode state\n */\nstatic int\nhybiReadAndDecode(ws_ctx_t *wsctx, char *dst, int len, int *sockRet, int nInBuf)\n{\n  int n;\n  int i;\n  int toReturn; /* number of data bytes to return */\n  int toDecode; /* number of bytes to decode starting at wsctx->writePos */\n  int bufsize;\n  int nextRead;\n  unsigned char *data;\n\n  /* if data was carried over, copy to start of buffer */\n  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n  wsctx->writePos += wsctx->carrylen;\n\n  /* -1 accounts for potential '\\0' terminator for base64 decoding */\n  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;\n  ws_dbg(\"bufsize=%d\\n\", bufsize);\n  if (hybiRemaining(wsctx) > bufsize) {\n    nextRead = bufsize;\n  } else {\n    nextRead = hybiRemaining(wsctx);\n  }\n\n  ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);\n\n  if (nextRead > 0) {\n    /* decode more data */\n    if (-1 == (n = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, wsctx->writePos, nextRead))) {\n      int olderrno = errno;\n      rfbErr(\"%s: read; %s\", __func__, strerror(errno));\n      errno = olderrno;\n      *sockRet = -1;\n      return WS_HYBI_STATE_ERR;\n    } else if (n == 0) {\n      *sockRet = 0;\n      return WS_HYBI_STATE_ERR;\n    } else {\n      ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadPayload);\n    }\n  } else {\n    n = 0;\n  }\n\n  wsctx->nReadPayload += n;\n  wsctx->writePos += n;\n\n  if (hybiRemaining(wsctx) == 0) {\n    wsctx->hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE;\n  }\n\n  /* number of not yet unmasked payload bytes: what we read here + what was\n   * carried over + what was read with the header */\n  toDecode = n + wsctx->carrylen + nInBuf;\n  ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);\n  if (toDecode < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);\n    errno=EIO;\n    *sockRet = -1;\n    return WS_HYBI_STATE_ERR;\n  }\n\n  /* for a possible base64 decoding, we decode multiples of 4 bytes until\n   * the whole frame is received and carry over any remaining bytes in the carry buf*/\n  data = (unsigned char *)(wsctx->writePos - toDecode);\n\n  for (i = 0; i < (toDecode >> 2); i++) {\n    uint32_t tmp;\n    memcpy(&tmp, data + i * sizeof(tmp), sizeof(tmp));\n    tmp ^= wsctx->header.mask.u;\n    memcpy(data + i * sizeof(tmp), &tmp, sizeof(tmp));\n  }\n  ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n\n  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n    /* process the remaining bytes (if any) */\n    for (i*=4; i < toDecode; i++) {\n      data[i] ^= wsctx->header.mask.c[i % 4];\n    }\n\n    /* all data is here, no carrying */\n    wsctx->carrylen = 0;\n  } else {\n    /* carry over remaining, non-multiple-of-four bytes */\n    wsctx->carrylen = toDecode - (i * 4);\n    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);\n      *sockRet = -1;\n      errno = EIO;\n      return WS_HYBI_STATE_ERR;\n    }\n    ws_dbg(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);\n    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);\n    wsctx->writePos -= wsctx->carrylen;\n  }\n\n  toReturn = toDecode - wsctx->carrylen;\n\n  switch (wsctx->header.opcode) {\n    case WS_OPCODE_CLOSE:\n      /* this data is not returned as payload data */\n      if (hybiWsFrameComplete(wsctx)) {\n        *(wsctx->writePos) = '\\0';\n        ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(wsctx->writePos - hybiPayloadStart(wsctx)), WS_NTOH16(((uint16_t *)hybiPayloadStart(wsctx))[0]), &hybiPayloadStart(wsctx)[2]);\n        errno = ECONNRESET;\n        *sockRet = -1;\n        return WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(wsctx));\n        *sockRet = -1;\n        errno = EAGAIN;\n        return WS_HYBI_STATE_CLOSE_REASON_PENDING;\n      }\n      break;\n    case WS_OPCODE_TEXT_FRAME:\n      data[toReturn] = '\\0';\n      ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);\n      if (-1 == (wsctx->readlen = rfbBase64PtoN((char *)data, data, bufsize))) {\n        rfbErr(\"%s: Base64 decode error; %s\\n\", __func__, strerror(errno));\n      }\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      break;\n    case WS_OPCODE_BINARY_FRAME:\n      wsctx->readlen = toReturn;\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      ws_dbg(\"set readlen=%d writePos=%p\\n\", wsctx->readlen, wsctx->writePos);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);\n  }\n  wsctx->readPos = data;\n\n  return hybiReturnData(dst, len, wsctx, sockRet);\n}\n\n/**\n * Read function for websocket-socket emulation.\n *\n *    0                   1                   2                   3\n *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *   +-+-+-+-+-------+-+-------------+-------------------------------+\n *   |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n *   |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n *   |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n *   | |1|2|3|       |K|             |                               |\n *   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n *   |     Extended payload length continued, if payload len == 127  |\n *   + - - - - - - - - - - - - - - - +-------------------------------+\n *   |                               |Masking-key, if MASK set to 1  |\n *   +-------------------------------+-------------------------------+\n *   | Masking-key (continued)       |          Payload Data         |\n *   +-------------------------------- - - - - - - - - - - - - - - - +\n *   :                     Payload Data continued ...                :\n *   + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n *   |                     Payload Data continued ...                |\n *   +---------------------------------------------------------------+\n *\n * Using the decode buffer, this function:\n *  - reads the complete header from the underlying socket\n *  - reads any remaining data bytes\n *  - unmasks the payload data using the provided mask\n *  - decodes Base64 encoded text data\n *  - copies len bytes of decoded payload data into dst\n *\n * Emulates a read call on a socket.\n */\nint\nwebSocketsDecodeHybi(ws_ctx_t *wsctx, char *dst, int len)\n{\n    int result = -1;\n    /* int fin; */ /* not used atm */\n\n    ws_dbg(\"%s_enter: len=%d; \"\n                      \"CTX: readlen=%d readPos=%p \"\n                      \"writeTo=%p \"\n                      \"state=%d payloadtoRead=%d payloadRemaining=%llu \"\n                      \" nReadPayload=%d carrylen=%d carryBuf=%p\\n\",\n                      __func__, len,\n                      wsctx->readlen, wsctx->readPos,\n                      wsctx->writePos,\n                      wsctx->hybiDecodeState, wsctx->header.payloadLen, hybiRemaining(wsctx),\n                      wsctx->nReadPayload, wsctx->carrylen, wsctx->carryBuf);\n\n    switch (wsctx->hybiDecodeState){\n      int nInBuf;\n      case WS_HYBI_STATE_HEADER_PENDING:\n        wsctx->hybiDecodeState = hybiReadHeader(wsctx, &result, &nInBuf);\n        if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n          goto spor;\n        }\n        if (wsctx->hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING) {\n\n          /* when header is complete, try to read some more data */\n          wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result, nInBuf);\n        }\n        break;\n      case WS_HYBI_STATE_DATA_AVAILABLE:\n        wsctx->hybiDecodeState = hybiReturnData(dst, len, wsctx, &result);\n        break;\n      case WS_HYBI_STATE_DATA_NEEDED:\n        wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result, 0);\n        break;\n      case WS_HYBI_STATE_CLOSE_REASON_PENDING:\n        wsctx->hybiDecodeState = hybiReadAndDecode(wsctx, dst, len, &result, 0);\n        break;\n      default:\n        /* invalid state */\n        rfbErr(\"%s: called with invalid state %d\\n\", wsctx->hybiDecodeState);\n        result = -1;\n        errno = EIO;\n        wsctx->hybiDecodeState = WS_HYBI_STATE_ERR;\n    }\n\n    /* single point of return, if someone has questions :-) */\nspor:\n    if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n      ws_dbg(\"frame received successfully, cleaning up: read=%d hlen=%d plen=%d\\n\", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);\n      if (wsctx->header.fin && !isControlFrame(wsctx)) {\n        /* frame finished, cleanup state */\n        hybiDecodeCleanupComplete(wsctx);\n      } else {\n        /* always retain continuation opcode for unfinished data frames\n         * or control frames, which may interleave with data frames */\n        hybiDecodeCleanupForContinuation(wsctx);\n      }\n    } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n      hybiDecodeCleanupComplete(wsctx);\n    }\n\n    ws_dbg(\"%s_exit: len=%d; \"\n                      \"CTX: readlen=%d readPos=%p \"\n                      \"writePos=%p \"\n                      \"state=%d payloadtoRead=%d payloadRemaining=%d \"\n                      \"nRead=%d carrylen=%d carryBuf=%p \"\n                      \"result=%d \"\n                      \"errno=%d\\n\",\n                      __func__, len,\n                      wsctx->readlen, wsctx->readPos,\n                      wsctx->writePos,\n                      wsctx->hybiDecodeState, wsctx->header.payloadLen, hybiRemaining(wsctx),\n                      wsctx->nReadPayload, wsctx->carrylen, wsctx->carryBuf,\n                      result,\n                      errno);\n    return result;\n}\n"], "filenames": ["libvncserver/ws_decode.c"], "buggy_code_start_loc": [330], "buggy_code_end_loc": [390], "fixing_code_start_loc": [329], "fixing_code_end_loc": [391], "type": "CWE-787", "message": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/ws_decode.c can lead to a crash because of unaligned accesses in hybiReadAndDecode.", "other": {"cve": {"id": "CVE-2019-20840", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:11.523", "lastModified": "2022-03-10T15:23:29.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/ws_decode.c can lead to a crash because of unaligned accesses in hybiReadAndDecode."}, {"lang": "es", "value": "Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. La biblioteca libvncserver/ws_decode.c puede conllevar a un bloqueo debido a accesos no alineados en la funci\u00f3n hybiReadAndDecode"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.12", "matchCriteriaId": "A03A7282-D445-4E26-98A0-6A1597838D35"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/0cf1400c61850065de590d403f6d49e32882fd76", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4F6FUH4EFK4NAP6GT4TQRTBKWIRCZLIY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/0cf1400c61850065de590d403f6d49e32882fd76"}}