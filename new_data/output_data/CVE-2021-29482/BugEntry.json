{"buggy_code": ["// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xz\n\nimport (\n\t\"errors\"\n\t\"io\"\n)\n\n// putUint32LE puts the little-endian representation of x into the first\n// four bytes of p.\nfunc putUint32LE(p []byte, x uint32) {\n\tp[0] = byte(x)\n\tp[1] = byte(x >> 8)\n\tp[2] = byte(x >> 16)\n\tp[3] = byte(x >> 24)\n}\n\n// putUint64LE puts the little-endian representation of x into the first\n// eight bytes of p.\nfunc putUint64LE(p []byte, x uint64) {\n\tp[0] = byte(x)\n\tp[1] = byte(x >> 8)\n\tp[2] = byte(x >> 16)\n\tp[3] = byte(x >> 24)\n\tp[4] = byte(x >> 32)\n\tp[5] = byte(x >> 40)\n\tp[6] = byte(x >> 48)\n\tp[7] = byte(x >> 56)\n}\n\n// uint32LE converts a little endian representation to an uint32 value.\nfunc uint32LE(p []byte) uint32 {\n\treturn uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 |\n\t\tuint32(p[3])<<24\n}\n\n// putUvarint puts a uvarint representation of x into the byte slice.\nfunc putUvarint(p []byte, x uint64) int {\n\ti := 0\n\tfor x >= 0x80 {\n\t\tp[i] = byte(x) | 0x80\n\t\tx >>= 7\n\t\ti++\n\t}\n\tp[i] = byte(x)\n\treturn i + 1\n}\n\n// errOverflow indicates an overflow of the 64-bit unsigned integer.\nvar errOverflowU64 = errors.New(\"xz: uvarint overflows 64-bit unsigned integer\")\n\n// readUvarint reads a uvarint from the given byte reader.\nfunc readUvarint(r io.ByteReader) (x uint64, n int, err error) {\n\tvar s uint\n\ti := 0\n\tfor {\n\t\tb, err := r.ReadByte()\n\t\tif err != nil {\n\t\t\treturn x, i, err\n\t\t}\n\t\ti++\n\t\tif b < 0x80 {\n\t\t\tif i > 10 || i == 10 && b > 1 {\n\t\t\t\treturn x, i, errOverflowU64\n\t\t\t}\n\t\t\treturn x | uint64(b)<<s, i, nil\n\t\t}\n\t\tx |= uint64(b&0x7f) << s\n\t\ts += 7\n\t}\n}\n", "// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xz\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestUvarint(t *testing.T) {\n\ttests := []uint64{0, 0x80, 0x100, 0xffffffff, 0x100000000, 1<<64 - 1}\n\tp := make([]byte, 10)\n\tfor _, u := range tests {\n\t\tp = p[:10]\n\t\tn := putUvarint(p, u)\n\t\tif n < 1 {\n\t\t\tt.Fatalf(\"putUvarint returned %d\", n)\n\t\t}\n\t\tr := bytes.NewReader(p[:n])\n\t\tx, m, err := readUvarint(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"readUvarint returned %s\", err)\n\t\t}\n\t\tif m != n {\n\t\t\tt.Fatalf(\"readUvarint read %d bytes; want %d\", m, n)\n\t\t}\n\t\tif x != u {\n\t\t\tt.Fatalf(\"readUvarint returned 0x%x; want 0x%x\", x, u)\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xz\n\nimport (\n\t\"errors\"\n\t\"io\"\n)\n\n// putUint32LE puts the little-endian representation of x into the first\n// four bytes of p.\nfunc putUint32LE(p []byte, x uint32) {\n\tp[0] = byte(x)\n\tp[1] = byte(x >> 8)\n\tp[2] = byte(x >> 16)\n\tp[3] = byte(x >> 24)\n}\n\n// putUint64LE puts the little-endian representation of x into the first\n// eight bytes of p.\nfunc putUint64LE(p []byte, x uint64) {\n\tp[0] = byte(x)\n\tp[1] = byte(x >> 8)\n\tp[2] = byte(x >> 16)\n\tp[3] = byte(x >> 24)\n\tp[4] = byte(x >> 32)\n\tp[5] = byte(x >> 40)\n\tp[6] = byte(x >> 48)\n\tp[7] = byte(x >> 56)\n}\n\n// uint32LE converts a little endian representation to an uint32 value.\nfunc uint32LE(p []byte) uint32 {\n\treturn uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 |\n\t\tuint32(p[3])<<24\n}\n\n// putUvarint puts a uvarint representation of x into the byte slice.\nfunc putUvarint(p []byte, x uint64) int {\n\ti := 0\n\tfor x >= 0x80 {\n\t\tp[i] = byte(x) | 0x80\n\t\tx >>= 7\n\t\ti++\n\t}\n\tp[i] = byte(x)\n\treturn i + 1\n}\n\n// errOverflow indicates an overflow of the 64-bit unsigned integer.\nvar errOverflowU64 = errors.New(\"xz: uvarint overflows 64-bit unsigned integer\")\n\n// readUvarint reads a uvarint from the given byte reader.\nfunc readUvarint(r io.ByteReader) (x uint64, n int, err error) {\n\tconst maxUvarintLen = 10\n\n\tvar s uint\n\ti := 0\n\tfor {\n\t\tb, err := r.ReadByte()\n\t\tif err != nil {\n\t\t\treturn x, i, err\n\t\t}\n\t\ti++\n\t\tif i > maxUvarintLen {\n\t\t\treturn x, i, errOverflowU64\n\t\t}\n\t\tif b < 0x80 {\n\t\t\tif i == maxUvarintLen && b > 1 {\n\t\t\t\treturn x, i, errOverflowU64\n\t\t\t}\n\t\t\treturn x | uint64(b)<<s, i, nil\n\t\t}\n\t\tx |= uint64(b&0x7f) << s\n\t\ts += 7\n\t}\n}\n", "// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xz\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestUvarint(t *testing.T) {\n\ttests := []uint64{0, 0x80, 0x100, 0xffffffff, 0x100000000, 1<<64 - 1}\n\tp := make([]byte, 10)\n\tfor _, u := range tests {\n\t\tp = p[:10]\n\t\tn := putUvarint(p, u)\n\t\tif n < 1 {\n\t\t\tt.Fatalf(\"putUvarint returned %d\", n)\n\t\t}\n\t\tr := bytes.NewReader(p[:n])\n\t\tx, m, err := readUvarint(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"readUvarint returned %s\", err)\n\t\t}\n\t\tif m != n {\n\t\t\tt.Fatalf(\"readUvarint read %d bytes; want %d\", m, n)\n\t\t}\n\t\tif x != u {\n\t\t\tt.Fatalf(\"readUvarint returned 0x%x; want 0x%x\", x, u)\n\t\t}\n\t}\n}\n\nfunc TestUvarIntCVE_2020_16845(t *testing.T) {\n\tvar a = []byte{0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n\t\t0x88, 0x89, 0x8a, 0x8b}\n\n\tr := bytes.NewReader(a)\n\t_, _, err := readUvarint(r)\n\tif err != errOverflowU64 {\n\t\tt.Fatalf(\"readUvarint overflow not detected\")\n\t}\n}\n"], "filenames": ["bits.go", "bits_test.go"], "buggy_code_start_loc": [56, 33], "buggy_code_end_loc": [67, 33], "fixing_code_start_loc": [57, 34], "fixing_code_end_loc": [72, 45], "type": "CWE-835", "message": "xz is a compression and decompression library focusing on the xz format completely written in Go. The function readUvarint used to read the xz container format may not terminate a loop provide malicous input. The problem has been fixed in release v0.5.8. As a workaround users can limit the size of the compressed file input to a reasonable size for their use case. The standard library had recently the same issue and got the CVE-2020-16845 allocated.", "other": {"cve": {"id": "CVE-2021-29482", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-28T19:15:08.587", "lastModified": "2021-05-14T19:56:32.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "xz is a compression and decompression library focusing on the xz format completely written in Go. The function readUvarint used to read the xz container format may not terminate a loop provide malicous input. The problem has been fixed in release v0.5.8. As a workaround users can limit the size of the compressed file input to a reasonable size for their use case. The standard library had recently the same issue and got the CVE-2020-16845 allocated."}, {"lang": "es", "value": "xz es una biblioteca de compresi\u00f3n y descompresi\u00f3n que se centra en el formato xz escrito completamente en Go.&#xa0;La funci\u00f3n readUvarint utilizada para leer el formato contenedor xz no puede terminar un bucle y proporcionar una entrada maliciosa.&#xa0;El problema ha sido corregido en la versi\u00f3n v0.5.8.&#xa0;Como soluci\u00f3n alternativa, los usuarios pueden limitar el tama\u00f1o de la entrada del archivo comprimido a un tama\u00f1o razonable para su caso de uso.&#xa0;La biblioteca est\u00e1ndar tuvo recientemente el mismo problema y se le asign\u00f3 el CVE-2020-16845"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xz_project:xz:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.5.8", "matchCriteriaId": "7BD33BAB-9C3D-43FF-B75B-D71DFB85DB88"}]}]}], "references": [{"url": "https://github.com/ulikunitz/xz/commit/69c6093c7b2397b923acf82cb378f55ab2652b9b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ulikunitz/xz/security/advisories/GHSA-25xm-hr59-7c27", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ulikunitz/xz/commit/69c6093c7b2397b923acf82cb378f55ab2652b9b"}}