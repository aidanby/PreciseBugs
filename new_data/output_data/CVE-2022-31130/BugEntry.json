{"buggy_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n\t\"github.com/grafana/grafana/pkg/services/pluginsettings\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util/errutil\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\tcoreFilter := c.Query(\"core\")\n\n\t// For users with viewer role we only return core plugins\n\tif !c.HasRole(models.ROLE_ADMIN) {\n\t\tcoreFilter = \"1\"\n\t}\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get list of plugins\", err)\n\t}\n\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range hs.pluginStore.Plugins(c.Req.Context()) {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tDefaultNavUrl: path.Join(hs.Cfg.AppSubURL, pluginDef.DefaultNavURL),\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t}\n\n\t\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), pluginDef.ID)\n\t\tif exists {\n\t\t\tlistItem.LatestVersion = update\n\t\t\tlistItem.HasUpdate = true\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif enabledFilter == \"1\" && !listItem.Enabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(200, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:          string(plugin.Type),\n\t\tId:            plugin.ID,\n\t\tName:          plugin.Name,\n\t\tInfo:          plugin.Info,\n\t\tDependencies:  plugin.Dependencies,\n\t\tIncludes:      plugin.Includes,\n\t\tBaseUrl:       plugin.BaseURL,\n\t\tModule:        plugin.Module,\n\t\tDefaultNavUrl: path.Join(hs.Cfg.AppSubURL, plugin.DefaultNavURL),\n\t\tState:         plugin.State,\n\t\tSignature:     plugin.Signature,\n\t\tSignatureType: plugin.SignatureType,\n\t\tSignatureOrg:  plugin.SignatureOrg,\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tps, err := hs.PluginSettings.GetPluginSettingByPluginID(c.Req.Context(), &pluginsettings.GetByPluginIDArgs{\n\t\tPluginID: pluginID,\n\t\tOrgID:    c.OrgId,\n\t})\n\tif err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to get plugin settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = ps.Enabled\n\t\tdto.Pinned = ps.Pinned\n\t\tdto.JsonData = ps.JSONData\n\t}\n\n\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), plugin.ID)\n\tif exists {\n\t\tdto.LatestVersion = update\n\t\tdto.HasUpdate = true\n\t}\n\n\treturn response.JSON(200, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgId\n\tcmd.PluginId = pluginID\n\tif err := hs.PluginSettings.UpdatePluginSetting(c.Req.Context(), &pluginsettings.UpdateArgs{\n\t\tEnabled:                 cmd.Enabled,\n\t\tPinned:                  cmd.Pinned,\n\t\tJSONData:                cmd.JsonData,\n\t\tSecureJSONData:          cmd.SecureJsonData,\n\t\tPluginVersion:           cmd.PluginVersion,\n\t\tPluginID:                cmd.PluginId,\n\t\tOrgID:                   cmd.OrgId,\n\t\tEncryptedSecureJSONData: cmd.EncryptedSecureJsonData,\n\t}); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(200, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), &backend.CollectMetricsRequest{PluginContext: backend.PluginContext{PluginID: pluginID}})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(200, payload)\n}\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\ths.callPluginResource(c, web.Params(c.Req)[\":pluginId\"], \"\")\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(200, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Add(c.Req.Context(), pluginID, dto.Version)\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr installer.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr installer.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError installer.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tpath := filepath.Join(plugin.PluginDir, mdFilepath(strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, mdFilepath(strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc mdFilepath(mdFilename string) string {\n\treturn filepath.Clean(filepath.Join(\"/\", fmt.Sprintf(\"%s.md\", mdFilename)))\n}\n\nfunc (hs *HTTPServer) callPluginResource(c *models.ReqContext, pluginID, dsUID string) {\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, dsUID, c.SignedInUser, false)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\tvar dsURL string\n\tif pCtx.DataSourceInstanceSettings != nil {\n\t\tdsURL = pCtx.DataSourceInstanceSettings.URL\n\t}\n\n\terr = hs.PluginRequestValidator.Validate(dsURL, c.Req)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusForbidden, \"Access denied\", err)\n\t\treturn\n\t}\n\n\tclonedReq := c.Req.Clone(c.Req.Context())\n\trawURL := web.Params(c.Req)[\"*\"]\n\tif clonedReq.URL.RawQuery != \"\" {\n\t\trawURL += \"?\" + clonedReq.URL.RawQuery\n\t}\n\turlPath, err := url.Parse(rawURL)\n\tif err != nil {\n\t\thandleCallResourceError(err, c)\n\t\treturn\n\t}\n\tclonedReq.URL = urlPath\n\n\tif dsUID != \"\" {\n\t\tds, err := hs.DataSourceCache.GetDatasourceByUID(c.Req.Context(), dsUID, c.SignedInUser, c.SkipCache)\n\n\t\tif err != nil {\n\t\t\tif errors.Is(err, models.ErrDataSourceNotFound) {\n\t\t\t\tc.JsonApiErr(404, \"Datasource not found\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tc.JsonApiErr(500, \"Failed to get datasource\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif hs.DataProxy.OAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\t\tif token := hs.DataProxy.OAuthTokenService.GetCurrentOAuthToken(c.Req.Context(), c.SignedInUser); token != nil {\n\t\t\t\tclonedReq.Header.Add(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\n\t\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\t\tif ok && idToken != \"\" {\n\t\t\t\t\tclonedReq.Header.Add(\"X-ID-Token\", idToken)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = hs.makePluginResourceRequest(c.Resp, clonedReq, pCtx); err != nil {\n\t\thandleCallResourceError(err, c)\n\t}\n}\n\nfunc (hs *HTTPServer) makePluginResourceRequest(w http.ResponseWriter, req *http.Request, pCtx backend.PluginContext) error {\n\tkeepCookieModel := struct {\n\t\tKeepCookies []string `json:\"keepCookies\"`\n\t}{}\n\tif dis := pCtx.DataSourceInstanceSettings; dis != nil {\n\t\terr := json.Unmarshal(dis.JSONData, &keepCookieModel)\n\t\tif err != nil {\n\t\t\ths.log.Warn(\"failed to to unpack JSONData in datasource instance settings\", \"err\", err)\n\t\t}\n\t}\n\tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies)\n\tproxyutil.PrepareProxyRequest(req)\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read request body: %w\", err)\n\t}\n\n\tcrReq := &backend.CallResourceRequest{\n\t\tPluginContext: pCtx,\n\t\tPath:          req.URL.Path,\n\t\tMethod:        req.Method,\n\t\tURL:           req.URL.String(),\n\t\tHeaders:       req.Header,\n\t\tBody:          body,\n\t}\n\n\tchildCtx, cancel := context.WithCancel(req.Context())\n\tdefer cancel()\n\tstream := newCallResourceResponseStream(childCtx)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tdefer func() {\n\t\tif err := stream.Close(); err != nil {\n\t\t\ths.log.Warn(\"Failed to close plugin resource stream\", \"err\", err)\n\t\t}\n\t\twg.Wait()\n\t}()\n\n\tvar flushStreamErr error\n\tgo func() {\n\t\tflushStreamErr = hs.flushStream(stream, w)\n\t\twg.Done()\n\t}()\n\n\tif err := hs.pluginClient.CallResource(req.Context(), crReq, stream); err != nil {\n\t\treturn err\n\t}\n\n\treturn flushStreamErr\n}\n\nfunc (hs *HTTPServer) flushStream(stream callResourceClientResponseStream, w http.ResponseWriter) error {\n\tprocessedStreams := 0\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errors.New(\"received empty resource response\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errutil.Wrap(\"failed to receive response from resource call\", err)\n\t\t\t}\n\n\t\t\ths.log.Error(\"Failed to receive response from resource call\", \"err\", err)\n\t\t\treturn stream.Close()\n\t\t}\n\n\t\t// Expected that headers and status are only part of first stream\n\t\tif processedStreams == 0 && resp.Headers != nil {\n\t\t\t// Make sure a content type always is returned in response\n\t\t\tif _, exists := resp.Headers[\"Content-Type\"]; !exists {\n\t\t\t\tresp.Headers[\"Content-Type\"] = []string{\"application/json\"}\n\t\t\t}\n\n\t\t\tfor k, values := range resp.Headers {\n\t\t\t\t// Due to security reasons we don't want to forward\n\t\t\t\t// cookies from a backend plugin to clients/browsers.\n\t\t\t\tif k == \"Set-Cookie\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range values {\n\t\t\t\t\t// TODO: Figure out if we should use Set here instead\n\t\t\t\t\t// nolint:gocritic\n\t\t\t\t\tw.Header().Add(k, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyutil.SetProxyResponseHeaders(w.Header())\n\n\t\t\tw.WriteHeader(resp.Status)\n\t\t}\n\n\t\tif _, err := w.Write(resp.Body); err != nil {\n\t\t\ths.log.Error(\"Failed to write resource response\", \"err\", err)\n\t\t}\n\n\t\tif flusher, ok := w.(http.Flusher); ok {\n\t\t\tflusher.Flush()\n\t\t}\n\t\tprocessedStreams++\n\t}\n}\n\nfunc handleCallResourceError(err error, reqCtx *models.ReqContext) {\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treqCtx.JsonApiErr(503, \"Plugin unavailable\", err)\n\t\treturn\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treqCtx.JsonApiErr(404, \"Not found\", err)\n\t\treturn\n\t}\n\n\treqCtx.JsonApiErr(500, \"Failed to call resource\", err)\n}\n\n// callResourceClientResponseStream is used for receiving resource call responses.\ntype callResourceClientResponseStream interface {\n\tRecv() (*backend.CallResourceResponse, error)\n\tClose() error\n}\n\ntype callResourceResponseStream struct {\n\tctx    context.Context\n\tstream chan *backend.CallResourceResponse\n\tclosed bool\n}\n\nfunc newCallResourceResponseStream(ctx context.Context) *callResourceResponseStream {\n\treturn &callResourceResponseStream{\n\t\tctx:    ctx,\n\t\tstream: make(chan *backend.CallResourceResponse),\n\t}\n}\n\nfunc (s *callResourceResponseStream) Send(res *backend.CallResourceResponse) error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot send to a closed stream\")\n\t}\n\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn errors.New(\"cancelled\")\n\tcase s.stream <- res:\n\t\treturn nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Recv() (*backend.CallResourceResponse, error) {\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn nil, s.ctx.Err()\n\tcase res, ok := <-s.stream:\n\t\tif !ok {\n\t\t\treturn nil, io.EOF\n\t\t}\n\t\treturn res, nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Close() error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot close a closed stream\")\n\t}\n\n\tclose(s.stream)\n\ts.closed = true\n\treturn nil\n}\n", "package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web/webtest\"\n)\n\nfunc Test_PluginsInstallAndUninstall(t *testing.T) {\n\ttype tc struct {\n\t\tpluginAdminEnabled               bool\n\t\tpluginAdminExternalManageEnabled bool\n\t\texpectedHTTPStatus               int\n\t\texpectedHTTPBody                 string\n\t}\n\ttcs := []tc{\n\t\t{pluginAdminEnabled: true, pluginAdminExternalManageEnabled: true, expectedHTTPStatus: 404, expectedHTTPBody: \"404 page not found\\n\"},\n\t\t{pluginAdminEnabled: true, pluginAdminExternalManageEnabled: false, expectedHTTPStatus: 200, expectedHTTPBody: \"\"},\n\t\t{pluginAdminEnabled: false, pluginAdminExternalManageEnabled: true, expectedHTTPStatus: 404, expectedHTTPBody: \"404 page not found\\n\"},\n\t\t{pluginAdminEnabled: false, pluginAdminExternalManageEnabled: false, expectedHTTPStatus: 404, expectedHTTPBody: \"404 page not found\\n\"},\n\t}\n\n\ttestName := func(action string, testCase tc) string {\n\t\treturn fmt.Sprintf(\"%s request returns %d when adminEnabled: %t and externalEnabled: %t\",\n\t\t\taction, testCase.expectedHTTPStatus, testCase.pluginAdminEnabled, testCase.pluginAdminExternalManageEnabled)\n\t}\n\n\tps := fakePluginStore{\n\t\tplugins: make(map[string]plugins.PluginDTO),\n\t}\n\tfor _, tc := range tcs {\n\t\tsrv := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\t\ths.Cfg = &setting.Cfg{\n\t\t\t\tPluginAdminEnabled:               tc.pluginAdminEnabled,\n\t\t\t\tPluginAdminExternalManageEnabled: tc.pluginAdminExternalManageEnabled,\n\t\t\t}\n\t\t\ths.pluginStore = ps\n\t\t})\n\n\t\tt.Run(testName(\"Install\", tc), func(t *testing.T) {\n\t\t\treq := srv.NewPostRequest(\"/api/plugins/test/install\", strings.NewReader(\"{ \\\"version\\\": \\\"1.0.2\\\" }\"))\n\t\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_EDITOR, IsGrafanaAdmin: true})\n\t\t\tresp, err := srv.SendJSON(req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tbody := new(strings.Builder)\n\t\t\t_, err = io.Copy(body, resp.Body)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.expectedHTTPBody, body.String())\n\t\t\trequire.NoError(t, resp.Body.Close())\n\t\t\trequire.Equal(t, tc.expectedHTTPStatus, resp.StatusCode)\n\n\t\t\tif tc.expectedHTTPStatus == 200 {\n\t\t\t\trequire.Equal(t, plugins.PluginDTO{\n\t\t\t\t\tJSONData: plugins.JSONData{\n\t\t\t\t\t\tID: \"test\",\n\t\t\t\t\t\tInfo: plugins.Info{\n\t\t\t\t\t\t\tVersion: \"1.0.2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}, ps.plugins[\"test\"])\n\t\t\t}\n\t\t})\n\n\t\tt.Run(testName(\"Uninstall\", tc), func(t *testing.T) {\n\t\t\treq := srv.NewPostRequest(\"/api/plugins/test/uninstall\", strings.NewReader(\"{}\"))\n\t\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER, IsGrafanaAdmin: true})\n\t\t\tresp, err := srv.SendJSON(req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tbody := new(strings.Builder)\n\t\t\t_, err = io.Copy(body, resp.Body)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.expectedHTTPBody, body.String())\n\t\t\trequire.NoError(t, resp.Body.Close())\n\t\t\trequire.Equal(t, tc.expectedHTTPStatus, resp.StatusCode)\n\n\t\t\tif tc.expectedHTTPStatus == 200 {\n\t\t\t\trequire.Empty(t, ps.plugins)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_GetPluginAssets(t *testing.T) {\n\tpluginID := \"test-plugin\"\n\tpluginDir := \".\"\n\ttmpFile, err := ioutil.TempFile(pluginDir, \"\")\n\trequire.NoError(t, err)\n\ttmpFileInParentDir, err := ioutil.TempFile(\"..\", \"\")\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\terr := os.RemoveAll(tmpFile.Name())\n\t\tassert.NoError(t, err)\n\t\terr = os.RemoveAll(tmpFileInParentDir.Name())\n\t\tassert.NoError(t, err)\n\t})\n\texpectedBody := \"Plugin test\"\n\t_, err = tmpFile.WriteString(expectedBody)\n\tassert.NoError(t, err)\n\n\trequestedFile := filepath.Clean(tmpFile.Name())\n\n\tt.Run(\"Given a request for an existing plugin file that is listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t\tSignedFiles: map[string]struct{}{\n\t\t\t\trequestedFile: {},\n\t\t\t},\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a relative path\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, tmpFileInParentDir.Name())\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an existing plugin file that is not listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin file not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a core plugin's file\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: {\n\t\t\t\t\tClass: plugins.Core,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n}\n\nfunc TestMakePluginResourceRequest(t *testing.T) {\n\tpluginClient := &fakePluginClient{}\n\ths := HTTPServer{\n\t\tCfg:          setting.NewCfg(),\n\t\tlog:          log.New(),\n\t\tpluginClient: pluginClient,\n\t}\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tresp := httptest.NewRecorder()\n\tpCtx := backend.PluginContext{}\n\terr := hs.makePluginResourceRequest(resp, req, pCtx)\n\trequire.NoError(t, err)\n\n\tfor {\n\t\tif resp.Flushed {\n\t\t\tbreak\n\t\t}\n\t}\n\n\trequire.Equal(t, \"sandbox\", resp.Header().Get(\"Content-Security-Policy\"))\n}\n\nfunc callGetPluginAsset(sc *scenarioContext) {\n\tsc.fakeReqWithParams(\"GET\", sc.url, map[string]string{}).exec()\n}\n\nfunc pluginAssetScenario(t *testing.T, desc string, url string, urlPattern string, pluginStore plugins.Store,\n\tlogger log.Logger, fn scenarioFunc) {\n\tt.Run(fmt.Sprintf(\"%s %s\", desc, url), func(t *testing.T) {\n\t\ths := HTTPServer{\n\t\t\tCfg:         setting.NewCfg(),\n\t\t\tpluginStore: pluginStore,\n\t\t\tlog:         logger,\n\t\t}\n\n\t\tsc := setupScenarioContext(t, url)\n\t\tsc.defaultHandler = func(c *models.ReqContext) {\n\t\t\tsc.context = c\n\t\t\ths.getPluginAssets(c)\n\t\t}\n\n\t\tsc.m.Get(urlPattern, sc.defaultHandler)\n\n\t\tfn(sc)\n\t})\n}\n\ntype logger struct {\n\tlog.Logger\n\n\twarnings []string\n}\n\nfunc (l *logger) Warn(msg string, ctx ...interface{}) {\n\tl.warnings = append(l.warnings, msg)\n}\n\ntype fakePluginClient struct {\n\tplugins.Client\n\n\treq *backend.CallResourceRequest\n\n\tbackend.QueryDataHandlerFunc\n}\n\nfunc (c *fakePluginClient) CallResource(_ context.Context, req *backend.CallResourceRequest, sender backend.CallResourceResponseSender) error {\n\tc.req = req\n\tbytes, err := json.Marshal(map[string]interface{}{\n\t\t\"message\": \"hello\",\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn sender.Send(&backend.CallResourceResponse{\n\t\tStatus:  http.StatusOK,\n\t\tHeaders: make(map[string][]string),\n\t\tBody:    bytes,\n\t})\n}\n\nfunc (c *fakePluginClient) QueryData(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tif c.QueryDataHandlerFunc != nil {\n\t\treturn c.QueryDataHandlerFunc.QueryData(ctx, req)\n\t}\n\n\treturn backend.NewQueryDataResponse(), nil\n}\n", "package middleware\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/services/login/logintest\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestMiddlewareBasicAuth(t *testing.T) {\n\tconst id int64 = 12\n\n\tconfigure := func(cfg *setting.Cfg) {\n\t\tcfg.BasicAuthEnabled = true\n\t\tcfg.DisableBruteForceLoginProtection = true\n\t}\n\n\tmiddlewareScenario(t, \"Valid API key\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst orgID int64 = 2\n\t\tkeyhash, err := util.EncodePassword(\"v5nAwpMafFP6znaS4urhdWDLS5511M42\", \"asd\")\n\t\trequire.NoError(t, err)\n\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: orgID, Role: models.ROLE_EDITOR, Key: keyhash}\n\n\t\tauthHeader := util.GetBasicAuthHeader(\"api_key\", \"eyJrIjoidjVuQXdwTWFmRlA2em5hUzR1cmhkV0RMUzU1MTFNNDIiLCJuIjoiYXNkIiwiaWQiOjF9\")\n\t\tsc.fakeReq(\"GET\", \"/\").withAuthorizationHeader(authHeader).exec()\n\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Handle auth\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst password = \"MyPass\"\n\t\tconst orgID int64 = 2\n\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: id}\n\n\t\tauthHeader := util.GetBasicAuthHeader(\"myUser\", password)\n\t\tsc.fakeReq(\"GET\", \"/\").withAuthorizationHeader(authHeader).exec()\n\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Auth sequence\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst password = \"MyPass\"\n\t\tconst salt = \"Salt\"\n\n\t\tencoded, err := util.EncodePassword(password, salt)\n\t\trequire.NoError(t, err)\n\n\t\tsc.mockSQLStore.ExpectedUser = &models.User{Password: encoded, Id: id, Salt: salt}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id}\n\t\tlogin.ProvideService(sc.mockSQLStore, &logintest.LoginServiceFake{})\n\n\t\tauthHeader := util.GetBasicAuthHeader(\"myUser\", password)\n\t\tsc.fakeReq(\"GET\", \"/\").withAuthorizationHeader(authHeader).exec()\n\t\trequire.NotNil(t, sc.context)\n\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Should return error if user is not found\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.mockSQLStore.ExpectedError = models.ErrUserNotFound\n\t\tsc.fakeReq(\"GET\", \"/\")\n\t\tsc.req.SetBasicAuth(\"user\", \"password\")\n\t\tsc.exec()\n\n\t\terr := json.NewDecoder(sc.resp.Body).Decode(&sc.respJson)\n\t\trequire.Error(t, err)\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidUsernamePassword, sc.respJson[\"message\"])\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Should return error if user & password do not match\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.mockSQLStore.ExpectedError = models.ErrUserNotFound\n\t\tsc.fakeReq(\"GET\", \"/\")\n\t\tsc.req.SetBasicAuth(\"killa\", \"gorilla\")\n\t\tsc.exec()\n\n\t\terr := json.NewDecoder(sc.resp.Body).Decode(&sc.respJson)\n\t\trequire.Error(t, err)\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidUsernamePassword, sc.respJson[\"message\"])\n\t}, configure)\n}\n", "package middleware\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n)\n\nfunc TestMiddlewareJWTAuth(t *testing.T) {\n\tconst id int64 = 12\n\tconst orgID int64 = 2\n\n\tconfigure := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthEnabled = true\n\t\tcfg.JWTAuthHeaderName = \"x-jwt-assertion\"\n\t}\n\n\tconfigureUsernameClaim := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthUsernameClaim = \"foo-username\"\n\t}\n\n\tconfigureEmailClaim := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthEmailClaim = \"foo-email\"\n\t}\n\n\tconfigureAutoSignUp := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthAutoSignUp = true\n\t}\n\n\ttoken := \"some-token\"\n\n\tmiddlewareScenario(t, \"Valid token with valid login claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyUsername := \"vladimir\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":          myUsername,\n\t\t\t\t\"foo-username\": myUsername,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id, OrgId: orgID, Login: myUsername}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tassert.Equal(t, myUsername, sc.context.Login)\n\t}, configure, configureUsernameClaim)\n\n\tmiddlewareScenario(t, \"Valid token with valid email claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyEmail := \"vladimir@example.com\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":       myEmail,\n\t\t\t\t\"foo-email\": myEmail,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id, OrgId: orgID, Email: myEmail}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tassert.Equal(t, myEmail, sc.context.Email)\n\t}, configure, configureEmailClaim)\n\n\tmiddlewareScenario(t, \"Valid token with no user and auto_sign_up disabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyEmail := \"vladimir@example.com\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":       myEmail,\n\t\t\t\t\"name\":      \"Vladimir Example\",\n\t\t\t\t\"foo-email\": myEmail,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedError = models.ErrUserNotFound\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.UserNotFound, sc.respJson[\"message\"])\n\t}, configure, configureEmailClaim)\n\n\tmiddlewareScenario(t, \"Valid token with no user and auto_sign_up enabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyEmail := \"vladimir@example.com\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":       myEmail,\n\t\t\t\t\"name\":      \"Vladimir Example\",\n\t\t\t\t\"foo-email\": myEmail,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id, OrgId: orgID, Email: myEmail}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tassert.Equal(t, myEmail, sc.context.Email)\n\t}, configure, configureEmailClaim, configureAutoSignUp)\n\n\tmiddlewareScenario(t, \"Valid token without a login claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\": \"baz\",\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidJWT, sc.respJson[\"message\"])\n\t}, configure, configureUsernameClaim)\n\n\tmiddlewareScenario(t, \"Valid token without a email claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\": \"baz\",\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidJWT, sc.respJson[\"message\"])\n\t}, configure, configureEmailClaim)\n\n\tmiddlewareScenario(t, \"Invalid token\", func(t *testing.T, sc *scenarioContext) {\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn nil, errors.New(\"token is invalid\")\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidJWT, sc.respJson[\"message\"])\n\t}, configure, configureUsernameClaim)\n}\n", "package middleware\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/gtime\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/infra/remotecache\"\n\t\"github.com/grafana/grafana/pkg/infra/tracing\"\n\t\"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/auth\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler/authproxy\"\n\t\"github.com/grafana/grafana/pkg/services/login/loginservice\"\n\t\"github.com/grafana/grafana/pkg/services/login/logintest\"\n\t\"github.com/grafana/grafana/pkg/services/rendering\"\n\t\"github.com/grafana/grafana/pkg/services/sqlstore/mockstore\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/web\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc fakeGetTime() func() time.Time {\n\tvar timeSeed int64\n\treturn func() time.Time {\n\t\tfakeNow := time.Unix(timeSeed, 0)\n\t\ttimeSeed++\n\t\treturn fakeNow\n\t}\n}\n\nfunc TestMiddleWareSecurityHeaders(t *testing.T) {\n\tmiddlewareScenario(t, \"middleware should get correct x-xss-protection header\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"1; mode=block\", sc.resp.Header().Get(\"X-XSS-Protection\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.XSSProtectionHeader = true\n\t})\n\n\tmiddlewareScenario(t, \"middleware should not get x-xss-protection when disabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Empty(t, sc.resp.Header().Get(\"X-XSS-Protection\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.XSSProtectionHeader = false\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add correct Strict-Transport-Security header\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"max-age=64000\", sc.resp.Header().Get(\"Strict-Transport-Security\"))\n\t\tsc.cfg.StrictTransportSecurityPreload = true\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"max-age=64000; preload\", sc.resp.Header().Get(\"Strict-Transport-Security\"))\n\t\tsc.cfg.StrictTransportSecuritySubDomains = true\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"max-age=64000; preload; includeSubDomains\", sc.resp.Header().Get(\"Strict-Transport-Security\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.StrictTransportSecurity = true\n\t\tcfg.StrictTransportSecurityMaxAge = 64000\n\t})\n}\n\nfunc TestMiddlewareContext(t *testing.T) {\n\tconst noCache = \"no-cache\"\n\n\tmiddlewareScenario(t, \"middleware should add context to injector\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\tassert.NotNil(t, sc.context)\n\t})\n\n\tmiddlewareScenario(t, \"Default middleware should allow get request\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add Cache-Control header for requests to API\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/search\").exec()\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Cache-Control\"))\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Pragma\"))\n\t\tassert.Equal(t, \"-1\", sc.resp.Header().Get(\"Expires\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should not add Cache-Control header for requests to datasource proxy API\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/datasources/proxy/1/test\").exec()\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Cache-Control\"))\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Pragma\"))\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Expires\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add Cache-Control header for requests with HTML response\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.handlerFunc = func(c *models.ReqContext) {\n\t\t\tt.Log(\"Handler called\")\n\t\t\tdata := &dtos.IndexViewData{\n\t\t\t\tUser:     &dtos.CurrentUser{},\n\t\t\t\tSettings: map[string]interface{}{},\n\t\t\t\tNavTree:  []*dtos.NavLink{},\n\t\t\t}\n\t\t\tt.Log(\"Calling HTML\", \"data\", data)\n\t\t\tc.HTML(200, \"index-template\", data)\n\t\t\tt.Log(\"Returned HTML with code 200\")\n\t\t}\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Cache-Control\"))\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Pragma\"))\n\t\tassert.Equal(t, \"-1\", sc.resp.Header().Get(\"Expires\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add X-Frame-Options header with deny for request when not allowing embedding\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/search\").exec()\n\t\tassert.Equal(t, \"deny\", sc.resp.Header().Get(\"X-Frame-Options\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should not add X-Frame-Options header for request when allowing embedding\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/search\").exec()\n\t\tassert.Empty(t, sc.resp.Header().Get(\"X-Frame-Options\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.AllowEmbedding = true\n\t})\n\n\tmiddlewareScenario(t, \"Invalid api key\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.apiKey = \"invalid_key_test\"\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Set-Cookie\"))\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidAPIKey, sc.respJson[\"message\"])\n\t})\n\n\tmiddlewareScenario(t, \"Valid API key\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst orgID int64 = 12\n\t\tkeyhash, err := util.EncodePassword(\"v5nAwpMafFP6znaS4urhdWDLS5511M42\", \"asd\")\n\t\trequire.NoError(t, err)\n\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: orgID, Role: models.ROLE_EDITOR, Key: keyhash}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withValidApiKey().exec()\n\n\t\trequire.Equal(t, 200, sc.resp.Code)\n\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n\t})\n\n\tmiddlewareScenario(t, \"Valid API key, but does not match DB hash\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst keyhash = \"Something_not_matching\"\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: 12, Role: models.ROLE_EDITOR, Key: keyhash}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withValidApiKey().exec()\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidAPIKey, sc.respJson[\"message\"])\n\t})\n\n\tmiddlewareScenario(t, \"Valid API key, but expired\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.contextHandler.GetTime = fakeGetTime()\n\n\t\tkeyhash, err := util.EncodePassword(\"v5nAwpMafFP6znaS4urhdWDLS5511M42\", \"asd\")\n\t\trequire.NoError(t, err)\n\n\t\texpires := sc.contextHandler.GetTime().Add(-1 * time.Second).Unix()\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: 12, Role: models.ROLE_EDITOR, Key: keyhash, Expires: &expires}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withValidApiKey().exec()\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, \"Expired API key\", sc.respJson[\"message\"])\n\t})\n\n\tmiddlewareScenario(t, \"Non-expired auth token in cookie which is not being rotated\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tconst userID int64 = 12\n\n\t\tsc.withTokenSessionCookie(\"token\")\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: 2, UserId: userID}\n\n\t\tsc.userAuthTokenService.LookupTokenProvider = func(ctx context.Context, unhashedToken string) (*models.UserToken, error) {\n\t\t\treturn &models.UserToken{\n\t\t\t\tUserId:        userID,\n\t\t\t\tUnhashedToken: unhashedToken,\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\trequire.NotNil(t, sc.context)\n\t\trequire.NotNil(t, sc.context.UserToken)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\tassert.Equal(t, userID, sc.context.UserToken.UserId)\n\t\tassert.Equal(t, \"token\", sc.context.UserToken.UnhashedToken)\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Set-Cookie\"))\n\t})\n\n\tmiddlewareScenario(t, \"Non-expired auth token in cookie which is being rotated\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst userID int64 = 12\n\n\t\tsc.withTokenSessionCookie(\"token\")\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: 2, UserId: userID}\n\n\t\tsc.userAuthTokenService.LookupTokenProvider = func(ctx context.Context, unhashedToken string) (*models.UserToken, error) {\n\t\t\treturn &models.UserToken{\n\t\t\t\tUserId:        userID,\n\t\t\t\tUnhashedToken: \"\",\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.userAuthTokenService.TryRotateTokenProvider = func(ctx context.Context, userToken *models.UserToken,\n\t\t\tclientIP net.IP, userAgent string) (bool, error) {\n\t\t\tuserToken.UnhashedToken = \"rotated\"\n\t\t\treturn true, nil\n\t\t}\n\n\t\tmaxAge := int(sc.cfg.LoginMaxLifetime.Seconds())\n\n\t\tsameSiteModes := []http.SameSite{\n\t\t\thttp.SameSiteNoneMode,\n\t\t\thttp.SameSiteLaxMode,\n\t\t\thttp.SameSiteStrictMode,\n\t\t}\n\t\tfor _, sameSiteMode := range sameSiteModes {\n\t\t\tt.Run(fmt.Sprintf(\"Same site mode %d\", sameSiteMode), func(t *testing.T) {\n\t\t\t\torigCookieSameSiteMode := setting.CookieSameSiteMode\n\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\tsetting.CookieSameSiteMode = origCookieSameSiteMode\n\t\t\t\t})\n\t\t\t\tsetting.CookieSameSiteMode = sameSiteMode\n\n\t\t\t\texpectedCookiePath := \"/\"\n\t\t\t\tif len(sc.cfg.AppSubURL) > 0 {\n\t\t\t\t\texpectedCookiePath = sc.cfg.AppSubURL\n\t\t\t\t}\n\t\t\t\texpectedCookie := &http.Cookie{\n\t\t\t\t\tName:     sc.cfg.LoginCookieName,\n\t\t\t\t\tValue:    \"rotated\",\n\t\t\t\t\tPath:     expectedCookiePath,\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tMaxAge:   maxAge,\n\t\t\t\t\tSecure:   setting.CookieSecure,\n\t\t\t\t\tSameSite: sameSiteMode,\n\t\t\t\t}\n\n\t\t\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\t\tassert.Equal(t, userID, sc.context.UserToken.UserId)\n\t\t\t\tassert.Equal(t, \"rotated\", sc.context.UserToken.UnhashedToken)\n\t\t\t\tassert.Equal(t, expectedCookie.String(), sc.resp.Header().Get(\"Set-Cookie\"))\n\t\t\t})\n\t\t}\n\n\t\tt.Run(\"Should not set cookie with SameSite attribute when setting.CookieSameSiteDisabled is true\", func(t *testing.T) {\n\t\t\torigCookieSameSiteDisabled := setting.CookieSameSiteDisabled\n\t\t\torigCookieSameSiteMode := setting.CookieSameSiteMode\n\t\t\tt.Cleanup(func() {\n\t\t\t\tsetting.CookieSameSiteDisabled = origCookieSameSiteDisabled\n\t\t\t\tsetting.CookieSameSiteMode = origCookieSameSiteMode\n\t\t\t})\n\t\t\tsetting.CookieSameSiteDisabled = true\n\t\t\tsetting.CookieSameSiteMode = http.SameSiteLaxMode\n\n\t\t\texpectedCookiePath := \"/\"\n\t\t\tif len(sc.cfg.AppSubURL) > 0 {\n\t\t\t\texpectedCookiePath = sc.cfg.AppSubURL\n\t\t\t}\n\t\t\texpectedCookie := &http.Cookie{\n\t\t\t\tName:     sc.cfg.LoginCookieName,\n\t\t\t\tValue:    \"rotated\",\n\t\t\t\tPath:     expectedCookiePath,\n\t\t\t\tHttpOnly: true,\n\t\t\t\tMaxAge:   maxAge,\n\t\t\t\tSecure:   setting.CookieSecure,\n\t\t\t}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\t\tassert.Equal(t, expectedCookie.String(), sc.resp.Header().Get(\"Set-Cookie\"))\n\t\t})\n\t})\n\n\tmiddlewareScenario(t, \"Invalid/expired auth token in cookie\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.withTokenSessionCookie(\"token\")\n\n\t\tsc.userAuthTokenService.LookupTokenProvider = func(ctx context.Context, unhashedToken string) (*models.UserToken, error) {\n\t\t\treturn nil, models.ErrUserTokenNotFound\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\tassert.False(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, int64(0), sc.context.UserId)\n\t\tassert.Nil(t, sc.context.UserToken)\n\t})\n\n\tmiddlewareScenario(t, \"When anonymous access is enabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.mockSQLStore.ExpectedOrg = &models.Org{Id: 1, Name: sc.cfg.AnonymousOrgName}\n\t\torg, err := sc.mockSQLStore.CreateOrgWithMember(sc.cfg.AnonymousOrgName, 1)\n\t\trequire.NoError(t, err)\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\tassert.Equal(t, int64(0), sc.context.UserId)\n\t\tassert.Equal(t, org.Id, sc.context.OrgId)\n\t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n\t\tassert.False(t, sc.context.IsSignedIn)\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.AnonymousEnabled = true\n\t\tcfg.AnonymousOrgName = \"test\"\n\t\tcfg.AnonymousOrgRole = string(models.ROLE_EDITOR)\n\t})\n\n\tt.Run(\"auth_proxy\", func(t *testing.T) {\n\t\tconst userID int64 = 33\n\t\tconst orgID int64 = 4\n\t\tconst defaultOrgId int64 = 1\n\t\tconst orgRole = \"Admin\"\n\n\t\tconfigure := func(cfg *setting.Cfg) {\n\t\t\tcfg.AuthProxyEnabled = true\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t\tcfg.LDAPEnabled = true\n\t\t\tcfg.AuthProxyHeaderName = \"X-WEBAUTH-USER\"\n\t\t\tcfg.AuthProxyHeaderProperty = \"username\"\n\t\t\tcfg.AuthProxyHeaders = map[string]string{\"Groups\": \"X-WEBAUTH-GROUPS\", \"Role\": \"X-WEBAUTH-ROLE\"}\n\t\t}\n\n\t\tconst hdrName = \"markelog\"\n\t\tconst group = \"grafana-core-team\"\n\n\t\tmiddlewareScenario(t, \"Should not sync the user if it's in the cache\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\n\t\t\th, err := authproxy.HashCacheKey(hdrName + \"-\" + group)\n\t\t\trequire.NoError(t, err)\n\t\t\tkey := fmt.Sprintf(authproxy.CachePrefix, h)\n\t\t\terr = sc.remoteCacheService.Set(context.Background(), key, userID, 0)\n\t\t\trequire.NoError(t, err)\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"X-WEBAUTH-GROUPS\", group)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, configure)\n\n\t\tmiddlewareScenario(t, \"Should respect auto signup option\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar actualAuthProxyAutoSignUp *bool = nil\n\t\t\tsc.loginService.ExpectedUserFunc = func(cmd *models.UpsertUserCommand) *models.User {\n\t\t\t\tactualAuthProxyAutoSignUp = &cmd.SignupAllowed\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tsc.loginService.ExpectedError = login.ErrInvalidCredentials\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.False(t, *actualAuthProxyAutoSignUp)\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should create an user from a header\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should assign role from header to default org\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar storedRoleInfo map[int64]models.RoleType = nil\n\t\t\tsc.loginService.ExpectedUserFunc = func(cmd *models.UpsertUserCommand) *models.User {\n\t\t\t\tstoredRoleInfo = cmd.ExternalUser.OrgRoles\n\t\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: defaultOrgId, UserId: userID, OrgRole: storedRoleInfo[defaultOrgId]}\n\t\t\t\treturn &models.User{Id: userID}\n\t\t\t}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"X-WEBAUTH-ROLE\", orgRole)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, defaultOrgId, sc.context.OrgId)\n\t\t\tassert.Equal(t, orgRole, string(sc.context.OrgRole))\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should NOT assign role from header to non-default org\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar storedRoleInfo map[int64]models.RoleType = nil\n\t\t\tsc.loginService.ExpectedUserFunc = func(cmd *models.UpsertUserCommand) *models.User {\n\t\t\t\tstoredRoleInfo = cmd.ExternalUser.OrgRoles\n\t\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID, OrgRole: storedRoleInfo[orgID]}\n\t\t\t\treturn &models.User{Id: userID}\n\t\t\t}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"X-WEBAUTH-ROLE\", \"Admin\")\n\t\t\tsc.req.Header.Set(\"X-Grafana-Org-Id\", strconv.FormatInt(orgID, 10))\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\n\t\t\t// For non-default org, the user role should be empty\n\t\t\tassert.Equal(t, \"\", string(sc.context.OrgRole))\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should use organisation specified by targetOrgId parameter\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar targetOrgID int64 = 123\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: targetOrgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", fmt.Sprintf(\"/?targetOrgId=%d\", targetOrgID))\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, targetOrgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Request body should not be read in default context handler\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.fakeReq(\"POST\", \"/?targetOrgId=123\")\n\t\t\tbody := \"key=value\"\n\t\t\tsc.req.Body = io.NopCloser(strings.NewReader(body))\n\n\t\t\tsc.handlerFunc = func(c *models.ReqContext) {\n\t\t\t\tt.Log(\"Handler called\")\n\t\t\t\tdefer func() {\n\t\t\t\t\terr := c.Req.Body.Close()\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}()\n\n\t\t\t\tbodyAfterHandler, e := io.ReadAll(c.Req.Body)\n\t\t\t\trequire.NoError(t, e)\n\t\t\t\trequire.Equal(t, body, string(bodyAfterHandler))\n\t\t\t}\n\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\t\tsc.req.Header.Set(\"Content-Length\", strconv.Itoa(len(body)))\n\t\t\tsc.m.Post(\"/\", sc.defaultHandler)\n\t\t\tsc.exec()\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should get an existing user from header\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tconst userID int64 = 12\n\t\t\tconst orgID int64 = 2\n\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should allow the request from whitelist IP\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.RemoteAddr = \"[2001::23]:12345\"\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.AuthProxyWhitelist = \"192.168.1.0/24, 2001::0/120\"\n\t\t\tcfg.LDAPEnabled = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should not allow the request from whitelisted IP\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.RemoteAddr = \"[2001::23]:12345\"\n\t\t\tsc.exec()\n\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.AuthProxyWhitelist = \"8.8.8.8\"\n\t\t\tcfg.LDAPEnabled = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should return 407 status code if LDAP says no\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, configure)\n\n\t\tmiddlewareScenario(t, \"Should return 407 status code if there is cache mishap\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, configure)\n\t})\n}\n\nfunc middlewareScenario(t *testing.T, desc string, fn scenarioFunc, cbs ...func(*setting.Cfg)) {\n\tt.Helper()\n\n\tt.Run(desc, func(t *testing.T) {\n\t\tlogger := log.New(\"test\")\n\n\t\tloginMaxLifetime, err := gtime.ParseDuration(\"30d\")\n\t\trequire.NoError(t, err)\n\t\tcfg := setting.NewCfg()\n\t\tcfg.LoginCookieName = \"grafana_session\"\n\t\tcfg.LoginMaxLifetime = loginMaxLifetime\n\t\t// Required when rendering errors\n\t\tcfg.ErrTemplateName = \"error-template\"\n\t\tfor _, cb := range cbs {\n\t\t\tcb(cfg)\n\t\t}\n\n\t\tsc := &scenarioContext{t: t, cfg: cfg}\n\t\tviewsPath, err := filepath.Abs(\"../../public/views\")\n\t\trequire.NoError(t, err)\n\t\texists, err := fs.Exists(viewsPath)\n\t\trequire.NoError(t, err)\n\t\trequire.Truef(t, exists, \"Views directory should exist at %q\", viewsPath)\n\n\t\tsc.m = web.New()\n\t\tsc.m.Use(AddDefaultResponseHeaders(cfg))\n\t\tsc.m.UseMiddleware(AddCSPHeader(cfg, logger))\n\t\tsc.m.UseMiddleware(web.Renderer(viewsPath, \"[[\", \"]]\"))\n\n\t\tsc.mockSQLStore = mockstore.NewSQLStoreMock()\n\t\tsc.loginService = &loginservice.LoginServiceMock{}\n\t\tctxHdlr := getContextHandler(t, cfg, sc.mockSQLStore, sc.loginService)\n\t\tsc.sqlStore = ctxHdlr.SQLStore\n\t\tsc.contextHandler = ctxHdlr\n\t\tsc.m.Use(ctxHdlr.Middleware)\n\t\tsc.m.Use(OrgRedirect(sc.cfg, sc.mockSQLStore))\n\n\t\tsc.userAuthTokenService = ctxHdlr.AuthTokenService.(*auth.FakeUserAuthTokenService)\n\t\tsc.jwtAuthService = ctxHdlr.JWTAuthService.(*models.FakeJWTService)\n\t\tsc.remoteCacheService = ctxHdlr.RemoteCache\n\n\t\tsc.defaultHandler = func(c *models.ReqContext) {\n\t\t\trequire.NotNil(t, c)\n\t\t\tt.Log(\"Default HTTP handler called\")\n\t\t\tsc.context = c\n\t\t\tif sc.handlerFunc != nil {\n\t\t\t\tsc.handlerFunc(sc.context)\n\t\t\t} else {\n\t\t\t\tt.Log(\"Returning JSON OK\")\n\t\t\t\tresp := make(map[string]interface{})\n\t\t\t\tresp[\"message\"] = \"OK\"\n\t\t\t\tc.JSON(200, resp)\n\t\t\t}\n\t\t}\n\n\t\tsc.m.Get(\"/\", sc.defaultHandler)\n\n\t\tfn(t, sc)\n\t})\n}\n\nfunc getContextHandler(t *testing.T, cfg *setting.Cfg, mockSQLStore *mockstore.SQLStoreMock, loginService *loginservice.LoginServiceMock) *contexthandler.ContextHandler {\n\tt.Helper()\n\n\tif cfg == nil {\n\t\tcfg = setting.NewCfg()\n\t}\n\tcfg.RemoteCacheOptions = &setting.RemoteCacheOptions{\n\t\tName: \"database\",\n\t}\n\n\tremoteCacheSvc := remotecache.NewFakeStore(t)\n\tuserAuthTokenSvc := auth.NewFakeUserAuthTokenService()\n\trenderSvc := &fakeRenderService{}\n\tauthJWTSvc := models.NewFakeJWTService()\n\ttracer, err := tracing.InitializeTracerForTest()\n\tauthProxy := authproxy.ProvideAuthProxy(cfg, remoteCacheSvc, loginService, mockSQLStore)\n\tauthenticator := &logintest.AuthenticatorFake{ExpectedUser: &models.User{}}\n\trequire.NoError(t, err)\n\treturn contexthandler.ProvideService(cfg, userAuthTokenSvc, authJWTSvc, remoteCacheSvc, renderSvc, mockSQLStore, tracer, authProxy, loginService, authenticator)\n}\n\ntype fakeRenderService struct {\n\trendering.Service\n}\n\nfunc (s *fakeRenderService) Init() error {\n\treturn nil\n}\n", "package contexthandler\n\nimport (\n\t\"errors\"\n\n\t\"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/models\"\n)\n\nconst InvalidJWT = \"Invalid JWT\"\nconst UserNotFound = \"User not found\"\n\nfunc (h *ContextHandler) initContextWithJWT(ctx *models.ReqContext, orgId int64) bool {\n\tif !h.Cfg.JWTAuthEnabled || h.Cfg.JWTAuthHeaderName == \"\" {\n\t\treturn false\n\t}\n\n\tjwtToken := ctx.Req.Header.Get(h.Cfg.JWTAuthHeaderName)\n\tif jwtToken == \"\" {\n\t\treturn false\n\t}\n\n\tclaims, err := h.JWTAuthService.Verify(ctx.Req.Context(), jwtToken)\n\tif err != nil {\n\t\tctx.Logger.Debug(\"Failed to verify JWT\", \"error\", err)\n\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\treturn true\n\t}\n\n\tquery := models.GetSignedInUserQuery{OrgId: orgId}\n\n\tsub, _ := claims[\"sub\"].(string)\n\n\tif sub == \"\" {\n\t\tctx.Logger.Warn(\"Got a JWT without the mandatory 'sub' claim\", \"error\", err)\n\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\treturn true\n\t}\n\textUser := &models.ExternalUserInfo{\n\t\tAuthModule: \"jwt\",\n\t\tAuthId:     sub,\n\t}\n\n\tif key := h.Cfg.JWTAuthUsernameClaim; key != \"\" {\n\t\tquery.Login, _ = claims[key].(string)\n\t\textUser.Login, _ = claims[key].(string)\n\t}\n\tif key := h.Cfg.JWTAuthEmailClaim; key != \"\" {\n\t\tquery.Email, _ = claims[key].(string)\n\t\textUser.Email, _ = claims[key].(string)\n\t}\n\n\tif name, _ := claims[\"name\"].(string); name != \"\" {\n\t\textUser.Name = name\n\t}\n\n\tif query.Login == \"\" && query.Email == \"\" {\n\t\tctx.Logger.Debug(\"Failed to get an authentication claim from JWT\")\n\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\treturn true\n\t}\n\n\tif h.Cfg.JWTAuthAutoSignUp {\n\t\tupsert := &models.UpsertUserCommand{\n\t\t\tReqContext:    ctx,\n\t\t\tSignupAllowed: h.Cfg.JWTAuthAutoSignUp,\n\t\t\tExternalUser:  extUser,\n\t\t\tUserLookupParams: models.UserLookupParams{\n\t\t\t\tUserID: nil,\n\t\t\t\tLogin:  &query.Login,\n\t\t\t\tEmail:  &query.Email,\n\t\t\t},\n\t\t}\n\t\tif err := h.loginService.UpsertUser(ctx.Req.Context(), upsert); err != nil {\n\t\t\tctx.Logger.Error(\"Failed to upsert JWT user\", \"error\", err)\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(ctx.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tctx.Logger.Debug(\n\t\t\t\t\"Failed to find user using JWT claims\",\n\t\t\t\t\"email_claim\", query.Email,\n\t\t\t\t\"username_claim\", query.Login,\n\t\t\t)\n\t\t\terr = login.ErrInvalidCredentials\n\t\t\tctx.JsonApiErr(401, UserNotFound, err)\n\t\t} else {\n\t\t\tctx.Logger.Error(\"Failed to get signed in user\", \"error\", err)\n\t\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\t}\n\t\treturn true\n\t}\n\n\tctx.SignedInUser = query.Result\n\tctx.IsSignedIn = true\n\n\treturn true\n}\n", "// Package contexthandler contains the ContextHandler service.\npackage contexthandler\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/components/apikeygen\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/infra/network\"\n\t\"github.com/grafana/grafana/pkg/infra/remotecache\"\n\t\"github.com/grafana/grafana/pkg/infra/tracing\"\n\tloginpkg \"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/middleware/cookies\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler/authproxy\"\n\t\"github.com/grafana/grafana/pkg/services/login\"\n\t\"github.com/grafana/grafana/pkg/services/rendering\"\n\t\"github.com/grafana/grafana/pkg/services/sqlstore\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nconst (\n\tInvalidUsernamePassword = \"invalid username or password\"\n\tInvalidAPIKey           = \"invalid API key\"\n)\n\nconst ServiceName = \"ContextHandler\"\n\nfunc ProvideService(cfg *setting.Cfg, tokenService models.UserTokenService, jwtService models.JWTService,\n\tremoteCache *remotecache.RemoteCache, renderService rendering.Service, sqlStore sqlstore.Store,\n\ttracer tracing.Tracer, authProxy *authproxy.AuthProxy, loginService login.Service, authenticator loginpkg.Authenticator) *ContextHandler {\n\treturn &ContextHandler{\n\t\tCfg:              cfg,\n\t\tAuthTokenService: tokenService,\n\t\tJWTAuthService:   jwtService,\n\t\tRemoteCache:      remoteCache,\n\t\tRenderService:    renderService,\n\t\tSQLStore:         sqlStore,\n\t\ttracer:           tracer,\n\t\tauthProxy:        authProxy,\n\t\tauthenticator:    authenticator,\n\t\tloginService:     loginService,\n\t}\n}\n\n// ContextHandler is a middleware.\ntype ContextHandler struct {\n\tCfg              *setting.Cfg\n\tAuthTokenService models.UserTokenService\n\tJWTAuthService   models.JWTService\n\tRemoteCache      *remotecache.RemoteCache\n\tRenderService    rendering.Service\n\tSQLStore         sqlstore.Store\n\ttracer           tracing.Tracer\n\tauthProxy        *authproxy.AuthProxy\n\tauthenticator    loginpkg.Authenticator\n\tloginService     login.Service\n\t// GetTime returns the current time.\n\t// Stubbable by tests.\n\tGetTime func() time.Time\n}\n\ntype reqContextKey struct{}\n\n// FromContext returns the ReqContext value stored in a context.Context, if any.\nfunc FromContext(c context.Context) *models.ReqContext {\n\tif reqCtx, ok := c.Value(reqContextKey{}).(*models.ReqContext); ok {\n\t\treturn reqCtx\n\t}\n\treturn nil\n}\n\n// Middleware provides a middleware to initialize the Macaron context.\nfunc (h *ContextHandler) Middleware(mContext *web.Context) {\n\t_, span := h.tracer.Start(mContext.Req.Context(), \"Auth - Middleware\")\n\tdefer span.End()\n\n\treqContext := &models.ReqContext{\n\t\tContext:        mContext,\n\t\tSignedInUser:   &models.SignedInUser{},\n\t\tIsSignedIn:     false,\n\t\tAllowAnonymous: false,\n\t\tSkipCache:      false,\n\t\tLogger:         log.New(\"context\"),\n\t}\n\n\t// Inject ReqContext into a request context and replace the request instance in the macaron context\n\tmContext.Req = mContext.Req.WithContext(context.WithValue(mContext.Req.Context(), reqContextKey{}, reqContext))\n\tmContext.Map(mContext.Req)\n\n\ttraceID := tracing.TraceIDFromContext(mContext.Req.Context(), false)\n\tif traceID != \"\" {\n\t\treqContext.Logger = reqContext.Logger.New(\"traceID\", traceID)\n\t}\n\n\tconst headerName = \"X-Grafana-Org-Id\"\n\torgID := int64(0)\n\torgIDHeader := reqContext.Req.Header.Get(headerName)\n\tif orgIDHeader != \"\" {\n\t\tid, err := strconv.ParseInt(orgIDHeader, 10, 64)\n\t\tif err == nil {\n\t\t\torgID = id\n\t\t} else {\n\t\t\treqContext.Logger.Debug(\"Received invalid header\", \"header\", headerName, \"value\", orgIDHeader)\n\t\t}\n\t}\n\n\tqueryParameters, err := url.ParseQuery(reqContext.Req.URL.RawQuery)\n\tif err != nil {\n\t\treqContext.Logger.Error(\"Failed to parse query parameters\", \"error\", err)\n\t}\n\tif queryParameters.Has(\"targetOrgId\") {\n\t\ttargetOrg, err := strconv.ParseInt(queryParameters.Get(\"targetOrgId\"), 10, 64)\n\t\tif err == nil {\n\t\t\torgID = targetOrg\n\t\t} else {\n\t\t\treqContext.Logger.Error(\"Invalid target organization ID\", \"error\", err)\n\t\t}\n\t}\n\n\t// the order in which these are tested are important\n\t// look for api key in Authorization header first\n\t// then init session and look for userId in session\n\t// then look for api key in session (special case for render calls via api)\n\t// then test if anonymous access is enabled\n\tswitch {\n\tcase h.initContextWithRenderAuth(reqContext):\n\tcase h.initContextWithAPIKey(reqContext):\n\tcase h.initContextWithBasicAuth(reqContext, orgID):\n\tcase h.initContextWithAuthProxy(reqContext, orgID):\n\tcase h.initContextWithToken(reqContext, orgID):\n\tcase h.initContextWithJWT(reqContext, orgID):\n\tcase h.initContextWithAnonymousUser(reqContext):\n\t}\n\n\treqContext.Logger = reqContext.Logger.New(\"userId\", reqContext.UserId, \"orgId\", reqContext.OrgId, \"uname\", reqContext.Login)\n\tspan.AddEvents(\n\t\t[]string{\"uname\", \"orgId\", \"userId\"},\n\t\t[]tracing.EventValue{\n\t\t\t{Str: reqContext.Login},\n\t\t\t{Num: reqContext.OrgId},\n\t\t\t{Num: reqContext.UserId}},\n\t)\n\n\tmContext.Map(reqContext)\n\n\t// update last seen every 5min\n\tif reqContext.ShouldUpdateLastSeenAt() {\n\t\treqContext.Logger.Debug(\"Updating last user_seen_at\", \"user_id\", reqContext.UserId)\n\t\tif err := h.SQLStore.UpdateUserLastSeenAt(mContext.Req.Context(), &models.UpdateUserLastSeenAtCommand{UserId: reqContext.UserId}); err != nil {\n\t\t\treqContext.Logger.Error(\"Failed to update last_seen_at\", \"error\", err)\n\t\t}\n\t}\n}\n\nfunc (h *ContextHandler) initContextWithAnonymousUser(reqContext *models.ReqContext) bool {\n\tif !h.Cfg.AnonymousEnabled {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithAnonymousUser\")\n\tdefer span.End()\n\n\torg, err := h.SQLStore.GetOrgByName(h.Cfg.AnonymousOrgName)\n\tif err != nil {\n\t\treqContext.Logger.Error(\"Anonymous access organization error.\", \"org_name\", h.Cfg.AnonymousOrgName, \"error\", err)\n\t\treturn false\n\t}\n\n\treqContext.IsSignedIn = false\n\treqContext.AllowAnonymous = true\n\treqContext.SignedInUser = &models.SignedInUser{IsAnonymous: true}\n\treqContext.OrgRole = models.RoleType(h.Cfg.AnonymousOrgRole)\n\treqContext.OrgId = org.Id\n\treqContext.OrgName = org.Name\n\treturn true\n}\n\nfunc (h *ContextHandler) initContextWithAPIKey(reqContext *models.ReqContext) bool {\n\theader := reqContext.Req.Header.Get(\"Authorization\")\n\tparts := strings.SplitN(header, \" \", 2)\n\tvar keyString string\n\tif len(parts) == 2 && parts[0] == \"Bearer\" {\n\t\tkeyString = parts[1]\n\t} else {\n\t\tusername, password, err := util.DecodeBasicAuthHeader(header)\n\t\tif err == nil && username == \"api_key\" {\n\t\t\tkeyString = password\n\t\t}\n\t}\n\n\tif keyString == \"\" {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithAPIKey\")\n\tdefer span.End()\n\n\t// base64 decode key\n\tdecoded, err := apikeygen.Decode(keyString)\n\tif err != nil {\n\t\treqContext.JsonApiErr(401, InvalidAPIKey, err)\n\t\treturn true\n\t}\n\n\t// fetch key\n\tkeyQuery := models.GetApiKeyByNameQuery{KeyName: decoded.Name, OrgId: decoded.OrgId}\n\tif err := h.SQLStore.GetApiKeyByName(reqContext.Req.Context(), &keyQuery); err != nil {\n\t\treqContext.JsonApiErr(401, InvalidAPIKey, err)\n\t\treturn true\n\t}\n\n\tapikey := keyQuery.Result\n\n\t// validate api key\n\tisValid, err := apikeygen.IsValid(decoded, apikey.Key)\n\tif err != nil {\n\t\treqContext.JsonApiErr(500, \"Validating API key failed\", err)\n\t\treturn true\n\t}\n\tif !isValid {\n\t\treqContext.JsonApiErr(401, InvalidAPIKey, err)\n\t\treturn true\n\t}\n\n\t// check for expiration\n\tgetTime := h.GetTime\n\tif getTime == nil {\n\t\tgetTime = time.Now\n\t}\n\tif apikey.Expires != nil && *apikey.Expires <= getTime().Unix() {\n\t\treqContext.JsonApiErr(401, \"Expired API key\", err)\n\t\treturn true\n\t}\n\n\tif apikey.ServiceAccountId == nil || *apikey.ServiceAccountId < 1 { //There is no service account attached to the apikey\n\t\t//Use the old APIkey method.  This provides backwards compatibility.\n\t\treqContext.SignedInUser = &models.SignedInUser{}\n\t\treqContext.OrgRole = apikey.Role\n\t\treqContext.ApiKeyId = apikey.Id\n\t\treqContext.OrgId = apikey.OrgId\n\t\treqContext.IsSignedIn = true\n\t\treturn true\n\t}\n\n\t//There is a service account attached to the API key\n\n\t//Use service account linked to API key as the signed in user\n\tquerySignedInUser := models.GetSignedInUserQuery{UserId: *apikey.ServiceAccountId, OrgId: apikey.OrgId}\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(reqContext.Req.Context(), &querySignedInUser); err != nil {\n\t\treqContext.Logger.Error(\n\t\t\t\"Failed to link API key to service account in\",\n\t\t\t\"id\", querySignedInUser.UserId,\n\t\t\t\"org\", querySignedInUser.OrgId,\n\t\t\t\"err\", err,\n\t\t)\n\t\treqContext.JsonApiErr(http.StatusInternalServerError, \"Unable to link API key to service account\", err)\n\t\treturn true\n\t}\n\n\t// disabled service accounts are not allowed to access the API\n\tif querySignedInUser.Result.IsDisabled {\n\t\treqContext.JsonApiErr(http.StatusUnauthorized, \"Service account is disabled\", nil)\n\t\treturn true\n\t}\n\n\treqContext.IsSignedIn = true\n\treqContext.SignedInUser = querySignedInUser.Result\n\treturn true\n}\n\nfunc (h *ContextHandler) initContextWithBasicAuth(reqContext *models.ReqContext, orgID int64) bool {\n\tif !h.Cfg.BasicAuthEnabled {\n\t\treturn false\n\t}\n\n\theader := reqContext.Req.Header.Get(\"Authorization\")\n\tif header == \"\" {\n\t\treturn false\n\t}\n\n\tctx, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithBasicAuth\")\n\tdefer span.End()\n\n\tusername, password, err := util.DecodeBasicAuthHeader(header)\n\tif err != nil {\n\t\treqContext.JsonApiErr(401, \"Invalid Basic Auth Header\", err)\n\t\treturn true\n\t}\n\n\tauthQuery := models.LoginUserQuery{\n\t\tUsername: username,\n\t\tPassword: password,\n\t\tCfg:      h.Cfg,\n\t}\n\tif err := h.authenticator.AuthenticateUser(reqContext.Req.Context(), &authQuery); err != nil {\n\t\treqContext.Logger.Debug(\n\t\t\t\"Failed to authorize the user\",\n\t\t\t\"username\", username,\n\t\t\t\"err\", err,\n\t\t)\n\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\terr = login.ErrInvalidCredentials\n\t\t}\n\t\treqContext.JsonApiErr(401, InvalidUsernamePassword, err)\n\t\treturn true\n\t}\n\n\tuser := authQuery.User\n\n\tquery := models.GetSignedInUserQuery{UserId: user.Id, OrgId: orgID}\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(ctx, &query); err != nil {\n\t\treqContext.Logger.Error(\n\t\t\t\"Failed at user signed in\",\n\t\t\t\"id\", user.Id,\n\t\t\t\"org\", orgID,\n\t\t)\n\t\treqContext.JsonApiErr(401, InvalidUsernamePassword, err)\n\t\treturn true\n\t}\n\n\treqContext.SignedInUser = query.Result\n\treqContext.IsSignedIn = true\n\treturn true\n}\n\nfunc (h *ContextHandler) initContextWithToken(reqContext *models.ReqContext, orgID int64) bool {\n\tif h.Cfg.LoginCookieName == \"\" {\n\t\treturn false\n\t}\n\n\trawToken := reqContext.GetCookie(h.Cfg.LoginCookieName)\n\tif rawToken == \"\" {\n\t\treturn false\n\t}\n\n\tctx, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithToken\")\n\tdefer span.End()\n\n\ttoken, err := h.AuthTokenService.LookupToken(ctx, rawToken)\n\tif err != nil {\n\t\treqContext.Logger.Error(\"Failed to look up user based on cookie\", \"error\", err)\n\t\treqContext.LookupTokenErr = err\n\t\treturn false\n\t}\n\n\tquery := models.GetSignedInUserQuery{UserId: token.UserId, OrgId: orgID}\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(ctx, &query); err != nil {\n\t\treqContext.Logger.Error(\"Failed to get user with id\", \"userId\", token.UserId, \"error\", err)\n\t\treturn false\n\t}\n\n\treqContext.SignedInUser = query.Result\n\treqContext.IsSignedIn = true\n\treqContext.UserToken = token\n\n\t// Rotate the token just before we write response headers to ensure there is no delay between\n\t// the new token being generated and the client receiving it.\n\treqContext.Resp.Before(h.rotateEndOfRequestFunc(reqContext, h.AuthTokenService, token))\n\n\treturn true\n}\n\nfunc (h *ContextHandler) rotateEndOfRequestFunc(reqContext *models.ReqContext, authTokenService models.UserTokenService,\n\ttoken *models.UserToken) web.BeforeFunc {\n\treturn func(w web.ResponseWriter) {\n\t\t// if response has already been written, skip.\n\t\tif w.Written() {\n\t\t\treturn\n\t\t}\n\n\t\t// if the request is cancelled by the client we should not try\n\t\t// to rotate the token since the client would not accept any result.\n\t\tif errors.Is(reqContext.Context.Req.Context().Err(), context.Canceled) {\n\t\t\treturn\n\t\t}\n\n\t\tctx, span := h.tracer.Start(reqContext.Req.Context(), \"rotateEndOfRequestFunc\")\n\t\tdefer span.End()\n\n\t\taddr := reqContext.RemoteAddr()\n\t\tip, err := network.GetIPFromAddress(addr)\n\t\tif err != nil {\n\t\t\treqContext.Logger.Debug(\"Failed to get client IP address\", \"addr\", addr, \"err\", err)\n\t\t\tip = nil\n\t\t}\n\t\trotated, err := authTokenService.TryRotateToken(ctx, token, ip, reqContext.Req.UserAgent())\n\t\tif err != nil {\n\t\t\treqContext.Logger.Error(\"Failed to rotate token\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif rotated {\n\t\t\tcookies.WriteSessionCookie(reqContext, h.Cfg, token.UnhashedToken, h.Cfg.LoginMaxLifetime)\n\t\t}\n\t}\n}\n\nfunc (h *ContextHandler) initContextWithRenderAuth(reqContext *models.ReqContext) bool {\n\tkey := reqContext.GetCookie(\"renderKey\")\n\tif key == \"\" {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithRenderAuth\")\n\tdefer span.End()\n\n\trenderUser, exists := h.RenderService.GetRenderUser(reqContext.Req.Context(), key)\n\tif !exists {\n\t\treqContext.JsonApiErr(401, \"Invalid Render Key\", nil)\n\t\treturn true\n\t}\n\n\treqContext.IsSignedIn = true\n\treqContext.SignedInUser = &models.SignedInUser{\n\t\tOrgId:   renderUser.OrgID,\n\t\tUserId:  renderUser.UserID,\n\t\tOrgRole: models.RoleType(renderUser.OrgRole),\n\t}\n\treqContext.IsRenderCall = true\n\treqContext.LastSeenAt = time.Now()\n\treturn true\n}\n\nfunc logUserIn(reqContext *models.ReqContext, auth *authproxy.AuthProxy, username string, logger log.Logger, ignoreCache bool) (int64, error) {\n\tlogger.Debug(\"Trying to log user in\", \"username\", username, \"ignoreCache\", ignoreCache)\n\t// Try to log in user via various providers\n\tid, err := auth.Login(reqContext, ignoreCache)\n\tif err != nil {\n\t\tdetails := err\n\t\tvar e authproxy.Error\n\t\tif errors.As(err, &e) {\n\t\t\tdetails = e.DetailsError\n\t\t}\n\t\tlogger.Error(\"Failed to login\", \"username\", username, \"message\", err.Error(), \"error\", details,\n\t\t\t\"ignoreCache\", ignoreCache)\n\t\treturn 0, err\n\t}\n\treturn id, nil\n}\n\nfunc (h *ContextHandler) handleError(ctx *models.ReqContext, err error, statusCode int, cb func(error)) {\n\tdetails := err\n\tvar e authproxy.Error\n\tif errors.As(err, &e) {\n\t\tdetails = e.DetailsError\n\t}\n\tctx.Handle(h.Cfg, statusCode, err.Error(), details)\n\n\tif cb != nil {\n\t\tcb(details)\n\t}\n}\n\nfunc (h *ContextHandler) initContextWithAuthProxy(reqContext *models.ReqContext, orgID int64) bool {\n\tusername := reqContext.Req.Header.Get(h.Cfg.AuthProxyHeaderName)\n\n\tlogger := log.New(\"auth.proxy\")\n\n\t// Bail if auth proxy is not enabled\n\tif !h.authProxy.IsEnabled() {\n\t\treturn false\n\t}\n\n\t// If there is no header - we can't move forward\n\tif !h.authProxy.HasHeader(reqContext) {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithAuthProxy\")\n\tdefer span.End()\n\n\t// Check if allowed continuing with this IP\n\tif err := h.authProxy.IsAllowedIP(reqContext.Req.RemoteAddr); err != nil {\n\t\th.handleError(reqContext, err, 407, func(details error) {\n\t\t\tlogger.Error(\"Failed to check whitelisted IP addresses\", \"message\", err.Error(), \"error\", details)\n\t\t})\n\t\treturn true\n\t}\n\n\tid, err := logUserIn(reqContext, h.authProxy, username, logger, false)\n\tif err != nil {\n\t\th.handleError(reqContext, err, 407, nil)\n\t\treturn true\n\t}\n\n\tlogger.Debug(\"Got user ID, getting full user info\", \"userID\", id)\n\n\tuser, err := h.authProxy.GetSignedInUser(id, orgID)\n\tif err != nil {\n\t\t// The reason we couldn't find the user corresponding to the ID might be that the ID was found from a stale\n\t\t// cache entry. For example, if a user is deleted via the API, corresponding cache entries aren't invalidated\n\t\t// because cache keys are computed from request header values and not just the user ID. Meaning that\n\t\t// we can't easily derive cache keys to invalidate when deleting a user. To work around this, we try to\n\t\t// log the user in again without the cache.\n\t\tlogger.Debug(\"Failed to get user info given ID, retrying without cache\", \"userID\", id)\n\t\tif err := h.authProxy.RemoveUserFromCache(reqContext); err != nil {\n\t\t\tif !errors.Is(err, remotecache.ErrCacheItemNotFound) {\n\t\t\t\tlogger.Error(\"Got unexpected error when removing user from auth cache\", \"error\", err)\n\t\t\t}\n\t\t}\n\t\tid, err = logUserIn(reqContext, h.authProxy, username, logger, true)\n\t\tif err != nil {\n\t\t\th.handleError(reqContext, err, 407, nil)\n\t\t\treturn true\n\t\t}\n\n\t\tuser, err = h.authProxy.GetSignedInUser(id, orgID)\n\t\tif err != nil {\n\t\t\th.handleError(reqContext, err, 407, nil)\n\t\t\treturn true\n\t\t}\n\t}\n\n\tlogger.Debug(\"Successfully got user info\", \"userID\", user.UserId, \"username\", user.Login)\n\n\t// Add user info to context\n\treqContext.SignedInUser = user\n\treqContext.IsSignedIn = true\n\n\t// Remember user data in cache\n\tif err := h.authProxy.Remember(reqContext, id); err != nil {\n\t\th.handleError(reqContext, err, 500, func(details error) {\n\t\t\tlogger.Error(\n\t\t\t\t\"Failed to store user in cache\",\n\t\t\t\t\"username\", username,\n\t\t\t\t\"message\", err.Error(),\n\t\t\t\t\"error\", details,\n\t\t\t)\n\t\t})\n\t\treturn true\n\t}\n\n\treturn true\n}\n", "package proxyutil\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"strings\"\n\t\"time\"\n\n\tglog \"github.com/grafana/grafana/pkg/infra/log\"\n)\n\n// StatusClientClosedRequest A non-standard status code introduced by nginx\n// for the case when a client closes the connection while nginx is processing\n// the request.\n// https://httpstatus.in/499/\nconst StatusClientClosedRequest = 499\n\n// ReverseProxyOption reverse proxy option to configure a httputil.ReverseProxy.\ntype ReverseProxyOption func(*httputil.ReverseProxy)\n\n// NewReverseProxy creates a new httputil.ReverseProxy with sane default configuration.\nfunc NewReverseProxy(logger glog.Logger, director func(*http.Request), opts ...ReverseProxyOption) *httputil.ReverseProxy {\n\tif logger == nil {\n\t\tpanic(\"logger cannot be nil\")\n\t}\n\n\tif director == nil {\n\t\tpanic(\"director cannot be nil\")\n\t}\n\n\tp := &httputil.ReverseProxy{\n\t\tFlushInterval: time.Millisecond * 200,\n\t\tErrorHandler:  errorHandler(logger),\n\t\tErrorLog:      log.New(&logWrapper{logger: logger}, \"\", 0),\n\t\tDirector:      director,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\n\torigDirector := p.Director\n\tp.Director = wrapDirector(origDirector)\n\n\tif p.ModifyResponse == nil {\n\t\t// nolint:bodyclose\n\t\tp.ModifyResponse = modifyResponse(logger)\n\t} else {\n\t\tmodResponse := p.ModifyResponse\n\t\tp.ModifyResponse = func(resp *http.Response) error {\n\t\t\tif err := modResponse(resp); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// nolint:bodyclose\n\t\t\treturn modifyResponse(logger)(resp)\n\t\t}\n\t}\n\n\treturn p\n}\n\n// wrapDirector wraps a director and adds additional functionality.\nfunc wrapDirector(d func(*http.Request)) func(req *http.Request) {\n\treturn func(req *http.Request) {\n\t\td(req)\n\t\tPrepareProxyRequest(req)\n\n\t\t// Clear Origin and Referer to avoid CORS issues\n\t\treq.Header.Del(\"Origin\")\n\t\treq.Header.Del(\"Referer\")\n\t}\n}\n\n// modifyResponse enforces certain constraints on http.Response.\nfunc modifyResponse(logger glog.Logger) func(resp *http.Response) error {\n\treturn func(resp *http.Response) error {\n\t\tresp.Header.Del(\"Set-Cookie\")\n\t\tSetProxyResponseHeaders(resp.Header)\n\t\treturn nil\n\t}\n}\n\ntype timeoutError interface {\n\terror\n\tTimeout() bool\n}\n\n// errorHandler handles any errors happening while proxying a request and enforces\n// certain HTTP status based on the kind of error.\n// If client cancel/close the request we return 499 StatusClientClosedRequest.\n// If timeout happens while communicating with upstream server we return http.StatusGatewayTimeout.\n// If any other error we return http.StatusBadGateway.\nfunc errorHandler(logger glog.Logger) func(http.ResponseWriter, *http.Request, error) {\n\treturn func(w http.ResponseWriter, r *http.Request, err error) {\n\t\tif errors.Is(err, context.Canceled) {\n\t\t\tlogger.Debug(\"Proxy request cancelled by client\")\n\t\t\tw.WriteHeader(StatusClientClosedRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// nolint:errorlint\n\t\tif timeoutErr, ok := err.(timeoutError); ok && timeoutErr.Timeout() {\n\t\t\tlogger.Error(\"Proxy request timed out\", \"err\", err)\n\t\t\tw.WriteHeader(http.StatusGatewayTimeout)\n\t\t\treturn\n\t\t}\n\n\t\tlogger.Error(\"Proxy request failed\", \"err\", err)\n\t\tw.WriteHeader(http.StatusBadGateway)\n\t}\n}\n\ntype logWrapper struct {\n\tlogger glog.Logger\n}\n\n// Write writes log messages as bytes from proxy.\nfunc (lw *logWrapper) Write(p []byte) (n int, err error) {\n\twithoutNewline := strings.TrimSuffix(string(p), \"\\n\")\n\tlw.logger.Error(\"Proxy request error\", \"error\", withoutNewline)\n\treturn len(p), nil\n}\n\nfunc WithTransport(transport http.RoundTripper) ReverseProxyOption {\n\tif transport == nil {\n\t\tpanic(\"transport cannot be nil\")\n\t}\n\n\treturn ReverseProxyOption(func(rp *httputil.ReverseProxy) {\n\t\trp.Transport = transport\n\t})\n}\n\nfunc WithModifyResponse(fn func(*http.Response) error) ReverseProxyOption {\n\tif fn == nil {\n\t\tpanic(\"fn cannot be nil\")\n\t}\n\n\treturn ReverseProxyOption(func(rp *httputil.ReverseProxy) {\n\t\trp.ModifyResponse = fn\n\t})\n}\n", "package proxyutil\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestReverseProxy(t *testing.T) {\n\tt.Run(\"When proxying a request should enforce request and response constraints\", func(t *testing.T) {\n\t\tvar actualReq *http.Request\n\t\tupstream := newUpstreamServer(t, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\tactualReq = req\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"test\"})\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t}))\n\t\tt.Cleanup(upstream.Close)\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, upstream.URL, nil)\n\t\treq.Header.Set(\"X-Forwarded-Host\", \"forwarded.host.com\")\n\t\treq.Header.Set(\"X-Forwarded-Port\", \"8080\")\n\t\treq.Header.Set(\"X-Forwarded-Proto\", \"https\")\n\t\treq.Header.Set(\"Origin\", \"test.com\")\n\t\treq.Header.Set(\"Referer\", \"https://test.com/api\")\n\t\treq.RemoteAddr = \"10.0.0.1\"\n\n\t\trp := NewReverseProxy(log.New(\"test\"), func(req *http.Request) {\n\t\t\treq.Header.Set(\"X-KEY\", \"value\")\n\t\t})\n\t\trequire.NotNil(t, rp)\n\t\trequire.NotNil(t, rp.ModifyResponse)\n\t\trp.ServeHTTP(rec, req)\n\n\t\trequire.NotNil(t, actualReq)\n\t\trequire.Empty(t, actualReq.Header.Get(\"X-Forwarded-Host\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"X-Forwarded-Port\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"X-Forwarded-Proto\"))\n\t\trequire.Equal(t, \"10.0.0.1\", actualReq.Header.Get(\"X-Forwarded-For\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"Origin\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"Referer\"))\n\t\trequire.Equal(t, \"value\", actualReq.Header.Get(\"X-KEY\"))\n\t\tresp := rec.Result()\n\t\trequire.Empty(t, resp.Cookies())\n\t\trequire.Equal(t, \"sandbox\", resp.Header.Get(\"Content-Security-Policy\"))\n\t\trequire.NoError(t, resp.Body.Close())\n\t})\n\n\tt.Run(\"When proxying a request using WithModifyResponse should call it before default ModifyResponse func\", func(t *testing.T) {\n\t\tvar actualReq *http.Request\n\t\tupstream := newUpstreamServer(t, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\tactualReq = req\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"test\"})\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t}))\n\t\tt.Cleanup(upstream.Close)\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, upstream.URL, nil)\n\t\trp := NewReverseProxy(\n\t\t\tlog.New(\"test\"),\n\t\t\tfunc(req *http.Request) {\n\t\t\t\treq.Header.Set(\"X-KEY\", \"value\")\n\t\t\t},\n\t\t\tWithModifyResponse(func(r *http.Response) error {\n\t\t\t\tr.Header.Set(\"X-KEY2\", \"value2\")\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\t\trequire.NotNil(t, rp)\n\t\trequire.NotNil(t, rp.ModifyResponse)\n\t\trp.ServeHTTP(rec, req)\n\n\t\trequire.NotNil(t, actualReq)\n\t\trequire.Equal(t, \"value\", actualReq.Header.Get(\"X-KEY\"))\n\t\tresp := rec.Result()\n\t\trequire.Empty(t, resp.Cookies())\n\t\trequire.Equal(t, \"sandbox\", resp.Header.Get(\"Content-Security-Policy\"))\n\t\trequire.Equal(t, \"value2\", resp.Header.Get(\"X-KEY2\"))\n\t\trequire.NoError(t, resp.Body.Close())\n\t})\n\n\tt.Run(\"Error handling should convert status codes depending on what kind of error it is\", func(t *testing.T) {\n\t\ttimedOutTransport := http.DefaultTransport.(*http.Transport)\n\t\ttimedOutTransport.ResponseHeaderTimeout = time.Millisecond\n\n\t\ttestCases := []struct {\n\t\t\tdesc               string\n\t\t\ttransport          http.RoundTripper\n\t\t\tresponseWaitTime   time.Duration\n\t\t\texpectedStatusCode int\n\t\t}{\n\t\t\t{\n\t\t\t\tdesc:               \"Cancelled request should return 499 Client closed request\",\n\t\t\t\ttransport:          &cancelledRoundTripper{},\n\t\t\t\texpectedStatusCode: StatusClientClosedRequest,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:               \"Timed out request should return 504 Gateway timeout\",\n\t\t\t\ttransport:          timedOutTransport,\n\t\t\t\tresponseWaitTime:   100 * time.Millisecond,\n\t\t\t\texpectedStatusCode: http.StatusGatewayTimeout,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:               \"Failed request should return 502 Bad gateway\",\n\t\t\t\ttransport:          &failingRoundTripper{},\n\t\t\t\texpectedStatusCode: http.StatusBadGateway,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\t\tupstream := newUpstreamServer(t, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\t\t\tif tc.responseWaitTime > 0 {\n\t\t\t\t\t\ttime.Sleep(tc.responseWaitTime)\n\t\t\t\t\t}\n\n\t\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\t}))\n\t\t\t\tt.Cleanup(upstream.Close)\n\t\t\t\trec := httptest.NewRecorder()\n\t\t\t\treq := httptest.NewRequest(http.MethodGet, upstream.URL, nil)\n\n\t\t\t\trp := NewReverseProxy(\n\t\t\t\t\tlog.New(\"test\"),\n\t\t\t\t\tfunc(req *http.Request) {},\n\t\t\t\t\tWithTransport(tc.transport),\n\t\t\t\t)\n\t\t\t\trequire.NotNil(t, rp)\n\t\t\t\trequire.NotNil(t, rp.Transport)\n\t\t\t\trequire.Same(t, tc.transport, rp.Transport)\n\t\t\t\trp.ServeHTTP(rec, req)\n\n\t\t\t\tresp := rec.Result()\n\t\t\t\trequire.Equal(t, tc.expectedStatusCode, resp.StatusCode)\n\t\t\t\trequire.NoError(t, resp.Body.Close())\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc newUpstreamServer(t *testing.T, handler http.Handler) *httptest.Server {\n\tt.Helper()\n\n\tupstream := httptest.NewServer(handler)\n\treturn upstream\n}\n\ntype cancelledRoundTripper struct{}\n\nfunc (cancelledRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {\n\treturn nil, context.Canceled\n}\n\ntype failingRoundTripper struct{}\n\nfunc (failingRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {\n\treturn nil, errors.New(\"some error\")\n}\n"], "fixing_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/services/pluginsettings\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util/errutil\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\tcoreFilter := c.Query(\"core\")\n\n\t// For users with viewer role we only return core plugins\n\tif !c.HasRole(models.ROLE_ADMIN) {\n\t\tcoreFilter = \"1\"\n\t}\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get list of plugins\", err)\n\t}\n\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range hs.pluginStore.Plugins(c.Req.Context()) {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tDefaultNavUrl: path.Join(hs.Cfg.AppSubURL, pluginDef.DefaultNavURL),\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t}\n\n\t\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), pluginDef.ID)\n\t\tif exists {\n\t\t\tlistItem.LatestVersion = update\n\t\t\tlistItem.HasUpdate = true\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif enabledFilter == \"1\" && !listItem.Enabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(200, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:          string(plugin.Type),\n\t\tId:            plugin.ID,\n\t\tName:          plugin.Name,\n\t\tInfo:          plugin.Info,\n\t\tDependencies:  plugin.Dependencies,\n\t\tIncludes:      plugin.Includes,\n\t\tBaseUrl:       plugin.BaseURL,\n\t\tModule:        plugin.Module,\n\t\tDefaultNavUrl: path.Join(hs.Cfg.AppSubURL, plugin.DefaultNavURL),\n\t\tState:         plugin.State,\n\t\tSignature:     plugin.Signature,\n\t\tSignatureType: plugin.SignatureType,\n\t\tSignatureOrg:  plugin.SignatureOrg,\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tps, err := hs.PluginSettings.GetPluginSettingByPluginID(c.Req.Context(), &pluginsettings.GetByPluginIDArgs{\n\t\tPluginID: pluginID,\n\t\tOrgID:    c.OrgId,\n\t})\n\tif err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to get plugin settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = ps.Enabled\n\t\tdto.Pinned = ps.Pinned\n\t\tdto.JsonData = ps.JSONData\n\t}\n\n\tupdate, exists := hs.pluginsUpdateChecker.HasUpdate(c.Req.Context(), plugin.ID)\n\tif exists {\n\t\tdto.LatestVersion = update\n\t\tdto.HasUpdate = true\n\t}\n\n\treturn response.JSON(200, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgId\n\tcmd.PluginId = pluginID\n\tif err := hs.PluginSettings.UpdatePluginSetting(c.Req.Context(), &pluginsettings.UpdateArgs{\n\t\tEnabled:                 cmd.Enabled,\n\t\tPinned:                  cmd.Pinned,\n\t\tJSONData:                cmd.JsonData,\n\t\tSecureJSONData:          cmd.SecureJsonData,\n\t\tPluginVersion:           cmd.PluginVersion,\n\t\tPluginID:                cmd.PluginId,\n\t\tOrgID:                   cmd.OrgId,\n\t\tEncryptedSecureJSONData: cmd.EncryptedSecureJsonData,\n\t}); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(200, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), &backend.CollectMetricsRequest{PluginContext: backend.PluginContext{PluginID: pluginID}})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(200, payload)\n}\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\ths.callPluginResource(c, web.Params(c.Req)[\":pluginId\"], \"\")\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(200, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Add(c.Req.Context(), pluginID, dto.Version)\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr installer.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr installer.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError installer.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tpath := filepath.Join(plugin.PluginDir, mdFilepath(strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, mdFilepath(strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning since we have cleaned the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc mdFilepath(mdFilename string) string {\n\treturn filepath.Clean(filepath.Join(\"/\", fmt.Sprintf(\"%s.md\", mdFilename)))\n}\n\nfunc (hs *HTTPServer) callPluginResource(c *models.ReqContext, pluginID, dsUID string) {\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, dsUID, c.SignedInUser, false)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\tvar dsURL string\n\tif pCtx.DataSourceInstanceSettings != nil {\n\t\tdsURL = pCtx.DataSourceInstanceSettings.URL\n\t}\n\n\terr = hs.PluginRequestValidator.Validate(dsURL, c.Req)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusForbidden, \"Access denied\", err)\n\t\treturn\n\t}\n\n\tclonedReq := c.Req.Clone(c.Req.Context())\n\trawURL := web.Params(c.Req)[\"*\"]\n\tif clonedReq.URL.RawQuery != \"\" {\n\t\trawURL += \"?\" + clonedReq.URL.RawQuery\n\t}\n\turlPath, err := url.Parse(rawURL)\n\tif err != nil {\n\t\thandleCallResourceError(err, c)\n\t\treturn\n\t}\n\tclonedReq.URL = urlPath\n\n\tif dsUID != \"\" {\n\t\tds, err := hs.DataSourceCache.GetDatasourceByUID(c.Req.Context(), dsUID, c.SignedInUser, c.SkipCache)\n\n\t\tif err != nil {\n\t\t\tif errors.Is(err, models.ErrDataSourceNotFound) {\n\t\t\t\tc.JsonApiErr(404, \"Datasource not found\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tc.JsonApiErr(500, \"Failed to get datasource\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif hs.DataProxy.OAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\t\tif token := hs.DataProxy.OAuthTokenService.GetCurrentOAuthToken(c.Req.Context(), c.SignedInUser); token != nil {\n\t\t\t\tclonedReq.Header.Add(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\n\t\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\t\tif ok && idToken != \"\" {\n\t\t\t\t\tclonedReq.Header.Add(\"X-ID-Token\", idToken)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = hs.makePluginResourceRequest(c.Resp, clonedReq, pCtx); err != nil {\n\t\thandleCallResourceError(err, c)\n\t}\n}\n\nfunc (hs *HTTPServer) makePluginResourceRequest(w http.ResponseWriter, req *http.Request, pCtx backend.PluginContext) error {\n\tkeepCookieModel := struct {\n\t\tKeepCookies []string `json:\"keepCookies\"`\n\t}{}\n\tif dis := pCtx.DataSourceInstanceSettings; dis != nil {\n\t\terr := json.Unmarshal(dis.JSONData, &keepCookieModel)\n\t\tif err != nil {\n\t\t\ths.log.Warn(\"failed to to unpack JSONData in datasource instance settings\", \"err\", err)\n\t\t}\n\t}\n\n\tlist := contexthandler.AuthHTTPHeaderListFromContext(req.Context())\n\tif list != nil {\n\t\tfor _, name := range list.Items {\n\t\t\treq.Header.Del(name)\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies)\n\tproxyutil.PrepareProxyRequest(req)\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read request body: %w\", err)\n\t}\n\n\tcrReq := &backend.CallResourceRequest{\n\t\tPluginContext: pCtx,\n\t\tPath:          req.URL.Path,\n\t\tMethod:        req.Method,\n\t\tURL:           req.URL.String(),\n\t\tHeaders:       req.Header,\n\t\tBody:          body,\n\t}\n\n\tchildCtx, cancel := context.WithCancel(req.Context())\n\tdefer cancel()\n\tstream := newCallResourceResponseStream(childCtx)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tdefer func() {\n\t\tif err := stream.Close(); err != nil {\n\t\t\ths.log.Warn(\"Failed to close plugin resource stream\", \"err\", err)\n\t\t}\n\t\twg.Wait()\n\t}()\n\n\tvar flushStreamErr error\n\tgo func() {\n\t\tflushStreamErr = hs.flushStream(stream, w)\n\t\twg.Done()\n\t}()\n\n\tif err := hs.pluginClient.CallResource(req.Context(), crReq, stream); err != nil {\n\t\treturn err\n\t}\n\n\treturn flushStreamErr\n}\n\nfunc (hs *HTTPServer) flushStream(stream callResourceClientResponseStream, w http.ResponseWriter) error {\n\tprocessedStreams := 0\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errors.New(\"received empty resource response\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errutil.Wrap(\"failed to receive response from resource call\", err)\n\t\t\t}\n\n\t\t\ths.log.Error(\"Failed to receive response from resource call\", \"err\", err)\n\t\t\treturn stream.Close()\n\t\t}\n\n\t\t// Expected that headers and status are only part of first stream\n\t\tif processedStreams == 0 && resp.Headers != nil {\n\t\t\t// Make sure a content type always is returned in response\n\t\t\tif _, exists := resp.Headers[\"Content-Type\"]; !exists {\n\t\t\t\tresp.Headers[\"Content-Type\"] = []string{\"application/json\"}\n\t\t\t}\n\n\t\t\tfor k, values := range resp.Headers {\n\t\t\t\t// Due to security reasons we don't want to forward\n\t\t\t\t// cookies from a backend plugin to clients/browsers.\n\t\t\t\tif k == \"Set-Cookie\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range values {\n\t\t\t\t\t// TODO: Figure out if we should use Set here instead\n\t\t\t\t\t// nolint:gocritic\n\t\t\t\t\tw.Header().Add(k, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyutil.SetProxyResponseHeaders(w.Header())\n\n\t\t\tw.WriteHeader(resp.Status)\n\t\t}\n\n\t\tif _, err := w.Write(resp.Body); err != nil {\n\t\t\ths.log.Error(\"Failed to write resource response\", \"err\", err)\n\t\t}\n\n\t\tif flusher, ok := w.(http.Flusher); ok {\n\t\t\tflusher.Flush()\n\t\t}\n\t\tprocessedStreams++\n\t}\n}\n\nfunc handleCallResourceError(err error, reqCtx *models.ReqContext) {\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treqCtx.JsonApiErr(503, \"Plugin unavailable\", err)\n\t\treturn\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treqCtx.JsonApiErr(404, \"Not found\", err)\n\t\treturn\n\t}\n\n\treqCtx.JsonApiErr(500, \"Failed to call resource\", err)\n}\n\n// callResourceClientResponseStream is used for receiving resource call responses.\ntype callResourceClientResponseStream interface {\n\tRecv() (*backend.CallResourceResponse, error)\n\tClose() error\n}\n\ntype callResourceResponseStream struct {\n\tctx    context.Context\n\tstream chan *backend.CallResourceResponse\n\tclosed bool\n}\n\nfunc newCallResourceResponseStream(ctx context.Context) *callResourceResponseStream {\n\treturn &callResourceResponseStream{\n\t\tctx:    ctx,\n\t\tstream: make(chan *backend.CallResourceResponse),\n\t}\n}\n\nfunc (s *callResourceResponseStream) Send(res *backend.CallResourceResponse) error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot send to a closed stream\")\n\t}\n\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn errors.New(\"cancelled\")\n\tcase s.stream <- res:\n\t\treturn nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Recv() (*backend.CallResourceResponse, error) {\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn nil, s.ctx.Err()\n\tcase res, ok := <-s.stream:\n\t\tif !ok {\n\t\t\treturn nil, io.EOF\n\t\t}\n\t\treturn res, nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Close() error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot close a closed stream\")\n\t}\n\n\tclose(s.stream)\n\ts.closed = true\n\treturn nil\n}\n", "package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web/webtest\"\n)\n\nfunc Test_PluginsInstallAndUninstall(t *testing.T) {\n\ttype tc struct {\n\t\tpluginAdminEnabled               bool\n\t\tpluginAdminExternalManageEnabled bool\n\t\texpectedHTTPStatus               int\n\t\texpectedHTTPBody                 string\n\t}\n\ttcs := []tc{\n\t\t{pluginAdminEnabled: true, pluginAdminExternalManageEnabled: true, expectedHTTPStatus: 404, expectedHTTPBody: \"404 page not found\\n\"},\n\t\t{pluginAdminEnabled: true, pluginAdminExternalManageEnabled: false, expectedHTTPStatus: 200, expectedHTTPBody: \"\"},\n\t\t{pluginAdminEnabled: false, pluginAdminExternalManageEnabled: true, expectedHTTPStatus: 404, expectedHTTPBody: \"404 page not found\\n\"},\n\t\t{pluginAdminEnabled: false, pluginAdminExternalManageEnabled: false, expectedHTTPStatus: 404, expectedHTTPBody: \"404 page not found\\n\"},\n\t}\n\n\ttestName := func(action string, testCase tc) string {\n\t\treturn fmt.Sprintf(\"%s request returns %d when adminEnabled: %t and externalEnabled: %t\",\n\t\t\taction, testCase.expectedHTTPStatus, testCase.pluginAdminEnabled, testCase.pluginAdminExternalManageEnabled)\n\t}\n\n\tps := fakePluginStore{\n\t\tplugins: make(map[string]plugins.PluginDTO),\n\t}\n\tfor _, tc := range tcs {\n\t\tsrv := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\t\ths.Cfg = &setting.Cfg{\n\t\t\t\tPluginAdminEnabled:               tc.pluginAdminEnabled,\n\t\t\t\tPluginAdminExternalManageEnabled: tc.pluginAdminExternalManageEnabled,\n\t\t\t}\n\t\t\ths.pluginStore = ps\n\t\t})\n\n\t\tt.Run(testName(\"Install\", tc), func(t *testing.T) {\n\t\t\treq := srv.NewPostRequest(\"/api/plugins/test/install\", strings.NewReader(\"{ \\\"version\\\": \\\"1.0.2\\\" }\"))\n\t\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_EDITOR, IsGrafanaAdmin: true})\n\t\t\tresp, err := srv.SendJSON(req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tbody := new(strings.Builder)\n\t\t\t_, err = io.Copy(body, resp.Body)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.expectedHTTPBody, body.String())\n\t\t\trequire.NoError(t, resp.Body.Close())\n\t\t\trequire.Equal(t, tc.expectedHTTPStatus, resp.StatusCode)\n\n\t\t\tif tc.expectedHTTPStatus == 200 {\n\t\t\t\trequire.Equal(t, plugins.PluginDTO{\n\t\t\t\t\tJSONData: plugins.JSONData{\n\t\t\t\t\t\tID: \"test\",\n\t\t\t\t\t\tInfo: plugins.Info{\n\t\t\t\t\t\t\tVersion: \"1.0.2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}, ps.plugins[\"test\"])\n\t\t\t}\n\t\t})\n\n\t\tt.Run(testName(\"Uninstall\", tc), func(t *testing.T) {\n\t\t\treq := srv.NewPostRequest(\"/api/plugins/test/uninstall\", strings.NewReader(\"{}\"))\n\t\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER, IsGrafanaAdmin: true})\n\t\t\tresp, err := srv.SendJSON(req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tbody := new(strings.Builder)\n\t\t\t_, err = io.Copy(body, resp.Body)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.expectedHTTPBody, body.String())\n\t\t\trequire.NoError(t, resp.Body.Close())\n\t\t\trequire.Equal(t, tc.expectedHTTPStatus, resp.StatusCode)\n\n\t\t\tif tc.expectedHTTPStatus == 200 {\n\t\t\t\trequire.Empty(t, ps.plugins)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_GetPluginAssets(t *testing.T) {\n\tpluginID := \"test-plugin\"\n\tpluginDir := \".\"\n\ttmpFile, err := ioutil.TempFile(pluginDir, \"\")\n\trequire.NoError(t, err)\n\ttmpFileInParentDir, err := ioutil.TempFile(\"..\", \"\")\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\terr := os.RemoveAll(tmpFile.Name())\n\t\tassert.NoError(t, err)\n\t\terr = os.RemoveAll(tmpFileInParentDir.Name())\n\t\tassert.NoError(t, err)\n\t})\n\texpectedBody := \"Plugin test\"\n\t_, err = tmpFile.WriteString(expectedBody)\n\tassert.NoError(t, err)\n\n\trequestedFile := filepath.Clean(tmpFile.Name())\n\n\tt.Run(\"Given a request for an existing plugin file that is listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t\tSignedFiles: map[string]struct{}{\n\t\t\t\trequestedFile: {},\n\t\t\t},\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a relative path\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, tmpFileInParentDir.Name())\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an existing plugin file that is not listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin file not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a core plugin's file\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: {\n\t\t\t\t\tClass: plugins.Core,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n}\n\nfunc TestMakePluginResourceRequest(t *testing.T) {\n\tpluginClient := &fakePluginClient{}\n\ths := HTTPServer{\n\t\tCfg:          setting.NewCfg(),\n\t\tlog:          log.New(),\n\t\tpluginClient: pluginClient,\n\t}\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\n\tconst customHeader = \"X-CUSTOM\"\n\treq.Header.Set(customHeader, \"val\")\n\tctx := contexthandler.WithAuthHTTPHeader(req.Context(), customHeader)\n\treq = req.WithContext(ctx)\n\n\tresp := httptest.NewRecorder()\n\tpCtx := backend.PluginContext{}\n\terr := hs.makePluginResourceRequest(resp, req, pCtx)\n\trequire.NoError(t, err)\n\n\tfor {\n\t\tif resp.Flushed {\n\t\t\tbreak\n\t\t}\n\t}\n\n\trequire.Equal(t, \"sandbox\", resp.Header().Get(\"Content-Security-Policy\"))\n\trequire.Empty(t, req.Header.Get(customHeader))\n}\n\nfunc callGetPluginAsset(sc *scenarioContext) {\n\tsc.fakeReqWithParams(\"GET\", sc.url, map[string]string{}).exec()\n}\n\nfunc pluginAssetScenario(t *testing.T, desc string, url string, urlPattern string, pluginStore plugins.Store,\n\tlogger log.Logger, fn scenarioFunc) {\n\tt.Run(fmt.Sprintf(\"%s %s\", desc, url), func(t *testing.T) {\n\t\ths := HTTPServer{\n\t\t\tCfg:         setting.NewCfg(),\n\t\t\tpluginStore: pluginStore,\n\t\t\tlog:         logger,\n\t\t}\n\n\t\tsc := setupScenarioContext(t, url)\n\t\tsc.defaultHandler = func(c *models.ReqContext) {\n\t\t\tsc.context = c\n\t\t\ths.getPluginAssets(c)\n\t\t}\n\n\t\tsc.m.Get(urlPattern, sc.defaultHandler)\n\n\t\tfn(sc)\n\t})\n}\n\ntype logger struct {\n\tlog.Logger\n\n\twarnings []string\n}\n\nfunc (l *logger) Warn(msg string, ctx ...interface{}) {\n\tl.warnings = append(l.warnings, msg)\n}\n\ntype fakePluginClient struct {\n\tplugins.Client\n\n\treq *backend.CallResourceRequest\n\n\tbackend.QueryDataHandlerFunc\n}\n\nfunc (c *fakePluginClient) CallResource(_ context.Context, req *backend.CallResourceRequest, sender backend.CallResourceResponseSender) error {\n\tc.req = req\n\tbytes, err := json.Marshal(map[string]interface{}{\n\t\t\"message\": \"hello\",\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn sender.Send(&backend.CallResourceResponse{\n\t\tStatus:  http.StatusOK,\n\t\tHeaders: make(map[string][]string),\n\t\tBody:    bytes,\n\t})\n}\n\nfunc (c *fakePluginClient) QueryData(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tif c.QueryDataHandlerFunc != nil {\n\t\treturn c.QueryDataHandlerFunc.QueryData(ctx, req)\n\t}\n\n\treturn backend.NewQueryDataResponse(), nil\n}\n", "package middleware\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/services/login/logintest\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestMiddlewareBasicAuth(t *testing.T) {\n\tconst id int64 = 12\n\n\tconfigure := func(cfg *setting.Cfg) {\n\t\tcfg.BasicAuthEnabled = true\n\t\tcfg.DisableBruteForceLoginProtection = true\n\t}\n\n\tmiddlewareScenario(t, \"Valid API key\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst orgID int64 = 2\n\t\tkeyhash, err := util.EncodePassword(\"v5nAwpMafFP6znaS4urhdWDLS5511M42\", \"asd\")\n\t\trequire.NoError(t, err)\n\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: orgID, Role: models.ROLE_EDITOR, Key: keyhash}\n\n\t\tauthHeader := util.GetBasicAuthHeader(\"api_key\", \"eyJrIjoidjVuQXdwTWFmRlA2em5hUzR1cmhkV0RMUzU1MTFNNDIiLCJuIjoiYXNkIiwiaWQiOjF9\")\n\t\tsc.fakeReq(\"GET\", \"/\").withAuthorizationHeader(authHeader).exec()\n\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n\t\trequire.NotNil(t, list)\n\t\trequire.EqualValues(t, []string{\"Authorization\"}, list.Items)\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Handle auth\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst password = \"MyPass\"\n\t\tconst orgID int64 = 2\n\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: id}\n\n\t\tauthHeader := util.GetBasicAuthHeader(\"myUser\", password)\n\t\tsc.fakeReq(\"GET\", \"/\").withAuthorizationHeader(authHeader).exec()\n\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Auth sequence\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst password = \"MyPass\"\n\t\tconst salt = \"Salt\"\n\n\t\tencoded, err := util.EncodePassword(password, salt)\n\t\trequire.NoError(t, err)\n\n\t\tsc.mockSQLStore.ExpectedUser = &models.User{Password: encoded, Id: id, Salt: salt}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id}\n\t\tlogin.ProvideService(sc.mockSQLStore, &logintest.LoginServiceFake{})\n\n\t\tauthHeader := util.GetBasicAuthHeader(\"myUser\", password)\n\t\tsc.fakeReq(\"GET\", \"/\").withAuthorizationHeader(authHeader).exec()\n\t\trequire.NotNil(t, sc.context)\n\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n\t\trequire.NotNil(t, list)\n\t\trequire.EqualValues(t, []string{\"Authorization\"}, list.Items)\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Should return error if user is not found\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.mockSQLStore.ExpectedError = models.ErrUserNotFound\n\t\tsc.fakeReq(\"GET\", \"/\")\n\t\tsc.req.SetBasicAuth(\"user\", \"password\")\n\t\tsc.exec()\n\n\t\terr := json.NewDecoder(sc.resp.Body).Decode(&sc.respJson)\n\t\trequire.Error(t, err)\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidUsernamePassword, sc.respJson[\"message\"])\n\t}, configure)\n\n\tmiddlewareScenario(t, \"Should return error if user & password do not match\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.mockSQLStore.ExpectedError = models.ErrUserNotFound\n\t\tsc.fakeReq(\"GET\", \"/\")\n\t\tsc.req.SetBasicAuth(\"killa\", \"gorilla\")\n\t\tsc.exec()\n\n\t\terr := json.NewDecoder(sc.resp.Body).Decode(&sc.respJson)\n\t\trequire.Error(t, err)\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidUsernamePassword, sc.respJson[\"message\"])\n\t}, configure)\n}\n", "package middleware\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n)\n\nfunc TestMiddlewareJWTAuth(t *testing.T) {\n\tconst id int64 = 12\n\tconst orgID int64 = 2\n\n\tconfigure := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthEnabled = true\n\t\tcfg.JWTAuthHeaderName = \"x-jwt-assertion\"\n\t}\n\n\tconfigureUsernameClaim := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthUsernameClaim = \"foo-username\"\n\t}\n\n\tconfigureEmailClaim := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthEmailClaim = \"foo-email\"\n\t}\n\n\tconfigureAutoSignUp := func(cfg *setting.Cfg) {\n\t\tcfg.JWTAuthAutoSignUp = true\n\t}\n\n\ttoken := \"some-token\"\n\n\tmiddlewareScenario(t, \"Valid token with valid login claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyUsername := \"vladimir\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":          myUsername,\n\t\t\t\t\"foo-username\": myUsername,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id, OrgId: orgID, Login: myUsername}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tassert.Equal(t, myUsername, sc.context.Login)\n\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n\t\trequire.NotNil(t, list)\n\t\trequire.EqualValues(t, []string{sc.cfg.JWTAuthHeaderName}, list.Items)\n\t}, configure, configureUsernameClaim)\n\n\tmiddlewareScenario(t, \"Valid token with valid email claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyEmail := \"vladimir@example.com\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":       myEmail,\n\t\t\t\t\"foo-email\": myEmail,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id, OrgId: orgID, Email: myEmail}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tassert.Equal(t, myEmail, sc.context.Email)\n\t}, configure, configureEmailClaim)\n\n\tmiddlewareScenario(t, \"Valid token with no user and auto_sign_up disabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyEmail := \"vladimir@example.com\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":       myEmail,\n\t\t\t\t\"name\":      \"Vladimir Example\",\n\t\t\t\t\"foo-email\": myEmail,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedError = models.ErrUserNotFound\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.UserNotFound, sc.respJson[\"message\"])\n\t}, configure, configureEmailClaim)\n\n\tmiddlewareScenario(t, \"Valid token with no user and auto_sign_up enabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tmyEmail := \"vladimir@example.com\"\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\":       myEmail,\n\t\t\t\t\"name\":      \"Vladimir Example\",\n\t\t\t\t\"foo-email\": myEmail,\n\t\t\t}, nil\n\t\t}\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{UserId: id, OrgId: orgID, Email: myEmail}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, id, sc.context.UserId)\n\t\tassert.Equal(t, myEmail, sc.context.Email)\n\t}, configure, configureEmailClaim, configureAutoSignUp)\n\n\tmiddlewareScenario(t, \"Valid token without a login claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\": \"baz\",\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidJWT, sc.respJson[\"message\"])\n\t}, configure, configureUsernameClaim)\n\n\tmiddlewareScenario(t, \"Valid token without a email claim\", func(t *testing.T, sc *scenarioContext) {\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn models.JWTClaims{\n\t\t\t\t\"sub\": \"baz\",\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidJWT, sc.respJson[\"message\"])\n\t}, configure, configureEmailClaim)\n\n\tmiddlewareScenario(t, \"Invalid token\", func(t *testing.T, sc *scenarioContext) {\n\t\tvar verifiedToken string\n\t\tsc.jwtAuthService.VerifyProvider = func(ctx context.Context, token string) (models.JWTClaims, error) {\n\t\t\tverifiedToken = token\n\t\t\treturn nil, errors.New(\"token is invalid\")\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withJWTAuthHeader(token).exec()\n\t\tassert.Equal(t, verifiedToken, token)\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidJWT, sc.respJson[\"message\"])\n\t}, configure, configureUsernameClaim)\n}\n", "package middleware\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/gtime\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/infra/remotecache\"\n\t\"github.com/grafana/grafana/pkg/infra/tracing\"\n\t\"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/auth\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler/authproxy\"\n\t\"github.com/grafana/grafana/pkg/services/login/loginservice\"\n\t\"github.com/grafana/grafana/pkg/services/login/logintest\"\n\t\"github.com/grafana/grafana/pkg/services/rendering\"\n\t\"github.com/grafana/grafana/pkg/services/sqlstore/mockstore\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/web\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc fakeGetTime() func() time.Time {\n\tvar timeSeed int64\n\treturn func() time.Time {\n\t\tfakeNow := time.Unix(timeSeed, 0)\n\t\ttimeSeed++\n\t\treturn fakeNow\n\t}\n}\n\nfunc TestMiddleWareSecurityHeaders(t *testing.T) {\n\tmiddlewareScenario(t, \"middleware should get correct x-xss-protection header\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"1; mode=block\", sc.resp.Header().Get(\"X-XSS-Protection\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.XSSProtectionHeader = true\n\t})\n\n\tmiddlewareScenario(t, \"middleware should not get x-xss-protection when disabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Empty(t, sc.resp.Header().Get(\"X-XSS-Protection\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.XSSProtectionHeader = false\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add correct Strict-Transport-Security header\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"max-age=64000\", sc.resp.Header().Get(\"Strict-Transport-Security\"))\n\t\tsc.cfg.StrictTransportSecurityPreload = true\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"max-age=64000; preload\", sc.resp.Header().Get(\"Strict-Transport-Security\"))\n\t\tsc.cfg.StrictTransportSecuritySubDomains = true\n\t\tsc.fakeReq(\"GET\", \"/api/\").exec()\n\t\tassert.Equal(t, \"max-age=64000; preload; includeSubDomains\", sc.resp.Header().Get(\"Strict-Transport-Security\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.StrictTransportSecurity = true\n\t\tcfg.StrictTransportSecurityMaxAge = 64000\n\t})\n}\n\nfunc TestMiddlewareContext(t *testing.T) {\n\tconst noCache = \"no-cache\"\n\n\tmiddlewareScenario(t, \"middleware should add context to injector\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\tassert.NotNil(t, sc.context)\n\t})\n\n\tmiddlewareScenario(t, \"Default middleware should allow get request\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\tassert.Equal(t, 200, sc.resp.Code)\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add Cache-Control header for requests to API\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/search\").exec()\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Cache-Control\"))\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Pragma\"))\n\t\tassert.Equal(t, \"-1\", sc.resp.Header().Get(\"Expires\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should not add Cache-Control header for requests to datasource proxy API\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/datasources/proxy/1/test\").exec()\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Cache-Control\"))\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Pragma\"))\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Expires\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add Cache-Control header for requests with HTML response\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.handlerFunc = func(c *models.ReqContext) {\n\t\t\tt.Log(\"Handler called\")\n\t\t\tdata := &dtos.IndexViewData{\n\t\t\t\tUser:     &dtos.CurrentUser{},\n\t\t\t\tSettings: map[string]interface{}{},\n\t\t\t\tNavTree:  []*dtos.NavLink{},\n\t\t\t}\n\t\t\tt.Log(\"Calling HTML\", \"data\", data)\n\t\t\tc.HTML(200, \"index-template\", data)\n\t\t\tt.Log(\"Returned HTML with code 200\")\n\t\t}\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Cache-Control\"))\n\t\tassert.Equal(t, noCache, sc.resp.Header().Get(\"Pragma\"))\n\t\tassert.Equal(t, \"-1\", sc.resp.Header().Get(\"Expires\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should add X-Frame-Options header with deny for request when not allowing embedding\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/search\").exec()\n\t\tassert.Equal(t, \"deny\", sc.resp.Header().Get(\"X-Frame-Options\"))\n\t})\n\n\tmiddlewareScenario(t, \"middleware should not add X-Frame-Options header for request when allowing embedding\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tsc.fakeReq(\"GET\", \"/api/search\").exec()\n\t\tassert.Empty(t, sc.resp.Header().Get(\"X-Frame-Options\"))\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.AllowEmbedding = true\n\t})\n\n\tmiddlewareScenario(t, \"Invalid api key\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.apiKey = \"invalid_key_test\"\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Set-Cookie\"))\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidAPIKey, sc.respJson[\"message\"])\n\t})\n\n\tmiddlewareScenario(t, \"Valid API key\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst orgID int64 = 12\n\t\tkeyhash, err := util.EncodePassword(\"v5nAwpMafFP6znaS4urhdWDLS5511M42\", \"asd\")\n\t\trequire.NoError(t, err)\n\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: orgID, Role: models.ROLE_EDITOR, Key: keyhash}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withValidApiKey().exec()\n\n\t\trequire.Equal(t, 200, sc.resp.Code)\n\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n\t})\n\n\tmiddlewareScenario(t, \"Valid API key, but does not match DB hash\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst keyhash = \"Something_not_matching\"\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: 12, Role: models.ROLE_EDITOR, Key: keyhash}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withValidApiKey().exec()\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, contexthandler.InvalidAPIKey, sc.respJson[\"message\"])\n\t})\n\n\tmiddlewareScenario(t, \"Valid API key, but expired\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.contextHandler.GetTime = fakeGetTime()\n\n\t\tkeyhash, err := util.EncodePassword(\"v5nAwpMafFP6znaS4urhdWDLS5511M42\", \"asd\")\n\t\trequire.NoError(t, err)\n\n\t\texpires := sc.contextHandler.GetTime().Add(-1 * time.Second).Unix()\n\t\tsc.mockSQLStore.ExpectedAPIKey = &models.ApiKey{OrgId: 12, Role: models.ROLE_EDITOR, Key: keyhash, Expires: &expires}\n\n\t\tsc.fakeReq(\"GET\", \"/\").withValidApiKey().exec()\n\n\t\tassert.Equal(t, 401, sc.resp.Code)\n\t\tassert.Equal(t, \"Expired API key\", sc.respJson[\"message\"])\n\t})\n\n\tmiddlewareScenario(t, \"Non-expired auth token in cookie which is not being rotated\", func(\n\t\tt *testing.T, sc *scenarioContext) {\n\t\tconst userID int64 = 12\n\n\t\tsc.withTokenSessionCookie(\"token\")\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: 2, UserId: userID}\n\n\t\tsc.userAuthTokenService.LookupTokenProvider = func(ctx context.Context, unhashedToken string) (*models.UserToken, error) {\n\t\t\treturn &models.UserToken{\n\t\t\t\tUserId:        userID,\n\t\t\t\tUnhashedToken: unhashedToken,\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\trequire.NotNil(t, sc.context)\n\t\trequire.NotNil(t, sc.context.UserToken)\n\t\tassert.True(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\tassert.Equal(t, userID, sc.context.UserToken.UserId)\n\t\tassert.Equal(t, \"token\", sc.context.UserToken.UnhashedToken)\n\t\tassert.Empty(t, sc.resp.Header().Get(\"Set-Cookie\"))\n\t})\n\n\tmiddlewareScenario(t, \"Non-expired auth token in cookie which is being rotated\", func(t *testing.T, sc *scenarioContext) {\n\t\tconst userID int64 = 12\n\n\t\tsc.withTokenSessionCookie(\"token\")\n\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: 2, UserId: userID}\n\n\t\tsc.userAuthTokenService.LookupTokenProvider = func(ctx context.Context, unhashedToken string) (*models.UserToken, error) {\n\t\t\treturn &models.UserToken{\n\t\t\t\tUserId:        userID,\n\t\t\t\tUnhashedToken: \"\",\n\t\t\t}, nil\n\t\t}\n\n\t\tsc.userAuthTokenService.TryRotateTokenProvider = func(ctx context.Context, userToken *models.UserToken,\n\t\t\tclientIP net.IP, userAgent string) (bool, error) {\n\t\t\tuserToken.UnhashedToken = \"rotated\"\n\t\t\treturn true, nil\n\t\t}\n\n\t\tmaxAge := int(sc.cfg.LoginMaxLifetime.Seconds())\n\n\t\tsameSiteModes := []http.SameSite{\n\t\t\thttp.SameSiteNoneMode,\n\t\t\thttp.SameSiteLaxMode,\n\t\t\thttp.SameSiteStrictMode,\n\t\t}\n\t\tfor _, sameSiteMode := range sameSiteModes {\n\t\t\tt.Run(fmt.Sprintf(\"Same site mode %d\", sameSiteMode), func(t *testing.T) {\n\t\t\t\torigCookieSameSiteMode := setting.CookieSameSiteMode\n\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\tsetting.CookieSameSiteMode = origCookieSameSiteMode\n\t\t\t\t})\n\t\t\t\tsetting.CookieSameSiteMode = sameSiteMode\n\n\t\t\t\texpectedCookiePath := \"/\"\n\t\t\t\tif len(sc.cfg.AppSubURL) > 0 {\n\t\t\t\t\texpectedCookiePath = sc.cfg.AppSubURL\n\t\t\t\t}\n\t\t\t\texpectedCookie := &http.Cookie{\n\t\t\t\t\tName:     sc.cfg.LoginCookieName,\n\t\t\t\t\tValue:    \"rotated\",\n\t\t\t\t\tPath:     expectedCookiePath,\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tMaxAge:   maxAge,\n\t\t\t\t\tSecure:   setting.CookieSecure,\n\t\t\t\t\tSameSite: sameSiteMode,\n\t\t\t\t}\n\n\t\t\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\t\tassert.Equal(t, userID, sc.context.UserToken.UserId)\n\t\t\t\tassert.Equal(t, \"rotated\", sc.context.UserToken.UnhashedToken)\n\t\t\t\tassert.Equal(t, expectedCookie.String(), sc.resp.Header().Get(\"Set-Cookie\"))\n\t\t\t})\n\t\t}\n\n\t\tt.Run(\"Should not set cookie with SameSite attribute when setting.CookieSameSiteDisabled is true\", func(t *testing.T) {\n\t\t\torigCookieSameSiteDisabled := setting.CookieSameSiteDisabled\n\t\t\torigCookieSameSiteMode := setting.CookieSameSiteMode\n\t\t\tt.Cleanup(func() {\n\t\t\t\tsetting.CookieSameSiteDisabled = origCookieSameSiteDisabled\n\t\t\t\tsetting.CookieSameSiteMode = origCookieSameSiteMode\n\t\t\t})\n\t\t\tsetting.CookieSameSiteDisabled = true\n\t\t\tsetting.CookieSameSiteMode = http.SameSiteLaxMode\n\n\t\t\texpectedCookiePath := \"/\"\n\t\t\tif len(sc.cfg.AppSubURL) > 0 {\n\t\t\t\texpectedCookiePath = sc.cfg.AppSubURL\n\t\t\t}\n\t\t\texpectedCookie := &http.Cookie{\n\t\t\t\tName:     sc.cfg.LoginCookieName,\n\t\t\t\tValue:    \"rotated\",\n\t\t\t\tPath:     expectedCookiePath,\n\t\t\t\tHttpOnly: true,\n\t\t\t\tMaxAge:   maxAge,\n\t\t\t\tSecure:   setting.CookieSecure,\n\t\t\t}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\t\t\tassert.Equal(t, expectedCookie.String(), sc.resp.Header().Get(\"Set-Cookie\"))\n\t\t})\n\t})\n\n\tmiddlewareScenario(t, \"Invalid/expired auth token in cookie\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.withTokenSessionCookie(\"token\")\n\n\t\tsc.userAuthTokenService.LookupTokenProvider = func(ctx context.Context, unhashedToken string) (*models.UserToken, error) {\n\t\t\treturn nil, models.ErrUserTokenNotFound\n\t\t}\n\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\tassert.False(t, sc.context.IsSignedIn)\n\t\tassert.Equal(t, int64(0), sc.context.UserId)\n\t\tassert.Nil(t, sc.context.UserToken)\n\t})\n\n\tmiddlewareScenario(t, \"When anonymous access is enabled\", func(t *testing.T, sc *scenarioContext) {\n\t\tsc.mockSQLStore.ExpectedOrg = &models.Org{Id: 1, Name: sc.cfg.AnonymousOrgName}\n\t\torg, err := sc.mockSQLStore.CreateOrgWithMember(sc.cfg.AnonymousOrgName, 1)\n\t\trequire.NoError(t, err)\n\t\tsc.fakeReq(\"GET\", \"/\").exec()\n\n\t\tassert.Equal(t, int64(0), sc.context.UserId)\n\t\tassert.Equal(t, org.Id, sc.context.OrgId)\n\t\tassert.Equal(t, models.ROLE_EDITOR, sc.context.OrgRole)\n\t\tassert.False(t, sc.context.IsSignedIn)\n\t}, func(cfg *setting.Cfg) {\n\t\tcfg.AnonymousEnabled = true\n\t\tcfg.AnonymousOrgName = \"test\"\n\t\tcfg.AnonymousOrgRole = string(models.ROLE_EDITOR)\n\t})\n\n\tt.Run(\"auth_proxy\", func(t *testing.T) {\n\t\tconst userID int64 = 33\n\t\tconst orgID int64 = 4\n\t\tconst defaultOrgId int64 = 1\n\t\tconst orgRole = \"Admin\"\n\n\t\tconfigure := func(cfg *setting.Cfg) {\n\t\t\tcfg.AuthProxyEnabled = true\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t\tcfg.LDAPEnabled = true\n\t\t\tcfg.AuthProxyHeaderName = \"X-WEBAUTH-USER\"\n\t\t\tcfg.AuthProxyHeaderProperty = \"username\"\n\t\t\tcfg.AuthProxyHeaders = map[string]string{\"Groups\": \"X-WEBAUTH-GROUPS\", \"Role\": \"X-WEBAUTH-ROLE\"}\n\t\t}\n\n\t\tconst hdrName = \"markelog\"\n\t\tconst group = \"grafana-core-team\"\n\n\t\tmiddlewareScenario(t, \"Should not sync the user if it's in the cache\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\n\t\t\th, err := authproxy.HashCacheKey(hdrName + \"-\" + group)\n\t\t\trequire.NoError(t, err)\n\t\t\tkey := fmt.Sprintf(authproxy.CachePrefix, h)\n\t\t\terr = sc.remoteCacheService.Set(context.Background(), key, userID, 0)\n\t\t\trequire.NoError(t, err)\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"X-WEBAUTH-GROUPS\", group)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, configure)\n\n\t\tmiddlewareScenario(t, \"Should respect auto signup option\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar actualAuthProxyAutoSignUp *bool = nil\n\t\t\tsc.loginService.ExpectedUserFunc = func(cmd *models.UpsertUserCommand) *models.User {\n\t\t\t\tactualAuthProxyAutoSignUp = &cmd.SignupAllowed\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tsc.loginService.ExpectedError = login.ErrInvalidCredentials\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.False(t, *actualAuthProxyAutoSignUp)\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should create an user from a header\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(sc.context.Req.Context())\n\t\t\trequire.NotNil(t, list)\n\t\t\trequire.Contains(t, list.Items, sc.cfg.AuthProxyHeaderName)\n\t\t\trequire.Contains(t, list.Items, \"X-WEBAUTH-GROUPS\")\n\t\t\trequire.Contains(t, list.Items, \"X-WEBAUTH-ROLE\")\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should assign role from header to default org\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar storedRoleInfo map[int64]models.RoleType = nil\n\t\t\tsc.loginService.ExpectedUserFunc = func(cmd *models.UpsertUserCommand) *models.User {\n\t\t\t\tstoredRoleInfo = cmd.ExternalUser.OrgRoles\n\t\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: defaultOrgId, UserId: userID, OrgRole: storedRoleInfo[defaultOrgId]}\n\t\t\t\treturn &models.User{Id: userID}\n\t\t\t}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"X-WEBAUTH-ROLE\", orgRole)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, defaultOrgId, sc.context.OrgId)\n\t\t\tassert.Equal(t, orgRole, string(sc.context.OrgRole))\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should NOT assign role from header to non-default org\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar storedRoleInfo map[int64]models.RoleType = nil\n\t\t\tsc.loginService.ExpectedUserFunc = func(cmd *models.UpsertUserCommand) *models.User {\n\t\t\t\tstoredRoleInfo = cmd.ExternalUser.OrgRoles\n\t\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID, OrgRole: storedRoleInfo[orgID]}\n\t\t\t\treturn &models.User{Id: userID}\n\t\t\t}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"X-WEBAUTH-ROLE\", \"Admin\")\n\t\t\tsc.req.Header.Set(\"X-Grafana-Org-Id\", strconv.FormatInt(orgID, 10))\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\n\t\t\t// For non-default org, the user role should be empty\n\t\t\tassert.Equal(t, \"\", string(sc.context.OrgRole))\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should use organisation specified by targetOrgId parameter\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tvar targetOrgID int64 = 123\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: targetOrgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", fmt.Sprintf(\"/?targetOrgId=%d\", targetOrgID))\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, targetOrgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t\tcfg.AuthProxyAutoSignUp = true\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Request body should not be read in default context handler\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.fakeReq(\"POST\", \"/?targetOrgId=123\")\n\t\t\tbody := \"key=value\"\n\t\t\tsc.req.Body = io.NopCloser(strings.NewReader(body))\n\n\t\t\tsc.handlerFunc = func(c *models.ReqContext) {\n\t\t\t\tt.Log(\"Handler called\")\n\t\t\t\tdefer func() {\n\t\t\t\t\terr := c.Req.Body.Close()\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}()\n\n\t\t\t\tbodyAfterHandler, e := io.ReadAll(c.Req.Body)\n\t\t\t\trequire.NoError(t, e)\n\t\t\t\trequire.Equal(t, body, string(bodyAfterHandler))\n\t\t\t}\n\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\t\tsc.req.Header.Set(\"Content-Length\", strconv.Itoa(len(body)))\n\t\t\tsc.m.Post(\"/\", sc.defaultHandler)\n\t\t\tsc.exec()\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should get an existing user from header\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tconst userID int64 = 12\n\t\t\tconst orgID int64 = 2\n\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.LDAPEnabled = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should allow the request from whitelist IP\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.mockSQLStore.ExpectedSignedInUser = &models.SignedInUser{OrgId: orgID, UserId: userID}\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.RemoteAddr = \"[2001::23]:12345\"\n\t\t\tsc.exec()\n\n\t\t\tassert.True(t, sc.context.IsSignedIn)\n\t\t\tassert.Equal(t, userID, sc.context.UserId)\n\t\t\tassert.Equal(t, orgID, sc.context.OrgId)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.AuthProxyWhitelist = \"192.168.1.0/24, 2001::0/120\"\n\t\t\tcfg.LDAPEnabled = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should not allow the request from whitelisted IP\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.loginService.ExpectedUser = &models.User{Id: userID}\n\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.req.RemoteAddr = \"[2001::23]:12345\"\n\t\t\tsc.exec()\n\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, func(cfg *setting.Cfg) {\n\t\t\tconfigure(cfg)\n\t\t\tcfg.AuthProxyWhitelist = \"8.8.8.8\"\n\t\t\tcfg.LDAPEnabled = false\n\t\t})\n\n\t\tmiddlewareScenario(t, \"Should return 407 status code if LDAP says no\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, configure)\n\n\t\tmiddlewareScenario(t, \"Should return 407 status code if there is cache mishap\", func(t *testing.T, sc *scenarioContext) {\n\t\t\tsc.fakeReq(\"GET\", \"/\")\n\t\t\tsc.req.Header.Set(sc.cfg.AuthProxyHeaderName, hdrName)\n\t\t\tsc.exec()\n\n\t\t\tassert.Equal(t, 407, sc.resp.Code)\n\t\t\tassert.Nil(t, sc.context)\n\t\t}, configure)\n\t})\n}\n\nfunc middlewareScenario(t *testing.T, desc string, fn scenarioFunc, cbs ...func(*setting.Cfg)) {\n\tt.Helper()\n\n\tt.Run(desc, func(t *testing.T) {\n\t\tlogger := log.New(\"test\")\n\n\t\tloginMaxLifetime, err := gtime.ParseDuration(\"30d\")\n\t\trequire.NoError(t, err)\n\t\tcfg := setting.NewCfg()\n\t\tcfg.LoginCookieName = \"grafana_session\"\n\t\tcfg.LoginMaxLifetime = loginMaxLifetime\n\t\t// Required when rendering errors\n\t\tcfg.ErrTemplateName = \"error-template\"\n\t\tfor _, cb := range cbs {\n\t\t\tcb(cfg)\n\t\t}\n\n\t\tsc := &scenarioContext{t: t, cfg: cfg}\n\t\tviewsPath, err := filepath.Abs(\"../../public/views\")\n\t\trequire.NoError(t, err)\n\t\texists, err := fs.Exists(viewsPath)\n\t\trequire.NoError(t, err)\n\t\trequire.Truef(t, exists, \"Views directory should exist at %q\", viewsPath)\n\n\t\tsc.m = web.New()\n\t\tsc.m.Use(AddDefaultResponseHeaders(cfg))\n\t\tsc.m.UseMiddleware(AddCSPHeader(cfg, logger))\n\t\tsc.m.UseMiddleware(web.Renderer(viewsPath, \"[[\", \"]]\"))\n\n\t\tsc.mockSQLStore = mockstore.NewSQLStoreMock()\n\t\tsc.loginService = &loginservice.LoginServiceMock{}\n\t\tctxHdlr := getContextHandler(t, cfg, sc.mockSQLStore, sc.loginService)\n\t\tsc.sqlStore = ctxHdlr.SQLStore\n\t\tsc.contextHandler = ctxHdlr\n\t\tsc.m.Use(ctxHdlr.Middleware)\n\t\tsc.m.Use(OrgRedirect(sc.cfg, sc.mockSQLStore))\n\n\t\tsc.userAuthTokenService = ctxHdlr.AuthTokenService.(*auth.FakeUserAuthTokenService)\n\t\tsc.jwtAuthService = ctxHdlr.JWTAuthService.(*models.FakeJWTService)\n\t\tsc.remoteCacheService = ctxHdlr.RemoteCache\n\n\t\tsc.defaultHandler = func(c *models.ReqContext) {\n\t\t\trequire.NotNil(t, c)\n\t\t\tt.Log(\"Default HTTP handler called\")\n\t\t\tsc.context = c\n\t\t\tif sc.handlerFunc != nil {\n\t\t\t\tsc.handlerFunc(sc.context)\n\t\t\t} else {\n\t\t\t\tt.Log(\"Returning JSON OK\")\n\t\t\t\tresp := make(map[string]interface{})\n\t\t\t\tresp[\"message\"] = \"OK\"\n\t\t\t\tc.JSON(200, resp)\n\t\t\t}\n\t\t}\n\n\t\tsc.m.Get(\"/\", sc.defaultHandler)\n\n\t\tfn(t, sc)\n\t})\n}\n\nfunc getContextHandler(t *testing.T, cfg *setting.Cfg, mockSQLStore *mockstore.SQLStoreMock, loginService *loginservice.LoginServiceMock) *contexthandler.ContextHandler {\n\tt.Helper()\n\n\tif cfg == nil {\n\t\tcfg = setting.NewCfg()\n\t}\n\tcfg.RemoteCacheOptions = &setting.RemoteCacheOptions{\n\t\tName: \"database\",\n\t}\n\n\tremoteCacheSvc := remotecache.NewFakeStore(t)\n\tuserAuthTokenSvc := auth.NewFakeUserAuthTokenService()\n\trenderSvc := &fakeRenderService{}\n\tauthJWTSvc := models.NewFakeJWTService()\n\ttracer, err := tracing.InitializeTracerForTest()\n\tauthProxy := authproxy.ProvideAuthProxy(cfg, remoteCacheSvc, loginService, mockSQLStore)\n\tauthenticator := &logintest.AuthenticatorFake{ExpectedUser: &models.User{}}\n\trequire.NoError(t, err)\n\treturn contexthandler.ProvideService(cfg, userAuthTokenSvc, authJWTSvc, remoteCacheSvc, renderSvc, mockSQLStore, tracer, authProxy, loginService, authenticator)\n}\n\ntype fakeRenderService struct {\n\trendering.Service\n}\n\nfunc (s *fakeRenderService) Init() error {\n\treturn nil\n}\n", "package contexthandler\n\nimport (\n\t\"errors\"\n\n\t\"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/models\"\n)\n\nconst InvalidJWT = \"Invalid JWT\"\nconst UserNotFound = \"User not found\"\n\nfunc (h *ContextHandler) initContextWithJWT(ctx *models.ReqContext, orgId int64) bool {\n\tif !h.Cfg.JWTAuthEnabled || h.Cfg.JWTAuthHeaderName == \"\" {\n\t\treturn false\n\t}\n\n\tjwtToken := ctx.Req.Header.Get(h.Cfg.JWTAuthHeaderName)\n\tif jwtToken == \"\" {\n\t\treturn false\n\t}\n\n\tclaims, err := h.JWTAuthService.Verify(ctx.Req.Context(), jwtToken)\n\tif err != nil {\n\t\tctx.Logger.Debug(\"Failed to verify JWT\", \"error\", err)\n\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\treturn true\n\t}\n\n\tquery := models.GetSignedInUserQuery{OrgId: orgId}\n\n\tsub, _ := claims[\"sub\"].(string)\n\n\tif sub == \"\" {\n\t\tctx.Logger.Warn(\"Got a JWT without the mandatory 'sub' claim\", \"error\", err)\n\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\treturn true\n\t}\n\textUser := &models.ExternalUserInfo{\n\t\tAuthModule: \"jwt\",\n\t\tAuthId:     sub,\n\t}\n\n\tif key := h.Cfg.JWTAuthUsernameClaim; key != \"\" {\n\t\tquery.Login, _ = claims[key].(string)\n\t\textUser.Login, _ = claims[key].(string)\n\t}\n\tif key := h.Cfg.JWTAuthEmailClaim; key != \"\" {\n\t\tquery.Email, _ = claims[key].(string)\n\t\textUser.Email, _ = claims[key].(string)\n\t}\n\n\tif name, _ := claims[\"name\"].(string); name != \"\" {\n\t\textUser.Name = name\n\t}\n\n\tif query.Login == \"\" && query.Email == \"\" {\n\t\tctx.Logger.Debug(\"Failed to get an authentication claim from JWT\")\n\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\treturn true\n\t}\n\n\tif h.Cfg.JWTAuthAutoSignUp {\n\t\tupsert := &models.UpsertUserCommand{\n\t\t\tReqContext:    ctx,\n\t\t\tSignupAllowed: h.Cfg.JWTAuthAutoSignUp,\n\t\t\tExternalUser:  extUser,\n\t\t\tUserLookupParams: models.UserLookupParams{\n\t\t\t\tUserID: nil,\n\t\t\t\tLogin:  &query.Login,\n\t\t\t\tEmail:  &query.Email,\n\t\t\t},\n\t\t}\n\t\tif err := h.loginService.UpsertUser(ctx.Req.Context(), upsert); err != nil {\n\t\t\tctx.Logger.Error(\"Failed to upsert JWT user\", \"error\", err)\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(ctx.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tctx.Logger.Debug(\n\t\t\t\t\"Failed to find user using JWT claims\",\n\t\t\t\t\"email_claim\", query.Email,\n\t\t\t\t\"username_claim\", query.Login,\n\t\t\t)\n\t\t\terr = login.ErrInvalidCredentials\n\t\t\tctx.JsonApiErr(401, UserNotFound, err)\n\t\t} else {\n\t\t\tctx.Logger.Error(\"Failed to get signed in user\", \"error\", err)\n\t\t\tctx.JsonApiErr(401, InvalidJWT, err)\n\t\t}\n\t\treturn true\n\t}\n\n\tnewCtx := WithAuthHTTPHeader(ctx.Req.Context(), h.Cfg.JWTAuthHeaderName)\n\t*ctx.Req = *ctx.Req.WithContext(newCtx)\n\n\tctx.SignedInUser = query.Result\n\tctx.IsSignedIn = true\n\n\treturn true\n}\n", "// Package contexthandler contains the ContextHandler service.\npackage contexthandler\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/components/apikeygen\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/infra/network\"\n\t\"github.com/grafana/grafana/pkg/infra/remotecache\"\n\t\"github.com/grafana/grafana/pkg/infra/tracing\"\n\tloginpkg \"github.com/grafana/grafana/pkg/login\"\n\t\"github.com/grafana/grafana/pkg/middleware/cookies\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler/authproxy\"\n\t\"github.com/grafana/grafana/pkg/services/login\"\n\t\"github.com/grafana/grafana/pkg/services/rendering\"\n\t\"github.com/grafana/grafana/pkg/services/sqlstore\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nconst (\n\tInvalidUsernamePassword = \"invalid username or password\"\n\tInvalidAPIKey           = \"invalid API key\"\n)\n\nconst ServiceName = \"ContextHandler\"\n\nfunc ProvideService(cfg *setting.Cfg, tokenService models.UserTokenService, jwtService models.JWTService,\n\tremoteCache *remotecache.RemoteCache, renderService rendering.Service, sqlStore sqlstore.Store,\n\ttracer tracing.Tracer, authProxy *authproxy.AuthProxy, loginService login.Service, authenticator loginpkg.Authenticator) *ContextHandler {\n\treturn &ContextHandler{\n\t\tCfg:              cfg,\n\t\tAuthTokenService: tokenService,\n\t\tJWTAuthService:   jwtService,\n\t\tRemoteCache:      remoteCache,\n\t\tRenderService:    renderService,\n\t\tSQLStore:         sqlStore,\n\t\ttracer:           tracer,\n\t\tauthProxy:        authProxy,\n\t\tauthenticator:    authenticator,\n\t\tloginService:     loginService,\n\t}\n}\n\n// ContextHandler is a middleware.\ntype ContextHandler struct {\n\tCfg              *setting.Cfg\n\tAuthTokenService models.UserTokenService\n\tJWTAuthService   models.JWTService\n\tRemoteCache      *remotecache.RemoteCache\n\tRenderService    rendering.Service\n\tSQLStore         sqlstore.Store\n\ttracer           tracing.Tracer\n\tauthProxy        *authproxy.AuthProxy\n\tauthenticator    loginpkg.Authenticator\n\tloginService     login.Service\n\t// GetTime returns the current time.\n\t// Stubbable by tests.\n\tGetTime func() time.Time\n}\n\ntype reqContextKey struct{}\n\n// FromContext returns the ReqContext value stored in a context.Context, if any.\nfunc FromContext(c context.Context) *models.ReqContext {\n\tif reqCtx, ok := c.Value(reqContextKey{}).(*models.ReqContext); ok {\n\t\treturn reqCtx\n\t}\n\treturn nil\n}\n\n// Middleware provides a middleware to initialize the Macaron context.\nfunc (h *ContextHandler) Middleware(mContext *web.Context) {\n\t_, span := h.tracer.Start(mContext.Req.Context(), \"Auth - Middleware\")\n\tdefer span.End()\n\n\treqContext := &models.ReqContext{\n\t\tContext:        mContext,\n\t\tSignedInUser:   &models.SignedInUser{},\n\t\tIsSignedIn:     false,\n\t\tAllowAnonymous: false,\n\t\tSkipCache:      false,\n\t\tLogger:         log.New(\"context\"),\n\t}\n\n\t// Inject ReqContext into a request context and replace the request instance in the macaron context\n\tmContext.Req = mContext.Req.WithContext(context.WithValue(mContext.Req.Context(), reqContextKey{}, reqContext))\n\tmContext.Map(mContext.Req)\n\n\ttraceID := tracing.TraceIDFromContext(mContext.Req.Context(), false)\n\tif traceID != \"\" {\n\t\treqContext.Logger = reqContext.Logger.New(\"traceID\", traceID)\n\t}\n\n\tconst headerName = \"X-Grafana-Org-Id\"\n\torgID := int64(0)\n\torgIDHeader := reqContext.Req.Header.Get(headerName)\n\tif orgIDHeader != \"\" {\n\t\tid, err := strconv.ParseInt(orgIDHeader, 10, 64)\n\t\tif err == nil {\n\t\t\torgID = id\n\t\t} else {\n\t\t\treqContext.Logger.Debug(\"Received invalid header\", \"header\", headerName, \"value\", orgIDHeader)\n\t\t}\n\t}\n\n\tqueryParameters, err := url.ParseQuery(reqContext.Req.URL.RawQuery)\n\tif err != nil {\n\t\treqContext.Logger.Error(\"Failed to parse query parameters\", \"error\", err)\n\t}\n\tif queryParameters.Has(\"targetOrgId\") {\n\t\ttargetOrg, err := strconv.ParseInt(queryParameters.Get(\"targetOrgId\"), 10, 64)\n\t\tif err == nil {\n\t\t\torgID = targetOrg\n\t\t} else {\n\t\t\treqContext.Logger.Error(\"Invalid target organization ID\", \"error\", err)\n\t\t}\n\t}\n\n\t// the order in which these are tested are important\n\t// look for api key in Authorization header first\n\t// then init session and look for userId in session\n\t// then look for api key in session (special case for render calls via api)\n\t// then test if anonymous access is enabled\n\tswitch {\n\tcase h.initContextWithRenderAuth(reqContext):\n\tcase h.initContextWithAPIKey(reqContext):\n\tcase h.initContextWithBasicAuth(reqContext, orgID):\n\tcase h.initContextWithAuthProxy(reqContext, orgID):\n\tcase h.initContextWithToken(reqContext, orgID):\n\tcase h.initContextWithJWT(reqContext, orgID):\n\tcase h.initContextWithAnonymousUser(reqContext):\n\t}\n\n\treqContext.Logger = reqContext.Logger.New(\"userId\", reqContext.UserId, \"orgId\", reqContext.OrgId, \"uname\", reqContext.Login)\n\tspan.AddEvents(\n\t\t[]string{\"uname\", \"orgId\", \"userId\"},\n\t\t[]tracing.EventValue{\n\t\t\t{Str: reqContext.Login},\n\t\t\t{Num: reqContext.OrgId},\n\t\t\t{Num: reqContext.UserId}},\n\t)\n\n\tmContext.Map(reqContext)\n\n\t// update last seen every 5min\n\tif reqContext.ShouldUpdateLastSeenAt() {\n\t\treqContext.Logger.Debug(\"Updating last user_seen_at\", \"user_id\", reqContext.UserId)\n\t\tif err := h.SQLStore.UpdateUserLastSeenAt(mContext.Req.Context(), &models.UpdateUserLastSeenAtCommand{UserId: reqContext.UserId}); err != nil {\n\t\t\treqContext.Logger.Error(\"Failed to update last_seen_at\", \"error\", err)\n\t\t}\n\t}\n}\n\nfunc (h *ContextHandler) initContextWithAnonymousUser(reqContext *models.ReqContext) bool {\n\tif !h.Cfg.AnonymousEnabled {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithAnonymousUser\")\n\tdefer span.End()\n\n\torg, err := h.SQLStore.GetOrgByName(h.Cfg.AnonymousOrgName)\n\tif err != nil {\n\t\treqContext.Logger.Error(\"Anonymous access organization error.\", \"org_name\", h.Cfg.AnonymousOrgName, \"error\", err)\n\t\treturn false\n\t}\n\n\treqContext.IsSignedIn = false\n\treqContext.AllowAnonymous = true\n\treqContext.SignedInUser = &models.SignedInUser{IsAnonymous: true}\n\treqContext.OrgRole = models.RoleType(h.Cfg.AnonymousOrgRole)\n\treqContext.OrgId = org.Id\n\treqContext.OrgName = org.Name\n\treturn true\n}\n\nfunc (h *ContextHandler) initContextWithAPIKey(reqContext *models.ReqContext) bool {\n\theader := reqContext.Req.Header.Get(\"Authorization\")\n\tparts := strings.SplitN(header, \" \", 2)\n\tvar keyString string\n\tif len(parts) == 2 && parts[0] == \"Bearer\" {\n\t\tkeyString = parts[1]\n\t} else {\n\t\tusername, password, err := util.DecodeBasicAuthHeader(header)\n\t\tif err == nil && username == \"api_key\" {\n\t\t\tkeyString = password\n\t\t}\n\t}\n\n\tif keyString == \"\" {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithAPIKey\")\n\tdefer span.End()\n\n\t// base64 decode key\n\tdecoded, err := apikeygen.Decode(keyString)\n\tif err != nil {\n\t\treqContext.JsonApiErr(401, InvalidAPIKey, err)\n\t\treturn true\n\t}\n\n\tctx := WithAuthHTTPHeader(reqContext.Req.Context(), \"Authorization\")\n\t*reqContext.Req = *reqContext.Req.WithContext(ctx)\n\n\t// fetch key\n\tkeyQuery := models.GetApiKeyByNameQuery{KeyName: decoded.Name, OrgId: decoded.OrgId}\n\tif err := h.SQLStore.GetApiKeyByName(reqContext.Req.Context(), &keyQuery); err != nil {\n\t\treqContext.JsonApiErr(401, InvalidAPIKey, err)\n\t\treturn true\n\t}\n\n\tapikey := keyQuery.Result\n\n\t// validate api key\n\tisValid, err := apikeygen.IsValid(decoded, apikey.Key)\n\tif err != nil {\n\t\treqContext.JsonApiErr(500, \"Validating API key failed\", err)\n\t\treturn true\n\t}\n\tif !isValid {\n\t\treqContext.JsonApiErr(401, InvalidAPIKey, err)\n\t\treturn true\n\t}\n\n\t// check for expiration\n\tgetTime := h.GetTime\n\tif getTime == nil {\n\t\tgetTime = time.Now\n\t}\n\tif apikey.Expires != nil && *apikey.Expires <= getTime().Unix() {\n\t\treqContext.JsonApiErr(401, \"Expired API key\", err)\n\t\treturn true\n\t}\n\n\tif apikey.ServiceAccountId == nil || *apikey.ServiceAccountId < 1 { //There is no service account attached to the apikey\n\t\t//Use the old APIkey method.  This provides backwards compatibility.\n\t\treqContext.SignedInUser = &models.SignedInUser{}\n\t\treqContext.OrgRole = apikey.Role\n\t\treqContext.ApiKeyId = apikey.Id\n\t\treqContext.OrgId = apikey.OrgId\n\t\treqContext.IsSignedIn = true\n\t\treturn true\n\t}\n\n\t//There is a service account attached to the API key\n\n\t//Use service account linked to API key as the signed in user\n\tquerySignedInUser := models.GetSignedInUserQuery{UserId: *apikey.ServiceAccountId, OrgId: apikey.OrgId}\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(reqContext.Req.Context(), &querySignedInUser); err != nil {\n\t\treqContext.Logger.Error(\n\t\t\t\"Failed to link API key to service account in\",\n\t\t\t\"id\", querySignedInUser.UserId,\n\t\t\t\"org\", querySignedInUser.OrgId,\n\t\t\t\"err\", err,\n\t\t)\n\t\treqContext.JsonApiErr(http.StatusInternalServerError, \"Unable to link API key to service account\", err)\n\t\treturn true\n\t}\n\n\t// disabled service accounts are not allowed to access the API\n\tif querySignedInUser.Result.IsDisabled {\n\t\treqContext.JsonApiErr(http.StatusUnauthorized, \"Service account is disabled\", nil)\n\t\treturn true\n\t}\n\n\treqContext.IsSignedIn = true\n\treqContext.SignedInUser = querySignedInUser.Result\n\treturn true\n}\n\nfunc (h *ContextHandler) initContextWithBasicAuth(reqContext *models.ReqContext, orgID int64) bool {\n\tif !h.Cfg.BasicAuthEnabled {\n\t\treturn false\n\t}\n\n\theader := reqContext.Req.Header.Get(\"Authorization\")\n\tif header == \"\" {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithBasicAuth\")\n\tdefer span.End()\n\n\tusername, password, err := util.DecodeBasicAuthHeader(header)\n\tif err != nil {\n\t\treqContext.JsonApiErr(401, \"Invalid Basic Auth Header\", err)\n\t\treturn true\n\t}\n\n\tctx := WithAuthHTTPHeader(reqContext.Req.Context(), \"Authorization\")\n\t*reqContext.Req = *reqContext.Req.WithContext(ctx)\n\n\tauthQuery := models.LoginUserQuery{\n\t\tUsername: username,\n\t\tPassword: password,\n\t\tCfg:      h.Cfg,\n\t}\n\tif err := h.authenticator.AuthenticateUser(ctx, &authQuery); err != nil {\n\t\treqContext.Logger.Debug(\n\t\t\t\"Failed to authorize the user\",\n\t\t\t\"username\", username,\n\t\t\t\"err\", err,\n\t\t)\n\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\terr = login.ErrInvalidCredentials\n\t\t}\n\t\treqContext.JsonApiErr(401, InvalidUsernamePassword, err)\n\t\treturn true\n\t}\n\n\tuser := authQuery.User\n\n\tquery := models.GetSignedInUserQuery{UserId: user.Id, OrgId: orgID}\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(ctx, &query); err != nil {\n\t\treqContext.Logger.Error(\n\t\t\t\"Failed at user signed in\",\n\t\t\t\"id\", user.Id,\n\t\t\t\"org\", orgID,\n\t\t)\n\t\treqContext.JsonApiErr(401, InvalidUsernamePassword, err)\n\t\treturn true\n\t}\n\n\treqContext.SignedInUser = query.Result\n\treqContext.IsSignedIn = true\n\treturn true\n}\n\nfunc (h *ContextHandler) initContextWithToken(reqContext *models.ReqContext, orgID int64) bool {\n\tif h.Cfg.LoginCookieName == \"\" {\n\t\treturn false\n\t}\n\n\trawToken := reqContext.GetCookie(h.Cfg.LoginCookieName)\n\tif rawToken == \"\" {\n\t\treturn false\n\t}\n\n\tctx, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithToken\")\n\tdefer span.End()\n\n\ttoken, err := h.AuthTokenService.LookupToken(ctx, rawToken)\n\tif err != nil {\n\t\treqContext.Logger.Error(\"Failed to look up user based on cookie\", \"error\", err)\n\t\treqContext.LookupTokenErr = err\n\t\treturn false\n\t}\n\n\tquery := models.GetSignedInUserQuery{UserId: token.UserId, OrgId: orgID}\n\tif err := h.SQLStore.GetSignedInUserWithCacheCtx(ctx, &query); err != nil {\n\t\treqContext.Logger.Error(\"Failed to get user with id\", \"userId\", token.UserId, \"error\", err)\n\t\treturn false\n\t}\n\n\treqContext.SignedInUser = query.Result\n\treqContext.IsSignedIn = true\n\treqContext.UserToken = token\n\n\t// Rotate the token just before we write response headers to ensure there is no delay between\n\t// the new token being generated and the client receiving it.\n\treqContext.Resp.Before(h.rotateEndOfRequestFunc(reqContext, h.AuthTokenService, token))\n\n\treturn true\n}\n\nfunc (h *ContextHandler) rotateEndOfRequestFunc(reqContext *models.ReqContext, authTokenService models.UserTokenService,\n\ttoken *models.UserToken) web.BeforeFunc {\n\treturn func(w web.ResponseWriter) {\n\t\t// if response has already been written, skip.\n\t\tif w.Written() {\n\t\t\treturn\n\t\t}\n\n\t\t// if the request is cancelled by the client we should not try\n\t\t// to rotate the token since the client would not accept any result.\n\t\tif errors.Is(reqContext.Context.Req.Context().Err(), context.Canceled) {\n\t\t\treturn\n\t\t}\n\n\t\tctx, span := h.tracer.Start(reqContext.Req.Context(), \"rotateEndOfRequestFunc\")\n\t\tdefer span.End()\n\n\t\taddr := reqContext.RemoteAddr()\n\t\tip, err := network.GetIPFromAddress(addr)\n\t\tif err != nil {\n\t\t\treqContext.Logger.Debug(\"Failed to get client IP address\", \"addr\", addr, \"err\", err)\n\t\t\tip = nil\n\t\t}\n\t\trotated, err := authTokenService.TryRotateToken(ctx, token, ip, reqContext.Req.UserAgent())\n\t\tif err != nil {\n\t\t\treqContext.Logger.Error(\"Failed to rotate token\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif rotated {\n\t\t\tcookies.WriteSessionCookie(reqContext, h.Cfg, token.UnhashedToken, h.Cfg.LoginMaxLifetime)\n\t\t}\n\t}\n}\n\nfunc (h *ContextHandler) initContextWithRenderAuth(reqContext *models.ReqContext) bool {\n\tkey := reqContext.GetCookie(\"renderKey\")\n\tif key == \"\" {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithRenderAuth\")\n\tdefer span.End()\n\n\trenderUser, exists := h.RenderService.GetRenderUser(reqContext.Req.Context(), key)\n\tif !exists {\n\t\treqContext.JsonApiErr(401, \"Invalid Render Key\", nil)\n\t\treturn true\n\t}\n\n\treqContext.IsSignedIn = true\n\treqContext.SignedInUser = &models.SignedInUser{\n\t\tOrgId:   renderUser.OrgID,\n\t\tUserId:  renderUser.UserID,\n\t\tOrgRole: models.RoleType(renderUser.OrgRole),\n\t}\n\treqContext.IsRenderCall = true\n\treqContext.LastSeenAt = time.Now()\n\treturn true\n}\n\nfunc logUserIn(reqContext *models.ReqContext, auth *authproxy.AuthProxy, username string, logger log.Logger, ignoreCache bool) (int64, error) {\n\tlogger.Debug(\"Trying to log user in\", \"username\", username, \"ignoreCache\", ignoreCache)\n\t// Try to log in user via various providers\n\tid, err := auth.Login(reqContext, ignoreCache)\n\tif err != nil {\n\t\tdetails := err\n\t\tvar e authproxy.Error\n\t\tif errors.As(err, &e) {\n\t\t\tdetails = e.DetailsError\n\t\t}\n\t\tlogger.Error(\"Failed to login\", \"username\", username, \"message\", err.Error(), \"error\", details,\n\t\t\t\"ignoreCache\", ignoreCache)\n\t\treturn 0, err\n\t}\n\treturn id, nil\n}\n\nfunc (h *ContextHandler) handleError(ctx *models.ReqContext, err error, statusCode int, cb func(error)) {\n\tdetails := err\n\tvar e authproxy.Error\n\tif errors.As(err, &e) {\n\t\tdetails = e.DetailsError\n\t}\n\tctx.Handle(h.Cfg, statusCode, err.Error(), details)\n\n\tif cb != nil {\n\t\tcb(details)\n\t}\n}\n\nfunc (h *ContextHandler) initContextWithAuthProxy(reqContext *models.ReqContext, orgID int64) bool {\n\tusername := reqContext.Req.Header.Get(h.Cfg.AuthProxyHeaderName)\n\n\tlogger := log.New(\"auth.proxy\")\n\n\t// Bail if auth proxy is not enabled\n\tif !h.authProxy.IsEnabled() {\n\t\treturn false\n\t}\n\n\t// If there is no header - we can't move forward\n\tif !h.authProxy.HasHeader(reqContext) {\n\t\treturn false\n\t}\n\n\t_, span := h.tracer.Start(reqContext.Req.Context(), \"initContextWithAuthProxy\")\n\tdefer span.End()\n\n\t// Check if allowed continuing with this IP\n\tif err := h.authProxy.IsAllowedIP(reqContext.Req.RemoteAddr); err != nil {\n\t\th.handleError(reqContext, err, 407, func(details error) {\n\t\t\tlogger.Error(\"Failed to check whitelisted IP addresses\", \"message\", err.Error(), \"error\", details)\n\t\t})\n\t\treturn true\n\t}\n\n\tid, err := logUserIn(reqContext, h.authProxy, username, logger, false)\n\tif err != nil {\n\t\th.handleError(reqContext, err, 407, nil)\n\t\treturn true\n\t}\n\n\tlogger.Debug(\"Got user ID, getting full user info\", \"userID\", id)\n\n\tuser, err := h.authProxy.GetSignedInUser(id, orgID)\n\tif err != nil {\n\t\t// The reason we couldn't find the user corresponding to the ID might be that the ID was found from a stale\n\t\t// cache entry. For example, if a user is deleted via the API, corresponding cache entries aren't invalidated\n\t\t// because cache keys are computed from request header values and not just the user ID. Meaning that\n\t\t// we can't easily derive cache keys to invalidate when deleting a user. To work around this, we try to\n\t\t// log the user in again without the cache.\n\t\tlogger.Debug(\"Failed to get user info given ID, retrying without cache\", \"userID\", id)\n\t\tif err := h.authProxy.RemoveUserFromCache(reqContext); err != nil {\n\t\t\tif !errors.Is(err, remotecache.ErrCacheItemNotFound) {\n\t\t\t\tlogger.Error(\"Got unexpected error when removing user from auth cache\", \"error\", err)\n\t\t\t}\n\t\t}\n\t\tid, err = logUserIn(reqContext, h.authProxy, username, logger, true)\n\t\tif err != nil {\n\t\t\th.handleError(reqContext, err, 407, nil)\n\t\t\treturn true\n\t\t}\n\n\t\tuser, err = h.authProxy.GetSignedInUser(id, orgID)\n\t\tif err != nil {\n\t\t\th.handleError(reqContext, err, 407, nil)\n\t\t\treturn true\n\t\t}\n\t}\n\n\tlogger.Debug(\"Successfully got user info\", \"userID\", user.UserId, \"username\", user.Login)\n\n\tctx := WithAuthHTTPHeader(reqContext.Req.Context(), h.Cfg.AuthProxyHeaderName)\n\tfor _, header := range h.Cfg.AuthProxyHeaders {\n\t\tif header != \"\" {\n\t\t\tctx = WithAuthHTTPHeader(ctx, header)\n\t\t}\n\t}\n\n\t*reqContext.Req = *reqContext.Req.WithContext(ctx)\n\n\t// Add user info to context\n\treqContext.SignedInUser = user\n\treqContext.IsSignedIn = true\n\n\t// Remember user data in cache\n\tif err := h.authProxy.Remember(reqContext, id); err != nil {\n\t\th.handleError(reqContext, err, 500, func(details error) {\n\t\t\tlogger.Error(\n\t\t\t\t\"Failed to store user in cache\",\n\t\t\t\t\"username\", username,\n\t\t\t\t\"message\", err.Error(),\n\t\t\t\t\"error\", details,\n\t\t\t)\n\t\t})\n\t\treturn true\n\t}\n\n\treturn true\n}\n\ntype authHTTPHeaderListContextKey struct{}\n\nvar authHTTPHeaderListKey = authHTTPHeaderListContextKey{}\n\n// AuthHTTPHeaderList used to record HTTP headers that being when verifying authentication\n// of an incoming HTTP request.\ntype AuthHTTPHeaderList struct {\n\tItems []string\n}\n\n// WithAuthHTTPHeader returns a copy of parent in which the named HTTP header will be included\n// and later retrievable by AuthHTTPHeaderListFromContext.\nfunc WithAuthHTTPHeader(parent context.Context, name string) context.Context {\n\tlist := AuthHTTPHeaderListFromContext(parent)\n\n\tif list == nil {\n\t\tlist = &AuthHTTPHeaderList{\n\t\t\tItems: []string{},\n\t\t}\n\t}\n\n\tlist.Items = append(list.Items, name)\n\n\treturn context.WithValue(parent, authHTTPHeaderListKey, list)\n}\n\n// AuthHTTPHeaderListFromContext returns the AuthHTTPHeaderList in a context.Context, if any,\n// and will include any HTTP headers used when verifying authentication of an incoming HTTP request.\nfunc AuthHTTPHeaderListFromContext(c context.Context) *AuthHTTPHeaderList {\n\tif list, ok := c.Value(authHTTPHeaderListKey).(*AuthHTTPHeaderList); ok {\n\t\treturn list\n\t}\n\treturn nil\n}\n", "package proxyutil\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"strings\"\n\t\"time\"\n\n\tglog \"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n)\n\n// StatusClientClosedRequest A non-standard status code introduced by nginx\n// for the case when a client closes the connection while nginx is processing\n// the request.\n// https://httpstatus.in/499/\nconst StatusClientClosedRequest = 499\n\n// ReverseProxyOption reverse proxy option to configure a httputil.ReverseProxy.\ntype ReverseProxyOption func(*httputil.ReverseProxy)\n\n// NewReverseProxy creates a new httputil.ReverseProxy with sane default configuration.\nfunc NewReverseProxy(logger glog.Logger, director func(*http.Request), opts ...ReverseProxyOption) *httputil.ReverseProxy {\n\tif logger == nil {\n\t\tpanic(\"logger cannot be nil\")\n\t}\n\n\tif director == nil {\n\t\tpanic(\"director cannot be nil\")\n\t}\n\n\tp := &httputil.ReverseProxy{\n\t\tFlushInterval: time.Millisecond * 200,\n\t\tErrorHandler:  errorHandler(logger),\n\t\tErrorLog:      log.New(&logWrapper{logger: logger}, \"\", 0),\n\t\tDirector:      director,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\n\torigDirector := p.Director\n\tp.Director = wrapDirector(origDirector)\n\n\tif p.ModifyResponse == nil {\n\t\t// nolint:bodyclose\n\t\tp.ModifyResponse = modifyResponse(logger)\n\t} else {\n\t\tmodResponse := p.ModifyResponse\n\t\tp.ModifyResponse = func(resp *http.Response) error {\n\t\t\tif err := modResponse(resp); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// nolint:bodyclose\n\t\t\treturn modifyResponse(logger)(resp)\n\t\t}\n\t}\n\n\treturn p\n}\n\n// wrapDirector wraps a director and adds additional functionality.\nfunc wrapDirector(d func(*http.Request)) func(req *http.Request) {\n\treturn func(req *http.Request) {\n\t\tlist := contexthandler.AuthHTTPHeaderListFromContext(req.Context())\n\t\tif list != nil {\n\t\t\tfor _, name := range list.Items {\n\t\t\t\treq.Header.Del(name)\n\t\t\t}\n\t\t}\n\n\t\td(req)\n\t\tPrepareProxyRequest(req)\n\n\t\t// Clear Origin and Referer to avoid CORS issues\n\t\treq.Header.Del(\"Origin\")\n\t\treq.Header.Del(\"Referer\")\n\t}\n}\n\n// modifyResponse enforces certain constraints on http.Response.\nfunc modifyResponse(logger glog.Logger) func(resp *http.Response) error {\n\treturn func(resp *http.Response) error {\n\t\tresp.Header.Del(\"Set-Cookie\")\n\t\tSetProxyResponseHeaders(resp.Header)\n\t\treturn nil\n\t}\n}\n\ntype timeoutError interface {\n\terror\n\tTimeout() bool\n}\n\n// errorHandler handles any errors happening while proxying a request and enforces\n// certain HTTP status based on the kind of error.\n// If client cancel/close the request we return 499 StatusClientClosedRequest.\n// If timeout happens while communicating with upstream server we return http.StatusGatewayTimeout.\n// If any other error we return http.StatusBadGateway.\nfunc errorHandler(logger glog.Logger) func(http.ResponseWriter, *http.Request, error) {\n\treturn func(w http.ResponseWriter, r *http.Request, err error) {\n\t\tif errors.Is(err, context.Canceled) {\n\t\t\tlogger.Debug(\"Proxy request cancelled by client\")\n\t\t\tw.WriteHeader(StatusClientClosedRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// nolint:errorlint\n\t\tif timeoutErr, ok := err.(timeoutError); ok && timeoutErr.Timeout() {\n\t\t\tlogger.Error(\"Proxy request timed out\", \"err\", err)\n\t\t\tw.WriteHeader(http.StatusGatewayTimeout)\n\t\t\treturn\n\t\t}\n\n\t\tlogger.Error(\"Proxy request failed\", \"err\", err)\n\t\tw.WriteHeader(http.StatusBadGateway)\n\t}\n}\n\ntype logWrapper struct {\n\tlogger glog.Logger\n}\n\n// Write writes log messages as bytes from proxy.\nfunc (lw *logWrapper) Write(p []byte) (n int, err error) {\n\twithoutNewline := strings.TrimSuffix(string(p), \"\\n\")\n\tlw.logger.Error(\"Proxy request error\", \"error\", withoutNewline)\n\treturn len(p), nil\n}\n\nfunc WithTransport(transport http.RoundTripper) ReverseProxyOption {\n\tif transport == nil {\n\t\tpanic(\"transport cannot be nil\")\n\t}\n\n\treturn ReverseProxyOption(func(rp *httputil.ReverseProxy) {\n\t\trp.Transport = transport\n\t})\n}\n\nfunc WithModifyResponse(fn func(*http.Response) error) ReverseProxyOption {\n\tif fn == nil {\n\t\tpanic(\"fn cannot be nil\")\n\t}\n\n\treturn ReverseProxyOption(func(rp *httputil.ReverseProxy) {\n\t\trp.ModifyResponse = fn\n\t})\n}\n", "package proxyutil\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestReverseProxy(t *testing.T) {\n\tt.Run(\"When proxying a request should enforce request and response constraints\", func(t *testing.T) {\n\t\tvar actualReq *http.Request\n\t\tupstream := newUpstreamServer(t, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\tactualReq = req\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"test\"})\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t}))\n\t\tt.Cleanup(upstream.Close)\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, upstream.URL, nil)\n\t\treq.Header.Set(\"X-Forwarded-Host\", \"forwarded.host.com\")\n\t\treq.Header.Set(\"X-Forwarded-Port\", \"8080\")\n\t\treq.Header.Set(\"X-Forwarded-Proto\", \"https\")\n\t\treq.Header.Set(\"Origin\", \"test.com\")\n\t\treq.Header.Set(\"Referer\", \"https://test.com/api\")\n\t\treq.RemoteAddr = \"10.0.0.1\"\n\n\t\tconst customHeader = \"X-CUSTOM\"\n\t\treq.Header.Set(customHeader, \"val\")\n\t\tctx := contexthandler.WithAuthHTTPHeader(req.Context(), customHeader)\n\t\treq = req.WithContext(ctx)\n\n\t\trp := NewReverseProxy(log.New(\"test\"), func(req *http.Request) {\n\t\t\treq.Header.Set(\"X-KEY\", \"value\")\n\t\t})\n\t\trequire.NotNil(t, rp)\n\t\trequire.NotNil(t, rp.ModifyResponse)\n\t\trp.ServeHTTP(rec, req)\n\n\t\trequire.NotNil(t, actualReq)\n\t\trequire.Empty(t, actualReq.Header.Get(\"X-Forwarded-Host\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"X-Forwarded-Port\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"X-Forwarded-Proto\"))\n\t\trequire.Equal(t, \"10.0.0.1\", actualReq.Header.Get(\"X-Forwarded-For\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"Origin\"))\n\t\trequire.Empty(t, actualReq.Header.Get(\"Referer\"))\n\t\trequire.Equal(t, \"value\", actualReq.Header.Get(\"X-KEY\"))\n\t\tresp := rec.Result()\n\t\trequire.Empty(t, resp.Cookies())\n\t\trequire.Equal(t, \"sandbox\", resp.Header.Get(\"Content-Security-Policy\"))\n\t\trequire.NoError(t, resp.Body.Close())\n\t\trequire.Empty(t, actualReq.Header.Get(customHeader))\n\t})\n\n\tt.Run(\"When proxying a request using WithModifyResponse should call it before default ModifyResponse func\", func(t *testing.T) {\n\t\tvar actualReq *http.Request\n\t\tupstream := newUpstreamServer(t, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\tactualReq = req\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"test\"})\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t}))\n\t\tt.Cleanup(upstream.Close)\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, upstream.URL, nil)\n\t\trp := NewReverseProxy(\n\t\t\tlog.New(\"test\"),\n\t\t\tfunc(req *http.Request) {\n\t\t\t\treq.Header.Set(\"X-KEY\", \"value\")\n\t\t\t},\n\t\t\tWithModifyResponse(func(r *http.Response) error {\n\t\t\t\tr.Header.Set(\"X-KEY2\", \"value2\")\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\t\trequire.NotNil(t, rp)\n\t\trequire.NotNil(t, rp.ModifyResponse)\n\t\trp.ServeHTTP(rec, req)\n\n\t\trequire.NotNil(t, actualReq)\n\t\trequire.Equal(t, \"value\", actualReq.Header.Get(\"X-KEY\"))\n\t\tresp := rec.Result()\n\t\trequire.Empty(t, resp.Cookies())\n\t\trequire.Equal(t, \"sandbox\", resp.Header.Get(\"Content-Security-Policy\"))\n\t\trequire.Equal(t, \"value2\", resp.Header.Get(\"X-KEY2\"))\n\t\trequire.NoError(t, resp.Body.Close())\n\t})\n\n\tt.Run(\"Error handling should convert status codes depending on what kind of error it is\", func(t *testing.T) {\n\t\ttimedOutTransport := http.DefaultTransport.(*http.Transport)\n\t\ttimedOutTransport.ResponseHeaderTimeout = time.Millisecond\n\n\t\ttestCases := []struct {\n\t\t\tdesc               string\n\t\t\ttransport          http.RoundTripper\n\t\t\tresponseWaitTime   time.Duration\n\t\t\texpectedStatusCode int\n\t\t}{\n\t\t\t{\n\t\t\t\tdesc:               \"Cancelled request should return 499 Client closed request\",\n\t\t\t\ttransport:          &cancelledRoundTripper{},\n\t\t\t\texpectedStatusCode: StatusClientClosedRequest,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:               \"Timed out request should return 504 Gateway timeout\",\n\t\t\t\ttransport:          timedOutTransport,\n\t\t\t\tresponseWaitTime:   100 * time.Millisecond,\n\t\t\t\texpectedStatusCode: http.StatusGatewayTimeout,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:               \"Failed request should return 502 Bad gateway\",\n\t\t\t\ttransport:          &failingRoundTripper{},\n\t\t\t\texpectedStatusCode: http.StatusBadGateway,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\t\tupstream := newUpstreamServer(t, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\t\t\tif tc.responseWaitTime > 0 {\n\t\t\t\t\t\ttime.Sleep(tc.responseWaitTime)\n\t\t\t\t\t}\n\n\t\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\t}))\n\t\t\t\tt.Cleanup(upstream.Close)\n\t\t\t\trec := httptest.NewRecorder()\n\t\t\t\treq := httptest.NewRequest(http.MethodGet, upstream.URL, nil)\n\n\t\t\t\trp := NewReverseProxy(\n\t\t\t\t\tlog.New(\"test\"),\n\t\t\t\t\tfunc(req *http.Request) {},\n\t\t\t\t\tWithTransport(tc.transport),\n\t\t\t\t)\n\t\t\t\trequire.NotNil(t, rp)\n\t\t\t\trequire.NotNil(t, rp.Transport)\n\t\t\t\trequire.Same(t, tc.transport, rp.Transport)\n\t\t\t\trp.ServeHTTP(rec, req)\n\n\t\t\t\tresp := rec.Result()\n\t\t\t\trequire.Equal(t, tc.expectedStatusCode, resp.StatusCode)\n\t\t\t\trequire.NoError(t, resp.Body.Close())\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc newUpstreamServer(t *testing.T, handler http.Handler) *httptest.Server {\n\tt.Helper()\n\n\tupstream := httptest.NewServer(handler)\n\treturn upstream\n}\n\ntype cancelledRoundTripper struct{}\n\nfunc (cancelledRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {\n\treturn nil, context.Canceled\n}\n\ntype failingRoundTripper struct{}\n\nfunc (failingRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {\n\treturn nil, errors.New(\"some error\")\n}\n"], "filenames": ["pkg/api/plugins.go", "pkg/api/plugins_test.go", "pkg/middleware/middleware_basic_auth_test.go", "pkg/middleware/middleware_jwt_auth_test.go", "pkg/middleware/middleware_test.go", "pkg/services/contexthandler/auth_jwt.go", "pkg/services/contexthandler/contexthandler.go", "pkg/util/proxyutil/reverse_proxy.go", "pkg/util/proxyutil/reverse_proxy_test.go"], "buggy_code_start_loc": [26, 22, 38, 8, 397, 95, 213, 12, 11], "buggy_code_end_loc": [548, 289, 71, 56, 397, 95, 544, 68, 51], "fixing_code_start_loc": [27, 23, 39, 9, 398, 96, 214, 13, 12], "fixing_code_end_loc": [558, 298, 78, 61, 403, 99, 595, 77, 59], "type": "CWE-522", "message": "Grafana is an open source observability and data visualization platform. Versions of Grafana for endpoints prior to 9.1.8 and 8.5.14 could leak authentication tokens to some destination plugins under some conditions. The vulnerability impacts data source and plugin proxy endpoints with authentication tokens. The destination plugin could receive a user's Grafana authentication token. Versions 9.1.8 and 8.5.14 contain a patch for this issue. As a workaround, do not use API keys, JWT authentication, or any HTTP Header based authentication.", "other": {"cve": {"id": "CVE-2022-31130", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-13T23:15:09.637", "lastModified": "2022-10-17T13:31:29.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grafana is an open source observability and data visualization platform. Versions of Grafana for endpoints prior to 9.1.8 and 8.5.14 could leak authentication tokens to some destination plugins under some conditions. The vulnerability impacts data source and plugin proxy endpoints with authentication tokens. The destination plugin could receive a user's Grafana authentication token. Versions 9.1.8 and 8.5.14 contain a patch for this issue. As a workaround, do not use API keys, JWT authentication, or any HTTP Header based authentication."}, {"lang": "es", "value": "Grafana es una plataforma de c\u00f3digo abierto de observabilidad y visualizaci\u00f3n de datos. Las versiones de Grafana para endpoints anteriores a 9.1.8 y 8.5.14, podr\u00edan filtrar tokens de autenticaci\u00f3n a algunos plugins de destino bajo algunas condiciones. La vulnerabilidad afecta a los endpoints de origen de datos y proxy de plugins con tokens de autenticaci\u00f3n. El plugin de destino podr\u00eda recibir el token de autenticaci\u00f3n de Grafana de un usuario. Las versiones 9.1.8 y 8.5.14 contienen un parche para este problema. Como mitigaci\u00f3n, no use claves de API, autenticaci\u00f3n JWT o cualquier autenticaci\u00f3n basada en encabezados HTTP"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.5.14", "matchCriteriaId": "3959EA7C-8C8F-4CA2-B33F-F9BBAB8CD15C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.1.8", "matchCriteriaId": "E8E1ACC7-F43B-4395-A1FD-44CAEB43430D"}]}]}], "references": [{"url": "https://github.com/grafana/grafana/commit/4dd56e4dabce10007bf4ba1059bf54178c35b177", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/9da278c044ba605eb5a1886c48df9a2cb0d3885f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/releases/tag/v9.1.8", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-jv32-5578-pxjc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/4dd56e4dabce10007bf4ba1059bf54178c35b177"}}