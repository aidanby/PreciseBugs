{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the TCP module.\n *\n * Version:\t@(#)tcp.h\t1.0.5\t05/23/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n#ifndef _TCP_H\n#define _TCP_H\n\n#define FASTRETRANS_DEBUG 1\n\n#include <linux/list.h>\n#include <linux/tcp.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/cryptohash.h>\n#include <linux/kref.h>\n#include <linux/ktime.h>\n\n#include <net/inet_connection_sock.h>\n#include <net/inet_timewait_sock.h>\n#include <net/inet_hashtables.h>\n#include <net/checksum.h>\n#include <net/request_sock.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/tcp_states.h>\n#include <net/inet_ecn.h>\n#include <net/dst.h>\n\n#include <linux/seq_file.h>\n#include <linux/memcontrol.h>\n\nextern struct inet_hashinfo tcp_hashinfo;\n\nextern struct percpu_counter tcp_orphan_count;\nvoid tcp_time_wait(struct sock *sk, int state, int timeo);\n\n#define MAX_TCP_HEADER\t(128 + MAX_HEADER)\n#define MAX_TCP_OPTION_SPACE 40\n\n/*\n * Never offer a window over 32767 without using window scaling. Some\n * poor stacks do signed 16bit maths!\n */\n#define MAX_TCP_WINDOW\t\t32767U\n\n/* Minimal accepted MSS. It is (60+60+8) - (20+20). */\n#define TCP_MIN_MSS\t\t88U\n\n/* The least MTU to use for probing */\n#define TCP_BASE_MSS\t\t1024\n\n/* probing interval, default to 10 minutes as per RFC4821 */\n#define TCP_PROBE_INTERVAL\t600\n\n/* Specify interval when tcp mtu probing will stop */\n#define TCP_PROBE_THRESHOLD\t8\n\n/* After receiving this amount of duplicate ACKs fast retransmit starts. */\n#define TCP_FASTRETRANS_THRESH 3\n\n/* Maximal number of ACKs sent quickly to accelerate slow-start. */\n#define TCP_MAX_QUICKACKS\t16U\n\n/* urg_data states */\n#define TCP_URG_VALID\t0x0100\n#define TCP_URG_NOTYET\t0x0200\n#define TCP_URG_READ\t0x0400\n\n#define TCP_RETR1\t3\t/*\n\t\t\t\t * This is how many retries it does before it\n\t\t\t\t * tries to figure out if the gateway is\n\t\t\t\t * down. Minimal RFC value is 3; it corresponds\n\t\t\t\t * to ~3sec-8min depending on RTO.\n\t\t\t\t */\n\n#define TCP_RETR2\t15\t/*\n\t\t\t\t * This should take at least\n\t\t\t\t * 90 minutes to time out.\n\t\t\t\t * RFC1122 says that the limit is 100 sec.\n\t\t\t\t * 15 is ~13-30min depending on RTO.\n\t\t\t\t */\n\n#define TCP_SYN_RETRIES\t 6\t/* This is how many retries are done\n\t\t\t\t * when active opening a connection.\n\t\t\t\t * RFC1122 says the minimum retry MUST\n\t\t\t\t * be at least 180secs.  Nevertheless\n\t\t\t\t * this value is corresponding to\n\t\t\t\t * 63secs of retransmission with the\n\t\t\t\t * current initial RTO.\n\t\t\t\t */\n\n#define TCP_SYNACK_RETRIES 5\t/* This is how may retries are done\n\t\t\t\t * when passive opening a connection.\n\t\t\t\t * This is corresponding to 31secs of\n\t\t\t\t * retransmission with the current\n\t\t\t\t * initial RTO.\n\t\t\t\t */\n\n#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT\n\t\t\t\t  * state, about 60 seconds\t*/\n#define TCP_FIN_TIMEOUT\tTCP_TIMEWAIT_LEN\n                                 /* BSD style FIN_WAIT2 deadlock breaker.\n\t\t\t\t  * It used to be 3min, new value is 60sec,\n\t\t\t\t  * to combine FIN-WAIT-2 timeout with\n\t\t\t\t  * TIME-WAIT timer.\n\t\t\t\t  */\n\n#define TCP_DELACK_MAX\t((unsigned)(HZ/5))\t/* maximal time to delay before sending an ACK */\n#if HZ >= 100\n#define TCP_DELACK_MIN\t((unsigned)(HZ/25))\t/* minimal time to delay before sending an ACK */\n#define TCP_ATO_MIN\t((unsigned)(HZ/25))\n#else\n#define TCP_DELACK_MIN\t4U\n#define TCP_ATO_MIN\t4U\n#endif\n#define TCP_RTO_MAX\t((unsigned)(120*HZ))\n#define TCP_RTO_MIN\t((unsigned)(HZ/5))\n#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))\t/* RFC6298 2.1 initial RTO value\t*/\n#define TCP_TIMEOUT_FALLBACK ((unsigned)(3*HZ))\t/* RFC 1122 initial RTO value, now\n\t\t\t\t\t\t * used as a fallback RTO for the\n\t\t\t\t\t\t * initial data transmission if no\n\t\t\t\t\t\t * valid RTT sample has been acquired,\n\t\t\t\t\t\t * most likely due to retrans in 3WHS.\n\t\t\t\t\t\t */\n\n#define TCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ/2U)) /* Maximal interval between probes\n\t\t\t\t\t                 * for local resources.\n\t\t\t\t\t                 */\n\n#define TCP_KEEPALIVE_TIME\t(120*60*HZ)\t/* two hours */\n#define TCP_KEEPALIVE_PROBES\t9\t\t/* Max of 9 keepalive probes\t*/\n#define TCP_KEEPALIVE_INTVL\t(75*HZ)\n\n#define MAX_TCP_KEEPIDLE\t32767\n#define MAX_TCP_KEEPINTVL\t32767\n#define MAX_TCP_KEEPCNT\t\t127\n#define MAX_TCP_SYNCNT\t\t127\n\n#define TCP_SYNQ_INTERVAL\t(HZ/5)\t/* Period of SYNACK timer */\n\n#define TCP_PAWS_24DAYS\t(60 * 60 * 24 * 24)\n#define TCP_PAWS_MSL\t60\t\t/* Per-host timestamps are invalidated\n\t\t\t\t\t * after this time. It should be equal\n\t\t\t\t\t * (or greater than) TCP_TIMEWAIT_LEN\n\t\t\t\t\t * to provide reliability equal to one\n\t\t\t\t\t * provided by timewait state.\n\t\t\t\t\t */\n#define TCP_PAWS_WINDOW\t1\t\t/* Replay window for per-host\n\t\t\t\t\t * timestamps. It must be less than\n\t\t\t\t\t * minimal timewait lifetime.\n\t\t\t\t\t */\n/*\n *\tTCP option\n */\n\n#define TCPOPT_NOP\t\t1\t/* Padding */\n#define TCPOPT_EOL\t\t0\t/* End of options */\n#define TCPOPT_MSS\t\t2\t/* Segment size negotiating */\n#define TCPOPT_WINDOW\t\t3\t/* Window scaling */\n#define TCPOPT_SACK_PERM        4       /* SACK Permitted */\n#define TCPOPT_SACK             5       /* SACK Block */\n#define TCPOPT_TIMESTAMP\t8\t/* Better RTT estimations/PAWS */\n#define TCPOPT_MD5SIG\t\t19\t/* MD5 Signature (RFC2385) */\n#define TCPOPT_FASTOPEN\t\t34\t/* Fast open (RFC7413) */\n#define TCPOPT_EXP\t\t254\t/* Experimental */\n/* Magic number to be after the option value for sharing TCP\n * experimental options. See draft-ietf-tcpm-experimental-options-00.txt\n */\n#define TCPOPT_FASTOPEN_MAGIC\t0xF989\n\n/*\n *     TCP option lengths\n */\n\n#define TCPOLEN_MSS            4\n#define TCPOLEN_WINDOW         3\n#define TCPOLEN_SACK_PERM      2\n#define TCPOLEN_TIMESTAMP      10\n#define TCPOLEN_MD5SIG         18\n#define TCPOLEN_FASTOPEN_BASE  2\n#define TCPOLEN_EXP_FASTOPEN_BASE  4\n\n/* But this is what stacks really send out. */\n#define TCPOLEN_TSTAMP_ALIGNED\t\t12\n#define TCPOLEN_WSCALE_ALIGNED\t\t4\n#define TCPOLEN_SACKPERM_ALIGNED\t4\n#define TCPOLEN_SACK_BASE\t\t2\n#define TCPOLEN_SACK_BASE_ALIGNED\t4\n#define TCPOLEN_SACK_PERBLOCK\t\t8\n#define TCPOLEN_MD5SIG_ALIGNED\t\t20\n#define TCPOLEN_MSS_ALIGNED\t\t4\n\n/* Flags in tp->nonagle */\n#define TCP_NAGLE_OFF\t\t1\t/* Nagle's algo is disabled */\n#define TCP_NAGLE_CORK\t\t2\t/* Socket is corked\t    */\n#define TCP_NAGLE_PUSH\t\t4\t/* Cork is overridden for already queued data */\n\n/* TCP thin-stream limits */\n#define TCP_THIN_LINEAR_RETRIES 6       /* After 6 linear retries, do exp. backoff */\n\n/* TCP initial congestion window as per rfc6928 */\n#define TCP_INIT_CWND\t\t10\n\n/* Bit Flags for sysctl_tcp_fastopen */\n#define\tTFO_CLIENT_ENABLE\t1\n#define\tTFO_SERVER_ENABLE\t2\n#define\tTFO_CLIENT_NO_COOKIE\t4\t/* Data in SYN w/o cookie option */\n\n/* Accept SYN data w/o any cookie option */\n#define\tTFO_SERVER_COOKIE_NOT_REQD\t0x200\n\n/* Force enable TFO on all listeners, i.e., not requiring the\n * TCP_FASTOPEN socket option.\n */\n#define\tTFO_SERVER_WO_SOCKOPT1\t0x400\n\nextern struct inet_timewait_death_row tcp_death_row;\n\n/* sysctl variables for tcp */\nextern int sysctl_tcp_timestamps;\nextern int sysctl_tcp_window_scaling;\nextern int sysctl_tcp_sack;\nextern int sysctl_tcp_fastopen;\nextern int sysctl_tcp_retrans_collapse;\nextern int sysctl_tcp_stdurg;\nextern int sysctl_tcp_rfc1337;\nextern int sysctl_tcp_abort_on_overflow;\nextern int sysctl_tcp_max_orphans;\nextern int sysctl_tcp_fack;\nextern int sysctl_tcp_reordering;\nextern int sysctl_tcp_max_reordering;\nextern int sysctl_tcp_dsack;\nextern long sysctl_tcp_mem[3];\nextern int sysctl_tcp_wmem[3];\nextern int sysctl_tcp_rmem[3];\nextern int sysctl_tcp_app_win;\nextern int sysctl_tcp_adv_win_scale;\nextern int sysctl_tcp_tw_reuse;\nextern int sysctl_tcp_frto;\nextern int sysctl_tcp_low_latency;\nextern int sysctl_tcp_nometrics_save;\nextern int sysctl_tcp_moderate_rcvbuf;\nextern int sysctl_tcp_tso_win_divisor;\nextern int sysctl_tcp_workaround_signed_windows;\nextern int sysctl_tcp_slow_start_after_idle;\nextern int sysctl_tcp_thin_linear_timeouts;\nextern int sysctl_tcp_thin_dupack;\nextern int sysctl_tcp_early_retrans;\nextern int sysctl_tcp_limit_output_bytes;\nextern int sysctl_tcp_challenge_ack_limit;\nextern int sysctl_tcp_min_tso_segs;\nextern int sysctl_tcp_min_rtt_wlen;\nextern int sysctl_tcp_autocorking;\nextern int sysctl_tcp_invalid_ratelimit;\nextern int sysctl_tcp_pacing_ss_ratio;\nextern int sysctl_tcp_pacing_ca_ratio;\n\nextern atomic_long_t tcp_memory_allocated;\nextern struct percpu_counter tcp_sockets_allocated;\nextern int tcp_memory_pressure;\n\n/* optimized version of sk_under_memory_pressure() for TCP sockets */\nstatic inline bool tcp_under_memory_pressure(const struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled && sk->sk_memcg &&\n\t    mem_cgroup_under_socket_pressure(sk->sk_memcg))\n\t\treturn true;\n\n\treturn tcp_memory_pressure;\n}\n/*\n * The next routines deal with comparing 32 bit unsigned ints\n * and worry about wraparound (automatic with unsigned arithmetic).\n */\n\nstatic inline bool before(__u32 seq1, __u32 seq2)\n{\n        return (__s32)(seq1-seq2) < 0;\n}\n#define after(seq2, seq1) \tbefore(seq1, seq2)\n\n/* is s2<=s1<=s3 ? */\nstatic inline bool between(__u32 seq1, __u32 seq2, __u32 seq3)\n{\n\treturn seq3 - seq2 >= seq1 - seq2;\n}\n\nstatic inline bool tcp_out_of_memory(struct sock *sk)\n{\n\tif (sk->sk_wmem_queued > SOCK_MIN_SNDBUF &&\n\t    sk_memory_allocated(sk) > sk_prot_mem_limits(sk, 2))\n\t\treturn true;\n\treturn false;\n}\n\nvoid sk_forced_mem_schedule(struct sock *sk, int size);\n\nstatic inline bool tcp_too_many_orphans(struct sock *sk, int shift)\n{\n\tstruct percpu_counter *ocp = sk->sk_prot->orphan_count;\n\tint orphans = percpu_counter_read_positive(ocp);\n\n\tif (orphans << shift > sysctl_tcp_max_orphans) {\n\t\torphans = percpu_counter_sum_positive(ocp);\n\t\tif (orphans << shift > sysctl_tcp_max_orphans)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool tcp_check_oom(struct sock *sk, int shift);\n\n\nextern struct proto tcp_prot;\n\n#define TCP_INC_STATS(net, field)\tSNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define __TCP_INC_STATS(net, field)\t__SNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_DEC_STATS(net, field)\tSNMP_DEC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_ADD_STATS(net, field, val)\tSNMP_ADD_STATS((net)->mib.tcp_statistics, field, val)\n\nvoid tcp_tasklet_init(void);\n\nvoid tcp_v4_err(struct sk_buff *skb, u32);\n\nvoid tcp_shutdown(struct sock *sk, int how);\n\nvoid tcp_v4_early_demux(struct sk_buff *skb);\nint tcp_v4_rcv(struct sk_buff *skb);\n\nint tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);\nint tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nint tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,\n\t\t int flags);\nvoid tcp_release_cb(struct sock *sk);\nvoid tcp_wfree(struct sk_buff *skb);\nvoid tcp_write_timer_handler(struct sock *sk);\nvoid tcp_delack_timer_handler(struct sock *sk);\nint tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb);\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct tcphdr *th, unsigned int len);\nvoid tcp_rcv_space_adjust(struct sock *sk);\nint tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);\nvoid tcp_twsk_destructor(struct sock *sk);\nssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags);\n\nstatic inline void tcp_dec_quickack_mode(struct sock *sk,\n\t\t\t\t\t const unsigned int pkts)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ack.quick) {\n\t\tif (pkts >= icsk->icsk_ack.quick) {\n\t\t\ticsk->icsk_ack.quick = 0;\n\t\t\t/* Leaving quickack mode we deflate ATO. */\n\t\t\ticsk->icsk_ack.ato   = TCP_ATO_MIN;\n\t\t} else\n\t\t\ticsk->icsk_ack.quick -= pkts;\n\t}\n}\n\n#define\tTCP_ECN_OK\t\t1\n#define\tTCP_ECN_QUEUE_CWR\t2\n#define\tTCP_ECN_DEMAND_CWR\t4\n#define\tTCP_ECN_SEEN\t\t8\n\nenum tcp_tw_status {\n\tTCP_TW_SUCCESS = 0,\n\tTCP_TW_RST = 1,\n\tTCP_TW_ACK = 2,\n\tTCP_TW_SYN = 3\n};\n\n\nenum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock *tw,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      const struct tcphdr *th);\nstruct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct request_sock *req, bool fastopen);\nint tcp_child_process(struct sock *parent, struct sock *child,\n\t\t      struct sk_buff *skb);\nvoid tcp_enter_loss(struct sock *sk);\nvoid tcp_clear_retrans(struct tcp_sock *tp);\nvoid tcp_update_metrics(struct sock *sk);\nvoid tcp_init_metrics(struct sock *sk);\nvoid tcp_metrics_init(void);\nbool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst,\n\t\t\tbool paws_check, bool timestamps);\nbool tcp_remember_stamp(struct sock *sk);\nbool tcp_tw_remember_stamp(struct inet_timewait_sock *tw);\nvoid tcp_fetch_timewait_stamp(struct sock *sk, struct dst_entry *dst);\nvoid tcp_disable_fack(struct tcp_sock *tp);\nvoid tcp_close(struct sock *sk, long timeout);\nvoid tcp_init_sock(struct sock *sk);\nunsigned int tcp_poll(struct file *file, struct socket *sock,\n\t\t      struct poll_table_struct *wait);\nint tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, int __user *optlen);\nint tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, unsigned int optlen);\nint compat_tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen);\nint compat_tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen);\nvoid tcp_set_keepalive(struct sock *sk, int val);\nvoid tcp_syn_ack_timeout(const struct request_sock *req);\nint tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,\n\t\tint flags, int *addr_len);\nvoid tcp_parse_options(const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx,\n\t\t       int estab, struct tcp_fastopen_cookie *foc);\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th);\n\n/*\n *\tTCP v4 functions exported for the inet6 API\n */\n\nvoid tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);\nvoid tcp_v4_mtu_reduced(struct sock *sk);\nvoid tcp_req_err(struct sock *sk, u32 seq, bool abort);\nint tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb);\nvoid tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst);\nstruct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t  bool *own_req);\nint tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nint tcp_connect(struct sock *sk);\nenum tcp_synack_type {\n\tTCP_SYNACK_NORMAL,\n\tTCP_SYNACK_FASTOPEN,\n\tTCP_SYNACK_COOKIE,\n};\nstruct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\tstruct request_sock *req,\n\t\t\t\tstruct tcp_fastopen_cookie *foc,\n\t\t\t\tenum tcp_synack_type synack_type);\nint tcp_disconnect(struct sock *sk, int flags);\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb);\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size);\nvoid inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);\n\n/* From syncookies.c */\nstruct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t struct dst_entry *dst);\nint __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\n/* Syncookies use a monotonic timer which increments every 60 seconds.\n * This counter is used both as a hash input and partially encoded into\n * the cookie value.  A cookie is only validated further if the delta\n * between the current counter value and the encoded one is less than this,\n * i.e. a sent cookie is valid only at most for 2*60 seconds (or less if\n * the counter advances immediately after a cookie is generated).\n */\n#define MAX_SYNCOOKIE_AGE\t2\n#define TCP_SYNCOOKIE_PERIOD\t(60 * HZ)\n#define TCP_SYNCOOKIE_VALID\t(MAX_SYNCOOKIE_AGE * TCP_SYNCOOKIE_PERIOD)\n\n/* syncookies: remember time of last synqueue overflow\n * But do not dirty this field too often (once per second is enough)\n * It is racy as we do not hold a lock, but race is very minor.\n */\nstatic inline void tcp_synq_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\tunsigned long now = jiffies;\n\n\tif (time_after(now, last_overflow + HZ))\n\t\ttcp_sk(sk)->rx_opt.ts_recent_stamp = now;\n}\n\n/* syncookies: no recent synqueue overflow on this listening socket? */\nstatic inline bool tcp_synq_no_recent_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\n\treturn time_after(jiffies, last_overflow + TCP_SYNCOOKIE_VALID);\n}\n\nstatic inline u32 tcp_cookie_time(void)\n{\n\tu64 val = get_jiffies_64();\n\n\tdo_div(val, TCP_SYNCOOKIE_PERIOD);\n\treturn val;\n}\n\nu32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,\n\t\t\t      u16 *mssp);\n__u32 cookie_v4_init_sequence(const struct sk_buff *skb, __u16 *mss);\n__u32 cookie_init_timestamp(struct request_sock *req);\nbool cookie_timestamp_decode(struct tcp_options_received *opt);\nbool cookie_ecn_ok(const struct tcp_options_received *opt,\n\t\t   const struct net *net, const struct dst_entry *dst);\n\n/* From net/ipv6/syncookies.c */\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, u16 *mssp);\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mss);\n#endif\n/* tcp_output.c */\n\nu32 tcp_tso_autosize(const struct sock *sk, unsigned int mss_now,\n\t\t     int min_tso_segs);\nvoid __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,\n\t\t\t       int nonagle);\nbool tcp_may_send_now(struct sock *sk);\nint __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nint tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nvoid tcp_retransmit_timer(struct sock *sk);\nvoid tcp_xmit_retransmit_queue(struct sock *);\nvoid tcp_simple_retransmit(struct sock *);\nint tcp_trim_head(struct sock *, struct sk_buff *, u32);\nint tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int, gfp_t);\n\nvoid tcp_send_probe0(struct sock *);\nvoid tcp_send_partial(struct sock *);\nint tcp_write_wakeup(struct sock *, int mib);\nvoid tcp_send_fin(struct sock *sk);\nvoid tcp_send_active_reset(struct sock *sk, gfp_t priority);\nint tcp_send_synack(struct sock *);\nvoid tcp_push_one(struct sock *, unsigned int mss_now);\nvoid tcp_send_ack(struct sock *sk);\nvoid tcp_send_delayed_ack(struct sock *sk);\nvoid tcp_send_loss_probe(struct sock *sk);\nbool tcp_schedule_loss_probe(struct sock *sk);\nvoid tcp_skb_collapse_tstamp(struct sk_buff *skb,\n\t\t\t     const struct sk_buff *next_skb);\n\n/* tcp_input.c */\nvoid tcp_resume_early_retransmit(struct sock *sk);\nvoid tcp_rearm_rto(struct sock *sk);\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req);\nvoid tcp_reset(struct sock *sk);\nvoid tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb);\nvoid tcp_fin(struct sock *sk);\n\n/* tcp_timer.c */\nvoid tcp_init_xmit_timers(struct sock *);\nstatic inline void tcp_clear_xmit_timers(struct sock *sk)\n{\n\tinet_csk_clear_xmit_timers(sk);\n}\n\nunsigned int tcp_sync_mss(struct sock *sk, u32 pmtu);\nunsigned int tcp_current_mss(struct sock *sk);\n\n/* Bound MSS / TSO packet size with the half of the window */\nstatic inline int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)\n{\n\tint cutoff;\n\n\t/* When peer uses tiny windows, there is no use in packetizing\n\t * to sub-MSS pieces for the sake of SWS or making sure there\n\t * are enough packets in the pipe for fast recovery.\n\t *\n\t * On the other hand, for extremely large MSS devices, handling\n\t * smaller than MSS windows in this way does make sense.\n\t */\n\tif (tp->max_window > TCP_MSS_DEFAULT)\n\t\tcutoff = (tp->max_window >> 1);\n\telse\n\t\tcutoff = tp->max_window;\n\n\tif (cutoff && pktsize > cutoff)\n\t\treturn max_t(int, cutoff, 68U - tp->tcp_header_len);\n\telse\n\t\treturn pktsize;\n}\n\n/* tcp.c */\nvoid tcp_get_info(struct sock *, struct tcp_info *);\n\n/* Read 'sendfile()'-style from a TCP socket */\nint tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor);\n\nvoid tcp_initialize_rcv_mss(struct sock *sk);\n\nint tcp_mtu_to_mss(struct sock *sk, int pmtu);\nint tcp_mss_to_mtu(struct sock *sk, int mss);\nvoid tcp_mtup_init(struct sock *sk);\nvoid tcp_init_buffer_space(struct sock *sk);\n\nstatic inline void tcp_bound_rto(const struct sock *sk)\n{\n\tif (inet_csk(sk)->icsk_rto > TCP_RTO_MAX)\n\t\tinet_csk(sk)->icsk_rto = TCP_RTO_MAX;\n}\n\nstatic inline u32 __tcp_set_rto(const struct tcp_sock *tp)\n{\n\treturn usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);\n}\n\nstatic inline void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)\n{\n\ttp->pred_flags = htonl((tp->tcp_header_len << 26) |\n\t\t\t       ntohl(TCP_FLAG_ACK) |\n\t\t\t       snd_wnd);\n}\n\nstatic inline void tcp_fast_path_on(struct tcp_sock *tp)\n{\n\t__tcp_fast_path_on(tp, tp->snd_wnd >> tp->rx_opt.snd_wscale);\n}\n\nstatic inline void tcp_fast_path_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue) &&\n\t    tp->rcv_wnd &&\n\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf &&\n\t    !tp->urg_data)\n\t\ttcp_fast_path_on(tp);\n}\n\n/* Compute the actual rto_min value */\nstatic inline u32 tcp_rto_min(struct sock *sk)\n{\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\tu32 rto_min = TCP_RTO_MIN;\n\n\tif (dst && dst_metric_locked(dst, RTAX_RTO_MIN))\n\t\trto_min = dst_metric_rtt(dst, RTAX_RTO_MIN);\n\treturn rto_min;\n}\n\nstatic inline u32 tcp_rto_min_us(struct sock *sk)\n{\n\treturn jiffies_to_usecs(tcp_rto_min(sk));\n}\n\nstatic inline bool tcp_ca_dst_locked(const struct dst_entry *dst)\n{\n\treturn dst_metric_locked(dst, RTAX_CC_ALGO);\n}\n\n/* Minimum RTT in usec. ~0 means not available. */\nstatic inline u32 tcp_min_rtt(const struct tcp_sock *tp)\n{\n\treturn minmax_get(&tp->rtt_min);\n}\n\n/* Compute the actual receive window we are currently advertising.\n * Rcv_nxt can be after the window if our peer push more data\n * than the offered window.\n */\nstatic inline u32 tcp_receive_window(const struct tcp_sock *tp)\n{\n\ts32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;\n\n\tif (win < 0)\n\t\twin = 0;\n\treturn (u32) win;\n}\n\n/* Choose a new window, without checks for shrinking, and without\n * scaling applied to the result.  The caller does these things\n * if necessary.  This is a \"raw\" window selection.\n */\nu32 __tcp_select_window(struct sock *sk);\n\nvoid tcp_send_window_probe(struct sock *sk);\n\n/* TCP timestamps are only 32-bits, this causes a slight\n * complication on 64-bit systems since we store a snapshot\n * of jiffies in the buffer control blocks below.  We decided\n * to use only the low 32-bits of jiffies and hide the ugly\n * casts with the following macro.\n */\n#define tcp_time_stamp\t\t((__u32)(jiffies))\n\nstatic inline u32 tcp_skb_timestamp(const struct sk_buff *skb)\n{\n\treturn skb->skb_mstamp.stamp_jiffies;\n}\n\n\n#define tcp_flag_byte(th) (((u_int8_t *)th)[13])\n\n#define TCPHDR_FIN 0x01\n#define TCPHDR_SYN 0x02\n#define TCPHDR_RST 0x04\n#define TCPHDR_PSH 0x08\n#define TCPHDR_ACK 0x10\n#define TCPHDR_URG 0x20\n#define TCPHDR_ECE 0x40\n#define TCPHDR_CWR 0x80\n\n#define TCPHDR_SYN_ECN\t(TCPHDR_SYN | TCPHDR_ECE | TCPHDR_CWR)\n\n/* This is what the send packet queuing engine uses to pass\n * TCP per-packet control information to the transmission code.\n * We also store the host-order sequence numbers in here too.\n * This is 44 bytes if IPV6 is enabled.\n * If this grows please adjust skbuff.h:skbuff->cb[xxx] size appropriately.\n */\nstruct tcp_skb_cb {\n\t__u32\t\tseq;\t\t/* Starting sequence number\t*/\n\t__u32\t\tend_seq;\t/* SEQ + FIN + SYN + datalen\t*/\n\tunion {\n\t\t/* Note : tcp_tw_isn is used in input path only\n\t\t *\t  (isn chosen by tcp_timewait_state_process())\n\t\t *\n\t\t * \t  tcp_gso_segs/size are used in write queue only,\n\t\t *\t  cf tcp_skb_pcount()/tcp_skb_mss()\n\t\t */\n\t\t__u32\t\ttcp_tw_isn;\n\t\tstruct {\n\t\t\tu16\ttcp_gso_segs;\n\t\t\tu16\ttcp_gso_size;\n\t\t};\n\t};\n\t__u8\t\ttcp_flags;\t/* TCP header flags. (tcp[13])\t*/\n\n\t__u8\t\tsacked;\t\t/* State flags for SACK/FACK.\t*/\n#define TCPCB_SACKED_ACKED\t0x01\t/* SKB ACK'd by a SACK block\t*/\n#define TCPCB_SACKED_RETRANS\t0x02\t/* SKB retransmitted\t\t*/\n#define TCPCB_LOST\t\t0x04\t/* SKB is lost\t\t\t*/\n#define TCPCB_TAGBITS\t\t0x07\t/* All tag bits\t\t\t*/\n#define TCPCB_REPAIRED\t\t0x10\t/* SKB repaired (no skb_mstamp)\t*/\n#define TCPCB_EVER_RETRANS\t0x80\t/* Ever retransmitted frame\t*/\n#define TCPCB_RETRANS\t\t(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS| \\\n\t\t\t\tTCPCB_REPAIRED)\n\n\t__u8\t\tip_dsfield;\t/* IPv4 tos or IPv6 dsfield\t*/\n\t__u8\t\ttxstamp_ack:1,\t/* Record TX timestamp for ack? */\n\t\t\teor:1,\t\t/* Is skb MSG_EOR marked? */\n\t\t\tunused:6;\n\t__u32\t\tack_seq;\t/* Sequence number ACK'd\t*/\n\tunion {\n\t\tstruct {\n\t\t\t/* There is space for up to 24 bytes */\n\t\t\t__u32 in_flight:30,/* Bytes in flight at transmit */\n\t\t\t      is_app_limited:1, /* cwnd not fully used? */\n\t\t\t      unused:1;\n\t\t\t/* pkts S/ACKed so far upon tx of skb, incl retrans: */\n\t\t\t__u32 delivered;\n\t\t\t/* start of send pipeline phase */\n\t\t\tstruct skb_mstamp first_tx_mstamp;\n\t\t\t/* when we reached the \"delivered\" count */\n\t\t\tstruct skb_mstamp delivered_mstamp;\n\t\t} tx;   /* only used for outgoing skbs */\n\t\tunion {\n\t\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tstruct inet6_skb_parm\th6;\n#endif\n\t\t} header;\t/* For incoming skbs */\n\t};\n};\n\n#define TCP_SKB_CB(__skb)\t((struct tcp_skb_cb *)&((__skb)->cb[0]))\n\n\n#if IS_ENABLED(CONFIG_IPV6)\n/* This is the variant of inet6_iif() that must be used by TCP,\n * as TCP moves IP6CB into a different location in skb->cb[]\n */\nstatic inline int tcp_v6_iif(const struct sk_buff *skb)\n{\n\tbool l3_slave = ipv6_l3mdev_skb(TCP_SKB_CB(skb)->header.h6.flags);\n\n\treturn l3_slave ? skb->skb_iif : TCP_SKB_CB(skb)->header.h6.iif;\n}\n#endif\n\n/* TCP_SKB_CB reference means this can not be used from early demux */\nstatic inline bool inet_exact_dif_match(struct net *net, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\tif (!net->ipv4.sysctl_tcp_l3mdev_accept &&\n\t    skb && ipv4_l3mdev_skb(TCP_SKB_CB(skb)->header.h4.flags))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n/* Due to TSO, an SKB can be composed of multiple actual\n * packets.  To keep these tracked properly, we use this.\n */\nstatic inline int tcp_skb_pcount(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_segs;\n}\n\nstatic inline void tcp_skb_pcount_set(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs = segs;\n}\n\nstatic inline void tcp_skb_pcount_add(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs += segs;\n}\n\n/* This is valid iff skb is in write queue and tcp_skb_pcount() > 1. */\nstatic inline int tcp_skb_mss(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_size;\n}\n\nstatic inline bool tcp_skb_can_collapse_to(const struct sk_buff *skb)\n{\n\treturn likely(!TCP_SKB_CB(skb)->eor);\n}\n\n/* Events passed to congestion control interface */\nenum tcp_ca_event {\n\tCA_EVENT_TX_START,\t/* first transmit when no packets in flight */\n\tCA_EVENT_CWND_RESTART,\t/* congestion window restart */\n\tCA_EVENT_COMPLETE_CWR,\t/* end of congestion recovery */\n\tCA_EVENT_LOSS,\t\t/* loss timeout */\n\tCA_EVENT_ECN_NO_CE,\t/* ECT set, but not CE marked */\n\tCA_EVENT_ECN_IS_CE,\t/* received CE marked IP packet */\n\tCA_EVENT_DELAYED_ACK,\t/* Delayed ack is sent */\n\tCA_EVENT_NON_DELAYED_ACK,\n};\n\n/* Information about inbound ACK, passed to cong_ops->in_ack_event() */\nenum tcp_ca_ack_event_flags {\n\tCA_ACK_SLOWPATH\t\t= (1 << 0),\t/* In slow path processing */\n\tCA_ACK_WIN_UPDATE\t= (1 << 1),\t/* ACK updated window */\n\tCA_ACK_ECE\t\t= (1 << 2),\t/* ECE bit is set on ack */\n};\n\n/*\n * Interface for adding new TCP congestion control handlers\n */\n#define TCP_CA_NAME_MAX\t16\n#define TCP_CA_MAX\t128\n#define TCP_CA_BUF_MAX\t(TCP_CA_NAME_MAX*TCP_CA_MAX)\n\n#define TCP_CA_UNSPEC\t0\n\n/* Algorithm can be set on socket without CAP_NET_ADMIN privileges */\n#define TCP_CONG_NON_RESTRICTED 0x1\n/* Requires ECN/ECT set on all packets */\n#define TCP_CONG_NEEDS_ECN\t0x2\n\nunion tcp_cc_info;\n\nstruct ack_sample {\n\tu32 pkts_acked;\n\ts32 rtt_us;\n\tu32 in_flight;\n};\n\n/* A rate sample measures the number of (original/retransmitted) data\n * packets delivered \"delivered\" over an interval of time \"interval_us\".\n * The tcp_rate.c code fills in the rate sample, and congestion\n * control modules that define a cong_control function to run at the end\n * of ACK processing can optionally chose to consult this sample when\n * setting cwnd and pacing rate.\n * A sample is invalid if \"delivered\" or \"interval_us\" is negative.\n */\nstruct rate_sample {\n\tstruct\tskb_mstamp prior_mstamp; /* starting timestamp for interval */\n\tu32  prior_delivered;\t/* tp->delivered at \"prior_mstamp\" */\n\ts32  delivered;\t\t/* number of packets delivered over interval */\n\tlong interval_us;\t/* time for tp->delivered to incr \"delivered\" */\n\tlong rtt_us;\t\t/* RTT of last (S)ACKed packet (or -1) */\n\tint  losses;\t\t/* number of packets marked lost upon ACK */\n\tu32  acked_sacked;\t/* number of packets newly (S)ACKed upon ACK */\n\tu32  prior_in_flight;\t/* in flight before this ACK */\n\tbool is_app_limited;\t/* is sample from packet with bubble in pipe? */\n\tbool is_retrans;\t/* is sample from retransmission? */\n};\n\nstruct tcp_congestion_ops {\n\tstruct list_head\tlist;\n\tu32 key;\n\tu32 flags;\n\n\t/* initialize private data (optional) */\n\tvoid (*init)(struct sock *sk);\n\t/* cleanup private data  (optional) */\n\tvoid (*release)(struct sock *sk);\n\n\t/* return slow start threshold (required) */\n\tu32 (*ssthresh)(struct sock *sk);\n\t/* do new cwnd calculation (required) */\n\tvoid (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);\n\t/* call before changing ca_state (optional) */\n\tvoid (*set_state)(struct sock *sk, u8 new_state);\n\t/* call when cwnd event occurs (optional) */\n\tvoid (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);\n\t/* call when ack arrives (optional) */\n\tvoid (*in_ack_event)(struct sock *sk, u32 flags);\n\t/* new value of cwnd after loss (optional) */\n\tu32  (*undo_cwnd)(struct sock *sk);\n\t/* hook for packet ack accounting (optional) */\n\tvoid (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);\n\t/* suggest number of segments for each skb to transmit (optional) */\n\tu32 (*tso_segs_goal)(struct sock *sk);\n\t/* returns the multiplier used in tcp_sndbuf_expand (optional) */\n\tu32 (*sndbuf_expand)(struct sock *sk);\n\t/* call when packets are delivered to update cwnd and pacing rate,\n\t * after all the ca_state processing. (optional)\n\t */\n\tvoid (*cong_control)(struct sock *sk, const struct rate_sample *rs);\n\t/* get info for inet_diag (optional) */\n\tsize_t (*get_info)(struct sock *sk, u32 ext, int *attr,\n\t\t\t   union tcp_cc_info *info);\n\n\tchar \t\tname[TCP_CA_NAME_MAX];\n\tstruct module \t*owner;\n};\n\nint tcp_register_congestion_control(struct tcp_congestion_ops *type);\nvoid tcp_unregister_congestion_control(struct tcp_congestion_ops *type);\n\nvoid tcp_assign_congestion_control(struct sock *sk);\nvoid tcp_init_congestion_control(struct sock *sk);\nvoid tcp_cleanup_congestion_control(struct sock *sk);\nint tcp_set_default_congestion_control(const char *name);\nvoid tcp_get_default_congestion_control(char *name);\nvoid tcp_get_available_congestion_control(char *buf, size_t len);\nvoid tcp_get_allowed_congestion_control(char *buf, size_t len);\nint tcp_set_allowed_congestion_control(char *allowed);\nint tcp_set_congestion_control(struct sock *sk, const char *name);\nu32 tcp_slow_start(struct tcp_sock *tp, u32 acked);\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked);\n\nu32 tcp_reno_ssthresh(struct sock *sk);\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);\nextern struct tcp_congestion_ops tcp_reno;\n\nstruct tcp_congestion_ops *tcp_ca_find_key(u32 key);\nu32 tcp_ca_get_key_by_name(const char *name, bool *ecn_ca);\n#ifdef CONFIG_INET\nchar *tcp_ca_get_name_by_key(u32 key, char *buffer);\n#else\nstatic inline char *tcp_ca_get_name_by_key(u32 key, char *buffer)\n{\n\treturn NULL;\n}\n#endif\n\nstatic inline bool tcp_ca_needs_ecn(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\treturn icsk->icsk_ca_ops->flags & TCP_CONG_NEEDS_ECN;\n}\n\nstatic inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->set_state)\n\t\ticsk->icsk_ca_ops->set_state(sk, ca_state);\n\ticsk->icsk_ca_state = ca_state;\n}\n\nstatic inline void tcp_ca_event(struct sock *sk, const enum tcp_ca_event event)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->cwnd_event)\n\t\ticsk->icsk_ca_ops->cwnd_event(sk, event);\n}\n\n/* From tcp_rate.c */\nvoid tcp_rate_skb_sent(struct sock *sk, struct sk_buff *skb);\nvoid tcp_rate_skb_delivered(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct rate_sample *rs);\nvoid tcp_rate_gen(struct sock *sk, u32 delivered, u32 lost,\n\t\t  struct skb_mstamp *now, struct rate_sample *rs);\nvoid tcp_rate_check_app_limited(struct sock *sk);\n\n/* These functions determine how the current flow behaves in respect of SACK\n * handling. SACK is negotiated with the peer, and therefore it can vary\n * between different flows.\n *\n * tcp_is_sack - SACK enabled\n * tcp_is_reno - No SACK\n * tcp_is_fack - FACK enabled, implies SACK enabled\n */\nstatic inline int tcp_is_sack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok;\n}\n\nstatic inline bool tcp_is_reno(const struct tcp_sock *tp)\n{\n\treturn !tcp_is_sack(tp);\n}\n\nstatic inline bool tcp_is_fack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok & TCP_FACK_ENABLED;\n}\n\nstatic inline void tcp_enable_fack(struct tcp_sock *tp)\n{\n\ttp->rx_opt.sack_ok |= TCP_FACK_ENABLED;\n}\n\n/* TCP early-retransmit (ER) is similar to but more conservative than\n * the thin-dupack feature.  Enable ER only if thin-dupack is disabled.\n */\nstatic inline void tcp_enable_early_retrans(struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\ttp->do_early_retrans = sysctl_tcp_early_retrans &&\n\t\tsysctl_tcp_early_retrans < 4 && !sysctl_tcp_thin_dupack &&\n\t\tnet->ipv4.sysctl_tcp_reordering == 3;\n}\n\nstatic inline void tcp_disable_early_retrans(struct tcp_sock *tp)\n{\n\ttp->do_early_retrans = 0;\n}\n\nstatic inline unsigned int tcp_left_out(const struct tcp_sock *tp)\n{\n\treturn tp->sacked_out + tp->lost_out;\n}\n\n/* This determines how many packets are \"in the network\" to the best\n * of our knowledge.  In many cases it is conservative, but where\n * detailed information is available from the receiver (via SACK\n * blocks etc.) we can make more aggressive calculations.\n *\n * Use this for decisions involving congestion control, use just\n * tp->packets_out to determine if the send queue is empty or not.\n *\n * Read this equation as:\n *\n *\t\"Packets sent once on transmission queue\" MINUS\n *\t\"Packets left network, but not honestly ACKed yet\" PLUS\n *\t\"Packets fast retransmitted\"\n */\nstatic inline unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)\n{\n\treturn tp->packets_out - tcp_left_out(tp) + tp->retrans_out;\n}\n\n#define TCP_INFINITE_SSTHRESH\t0x7fffffff\n\nstatic inline bool tcp_in_slow_start(const struct tcp_sock *tp)\n{\n\treturn tp->snd_cwnd < tp->snd_ssthresh;\n}\n\nstatic inline bool tcp_in_initial_slowstart(const struct tcp_sock *tp)\n{\n\treturn tp->snd_ssthresh >= TCP_INFINITE_SSTHRESH;\n}\n\nstatic inline bool tcp_in_cwnd_reduction(const struct sock *sk)\n{\n\treturn (TCPF_CA_CWR | TCPF_CA_Recovery) &\n\t       (1 << inet_csk(sk)->icsk_ca_state);\n}\n\n/* If cwnd > ssthresh, we may raise ssthresh to be half-way to cwnd.\n * The exception is cwnd reduction phase, when cwnd is decreasing towards\n * ssthresh.\n */\nstatic inline __u32 tcp_current_ssthresh(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_in_cwnd_reduction(sk))\n\t\treturn tp->snd_ssthresh;\n\telse\n\t\treturn max(tp->snd_ssthresh,\n\t\t\t   ((tp->snd_cwnd >> 1) +\n\t\t\t    (tp->snd_cwnd >> 2)));\n}\n\n/* Use define here intentionally to get WARN_ON location shown at the caller */\n#define tcp_verify_left_out(tp)\tWARN_ON(tcp_left_out(tp) > tp->packets_out)\n\nvoid tcp_enter_cwr(struct sock *sk);\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst);\n\n/* The maximum number of MSS of available cwnd for which TSO defers\n * sending if not using sysctl_tcp_tso_win_divisor.\n */\nstatic inline __u32 tcp_max_tso_deferred_mss(const struct tcp_sock *tp)\n{\n\treturn 3;\n}\n\n/* Returns end sequence number of the receiver's advertised window */\nstatic inline u32 tcp_wnd_end(const struct tcp_sock *tp)\n{\n\treturn tp->snd_una + tp->snd_wnd;\n}\n\n/* We follow the spirit of RFC2861 to validate cwnd but implement a more\n * flexible approach. The RFC suggests cwnd should not be raised unless\n * it was fully used previously. And that's exactly what we do in\n * congestion avoidance mode. But in slow start we allow cwnd to grow\n * as long as the application has used half the cwnd.\n * Example :\n *    cwnd is 10 (IW10), but application sends 9 frames.\n *    We allow cwnd to reach 18 when all frames are ACKed.\n * This check is safe because it's as aggressive as slow start which already\n * risks 100% overshoot. The advantage is that we discourage application to\n * either send more filler packets or data to artificially blow up the cwnd\n * usage, and allow application-limited process to probe bw more aggressively.\n */\nstatic inline bool tcp_is_cwnd_limited(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If in slow start, ensure cwnd grows to twice what was ACKed. */\n\tif (tcp_in_slow_start(tp))\n\t\treturn tp->snd_cwnd < 2 * tp->max_packets_out;\n\n\treturn tp->is_cwnd_limited;\n}\n\n/* Something is really bad, we could not queue an additional packet,\n * because qdisc is full or receiver sent a 0 window.\n * We do not want to add fuel to the fire, or abort too early,\n * so make sure the timer we arm now is at least 200ms in the future,\n * regardless of current icsk_rto value (as it could be ~2ms)\n */\nstatic inline unsigned long tcp_probe0_base(const struct sock *sk)\n{\n\treturn max_t(unsigned long, inet_csk(sk)->icsk_rto, TCP_RTO_MIN);\n}\n\n/* Variant of inet_csk_rto_backoff() used for zero window probes */\nstatic inline unsigned long tcp_probe0_when(const struct sock *sk,\n\t\t\t\t\t    unsigned long max_when)\n{\n\tu64 when = (u64)tcp_probe0_base(sk) << inet_csk(sk)->icsk_backoff;\n\n\treturn (unsigned long)min_t(u64, when, max_when);\n}\n\nstatic inline void tcp_check_probe_timer(struct sock *sk)\n{\n\tif (!tcp_sk(sk)->packets_out && !inet_csk(sk)->icsk_pending)\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t\t  tcp_probe0_base(sk), TCP_RTO_MAX);\n}\n\nstatic inline void tcp_init_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\nstatic inline void tcp_update_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\n/*\n * Calculate(/check) TCP checksum\n */\nstatic inline __sum16 tcp_v4_check(int len, __be32 saddr,\n\t\t\t\t   __be32 daddr, __wsum base)\n{\n\treturn csum_tcpudp_magic(saddr,daddr,len,IPPROTO_TCP,base);\n}\n\nstatic inline __sum16 __tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn __skb_checksum_complete(skb);\n}\n\nstatic inline bool tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t\t__tcp_checksum_complete(skb);\n}\n\n/* Prequeue for VJ style copy to user, combined with checksumming. */\n\nstatic inline void tcp_prequeue_init(struct tcp_sock *tp)\n{\n\ttp->ucopy.task = NULL;\n\ttp->ucopy.len = 0;\n\ttp->ucopy.memory = 0;\n\tskb_queue_head_init(&tp->ucopy.prequeue);\n}\n\nbool tcp_prequeue(struct sock *sk, struct sk_buff *skb);\nbool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);\n\n#undef STATE_TRACE\n\n#ifdef STATE_TRACE\nstatic const char *statename[]={\n\t\"Unused\",\"Established\",\"Syn Sent\",\"Syn Recv\",\n\t\"Fin Wait 1\",\"Fin Wait 2\",\"Time Wait\", \"Close\",\n\t\"Close Wait\",\"Last ACK\",\"Listen\",\"Closing\"\n};\n#endif\nvoid tcp_set_state(struct sock *sk, int state);\n\nvoid tcp_done(struct sock *sk);\n\nint tcp_abort(struct sock *sk, int err);\n\nstatic inline void tcp_sack_reset(struct tcp_options_received *rx_opt)\n{\n\trx_opt->dsack = 0;\n\trx_opt->num_sacks = 0;\n}\n\nu32 tcp_default_init_rwnd(u32 mss);\nvoid tcp_cwnd_restart(struct sock *sk, s32 delta);\n\nstatic inline void tcp_slow_start_after_idle_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ts32 delta;\n\n\tif (!sysctl_tcp_slow_start_after_idle || tp->packets_out)\n\t\treturn;\n\tdelta = tcp_time_stamp - tp->lsndtime;\n\tif (delta > inet_csk(sk)->icsk_rto)\n\t\ttcp_cwnd_restart(sk, delta);\n}\n\n/* Determine a window scaling and initial window to offer. */\nvoid tcp_select_initial_window(int __space, __u32 mss, __u32 *rcv_wnd,\n\t\t\t       __u32 *window_clamp, int wscale_ok,\n\t\t\t       __u8 *rcv_wscale, __u32 init_rcv_wnd);\n\nstatic inline int tcp_win_from_space(int space)\n{\n\treturn sysctl_tcp_adv_win_scale<=0 ?\n\t\t(space>>(-sysctl_tcp_adv_win_scale)) :\n\t\tspace - (space>>sysctl_tcp_adv_win_scale);\n}\n\n/* Note: caller must be prepared to deal with negative returns */\nstatic inline int tcp_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf -\n\t\t\t\t  atomic_read(&sk->sk_rmem_alloc));\n}\n\nstatic inline int tcp_full_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf);\n}\n\nextern void tcp_openreq_init_rwin(struct request_sock *req,\n\t\t\t\t  const struct sock *sk_listener,\n\t\t\t\t  const struct dst_entry *dst);\n\nvoid tcp_enter_memory_pressure(struct sock *sk);\n\nstatic inline int keepalive_intvl_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_intvl ? : net->ipv4.sysctl_tcp_keepalive_intvl;\n}\n\nstatic inline int keepalive_time_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_time ? : net->ipv4.sysctl_tcp_keepalive_time;\n}\n\nstatic inline int keepalive_probes(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_probes ? : net->ipv4.sysctl_tcp_keepalive_probes;\n}\n\nstatic inline u32 keepalive_time_elapsed(const struct tcp_sock *tp)\n{\n\tconst struct inet_connection_sock *icsk = &tp->inet_conn;\n\n\treturn min_t(u32, tcp_time_stamp - icsk->icsk_ack.lrcvtime,\n\t\t\t  tcp_time_stamp - tp->rcv_tstamp);\n}\n\nstatic inline int tcp_fin_time(const struct sock *sk)\n{\n\tint fin_timeout = tcp_sk(sk)->linger2 ? : sock_net(sk)->ipv4.sysctl_tcp_fin_timeout;\n\tconst int rto = inet_csk(sk)->icsk_rto;\n\n\tif (fin_timeout < (rto << 2) - (rto >> 1))\n\t\tfin_timeout = (rto << 2) - (rto >> 1);\n\n\treturn fin_timeout;\n}\n\nstatic inline bool tcp_paws_check(const struct tcp_options_received *rx_opt,\n\t\t\t\t  int paws_win)\n{\n\tif ((s32)(rx_opt->ts_recent - rx_opt->rcv_tsval) <= paws_win)\n\t\treturn true;\n\tif (unlikely(get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_24DAYS))\n\t\treturn true;\n\t/*\n\t * Some OSes send SYN and SYNACK messages with tsval=0 tsecr=0,\n\t * then following tcp messages have valid values. Ignore 0 value,\n\t * or else 'negative' tsval might forbid us to accept their packets.\n\t */\n\tif (!rx_opt->ts_recent)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,\n\t\t\t\t   int rst)\n{\n\tif (tcp_paws_check(rx_opt, 0))\n\t\treturn false;\n\n\t/* RST segments are not recommended to carry timestamp,\n\t   and, if they do, it is recommended to ignore PAWS because\n\t   \"their cleanup function should take precedence over timestamps.\"\n\t   Certainly, it is mistake. It is necessary to understand the reasons\n\t   of this constraint to relax it: if peer reboots, clock may go\n\t   out-of-sync and half-open connections will not be reset.\n\t   Actually, the problem would be not existing if all\n\t   the implementations followed draft about maintaining clock\n\t   via reboots. Linux-2.2 DOES NOT!\n\n\t   However, we can relax time bounds for RST segments to MSL.\n\t */\n\tif (rst && get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_MSL)\n\t\treturn false;\n\treturn true;\n}\n\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time);\n\nstatic inline void tcp_mib_init(struct net *net)\n{\n\t/* See RFC 2012 */\n\tTCP_ADD_STATS(net, TCP_MIB_RTOALGORITHM, 1);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMIN, TCP_RTO_MIN*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMAX, TCP_RTO_MAX*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_MAXCONN, -1);\n}\n\n/* from STCP */\nstatic inline void tcp_clear_retrans_hints_partial(struct tcp_sock *tp)\n{\n\ttp->lost_skb_hint = NULL;\n}\n\nstatic inline void tcp_clear_all_retrans_hints(struct tcp_sock *tp)\n{\n\ttcp_clear_retrans_hints_partial(tp);\n\ttp->retransmit_skb_hint = NULL;\n}\n\nunion tcp_md5_addr {\n\tstruct in_addr  a4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr\ta6;\n#endif\n};\n\n/* - key database */\nstruct tcp_md5sig_key {\n\tstruct hlist_node\tnode;\n\tu8\t\t\tkeylen;\n\tu8\t\t\tfamily; /* AF_INET or AF_INET6 */\n\tunion tcp_md5_addr\taddr;\n\tu8\t\t\tkey[TCP_MD5SIG_MAXKEYLEN];\n\tstruct rcu_head\t\trcu;\n};\n\n/* - sock block */\nstruct tcp_md5sig_info {\n\tstruct hlist_head\thead;\n\tstruct rcu_head\t\trcu;\n};\n\n/* - pseudo header */\nstruct tcp4_pseudohdr {\n\t__be32\t\tsaddr;\n\t__be32\t\tdaddr;\n\t__u8\t\tpad;\n\t__u8\t\tprotocol;\n\t__be16\t\tlen;\n};\n\nstruct tcp6_pseudohdr {\n\tstruct in6_addr\tsaddr;\n\tstruct in6_addr daddr;\n\t__be32\t\tlen;\n\t__be32\t\tprotocol;\t/* including padding */\n};\n\nunion tcp_md5sum_block {\n\tstruct tcp4_pseudohdr ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct tcp6_pseudohdr ip6;\n#endif\n};\n\n/* - pool: digest algorithm, hash description and scratch buffer */\nstruct tcp_md5sig_pool {\n\tstruct ahash_request\t*md5_req;\n\tvoid\t\t\t*scratch;\n};\n\n/* - functions */\nint tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\tconst struct sock *sk, const struct sk_buff *skb);\nint tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family, const u8 *newkey, u8 newkeylen, gfp_t gfp);\nint tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family);\nstruct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,\n\t\t\t\t\t const struct sock *addr_sk);\n\n#ifdef CONFIG_TCP_MD5SIG\nstruct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family);\n#define tcp_twsk_md5_key(twsk)\t((twsk)->tw_md5_key)\n#else\nstatic inline struct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family)\n{\n\treturn NULL;\n}\n#define tcp_twsk_md5_key(twsk)\tNULL\n#endif\n\nbool tcp_alloc_md5sig_pool(void);\n\nstruct tcp_md5sig_pool *tcp_get_md5sig_pool(void);\nstatic inline void tcp_put_md5sig_pool(void)\n{\n\tlocal_bh_enable();\n}\n\nint tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,\n\t\t\t  unsigned int header_len);\nint tcp_md5_hash_key(struct tcp_md5sig_pool *hp,\n\t\t     const struct tcp_md5sig_key *key);\n\n/* From tcp_fastopen.c */\nvoid tcp_fastopen_cache_get(struct sock *sk, u16 *mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, int *syn_loss,\n\t\t\t    unsigned long *last_syn_loss);\nvoid tcp_fastopen_cache_set(struct sock *sk, u16 mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, bool syn_lost,\n\t\t\t    u16 try_exp);\nstruct tcp_fastopen_request {\n\t/* Fast Open cookie. Size 0 means a cookie request */\n\tstruct tcp_fastopen_cookie\tcookie;\n\tstruct msghdr\t\t\t*data;  /* data in MSG_FASTOPEN */\n\tsize_t\t\t\t\tsize;\n\tint\t\t\t\tcopied;\t/* queued in tcp_connect() */\n};\nvoid tcp_free_fastopen_req(struct tcp_sock *tp);\n\nextern struct tcp_fastopen_context __rcu *tcp_fastopen_ctx;\nint tcp_fastopen_reset_cipher(void *key, unsigned int len);\nvoid tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      struct dst_entry *dst);\nvoid tcp_fastopen_init_key_once(bool publish);\n#define TCP_FASTOPEN_KEY_LENGTH 16\n\n/* Fastopen key context */\nstruct tcp_fastopen_context {\n\tstruct crypto_cipher\t*tfm;\n\t__u8\t\t\tkey[TCP_FASTOPEN_KEY_LENGTH];\n\tstruct rcu_head\t\trcu;\n};\n\n/* write queue abstraction */\nstatic inline void tcp_write_queue_purge(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&sk->sk_write_queue)) != NULL)\n\t\tsk_wmem_free_skb(sk, skb);\n\tsk_mem_reclaim(sk);\n\ttcp_clear_all_retrans_hints(tcp_sk(sk));\n}\n\nstatic inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)\n{\n\treturn skb_peek(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)\n{\n\treturn skb_peek_tail(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_next(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_next(&sk->sk_write_queue, skb);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_prev(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_prev(&sk->sk_write_queue, skb);\n}\n\n#define tcp_for_write_queue(skb, sk)\t\t\t\t\t\\\n\tskb_queue_walk(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from(skb, sk)\t\t\t\t\\\n\tskb_queue_walk_from(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from_safe(skb, tmp, sk)\t\t\t\\\n\tskb_queue_walk_from_safe(&(sk)->sk_write_queue, skb, tmp)\n\nstatic inline struct sk_buff *tcp_send_head(const struct sock *sk)\n{\n\treturn sk->sk_send_head;\n}\n\nstatic inline bool tcp_skb_is_last(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_is_last(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_advance_send_head(struct sock *sk, const struct sk_buff *skb)\n{\n\tif (tcp_skb_is_last(sk, skb))\n\t\tsk->sk_send_head = NULL;\n\telse\n\t\tsk->sk_send_head = tcp_write_queue_next(sk, skb);\n}\n\nstatic inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}\n\nstatic inline void tcp_init_send_head(struct sock *sk)\n{\n\tsk->sk_send_head = NULL;\n}\n\nstatic inline void __tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__tcp_add_write_queue_tail(sk, skb);\n\n\t/* Queue it, remembering where we must start sending. */\n\tif (sk->sk_send_head == NULL) {\n\t\tsk->sk_send_head = skb;\n\n\t\tif (tcp_sk(sk)->highest_sack == NULL)\n\t\t\ttcp_sk(sk)->highest_sack = skb;\n\t}\n}\n\nstatic inline void __tcp_add_write_queue_head(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_head(&sk->sk_write_queue, skb);\n}\n\n/* Insert buff after skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_after(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sk_buff *buff,\n\t\t\t\t\t\tstruct sock *sk)\n{\n\t__skb_queue_after(&sk->sk_write_queue, skb, buff);\n}\n\n/* Insert new before skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_before(struct sk_buff *new,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  struct sock *sk)\n{\n\t__skb_queue_before(&sk->sk_write_queue, skb, new);\n\n\tif (sk->sk_send_head == skb)\n\t\tsk->sk_send_head = new;\n}\n\nstatic inline void tcp_unlink_write_queue(struct sk_buff *skb, struct sock *sk)\n{\n\t__skb_unlink(skb, &sk->sk_write_queue);\n}\n\nstatic inline bool tcp_write_queue_empty(struct sock *sk)\n{\n\treturn skb_queue_empty(&sk->sk_write_queue);\n}\n\nstatic inline void tcp_push_pending_frames(struct sock *sk)\n{\n\tif (tcp_send_head(sk)) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk), tp->nonagle);\n\t}\n}\n\n/* Start sequence of the skb just after the highest skb with SACKed\n * bit, valid only if sacked_out > 0 or when the caller has ensured\n * validity by itself.\n */\nstatic inline u32 tcp_highest_sack_seq(struct tcp_sock *tp)\n{\n\tif (!tp->sacked_out)\n\t\treturn tp->snd_una;\n\n\tif (tp->highest_sack == NULL)\n\t\treturn tp->snd_nxt;\n\n\treturn TCP_SKB_CB(tp->highest_sack)->seq;\n}\n\nstatic inline void tcp_advance_highest_sack(struct sock *sk, struct sk_buff *skb)\n{\n\ttcp_sk(sk)->highest_sack = tcp_skb_is_last(sk, skb) ? NULL :\n\t\t\t\t\t\ttcp_write_queue_next(sk, skb);\n}\n\nstatic inline struct sk_buff *tcp_highest_sack(struct sock *sk)\n{\n\treturn tcp_sk(sk)->highest_sack;\n}\n\nstatic inline void tcp_highest_sack_reset(struct sock *sk)\n{\n\ttcp_sk(sk)->highest_sack = tcp_write_queue_head(sk);\n}\n\n/* Called when old skb is about to be deleted (to be combined with new skb) */\nstatic inline void tcp_highest_sack_combine(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *old,\n\t\t\t\t\t    struct sk_buff *new)\n{\n\tif (tcp_sk(sk)->sacked_out && (old == tcp_sk(sk)->highest_sack))\n\t\ttcp_sk(sk)->highest_sack = new;\n}\n\n/* This helper checks if socket has IP_TRANSPARENT set */\nstatic inline bool inet_sk_transparent(const struct sock *sk)\n{\n\tswitch (sk->sk_state) {\n\tcase TCP_TIME_WAIT:\n\t\treturn inet_twsk(sk)->tw_transparent;\n\tcase TCP_NEW_SYN_RECV:\n\t\treturn inet_rsk(inet_reqsk(sk))->no_srccheck;\n\t}\n\treturn inet_sk(sk)->transparent;\n}\n\n/* Determines whether this is a thin stream (which may suffer from\n * increased latency). Used to trigger latency-reducing mechanisms.\n */\nstatic inline bool tcp_stream_is_thin(struct tcp_sock *tp)\n{\n\treturn tp->packets_out < 4 && !tcp_in_initial_slowstart(tp);\n}\n\n/* /proc */\nenum tcp_seq_states {\n\tTCP_SEQ_STATE_LISTENING,\n\tTCP_SEQ_STATE_ESTABLISHED,\n};\n\nint tcp_seq_open(struct inode *inode, struct file *file);\n\nstruct tcp_seq_afinfo {\n\tchar\t\t\t\t*name;\n\tsa_family_t\t\t\tfamily;\n\tconst struct file_operations\t*seq_fops;\n\tstruct seq_operations\t\tseq_ops;\n};\n\nstruct tcp_iter_state {\n\tstruct seq_net_private\tp;\n\tsa_family_t\t\tfamily;\n\tenum tcp_seq_states\tstate;\n\tstruct sock\t\t*syn_wait_sk;\n\tint\t\t\tbucket, offset, sbucket, num;\n\tloff_t\t\t\tlast_pos;\n};\n\nint tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo);\nvoid tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo);\n\nextern struct request_sock_ops tcp_request_sock_ops;\nextern struct request_sock_ops tcp6_request_sock_ops;\n\nvoid tcp_v4_destroy_sock(struct sock *sk);\n\nstruct sk_buff *tcp_gso_segment(struct sk_buff *skb,\n\t\t\t\tnetdev_features_t features);\nstruct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb);\nint tcp_gro_complete(struct sk_buff *skb);\n\nvoid __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr);\n\nstatic inline u32 tcp_notsent_lowat(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\treturn tp->notsent_lowat ?: net->ipv4.sysctl_tcp_notsent_lowat;\n}\n\nstatic inline bool tcp_stream_memory_free(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu32 notsent_bytes = tp->write_seq - tp->snd_nxt;\n\n\treturn notsent_bytes < tcp_notsent_lowat(tp);\n}\n\n#ifdef CONFIG_PROC_FS\nint tcp4_proc_init(void);\nvoid tcp4_proc_exit(void);\n#endif\n\nint tcp_rtx_synack(const struct sock *sk, struct request_sock *req);\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb);\n\n/* TCP af-specific functions */\nstruct tcp_sock_af_ops {\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key\t*(*md5_lookup) (const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash)(char *location,\n\t\t\t\t\t const struct tcp_md5sig_key *md5,\n\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t const struct sk_buff *skb);\n\tint\t\t(*md5_parse)(struct sock *sk,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int optlen);\n#endif\n};\n\nstruct tcp_request_sock_ops {\n\tu16 mss_clamp;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *(*req_md5_lookup)(const struct sock *sk,\n\t\t\t\t\t\t const struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash) (char *location,\n\t\t\t\t\t  const struct tcp_md5sig_key *md5,\n\t\t\t\t\t  const struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb);\n#endif\n\tvoid (*init_req)(struct request_sock *req,\n\t\t\t const struct sock *sk_listener,\n\t\t\t struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\t__u32 (*cookie_init_seq)(const struct sk_buff *skb,\n\t\t\t\t __u16 *mss);\n#endif\n\tstruct dst_entry *(*route_req)(const struct sock *sk, struct flowi *fl,\n\t\t\t\t       const struct request_sock *req,\n\t\t\t\t       bool *strict);\n\t__u32 (*init_seq)(const struct sk_buff *skb);\n\tint (*send_synack)(const struct sock *sk, struct dst_entry *dst,\n\t\t\t   struct flowi *fl, struct request_sock *req,\n\t\t\t   struct tcp_fastopen_cookie *foc,\n\t\t\t   enum tcp_synack_type synack_type);\n};\n\n#ifdef CONFIG_SYN_COOKIES\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\ttcp_synq_overflow(sk);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESSENT);\n\treturn ops->cookie_init_seq(skb, mss);\n}\n#else\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\treturn 0;\n}\n#endif\n\nint tcpv4_offload_init(void);\n\nvoid tcp_v4_init(void);\nvoid tcp_init(void);\n\n/* tcp_recovery.c */\n\n/* Flags to enable various loss recovery features. See below */\nextern int sysctl_tcp_recovery;\n\n/* Use TCP RACK to detect (some) tail and retransmit losses */\n#define TCP_RACK_LOST_RETRANS  0x1\n\nextern int tcp_rack_mark_lost(struct sock *sk);\n\nextern void tcp_rack_advance(struct tcp_sock *tp,\n\t\t\t     const struct skb_mstamp *xmit_time, u8 sacked);\n\n/*\n * Save and compile IPv4 options, return a pointer to it\n */\nstatic inline struct ip_options_rcu *tcp_v4_save_options(struct sk_buff *skb)\n{\n\tconst struct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\n\tstruct ip_options_rcu *dopt = NULL;\n\n\tif (opt->optlen) {\n\t\tint opt_size = sizeof(*dopt) + opt->optlen;\n\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt && __ip_options_echo(&dopt->opt, skb, opt)) {\n\t\t\tkfree(dopt);\n\t\t\tdopt = NULL;\n\t\t}\n\t}\n\treturn dopt;\n}\n\n/* locally generated TCP pure ACKs have skb->truesize == 2\n * (check tcp_send_ack() in net/ipv4/tcp_output.c )\n * This is much faster than dissecting the packet to find out.\n * (Think of GRE encapsulations, IPv4, IPv6, ...)\n */\nstatic inline bool skb_is_tcp_pure_ack(const struct sk_buff *skb)\n{\n\treturn skb->truesize == 2;\n}\n\nstatic inline void skb_set_tcp_pure_ack(struct sk_buff *skb)\n{\n\tskb->truesize = 2;\n}\n\nstatic inline int tcp_inq(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint answ;\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\tansw = 0;\n\t} else if (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t   !tp->urg_data ||\n\t\t   before(tp->urg_seq, tp->copied_seq) ||\n\t\t   !before(tp->urg_seq, tp->rcv_nxt)) {\n\n\t\tansw = tp->rcv_nxt - tp->copied_seq;\n\n\t\t/* Subtract 1, if FIN was received */\n\t\tif (answ && sock_flag(sk, SOCK_DONE))\n\t\t\tansw--;\n\t} else {\n\t\tansw = tp->urg_seq - tp->copied_seq;\n\t}\n\n\treturn answ;\n}\n\nint tcp_peek_len(struct socket *sock);\n\nstatic inline void tcp_segs_in(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tu16 segs_in;\n\n\tsegs_in = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\ttp->segs_in += segs_in;\n\tif (skb->len > tcp_hdrlen(skb))\n\t\ttp->data_segs_in += segs_in;\n}\n\n/*\n * TCP listen path runs lockless.\n * We forced \"struct sock\" to be const qualified to make sure\n * we don't modify one of its field by mistake.\n * Here, we increment sk_drops which is an atomic_t, so we can safely\n * make sock writable again.\n */\nstatic inline void tcp_listendrop(const struct sock *sk)\n{\n\tatomic_inc(&((struct sock *)sk)->sk_drops);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n}\n\n#endif\t/* _TCP_H */\n", "/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tImplementation of the Transmission Control Protocol(TCP).\n *\n *\t\tIPv4 specific functions\n *\n *\n *\t\tcode split from:\n *\t\tlinux/ipv4/tcp.c\n *\t\tlinux/ipv4/tcp_input.c\n *\t\tlinux/ipv4/tcp_output.c\n *\n *\t\tSee tcp.c for author information\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n * Changes:\n *\t\tDavid S. Miller\t:\tNew socket lookup architecture.\n *\t\t\t\t\tThis code is dedicated to John Dyson.\n *\t\tDavid S. Miller :\tChange semantics of established hash,\n *\t\t\t\t\thalf is devoted to TIME_WAIT sockets\n *\t\t\t\t\tand the rest go in the other half.\n *\t\tAndi Kleen :\t\tAdd support for syncookies and fixed\n *\t\t\t\t\tsome bugs: ip options weren't passed to\n *\t\t\t\t\tthe TCP layer, missed a check for an\n *\t\t\t\t\tACK bit.\n *\t\tAndi Kleen :\t\tImplemented fast path mtu discovery.\n *\t     \t\t\t\tFixed many serious bugs in the\n *\t\t\t\t\trequest_sock handling and moved\n *\t\t\t\t\tmost of it into the af independent code.\n *\t\t\t\t\tAdded tail drop and some other bugfixes.\n *\t\t\t\t\tAdded new listen semantics.\n *\t\tMike McLagan\t:\tRouting by source\n *\tJuan Jose Ciarlante:\t\tip_dynaddr bits\n *\t\tAndi Kleen:\t\tvarious fixes.\n *\tVitaly E. Lavrov\t:\tTransparent proxy revived after year\n *\t\t\t\t\tcoma.\n *\tAndi Kleen\t\t:\tFix new listen.\n *\tAndi Kleen\t\t:\tFix accept error reporting.\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n */\n\n#define pr_fmt(fmt) \"TCP: \" fmt\n\n#include <linux/bottom_half.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/cache.h>\n#include <linux/jhash.h>\n#include <linux/init.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n\n#include <net/net_namespace.h>\n#include <net/icmp.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp.h>\n#include <net/transp_v6.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/timewait_sock.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/inet.h>\n#include <linux/ipv6.h>\n#include <linux/stddef.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\nint sysctl_tcp_tw_reuse __read_mostly;\nint sysctl_tcp_low_latency __read_mostly;\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       __be32 daddr, __be32 saddr, const struct tcphdr *th);\n#endif\n\nstruct inet_hashinfo tcp_hashinfo;\nEXPORT_SYMBOL(tcp_hashinfo);\n\nstatic  __u32 tcp_v4_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_tcp_sequence_number(ip_hdr(skb)->daddr,\n\t\t\t\t\t  ip_hdr(skb)->saddr,\n\t\t\t\t\t  tcp_hdr(skb)->dest,\n\t\t\t\t\t  tcp_hdr(skb)->source);\n}\n\nint tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp)\n{\n\tconst struct tcp_timewait_sock *tcptw = tcp_twsk(sktw);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* With PAWS, it is safe from the viewpoint\n\t   of data integrity. Even without PAWS it is safe provided sequence\n\t   spaces do not overlap i.e. at data rates <= 80Mbit/sec.\n\n\t   Actually, the idea is close to VJ's one, only timestamp cache is\n\t   held not per host, but per port pair and TW bucket is used as state\n\t   holder.\n\n\t   If TW bucket has been already destroyed we fall back to VJ's scheme\n\t   and use initial timestamp retrieved from peer table.\n\t */\n\tif (tcptw->tw_ts_recent_stamp &&\n\t    (!twp || (sysctl_tcp_tw_reuse &&\n\t\t\t     get_seconds() - tcptw->tw_ts_recent_stamp > 1))) {\n\t\ttp->write_seq = tcptw->tw_snd_nxt + 65535 + 2;\n\t\tif (tp->write_seq == 0)\n\t\t\ttp->write_seq = 1;\n\t\ttp->rx_opt.ts_recent\t   = tcptw->tw_ts_recent;\n\t\ttp->rx_opt.ts_recent_stamp = tcptw->tw_ts_recent_stamp;\n\t\tsock_hold(sktw);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tcp_twsk_unique);\n\n/* This will initiate an outgoing connection. */\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 *fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     lockdep_sock_is_held(sk));\n\tif (inet_opt && inet_opt->opt.srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\tfl4 = &inet->cork.fl.u.ip4;\n\trt = ip_route_connect(fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_TCP,\n\t\t\t      orig_sport, orig_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\treturn err;\n\t}\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (!inet_opt || !inet_opt->opt.srr)\n\t\tdaddr = fl4->daddr;\n\n\tif (!inet->inet_saddr)\n\t\tinet->inet_saddr = fl4->saddr;\n\tsk_rcv_saddr_set(sk, inet->inet_saddr);\n\n\tif (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) {\n\t\t/* Reset inherited state */\n\t\ttp->rx_opt.ts_recent\t   = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\tif (likely(!tp->repair))\n\t\t\ttp->write_seq\t   = 0;\n\t}\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp && fl4->daddr == daddr)\n\t\ttcp_fetch_timewait_stamp(sk, &rt->dst);\n\n\tinet->inet_dport = usin->sin_port;\n\tsk_daddr_set(sk, daddr);\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\n\ttp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n\n\t/* Socket identity is still unknown (sport may be zero).\n\t * However we set state to SYN-SENT and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto failure;\n\n\tsk_set_txhash(sk);\n\n\trt = ip_route_newports(fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(sk, &rt->dst);\n\n\tif (!tp->write_seq && likely(!tp->repair))\n\t\ttp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t\t   inet->inet_daddr,\n\t\t\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t\t\t   usin->sin_port);\n\n\tinet->inet_id = tp->write_seq ^ jiffies;\n\n\terr = tcp_connect(sk);\n\n\trt = NULL;\n\tif (err)\n\t\tgoto failure;\n\n\treturn 0;\n\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port,\n\t * if necessary.\n\t */\n\ttcp_set_state(sk, TCP_CLOSE);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\treturn err;\n}\nEXPORT_SYMBOL(tcp_v4_connect);\n\n/*\n * This routine reacts to ICMP_FRAG_NEEDED mtu indications as defined in RFC1191.\n * It can be called through tcp_release_cb() if socket was owned by user\n * at the time tcp_v4_err() was called to handle ICMP message.\n */\nvoid tcp_v4_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tu32 mtu = tcp_sk(sk)->mtu_info;\n\n\tdst = inet_csk_update_pmtu(sk, mtu);\n\tif (!dst)\n\t\treturn;\n\n\t/* Something is about to be wrong... Remember soft error\n\t * for the case, if this connection will not able to recover.\n\t */\n\tif (mtu < dst_mtu(dst) && ip_dont_fragment(sk, dst))\n\t\tsk->sk_err_soft = EMSGSIZE;\n\n\tmtu = dst_mtu(dst);\n\n\tif (inet->pmtudisc != IP_PMTUDISC_DONT &&\n\t    ip_sk_accept_pmtu(sk) &&\n\t    inet_csk(sk)->icsk_pmtu_cookie > mtu) {\n\t\ttcp_sync_mss(sk, mtu);\n\n\t\t/* Resend the TCP packet because it's\n\t\t * clear that the old packet has been\n\t\t * dropped. This is the new \"fast\" path mtu\n\t\t * discovery.\n\t\t */\n\t\ttcp_simple_retransmit(sk);\n\t} /* else let the usual retransmit timer handle it */\n}\nEXPORT_SYMBOL(tcp_v4_mtu_reduced);\n\nstatic void do_redirect(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct dst_entry *dst = __sk_dst_check(sk, 0);\n\n\tif (dst)\n\t\tdst->ops->redirect(dst, sk, skb);\n}\n\n\n/* handle ICMP messages on TCP_NEW_SYN_RECV request sockets */\nvoid tcp_req_err(struct sock *sk, u32 seq, bool abort)\n{\n\tstruct request_sock *req = inet_reqsk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t/* ICMPs are not backlogged, hence we cannot get\n\t * an established socket here.\n\t */\n\tif (seq != tcp_rsk(req)->snt_isn) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t} else if (abort) {\n\t\t/*\n\t\t * Still in SYN_RECV, just remove it silently.\n\t\t * There is no good way to pass the error to the newly\n\t\t * created socket, and POSIX does not want network\n\t\t * errors returned from accept().\n\t\t */\n\t\tinet_csk_reqsk_queue_drop(req->rsk_listener, req);\n\t\ttcp_listendrop(req->rsk_listener);\n\t}\n\treqsk_put(req);\n}\nEXPORT_SYMBOL(tcp_req_err);\n\n/*\n * This routine is called by the ICMP module when it gets some\n * sort of error condition.  If err < 0 then the socket should\n * be closed and the error returned to the user.  If err > 0\n * it's just the icmp type << 8 | icmp code.  After adjustment\n * header points to the first 8 bytes of the tcp header.  We need\n * to find the appropriate port.\n *\n * The locking strategy used here is very \"optimistic\". When\n * someone else accesses the socket the ICMP is just dropped\n * and for some paths there is no check at all.\n * A more general error queue to queue errors for later handling\n * is probably better.\n *\n */\n\nvoid tcp_v4_err(struct sk_buff *icmp_skb, u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)icmp_skb->data;\n\tstruct tcphdr *th = (struct tcphdr *)(icmp_skb->data + (iph->ihl << 2));\n\tstruct inet_connection_sock *icsk;\n\tstruct tcp_sock *tp;\n\tstruct inet_sock *inet;\n\tconst int type = icmp_hdr(icmp_skb)->type;\n\tconst int code = icmp_hdr(icmp_skb)->code;\n\tstruct sock *sk;\n\tstruct sk_buff *skb;\n\tstruct request_sock *fastopen;\n\t__u32 seq, snd_una;\n\t__u32 remaining;\n\tint err;\n\tstruct net *net = dev_net(icmp_skb->dev);\n\n\tsk = __inet_lookup_established(net, &tcp_hashinfo, iph->daddr,\n\t\t\t\t       th->dest, iph->saddr, ntohs(th->source),\n\t\t\t\t       inet_iif(icmp_skb));\n\tif (!sk) {\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\t\treturn;\n\t}\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq,\n\t\t\t\t  type == ICMP_PARAMETERPROB ||\n\t\t\t\t  type == ICMP_TIME_EXCEEDED ||\n\t\t\t\t  (type == ICMP_DEST_UNREACH &&\n\t\t\t\t   (code == ICMP_NET_UNREACH ||\n\t\t\t\t    code == ICMP_HOST_UNREACH)));\n\n\tbh_lock_sock(sk);\n\t/* If too many ICMPs get dropped on busy\n\t * servers this needs to be solved differently.\n\t * We do take care of PMTU discovery (RFC1191) special case :\n\t * we can receive locally generated ICMP messages while socket is held.\n\t */\n\tif (sock_owned_by_user(sk)) {\n\t\tif (!(type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED))\n\t\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\t}\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ticsk = inet_csk(sk);\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ICMP_REDIRECT:\n\t\tdo_redirect(icmp_skb, sk);\n\t\tgoto out;\n\tcase ICMP_SOURCE_QUENCH:\n\t\t/* Just silently ignore these. */\n\t\tgoto out;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tgoto out;\n\n\t\tif (code == ICMP_FRAG_NEEDED) { /* PMTU discovery (RFC1191) */\n\t\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t\t * they should go through unfragmented).\n\t\t\t */\n\t\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\t\tgoto out;\n\n\t\t\ttp->mtu_info = info;\n\t\t\tif (!sock_owned_by_user(sk)) {\n\t\t\t\ttcp_v4_mtu_reduced(sk);\n\t\t\t} else {\n\t\t\t\tif (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED, &tp->tsq_flags))\n\t\t\t\t\tsock_hold(sk);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = icmp_err_convert[code].errno;\n\t\t/* check if icmp_skb allows revert of backoff\n\t\t * (see draft-zimmermann-tcp-lcd) */\n\t\tif (code != ICMP_NET_UNREACH && code != ICMP_HOST_UNREACH)\n\t\t\tbreak;\n\t\tif (seq != tp->snd_una  || !icsk->icsk_retransmits ||\n\t\t    !icsk->icsk_backoff || fastopen)\n\t\t\tbreak;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tbreak;\n\n\t\ticsk->icsk_backoff--;\n\t\ticsk->icsk_rto = tp->srtt_us ? __tcp_set_rto(tp) :\n\t\t\t\t\t       TCP_TIMEOUT_INIT;\n\t\ticsk->icsk_rto = inet_csk_rto_backoff(icsk, TCP_RTO_MAX);\n\n\t\tskb = tcp_write_queue_head(sk);\n\t\tBUG_ON(!skb);\n\n\t\tremaining = icsk->icsk_rto -\n\t\t\t    min(icsk->icsk_rto,\n\t\t\t\ttcp_time_stamp - tcp_skb_timestamp(skb));\n\n\t\tif (remaining) {\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t\t  remaining, TCP_RTO_MAX);\n\t\t} else {\n\t\t\t/* RTO revert clocked out retransmission.\n\t\t\t * Will retransmit now */\n\t\t\ttcp_retransmit_timer(sk);\n\t\t}\n\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\n\t\t\tsk->sk_error_report(sk);\n\n\t\t\ttcp_done(sk);\n\t\t} else {\n\t\t\tsk->sk_err_soft = err;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* If we've already connected we will keep trying\n\t * until we time out, or the user gives up.\n\t *\n\t * rfc1122 4.2.3.9 allows to consider as hard errors\n\t * only PROTO_UNREACH and PORT_UNREACH (well, FRAG_FAILED too,\n\t * but it is obsoleted by pmtu discovery).\n\t *\n\t * Note, that in modern internet, where routing is unreliable\n\t * and in each dark corner broken firewalls sit, sending random\n\t * errors ordered by their masters even this two messages finally lose\n\t * their original sense (even Linux sends invalid PORT_UNREACHs)\n\t *\n\t * Now we are in compliance with RFCs.\n\t *\t\t\t\t\t\t\t--ANK (980905)\n\t */\n\n\tinet = inet_sk(sk);\n\tif (!sock_owned_by_user(sk) && inet->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\t{ /* Only an error on timeout */\n\t\tsk->sk_err_soft = err;\n\t}\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nvoid __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr)\n{\n\tstruct tcphdr *th = tcp_hdr(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tth->check = ~tcp_v4_check(skb->len, saddr, daddr, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct tcphdr, check);\n\t} else {\n\t\tth->check = tcp_v4_check(skb->len, saddr, daddr,\n\t\t\t\t\t csum_partial(th,\n\t\t\t\t\t\t      th->doff << 2,\n\t\t\t\t\t\t      skb->csum));\n\t}\n}\n\n/* This routine computes an IPv4 TCP checksum. */\nvoid tcp_v4_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\n\t__tcp_v4_send_check(skb, inet->inet_saddr, inet->inet_daddr);\n}\nEXPORT_SYMBOL(tcp_v4_send_check);\n\n/*\n *\tThis routine will send an RST to the other tcp.\n *\n *\tSomeone asks: why I NEVER use socket parameters (TOS, TTL etc.)\n *\t\t      for reset.\n *\tAnswer: if a packet caused RST, it is not for a socket\n *\t\texisting in our system, if it is matched to a socket,\n *\t\tit is just duplicate segment or bug in other side's TCP.\n *\t\tSo that we build reply only basing on parameters\n *\t\tarrived with segment.\n *\tException: precedence violation. We do not implement it in any case.\n */\n\nstatic void tcp_v4_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct {\n\t\tstruct tcphdr th;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t__be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];\n#endif\n\t} rep;\n\tstruct ip_reply_arg arg;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key = NULL;\n\tconst __u8 *hash_location = NULL;\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tstruct net *net;\n\n\t/* Never send a reset in response to a reset. */\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && skb_rtable(skb)->rt_type != RTN_LOCAL)\n\t\treturn;\n\n\t/* Swap the send and the receive. */\n\tmemset(&rep, 0, sizeof(rep));\n\trep.th.dest   = th->source;\n\trep.th.source = th->dest;\n\trep.th.doff   = sizeof(struct tcphdr) / 4;\n\trep.th.rst    = 1;\n\n\tif (th->ack) {\n\t\trep.th.seq = th->ack_seq;\n\t} else {\n\t\trep.th.ack = 1;\n\t\trep.th.ack_seq = htonl(ntohl(th->seq) + th->syn + th->fin +\n\t\t\t\t       skb->len - (th->doff << 2));\n\t}\n\n\tmemset(&arg, 0, sizeof(arg));\n\targ.iov[0].iov_base = (unsigned char *)&rep;\n\targ.iov[0].iov_len  = sizeof(rep.th);\n\n\tnet = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tkey = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)\n\t\t\t\t\t&ip_hdr(skb)->saddr, AF_INET);\n\t} else if (hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = __inet_lookup_listener(net, &tcp_hashinfo, NULL, 0,\n\t\t\t\t\t     ip_hdr(skb)->saddr,\n\t\t\t\t\t     th->source, ip_hdr(skb)->daddr,\n\t\t\t\t\t     ntohs(th->source), inet_iif(skb));\n\t\t/* don't send rst if it can't find key */\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\tkey = tcp_md5_do_lookup(sk1, (union tcp_md5_addr *)\n\t\t\t\t\t&ip_hdr(skb)->saddr, AF_INET);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\n\t\tgenhash = tcp_v4_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\n\t}\n\n\tif (key) {\n\t\trep.opt[0] = htonl((TCPOPT_NOP << 24) |\n\t\t\t\t   (TCPOPT_NOP << 16) |\n\t\t\t\t   (TCPOPT_MD5SIG << 8) |\n\t\t\t\t   TCPOLEN_MD5SIG);\n\t\t/* Update length and the length the header thinks exists */\n\t\targ.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;\n\t\trep.th.doff = arg.iov[0].iov_len / 4;\n\n\t\ttcp_v4_md5_hash_hdr((__u8 *) &rep.opt[1],\n\t\t\t\t     key, ip_hdr(skb)->saddr,\n\t\t\t\t     ip_hdr(skb)->daddr, &rep.th);\n\t}\n#endif\n\targ.csum = csum_tcpudp_nofold(ip_hdr(skb)->daddr,\n\t\t\t\t      ip_hdr(skb)->saddr, /* XXX */\n\t\t\t\t      arg.iov[0].iov_len, IPPROTO_TCP, 0);\n\targ.csumoffset = offsetof(struct tcphdr, check) / 2;\n\targ.flags = (sk && inet_sk_transparent(sk)) ? IP_REPLY_ARG_NOSRCCHECK : 0;\n\n\t/* When socket is gone, all binding information is lost.\n\t * routing might fail in this case. No choice here, if we choose to force\n\t * input interface, we will misroute in case of asymmetric route.\n\t */\n\tif (sk)\n\t\targ.bound_dev_if = sk->sk_bound_dev_if;\n\n\tBUILD_BUG_ON(offsetof(struct sock, sk_bound_dev_if) !=\n\t\t     offsetof(struct inet_timewait_sock, tw_bound_dev_if));\n\n\targ.tos = ip_hdr(skb)->tos;\n\tlocal_bh_disable();\n\tip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),\n\t\t\t      skb, &TCP_SKB_CB(skb)->header.h4.opt,\n\t\t\t      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,\n\t\t\t      &arg, arg.iov[0].iov_len);\n\n\t__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t__TCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\tlocal_bh_enable();\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\n/* The code following below sending ACKs in SYN-RECV and TIME-WAIT states\n   outside socket context is ugly, certainly. What can I do?\n */\n\nstatic void tcp_v4_send_ack(struct net *net,\n\t\t\t    struct sk_buff *skb, u32 seq, u32 ack,\n\t\t\t    u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key,\n\t\t\t    int reply_flags, u8 tos)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct {\n\t\tstruct tcphdr th;\n\t\t__be32 opt[(TCPOLEN_TSTAMP_ALIGNED >> 2)\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\t   + (TCPOLEN_MD5SIG_ALIGNED >> 2)\n#endif\n\t\t\t];\n\t} rep;\n\tstruct ip_reply_arg arg;\n\n\tmemset(&rep.th, 0, sizeof(struct tcphdr));\n\tmemset(&arg, 0, sizeof(arg));\n\n\targ.iov[0].iov_base = (unsigned char *)&rep;\n\targ.iov[0].iov_len  = sizeof(rep.th);\n\tif (tsecr) {\n\t\trep.opt[0] = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t   (TCPOPT_TIMESTAMP << 8) |\n\t\t\t\t   TCPOLEN_TIMESTAMP);\n\t\trep.opt[1] = htonl(tsval);\n\t\trep.opt[2] = htonl(tsecr);\n\t\targ.iov[0].iov_len += TCPOLEN_TSTAMP_ALIGNED;\n\t}\n\n\t/* Swap the send and the receive. */\n\trep.th.dest    = th->source;\n\trep.th.source  = th->dest;\n\trep.th.doff    = arg.iov[0].iov_len / 4;\n\trep.th.seq     = htonl(seq);\n\trep.th.ack_seq = htonl(ack);\n\trep.th.ack     = 1;\n\trep.th.window  = htons(win);\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\tint offset = (tsecr) ? 3 : 0;\n\n\t\trep.opt[offset++] = htonl((TCPOPT_NOP << 24) |\n\t\t\t\t\t  (TCPOPT_NOP << 16) |\n\t\t\t\t\t  (TCPOPT_MD5SIG << 8) |\n\t\t\t\t\t  TCPOLEN_MD5SIG);\n\t\targ.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;\n\t\trep.th.doff = arg.iov[0].iov_len/4;\n\n\t\ttcp_v4_md5_hash_hdr((__u8 *) &rep.opt[offset],\n\t\t\t\t    key, ip_hdr(skb)->saddr,\n\t\t\t\t    ip_hdr(skb)->daddr, &rep.th);\n\t}\n#endif\n\targ.flags = reply_flags;\n\targ.csum = csum_tcpudp_nofold(ip_hdr(skb)->daddr,\n\t\t\t\t      ip_hdr(skb)->saddr, /* XXX */\n\t\t\t\t      arg.iov[0].iov_len, IPPROTO_TCP, 0);\n\targ.csumoffset = offsetof(struct tcphdr, check) / 2;\n\tif (oif)\n\t\targ.bound_dev_if = oif;\n\targ.tos = tos;\n\tlocal_bh_disable();\n\tip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),\n\t\t\t      skb, &TCP_SKB_CB(skb)->header.h4.opt,\n\t\t\t      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,\n\t\t\t      &arg, arg.iov[0].iov_len);\n\n\t__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\tlocal_bh_enable();\n}\n\nstatic void tcp_v4_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v4_send_ack(sock_net(sk), skb,\n\t\t\ttcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent,\n\t\t\ttw->tw_bound_dev_if,\n\t\t\ttcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_transparent ? IP_REPLY_ARG_NOSRCCHECK : 0,\n\t\t\ttw->tw_tos\n\t\t\t);\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v4_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\tu32 seq = (sk->sk_state == TCP_LISTEN) ? tcp_rsk(req)->snt_isn + 1 :\n\t\t\t\t\t     tcp_sk(sk)->snd_nxt;\n\n\t/* RFC 7323 2.3\n\t * The window field (SEG.WND) of every outgoing segment, with the\n\t * exception of <SYN> segments, MUST be right-shifted by\n\t * Rcv.Wind.Shift bits:\n\t */\n\ttcp_v4_send_ack(sock_net(sk), skb, seq,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp,\n\t\t\treq->ts_recent,\n\t\t\t0,\n\t\t\ttcp_md5_do_lookup(sk, (union tcp_md5_addr *)&ip_hdr(skb)->daddr,\n\t\t\t\t\t  AF_INET),\n\t\t\tinet_rsk(req)->no_srccheck ? IP_REPLY_ARG_NOSRCCHECK : 0,\n\t\t\tip_hdr(skb)->tos);\n}\n\n/*\n *\tSend a SYN-ACK after having received a SYN.\n *\tThis still operates on a request_sock only, not on a big\n *\tsocket.\n */\nstatic int tcp_v4_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct flowi4 fl4;\n\tint err = -1;\n\tstruct sk_buff *skb;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet_csk_route_req(sk, &fl4, req)) == NULL)\n\t\treturn -1;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v4_send_check(skb, ireq->ir_loc_addr, ireq->ir_rmt_addr);\n\n\t\terr = ip_build_and_send_pkt(skb, sk, ireq->ir_loc_addr,\n\t\t\t\t\t    ireq->ir_rmt_addr,\n\t\t\t\t\t    ireq->opt);\n\t\terr = net_xmit_eval(err);\n\t}\n\n\treturn err;\n}\n\n/*\n *\tIPv4 request_sock destructor.\n */\nstatic void tcp_v4_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->opt);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\n/*\n * RFC2385 MD5 checksumming requires a mapping of\n * IP address->MD5 Key.\n * We need to maintain these in the sk structure.\n */\n\n/* Find the Key structure for an address.  */\nstruct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_key *key;\n\tunsigned int size = sizeof(struct in_addr);\n\tconst struct tcp_md5sig_info *md5sig;\n\n\t/* caller either holds rcu_read_lock() or socket lock */\n\tmd5sig = rcu_dereference_check(tp->md5sig_info,\n\t\t\t\t       lockdep_sock_is_held(sk));\n\tif (!md5sig)\n\t\treturn NULL;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (family == AF_INET6)\n\t\tsize = sizeof(struct in6_addr);\n#endif\n\thlist_for_each_entry_rcu(key, &md5sig->head, node) {\n\t\tif (key->family != family)\n\t\t\tcontinue;\n\t\tif (!memcmp(&key->addr, addr, size))\n\t\t\treturn key;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_md5_do_lookup);\n\nstruct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,\n\t\t\t\t\t const struct sock *addr_sk)\n{\n\tconst union tcp_md5_addr *addr;\n\n\taddr = (const union tcp_md5_addr *)&addr_sk->sk_daddr;\n\treturn tcp_md5_do_lookup(sk, addr, AF_INET);\n}\nEXPORT_SYMBOL(tcp_v4_md5_lookup);\n\n/* This can be called on a newly created socket, from other files */\nint tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family, const u8 *newkey, u8 newkeylen, gfp_t gfp)\n{\n\t/* Add Key to the list */\n\tstruct tcp_md5sig_key *key;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_info *md5sig;\n\n\tkey = tcp_md5_do_lookup(sk, addr, family);\n\tif (key) {\n\t\t/* Pre-existing entry - just update that one. */\n\t\tmemcpy(key->key, newkey, newkeylen);\n\t\tkey->keylen = newkeylen;\n\t\treturn 0;\n\t}\n\n\tmd5sig = rcu_dereference_protected(tp->md5sig_info,\n\t\t\t\t\t   lockdep_sock_is_held(sk));\n\tif (!md5sig) {\n\t\tmd5sig = kmalloc(sizeof(*md5sig), gfp);\n\t\tif (!md5sig)\n\t\t\treturn -ENOMEM;\n\n\t\tsk_nocaps_add(sk, NETIF_F_GSO_MASK);\n\t\tINIT_HLIST_HEAD(&md5sig->head);\n\t\trcu_assign_pointer(tp->md5sig_info, md5sig);\n\t}\n\n\tkey = sock_kmalloc(sk, sizeof(*key), gfp);\n\tif (!key)\n\t\treturn -ENOMEM;\n\tif (!tcp_alloc_md5sig_pool()) {\n\t\tsock_kfree_s(sk, key, sizeof(*key));\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(key->key, newkey, newkeylen);\n\tkey->keylen = newkeylen;\n\tkey->family = family;\n\tmemcpy(&key->addr, addr,\n\t       (family == AF_INET6) ? sizeof(struct in6_addr) :\n\t\t\t\t      sizeof(struct in_addr));\n\thlist_add_head_rcu(&key->node, &md5sig->head);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_md5_do_add);\n\nint tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr, int family)\n{\n\tstruct tcp_md5sig_key *key;\n\n\tkey = tcp_md5_do_lookup(sk, addr, family);\n\tif (!key)\n\t\treturn -ENOENT;\n\thlist_del_rcu(&key->node);\n\tatomic_sub(sizeof(*key), &sk->sk_omem_alloc);\n\tkfree_rcu(key, rcu);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_md5_do_del);\n\nstatic void tcp_clear_md5_list(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_key *key;\n\tstruct hlist_node *n;\n\tstruct tcp_md5sig_info *md5sig;\n\n\tmd5sig = rcu_dereference_protected(tp->md5sig_info, 1);\n\n\thlist_for_each_entry_safe(key, n, &md5sig->head, node) {\n\t\thlist_del_rcu(&key->node);\n\t\tatomic_sub(sizeof(*key), &sk->sk_omem_alloc);\n\t\tkfree_rcu(key, rcu);\n\t}\n}\n\nstatic int tcp_v4_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen)\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin->sin_addr.s_addr,\n\t\t\t\t      AF_INET);\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin->sin_addr.s_addr,\n\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen,\n\t\t\t      GFP_KERNEL);\n}\n\nstatic int tcp_v4_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   __be32 daddr, __be32 saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp4_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\tbp->saddr = saddr;\n\tbp->daddr = daddr;\n\tbp->pad = 0;\n\tbp->protocol = IPPROTO_TCP;\n\tbp->len = cpu_to_be16(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       __be32 daddr, __be32 saddr, const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v4_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nint tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\tconst struct sock *sk,\n\t\t\tconst struct sk_buff *skb)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__be32 saddr, daddr;\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = sk->sk_rcv_saddr;\n\t\tdaddr = sk->sk_daddr;\n\t} else {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\t\tsaddr = iph->saddr;\n\t\tdaddr = iph->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v4_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\nEXPORT_SYMBOL(tcp_v4_md5_hash_skb);\n\n#endif\n\n/* Called with rcu_read_lock() */\nstatic bool tcp_v4_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\t/*\n\t * This gets called for each TCP segment that arrives\n\t * so we want to be efficient.\n\t * We have 3 drop cases:\n\t * o No MD5 hash and one expected.\n\t * o MD5 hash and we're not expecting one.\n\t * o MD5 hash and its wrong.\n\t */\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tunsigned char newhash[16];\n\n\thash_expected = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&iph->saddr,\n\t\t\t\t\t  AF_INET);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* Okay, so this is hash_expected and hash_location -\n\t * so we need to calculate the checksum.\n\t */\n\tgenhash = tcp_v4_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);\n\t\tnet_info_ratelimited(\"MD5 Hash failed for (%pI4, %d)->(%pI4, %d)%s\\n\",\n\t\t\t\t     &iph->saddr, ntohs(th->source),\n\t\t\t\t     &iph->daddr, ntohs(th->dest),\n\t\t\t\t     genhash ? \" tcp_v4_calc_md5_hash failed\"\n\t\t\t\t     : \"\");\n\t\treturn true;\n\t}\n\treturn false;\n#endif\n\treturn false;\n}\n\nstatic void tcp_v4_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\tsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\n\tsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\n\tireq->opt = tcp_v4_save_options(skb);\n}\n\nstatic struct dst_entry *tcp_v4_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req,\n\t\t\t\t\t  bool *strict)\n{\n\tstruct dst_entry *dst = inet_csk_route_req(sk, &fl->u.ip4, req);\n\n\tif (strict) {\n\t\tif (fl->u.ip4.daddr == inet_rsk(req)->ir_rmt_addr)\n\t\t\t*strict = true;\n\t\telse\n\t\t\t*strict = false;\n\t}\n\n\treturn dst;\n}\n\nstruct request_sock_ops tcp_request_sock_ops __read_mostly = {\n\t.family\t\t=\tPF_INET,\n\t.obj_size\t=\tsizeof(struct tcp_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v4_reqsk_send_ack,\n\t.destructor\t=\ttcp_v4_reqsk_destructor,\n\t.send_reset\t=\ttcp_v4_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv4_ops = {\n\t.mss_clamp\t=\tTCP_MSS_DEFAULT,\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v4_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v4_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v4_route_req,\n\t.init_seq\t=\ttcp_v4_init_sequence,\n\t.send_synack\t=\ttcp_v4_send_synack,\n};\n\nint tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\t/* Never answer to SYNs send to broadcast or multicast */\n\tif (skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv4_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_v4_conn_request);\n\n\n/*\n * The three way handshake has completed - we got a valid synack -\n * now create the new socket.\n */\nstruct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t  bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct ip_options_rcu *inet_opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto exit_nonewsk;\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV4;\n\tinet_sk_rx_dst_set(newsk, skb);\n\n\tnewtp\t\t      = tcp_sk(newsk);\n\tnewinet\t\t      = inet_sk(newsk);\n\tireq\t\t      = inet_rsk(req);\n\tsk_daddr_set(newsk, ireq->ir_rmt_addr);\n\tsk_rcv_saddr_set(newsk, ireq->ir_loc_addr);\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\tnewinet->inet_saddr\t      = ireq->ir_loc_addr;\n\tinet_opt\t      = ireq->opt;\n\trcu_assign_pointer(newinet->inet_opt, inet_opt);\n\tireq->opt\t      = NULL;\n\tnewinet->mc_index     = inet_iif(skb);\n\tnewinet->mc_ttl\t      = ip_hdr(skb)->ttl;\n\tnewinet->rcv_tos      = ip_hdr(skb)->tos;\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\tnewinet->inet_id = newtp->write_seq ^ jiffies;\n\n\tif (!dst) {\n\t\tdst = inet_csk_route_child_sock(sk, newsk, req);\n\t\tif (!dst)\n\t\t\tgoto put_and_exit;\n\t} else {\n\t\t/* syncookie case : see end of cookie_v4_check() */\n\t}\n\tsk_setup_caps(newsk, dst);\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&newinet->inet_daddr,\n\t\t\t\tAF_INET);\n\tif (key) {\n\t\t/*\n\t\t * We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newinet->inet_daddr,\n\t\t\t       AF_INET, key->key, key->keylen, GFP_ATOMIC);\n\t\tsk_nocaps_add(newsk, NETIF_F_GSO_MASK);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0)\n\t\tgoto put_and_exit;\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req)\n\t\ttcp_move_syn(newtp, req);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\ttcp_listendrop(sk);\n\treturn NULL;\nput_and_exit:\n\tinet_csk_prepare_forced_close(newsk);\n\ttcp_done(newsk);\n\tgoto exit;\n}\nEXPORT_SYMBOL(tcp_v4_syn_recv_sock);\n\nstatic struct sock *tcp_v4_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v4_check(sk, skb);\n#endif\n\treturn sk;\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nint tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sock *rsk;\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    !dst->ops->check(dst, 0)) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v4_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb)) {\n\t\t\t\trsk = nsk;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb)) {\n\t\trsk = sk;\n\t\tgoto reset;\n\t}\n\treturn 0;\n\nreset:\n\ttcp_v4_send_reset(rsk, skb);\ndiscard:\n\tkfree_skb(skb);\n\t/* Be careful here. If this function gets more complicated and\n\t * gcc suffers from register pressure on the x86, sk (in %ebx)\n\t * might be destroyed here. This current version compiles correctly,\n\t * but you have been warned.\n\t */\n\treturn 0;\n\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n}\nEXPORT_SYMBOL(tcp_v4_do_rcv);\n\nvoid tcp_v4_early_demux(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\tiph = ip_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\tsk = __inet_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t       iph->saddr, th->source,\n\t\t\t\t       iph->daddr, ntohs(th->dest),\n\t\t\t\t       skb->skb_iif);\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, 0);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\n/* Packet is added to VJ-style prequeue for processing in process\n * context, if a reader task is waiting. Apparently, this exciting\n * idea (VJ's mail \"Re: query about TCP header on tcp-ip\" of 07 Sep 93)\n * failed somewhere. Latency? Burstiness? Well, at least now we will\n * see, why it failed. 8)8)\t\t\t\t  --ANK\n *\n */\nbool tcp_prequeue(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (sysctl_tcp_low_latency || !tp->ucopy.task)\n\t\treturn false;\n\n\tif (skb->len <= tcp_hdrlen(skb) &&\n\t    skb_queue_len(&tp->ucopy.prequeue) == 0)\n\t\treturn false;\n\n\t/* Before escaping RCU protected region, we need to take care of skb\n\t * dst. Prequeue is only enabled for established sockets.\n\t * For such sockets, we might need the skb dst only to set sk->sk_rx_dst\n\t * Instead of doing full sk_rx_dst validity here, let's perform\n\t * an optimistic check.\n\t */\n\tif (likely(sk->sk_rx_dst))\n\t\tskb_dst_drop(skb);\n\telse\n\t\tskb_dst_force_safe(skb);\n\n\t__skb_queue_tail(&tp->ucopy.prequeue, skb);\n\ttp->ucopy.memory += skb->truesize;\n\tif (skb_queue_len(&tp->ucopy.prequeue) >= 32 ||\n\t    tp->ucopy.memory + atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf) {\n\t\tstruct sk_buff *skb1;\n\n\t\tBUG_ON(sock_owned_by_user(sk));\n\t\t__NET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPPREQUEUEDROPPED,\n\t\t\t\tskb_queue_len(&tp->ucopy.prequeue));\n\n\t\twhile ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)\n\t\t\tsk_backlog_rcv(sk, skb1);\n\n\t\ttp->ucopy.memory = 0;\n\t} else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {\n\t\twake_up_interruptible_sync_poll(sk_sleep(sk),\n\t\t\t\t\t   POLLIN | POLLRDNORM | POLLRDBAND);\n\t\tif (!inet_csk_ack_scheduled(sk))\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,\n\t\t\t\t\t\t  (3 * tcp_rto_min(sk)) / 4,\n\t\t\t\t\t\t  TCP_RTO_MAX);\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(tcp_prequeue);\n\nbool tcp_add_backlog(struct sock *sk, struct sk_buff *skb)\n{\n\tu32 limit = sk->sk_rcvbuf + sk->sk_sndbuf;\n\n\t/* Only socket owner can try to collapse/prune rx queues\n\t * to reduce memory overhead, so add a little headroom here.\n\t * Few sockets backlog are possibly concurrently non empty.\n\t */\n\tlimit += 64*1024;\n\n\t/* In case all data was pulled from skb frags (in __pskb_pull_tail()),\n\t * we can fix skb->truesize to its real value to avoid future drops.\n\t * This is valid because skb is not yet charged to the socket.\n\t * It has been noticed pure SACK packets were sometimes dropped\n\t * (if cooked by drivers without copybreak feature).\n\t */\n\tif (!skb->data_len)\n\t\tskb->truesize = SKB_TRUESIZE(skb_end_offset(skb));\n\n\tif (unlikely(sk_add_backlog(sk, skb, limit))) {\n\t\tbh_unlock_sock(sk);\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPBACKLOGDROP);\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(tcp_add_backlog);\n\n/*\n *\tFrom tcp_input.c\n */\n\nint tcp_v4_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/* Count it even if it's bad */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff * 4))\n\t\tgoto discard_it;\n\n\t/* An explanation is required here, I think.\n\t * Packet length and doff are validated by header prediction,\n\t * provided case of th->doff==0 is eliminated.\n\t * So, we defer the checks. */\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\t/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()\n\t * barrier() makes sure compiler wont play fool^Waliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\n\t\tsizeof(struct inet_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff * 4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\n\tTCP_SKB_CB(skb)->sacked\t = 0;\n\nlookup:\n\tsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\n\t\t\t       th->dest, &refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\t/* We own a reference on the listener, increase it again\n\t\t * as we might lose it too soon.\n\t\t */\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v4_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_v4_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tnf_reset(skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v4_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v4_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\n\treturn ret;\n\nno_tcp_socket:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v4_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\t/* Discard frame. */\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN: {\n\t\tstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n\t\t\t\t\t\t\t&tcp_hashinfo, skb,\n\t\t\t\t\t\t\t__tcp_hdrlen(th),\n\t\t\t\t\t\t\tiph->saddr, th->source,\n\t\t\t\t\t\t\tiph->daddr, th->dest,\n\t\t\t\t\t\t\tinet_iif(skb));\n\t\tif (sk2) {\n\t\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v4_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v4_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:;\n\t}\n\tgoto discard_it;\n}\n\nstatic struct timewait_sock_ops tcp_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor= tcp_twsk_destructor,\n};\n\nvoid inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t}\n}\nEXPORT_SYMBOL(inet_sk_rx_dst_set);\n\nconst struct inet_connection_sock_af_ops ipv4_specific = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v4_conn_request,\n\t.syn_recv_sock\t   = tcp_v4_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.addr2sockaddr\t   = inet_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in),\n\t.bind_conflict\t   = inet_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ip_setsockopt,\n\t.compat_getsockopt = compat_ip_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\nEXPORT_SYMBOL(ipv4_specific);\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv4_specific = {\n\t.md5_lookup\t\t= tcp_v4_md5_lookup,\n\t.calc_md5_hash\t\t= tcp_v4_md5_hash_skb,\n\t.md5_parse\t\t= tcp_v4_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v4_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv4_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv4_specific;\n#endif\n\n\treturn 0;\n}\n\nvoid tcp_v4_destroy_sock(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_clear_xmit_timers(sk);\n\n\ttcp_cleanup_congestion_control(sk);\n\n\t/* Cleanup up the write buffer. */\n\ttcp_write_queue_purge(sk);\n\n\t/* Cleans up our, hopefully empty, out_of_order_queue. */\n\tskb_rbtree_purge(&tp->out_of_order_queue);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Clean up the MD5 key list, if any */\n\tif (tp->md5sig_info) {\n\t\ttcp_clear_md5_list(sk);\n\t\tkfree_rcu(tp->md5sig_info, rcu);\n\t\ttp->md5sig_info = NULL;\n\t}\n#endif\n\n\t/* Clean prequeue, it must be empty really */\n\t__skb_queue_purge(&tp->ucopy.prequeue);\n\n\t/* Clean up a referenced TCP bind bucket. */\n\tif (inet_csk(sk)->icsk_bind_hash)\n\t\tinet_put_port(sk);\n\n\tBUG_ON(tp->fastopen_rsk);\n\n\t/* If socket is aborted during connect operation */\n\ttcp_free_fastopen_req(tp);\n\ttcp_saved_syn_free(tp);\n\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tlocal_bh_enable();\n}\nEXPORT_SYMBOL(tcp_v4_destroy_sock);\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCP sock list dumping. */\n\n/*\n * Get next listener socket follow cur.  If cur is NULL, get first socket\n * starting from bucket given in st->bucket; when st->bucket is zero the\n * very first socket in the hash table is returned.\n */\nstatic void *listening_get_next(struct seq_file *seq, void *cur)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct inet_listen_hashbucket *ilb;\n\tstruct sock *sk = cur;\n\n\tif (!sk) {\nget_head:\n\t\tilb = &tcp_hashinfo.listening_hash[st->bucket];\n\t\tspin_lock_bh(&ilb->lock);\n\t\tsk = sk_head(&ilb->head);\n\t\tst->offset = 0;\n\t\tgoto get_sk;\n\t}\n\tilb = &tcp_hashinfo.listening_hash[st->bucket];\n\t++st->num;\n\t++st->offset;\n\n\tsk = sk_next(sk);\nget_sk:\n\tsk_for_each_from(sk) {\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\t\tif (sk->sk_family == st->family)\n\t\t\treturn sk;\n\t}\n\tspin_unlock_bh(&ilb->lock);\n\tst->offset = 0;\n\tif (++st->bucket < INET_LHTABLE_SIZE)\n\t\tgoto get_head;\n\treturn NULL;\n}\n\nstatic void *listening_get_idx(struct seq_file *seq, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc;\n\n\tst->bucket = 0;\n\tst->offset = 0;\n\trc = listening_get_next(seq, NULL);\n\n\twhile (rc && *pos) {\n\t\trc = listening_get_next(seq, rc);\n\t\t--*pos;\n\t}\n\treturn rc;\n}\n\nstatic inline bool empty_bucket(const struct tcp_iter_state *st)\n{\n\treturn hlist_nulls_empty(&tcp_hashinfo.ehash[st->bucket].chain);\n}\n\n/*\n * Get first established socket starting from bucket given in st->bucket.\n * If st->bucket is zero, the very first socket in the hash is returned.\n */\nstatic void *established_get_first(struct seq_file *seq)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tvoid *rc = NULL;\n\n\tst->offset = 0;\n\tfor (; st->bucket <= tcp_hashinfo.ehash_mask; ++st->bucket) {\n\t\tstruct sock *sk;\n\t\tstruct hlist_nulls_node *node;\n\t\tspinlock_t *lock = inet_ehash_lockp(&tcp_hashinfo, st->bucket);\n\n\t\t/* Lockless fast path for the common case of empty buckets */\n\t\tif (empty_bucket(st))\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(lock);\n\t\tsk_nulls_for_each(sk, node, &tcp_hashinfo.ehash[st->bucket].chain) {\n\t\t\tif (sk->sk_family != st->family ||\n\t\t\t    !net_eq(sock_net(sk), net)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trc = sk;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock_bh(lock);\n\t}\nout:\n\treturn rc;\n}\n\nstatic void *established_get_next(struct seq_file *seq, void *cur)\n{\n\tstruct sock *sk = cur;\n\tstruct hlist_nulls_node *node;\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\t++st->num;\n\t++st->offset;\n\n\tsk = sk_nulls_next(sk);\n\n\tsk_nulls_for_each_from(sk, node) {\n\t\tif (sk->sk_family == st->family && net_eq(sock_net(sk), net))\n\t\t\treturn sk;\n\t}\n\n\tspin_unlock_bh(inet_ehash_lockp(&tcp_hashinfo, st->bucket));\n\t++st->bucket;\n\treturn established_get_first(seq);\n}\n\nstatic void *established_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc;\n\n\tst->bucket = 0;\n\trc = established_get_first(seq);\n\n\twhile (rc && pos) {\n\t\trc = established_get_next(seq, rc);\n\t\t--pos;\n\t}\n\treturn rc;\n}\n\nstatic void *tcp_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tvoid *rc;\n\tstruct tcp_iter_state *st = seq->private;\n\n\tst->state = TCP_SEQ_STATE_LISTENING;\n\trc\t  = listening_get_idx(seq, &pos);\n\n\tif (!rc) {\n\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\trc\t  = established_get_idx(seq, pos);\n\t}\n\n\treturn rc;\n}\n\nstatic void *tcp_seek_last_pos(struct seq_file *seq)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tint offset = st->offset;\n\tint orig_num = st->num;\n\tvoid *rc = NULL;\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\tif (st->bucket >= INET_LHTABLE_SIZE)\n\t\t\tbreak;\n\t\tst->state = TCP_SEQ_STATE_LISTENING;\n\t\trc = listening_get_next(seq, NULL);\n\t\twhile (offset-- && rc)\n\t\t\trc = listening_get_next(seq, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tst->bucket = 0;\n\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\t/* Fallthrough */\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\tif (st->bucket > tcp_hashinfo.ehash_mask)\n\t\t\tbreak;\n\t\trc = established_get_first(seq);\n\t\twhile (offset-- && rc)\n\t\t\trc = established_get_next(seq, rc);\n\t}\n\n\tst->num = orig_num;\n\n\treturn rc;\n}\n\nstatic void *tcp_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc;\n\n\tif (*pos && *pos == st->last_pos) {\n\t\trc = tcp_seek_last_pos(seq);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tst->state = TCP_SEQ_STATE_LISTENING;\n\tst->num = 0;\n\tst->bucket = 0;\n\tst->offset = 0;\n\trc = *pos ? tcp_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n\nout:\n\tst->last_pos = *pos;\n\treturn rc;\n}\n\nstatic void *tcp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc = NULL;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\trc = tcp_get_idx(seq, 0);\n\t\tgoto out;\n\t}\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\trc = listening_get_next(seq, v);\n\t\tif (!rc) {\n\t\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\t\tst->bucket = 0;\n\t\t\tst->offset = 0;\n\t\t\trc\t  = established_get_first(seq);\n\t\t}\n\t\tbreak;\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\trc = established_get_next(seq, v);\n\t\tbreak;\n\t}\nout:\n\t++*pos;\n\tst->last_pos = *pos;\n\treturn rc;\n}\n\nstatic void tcp_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\tif (v != SEQ_START_TOKEN)\n\t\t\tspin_unlock_bh(&tcp_hashinfo.listening_hash[st->bucket].lock);\n\t\tbreak;\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\tif (v)\n\t\t\tspin_unlock_bh(inet_ehash_lockp(&tcp_hashinfo, st->bucket));\n\t\tbreak;\n\t}\n}\n\nint tcp_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct tcp_seq_afinfo *afinfo = PDE_DATA(inode);\n\tstruct tcp_iter_state *s;\n\tint err;\n\n\terr = seq_open_net(inode, file, &afinfo->seq_ops,\n\t\t\t  sizeof(struct tcp_iter_state));\n\tif (err < 0)\n\t\treturn err;\n\n\ts = ((struct seq_file *)file->private_data)->private;\n\ts->family\t\t= afinfo->family;\n\ts->last_pos\t\t= 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_seq_open);\n\nint tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo)\n{\n\tint rc = 0;\n\tstruct proc_dir_entry *p;\n\n\tafinfo->seq_ops.start\t\t= tcp_seq_start;\n\tafinfo->seq_ops.next\t\t= tcp_seq_next;\n\tafinfo->seq_ops.stop\t\t= tcp_seq_stop;\n\n\tp = proc_create_data(afinfo->name, S_IRUGO, net->proc_net,\n\t\t\t     afinfo->seq_fops, afinfo);\n\tif (!p)\n\t\trc = -ENOMEM;\n\treturn rc;\n}\nEXPORT_SYMBOL(tcp_proc_register);\n\nvoid tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo)\n{\n\tremove_proc_entry(afinfo->name, net->proc_net);\n}\nEXPORT_SYMBOL(tcp_proc_unregister);\n\nstatic void get_openreq4(const struct request_sock *req,\n\t\t\t struct seq_file *f, int i)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tlong delta = req->rsk_timer.expires - jiffies;\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %u %d %pK\",\n\t\ti,\n\t\tireq->ir_loc_addr,\n\t\tireq->ir_num,\n\t\tireq->ir_rmt_addr,\n\t\tntohs(ireq->ir_rmt_port),\n\t\tTCP_SYN_RECV,\n\t\t0, 0, /* could print option size, but that is af dependent. */\n\t\t1,    /* timers active (only the expire timer) */\n\t\tjiffies_delta_to_clock_t(delta),\n\t\treq->num_timeout,\n\t\tfrom_kuid_munged(seq_user_ns(f),\n\t\t\t\t sock_i_uid(req->rsk_listener)),\n\t\t0,  /* non standard timer */\n\t\t0, /* open_requests have no inode */\n\t\t0,\n\t\treq);\n}\n\nstatic void get_tcp4_sock(struct sock *sk, struct seq_file *f, int i)\n{\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src = inet->inet_rcv_saddr;\n\t__u16 destp = ntohs(inet->inet_dport);\n\t__u16 srcp = ntohs(inet->inet_sport);\n\tint rx_queue;\n\tint state;\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sk->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sk->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sk);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sk->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X %02X %08X:%08X %02X:%08lX \"\n\t\t\t\"%08X %5u %8d %lu %d %pK %lu %lu %u %u %d\",\n\t\ti, src, srcp, dest, destp, state,\n\t\ttp->write_seq - tp->snd_una,\n\t\trx_queue,\n\t\ttimer_active,\n\t\tjiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\ticsk->icsk_retransmits,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sk)),\n\t\ticsk->icsk_probes_out,\n\t\tsock_i_ino(sk),\n\t\tatomic_read(&sk->sk_refcnt), sk,\n\t\tjiffies_to_clock_t(icsk->icsk_rto),\n\t\tjiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t(icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\ttp->snd_cwnd,\n\t\tstate == TCP_LISTEN ?\n\t\t    fastopenq->max_qlen :\n\t\t    (tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh));\n}\n\nstatic void get_timewait4_sock(const struct inet_timewait_sock *tw,\n\t\t\t       struct seq_file *f, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\t__be32 dest, src;\n\t__u16 destp, srcp;\n\n\tdest  = tw->tw_daddr;\n\tsrc   = tw->tw_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\",\n\t\ti, src, srcp, dest, destp, tw->tw_substate, 0, 0,\n\t\t3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\tatomic_read(&tw->tw_refcnt), tw);\n}\n\n#define TMPSZ 150\n\nstatic int tcp4_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tseq_setwidth(seq, TMPSZ - 1);\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t   \"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t   \"inode\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait4_sock(v, seq, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq4(v, seq, st->num);\n\telse\n\t\tget_tcp4_sock(v, seq, st->num);\nout:\n\tseq_pad(seq, '\\n');\n\treturn 0;\n}\n\nstatic const struct file_operations tcp_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp4_seq_afinfo = {\n\t.name\t\t= \"tcp\",\n\t.family\t\t= AF_INET,\n\t.seq_fops\t= &tcp_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp4_seq_show,\n\t},\n};\n\nstatic int __net_init tcp4_proc_init_net(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp4_seq_afinfo);\n}\n\nstatic void __net_exit tcp4_proc_exit_net(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp4_seq_afinfo);\n}\n\nstatic struct pernet_operations tcp4_net_ops = {\n\t.init = tcp4_proc_init_net,\n\t.exit = tcp4_proc_exit_net,\n};\n\nint __init tcp4_proc_init(void)\n{\n\treturn register_pernet_subsys(&tcp4_net_ops);\n}\n\nvoid tcp4_proc_exit(void)\n{\n\tunregister_pernet_subsys(&tcp4_net_ops);\n}\n#endif /* CONFIG_PROC_FS */\n\nstruct proto tcp_prot = {\n\t.name\t\t\t= \"TCP\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v4_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v4_init_sock,\n\t.destroy\t\t= tcp_v4_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v4_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n\t.diag_destroy\t\t= tcp_abort,\n};\nEXPORT_SYMBOL(tcp_prot);\n\nstatic void __net_exit tcp_sk_exit(struct net *net)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinet_ctl_sock_destroy(*per_cpu_ptr(net->ipv4.tcp_sk, cpu));\n\tfree_percpu(net->ipv4.tcp_sk);\n}\n\nstatic int __net_init tcp_sk_init(struct net *net)\n{\n\tint res, cpu;\n\n\tnet->ipv4.tcp_sk = alloc_percpu(struct sock *);\n\tif (!net->ipv4.tcp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct sock *sk;\n\n\t\tres = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,\n\t\t\t\t\t   IPPROTO_TCP, net);\n\t\tif (res)\n\t\t\tgoto fail;\n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\t\t*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;\n\t}\n\n\tnet->ipv4.sysctl_tcp_ecn = 2;\n\tnet->ipv4.sysctl_tcp_ecn_fallback = 1;\n\n\tnet->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;\n\tnet->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;\n\tnet->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;\n\n\tnet->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;\n\tnet->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;\n\tnet->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;\n\n\tnet->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;\n\tnet->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;\n\tnet->ipv4.sysctl_tcp_syncookies = 1;\n\tnet->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;\n\tnet->ipv4.sysctl_tcp_retries1 = TCP_RETR1;\n\tnet->ipv4.sysctl_tcp_retries2 = TCP_RETR2;\n\tnet->ipv4.sysctl_tcp_orphan_retries = 0;\n\tnet->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;\n\tnet->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;\n\n\treturn 0;\nfail:\n\ttcp_sk_exit(net);\n\n\treturn res;\n}\n\nstatic void __net_exit tcp_sk_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET);\n}\n\nstatic struct pernet_operations __net_initdata tcp_sk_ops = {\n       .init\t   = tcp_sk_init,\n       .exit\t   = tcp_sk_exit,\n       .exit_batch = tcp_sk_exit_batch,\n};\n\nvoid __init tcp_v4_init(void)\n{\n\tinet_hashinfo_init(&tcp_hashinfo);\n\tif (register_pernet_subsys(&tcp_sk_ops))\n\t\tpanic(\"Failed to create the TCP control socket.\\n\");\n}\n", "/*\n *\tTCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on:\n *\tlinux/net/ipv4/tcp.c\n *\tlinux/net/ipv4/tcp_input.c\n *\tlinux/net/ipv4/tcp_output.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *\tYOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/tcp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nstatic int\ttcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t\tinet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic __u32 tcp_v6_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t    ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t    tcp_hdr(skb)->dest,\n\t\t\t\t\t    tcp_hdr(skb)->source);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t/*\n\t *\tconnect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 0x1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq = 0;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t *\tTCP over IPv4\n\t */\n\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &ipv6_mapped;\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &ipv6_specific;\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp &&\n\t    ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr))\n\t\ttcp_fetch_timewait_stamp(sk, dst);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n\t\t\t\t\t opt->opt_nflen;\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (!tp->write_seq && likely(!tp->repair))\n\t\ttp->write_seq = secure_tcpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t\t     sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t\t     inet->inet_sport,\n\t\t\t\t\t\t\t     inet->inet_dport);\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, tcp_sk(sk)->mtu_info);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq, fatal);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\tif (dst)\n\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &tp->tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, fl6, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn tcp_md5_do_lookup(sk, (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n}\n\nstatic int tcp_v6_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\t/* 1. TCP pseudo-header (RFC2460) */\n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic bool tcp_v6_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tu8 newhash[16];\n\n\thash_expected = tcp_v6_md5_do_lookup(sk, &ip6h->saddr);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* check the signature */\n\tgenhash = tcp_v6_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);\n\t\tnet_info_ratelimited(\"MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t\t     genhash ? \"failed\" : \"mismatch\",\n\t\t\t\t     &ip6h->saddr, ntohs(th->source),\n\t\t\t\t     &ip6h->daddr, ntohs(th->dest));\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req,\n\t\t\t\t\t  bool *strict)\n{\n\tif (strict)\n\t\t*strict = true;\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v6_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_sequence,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, __be32 label)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\tstruct dst_entry *dst;\n\t__be32 *topt;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\tbuff = alloc_skb(MAX_HEADER + sizeof(struct ipv6hdr) + tot_len,\n\t\t\t GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);\n\n\tt1 = (struct tcphdr *) skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t/* Swap the send and the receive. */\n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\tbuff->csum = 0;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse {\n\t\tif (!oif && netif_index_is_l3_master(net, skb->skb_iif))\n\t\t\toif = skb->skb_iif;\n\n\t\tfl6.flowi6_oif = oif;\n\t}\n\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\t/* Pass a socket to ip6_dst_lookup either it is for RST\n\t * Underlying function will use this to retrieve the network\n\t * namespace\n\t */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, NULL, tclass);\n\t\tTCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tint oif;\n\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tkey = tcp_v6_md5_do_lookup(sk, &ipv6h->saddr);\n\t} else if (hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = inet6_lookup_listener(dev_net(skb_dst(skb)->dev),\n\t\t\t\t\t   &tcp_hashinfo, NULL, 0,\n\t\t\t\t\t   &ipv6h->saddr,\n\t\t\t\t\t   th->source, &ipv6h->daddr,\n\t\t\t\t\t   ntohs(th->source), tcp_v6_iif(skb));\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\toif = sk ? sk->sk_bound_dev_if : 0;\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    __be32 label)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\t/* RFC 7323 2.3\n\t * The window field (SEG.WND) of every outgoing segment, with the\n\t * exception of <SYN> segments, MUST be right-shifted by\n\t * Rcv.Wind.Shift bits:\n\t */\n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),\n\t\t\t0, 0);\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0; /* don't send reset */\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_mask(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_mask(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\ttcp_listendrop(sk);\n\treturn NULL;\n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t/* We need to move header back to the beginning if xfrm6_policy_check()\n\t * and tcp_v6_fill_cb() are going to be called again.\n\t * ip6_datagram_recv_specific_ctl() also expects IP6CB to be there.\n\t */\n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t/* This is tricky: we move IP6CB at its correct location into\n\t * TCP_SKB_CB(). It must be done after xfrm6_policy_check(), because\n\t * _decode_session6() uses IP6CB().\n\t * barrier() makes sure compiler won't play aliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n}\n\nstatic int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr)/4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb),\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nstatic void tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t/* Note : We use inet6_iif() here, not tcp_v6_iif() */\n\tsk = __inet6_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nstatic const struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/*\n *\tTCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\nstatic void tcp_v6_destroy_sock(struct sock *sk)\n{\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCPv6 sock list dumping. */\nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0, /* could print option size, but that is af dependent. */\n\t\t   1,   /* timers active (only the expire timer) */\n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,  /* non standard timer */\n\t\t   0, /* open_requests have no inode */\n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sp->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   tp->write_seq - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\t   tp->snd_cwnd,\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct file_operations tcp6_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.name\t\t= \"tcp6\",\n\t.family\t\t= AF_INET6,\n\t.seq_fops\t= &tcp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp6_seq_show,\n\t},\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp6_seq_afinfo);\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}\n#endif\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v6_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet6_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n\t.diag_destroy\t\t= tcp_abort,\n};\n\nstatic const struct inet6_protocol tcpv6_protocol = {\n\t.early_demux\t=\ttcp_v6_early_demux,\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the TCP module.\n *\n * Version:\t@(#)tcp.h\t1.0.5\t05/23/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n#ifndef _TCP_H\n#define _TCP_H\n\n#define FASTRETRANS_DEBUG 1\n\n#include <linux/list.h>\n#include <linux/tcp.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/cryptohash.h>\n#include <linux/kref.h>\n#include <linux/ktime.h>\n\n#include <net/inet_connection_sock.h>\n#include <net/inet_timewait_sock.h>\n#include <net/inet_hashtables.h>\n#include <net/checksum.h>\n#include <net/request_sock.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/tcp_states.h>\n#include <net/inet_ecn.h>\n#include <net/dst.h>\n\n#include <linux/seq_file.h>\n#include <linux/memcontrol.h>\n\nextern struct inet_hashinfo tcp_hashinfo;\n\nextern struct percpu_counter tcp_orphan_count;\nvoid tcp_time_wait(struct sock *sk, int state, int timeo);\n\n#define MAX_TCP_HEADER\t(128 + MAX_HEADER)\n#define MAX_TCP_OPTION_SPACE 40\n\n/*\n * Never offer a window over 32767 without using window scaling. Some\n * poor stacks do signed 16bit maths!\n */\n#define MAX_TCP_WINDOW\t\t32767U\n\n/* Minimal accepted MSS. It is (60+60+8) - (20+20). */\n#define TCP_MIN_MSS\t\t88U\n\n/* The least MTU to use for probing */\n#define TCP_BASE_MSS\t\t1024\n\n/* probing interval, default to 10 minutes as per RFC4821 */\n#define TCP_PROBE_INTERVAL\t600\n\n/* Specify interval when tcp mtu probing will stop */\n#define TCP_PROBE_THRESHOLD\t8\n\n/* After receiving this amount of duplicate ACKs fast retransmit starts. */\n#define TCP_FASTRETRANS_THRESH 3\n\n/* Maximal number of ACKs sent quickly to accelerate slow-start. */\n#define TCP_MAX_QUICKACKS\t16U\n\n/* urg_data states */\n#define TCP_URG_VALID\t0x0100\n#define TCP_URG_NOTYET\t0x0200\n#define TCP_URG_READ\t0x0400\n\n#define TCP_RETR1\t3\t/*\n\t\t\t\t * This is how many retries it does before it\n\t\t\t\t * tries to figure out if the gateway is\n\t\t\t\t * down. Minimal RFC value is 3; it corresponds\n\t\t\t\t * to ~3sec-8min depending on RTO.\n\t\t\t\t */\n\n#define TCP_RETR2\t15\t/*\n\t\t\t\t * This should take at least\n\t\t\t\t * 90 minutes to time out.\n\t\t\t\t * RFC1122 says that the limit is 100 sec.\n\t\t\t\t * 15 is ~13-30min depending on RTO.\n\t\t\t\t */\n\n#define TCP_SYN_RETRIES\t 6\t/* This is how many retries are done\n\t\t\t\t * when active opening a connection.\n\t\t\t\t * RFC1122 says the minimum retry MUST\n\t\t\t\t * be at least 180secs.  Nevertheless\n\t\t\t\t * this value is corresponding to\n\t\t\t\t * 63secs of retransmission with the\n\t\t\t\t * current initial RTO.\n\t\t\t\t */\n\n#define TCP_SYNACK_RETRIES 5\t/* This is how may retries are done\n\t\t\t\t * when passive opening a connection.\n\t\t\t\t * This is corresponding to 31secs of\n\t\t\t\t * retransmission with the current\n\t\t\t\t * initial RTO.\n\t\t\t\t */\n\n#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT\n\t\t\t\t  * state, about 60 seconds\t*/\n#define TCP_FIN_TIMEOUT\tTCP_TIMEWAIT_LEN\n                                 /* BSD style FIN_WAIT2 deadlock breaker.\n\t\t\t\t  * It used to be 3min, new value is 60sec,\n\t\t\t\t  * to combine FIN-WAIT-2 timeout with\n\t\t\t\t  * TIME-WAIT timer.\n\t\t\t\t  */\n\n#define TCP_DELACK_MAX\t((unsigned)(HZ/5))\t/* maximal time to delay before sending an ACK */\n#if HZ >= 100\n#define TCP_DELACK_MIN\t((unsigned)(HZ/25))\t/* minimal time to delay before sending an ACK */\n#define TCP_ATO_MIN\t((unsigned)(HZ/25))\n#else\n#define TCP_DELACK_MIN\t4U\n#define TCP_ATO_MIN\t4U\n#endif\n#define TCP_RTO_MAX\t((unsigned)(120*HZ))\n#define TCP_RTO_MIN\t((unsigned)(HZ/5))\n#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))\t/* RFC6298 2.1 initial RTO value\t*/\n#define TCP_TIMEOUT_FALLBACK ((unsigned)(3*HZ))\t/* RFC 1122 initial RTO value, now\n\t\t\t\t\t\t * used as a fallback RTO for the\n\t\t\t\t\t\t * initial data transmission if no\n\t\t\t\t\t\t * valid RTT sample has been acquired,\n\t\t\t\t\t\t * most likely due to retrans in 3WHS.\n\t\t\t\t\t\t */\n\n#define TCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ/2U)) /* Maximal interval between probes\n\t\t\t\t\t                 * for local resources.\n\t\t\t\t\t                 */\n\n#define TCP_KEEPALIVE_TIME\t(120*60*HZ)\t/* two hours */\n#define TCP_KEEPALIVE_PROBES\t9\t\t/* Max of 9 keepalive probes\t*/\n#define TCP_KEEPALIVE_INTVL\t(75*HZ)\n\n#define MAX_TCP_KEEPIDLE\t32767\n#define MAX_TCP_KEEPINTVL\t32767\n#define MAX_TCP_KEEPCNT\t\t127\n#define MAX_TCP_SYNCNT\t\t127\n\n#define TCP_SYNQ_INTERVAL\t(HZ/5)\t/* Period of SYNACK timer */\n\n#define TCP_PAWS_24DAYS\t(60 * 60 * 24 * 24)\n#define TCP_PAWS_MSL\t60\t\t/* Per-host timestamps are invalidated\n\t\t\t\t\t * after this time. It should be equal\n\t\t\t\t\t * (or greater than) TCP_TIMEWAIT_LEN\n\t\t\t\t\t * to provide reliability equal to one\n\t\t\t\t\t * provided by timewait state.\n\t\t\t\t\t */\n#define TCP_PAWS_WINDOW\t1\t\t/* Replay window for per-host\n\t\t\t\t\t * timestamps. It must be less than\n\t\t\t\t\t * minimal timewait lifetime.\n\t\t\t\t\t */\n/*\n *\tTCP option\n */\n\n#define TCPOPT_NOP\t\t1\t/* Padding */\n#define TCPOPT_EOL\t\t0\t/* End of options */\n#define TCPOPT_MSS\t\t2\t/* Segment size negotiating */\n#define TCPOPT_WINDOW\t\t3\t/* Window scaling */\n#define TCPOPT_SACK_PERM        4       /* SACK Permitted */\n#define TCPOPT_SACK             5       /* SACK Block */\n#define TCPOPT_TIMESTAMP\t8\t/* Better RTT estimations/PAWS */\n#define TCPOPT_MD5SIG\t\t19\t/* MD5 Signature (RFC2385) */\n#define TCPOPT_FASTOPEN\t\t34\t/* Fast open (RFC7413) */\n#define TCPOPT_EXP\t\t254\t/* Experimental */\n/* Magic number to be after the option value for sharing TCP\n * experimental options. See draft-ietf-tcpm-experimental-options-00.txt\n */\n#define TCPOPT_FASTOPEN_MAGIC\t0xF989\n\n/*\n *     TCP option lengths\n */\n\n#define TCPOLEN_MSS            4\n#define TCPOLEN_WINDOW         3\n#define TCPOLEN_SACK_PERM      2\n#define TCPOLEN_TIMESTAMP      10\n#define TCPOLEN_MD5SIG         18\n#define TCPOLEN_FASTOPEN_BASE  2\n#define TCPOLEN_EXP_FASTOPEN_BASE  4\n\n/* But this is what stacks really send out. */\n#define TCPOLEN_TSTAMP_ALIGNED\t\t12\n#define TCPOLEN_WSCALE_ALIGNED\t\t4\n#define TCPOLEN_SACKPERM_ALIGNED\t4\n#define TCPOLEN_SACK_BASE\t\t2\n#define TCPOLEN_SACK_BASE_ALIGNED\t4\n#define TCPOLEN_SACK_PERBLOCK\t\t8\n#define TCPOLEN_MD5SIG_ALIGNED\t\t20\n#define TCPOLEN_MSS_ALIGNED\t\t4\n\n/* Flags in tp->nonagle */\n#define TCP_NAGLE_OFF\t\t1\t/* Nagle's algo is disabled */\n#define TCP_NAGLE_CORK\t\t2\t/* Socket is corked\t    */\n#define TCP_NAGLE_PUSH\t\t4\t/* Cork is overridden for already queued data */\n\n/* TCP thin-stream limits */\n#define TCP_THIN_LINEAR_RETRIES 6       /* After 6 linear retries, do exp. backoff */\n\n/* TCP initial congestion window as per rfc6928 */\n#define TCP_INIT_CWND\t\t10\n\n/* Bit Flags for sysctl_tcp_fastopen */\n#define\tTFO_CLIENT_ENABLE\t1\n#define\tTFO_SERVER_ENABLE\t2\n#define\tTFO_CLIENT_NO_COOKIE\t4\t/* Data in SYN w/o cookie option */\n\n/* Accept SYN data w/o any cookie option */\n#define\tTFO_SERVER_COOKIE_NOT_REQD\t0x200\n\n/* Force enable TFO on all listeners, i.e., not requiring the\n * TCP_FASTOPEN socket option.\n */\n#define\tTFO_SERVER_WO_SOCKOPT1\t0x400\n\nextern struct inet_timewait_death_row tcp_death_row;\n\n/* sysctl variables for tcp */\nextern int sysctl_tcp_timestamps;\nextern int sysctl_tcp_window_scaling;\nextern int sysctl_tcp_sack;\nextern int sysctl_tcp_fastopen;\nextern int sysctl_tcp_retrans_collapse;\nextern int sysctl_tcp_stdurg;\nextern int sysctl_tcp_rfc1337;\nextern int sysctl_tcp_abort_on_overflow;\nextern int sysctl_tcp_max_orphans;\nextern int sysctl_tcp_fack;\nextern int sysctl_tcp_reordering;\nextern int sysctl_tcp_max_reordering;\nextern int sysctl_tcp_dsack;\nextern long sysctl_tcp_mem[3];\nextern int sysctl_tcp_wmem[3];\nextern int sysctl_tcp_rmem[3];\nextern int sysctl_tcp_app_win;\nextern int sysctl_tcp_adv_win_scale;\nextern int sysctl_tcp_tw_reuse;\nextern int sysctl_tcp_frto;\nextern int sysctl_tcp_low_latency;\nextern int sysctl_tcp_nometrics_save;\nextern int sysctl_tcp_moderate_rcvbuf;\nextern int sysctl_tcp_tso_win_divisor;\nextern int sysctl_tcp_workaround_signed_windows;\nextern int sysctl_tcp_slow_start_after_idle;\nextern int sysctl_tcp_thin_linear_timeouts;\nextern int sysctl_tcp_thin_dupack;\nextern int sysctl_tcp_early_retrans;\nextern int sysctl_tcp_limit_output_bytes;\nextern int sysctl_tcp_challenge_ack_limit;\nextern int sysctl_tcp_min_tso_segs;\nextern int sysctl_tcp_min_rtt_wlen;\nextern int sysctl_tcp_autocorking;\nextern int sysctl_tcp_invalid_ratelimit;\nextern int sysctl_tcp_pacing_ss_ratio;\nextern int sysctl_tcp_pacing_ca_ratio;\n\nextern atomic_long_t tcp_memory_allocated;\nextern struct percpu_counter tcp_sockets_allocated;\nextern int tcp_memory_pressure;\n\n/* optimized version of sk_under_memory_pressure() for TCP sockets */\nstatic inline bool tcp_under_memory_pressure(const struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled && sk->sk_memcg &&\n\t    mem_cgroup_under_socket_pressure(sk->sk_memcg))\n\t\treturn true;\n\n\treturn tcp_memory_pressure;\n}\n/*\n * The next routines deal with comparing 32 bit unsigned ints\n * and worry about wraparound (automatic with unsigned arithmetic).\n */\n\nstatic inline bool before(__u32 seq1, __u32 seq2)\n{\n        return (__s32)(seq1-seq2) < 0;\n}\n#define after(seq2, seq1) \tbefore(seq1, seq2)\n\n/* is s2<=s1<=s3 ? */\nstatic inline bool between(__u32 seq1, __u32 seq2, __u32 seq3)\n{\n\treturn seq3 - seq2 >= seq1 - seq2;\n}\n\nstatic inline bool tcp_out_of_memory(struct sock *sk)\n{\n\tif (sk->sk_wmem_queued > SOCK_MIN_SNDBUF &&\n\t    sk_memory_allocated(sk) > sk_prot_mem_limits(sk, 2))\n\t\treturn true;\n\treturn false;\n}\n\nvoid sk_forced_mem_schedule(struct sock *sk, int size);\n\nstatic inline bool tcp_too_many_orphans(struct sock *sk, int shift)\n{\n\tstruct percpu_counter *ocp = sk->sk_prot->orphan_count;\n\tint orphans = percpu_counter_read_positive(ocp);\n\n\tif (orphans << shift > sysctl_tcp_max_orphans) {\n\t\torphans = percpu_counter_sum_positive(ocp);\n\t\tif (orphans << shift > sysctl_tcp_max_orphans)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool tcp_check_oom(struct sock *sk, int shift);\n\n\nextern struct proto tcp_prot;\n\n#define TCP_INC_STATS(net, field)\tSNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define __TCP_INC_STATS(net, field)\t__SNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_DEC_STATS(net, field)\tSNMP_DEC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_ADD_STATS(net, field, val)\tSNMP_ADD_STATS((net)->mib.tcp_statistics, field, val)\n\nvoid tcp_tasklet_init(void);\n\nvoid tcp_v4_err(struct sk_buff *skb, u32);\n\nvoid tcp_shutdown(struct sock *sk, int how);\n\nvoid tcp_v4_early_demux(struct sk_buff *skb);\nint tcp_v4_rcv(struct sk_buff *skb);\n\nint tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);\nint tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nint tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,\n\t\t int flags);\nvoid tcp_release_cb(struct sock *sk);\nvoid tcp_wfree(struct sk_buff *skb);\nvoid tcp_write_timer_handler(struct sock *sk);\nvoid tcp_delack_timer_handler(struct sock *sk);\nint tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb);\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct tcphdr *th, unsigned int len);\nvoid tcp_rcv_space_adjust(struct sock *sk);\nint tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);\nvoid tcp_twsk_destructor(struct sock *sk);\nssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags);\n\nstatic inline void tcp_dec_quickack_mode(struct sock *sk,\n\t\t\t\t\t const unsigned int pkts)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ack.quick) {\n\t\tif (pkts >= icsk->icsk_ack.quick) {\n\t\t\ticsk->icsk_ack.quick = 0;\n\t\t\t/* Leaving quickack mode we deflate ATO. */\n\t\t\ticsk->icsk_ack.ato   = TCP_ATO_MIN;\n\t\t} else\n\t\t\ticsk->icsk_ack.quick -= pkts;\n\t}\n}\n\n#define\tTCP_ECN_OK\t\t1\n#define\tTCP_ECN_QUEUE_CWR\t2\n#define\tTCP_ECN_DEMAND_CWR\t4\n#define\tTCP_ECN_SEEN\t\t8\n\nenum tcp_tw_status {\n\tTCP_TW_SUCCESS = 0,\n\tTCP_TW_RST = 1,\n\tTCP_TW_ACK = 2,\n\tTCP_TW_SYN = 3\n};\n\n\nenum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock *tw,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      const struct tcphdr *th);\nstruct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct request_sock *req, bool fastopen);\nint tcp_child_process(struct sock *parent, struct sock *child,\n\t\t      struct sk_buff *skb);\nvoid tcp_enter_loss(struct sock *sk);\nvoid tcp_clear_retrans(struct tcp_sock *tp);\nvoid tcp_update_metrics(struct sock *sk);\nvoid tcp_init_metrics(struct sock *sk);\nvoid tcp_metrics_init(void);\nbool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst,\n\t\t\tbool paws_check, bool timestamps);\nbool tcp_remember_stamp(struct sock *sk);\nbool tcp_tw_remember_stamp(struct inet_timewait_sock *tw);\nvoid tcp_fetch_timewait_stamp(struct sock *sk, struct dst_entry *dst);\nvoid tcp_disable_fack(struct tcp_sock *tp);\nvoid tcp_close(struct sock *sk, long timeout);\nvoid tcp_init_sock(struct sock *sk);\nunsigned int tcp_poll(struct file *file, struct socket *sock,\n\t\t      struct poll_table_struct *wait);\nint tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, int __user *optlen);\nint tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, unsigned int optlen);\nint compat_tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen);\nint compat_tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen);\nvoid tcp_set_keepalive(struct sock *sk, int val);\nvoid tcp_syn_ack_timeout(const struct request_sock *req);\nint tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,\n\t\tint flags, int *addr_len);\nvoid tcp_parse_options(const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx,\n\t\t       int estab, struct tcp_fastopen_cookie *foc);\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th);\n\n/*\n *\tTCP v4 functions exported for the inet6 API\n */\n\nvoid tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);\nvoid tcp_v4_mtu_reduced(struct sock *sk);\nvoid tcp_req_err(struct sock *sk, u32 seq, bool abort);\nint tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb);\nvoid tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst);\nstruct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t  bool *own_req);\nint tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nint tcp_connect(struct sock *sk);\nenum tcp_synack_type {\n\tTCP_SYNACK_NORMAL,\n\tTCP_SYNACK_FASTOPEN,\n\tTCP_SYNACK_COOKIE,\n};\nstruct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\tstruct request_sock *req,\n\t\t\t\tstruct tcp_fastopen_cookie *foc,\n\t\t\t\tenum tcp_synack_type synack_type);\nint tcp_disconnect(struct sock *sk, int flags);\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb);\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size);\nvoid inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);\n\n/* From syncookies.c */\nstruct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t struct dst_entry *dst);\nint __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\n/* Syncookies use a monotonic timer which increments every 60 seconds.\n * This counter is used both as a hash input and partially encoded into\n * the cookie value.  A cookie is only validated further if the delta\n * between the current counter value and the encoded one is less than this,\n * i.e. a sent cookie is valid only at most for 2*60 seconds (or less if\n * the counter advances immediately after a cookie is generated).\n */\n#define MAX_SYNCOOKIE_AGE\t2\n#define TCP_SYNCOOKIE_PERIOD\t(60 * HZ)\n#define TCP_SYNCOOKIE_VALID\t(MAX_SYNCOOKIE_AGE * TCP_SYNCOOKIE_PERIOD)\n\n/* syncookies: remember time of last synqueue overflow\n * But do not dirty this field too often (once per second is enough)\n * It is racy as we do not hold a lock, but race is very minor.\n */\nstatic inline void tcp_synq_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\tunsigned long now = jiffies;\n\n\tif (time_after(now, last_overflow + HZ))\n\t\ttcp_sk(sk)->rx_opt.ts_recent_stamp = now;\n}\n\n/* syncookies: no recent synqueue overflow on this listening socket? */\nstatic inline bool tcp_synq_no_recent_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\n\treturn time_after(jiffies, last_overflow + TCP_SYNCOOKIE_VALID);\n}\n\nstatic inline u32 tcp_cookie_time(void)\n{\n\tu64 val = get_jiffies_64();\n\n\tdo_div(val, TCP_SYNCOOKIE_PERIOD);\n\treturn val;\n}\n\nu32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,\n\t\t\t      u16 *mssp);\n__u32 cookie_v4_init_sequence(const struct sk_buff *skb, __u16 *mss);\n__u32 cookie_init_timestamp(struct request_sock *req);\nbool cookie_timestamp_decode(struct tcp_options_received *opt);\nbool cookie_ecn_ok(const struct tcp_options_received *opt,\n\t\t   const struct net *net, const struct dst_entry *dst);\n\n/* From net/ipv6/syncookies.c */\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, u16 *mssp);\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mss);\n#endif\n/* tcp_output.c */\n\nu32 tcp_tso_autosize(const struct sock *sk, unsigned int mss_now,\n\t\t     int min_tso_segs);\nvoid __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,\n\t\t\t       int nonagle);\nbool tcp_may_send_now(struct sock *sk);\nint __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nint tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nvoid tcp_retransmit_timer(struct sock *sk);\nvoid tcp_xmit_retransmit_queue(struct sock *);\nvoid tcp_simple_retransmit(struct sock *);\nint tcp_trim_head(struct sock *, struct sk_buff *, u32);\nint tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int, gfp_t);\n\nvoid tcp_send_probe0(struct sock *);\nvoid tcp_send_partial(struct sock *);\nint tcp_write_wakeup(struct sock *, int mib);\nvoid tcp_send_fin(struct sock *sk);\nvoid tcp_send_active_reset(struct sock *sk, gfp_t priority);\nint tcp_send_synack(struct sock *);\nvoid tcp_push_one(struct sock *, unsigned int mss_now);\nvoid tcp_send_ack(struct sock *sk);\nvoid tcp_send_delayed_ack(struct sock *sk);\nvoid tcp_send_loss_probe(struct sock *sk);\nbool tcp_schedule_loss_probe(struct sock *sk);\nvoid tcp_skb_collapse_tstamp(struct sk_buff *skb,\n\t\t\t     const struct sk_buff *next_skb);\n\n/* tcp_input.c */\nvoid tcp_resume_early_retransmit(struct sock *sk);\nvoid tcp_rearm_rto(struct sock *sk);\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req);\nvoid tcp_reset(struct sock *sk);\nvoid tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb);\nvoid tcp_fin(struct sock *sk);\n\n/* tcp_timer.c */\nvoid tcp_init_xmit_timers(struct sock *);\nstatic inline void tcp_clear_xmit_timers(struct sock *sk)\n{\n\tinet_csk_clear_xmit_timers(sk);\n}\n\nunsigned int tcp_sync_mss(struct sock *sk, u32 pmtu);\nunsigned int tcp_current_mss(struct sock *sk);\n\n/* Bound MSS / TSO packet size with the half of the window */\nstatic inline int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)\n{\n\tint cutoff;\n\n\t/* When peer uses tiny windows, there is no use in packetizing\n\t * to sub-MSS pieces for the sake of SWS or making sure there\n\t * are enough packets in the pipe for fast recovery.\n\t *\n\t * On the other hand, for extremely large MSS devices, handling\n\t * smaller than MSS windows in this way does make sense.\n\t */\n\tif (tp->max_window > TCP_MSS_DEFAULT)\n\t\tcutoff = (tp->max_window >> 1);\n\telse\n\t\tcutoff = tp->max_window;\n\n\tif (cutoff && pktsize > cutoff)\n\t\treturn max_t(int, cutoff, 68U - tp->tcp_header_len);\n\telse\n\t\treturn pktsize;\n}\n\n/* tcp.c */\nvoid tcp_get_info(struct sock *, struct tcp_info *);\n\n/* Read 'sendfile()'-style from a TCP socket */\nint tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor);\n\nvoid tcp_initialize_rcv_mss(struct sock *sk);\n\nint tcp_mtu_to_mss(struct sock *sk, int pmtu);\nint tcp_mss_to_mtu(struct sock *sk, int mss);\nvoid tcp_mtup_init(struct sock *sk);\nvoid tcp_init_buffer_space(struct sock *sk);\n\nstatic inline void tcp_bound_rto(const struct sock *sk)\n{\n\tif (inet_csk(sk)->icsk_rto > TCP_RTO_MAX)\n\t\tinet_csk(sk)->icsk_rto = TCP_RTO_MAX;\n}\n\nstatic inline u32 __tcp_set_rto(const struct tcp_sock *tp)\n{\n\treturn usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);\n}\n\nstatic inline void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)\n{\n\ttp->pred_flags = htonl((tp->tcp_header_len << 26) |\n\t\t\t       ntohl(TCP_FLAG_ACK) |\n\t\t\t       snd_wnd);\n}\n\nstatic inline void tcp_fast_path_on(struct tcp_sock *tp)\n{\n\t__tcp_fast_path_on(tp, tp->snd_wnd >> tp->rx_opt.snd_wscale);\n}\n\nstatic inline void tcp_fast_path_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue) &&\n\t    tp->rcv_wnd &&\n\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf &&\n\t    !tp->urg_data)\n\t\ttcp_fast_path_on(tp);\n}\n\n/* Compute the actual rto_min value */\nstatic inline u32 tcp_rto_min(struct sock *sk)\n{\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\tu32 rto_min = TCP_RTO_MIN;\n\n\tif (dst && dst_metric_locked(dst, RTAX_RTO_MIN))\n\t\trto_min = dst_metric_rtt(dst, RTAX_RTO_MIN);\n\treturn rto_min;\n}\n\nstatic inline u32 tcp_rto_min_us(struct sock *sk)\n{\n\treturn jiffies_to_usecs(tcp_rto_min(sk));\n}\n\nstatic inline bool tcp_ca_dst_locked(const struct dst_entry *dst)\n{\n\treturn dst_metric_locked(dst, RTAX_CC_ALGO);\n}\n\n/* Minimum RTT in usec. ~0 means not available. */\nstatic inline u32 tcp_min_rtt(const struct tcp_sock *tp)\n{\n\treturn minmax_get(&tp->rtt_min);\n}\n\n/* Compute the actual receive window we are currently advertising.\n * Rcv_nxt can be after the window if our peer push more data\n * than the offered window.\n */\nstatic inline u32 tcp_receive_window(const struct tcp_sock *tp)\n{\n\ts32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;\n\n\tif (win < 0)\n\t\twin = 0;\n\treturn (u32) win;\n}\n\n/* Choose a new window, without checks for shrinking, and without\n * scaling applied to the result.  The caller does these things\n * if necessary.  This is a \"raw\" window selection.\n */\nu32 __tcp_select_window(struct sock *sk);\n\nvoid tcp_send_window_probe(struct sock *sk);\n\n/* TCP timestamps are only 32-bits, this causes a slight\n * complication on 64-bit systems since we store a snapshot\n * of jiffies in the buffer control blocks below.  We decided\n * to use only the low 32-bits of jiffies and hide the ugly\n * casts with the following macro.\n */\n#define tcp_time_stamp\t\t((__u32)(jiffies))\n\nstatic inline u32 tcp_skb_timestamp(const struct sk_buff *skb)\n{\n\treturn skb->skb_mstamp.stamp_jiffies;\n}\n\n\n#define tcp_flag_byte(th) (((u_int8_t *)th)[13])\n\n#define TCPHDR_FIN 0x01\n#define TCPHDR_SYN 0x02\n#define TCPHDR_RST 0x04\n#define TCPHDR_PSH 0x08\n#define TCPHDR_ACK 0x10\n#define TCPHDR_URG 0x20\n#define TCPHDR_ECE 0x40\n#define TCPHDR_CWR 0x80\n\n#define TCPHDR_SYN_ECN\t(TCPHDR_SYN | TCPHDR_ECE | TCPHDR_CWR)\n\n/* This is what the send packet queuing engine uses to pass\n * TCP per-packet control information to the transmission code.\n * We also store the host-order sequence numbers in here too.\n * This is 44 bytes if IPV6 is enabled.\n * If this grows please adjust skbuff.h:skbuff->cb[xxx] size appropriately.\n */\nstruct tcp_skb_cb {\n\t__u32\t\tseq;\t\t/* Starting sequence number\t*/\n\t__u32\t\tend_seq;\t/* SEQ + FIN + SYN + datalen\t*/\n\tunion {\n\t\t/* Note : tcp_tw_isn is used in input path only\n\t\t *\t  (isn chosen by tcp_timewait_state_process())\n\t\t *\n\t\t * \t  tcp_gso_segs/size are used in write queue only,\n\t\t *\t  cf tcp_skb_pcount()/tcp_skb_mss()\n\t\t */\n\t\t__u32\t\ttcp_tw_isn;\n\t\tstruct {\n\t\t\tu16\ttcp_gso_segs;\n\t\t\tu16\ttcp_gso_size;\n\t\t};\n\t};\n\t__u8\t\ttcp_flags;\t/* TCP header flags. (tcp[13])\t*/\n\n\t__u8\t\tsacked;\t\t/* State flags for SACK/FACK.\t*/\n#define TCPCB_SACKED_ACKED\t0x01\t/* SKB ACK'd by a SACK block\t*/\n#define TCPCB_SACKED_RETRANS\t0x02\t/* SKB retransmitted\t\t*/\n#define TCPCB_LOST\t\t0x04\t/* SKB is lost\t\t\t*/\n#define TCPCB_TAGBITS\t\t0x07\t/* All tag bits\t\t\t*/\n#define TCPCB_REPAIRED\t\t0x10\t/* SKB repaired (no skb_mstamp)\t*/\n#define TCPCB_EVER_RETRANS\t0x80\t/* Ever retransmitted frame\t*/\n#define TCPCB_RETRANS\t\t(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS| \\\n\t\t\t\tTCPCB_REPAIRED)\n\n\t__u8\t\tip_dsfield;\t/* IPv4 tos or IPv6 dsfield\t*/\n\t__u8\t\ttxstamp_ack:1,\t/* Record TX timestamp for ack? */\n\t\t\teor:1,\t\t/* Is skb MSG_EOR marked? */\n\t\t\tunused:6;\n\t__u32\t\tack_seq;\t/* Sequence number ACK'd\t*/\n\tunion {\n\t\tstruct {\n\t\t\t/* There is space for up to 24 bytes */\n\t\t\t__u32 in_flight:30,/* Bytes in flight at transmit */\n\t\t\t      is_app_limited:1, /* cwnd not fully used? */\n\t\t\t      unused:1;\n\t\t\t/* pkts S/ACKed so far upon tx of skb, incl retrans: */\n\t\t\t__u32 delivered;\n\t\t\t/* start of send pipeline phase */\n\t\t\tstruct skb_mstamp first_tx_mstamp;\n\t\t\t/* when we reached the \"delivered\" count */\n\t\t\tstruct skb_mstamp delivered_mstamp;\n\t\t} tx;   /* only used for outgoing skbs */\n\t\tunion {\n\t\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tstruct inet6_skb_parm\th6;\n#endif\n\t\t} header;\t/* For incoming skbs */\n\t};\n};\n\n#define TCP_SKB_CB(__skb)\t((struct tcp_skb_cb *)&((__skb)->cb[0]))\n\n\n#if IS_ENABLED(CONFIG_IPV6)\n/* This is the variant of inet6_iif() that must be used by TCP,\n * as TCP moves IP6CB into a different location in skb->cb[]\n */\nstatic inline int tcp_v6_iif(const struct sk_buff *skb)\n{\n\tbool l3_slave = ipv6_l3mdev_skb(TCP_SKB_CB(skb)->header.h6.flags);\n\n\treturn l3_slave ? skb->skb_iif : TCP_SKB_CB(skb)->header.h6.iif;\n}\n#endif\n\n/* TCP_SKB_CB reference means this can not be used from early demux */\nstatic inline bool inet_exact_dif_match(struct net *net, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\tif (!net->ipv4.sysctl_tcp_l3mdev_accept &&\n\t    skb && ipv4_l3mdev_skb(TCP_SKB_CB(skb)->header.h4.flags))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n/* Due to TSO, an SKB can be composed of multiple actual\n * packets.  To keep these tracked properly, we use this.\n */\nstatic inline int tcp_skb_pcount(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_segs;\n}\n\nstatic inline void tcp_skb_pcount_set(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs = segs;\n}\n\nstatic inline void tcp_skb_pcount_add(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs += segs;\n}\n\n/* This is valid iff skb is in write queue and tcp_skb_pcount() > 1. */\nstatic inline int tcp_skb_mss(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_size;\n}\n\nstatic inline bool tcp_skb_can_collapse_to(const struct sk_buff *skb)\n{\n\treturn likely(!TCP_SKB_CB(skb)->eor);\n}\n\n/* Events passed to congestion control interface */\nenum tcp_ca_event {\n\tCA_EVENT_TX_START,\t/* first transmit when no packets in flight */\n\tCA_EVENT_CWND_RESTART,\t/* congestion window restart */\n\tCA_EVENT_COMPLETE_CWR,\t/* end of congestion recovery */\n\tCA_EVENT_LOSS,\t\t/* loss timeout */\n\tCA_EVENT_ECN_NO_CE,\t/* ECT set, but not CE marked */\n\tCA_EVENT_ECN_IS_CE,\t/* received CE marked IP packet */\n\tCA_EVENT_DELAYED_ACK,\t/* Delayed ack is sent */\n\tCA_EVENT_NON_DELAYED_ACK,\n};\n\n/* Information about inbound ACK, passed to cong_ops->in_ack_event() */\nenum tcp_ca_ack_event_flags {\n\tCA_ACK_SLOWPATH\t\t= (1 << 0),\t/* In slow path processing */\n\tCA_ACK_WIN_UPDATE\t= (1 << 1),\t/* ACK updated window */\n\tCA_ACK_ECE\t\t= (1 << 2),\t/* ECE bit is set on ack */\n};\n\n/*\n * Interface for adding new TCP congestion control handlers\n */\n#define TCP_CA_NAME_MAX\t16\n#define TCP_CA_MAX\t128\n#define TCP_CA_BUF_MAX\t(TCP_CA_NAME_MAX*TCP_CA_MAX)\n\n#define TCP_CA_UNSPEC\t0\n\n/* Algorithm can be set on socket without CAP_NET_ADMIN privileges */\n#define TCP_CONG_NON_RESTRICTED 0x1\n/* Requires ECN/ECT set on all packets */\n#define TCP_CONG_NEEDS_ECN\t0x2\n\nunion tcp_cc_info;\n\nstruct ack_sample {\n\tu32 pkts_acked;\n\ts32 rtt_us;\n\tu32 in_flight;\n};\n\n/* A rate sample measures the number of (original/retransmitted) data\n * packets delivered \"delivered\" over an interval of time \"interval_us\".\n * The tcp_rate.c code fills in the rate sample, and congestion\n * control modules that define a cong_control function to run at the end\n * of ACK processing can optionally chose to consult this sample when\n * setting cwnd and pacing rate.\n * A sample is invalid if \"delivered\" or \"interval_us\" is negative.\n */\nstruct rate_sample {\n\tstruct\tskb_mstamp prior_mstamp; /* starting timestamp for interval */\n\tu32  prior_delivered;\t/* tp->delivered at \"prior_mstamp\" */\n\ts32  delivered;\t\t/* number of packets delivered over interval */\n\tlong interval_us;\t/* time for tp->delivered to incr \"delivered\" */\n\tlong rtt_us;\t\t/* RTT of last (S)ACKed packet (or -1) */\n\tint  losses;\t\t/* number of packets marked lost upon ACK */\n\tu32  acked_sacked;\t/* number of packets newly (S)ACKed upon ACK */\n\tu32  prior_in_flight;\t/* in flight before this ACK */\n\tbool is_app_limited;\t/* is sample from packet with bubble in pipe? */\n\tbool is_retrans;\t/* is sample from retransmission? */\n};\n\nstruct tcp_congestion_ops {\n\tstruct list_head\tlist;\n\tu32 key;\n\tu32 flags;\n\n\t/* initialize private data (optional) */\n\tvoid (*init)(struct sock *sk);\n\t/* cleanup private data  (optional) */\n\tvoid (*release)(struct sock *sk);\n\n\t/* return slow start threshold (required) */\n\tu32 (*ssthresh)(struct sock *sk);\n\t/* do new cwnd calculation (required) */\n\tvoid (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);\n\t/* call before changing ca_state (optional) */\n\tvoid (*set_state)(struct sock *sk, u8 new_state);\n\t/* call when cwnd event occurs (optional) */\n\tvoid (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);\n\t/* call when ack arrives (optional) */\n\tvoid (*in_ack_event)(struct sock *sk, u32 flags);\n\t/* new value of cwnd after loss (optional) */\n\tu32  (*undo_cwnd)(struct sock *sk);\n\t/* hook for packet ack accounting (optional) */\n\tvoid (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);\n\t/* suggest number of segments for each skb to transmit (optional) */\n\tu32 (*tso_segs_goal)(struct sock *sk);\n\t/* returns the multiplier used in tcp_sndbuf_expand (optional) */\n\tu32 (*sndbuf_expand)(struct sock *sk);\n\t/* call when packets are delivered to update cwnd and pacing rate,\n\t * after all the ca_state processing. (optional)\n\t */\n\tvoid (*cong_control)(struct sock *sk, const struct rate_sample *rs);\n\t/* get info for inet_diag (optional) */\n\tsize_t (*get_info)(struct sock *sk, u32 ext, int *attr,\n\t\t\t   union tcp_cc_info *info);\n\n\tchar \t\tname[TCP_CA_NAME_MAX];\n\tstruct module \t*owner;\n};\n\nint tcp_register_congestion_control(struct tcp_congestion_ops *type);\nvoid tcp_unregister_congestion_control(struct tcp_congestion_ops *type);\n\nvoid tcp_assign_congestion_control(struct sock *sk);\nvoid tcp_init_congestion_control(struct sock *sk);\nvoid tcp_cleanup_congestion_control(struct sock *sk);\nint tcp_set_default_congestion_control(const char *name);\nvoid tcp_get_default_congestion_control(char *name);\nvoid tcp_get_available_congestion_control(char *buf, size_t len);\nvoid tcp_get_allowed_congestion_control(char *buf, size_t len);\nint tcp_set_allowed_congestion_control(char *allowed);\nint tcp_set_congestion_control(struct sock *sk, const char *name);\nu32 tcp_slow_start(struct tcp_sock *tp, u32 acked);\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked);\n\nu32 tcp_reno_ssthresh(struct sock *sk);\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);\nextern struct tcp_congestion_ops tcp_reno;\n\nstruct tcp_congestion_ops *tcp_ca_find_key(u32 key);\nu32 tcp_ca_get_key_by_name(const char *name, bool *ecn_ca);\n#ifdef CONFIG_INET\nchar *tcp_ca_get_name_by_key(u32 key, char *buffer);\n#else\nstatic inline char *tcp_ca_get_name_by_key(u32 key, char *buffer)\n{\n\treturn NULL;\n}\n#endif\n\nstatic inline bool tcp_ca_needs_ecn(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\treturn icsk->icsk_ca_ops->flags & TCP_CONG_NEEDS_ECN;\n}\n\nstatic inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->set_state)\n\t\ticsk->icsk_ca_ops->set_state(sk, ca_state);\n\ticsk->icsk_ca_state = ca_state;\n}\n\nstatic inline void tcp_ca_event(struct sock *sk, const enum tcp_ca_event event)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->cwnd_event)\n\t\ticsk->icsk_ca_ops->cwnd_event(sk, event);\n}\n\n/* From tcp_rate.c */\nvoid tcp_rate_skb_sent(struct sock *sk, struct sk_buff *skb);\nvoid tcp_rate_skb_delivered(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct rate_sample *rs);\nvoid tcp_rate_gen(struct sock *sk, u32 delivered, u32 lost,\n\t\t  struct skb_mstamp *now, struct rate_sample *rs);\nvoid tcp_rate_check_app_limited(struct sock *sk);\n\n/* These functions determine how the current flow behaves in respect of SACK\n * handling. SACK is negotiated with the peer, and therefore it can vary\n * between different flows.\n *\n * tcp_is_sack - SACK enabled\n * tcp_is_reno - No SACK\n * tcp_is_fack - FACK enabled, implies SACK enabled\n */\nstatic inline int tcp_is_sack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok;\n}\n\nstatic inline bool tcp_is_reno(const struct tcp_sock *tp)\n{\n\treturn !tcp_is_sack(tp);\n}\n\nstatic inline bool tcp_is_fack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok & TCP_FACK_ENABLED;\n}\n\nstatic inline void tcp_enable_fack(struct tcp_sock *tp)\n{\n\ttp->rx_opt.sack_ok |= TCP_FACK_ENABLED;\n}\n\n/* TCP early-retransmit (ER) is similar to but more conservative than\n * the thin-dupack feature.  Enable ER only if thin-dupack is disabled.\n */\nstatic inline void tcp_enable_early_retrans(struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\ttp->do_early_retrans = sysctl_tcp_early_retrans &&\n\t\tsysctl_tcp_early_retrans < 4 && !sysctl_tcp_thin_dupack &&\n\t\tnet->ipv4.sysctl_tcp_reordering == 3;\n}\n\nstatic inline void tcp_disable_early_retrans(struct tcp_sock *tp)\n{\n\ttp->do_early_retrans = 0;\n}\n\nstatic inline unsigned int tcp_left_out(const struct tcp_sock *tp)\n{\n\treturn tp->sacked_out + tp->lost_out;\n}\n\n/* This determines how many packets are \"in the network\" to the best\n * of our knowledge.  In many cases it is conservative, but where\n * detailed information is available from the receiver (via SACK\n * blocks etc.) we can make more aggressive calculations.\n *\n * Use this for decisions involving congestion control, use just\n * tp->packets_out to determine if the send queue is empty or not.\n *\n * Read this equation as:\n *\n *\t\"Packets sent once on transmission queue\" MINUS\n *\t\"Packets left network, but not honestly ACKed yet\" PLUS\n *\t\"Packets fast retransmitted\"\n */\nstatic inline unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)\n{\n\treturn tp->packets_out - tcp_left_out(tp) + tp->retrans_out;\n}\n\n#define TCP_INFINITE_SSTHRESH\t0x7fffffff\n\nstatic inline bool tcp_in_slow_start(const struct tcp_sock *tp)\n{\n\treturn tp->snd_cwnd < tp->snd_ssthresh;\n}\n\nstatic inline bool tcp_in_initial_slowstart(const struct tcp_sock *tp)\n{\n\treturn tp->snd_ssthresh >= TCP_INFINITE_SSTHRESH;\n}\n\nstatic inline bool tcp_in_cwnd_reduction(const struct sock *sk)\n{\n\treturn (TCPF_CA_CWR | TCPF_CA_Recovery) &\n\t       (1 << inet_csk(sk)->icsk_ca_state);\n}\n\n/* If cwnd > ssthresh, we may raise ssthresh to be half-way to cwnd.\n * The exception is cwnd reduction phase, when cwnd is decreasing towards\n * ssthresh.\n */\nstatic inline __u32 tcp_current_ssthresh(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_in_cwnd_reduction(sk))\n\t\treturn tp->snd_ssthresh;\n\telse\n\t\treturn max(tp->snd_ssthresh,\n\t\t\t   ((tp->snd_cwnd >> 1) +\n\t\t\t    (tp->snd_cwnd >> 2)));\n}\n\n/* Use define here intentionally to get WARN_ON location shown at the caller */\n#define tcp_verify_left_out(tp)\tWARN_ON(tcp_left_out(tp) > tp->packets_out)\n\nvoid tcp_enter_cwr(struct sock *sk);\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst);\n\n/* The maximum number of MSS of available cwnd for which TSO defers\n * sending if not using sysctl_tcp_tso_win_divisor.\n */\nstatic inline __u32 tcp_max_tso_deferred_mss(const struct tcp_sock *tp)\n{\n\treturn 3;\n}\n\n/* Returns end sequence number of the receiver's advertised window */\nstatic inline u32 tcp_wnd_end(const struct tcp_sock *tp)\n{\n\treturn tp->snd_una + tp->snd_wnd;\n}\n\n/* We follow the spirit of RFC2861 to validate cwnd but implement a more\n * flexible approach. The RFC suggests cwnd should not be raised unless\n * it was fully used previously. And that's exactly what we do in\n * congestion avoidance mode. But in slow start we allow cwnd to grow\n * as long as the application has used half the cwnd.\n * Example :\n *    cwnd is 10 (IW10), but application sends 9 frames.\n *    We allow cwnd to reach 18 when all frames are ACKed.\n * This check is safe because it's as aggressive as slow start which already\n * risks 100% overshoot. The advantage is that we discourage application to\n * either send more filler packets or data to artificially blow up the cwnd\n * usage, and allow application-limited process to probe bw more aggressively.\n */\nstatic inline bool tcp_is_cwnd_limited(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If in slow start, ensure cwnd grows to twice what was ACKed. */\n\tif (tcp_in_slow_start(tp))\n\t\treturn tp->snd_cwnd < 2 * tp->max_packets_out;\n\n\treturn tp->is_cwnd_limited;\n}\n\n/* Something is really bad, we could not queue an additional packet,\n * because qdisc is full or receiver sent a 0 window.\n * We do not want to add fuel to the fire, or abort too early,\n * so make sure the timer we arm now is at least 200ms in the future,\n * regardless of current icsk_rto value (as it could be ~2ms)\n */\nstatic inline unsigned long tcp_probe0_base(const struct sock *sk)\n{\n\treturn max_t(unsigned long, inet_csk(sk)->icsk_rto, TCP_RTO_MIN);\n}\n\n/* Variant of inet_csk_rto_backoff() used for zero window probes */\nstatic inline unsigned long tcp_probe0_when(const struct sock *sk,\n\t\t\t\t\t    unsigned long max_when)\n{\n\tu64 when = (u64)tcp_probe0_base(sk) << inet_csk(sk)->icsk_backoff;\n\n\treturn (unsigned long)min_t(u64, when, max_when);\n}\n\nstatic inline void tcp_check_probe_timer(struct sock *sk)\n{\n\tif (!tcp_sk(sk)->packets_out && !inet_csk(sk)->icsk_pending)\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t\t  tcp_probe0_base(sk), TCP_RTO_MAX);\n}\n\nstatic inline void tcp_init_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\nstatic inline void tcp_update_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\n/*\n * Calculate(/check) TCP checksum\n */\nstatic inline __sum16 tcp_v4_check(int len, __be32 saddr,\n\t\t\t\t   __be32 daddr, __wsum base)\n{\n\treturn csum_tcpudp_magic(saddr,daddr,len,IPPROTO_TCP,base);\n}\n\nstatic inline __sum16 __tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn __skb_checksum_complete(skb);\n}\n\nstatic inline bool tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t\t__tcp_checksum_complete(skb);\n}\n\n/* Prequeue for VJ style copy to user, combined with checksumming. */\n\nstatic inline void tcp_prequeue_init(struct tcp_sock *tp)\n{\n\ttp->ucopy.task = NULL;\n\ttp->ucopy.len = 0;\n\ttp->ucopy.memory = 0;\n\tskb_queue_head_init(&tp->ucopy.prequeue);\n}\n\nbool tcp_prequeue(struct sock *sk, struct sk_buff *skb);\nbool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);\nint tcp_filter(struct sock *sk, struct sk_buff *skb);\n\n#undef STATE_TRACE\n\n#ifdef STATE_TRACE\nstatic const char *statename[]={\n\t\"Unused\",\"Established\",\"Syn Sent\",\"Syn Recv\",\n\t\"Fin Wait 1\",\"Fin Wait 2\",\"Time Wait\", \"Close\",\n\t\"Close Wait\",\"Last ACK\",\"Listen\",\"Closing\"\n};\n#endif\nvoid tcp_set_state(struct sock *sk, int state);\n\nvoid tcp_done(struct sock *sk);\n\nint tcp_abort(struct sock *sk, int err);\n\nstatic inline void tcp_sack_reset(struct tcp_options_received *rx_opt)\n{\n\trx_opt->dsack = 0;\n\trx_opt->num_sacks = 0;\n}\n\nu32 tcp_default_init_rwnd(u32 mss);\nvoid tcp_cwnd_restart(struct sock *sk, s32 delta);\n\nstatic inline void tcp_slow_start_after_idle_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ts32 delta;\n\n\tif (!sysctl_tcp_slow_start_after_idle || tp->packets_out)\n\t\treturn;\n\tdelta = tcp_time_stamp - tp->lsndtime;\n\tif (delta > inet_csk(sk)->icsk_rto)\n\t\ttcp_cwnd_restart(sk, delta);\n}\n\n/* Determine a window scaling and initial window to offer. */\nvoid tcp_select_initial_window(int __space, __u32 mss, __u32 *rcv_wnd,\n\t\t\t       __u32 *window_clamp, int wscale_ok,\n\t\t\t       __u8 *rcv_wscale, __u32 init_rcv_wnd);\n\nstatic inline int tcp_win_from_space(int space)\n{\n\treturn sysctl_tcp_adv_win_scale<=0 ?\n\t\t(space>>(-sysctl_tcp_adv_win_scale)) :\n\t\tspace - (space>>sysctl_tcp_adv_win_scale);\n}\n\n/* Note: caller must be prepared to deal with negative returns */\nstatic inline int tcp_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf -\n\t\t\t\t  atomic_read(&sk->sk_rmem_alloc));\n}\n\nstatic inline int tcp_full_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf);\n}\n\nextern void tcp_openreq_init_rwin(struct request_sock *req,\n\t\t\t\t  const struct sock *sk_listener,\n\t\t\t\t  const struct dst_entry *dst);\n\nvoid tcp_enter_memory_pressure(struct sock *sk);\n\nstatic inline int keepalive_intvl_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_intvl ? : net->ipv4.sysctl_tcp_keepalive_intvl;\n}\n\nstatic inline int keepalive_time_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_time ? : net->ipv4.sysctl_tcp_keepalive_time;\n}\n\nstatic inline int keepalive_probes(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_probes ? : net->ipv4.sysctl_tcp_keepalive_probes;\n}\n\nstatic inline u32 keepalive_time_elapsed(const struct tcp_sock *tp)\n{\n\tconst struct inet_connection_sock *icsk = &tp->inet_conn;\n\n\treturn min_t(u32, tcp_time_stamp - icsk->icsk_ack.lrcvtime,\n\t\t\t  tcp_time_stamp - tp->rcv_tstamp);\n}\n\nstatic inline int tcp_fin_time(const struct sock *sk)\n{\n\tint fin_timeout = tcp_sk(sk)->linger2 ? : sock_net(sk)->ipv4.sysctl_tcp_fin_timeout;\n\tconst int rto = inet_csk(sk)->icsk_rto;\n\n\tif (fin_timeout < (rto << 2) - (rto >> 1))\n\t\tfin_timeout = (rto << 2) - (rto >> 1);\n\n\treturn fin_timeout;\n}\n\nstatic inline bool tcp_paws_check(const struct tcp_options_received *rx_opt,\n\t\t\t\t  int paws_win)\n{\n\tif ((s32)(rx_opt->ts_recent - rx_opt->rcv_tsval) <= paws_win)\n\t\treturn true;\n\tif (unlikely(get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_24DAYS))\n\t\treturn true;\n\t/*\n\t * Some OSes send SYN and SYNACK messages with tsval=0 tsecr=0,\n\t * then following tcp messages have valid values. Ignore 0 value,\n\t * or else 'negative' tsval might forbid us to accept their packets.\n\t */\n\tif (!rx_opt->ts_recent)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,\n\t\t\t\t   int rst)\n{\n\tif (tcp_paws_check(rx_opt, 0))\n\t\treturn false;\n\n\t/* RST segments are not recommended to carry timestamp,\n\t   and, if they do, it is recommended to ignore PAWS because\n\t   \"their cleanup function should take precedence over timestamps.\"\n\t   Certainly, it is mistake. It is necessary to understand the reasons\n\t   of this constraint to relax it: if peer reboots, clock may go\n\t   out-of-sync and half-open connections will not be reset.\n\t   Actually, the problem would be not existing if all\n\t   the implementations followed draft about maintaining clock\n\t   via reboots. Linux-2.2 DOES NOT!\n\n\t   However, we can relax time bounds for RST segments to MSL.\n\t */\n\tif (rst && get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_MSL)\n\t\treturn false;\n\treturn true;\n}\n\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time);\n\nstatic inline void tcp_mib_init(struct net *net)\n{\n\t/* See RFC 2012 */\n\tTCP_ADD_STATS(net, TCP_MIB_RTOALGORITHM, 1);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMIN, TCP_RTO_MIN*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMAX, TCP_RTO_MAX*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_MAXCONN, -1);\n}\n\n/* from STCP */\nstatic inline void tcp_clear_retrans_hints_partial(struct tcp_sock *tp)\n{\n\ttp->lost_skb_hint = NULL;\n}\n\nstatic inline void tcp_clear_all_retrans_hints(struct tcp_sock *tp)\n{\n\ttcp_clear_retrans_hints_partial(tp);\n\ttp->retransmit_skb_hint = NULL;\n}\n\nunion tcp_md5_addr {\n\tstruct in_addr  a4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr\ta6;\n#endif\n};\n\n/* - key database */\nstruct tcp_md5sig_key {\n\tstruct hlist_node\tnode;\n\tu8\t\t\tkeylen;\n\tu8\t\t\tfamily; /* AF_INET or AF_INET6 */\n\tunion tcp_md5_addr\taddr;\n\tu8\t\t\tkey[TCP_MD5SIG_MAXKEYLEN];\n\tstruct rcu_head\t\trcu;\n};\n\n/* - sock block */\nstruct tcp_md5sig_info {\n\tstruct hlist_head\thead;\n\tstruct rcu_head\t\trcu;\n};\n\n/* - pseudo header */\nstruct tcp4_pseudohdr {\n\t__be32\t\tsaddr;\n\t__be32\t\tdaddr;\n\t__u8\t\tpad;\n\t__u8\t\tprotocol;\n\t__be16\t\tlen;\n};\n\nstruct tcp6_pseudohdr {\n\tstruct in6_addr\tsaddr;\n\tstruct in6_addr daddr;\n\t__be32\t\tlen;\n\t__be32\t\tprotocol;\t/* including padding */\n};\n\nunion tcp_md5sum_block {\n\tstruct tcp4_pseudohdr ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct tcp6_pseudohdr ip6;\n#endif\n};\n\n/* - pool: digest algorithm, hash description and scratch buffer */\nstruct tcp_md5sig_pool {\n\tstruct ahash_request\t*md5_req;\n\tvoid\t\t\t*scratch;\n};\n\n/* - functions */\nint tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\tconst struct sock *sk, const struct sk_buff *skb);\nint tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family, const u8 *newkey, u8 newkeylen, gfp_t gfp);\nint tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family);\nstruct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,\n\t\t\t\t\t const struct sock *addr_sk);\n\n#ifdef CONFIG_TCP_MD5SIG\nstruct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family);\n#define tcp_twsk_md5_key(twsk)\t((twsk)->tw_md5_key)\n#else\nstatic inline struct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family)\n{\n\treturn NULL;\n}\n#define tcp_twsk_md5_key(twsk)\tNULL\n#endif\n\nbool tcp_alloc_md5sig_pool(void);\n\nstruct tcp_md5sig_pool *tcp_get_md5sig_pool(void);\nstatic inline void tcp_put_md5sig_pool(void)\n{\n\tlocal_bh_enable();\n}\n\nint tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,\n\t\t\t  unsigned int header_len);\nint tcp_md5_hash_key(struct tcp_md5sig_pool *hp,\n\t\t     const struct tcp_md5sig_key *key);\n\n/* From tcp_fastopen.c */\nvoid tcp_fastopen_cache_get(struct sock *sk, u16 *mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, int *syn_loss,\n\t\t\t    unsigned long *last_syn_loss);\nvoid tcp_fastopen_cache_set(struct sock *sk, u16 mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, bool syn_lost,\n\t\t\t    u16 try_exp);\nstruct tcp_fastopen_request {\n\t/* Fast Open cookie. Size 0 means a cookie request */\n\tstruct tcp_fastopen_cookie\tcookie;\n\tstruct msghdr\t\t\t*data;  /* data in MSG_FASTOPEN */\n\tsize_t\t\t\t\tsize;\n\tint\t\t\t\tcopied;\t/* queued in tcp_connect() */\n};\nvoid tcp_free_fastopen_req(struct tcp_sock *tp);\n\nextern struct tcp_fastopen_context __rcu *tcp_fastopen_ctx;\nint tcp_fastopen_reset_cipher(void *key, unsigned int len);\nvoid tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      struct dst_entry *dst);\nvoid tcp_fastopen_init_key_once(bool publish);\n#define TCP_FASTOPEN_KEY_LENGTH 16\n\n/* Fastopen key context */\nstruct tcp_fastopen_context {\n\tstruct crypto_cipher\t*tfm;\n\t__u8\t\t\tkey[TCP_FASTOPEN_KEY_LENGTH];\n\tstruct rcu_head\t\trcu;\n};\n\n/* write queue abstraction */\nstatic inline void tcp_write_queue_purge(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&sk->sk_write_queue)) != NULL)\n\t\tsk_wmem_free_skb(sk, skb);\n\tsk_mem_reclaim(sk);\n\ttcp_clear_all_retrans_hints(tcp_sk(sk));\n}\n\nstatic inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)\n{\n\treturn skb_peek(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)\n{\n\treturn skb_peek_tail(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_next(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_next(&sk->sk_write_queue, skb);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_prev(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_prev(&sk->sk_write_queue, skb);\n}\n\n#define tcp_for_write_queue(skb, sk)\t\t\t\t\t\\\n\tskb_queue_walk(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from(skb, sk)\t\t\t\t\\\n\tskb_queue_walk_from(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from_safe(skb, tmp, sk)\t\t\t\\\n\tskb_queue_walk_from_safe(&(sk)->sk_write_queue, skb, tmp)\n\nstatic inline struct sk_buff *tcp_send_head(const struct sock *sk)\n{\n\treturn sk->sk_send_head;\n}\n\nstatic inline bool tcp_skb_is_last(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_is_last(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_advance_send_head(struct sock *sk, const struct sk_buff *skb)\n{\n\tif (tcp_skb_is_last(sk, skb))\n\t\tsk->sk_send_head = NULL;\n\telse\n\t\tsk->sk_send_head = tcp_write_queue_next(sk, skb);\n}\n\nstatic inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}\n\nstatic inline void tcp_init_send_head(struct sock *sk)\n{\n\tsk->sk_send_head = NULL;\n}\n\nstatic inline void __tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__tcp_add_write_queue_tail(sk, skb);\n\n\t/* Queue it, remembering where we must start sending. */\n\tif (sk->sk_send_head == NULL) {\n\t\tsk->sk_send_head = skb;\n\n\t\tif (tcp_sk(sk)->highest_sack == NULL)\n\t\t\ttcp_sk(sk)->highest_sack = skb;\n\t}\n}\n\nstatic inline void __tcp_add_write_queue_head(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_head(&sk->sk_write_queue, skb);\n}\n\n/* Insert buff after skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_after(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sk_buff *buff,\n\t\t\t\t\t\tstruct sock *sk)\n{\n\t__skb_queue_after(&sk->sk_write_queue, skb, buff);\n}\n\n/* Insert new before skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_before(struct sk_buff *new,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  struct sock *sk)\n{\n\t__skb_queue_before(&sk->sk_write_queue, skb, new);\n\n\tif (sk->sk_send_head == skb)\n\t\tsk->sk_send_head = new;\n}\n\nstatic inline void tcp_unlink_write_queue(struct sk_buff *skb, struct sock *sk)\n{\n\t__skb_unlink(skb, &sk->sk_write_queue);\n}\n\nstatic inline bool tcp_write_queue_empty(struct sock *sk)\n{\n\treturn skb_queue_empty(&sk->sk_write_queue);\n}\n\nstatic inline void tcp_push_pending_frames(struct sock *sk)\n{\n\tif (tcp_send_head(sk)) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk), tp->nonagle);\n\t}\n}\n\n/* Start sequence of the skb just after the highest skb with SACKed\n * bit, valid only if sacked_out > 0 or when the caller has ensured\n * validity by itself.\n */\nstatic inline u32 tcp_highest_sack_seq(struct tcp_sock *tp)\n{\n\tif (!tp->sacked_out)\n\t\treturn tp->snd_una;\n\n\tif (tp->highest_sack == NULL)\n\t\treturn tp->snd_nxt;\n\n\treturn TCP_SKB_CB(tp->highest_sack)->seq;\n}\n\nstatic inline void tcp_advance_highest_sack(struct sock *sk, struct sk_buff *skb)\n{\n\ttcp_sk(sk)->highest_sack = tcp_skb_is_last(sk, skb) ? NULL :\n\t\t\t\t\t\ttcp_write_queue_next(sk, skb);\n}\n\nstatic inline struct sk_buff *tcp_highest_sack(struct sock *sk)\n{\n\treturn tcp_sk(sk)->highest_sack;\n}\n\nstatic inline void tcp_highest_sack_reset(struct sock *sk)\n{\n\ttcp_sk(sk)->highest_sack = tcp_write_queue_head(sk);\n}\n\n/* Called when old skb is about to be deleted (to be combined with new skb) */\nstatic inline void tcp_highest_sack_combine(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *old,\n\t\t\t\t\t    struct sk_buff *new)\n{\n\tif (tcp_sk(sk)->sacked_out && (old == tcp_sk(sk)->highest_sack))\n\t\ttcp_sk(sk)->highest_sack = new;\n}\n\n/* This helper checks if socket has IP_TRANSPARENT set */\nstatic inline bool inet_sk_transparent(const struct sock *sk)\n{\n\tswitch (sk->sk_state) {\n\tcase TCP_TIME_WAIT:\n\t\treturn inet_twsk(sk)->tw_transparent;\n\tcase TCP_NEW_SYN_RECV:\n\t\treturn inet_rsk(inet_reqsk(sk))->no_srccheck;\n\t}\n\treturn inet_sk(sk)->transparent;\n}\n\n/* Determines whether this is a thin stream (which may suffer from\n * increased latency). Used to trigger latency-reducing mechanisms.\n */\nstatic inline bool tcp_stream_is_thin(struct tcp_sock *tp)\n{\n\treturn tp->packets_out < 4 && !tcp_in_initial_slowstart(tp);\n}\n\n/* /proc */\nenum tcp_seq_states {\n\tTCP_SEQ_STATE_LISTENING,\n\tTCP_SEQ_STATE_ESTABLISHED,\n};\n\nint tcp_seq_open(struct inode *inode, struct file *file);\n\nstruct tcp_seq_afinfo {\n\tchar\t\t\t\t*name;\n\tsa_family_t\t\t\tfamily;\n\tconst struct file_operations\t*seq_fops;\n\tstruct seq_operations\t\tseq_ops;\n};\n\nstruct tcp_iter_state {\n\tstruct seq_net_private\tp;\n\tsa_family_t\t\tfamily;\n\tenum tcp_seq_states\tstate;\n\tstruct sock\t\t*syn_wait_sk;\n\tint\t\t\tbucket, offset, sbucket, num;\n\tloff_t\t\t\tlast_pos;\n};\n\nint tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo);\nvoid tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo);\n\nextern struct request_sock_ops tcp_request_sock_ops;\nextern struct request_sock_ops tcp6_request_sock_ops;\n\nvoid tcp_v4_destroy_sock(struct sock *sk);\n\nstruct sk_buff *tcp_gso_segment(struct sk_buff *skb,\n\t\t\t\tnetdev_features_t features);\nstruct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb);\nint tcp_gro_complete(struct sk_buff *skb);\n\nvoid __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr);\n\nstatic inline u32 tcp_notsent_lowat(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\treturn tp->notsent_lowat ?: net->ipv4.sysctl_tcp_notsent_lowat;\n}\n\nstatic inline bool tcp_stream_memory_free(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu32 notsent_bytes = tp->write_seq - tp->snd_nxt;\n\n\treturn notsent_bytes < tcp_notsent_lowat(tp);\n}\n\n#ifdef CONFIG_PROC_FS\nint tcp4_proc_init(void);\nvoid tcp4_proc_exit(void);\n#endif\n\nint tcp_rtx_synack(const struct sock *sk, struct request_sock *req);\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb);\n\n/* TCP af-specific functions */\nstruct tcp_sock_af_ops {\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key\t*(*md5_lookup) (const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash)(char *location,\n\t\t\t\t\t const struct tcp_md5sig_key *md5,\n\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t const struct sk_buff *skb);\n\tint\t\t(*md5_parse)(struct sock *sk,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int optlen);\n#endif\n};\n\nstruct tcp_request_sock_ops {\n\tu16 mss_clamp;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *(*req_md5_lookup)(const struct sock *sk,\n\t\t\t\t\t\t const struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash) (char *location,\n\t\t\t\t\t  const struct tcp_md5sig_key *md5,\n\t\t\t\t\t  const struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb);\n#endif\n\tvoid (*init_req)(struct request_sock *req,\n\t\t\t const struct sock *sk_listener,\n\t\t\t struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\t__u32 (*cookie_init_seq)(const struct sk_buff *skb,\n\t\t\t\t __u16 *mss);\n#endif\n\tstruct dst_entry *(*route_req)(const struct sock *sk, struct flowi *fl,\n\t\t\t\t       const struct request_sock *req,\n\t\t\t\t       bool *strict);\n\t__u32 (*init_seq)(const struct sk_buff *skb);\n\tint (*send_synack)(const struct sock *sk, struct dst_entry *dst,\n\t\t\t   struct flowi *fl, struct request_sock *req,\n\t\t\t   struct tcp_fastopen_cookie *foc,\n\t\t\t   enum tcp_synack_type synack_type);\n};\n\n#ifdef CONFIG_SYN_COOKIES\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\ttcp_synq_overflow(sk);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESSENT);\n\treturn ops->cookie_init_seq(skb, mss);\n}\n#else\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\treturn 0;\n}\n#endif\n\nint tcpv4_offload_init(void);\n\nvoid tcp_v4_init(void);\nvoid tcp_init(void);\n\n/* tcp_recovery.c */\n\n/* Flags to enable various loss recovery features. See below */\nextern int sysctl_tcp_recovery;\n\n/* Use TCP RACK to detect (some) tail and retransmit losses */\n#define TCP_RACK_LOST_RETRANS  0x1\n\nextern int tcp_rack_mark_lost(struct sock *sk);\n\nextern void tcp_rack_advance(struct tcp_sock *tp,\n\t\t\t     const struct skb_mstamp *xmit_time, u8 sacked);\n\n/*\n * Save and compile IPv4 options, return a pointer to it\n */\nstatic inline struct ip_options_rcu *tcp_v4_save_options(struct sk_buff *skb)\n{\n\tconst struct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\n\tstruct ip_options_rcu *dopt = NULL;\n\n\tif (opt->optlen) {\n\t\tint opt_size = sizeof(*dopt) + opt->optlen;\n\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt && __ip_options_echo(&dopt->opt, skb, opt)) {\n\t\t\tkfree(dopt);\n\t\t\tdopt = NULL;\n\t\t}\n\t}\n\treturn dopt;\n}\n\n/* locally generated TCP pure ACKs have skb->truesize == 2\n * (check tcp_send_ack() in net/ipv4/tcp_output.c )\n * This is much faster than dissecting the packet to find out.\n * (Think of GRE encapsulations, IPv4, IPv6, ...)\n */\nstatic inline bool skb_is_tcp_pure_ack(const struct sk_buff *skb)\n{\n\treturn skb->truesize == 2;\n}\n\nstatic inline void skb_set_tcp_pure_ack(struct sk_buff *skb)\n{\n\tskb->truesize = 2;\n}\n\nstatic inline int tcp_inq(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint answ;\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\tansw = 0;\n\t} else if (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t   !tp->urg_data ||\n\t\t   before(tp->urg_seq, tp->copied_seq) ||\n\t\t   !before(tp->urg_seq, tp->rcv_nxt)) {\n\n\t\tansw = tp->rcv_nxt - tp->copied_seq;\n\n\t\t/* Subtract 1, if FIN was received */\n\t\tif (answ && sock_flag(sk, SOCK_DONE))\n\t\t\tansw--;\n\t} else {\n\t\tansw = tp->urg_seq - tp->copied_seq;\n\t}\n\n\treturn answ;\n}\n\nint tcp_peek_len(struct socket *sock);\n\nstatic inline void tcp_segs_in(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tu16 segs_in;\n\n\tsegs_in = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\ttp->segs_in += segs_in;\n\tif (skb->len > tcp_hdrlen(skb))\n\t\ttp->data_segs_in += segs_in;\n}\n\n/*\n * TCP listen path runs lockless.\n * We forced \"struct sock\" to be const qualified to make sure\n * we don't modify one of its field by mistake.\n * Here, we increment sk_drops which is an atomic_t, so we can safely\n * make sock writable again.\n */\nstatic inline void tcp_listendrop(const struct sock *sk)\n{\n\tatomic_inc(&((struct sock *)sk)->sk_drops);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n}\n\n#endif\t/* _TCP_H */\n", "/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tImplementation of the Transmission Control Protocol(TCP).\n *\n *\t\tIPv4 specific functions\n *\n *\n *\t\tcode split from:\n *\t\tlinux/ipv4/tcp.c\n *\t\tlinux/ipv4/tcp_input.c\n *\t\tlinux/ipv4/tcp_output.c\n *\n *\t\tSee tcp.c for author information\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n * Changes:\n *\t\tDavid S. Miller\t:\tNew socket lookup architecture.\n *\t\t\t\t\tThis code is dedicated to John Dyson.\n *\t\tDavid S. Miller :\tChange semantics of established hash,\n *\t\t\t\t\thalf is devoted to TIME_WAIT sockets\n *\t\t\t\t\tand the rest go in the other half.\n *\t\tAndi Kleen :\t\tAdd support for syncookies and fixed\n *\t\t\t\t\tsome bugs: ip options weren't passed to\n *\t\t\t\t\tthe TCP layer, missed a check for an\n *\t\t\t\t\tACK bit.\n *\t\tAndi Kleen :\t\tImplemented fast path mtu discovery.\n *\t     \t\t\t\tFixed many serious bugs in the\n *\t\t\t\t\trequest_sock handling and moved\n *\t\t\t\t\tmost of it into the af independent code.\n *\t\t\t\t\tAdded tail drop and some other bugfixes.\n *\t\t\t\t\tAdded new listen semantics.\n *\t\tMike McLagan\t:\tRouting by source\n *\tJuan Jose Ciarlante:\t\tip_dynaddr bits\n *\t\tAndi Kleen:\t\tvarious fixes.\n *\tVitaly E. Lavrov\t:\tTransparent proxy revived after year\n *\t\t\t\t\tcoma.\n *\tAndi Kleen\t\t:\tFix new listen.\n *\tAndi Kleen\t\t:\tFix accept error reporting.\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n */\n\n#define pr_fmt(fmt) \"TCP: \" fmt\n\n#include <linux/bottom_half.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/cache.h>\n#include <linux/jhash.h>\n#include <linux/init.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n\n#include <net/net_namespace.h>\n#include <net/icmp.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp.h>\n#include <net/transp_v6.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/timewait_sock.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/inet.h>\n#include <linux/ipv6.h>\n#include <linux/stddef.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\nint sysctl_tcp_tw_reuse __read_mostly;\nint sysctl_tcp_low_latency __read_mostly;\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       __be32 daddr, __be32 saddr, const struct tcphdr *th);\n#endif\n\nstruct inet_hashinfo tcp_hashinfo;\nEXPORT_SYMBOL(tcp_hashinfo);\n\nstatic  __u32 tcp_v4_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_tcp_sequence_number(ip_hdr(skb)->daddr,\n\t\t\t\t\t  ip_hdr(skb)->saddr,\n\t\t\t\t\t  tcp_hdr(skb)->dest,\n\t\t\t\t\t  tcp_hdr(skb)->source);\n}\n\nint tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp)\n{\n\tconst struct tcp_timewait_sock *tcptw = tcp_twsk(sktw);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* With PAWS, it is safe from the viewpoint\n\t   of data integrity. Even without PAWS it is safe provided sequence\n\t   spaces do not overlap i.e. at data rates <= 80Mbit/sec.\n\n\t   Actually, the idea is close to VJ's one, only timestamp cache is\n\t   held not per host, but per port pair and TW bucket is used as state\n\t   holder.\n\n\t   If TW bucket has been already destroyed we fall back to VJ's scheme\n\t   and use initial timestamp retrieved from peer table.\n\t */\n\tif (tcptw->tw_ts_recent_stamp &&\n\t    (!twp || (sysctl_tcp_tw_reuse &&\n\t\t\t     get_seconds() - tcptw->tw_ts_recent_stamp > 1))) {\n\t\ttp->write_seq = tcptw->tw_snd_nxt + 65535 + 2;\n\t\tif (tp->write_seq == 0)\n\t\t\ttp->write_seq = 1;\n\t\ttp->rx_opt.ts_recent\t   = tcptw->tw_ts_recent;\n\t\ttp->rx_opt.ts_recent_stamp = tcptw->tw_ts_recent_stamp;\n\t\tsock_hold(sktw);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tcp_twsk_unique);\n\n/* This will initiate an outgoing connection. */\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 *fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     lockdep_sock_is_held(sk));\n\tif (inet_opt && inet_opt->opt.srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\tfl4 = &inet->cork.fl.u.ip4;\n\trt = ip_route_connect(fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_TCP,\n\t\t\t      orig_sport, orig_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\treturn err;\n\t}\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (!inet_opt || !inet_opt->opt.srr)\n\t\tdaddr = fl4->daddr;\n\n\tif (!inet->inet_saddr)\n\t\tinet->inet_saddr = fl4->saddr;\n\tsk_rcv_saddr_set(sk, inet->inet_saddr);\n\n\tif (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) {\n\t\t/* Reset inherited state */\n\t\ttp->rx_opt.ts_recent\t   = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\tif (likely(!tp->repair))\n\t\t\ttp->write_seq\t   = 0;\n\t}\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp && fl4->daddr == daddr)\n\t\ttcp_fetch_timewait_stamp(sk, &rt->dst);\n\n\tinet->inet_dport = usin->sin_port;\n\tsk_daddr_set(sk, daddr);\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\n\ttp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n\n\t/* Socket identity is still unknown (sport may be zero).\n\t * However we set state to SYN-SENT and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto failure;\n\n\tsk_set_txhash(sk);\n\n\trt = ip_route_newports(fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(sk, &rt->dst);\n\n\tif (!tp->write_seq && likely(!tp->repair))\n\t\ttp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t\t   inet->inet_daddr,\n\t\t\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t\t\t   usin->sin_port);\n\n\tinet->inet_id = tp->write_seq ^ jiffies;\n\n\terr = tcp_connect(sk);\n\n\trt = NULL;\n\tif (err)\n\t\tgoto failure;\n\n\treturn 0;\n\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port,\n\t * if necessary.\n\t */\n\ttcp_set_state(sk, TCP_CLOSE);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\treturn err;\n}\nEXPORT_SYMBOL(tcp_v4_connect);\n\n/*\n * This routine reacts to ICMP_FRAG_NEEDED mtu indications as defined in RFC1191.\n * It can be called through tcp_release_cb() if socket was owned by user\n * at the time tcp_v4_err() was called to handle ICMP message.\n */\nvoid tcp_v4_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tu32 mtu = tcp_sk(sk)->mtu_info;\n\n\tdst = inet_csk_update_pmtu(sk, mtu);\n\tif (!dst)\n\t\treturn;\n\n\t/* Something is about to be wrong... Remember soft error\n\t * for the case, if this connection will not able to recover.\n\t */\n\tif (mtu < dst_mtu(dst) && ip_dont_fragment(sk, dst))\n\t\tsk->sk_err_soft = EMSGSIZE;\n\n\tmtu = dst_mtu(dst);\n\n\tif (inet->pmtudisc != IP_PMTUDISC_DONT &&\n\t    ip_sk_accept_pmtu(sk) &&\n\t    inet_csk(sk)->icsk_pmtu_cookie > mtu) {\n\t\ttcp_sync_mss(sk, mtu);\n\n\t\t/* Resend the TCP packet because it's\n\t\t * clear that the old packet has been\n\t\t * dropped. This is the new \"fast\" path mtu\n\t\t * discovery.\n\t\t */\n\t\ttcp_simple_retransmit(sk);\n\t} /* else let the usual retransmit timer handle it */\n}\nEXPORT_SYMBOL(tcp_v4_mtu_reduced);\n\nstatic void do_redirect(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct dst_entry *dst = __sk_dst_check(sk, 0);\n\n\tif (dst)\n\t\tdst->ops->redirect(dst, sk, skb);\n}\n\n\n/* handle ICMP messages on TCP_NEW_SYN_RECV request sockets */\nvoid tcp_req_err(struct sock *sk, u32 seq, bool abort)\n{\n\tstruct request_sock *req = inet_reqsk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t/* ICMPs are not backlogged, hence we cannot get\n\t * an established socket here.\n\t */\n\tif (seq != tcp_rsk(req)->snt_isn) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t} else if (abort) {\n\t\t/*\n\t\t * Still in SYN_RECV, just remove it silently.\n\t\t * There is no good way to pass the error to the newly\n\t\t * created socket, and POSIX does not want network\n\t\t * errors returned from accept().\n\t\t */\n\t\tinet_csk_reqsk_queue_drop(req->rsk_listener, req);\n\t\ttcp_listendrop(req->rsk_listener);\n\t}\n\treqsk_put(req);\n}\nEXPORT_SYMBOL(tcp_req_err);\n\n/*\n * This routine is called by the ICMP module when it gets some\n * sort of error condition.  If err < 0 then the socket should\n * be closed and the error returned to the user.  If err > 0\n * it's just the icmp type << 8 | icmp code.  After adjustment\n * header points to the first 8 bytes of the tcp header.  We need\n * to find the appropriate port.\n *\n * The locking strategy used here is very \"optimistic\". When\n * someone else accesses the socket the ICMP is just dropped\n * and for some paths there is no check at all.\n * A more general error queue to queue errors for later handling\n * is probably better.\n *\n */\n\nvoid tcp_v4_err(struct sk_buff *icmp_skb, u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)icmp_skb->data;\n\tstruct tcphdr *th = (struct tcphdr *)(icmp_skb->data + (iph->ihl << 2));\n\tstruct inet_connection_sock *icsk;\n\tstruct tcp_sock *tp;\n\tstruct inet_sock *inet;\n\tconst int type = icmp_hdr(icmp_skb)->type;\n\tconst int code = icmp_hdr(icmp_skb)->code;\n\tstruct sock *sk;\n\tstruct sk_buff *skb;\n\tstruct request_sock *fastopen;\n\t__u32 seq, snd_una;\n\t__u32 remaining;\n\tint err;\n\tstruct net *net = dev_net(icmp_skb->dev);\n\n\tsk = __inet_lookup_established(net, &tcp_hashinfo, iph->daddr,\n\t\t\t\t       th->dest, iph->saddr, ntohs(th->source),\n\t\t\t\t       inet_iif(icmp_skb));\n\tif (!sk) {\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\t\treturn;\n\t}\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq,\n\t\t\t\t  type == ICMP_PARAMETERPROB ||\n\t\t\t\t  type == ICMP_TIME_EXCEEDED ||\n\t\t\t\t  (type == ICMP_DEST_UNREACH &&\n\t\t\t\t   (code == ICMP_NET_UNREACH ||\n\t\t\t\t    code == ICMP_HOST_UNREACH)));\n\n\tbh_lock_sock(sk);\n\t/* If too many ICMPs get dropped on busy\n\t * servers this needs to be solved differently.\n\t * We do take care of PMTU discovery (RFC1191) special case :\n\t * we can receive locally generated ICMP messages while socket is held.\n\t */\n\tif (sock_owned_by_user(sk)) {\n\t\tif (!(type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED))\n\t\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\t}\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ticsk = inet_csk(sk);\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ICMP_REDIRECT:\n\t\tdo_redirect(icmp_skb, sk);\n\t\tgoto out;\n\tcase ICMP_SOURCE_QUENCH:\n\t\t/* Just silently ignore these. */\n\t\tgoto out;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tgoto out;\n\n\t\tif (code == ICMP_FRAG_NEEDED) { /* PMTU discovery (RFC1191) */\n\t\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t\t * they should go through unfragmented).\n\t\t\t */\n\t\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\t\tgoto out;\n\n\t\t\ttp->mtu_info = info;\n\t\t\tif (!sock_owned_by_user(sk)) {\n\t\t\t\ttcp_v4_mtu_reduced(sk);\n\t\t\t} else {\n\t\t\t\tif (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED, &tp->tsq_flags))\n\t\t\t\t\tsock_hold(sk);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = icmp_err_convert[code].errno;\n\t\t/* check if icmp_skb allows revert of backoff\n\t\t * (see draft-zimmermann-tcp-lcd) */\n\t\tif (code != ICMP_NET_UNREACH && code != ICMP_HOST_UNREACH)\n\t\t\tbreak;\n\t\tif (seq != tp->snd_una  || !icsk->icsk_retransmits ||\n\t\t    !icsk->icsk_backoff || fastopen)\n\t\t\tbreak;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tbreak;\n\n\t\ticsk->icsk_backoff--;\n\t\ticsk->icsk_rto = tp->srtt_us ? __tcp_set_rto(tp) :\n\t\t\t\t\t       TCP_TIMEOUT_INIT;\n\t\ticsk->icsk_rto = inet_csk_rto_backoff(icsk, TCP_RTO_MAX);\n\n\t\tskb = tcp_write_queue_head(sk);\n\t\tBUG_ON(!skb);\n\n\t\tremaining = icsk->icsk_rto -\n\t\t\t    min(icsk->icsk_rto,\n\t\t\t\ttcp_time_stamp - tcp_skb_timestamp(skb));\n\n\t\tif (remaining) {\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t\t  remaining, TCP_RTO_MAX);\n\t\t} else {\n\t\t\t/* RTO revert clocked out retransmission.\n\t\t\t * Will retransmit now */\n\t\t\ttcp_retransmit_timer(sk);\n\t\t}\n\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\n\t\t\tsk->sk_error_report(sk);\n\n\t\t\ttcp_done(sk);\n\t\t} else {\n\t\t\tsk->sk_err_soft = err;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* If we've already connected we will keep trying\n\t * until we time out, or the user gives up.\n\t *\n\t * rfc1122 4.2.3.9 allows to consider as hard errors\n\t * only PROTO_UNREACH and PORT_UNREACH (well, FRAG_FAILED too,\n\t * but it is obsoleted by pmtu discovery).\n\t *\n\t * Note, that in modern internet, where routing is unreliable\n\t * and in each dark corner broken firewalls sit, sending random\n\t * errors ordered by their masters even this two messages finally lose\n\t * their original sense (even Linux sends invalid PORT_UNREACHs)\n\t *\n\t * Now we are in compliance with RFCs.\n\t *\t\t\t\t\t\t\t--ANK (980905)\n\t */\n\n\tinet = inet_sk(sk);\n\tif (!sock_owned_by_user(sk) && inet->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\t{ /* Only an error on timeout */\n\t\tsk->sk_err_soft = err;\n\t}\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nvoid __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr)\n{\n\tstruct tcphdr *th = tcp_hdr(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tth->check = ~tcp_v4_check(skb->len, saddr, daddr, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct tcphdr, check);\n\t} else {\n\t\tth->check = tcp_v4_check(skb->len, saddr, daddr,\n\t\t\t\t\t csum_partial(th,\n\t\t\t\t\t\t      th->doff << 2,\n\t\t\t\t\t\t      skb->csum));\n\t}\n}\n\n/* This routine computes an IPv4 TCP checksum. */\nvoid tcp_v4_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\n\t__tcp_v4_send_check(skb, inet->inet_saddr, inet->inet_daddr);\n}\nEXPORT_SYMBOL(tcp_v4_send_check);\n\n/*\n *\tThis routine will send an RST to the other tcp.\n *\n *\tSomeone asks: why I NEVER use socket parameters (TOS, TTL etc.)\n *\t\t      for reset.\n *\tAnswer: if a packet caused RST, it is not for a socket\n *\t\texisting in our system, if it is matched to a socket,\n *\t\tit is just duplicate segment or bug in other side's TCP.\n *\t\tSo that we build reply only basing on parameters\n *\t\tarrived with segment.\n *\tException: precedence violation. We do not implement it in any case.\n */\n\nstatic void tcp_v4_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct {\n\t\tstruct tcphdr th;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t__be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];\n#endif\n\t} rep;\n\tstruct ip_reply_arg arg;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key = NULL;\n\tconst __u8 *hash_location = NULL;\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tstruct net *net;\n\n\t/* Never send a reset in response to a reset. */\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && skb_rtable(skb)->rt_type != RTN_LOCAL)\n\t\treturn;\n\n\t/* Swap the send and the receive. */\n\tmemset(&rep, 0, sizeof(rep));\n\trep.th.dest   = th->source;\n\trep.th.source = th->dest;\n\trep.th.doff   = sizeof(struct tcphdr) / 4;\n\trep.th.rst    = 1;\n\n\tif (th->ack) {\n\t\trep.th.seq = th->ack_seq;\n\t} else {\n\t\trep.th.ack = 1;\n\t\trep.th.ack_seq = htonl(ntohl(th->seq) + th->syn + th->fin +\n\t\t\t\t       skb->len - (th->doff << 2));\n\t}\n\n\tmemset(&arg, 0, sizeof(arg));\n\targ.iov[0].iov_base = (unsigned char *)&rep;\n\targ.iov[0].iov_len  = sizeof(rep.th);\n\n\tnet = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tkey = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)\n\t\t\t\t\t&ip_hdr(skb)->saddr, AF_INET);\n\t} else if (hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = __inet_lookup_listener(net, &tcp_hashinfo, NULL, 0,\n\t\t\t\t\t     ip_hdr(skb)->saddr,\n\t\t\t\t\t     th->source, ip_hdr(skb)->daddr,\n\t\t\t\t\t     ntohs(th->source), inet_iif(skb));\n\t\t/* don't send rst if it can't find key */\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\tkey = tcp_md5_do_lookup(sk1, (union tcp_md5_addr *)\n\t\t\t\t\t&ip_hdr(skb)->saddr, AF_INET);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\n\t\tgenhash = tcp_v4_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\n\t}\n\n\tif (key) {\n\t\trep.opt[0] = htonl((TCPOPT_NOP << 24) |\n\t\t\t\t   (TCPOPT_NOP << 16) |\n\t\t\t\t   (TCPOPT_MD5SIG << 8) |\n\t\t\t\t   TCPOLEN_MD5SIG);\n\t\t/* Update length and the length the header thinks exists */\n\t\targ.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;\n\t\trep.th.doff = arg.iov[0].iov_len / 4;\n\n\t\ttcp_v4_md5_hash_hdr((__u8 *) &rep.opt[1],\n\t\t\t\t     key, ip_hdr(skb)->saddr,\n\t\t\t\t     ip_hdr(skb)->daddr, &rep.th);\n\t}\n#endif\n\targ.csum = csum_tcpudp_nofold(ip_hdr(skb)->daddr,\n\t\t\t\t      ip_hdr(skb)->saddr, /* XXX */\n\t\t\t\t      arg.iov[0].iov_len, IPPROTO_TCP, 0);\n\targ.csumoffset = offsetof(struct tcphdr, check) / 2;\n\targ.flags = (sk && inet_sk_transparent(sk)) ? IP_REPLY_ARG_NOSRCCHECK : 0;\n\n\t/* When socket is gone, all binding information is lost.\n\t * routing might fail in this case. No choice here, if we choose to force\n\t * input interface, we will misroute in case of asymmetric route.\n\t */\n\tif (sk)\n\t\targ.bound_dev_if = sk->sk_bound_dev_if;\n\n\tBUILD_BUG_ON(offsetof(struct sock, sk_bound_dev_if) !=\n\t\t     offsetof(struct inet_timewait_sock, tw_bound_dev_if));\n\n\targ.tos = ip_hdr(skb)->tos;\n\tlocal_bh_disable();\n\tip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),\n\t\t\t      skb, &TCP_SKB_CB(skb)->header.h4.opt,\n\t\t\t      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,\n\t\t\t      &arg, arg.iov[0].iov_len);\n\n\t__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t__TCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\tlocal_bh_enable();\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\n/* The code following below sending ACKs in SYN-RECV and TIME-WAIT states\n   outside socket context is ugly, certainly. What can I do?\n */\n\nstatic void tcp_v4_send_ack(struct net *net,\n\t\t\t    struct sk_buff *skb, u32 seq, u32 ack,\n\t\t\t    u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key,\n\t\t\t    int reply_flags, u8 tos)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct {\n\t\tstruct tcphdr th;\n\t\t__be32 opt[(TCPOLEN_TSTAMP_ALIGNED >> 2)\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\t   + (TCPOLEN_MD5SIG_ALIGNED >> 2)\n#endif\n\t\t\t];\n\t} rep;\n\tstruct ip_reply_arg arg;\n\n\tmemset(&rep.th, 0, sizeof(struct tcphdr));\n\tmemset(&arg, 0, sizeof(arg));\n\n\targ.iov[0].iov_base = (unsigned char *)&rep;\n\targ.iov[0].iov_len  = sizeof(rep.th);\n\tif (tsecr) {\n\t\trep.opt[0] = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t   (TCPOPT_TIMESTAMP << 8) |\n\t\t\t\t   TCPOLEN_TIMESTAMP);\n\t\trep.opt[1] = htonl(tsval);\n\t\trep.opt[2] = htonl(tsecr);\n\t\targ.iov[0].iov_len += TCPOLEN_TSTAMP_ALIGNED;\n\t}\n\n\t/* Swap the send and the receive. */\n\trep.th.dest    = th->source;\n\trep.th.source  = th->dest;\n\trep.th.doff    = arg.iov[0].iov_len / 4;\n\trep.th.seq     = htonl(seq);\n\trep.th.ack_seq = htonl(ack);\n\trep.th.ack     = 1;\n\trep.th.window  = htons(win);\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\tint offset = (tsecr) ? 3 : 0;\n\n\t\trep.opt[offset++] = htonl((TCPOPT_NOP << 24) |\n\t\t\t\t\t  (TCPOPT_NOP << 16) |\n\t\t\t\t\t  (TCPOPT_MD5SIG << 8) |\n\t\t\t\t\t  TCPOLEN_MD5SIG);\n\t\targ.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;\n\t\trep.th.doff = arg.iov[0].iov_len/4;\n\n\t\ttcp_v4_md5_hash_hdr((__u8 *) &rep.opt[offset],\n\t\t\t\t    key, ip_hdr(skb)->saddr,\n\t\t\t\t    ip_hdr(skb)->daddr, &rep.th);\n\t}\n#endif\n\targ.flags = reply_flags;\n\targ.csum = csum_tcpudp_nofold(ip_hdr(skb)->daddr,\n\t\t\t\t      ip_hdr(skb)->saddr, /* XXX */\n\t\t\t\t      arg.iov[0].iov_len, IPPROTO_TCP, 0);\n\targ.csumoffset = offsetof(struct tcphdr, check) / 2;\n\tif (oif)\n\t\targ.bound_dev_if = oif;\n\targ.tos = tos;\n\tlocal_bh_disable();\n\tip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),\n\t\t\t      skb, &TCP_SKB_CB(skb)->header.h4.opt,\n\t\t\t      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,\n\t\t\t      &arg, arg.iov[0].iov_len);\n\n\t__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\tlocal_bh_enable();\n}\n\nstatic void tcp_v4_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v4_send_ack(sock_net(sk), skb,\n\t\t\ttcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent,\n\t\t\ttw->tw_bound_dev_if,\n\t\t\ttcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_transparent ? IP_REPLY_ARG_NOSRCCHECK : 0,\n\t\t\ttw->tw_tos\n\t\t\t);\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v4_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\tu32 seq = (sk->sk_state == TCP_LISTEN) ? tcp_rsk(req)->snt_isn + 1 :\n\t\t\t\t\t     tcp_sk(sk)->snd_nxt;\n\n\t/* RFC 7323 2.3\n\t * The window field (SEG.WND) of every outgoing segment, with the\n\t * exception of <SYN> segments, MUST be right-shifted by\n\t * Rcv.Wind.Shift bits:\n\t */\n\ttcp_v4_send_ack(sock_net(sk), skb, seq,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp,\n\t\t\treq->ts_recent,\n\t\t\t0,\n\t\t\ttcp_md5_do_lookup(sk, (union tcp_md5_addr *)&ip_hdr(skb)->daddr,\n\t\t\t\t\t  AF_INET),\n\t\t\tinet_rsk(req)->no_srccheck ? IP_REPLY_ARG_NOSRCCHECK : 0,\n\t\t\tip_hdr(skb)->tos);\n}\n\n/*\n *\tSend a SYN-ACK after having received a SYN.\n *\tThis still operates on a request_sock only, not on a big\n *\tsocket.\n */\nstatic int tcp_v4_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct flowi4 fl4;\n\tint err = -1;\n\tstruct sk_buff *skb;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet_csk_route_req(sk, &fl4, req)) == NULL)\n\t\treturn -1;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v4_send_check(skb, ireq->ir_loc_addr, ireq->ir_rmt_addr);\n\n\t\terr = ip_build_and_send_pkt(skb, sk, ireq->ir_loc_addr,\n\t\t\t\t\t    ireq->ir_rmt_addr,\n\t\t\t\t\t    ireq->opt);\n\t\terr = net_xmit_eval(err);\n\t}\n\n\treturn err;\n}\n\n/*\n *\tIPv4 request_sock destructor.\n */\nstatic void tcp_v4_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->opt);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\n/*\n * RFC2385 MD5 checksumming requires a mapping of\n * IP address->MD5 Key.\n * We need to maintain these in the sk structure.\n */\n\n/* Find the Key structure for an address.  */\nstruct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_key *key;\n\tunsigned int size = sizeof(struct in_addr);\n\tconst struct tcp_md5sig_info *md5sig;\n\n\t/* caller either holds rcu_read_lock() or socket lock */\n\tmd5sig = rcu_dereference_check(tp->md5sig_info,\n\t\t\t\t       lockdep_sock_is_held(sk));\n\tif (!md5sig)\n\t\treturn NULL;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (family == AF_INET6)\n\t\tsize = sizeof(struct in6_addr);\n#endif\n\thlist_for_each_entry_rcu(key, &md5sig->head, node) {\n\t\tif (key->family != family)\n\t\t\tcontinue;\n\t\tif (!memcmp(&key->addr, addr, size))\n\t\t\treturn key;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_md5_do_lookup);\n\nstruct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,\n\t\t\t\t\t const struct sock *addr_sk)\n{\n\tconst union tcp_md5_addr *addr;\n\n\taddr = (const union tcp_md5_addr *)&addr_sk->sk_daddr;\n\treturn tcp_md5_do_lookup(sk, addr, AF_INET);\n}\nEXPORT_SYMBOL(tcp_v4_md5_lookup);\n\n/* This can be called on a newly created socket, from other files */\nint tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family, const u8 *newkey, u8 newkeylen, gfp_t gfp)\n{\n\t/* Add Key to the list */\n\tstruct tcp_md5sig_key *key;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_info *md5sig;\n\n\tkey = tcp_md5_do_lookup(sk, addr, family);\n\tif (key) {\n\t\t/* Pre-existing entry - just update that one. */\n\t\tmemcpy(key->key, newkey, newkeylen);\n\t\tkey->keylen = newkeylen;\n\t\treturn 0;\n\t}\n\n\tmd5sig = rcu_dereference_protected(tp->md5sig_info,\n\t\t\t\t\t   lockdep_sock_is_held(sk));\n\tif (!md5sig) {\n\t\tmd5sig = kmalloc(sizeof(*md5sig), gfp);\n\t\tif (!md5sig)\n\t\t\treturn -ENOMEM;\n\n\t\tsk_nocaps_add(sk, NETIF_F_GSO_MASK);\n\t\tINIT_HLIST_HEAD(&md5sig->head);\n\t\trcu_assign_pointer(tp->md5sig_info, md5sig);\n\t}\n\n\tkey = sock_kmalloc(sk, sizeof(*key), gfp);\n\tif (!key)\n\t\treturn -ENOMEM;\n\tif (!tcp_alloc_md5sig_pool()) {\n\t\tsock_kfree_s(sk, key, sizeof(*key));\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(key->key, newkey, newkeylen);\n\tkey->keylen = newkeylen;\n\tkey->family = family;\n\tmemcpy(&key->addr, addr,\n\t       (family == AF_INET6) ? sizeof(struct in6_addr) :\n\t\t\t\t      sizeof(struct in_addr));\n\thlist_add_head_rcu(&key->node, &md5sig->head);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_md5_do_add);\n\nint tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr, int family)\n{\n\tstruct tcp_md5sig_key *key;\n\n\tkey = tcp_md5_do_lookup(sk, addr, family);\n\tif (!key)\n\t\treturn -ENOENT;\n\thlist_del_rcu(&key->node);\n\tatomic_sub(sizeof(*key), &sk->sk_omem_alloc);\n\tkfree_rcu(key, rcu);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_md5_do_del);\n\nstatic void tcp_clear_md5_list(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_key *key;\n\tstruct hlist_node *n;\n\tstruct tcp_md5sig_info *md5sig;\n\n\tmd5sig = rcu_dereference_protected(tp->md5sig_info, 1);\n\n\thlist_for_each_entry_safe(key, n, &md5sig->head, node) {\n\t\thlist_del_rcu(&key->node);\n\t\tatomic_sub(sizeof(*key), &sk->sk_omem_alloc);\n\t\tkfree_rcu(key, rcu);\n\t}\n}\n\nstatic int tcp_v4_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen)\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin->sin_addr.s_addr,\n\t\t\t\t      AF_INET);\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin->sin_addr.s_addr,\n\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen,\n\t\t\t      GFP_KERNEL);\n}\n\nstatic int tcp_v4_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   __be32 daddr, __be32 saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp4_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\tbp->saddr = saddr;\n\tbp->daddr = daddr;\n\tbp->pad = 0;\n\tbp->protocol = IPPROTO_TCP;\n\tbp->len = cpu_to_be16(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       __be32 daddr, __be32 saddr, const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v4_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nint tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\tconst struct sock *sk,\n\t\t\tconst struct sk_buff *skb)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__be32 saddr, daddr;\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = sk->sk_rcv_saddr;\n\t\tdaddr = sk->sk_daddr;\n\t} else {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\t\tsaddr = iph->saddr;\n\t\tdaddr = iph->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v4_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\nEXPORT_SYMBOL(tcp_v4_md5_hash_skb);\n\n#endif\n\n/* Called with rcu_read_lock() */\nstatic bool tcp_v4_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\t/*\n\t * This gets called for each TCP segment that arrives\n\t * so we want to be efficient.\n\t * We have 3 drop cases:\n\t * o No MD5 hash and one expected.\n\t * o MD5 hash and we're not expecting one.\n\t * o MD5 hash and its wrong.\n\t */\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tunsigned char newhash[16];\n\n\thash_expected = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&iph->saddr,\n\t\t\t\t\t  AF_INET);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* Okay, so this is hash_expected and hash_location -\n\t * so we need to calculate the checksum.\n\t */\n\tgenhash = tcp_v4_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);\n\t\tnet_info_ratelimited(\"MD5 Hash failed for (%pI4, %d)->(%pI4, %d)%s\\n\",\n\t\t\t\t     &iph->saddr, ntohs(th->source),\n\t\t\t\t     &iph->daddr, ntohs(th->dest),\n\t\t\t\t     genhash ? \" tcp_v4_calc_md5_hash failed\"\n\t\t\t\t     : \"\");\n\t\treturn true;\n\t}\n\treturn false;\n#endif\n\treturn false;\n}\n\nstatic void tcp_v4_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\tsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\n\tsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\n\tireq->opt = tcp_v4_save_options(skb);\n}\n\nstatic struct dst_entry *tcp_v4_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req,\n\t\t\t\t\t  bool *strict)\n{\n\tstruct dst_entry *dst = inet_csk_route_req(sk, &fl->u.ip4, req);\n\n\tif (strict) {\n\t\tif (fl->u.ip4.daddr == inet_rsk(req)->ir_rmt_addr)\n\t\t\t*strict = true;\n\t\telse\n\t\t\t*strict = false;\n\t}\n\n\treturn dst;\n}\n\nstruct request_sock_ops tcp_request_sock_ops __read_mostly = {\n\t.family\t\t=\tPF_INET,\n\t.obj_size\t=\tsizeof(struct tcp_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v4_reqsk_send_ack,\n\t.destructor\t=\ttcp_v4_reqsk_destructor,\n\t.send_reset\t=\ttcp_v4_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv4_ops = {\n\t.mss_clamp\t=\tTCP_MSS_DEFAULT,\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v4_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v4_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v4_route_req,\n\t.init_seq\t=\ttcp_v4_init_sequence,\n\t.send_synack\t=\ttcp_v4_send_synack,\n};\n\nint tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\t/* Never answer to SYNs send to broadcast or multicast */\n\tif (skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv4_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_v4_conn_request);\n\n\n/*\n * The three way handshake has completed - we got a valid synack -\n * now create the new socket.\n */\nstruct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t  bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct ip_options_rcu *inet_opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto exit_nonewsk;\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV4;\n\tinet_sk_rx_dst_set(newsk, skb);\n\n\tnewtp\t\t      = tcp_sk(newsk);\n\tnewinet\t\t      = inet_sk(newsk);\n\tireq\t\t      = inet_rsk(req);\n\tsk_daddr_set(newsk, ireq->ir_rmt_addr);\n\tsk_rcv_saddr_set(newsk, ireq->ir_loc_addr);\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\tnewinet->inet_saddr\t      = ireq->ir_loc_addr;\n\tinet_opt\t      = ireq->opt;\n\trcu_assign_pointer(newinet->inet_opt, inet_opt);\n\tireq->opt\t      = NULL;\n\tnewinet->mc_index     = inet_iif(skb);\n\tnewinet->mc_ttl\t      = ip_hdr(skb)->ttl;\n\tnewinet->rcv_tos      = ip_hdr(skb)->tos;\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\tnewinet->inet_id = newtp->write_seq ^ jiffies;\n\n\tif (!dst) {\n\t\tdst = inet_csk_route_child_sock(sk, newsk, req);\n\t\tif (!dst)\n\t\t\tgoto put_and_exit;\n\t} else {\n\t\t/* syncookie case : see end of cookie_v4_check() */\n\t}\n\tsk_setup_caps(newsk, dst);\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&newinet->inet_daddr,\n\t\t\t\tAF_INET);\n\tif (key) {\n\t\t/*\n\t\t * We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newinet->inet_daddr,\n\t\t\t       AF_INET, key->key, key->keylen, GFP_ATOMIC);\n\t\tsk_nocaps_add(newsk, NETIF_F_GSO_MASK);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0)\n\t\tgoto put_and_exit;\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req)\n\t\ttcp_move_syn(newtp, req);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\ttcp_listendrop(sk);\n\treturn NULL;\nput_and_exit:\n\tinet_csk_prepare_forced_close(newsk);\n\ttcp_done(newsk);\n\tgoto exit;\n}\nEXPORT_SYMBOL(tcp_v4_syn_recv_sock);\n\nstatic struct sock *tcp_v4_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v4_check(sk, skb);\n#endif\n\treturn sk;\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nint tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sock *rsk;\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    !dst->ops->check(dst, 0)) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v4_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb)) {\n\t\t\t\trsk = nsk;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb)) {\n\t\trsk = sk;\n\t\tgoto reset;\n\t}\n\treturn 0;\n\nreset:\n\ttcp_v4_send_reset(rsk, skb);\ndiscard:\n\tkfree_skb(skb);\n\t/* Be careful here. If this function gets more complicated and\n\t * gcc suffers from register pressure on the x86, sk (in %ebx)\n\t * might be destroyed here. This current version compiles correctly,\n\t * but you have been warned.\n\t */\n\treturn 0;\n\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n}\nEXPORT_SYMBOL(tcp_v4_do_rcv);\n\nvoid tcp_v4_early_demux(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\tiph = ip_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\tsk = __inet_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t       iph->saddr, th->source,\n\t\t\t\t       iph->daddr, ntohs(th->dest),\n\t\t\t\t       skb->skb_iif);\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, 0);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\n/* Packet is added to VJ-style prequeue for processing in process\n * context, if a reader task is waiting. Apparently, this exciting\n * idea (VJ's mail \"Re: query about TCP header on tcp-ip\" of 07 Sep 93)\n * failed somewhere. Latency? Burstiness? Well, at least now we will\n * see, why it failed. 8)8)\t\t\t\t  --ANK\n *\n */\nbool tcp_prequeue(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (sysctl_tcp_low_latency || !tp->ucopy.task)\n\t\treturn false;\n\n\tif (skb->len <= tcp_hdrlen(skb) &&\n\t    skb_queue_len(&tp->ucopy.prequeue) == 0)\n\t\treturn false;\n\n\t/* Before escaping RCU protected region, we need to take care of skb\n\t * dst. Prequeue is only enabled for established sockets.\n\t * For such sockets, we might need the skb dst only to set sk->sk_rx_dst\n\t * Instead of doing full sk_rx_dst validity here, let's perform\n\t * an optimistic check.\n\t */\n\tif (likely(sk->sk_rx_dst))\n\t\tskb_dst_drop(skb);\n\telse\n\t\tskb_dst_force_safe(skb);\n\n\t__skb_queue_tail(&tp->ucopy.prequeue, skb);\n\ttp->ucopy.memory += skb->truesize;\n\tif (skb_queue_len(&tp->ucopy.prequeue) >= 32 ||\n\t    tp->ucopy.memory + atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf) {\n\t\tstruct sk_buff *skb1;\n\n\t\tBUG_ON(sock_owned_by_user(sk));\n\t\t__NET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPPREQUEUEDROPPED,\n\t\t\t\tskb_queue_len(&tp->ucopy.prequeue));\n\n\t\twhile ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != NULL)\n\t\t\tsk_backlog_rcv(sk, skb1);\n\n\t\ttp->ucopy.memory = 0;\n\t} else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {\n\t\twake_up_interruptible_sync_poll(sk_sleep(sk),\n\t\t\t\t\t   POLLIN | POLLRDNORM | POLLRDBAND);\n\t\tif (!inet_csk_ack_scheduled(sk))\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,\n\t\t\t\t\t\t  (3 * tcp_rto_min(sk)) / 4,\n\t\t\t\t\t\t  TCP_RTO_MAX);\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(tcp_prequeue);\n\nbool tcp_add_backlog(struct sock *sk, struct sk_buff *skb)\n{\n\tu32 limit = sk->sk_rcvbuf + sk->sk_sndbuf;\n\n\t/* Only socket owner can try to collapse/prune rx queues\n\t * to reduce memory overhead, so add a little headroom here.\n\t * Few sockets backlog are possibly concurrently non empty.\n\t */\n\tlimit += 64*1024;\n\n\t/* In case all data was pulled from skb frags (in __pskb_pull_tail()),\n\t * we can fix skb->truesize to its real value to avoid future drops.\n\t * This is valid because skb is not yet charged to the socket.\n\t * It has been noticed pure SACK packets were sometimes dropped\n\t * (if cooked by drivers without copybreak feature).\n\t */\n\tif (!skb->data_len)\n\t\tskb->truesize = SKB_TRUESIZE(skb_end_offset(skb));\n\n\tif (unlikely(sk_add_backlog(sk, skb, limit))) {\n\t\tbh_unlock_sock(sk);\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPBACKLOGDROP);\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(tcp_add_backlog);\n\nint tcp_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n\tunsigned int eaten = skb->len;\n\tint err;\n\n\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n\tif (!err) {\n\t\teaten -= skb->len;\n\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(tcp_filter);\n\n/*\n *\tFrom tcp_input.c\n */\n\nint tcp_v4_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/* Count it even if it's bad */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff * 4))\n\t\tgoto discard_it;\n\n\t/* An explanation is required here, I think.\n\t * Packet length and doff are validated by header prediction,\n\t * provided case of th->doff==0 is eliminated.\n\t * So, we defer the checks. */\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\t/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()\n\t * barrier() makes sure compiler wont play fool^Waliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\n\t\tsizeof(struct inet_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff * 4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\n\tTCP_SKB_CB(skb)->sacked\t = 0;\n\nlookup:\n\tsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\n\t\t\t       th->dest, &refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\t/* We own a reference on the listener, increase it again\n\t\t * as we might lose it too soon.\n\t\t */\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v4_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_v4_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tnf_reset(skb);\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v4_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v4_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\n\treturn ret;\n\nno_tcp_socket:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v4_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\t/* Discard frame. */\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN: {\n\t\tstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n\t\t\t\t\t\t\t&tcp_hashinfo, skb,\n\t\t\t\t\t\t\t__tcp_hdrlen(th),\n\t\t\t\t\t\t\tiph->saddr, th->source,\n\t\t\t\t\t\t\tiph->daddr, th->dest,\n\t\t\t\t\t\t\tinet_iif(skb));\n\t\tif (sk2) {\n\t\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v4_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v4_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:;\n\t}\n\tgoto discard_it;\n}\n\nstatic struct timewait_sock_ops tcp_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor= tcp_twsk_destructor,\n};\n\nvoid inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t}\n}\nEXPORT_SYMBOL(inet_sk_rx_dst_set);\n\nconst struct inet_connection_sock_af_ops ipv4_specific = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v4_conn_request,\n\t.syn_recv_sock\t   = tcp_v4_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.addr2sockaddr\t   = inet_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in),\n\t.bind_conflict\t   = inet_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ip_setsockopt,\n\t.compat_getsockopt = compat_ip_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\nEXPORT_SYMBOL(ipv4_specific);\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv4_specific = {\n\t.md5_lookup\t\t= tcp_v4_md5_lookup,\n\t.calc_md5_hash\t\t= tcp_v4_md5_hash_skb,\n\t.md5_parse\t\t= tcp_v4_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v4_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv4_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv4_specific;\n#endif\n\n\treturn 0;\n}\n\nvoid tcp_v4_destroy_sock(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_clear_xmit_timers(sk);\n\n\ttcp_cleanup_congestion_control(sk);\n\n\t/* Cleanup up the write buffer. */\n\ttcp_write_queue_purge(sk);\n\n\t/* Cleans up our, hopefully empty, out_of_order_queue. */\n\tskb_rbtree_purge(&tp->out_of_order_queue);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Clean up the MD5 key list, if any */\n\tif (tp->md5sig_info) {\n\t\ttcp_clear_md5_list(sk);\n\t\tkfree_rcu(tp->md5sig_info, rcu);\n\t\ttp->md5sig_info = NULL;\n\t}\n#endif\n\n\t/* Clean prequeue, it must be empty really */\n\t__skb_queue_purge(&tp->ucopy.prequeue);\n\n\t/* Clean up a referenced TCP bind bucket. */\n\tif (inet_csk(sk)->icsk_bind_hash)\n\t\tinet_put_port(sk);\n\n\tBUG_ON(tp->fastopen_rsk);\n\n\t/* If socket is aborted during connect operation */\n\ttcp_free_fastopen_req(tp);\n\ttcp_saved_syn_free(tp);\n\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tlocal_bh_enable();\n}\nEXPORT_SYMBOL(tcp_v4_destroy_sock);\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCP sock list dumping. */\n\n/*\n * Get next listener socket follow cur.  If cur is NULL, get first socket\n * starting from bucket given in st->bucket; when st->bucket is zero the\n * very first socket in the hash table is returned.\n */\nstatic void *listening_get_next(struct seq_file *seq, void *cur)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct inet_listen_hashbucket *ilb;\n\tstruct sock *sk = cur;\n\n\tif (!sk) {\nget_head:\n\t\tilb = &tcp_hashinfo.listening_hash[st->bucket];\n\t\tspin_lock_bh(&ilb->lock);\n\t\tsk = sk_head(&ilb->head);\n\t\tst->offset = 0;\n\t\tgoto get_sk;\n\t}\n\tilb = &tcp_hashinfo.listening_hash[st->bucket];\n\t++st->num;\n\t++st->offset;\n\n\tsk = sk_next(sk);\nget_sk:\n\tsk_for_each_from(sk) {\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\t\tif (sk->sk_family == st->family)\n\t\t\treturn sk;\n\t}\n\tspin_unlock_bh(&ilb->lock);\n\tst->offset = 0;\n\tif (++st->bucket < INET_LHTABLE_SIZE)\n\t\tgoto get_head;\n\treturn NULL;\n}\n\nstatic void *listening_get_idx(struct seq_file *seq, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc;\n\n\tst->bucket = 0;\n\tst->offset = 0;\n\trc = listening_get_next(seq, NULL);\n\n\twhile (rc && *pos) {\n\t\trc = listening_get_next(seq, rc);\n\t\t--*pos;\n\t}\n\treturn rc;\n}\n\nstatic inline bool empty_bucket(const struct tcp_iter_state *st)\n{\n\treturn hlist_nulls_empty(&tcp_hashinfo.ehash[st->bucket].chain);\n}\n\n/*\n * Get first established socket starting from bucket given in st->bucket.\n * If st->bucket is zero, the very first socket in the hash is returned.\n */\nstatic void *established_get_first(struct seq_file *seq)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tvoid *rc = NULL;\n\n\tst->offset = 0;\n\tfor (; st->bucket <= tcp_hashinfo.ehash_mask; ++st->bucket) {\n\t\tstruct sock *sk;\n\t\tstruct hlist_nulls_node *node;\n\t\tspinlock_t *lock = inet_ehash_lockp(&tcp_hashinfo, st->bucket);\n\n\t\t/* Lockless fast path for the common case of empty buckets */\n\t\tif (empty_bucket(st))\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(lock);\n\t\tsk_nulls_for_each(sk, node, &tcp_hashinfo.ehash[st->bucket].chain) {\n\t\t\tif (sk->sk_family != st->family ||\n\t\t\t    !net_eq(sock_net(sk), net)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trc = sk;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock_bh(lock);\n\t}\nout:\n\treturn rc;\n}\n\nstatic void *established_get_next(struct seq_file *seq, void *cur)\n{\n\tstruct sock *sk = cur;\n\tstruct hlist_nulls_node *node;\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\t++st->num;\n\t++st->offset;\n\n\tsk = sk_nulls_next(sk);\n\n\tsk_nulls_for_each_from(sk, node) {\n\t\tif (sk->sk_family == st->family && net_eq(sock_net(sk), net))\n\t\t\treturn sk;\n\t}\n\n\tspin_unlock_bh(inet_ehash_lockp(&tcp_hashinfo, st->bucket));\n\t++st->bucket;\n\treturn established_get_first(seq);\n}\n\nstatic void *established_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc;\n\n\tst->bucket = 0;\n\trc = established_get_first(seq);\n\n\twhile (rc && pos) {\n\t\trc = established_get_next(seq, rc);\n\t\t--pos;\n\t}\n\treturn rc;\n}\n\nstatic void *tcp_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tvoid *rc;\n\tstruct tcp_iter_state *st = seq->private;\n\n\tst->state = TCP_SEQ_STATE_LISTENING;\n\trc\t  = listening_get_idx(seq, &pos);\n\n\tif (!rc) {\n\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\trc\t  = established_get_idx(seq, pos);\n\t}\n\n\treturn rc;\n}\n\nstatic void *tcp_seek_last_pos(struct seq_file *seq)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tint offset = st->offset;\n\tint orig_num = st->num;\n\tvoid *rc = NULL;\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\tif (st->bucket >= INET_LHTABLE_SIZE)\n\t\t\tbreak;\n\t\tst->state = TCP_SEQ_STATE_LISTENING;\n\t\trc = listening_get_next(seq, NULL);\n\t\twhile (offset-- && rc)\n\t\t\trc = listening_get_next(seq, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tst->bucket = 0;\n\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\t/* Fallthrough */\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\tif (st->bucket > tcp_hashinfo.ehash_mask)\n\t\t\tbreak;\n\t\trc = established_get_first(seq);\n\t\twhile (offset-- && rc)\n\t\t\trc = established_get_next(seq, rc);\n\t}\n\n\tst->num = orig_num;\n\n\treturn rc;\n}\n\nstatic void *tcp_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc;\n\n\tif (*pos && *pos == st->last_pos) {\n\t\trc = tcp_seek_last_pos(seq);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tst->state = TCP_SEQ_STATE_LISTENING;\n\tst->num = 0;\n\tst->bucket = 0;\n\tst->offset = 0;\n\trc = *pos ? tcp_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n\nout:\n\tst->last_pos = *pos;\n\treturn rc;\n}\n\nstatic void *tcp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc = NULL;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\trc = tcp_get_idx(seq, 0);\n\t\tgoto out;\n\t}\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\trc = listening_get_next(seq, v);\n\t\tif (!rc) {\n\t\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\t\tst->bucket = 0;\n\t\t\tst->offset = 0;\n\t\t\trc\t  = established_get_first(seq);\n\t\t}\n\t\tbreak;\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\trc = established_get_next(seq, v);\n\t\tbreak;\n\t}\nout:\n\t++*pos;\n\tst->last_pos = *pos;\n\treturn rc;\n}\n\nstatic void tcp_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\tif (v != SEQ_START_TOKEN)\n\t\t\tspin_unlock_bh(&tcp_hashinfo.listening_hash[st->bucket].lock);\n\t\tbreak;\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\tif (v)\n\t\t\tspin_unlock_bh(inet_ehash_lockp(&tcp_hashinfo, st->bucket));\n\t\tbreak;\n\t}\n}\n\nint tcp_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct tcp_seq_afinfo *afinfo = PDE_DATA(inode);\n\tstruct tcp_iter_state *s;\n\tint err;\n\n\terr = seq_open_net(inode, file, &afinfo->seq_ops,\n\t\t\t  sizeof(struct tcp_iter_state));\n\tif (err < 0)\n\t\treturn err;\n\n\ts = ((struct seq_file *)file->private_data)->private;\n\ts->family\t\t= afinfo->family;\n\ts->last_pos\t\t= 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_seq_open);\n\nint tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo)\n{\n\tint rc = 0;\n\tstruct proc_dir_entry *p;\n\n\tafinfo->seq_ops.start\t\t= tcp_seq_start;\n\tafinfo->seq_ops.next\t\t= tcp_seq_next;\n\tafinfo->seq_ops.stop\t\t= tcp_seq_stop;\n\n\tp = proc_create_data(afinfo->name, S_IRUGO, net->proc_net,\n\t\t\t     afinfo->seq_fops, afinfo);\n\tif (!p)\n\t\trc = -ENOMEM;\n\treturn rc;\n}\nEXPORT_SYMBOL(tcp_proc_register);\n\nvoid tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo)\n{\n\tremove_proc_entry(afinfo->name, net->proc_net);\n}\nEXPORT_SYMBOL(tcp_proc_unregister);\n\nstatic void get_openreq4(const struct request_sock *req,\n\t\t\t struct seq_file *f, int i)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tlong delta = req->rsk_timer.expires - jiffies;\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %u %d %pK\",\n\t\ti,\n\t\tireq->ir_loc_addr,\n\t\tireq->ir_num,\n\t\tireq->ir_rmt_addr,\n\t\tntohs(ireq->ir_rmt_port),\n\t\tTCP_SYN_RECV,\n\t\t0, 0, /* could print option size, but that is af dependent. */\n\t\t1,    /* timers active (only the expire timer) */\n\t\tjiffies_delta_to_clock_t(delta),\n\t\treq->num_timeout,\n\t\tfrom_kuid_munged(seq_user_ns(f),\n\t\t\t\t sock_i_uid(req->rsk_listener)),\n\t\t0,  /* non standard timer */\n\t\t0, /* open_requests have no inode */\n\t\t0,\n\t\treq);\n}\n\nstatic void get_tcp4_sock(struct sock *sk, struct seq_file *f, int i)\n{\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src = inet->inet_rcv_saddr;\n\t__u16 destp = ntohs(inet->inet_dport);\n\t__u16 srcp = ntohs(inet->inet_sport);\n\tint rx_queue;\n\tint state;\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sk->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sk->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sk);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sk->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X %02X %08X:%08X %02X:%08lX \"\n\t\t\t\"%08X %5u %8d %lu %d %pK %lu %lu %u %u %d\",\n\t\ti, src, srcp, dest, destp, state,\n\t\ttp->write_seq - tp->snd_una,\n\t\trx_queue,\n\t\ttimer_active,\n\t\tjiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\ticsk->icsk_retransmits,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sk)),\n\t\ticsk->icsk_probes_out,\n\t\tsock_i_ino(sk),\n\t\tatomic_read(&sk->sk_refcnt), sk,\n\t\tjiffies_to_clock_t(icsk->icsk_rto),\n\t\tjiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t(icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\ttp->snd_cwnd,\n\t\tstate == TCP_LISTEN ?\n\t\t    fastopenq->max_qlen :\n\t\t    (tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh));\n}\n\nstatic void get_timewait4_sock(const struct inet_timewait_sock *tw,\n\t\t\t       struct seq_file *f, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\t__be32 dest, src;\n\t__u16 destp, srcp;\n\n\tdest  = tw->tw_daddr;\n\tsrc   = tw->tw_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\",\n\t\ti, src, srcp, dest, destp, tw->tw_substate, 0, 0,\n\t\t3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\tatomic_read(&tw->tw_refcnt), tw);\n}\n\n#define TMPSZ 150\n\nstatic int tcp4_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tseq_setwidth(seq, TMPSZ - 1);\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t   \"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t   \"inode\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait4_sock(v, seq, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq4(v, seq, st->num);\n\telse\n\t\tget_tcp4_sock(v, seq, st->num);\nout:\n\tseq_pad(seq, '\\n');\n\treturn 0;\n}\n\nstatic const struct file_operations tcp_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp4_seq_afinfo = {\n\t.name\t\t= \"tcp\",\n\t.family\t\t= AF_INET,\n\t.seq_fops\t= &tcp_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp4_seq_show,\n\t},\n};\n\nstatic int __net_init tcp4_proc_init_net(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp4_seq_afinfo);\n}\n\nstatic void __net_exit tcp4_proc_exit_net(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp4_seq_afinfo);\n}\n\nstatic struct pernet_operations tcp4_net_ops = {\n\t.init = tcp4_proc_init_net,\n\t.exit = tcp4_proc_exit_net,\n};\n\nint __init tcp4_proc_init(void)\n{\n\treturn register_pernet_subsys(&tcp4_net_ops);\n}\n\nvoid tcp4_proc_exit(void)\n{\n\tunregister_pernet_subsys(&tcp4_net_ops);\n}\n#endif /* CONFIG_PROC_FS */\n\nstruct proto tcp_prot = {\n\t.name\t\t\t= \"TCP\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v4_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v4_init_sock,\n\t.destroy\t\t= tcp_v4_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v4_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n\t.diag_destroy\t\t= tcp_abort,\n};\nEXPORT_SYMBOL(tcp_prot);\n\nstatic void __net_exit tcp_sk_exit(struct net *net)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinet_ctl_sock_destroy(*per_cpu_ptr(net->ipv4.tcp_sk, cpu));\n\tfree_percpu(net->ipv4.tcp_sk);\n}\n\nstatic int __net_init tcp_sk_init(struct net *net)\n{\n\tint res, cpu;\n\n\tnet->ipv4.tcp_sk = alloc_percpu(struct sock *);\n\tif (!net->ipv4.tcp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct sock *sk;\n\n\t\tres = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,\n\t\t\t\t\t   IPPROTO_TCP, net);\n\t\tif (res)\n\t\t\tgoto fail;\n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\t\t*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;\n\t}\n\n\tnet->ipv4.sysctl_tcp_ecn = 2;\n\tnet->ipv4.sysctl_tcp_ecn_fallback = 1;\n\n\tnet->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;\n\tnet->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;\n\tnet->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;\n\n\tnet->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;\n\tnet->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;\n\tnet->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;\n\n\tnet->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;\n\tnet->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;\n\tnet->ipv4.sysctl_tcp_syncookies = 1;\n\tnet->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;\n\tnet->ipv4.sysctl_tcp_retries1 = TCP_RETR1;\n\tnet->ipv4.sysctl_tcp_retries2 = TCP_RETR2;\n\tnet->ipv4.sysctl_tcp_orphan_retries = 0;\n\tnet->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;\n\tnet->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;\n\n\treturn 0;\nfail:\n\ttcp_sk_exit(net);\n\n\treturn res;\n}\n\nstatic void __net_exit tcp_sk_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET);\n}\n\nstatic struct pernet_operations __net_initdata tcp_sk_ops = {\n       .init\t   = tcp_sk_init,\n       .exit\t   = tcp_sk_exit,\n       .exit_batch = tcp_sk_exit_batch,\n};\n\nvoid __init tcp_v4_init(void)\n{\n\tinet_hashinfo_init(&tcp_hashinfo);\n\tif (register_pernet_subsys(&tcp_sk_ops))\n\t\tpanic(\"Failed to create the TCP control socket.\\n\");\n}\n", "/*\n *\tTCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on:\n *\tlinux/net/ipv4/tcp.c\n *\tlinux/net/ipv4/tcp_input.c\n *\tlinux/net/ipv4/tcp_output.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *\tYOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/tcp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nstatic int\ttcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t\tinet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic __u32 tcp_v6_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t    ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t    tcp_hdr(skb)->dest,\n\t\t\t\t\t    tcp_hdr(skb)->source);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t/*\n\t *\tconnect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 0x1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq = 0;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t *\tTCP over IPv4\n\t */\n\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &ipv6_mapped;\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &ipv6_specific;\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp &&\n\t    ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr))\n\t\ttcp_fetch_timewait_stamp(sk, dst);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n\t\t\t\t\t opt->opt_nflen;\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (!tp->write_seq && likely(!tp->repair))\n\t\ttp->write_seq = secure_tcpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t\t     sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t\t     inet->inet_sport,\n\t\t\t\t\t\t\t     inet->inet_dport);\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, tcp_sk(sk)->mtu_info);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq, fatal);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\tif (dst)\n\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &tp->tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, fl6, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn tcp_md5_do_lookup(sk, (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n}\n\nstatic int tcp_v6_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\t/* 1. TCP pseudo-header (RFC2460) */\n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic bool tcp_v6_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tu8 newhash[16];\n\n\thash_expected = tcp_v6_md5_do_lookup(sk, &ip6h->saddr);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* check the signature */\n\tgenhash = tcp_v6_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);\n\t\tnet_info_ratelimited(\"MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t\t     genhash ? \"failed\" : \"mismatch\",\n\t\t\t\t     &ip6h->saddr, ntohs(th->source),\n\t\t\t\t     &ip6h->daddr, ntohs(th->dest));\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req,\n\t\t\t\t\t  bool *strict)\n{\n\tif (strict)\n\t\t*strict = true;\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v6_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_sequence,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, __be32 label)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\tstruct dst_entry *dst;\n\t__be32 *topt;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\tbuff = alloc_skb(MAX_HEADER + sizeof(struct ipv6hdr) + tot_len,\n\t\t\t GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);\n\n\tt1 = (struct tcphdr *) skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t/* Swap the send and the receive. */\n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\tbuff->csum = 0;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse {\n\t\tif (!oif && netif_index_is_l3_master(net, skb->skb_iif))\n\t\t\toif = skb->skb_iif;\n\n\t\tfl6.flowi6_oif = oif;\n\t}\n\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\t/* Pass a socket to ip6_dst_lookup either it is for RST\n\t * Underlying function will use this to retrieve the network\n\t * namespace\n\t */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, NULL, tclass);\n\t\tTCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tint oif;\n\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tkey = tcp_v6_md5_do_lookup(sk, &ipv6h->saddr);\n\t} else if (hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = inet6_lookup_listener(dev_net(skb_dst(skb)->dev),\n\t\t\t\t\t   &tcp_hashinfo, NULL, 0,\n\t\t\t\t\t   &ipv6h->saddr,\n\t\t\t\t\t   th->source, &ipv6h->daddr,\n\t\t\t\t\t   ntohs(th->source), tcp_v6_iif(skb));\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\toif = sk ? sk->sk_bound_dev_if : 0;\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    __be32 label)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\t/* RFC 7323 2.3\n\t * The window field (SEG.WND) of every outgoing segment, with the\n\t * exception of <SYN> segments, MUST be right-shifted by\n\t * Rcv.Wind.Shift bits:\n\t */\n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),\n\t\t\t0, 0);\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0; /* don't send reset */\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_mask(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_mask(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\ttcp_listendrop(sk);\n\treturn NULL;\n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t/* We need to move header back to the beginning if xfrm6_policy_check()\n\t * and tcp_v6_fill_cb() are going to be called again.\n\t * ip6_datagram_recv_specific_ctl() also expects IP6CB to be there.\n\t */\n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t/* This is tricky: we move IP6CB at its correct location into\n\t * TCP_SKB_CB(). It must be done after xfrm6_policy_check(), because\n\t * _decode_session6() uses IP6CB().\n\t * barrier() makes sure compiler won't play aliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n}\n\nstatic int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr)/4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb),\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nstatic void tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t/* Note : We use inet6_iif() here, not tcp_v6_iif() */\n\tsk = __inet6_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nstatic const struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/*\n *\tTCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\nstatic void tcp_v6_destroy_sock(struct sock *sk)\n{\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCPv6 sock list dumping. */\nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0, /* could print option size, but that is af dependent. */\n\t\t   1,   /* timers active (only the expire timer) */\n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,  /* non standard timer */\n\t\t   0, /* open_requests have no inode */\n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sp->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   tp->write_seq - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\t   tp->snd_cwnd,\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct file_operations tcp6_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.name\t\t= \"tcp6\",\n\t.family\t\t= AF_INET6,\n\t.seq_fops\t= &tcp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp6_seq_show,\n\t},\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp6_seq_afinfo);\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}\n#endif\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v6_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet6_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n\t.diag_destroy\t\t= tcp_abort,\n};\n\nstatic const struct inet6_protocol tcpv6_protocol = {\n\t.early_demux\t=\ttcp_v6_early_demux,\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n"], "filenames": ["include/net/tcp.h", "net/ipv4/tcp_ipv4.c", "net/ipv6/tcp_ipv6.c"], "buggy_code_start_loc": [1222, 1565, 1232], "buggy_code_end_loc": [1222, 1680, 1461], "fixing_code_start_loc": [1223, 1566, 1232], "fixing_code_end_loc": [1224, 1698, 1464], "type": "CWE-284", "message": "The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c.", "other": {"cve": {"id": "CVE-2016-8645", "sourceIdentifier": "secalert@redhat.com", "published": "2016-11-28T03:59:07.767", "lastModified": "2023-02-12T23:26:16.897", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c."}, {"lang": "es", "value": "La pila TCP en el kernel Linux en versiones anteriores a 4.8.10 maneja incorrectamente el truncamiento skb, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda de sistema) a trav\u00e9s de una aplicaci\u00f3n manipulada que hace llamadas de sistema sendto, relacionado con net/ipv4/tcp_ipv4.c y net/ipv6/tcp_ipv6.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.9", "matchCriteriaId": "8D8EDE04-A798-4EE3-84ED-0363CF212B69"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ac6e780070e30e4c35bd395acfe9191e6268bdd3", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory", "Patch"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.8.10", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/11/3", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/30/3", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/94264", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037285", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1393904", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3"}}