{"buggy_code": ["/*\n * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/* ====================================================================\n * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n *\n * Portions of the attached software (\"Contribution\") are developed by\n * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.\n *\n * The Contribution is licensed pursuant to the OpenSSL open source\n * license provided above.\n *\n * ECC cipher suite support in OpenSSL originally written by\n * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.\n *\n */\n/* ====================================================================\n * Copyright 2005 Nokia. All rights reserved.\n *\n * The portions of the attached software (\"Contribution\") is developed by\n * Nokia Corporation and is licensed pursuant to the OpenSSL open source\n * license.\n *\n * The Contribution, originally written by Mika Kousa and Pasi Eronen of\n * Nokia Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites\n * support (see RFC 4279) to OpenSSL.\n *\n * No patent licenses or other rights except those expressly stated in\n * the OpenSSL open source license shall be deemed granted or received\n * expressly, by implication, estoppel, or otherwise.\n *\n * No assurances are provided by Nokia that the Contribution does not\n * infringe the patent or other intellectual property rights of any third\n * party or that the license provides you with all the necessary rights\n * to make use of the Contribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN\n * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA\n * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY\n * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR\n * OTHERWISE.\n */\n\n#include <stdio.h>\n#include \"../ssl_locl.h\"\n#include \"statem_locl.h\"\n#include <openssl/buffer.h>\n#include <openssl/rand.h>\n#include <openssl/objects.h>\n#include <openssl/evp.h>\n#include <openssl/md5.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <openssl/engine.h>\n\nstatic ossl_inline int cert_req_allowed(SSL *s);\nstatic int key_exchange_expected(SSL *s);\nstatic int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b);\nstatic int ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk,\n                                    unsigned char *p);\n\n/*\n * Is a CertificateRequest message allowed at the moment or not?\n *\n *  Return values are:\n *  1: Yes\n *  0: No\n */\nstatic ossl_inline int cert_req_allowed(SSL *s)\n{\n    /* TLS does not like anon-DH with client cert */\n    if ((s->version > SSL3_VERSION\n         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))\n        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))\n        return 0;\n\n    return 1;\n}\n\n/*\n * Should we expect the ServerKeyExchange message or not?\n *\n *  Return values are:\n *  1: Yes\n *  0: No\n */\nstatic int key_exchange_expected(SSL *s)\n{\n    long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    /*\n     * Can't skip server key exchange if this is an ephemeral\n     * ciphersuite or for SRP\n     */\n    if (alg_k & (SSL_kDHE | SSL_kECDHE | SSL_kDHEPSK | SSL_kECDHEPSK\n                 | SSL_kSRP)) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/*\n * ossl_statem_client_read_transition() encapsulates the logic for the allowed\n * handshake state transitions when the client is reading messages from the\n * server. The message type that the server has sent is provided in |mt|. The\n * current state is in |s->statem.hand_state|.\n *\n *  Return values are:\n *  1: Success (transition allowed)\n *  0: Error (transition not allowed)\n */\nint ossl_statem_client_read_transition(SSL *s, int mt)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ske_expected;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        if (mt == SSL3_MT_SERVER_HELLO) {\n            st->hand_state = TLS_ST_CR_SRVR_HELLO;\n            return 1;\n        }\n\n        if (SSL_IS_DTLS(s)) {\n            if (mt == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n                st->hand_state = DTLS_ST_CR_HELLO_VERIFY_REQUEST;\n                return 1;\n            }\n        }\n        break;\n\n    case TLS_ST_CR_SRVR_HELLO:\n        if (s->hit) {\n            if (s->tlsext_ticket_expected) {\n                if (mt == SSL3_MT_NEWSESSION_TICKET) {\n                    st->hand_state = TLS_ST_CR_SESSION_TICKET;\n                    return 1;\n                }\n            } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n                st->hand_state = TLS_ST_CR_CHANGE;\n                return 1;\n            }\n        } else {\n            if (SSL_IS_DTLS(s) && mt == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n                st->hand_state = DTLS_ST_CR_HELLO_VERIFY_REQUEST;\n                return 1;\n            } else if (s->version >= TLS1_VERSION\n                       && s->tls_session_secret_cb != NULL\n                       && s->session->tlsext_tick != NULL\n                       && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n                /*\n                 * Normally, we can tell if the server is resuming the session\n                 * from the session ID. EAP-FAST (RFC 4851), however, relies on\n                 * the next server message after the ServerHello to determine if\n                 * the server is resuming.\n                 */\n                s->hit = 1;\n                st->hand_state = TLS_ST_CR_CHANGE;\n                return 1;\n            } else if (!(s->s3->tmp.new_cipher->algorithm_auth\n                         & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {\n                if (mt == SSL3_MT_CERTIFICATE) {\n                    st->hand_state = TLS_ST_CR_CERT;\n                    return 1;\n                }\n            } else {\n                ske_expected = key_exchange_expected(s);\n                /* SKE is optional for some PSK ciphersuites */\n                if (ske_expected\n                    || ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)\n                        && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {\n                    if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {\n                        st->hand_state = TLS_ST_CR_KEY_EXCH;\n                        return 1;\n                    }\n                } else if (mt == SSL3_MT_CERTIFICATE_REQUEST\n                           && cert_req_allowed(s)) {\n                    st->hand_state = TLS_ST_CR_CERT_REQ;\n                    return 1;\n                } else if (mt == SSL3_MT_SERVER_DONE) {\n                    st->hand_state = TLS_ST_CR_SRVR_DONE;\n                    return 1;\n                }\n            }\n        }\n        break;\n\n    case TLS_ST_CR_CERT:\n        /*\n         * The CertificateStatus message is optional even if\n         * |tlsext_status_expected| is set\n         */\n        if (s->tlsext_status_expected && mt == SSL3_MT_CERTIFICATE_STATUS) {\n            st->hand_state = TLS_ST_CR_CERT_STATUS;\n            return 1;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_CERT_STATUS:\n        ske_expected = key_exchange_expected(s);\n        /* SKE is optional for some PSK ciphersuites */\n        if (ske_expected || ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)\n                             && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {\n            if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {\n                st->hand_state = TLS_ST_CR_KEY_EXCH;\n                return 1;\n            }\n            goto err;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_KEY_EXCH:\n        if (mt == SSL3_MT_CERTIFICATE_REQUEST) {\n            if (cert_req_allowed(s)) {\n                st->hand_state = TLS_ST_CR_CERT_REQ;\n                return 1;\n            }\n            goto err;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_CERT_REQ:\n        if (mt == SSL3_MT_SERVER_DONE) {\n            st->hand_state = TLS_ST_CR_SRVR_DONE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CW_FINISHED:\n        if (s->tlsext_ticket_expected) {\n            if (mt == SSL3_MT_NEWSESSION_TICKET) {\n                st->hand_state = TLS_ST_CR_SESSION_TICKET;\n                return 1;\n            }\n        } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CR_SESSION_TICKET:\n        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CR_CHANGE:\n        if (mt == SSL3_MT_FINISHED) {\n            st->hand_state = TLS_ST_CR_FINISHED;\n            return 1;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n err:\n    /* No valid transition found */\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL3_AD_UNEXPECTED_MESSAGE);\n    SSLerr(SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;\n}\n\n/*\n * client_write_transition() works out what handshake state to move to next\n * when the client is writing messages to be sent to the server.\n */\nWRITE_TRAN ossl_statem_client_write_transition(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_OK:\n        /* Renegotiation - fall through */\n    case TLS_ST_BEFORE:\n        st->hand_state = TLS_ST_CW_CLNT_HELLO;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CLNT_HELLO:\n        /*\n         * No transition at the end of writing because we don't know what\n         * we will be sent\n         */\n        return WRITE_TRAN_FINISHED;\n\n    case DTLS_ST_CR_HELLO_VERIFY_REQUEST:\n        st->hand_state = TLS_ST_CW_CLNT_HELLO;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CR_SRVR_DONE:\n        if (s->s3->tmp.cert_req)\n            st->hand_state = TLS_ST_CW_CERT;\n        else\n            st->hand_state = TLS_ST_CW_KEY_EXCH;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CERT:\n        st->hand_state = TLS_ST_CW_KEY_EXCH;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_KEY_EXCH:\n        /*\n         * For TLS, cert_req is set to 2, so a cert chain of nothing is\n         * sent, but no verify packet is sent\n         */\n        /*\n         * XXX: For now, we do not support client authentication in ECDH\n         * cipher suites with ECDH (rather than ECDSA) certificates. We\n         * need to skip the certificate verify message when client's\n         * ECDH public key is sent inside the client certificate.\n         */\n        if (s->s3->tmp.cert_req == 1) {\n            st->hand_state = TLS_ST_CW_CERT_VRFY;\n        } else {\n            st->hand_state = TLS_ST_CW_CHANGE;\n        }\n        if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n            st->hand_state = TLS_ST_CW_CHANGE;\n        }\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CERT_VRFY:\n        st->hand_state = TLS_ST_CW_CHANGE;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CHANGE:\n#if defined(OPENSSL_NO_NEXTPROTONEG)\n        st->hand_state = TLS_ST_CW_FINISHED;\n#else\n        if (!SSL_IS_DTLS(s) && s->s3->next_proto_neg_seen)\n            st->hand_state = TLS_ST_CW_NEXT_PROTO;\n        else\n            st->hand_state = TLS_ST_CW_FINISHED;\n#endif\n        return WRITE_TRAN_CONTINUE;\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    case TLS_ST_CW_NEXT_PROTO:\n        st->hand_state = TLS_ST_CW_FINISHED;\n        return WRITE_TRAN_CONTINUE;\n#endif\n\n    case TLS_ST_CW_FINISHED:\n        if (s->hit) {\n            st->hand_state = TLS_ST_OK;\n            ossl_statem_set_in_init(s, 0);\n            return WRITE_TRAN_CONTINUE;\n        } else {\n            return WRITE_TRAN_FINISHED;\n        }\n\n    case TLS_ST_CR_FINISHED:\n        if (s->hit) {\n            st->hand_state = TLS_ST_CW_CHANGE;\n            return WRITE_TRAN_CONTINUE;\n        } else {\n            st->hand_state = TLS_ST_OK;\n            ossl_statem_set_in_init(s, 0);\n            return WRITE_TRAN_CONTINUE;\n        }\n\n    default:\n        /* Shouldn't happen */\n        return WRITE_TRAN_ERROR;\n    }\n}\n\n/*\n * Perform any pre work that needs to be done prior to sending a message from\n * the client to the server.\n */\nWORK_STATE ossl_statem_client_pre_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s)) {\n            /* every DTLS ClientHello resets Finished MAC */\n            if (!ssl3_init_finished_mac(s)) {\n                ossl_statem_set_error(s);\n                return WORK_ERROR;\n            }\n        }\n        break;\n\n    case TLS_ST_CW_CHANGE:\n        if (SSL_IS_DTLS(s)) {\n            if (s->hit) {\n                /*\n                 * We're into the last flight so we don't retransmit these\n                 * messages unless we need to.\n                 */\n                st->use_timer = 0;\n            }\n#ifndef OPENSSL_NO_SCTP\n            if (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n                return dtls_wait_for_dry(s);\n#endif\n        }\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_OK:\n        return tls_finish_handshake(s, wst);\n\n    default:\n        /* No pre work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}\n\n/*\n * Perform any work that needs to be done after sending a message from the\n * client to the server.\n */\nWORK_STATE ossl_statem_client_post_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    s->init_num = 0;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        if (wst == WORK_MORE_A && statem_flush(s) != 1)\n            return WORK_MORE_A;\n\n        if (SSL_IS_DTLS(s)) {\n            /* Treat the next message as the first packet */\n            s->first_packet = 1;\n        }\n        break;\n\n    case TLS_ST_CW_KEY_EXCH:\n        if (tls_client_key_exchange_post_work(s) == 0)\n            return WORK_ERROR;\n        break;\n\n    case TLS_ST_CW_CHANGE:\n        s->session->cipher = s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n        s->session->compress_meth = 0;\n#else\n        if (s->s3->tmp.new_compression == NULL)\n            s->session->compress_meth = 0;\n        else\n            s->session->compress_meth = s->s3->tmp.new_compression->id;\n#endif\n        if (!s->method->ssl3_enc->setup_key_block(s))\n            return WORK_ERROR;\n\n        if (!s->method->ssl3_enc->change_cipher_state(s,\n                                                      SSL3_CHANGE_CIPHER_CLIENT_WRITE))\n            return WORK_ERROR;\n\n        if (SSL_IS_DTLS(s)) {\n#ifndef OPENSSL_NO_SCTP\n            if (s->hit) {\n                /*\n                 * Change to new shared key of SCTP-Auth, will be ignored if\n                 * no SCTP used.\n                 */\n                BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY,\n                         0, NULL);\n            }\n#endif\n\n            dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);\n        }\n        break;\n\n    case TLS_ST_CW_FINISHED:\n#ifndef OPENSSL_NO_SCTP\n        if (wst == WORK_MORE_A && SSL_IS_DTLS(s) && s->hit == 0) {\n            /*\n             * Change to new shared key of SCTP-Auth, will be ignored if\n             * no SCTP used.\n             */\n            BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY,\n                     0, NULL);\n        }\n#endif\n        if (statem_flush(s) != 1)\n            return WORK_MORE_B;\n        break;\n\n    default:\n        /* No post work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}\n\n/*\n * Construct a message to be sent from the client to the server.\n *\n * Valid return values are:\n *   1: Success\n *   0: Error\n */\nint ossl_statem_client_construct_message(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        return tls_construct_client_hello(s);\n\n    case TLS_ST_CW_CERT:\n        return tls_construct_client_certificate(s);\n\n    case TLS_ST_CW_KEY_EXCH:\n        return tls_construct_client_key_exchange(s);\n\n    case TLS_ST_CW_CERT_VRFY:\n        return tls_construct_client_verify(s);\n\n    case TLS_ST_CW_CHANGE:\n        if (SSL_IS_DTLS(s))\n            return dtls_construct_change_cipher_spec(s);\n        else\n            return tls_construct_change_cipher_spec(s);\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    case TLS_ST_CW_NEXT_PROTO:\n        return tls_construct_next_proto(s);\n#endif\n    case TLS_ST_CW_FINISHED:\n        return tls_construct_finished(s,\n                                      s->method->\n                                      ssl3_enc->client_finished_label,\n                                      s->method->\n                                      ssl3_enc->client_finished_label_len);\n\n    default:\n        /* Shouldn't happen */\n        break;\n    }\n\n    return 0;\n}\n\n/*\n * Returns the maximum allowed length for the current message that we are\n * reading. Excludes the message header.\n */\nunsigned long ossl_statem_client_max_message_size(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CR_SRVR_HELLO:\n        return SERVER_HELLO_MAX_LENGTH;\n\n    case DTLS_ST_CR_HELLO_VERIFY_REQUEST:\n        return HELLO_VERIFY_REQUEST_MAX_LENGTH;\n\n    case TLS_ST_CR_CERT:\n        return s->max_cert_list;\n\n    case TLS_ST_CR_CERT_STATUS:\n        return SSL3_RT_MAX_PLAIN_LENGTH;\n\n    case TLS_ST_CR_KEY_EXCH:\n        return SERVER_KEY_EXCH_MAX_LENGTH;\n\n    case TLS_ST_CR_CERT_REQ:\n        /*\n         * Set to s->max_cert_list for compatibility with previous releases. In\n         * practice these messages can get quite long if servers are configured\n         * to provide a long list of acceptable CAs\n         */\n        return s->max_cert_list;\n\n    case TLS_ST_CR_SRVR_DONE:\n        return SERVER_HELLO_DONE_MAX_LENGTH;\n\n    case TLS_ST_CR_CHANGE:\n        if (s->version == DTLS1_BAD_VER)\n            return 3;\n        return CCS_MAX_LENGTH;\n\n    case TLS_ST_CR_SESSION_TICKET:\n        return SSL3_RT_MAX_PLAIN_LENGTH;\n\n    case TLS_ST_CR_FINISHED:\n        return FINISHED_MAX_LENGTH;\n\n    default:\n        /* Shouldn't happen */\n        break;\n    }\n\n    return 0;\n}\n\n/*\n * Process a message that the client has been received from the server.\n */\nMSG_PROCESS_RETURN ossl_statem_client_process_message(SSL *s, PACKET *pkt)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CR_SRVR_HELLO:\n        return tls_process_server_hello(s, pkt);\n\n    case DTLS_ST_CR_HELLO_VERIFY_REQUEST:\n        return dtls_process_hello_verify(s, pkt);\n\n    case TLS_ST_CR_CERT:\n        return tls_process_server_certificate(s, pkt);\n\n    case TLS_ST_CR_CERT_STATUS:\n        return tls_process_cert_status(s, pkt);\n\n    case TLS_ST_CR_KEY_EXCH:\n        return tls_process_key_exchange(s, pkt);\n\n    case TLS_ST_CR_CERT_REQ:\n        return tls_process_certificate_request(s, pkt);\n\n    case TLS_ST_CR_SRVR_DONE:\n        return tls_process_server_done(s, pkt);\n\n    case TLS_ST_CR_CHANGE:\n        return tls_process_change_cipher_spec(s, pkt);\n\n    case TLS_ST_CR_SESSION_TICKET:\n        return tls_process_new_session_ticket(s, pkt);\n\n    case TLS_ST_CR_FINISHED:\n        return tls_process_finished(s, pkt);\n\n    default:\n        /* Shouldn't happen */\n        break;\n    }\n\n    return MSG_PROCESS_ERROR;\n}\n\n/*\n * Perform any further processing required following the receipt of a message\n * from the server\n */\nWORK_STATE ossl_statem_client_post_process_message(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CR_CERT_REQ:\n        return tls_prepare_client_certificate(s, wst);\n\n#ifndef OPENSSL_NO_SCTP\n    case TLS_ST_CR_SRVR_DONE:\n        /* We only get here if we are using SCTP and we are renegotiating */\n        if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {\n            s->s3->in_read_app_data = 2;\n            s->rwstate = SSL_READING;\n            BIO_clear_retry_flags(SSL_get_rbio(s));\n            BIO_set_retry_read(SSL_get_rbio(s));\n            ossl_statem_set_sctp_read_sock(s, 1);\n            return WORK_MORE_A;\n        }\n        ossl_statem_set_sctp_read_sock(s, 0);\n        return WORK_FINISHED_STOP;\n#endif\n\n    default:\n        break;\n    }\n\n    /* Shouldn't happen */\n    return WORK_ERROR;\n}\n\nint tls_construct_client_hello(SSL *s)\n{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    int protverr;\n    unsigned long l;\n    int al = 0;\n#ifndef OPENSSL_NO_COMP\n    int j;\n    SSL_COMP *comp;\n#endif\n    SSL_SESSION *sess = s->session;\n\n    buf = (unsigned char *)s->init_buf->data;\n\n    /* Work out what SSL/TLS/DTLS version to use */\n    protverr = ssl_set_client_hello_version(s);\n    if (protverr != 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, protverr);\n        goto err;\n    }\n\n    if ((sess == NULL) || !ssl_version_supported(s, sess->ssl_version) ||\n        /*\n         * In the case of EAP-FAST, we can have a pre-shared\n         * \"ticket\" without a session ID.\n         */\n        (!sess->session_id_length && !sess->tlsext_tick) ||\n        (sess->not_resumable)) {\n        if (!ssl_get_new_session(s, 0))\n            goto err;\n    }\n    /* else use the pre-loaded session */\n\n    p = s->s3->client_random;\n\n    /*\n     * for DTLS if client_random is initialized, reuse it, we are\n     * required to use same upon reply to HelloVerify\n     */\n    if (SSL_IS_DTLS(s)) {\n        size_t idx;\n        i = 1;\n        for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n            if (p[idx]) {\n                i = 0;\n                break;\n            }\n        }\n    } else\n        i = 1;\n\n    if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random)) <= 0)\n        goto err;\n\n    /* Do the message type and length last */\n    d = p = ssl_handshake_start(s);\n\n    /*-\n     * version indicates the negotiated version: for example from\n     * an SSLv2/v3 compatible client hello). The client_version\n     * field is the maximum version we permit and it is also\n     * used in RSA encrypted premaster secrets. Some servers can\n     * choke if we initially report a higher version then\n     * renegotiate to a lower one in the premaster secret. This\n     * didn't happen with TLS 1.0 as most servers supported it\n     * but it can with TLS 1.1 or later if the server only supports\n     * 1.0.\n     *\n     * Possible scenario with previous logic:\n     *      1. Client hello indicates TLS 1.2\n     *      2. Server hello says TLS 1.0\n     *      3. RSA encrypted premaster secret uses 1.2.\n     *      4. Handshake proceeds using TLS 1.0.\n     *      5. Server sends hello request to renegotiate.\n     *      6. Client hello indicates TLS v1.0 as we now\n     *         know that is maximum server supports.\n     *      7. Server chokes on RSA encrypted premaster secret\n     *         containing version 1.0.\n     *\n     * For interoperability it should be OK to always use the\n     * maximum version we support in client hello and then rely\n     * on the checking of version to ensure the servers isn't\n     * being inconsistent: for example initially negotiating with\n     * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n     * client_version in client hello and not resetting it to\n     * the negotiated version.\n     */\n    *(p++) = s->client_version >> 8;\n    *(p++) = s->client_version & 0xff;\n\n    /* Random stuff */\n    memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n\n    /* Session ID */\n    if (s->new_session)\n        i = 0;\n    else\n        i = s->session->session_id_length;\n    *(p++) = i;\n    if (i != 0) {\n        if (i > (int)sizeof(s->session->session_id)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        memcpy(p, s->session->session_id, i);\n        p += i;\n    }\n\n    /* cookie stuff for DTLS */\n    if (SSL_IS_DTLS(s)) {\n        if (s->d1->cookie_len > sizeof(s->d1->cookie)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        *(p++) = s->d1->cookie_len;\n        memcpy(p, s->d1->cookie, s->d1->cookie_len);\n        p += s->d1->cookie_len;\n    }\n\n    /* Ciphers supported */\n    i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]));\n    if (i == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);\n        goto err;\n    }\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n    /*\n     * Some servers hang if client hello > 256 bytes as hack workaround\n     * chop number of supported ciphers to keep it well below this if we\n     * use TLS v1.2\n     */\n    if (TLS1_get_version(s) >= TLS1_2_VERSION\n        && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n        i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n    s2n(i, p);\n    p += i;\n\n    /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n    *(p++) = 1;\n#else\n\n    if (!ssl_allow_compression(s) || !s->ctx->comp_methods)\n        j = 0;\n    else\n        j = sk_SSL_COMP_num(s->ctx->comp_methods);\n    *(p++) = 1 + j;\n    for (i = 0; i < j; i++) {\n        comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n        *(p++) = comp->id;\n    }\n#endif\n    *(p++) = 0;                 /* Add the NULL method */\n\n    /* TLS extensions */\n    if (ssl_prepare_clienthello_tlsext(s) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n        goto err;\n    }\n    if ((p =\n         ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,\n                                    &al)) == NULL) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    l = p - d;\n    if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    return 1;\n err:\n    ossl_statem_set_error(s);\n    return 0;\n}\n\nMSG_PROCESS_RETURN dtls_process_hello_verify(SSL *s, PACKET *pkt)\n{\n    int al;\n    unsigned int cookie_len;\n    PACKET cookiepkt;\n\n    if (!PACKET_forward(pkt, 2)\n        || !PACKET_get_length_prefixed_1(pkt, &cookiepkt)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_DTLS_PROCESS_HELLO_VERIFY, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    cookie_len = PACKET_remaining(&cookiepkt);\n    if (cookie_len > sizeof(s->d1->cookie)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_DTLS_PROCESS_HELLO_VERIFY, SSL_R_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    if (!PACKET_copy_bytes(&cookiepkt, s->d1->cookie, cookie_len)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_DTLS_PROCESS_HELLO_VERIFY, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    s->d1->cookie_len = cookie_len;\n\n    return MSG_PROCESS_FINISHED_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_server_hello(SSL *s, PACKET *pkt)\n{\n    STACK_OF(SSL_CIPHER) *sk;\n    const SSL_CIPHER *c;\n    PACKET session_id;\n    size_t session_id_len;\n    const unsigned char *cipherchars;\n    int i, al = SSL_AD_INTERNAL_ERROR;\n    unsigned int compression;\n    unsigned int sversion;\n    int protverr;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n\n    if (!PACKET_get_net_2(pkt, &sversion)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    protverr = ssl_choose_client_version(s, sversion);\n    if (protverr != 0) {\n        al = SSL_AD_PROTOCOL_VERSION;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, protverr);\n        goto f_err;\n    }\n\n    /* load the server hello data */\n    /* load the server random */\n    if (!PACKET_copy_bytes(pkt, s->s3->server_random, SSL3_RANDOM_SIZE)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    s->hit = 0;\n\n    /* Get the session-id. */\n    if (!PACKET_get_length_prefixed_1(pkt, &session_id)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    session_id_len = PACKET_remaining(&session_id);\n    if (session_id_len > sizeof s->session->session_id\n        || session_id_len > SSL3_SESSION_ID_SIZE) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);\n        goto f_err;\n    }\n\n    if (!PACKET_get_bytes(pkt, &cipherchars, TLS_CIPHER_LEN)) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n\n    /*\n     * Check if we can resume the session based on external pre-shared secret.\n     * EAP-FAST (RFC 4851) supports two types of session resumption.\n     * Resumption based on server-side state works with session IDs.\n     * Resumption based on pre-shared Protected Access Credentials (PACs)\n     * works by overriding the SessionTicket extension at the application\n     * layer, and does not send a session ID. (We do not know whether EAP-FAST\n     * servers would honour the session ID.) Therefore, the session ID alone\n     * is not a reliable indicator of session resumption, so we first check if\n     * we can resume, and later peek at the next handshake message to see if the\n     * server wants to resume.\n     */\n    if (s->version >= TLS1_VERSION && s->tls_session_secret_cb &&\n        s->session->tlsext_tick) {\n        const SSL_CIPHER *pref_cipher = NULL;\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length,\n                                     NULL, &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->session->cipher = pref_cipher ?\n                pref_cipher : ssl_get_cipher_by_char(s, cipherchars);\n        } else {\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    }\n\n    if (session_id_len != 0 && session_id_len == s->session->session_id_length\n        && memcmp(PACKET_data(&session_id), s->session->session_id,\n                  session_id_len) == 0) {\n        if (s->sid_ctx_length != s->session->sid_ctx_length\n            || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {\n            /* actually a client application bug */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n                   SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n            goto f_err;\n        }\n        s->hit = 1;\n    } else {\n        /*\n         * If we were trying for session-id reuse but the server\n         * didn't echo the ID, make a new SSL_SESSION.\n         * In the case of EAP-FAST and PAC, we do not send a session ID,\n         * so the PAC-based session secret is always preserved. It'll be\n         * overwritten if the server refuses resumption.\n         */\n        if (s->session->session_id_length > 0) {\n            s->ctx->stats.sess_miss++;\n            if (!ssl_get_new_session(s, 0)) {\n                goto f_err;\n            }\n        }\n\n        s->session->ssl_version = s->version;\n        s->session->session_id_length = session_id_len;\n        /* session_id_len could be 0 */\n        memcpy(s->session->session_id, PACKET_data(&session_id),\n               session_id_len);\n    }\n\n    /* Session version and negotiated protocol version should match */\n    if (s->version != s->session->ssl_version) {\n        al = SSL_AD_PROTOCOL_VERSION;\n\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_SSL_SESSION_VERSION_MISMATCH);\n        goto f_err;\n    }\n\n    c = ssl_get_cipher_by_char(s, cipherchars);\n    if (c == NULL) {\n        /* unknown cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);\n        goto f_err;\n    }\n    /*\n     * Now that we know the version, update the check to see if it's an allowed\n     * version.\n     */\n    s->s3->tmp.min_ver = s->version;\n    s->s3->tmp.max_ver = s->version;\n    /*\n     * If it is a disabled cipher we either didn't send it in client hello,\n     * or it's not allowed for the selected protocol. So we return an error.\n     */\n    if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    sk = ssl_get_ciphers_by_id(s);\n    i = sk_SSL_CIPHER_find(sk, c);\n    if (i < 0) {\n        /* we did not say we would use this cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    /*\n     * Depending on the session caching (internal/external), the cipher\n     * and/or cipher_id values may not be set. Make sure that cipher_id is\n     * set and use it for comparison.\n     */\n    if (s->session->cipher)\n        s->session->cipher_id = s->session->cipher->id;\n    if (s->hit && (s->session->cipher_id != c->id)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n        goto f_err;\n    }\n    s->s3->tmp.new_cipher = c;\n    /* lets get the compression algorithm */\n    /* COMPRESSION */\n    if (!PACKET_get_1(pkt, &compression)) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n#ifdef OPENSSL_NO_COMP\n    if (compression != 0) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    }\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#else\n    if (s->hit && compression != s->session->compress_meth) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n        goto f_err;\n    }\n    if (compression == 0)\n        comp = NULL;\n    else if (!ssl_allow_compression(s)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);\n        goto f_err;\n    } else {\n        comp = ssl3_comp_find(s->ctx->comp_methods, compression);\n    }\n\n    if (compression != 0 && comp == NULL) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    } else {\n        s->s3->tmp.new_compression = comp;\n    }\n#endif\n\n    /* TLS extensions */\n    if (!ssl_parse_serverhello_tlsext(s, pkt)) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_PARSE_TLSEXT);\n        goto err;\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        /* wrong packet length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && s->hit) {\n        unsigned char sctpauthkey[64];\n        char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];\n\n        /*\n         * Add new shared key for SCTP-Auth, will be ignored if\n         * no SCTP used.\n         */\n        memcpy(labelbuffer, DTLS1_SCTP_AUTH_LABEL,\n               sizeof(DTLS1_SCTP_AUTH_LABEL));\n\n        if (SSL_export_keying_material(s, sctpauthkey,\n                                       sizeof(sctpauthkey),\n                                       labelbuffer,\n                                       sizeof(labelbuffer), NULL, 0, 0) <= 0)\n            goto err;\n\n        BIO_ctrl(SSL_get_wbio(s),\n                 BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n                 sizeof(sctpauthkey), sctpauthkey);\n    }\n#endif\n\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_server_certificate(SSL *s, PACKET *pkt)\n{\n    int al, i, ret = MSG_PROCESS_ERROR, exp_idx;\n    unsigned long cert_list_len, cert_len;\n    X509 *x = NULL;\n    const unsigned char *certstart, *certbytes;\n    STACK_OF(X509) *sk = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!PACKET_get_net_3(pkt, &cert_list_len)\n        || PACKET_remaining(pkt) != cert_list_len) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    while (PACKET_remaining(pkt)) {\n        if (!PACKET_get_net_3(pkt, &cert_len)\n            || !PACKET_get_bytes(pkt, &certbytes, cert_len)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n        certstart = certbytes;\n        x = d2i_X509(NULL, (const unsigned char **)&certbytes, cert_len);\n        if (x == NULL) {\n            al = SSL_AD_BAD_CERTIFICATE;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto f_err;\n        }\n        if (certbytes != (certstart + cert_len)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if (!sk_X509_push(sk, x)) {\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        x = NULL;\n    }\n\n    i = ssl_verify_cert_chain(s, sk);\n    /*\n     * The documented interface is that SSL_VERIFY_PEER should be set in order\n     * for client side verification of the server certificate to take place.\n     * However, historically the code has only checked that *any* flag is set\n     * to cause server verification to take place. Use of the other flags makes\n     * no sense in client mode. An attempt to clean up the semantics was\n     * reverted because at least one application *only* set\n     * SSL_VERIFY_FAIL_IF_NO_PEER_CERT. Prior to the clean up this still caused\n     * server verification to take place, after the clean up it silently did\n     * nothing. SSL_CTX_set_verify()/SSL_set_verify() cannot validate the flags\n     * sent to them because they are void functions. Therefore, we now use the\n     * (less clean) historic behaviour of performing validation if any flag is\n     * set. The *documented* interface remains the same.\n     */\n    if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n        al = ssl_verify_alarm_type(s->verify_result);\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_CERTIFICATE_VERIFY_FAILED);\n        goto f_err;\n    }\n    ERR_clear_error();          /* but we keep s->verify_result */\n    if (i > 1) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, i);\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        goto f_err;\n    }\n\n    s->session->peer_chain = sk;\n    /*\n     * Inconsistency alert: cert_chain does include the peer's certificate,\n     * which we don't include in statem_srvr.c\n     */\n    x = sk_X509_value(sk, 0);\n    sk = NULL;\n    /*\n     * VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @end\n     */\n\n    pkey = X509_get0_pubkey(x);\n\n    if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n        x = NULL;\n        al = SSL3_AL_FATAL;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n        goto f_err;\n    }\n\n    i = ssl_cert_type(x, pkey);\n    if (i < 0) {\n        x = NULL;\n        al = SSL3_AL_FATAL;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n        goto f_err;\n    }\n\n    exp_idx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);\n    if (exp_idx >= 0 && i != exp_idx\n        && (exp_idx != SSL_PKEY_GOST_EC ||\n            (i != SSL_PKEY_GOST12_512 && i != SSL_PKEY_GOST12_256\n             && i != SSL_PKEY_GOST01))) {\n        x = NULL;\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_WRONG_CERTIFICATE_TYPE);\n        goto f_err;\n    }\n    s->session->peer_type = i;\n\n    X509_free(s->session->peer);\n    X509_up_ref(x);\n    s->session->peer = x;\n    s->session->verify_result = s->verify_result;\n\n    x = NULL;\n    ret = MSG_PROCESS_CONTINUE_READING;\n    goto done;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n done:\n    X509_free(x);\n    sk_X509_pop_free(sk, X509_free);\n    return ret;\n}\n\nstatic int tls_process_ske_psk_preamble(SSL *s, PACKET *pkt, int *al)\n{\n#ifndef OPENSSL_NO_PSK\n    PACKET psk_identity_hint;\n\n    /* PSK ciphersuites are preceded by an identity hint */\n\n    if (!PACKET_get_length_prefixed_2(pkt, &psk_identity_hint)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    /*\n     * Store PSK identity hint for later use, hint is used in\n     * tls_construct_client_key_exchange.  Assume that the maximum length of\n     * a PSK identity hint can be as long as the maximum length of a PSK\n     * identity.\n     */\n    if (PACKET_remaining(&psk_identity_hint) > PSK_MAX_IDENTITY_LEN) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE, SSL_R_DATA_LENGTH_TOO_LONG);\n        return 0;\n    }\n\n    if (PACKET_remaining(&psk_identity_hint) == 0) {\n        OPENSSL_free(s->session->psk_identity_hint);\n        s->session->psk_identity_hint = NULL;\n    } else if (!PACKET_strndup(&psk_identity_hint,\n                               &s->session->psk_identity_hint)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_process_ske_srp(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)\n{\n#ifndef OPENSSL_NO_SRP\n    PACKET prime, generator, salt, server_pub;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_1(pkt, &salt)\n        || !PACKET_get_length_prefixed_2(pkt, &server_pub)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    if ((s->srp_ctx.N =\n         BN_bin2bn(PACKET_data(&prime),\n                   PACKET_remaining(&prime), NULL)) == NULL\n        || (s->srp_ctx.g =\n            BN_bin2bn(PACKET_data(&generator),\n                      PACKET_remaining(&generator), NULL)) == NULL\n        || (s->srp_ctx.s =\n            BN_bin2bn(PACKET_data(&salt),\n                      PACKET_remaining(&salt), NULL)) == NULL\n        || (s->srp_ctx.B =\n            BN_bin2bn(PACKET_data(&server_pub),\n                      PACKET_remaining(&server_pub), NULL)) == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, ERR_R_BN_LIB);\n        return 0;\n    }\n\n    if (!srp_verify_server_param(s, al)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, SSL_R_BAD_SRP_PARAMETERS);\n        return 0;\n    }\n\n    /* We must check if there is a certificate */\n    if (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    p = BN_bin2bn(PACKET_data(&prime), PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), PACKET_remaining(&generator), NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key), PACKET_remaining(&pub_key),\n                          NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    if (BN_is_zero(p) || BN_is_zero(g) || BN_is_zero(bnpub_key)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, DH_security_bits(dh), 0, dh)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    s->s3->peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_process_ske_ecdhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    PACKET encoded_pt;\n    const unsigned char *ecparams;\n    int curve_nid;\n    unsigned int curve_flags;\n    EVP_PKEY_CTX *pctx = NULL;\n\n    /*\n     * Extract elliptic curve parameters and the server's ephemeral ECDH\n     * public key. For now we only support named (not generic) curves and\n     * ECParameters in this case is just three bytes.\n     */\n    if (!PACKET_get_bytes(pkt, &ecparams, 3)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_LENGTH_TOO_SHORT);\n        return 0;\n    }\n    /*\n     * Check curve is one of our preferences, if not server has sent an\n     * invalid curve. ECParameters is 3 bytes.\n     */\n    if (!tls1_check_curve(s, ecparams, 3)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_WRONG_CURVE);\n        return 0;\n    }\n\n    curve_nid = tls1_ec_curve_id2nid(*(ecparams + 2), &curve_flags);\n\n    if (curve_nid == 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE,\n               SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n        return 0;\n    }\n\n    if ((curve_flags & TLS_CURVE_TYPE) == TLS_CURVE_CUSTOM) {\n        EVP_PKEY *key = EVP_PKEY_new();\n\n        if (key == NULL || !EVP_PKEY_set_type(key, curve_nid)) {\n            *al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_EVP_LIB);\n            EVP_PKEY_free(key);\n            return 0;\n        }\n        s->s3->peer_tmp = key;\n    } else {\n        /* Set up EVP_PKEY with named curve as parameters */\n        pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);\n        if (pctx == NULL\n            || EVP_PKEY_paramgen_init(pctx) <= 0\n            || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, curve_nid) <= 0\n            || EVP_PKEY_paramgen(pctx, &s->s3->peer_tmp) <= 0) {\n            *al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_EVP_LIB);\n            EVP_PKEY_CTX_free(pctx);\n            return 0;\n        }\n        EVP_PKEY_CTX_free(pctx);\n        pctx = NULL;\n    }\n\n    if (!PACKET_get_length_prefixed_1(pkt, &encoded_pt)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    if (!EVP_PKEY_set1_tls_encodedpoint(s->s3->peer_tmp,\n                                        PACKET_data(&encoded_pt),\n                                        PACKET_remaining(&encoded_pt))) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_BAD_ECPOINT);\n        return 0;\n    }\n\n    /*\n     * The ECC/TLS specification does not mention the use of DSA to sign\n     * ECParameters in the server key exchange message. We do support RSA\n     * and ECDSA.\n     */\n    if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aECDSA)\n        *pkey = X509_get0_pubkey(s->session->peer);\n    else if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aRSA)\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous ECDH, so no certificate or pkey. */\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nMSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)\n{\n    int al = -1;\n    long alg_k;\n    EVP_PKEY *pkey = NULL;\n    PACKET save_param_start, signature;\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    save_param_start = *pkt;\n\n#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)\n    EVP_PKEY_free(s->s3->peer_tmp);\n    s->s3->peer_tmp = NULL;\n#endif\n\n    if (alg_k & SSL_PSK) {\n        if (!tls_process_ske_psk_preamble(s, pkt, &al))\n            goto err;\n    }\n\n    /* Nothing else to do for plain PSK or RSAPSK */\n    if (alg_k & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_ske_srp(s, pkt, &pkey, &al))\n            goto err;\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_ske_dhe(s, pkt, &pkey, &al))\n            goto err;\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_ske_ecdhe(s, pkt, &pkey, &al))\n            goto err;\n    } else if (alg_k) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        PACKET params;\n        int maxsig;\n        const EVP_MD *md = NULL;\n        EVP_MD_CTX *md_ctx;\n\n        /*\n         * |pkt| now points to the beginning of the signature, so the difference\n         * equals the length of the parameters.\n         */\n        if (!PACKET_get_sub_packet(&save_param_start, &params,\n                                   PACKET_remaining(&save_param_start) -\n                                   PACKET_remaining(pkt))) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (SSL_USE_SIGALGS(s)) {\n            const unsigned char *sigalgs;\n            int rv;\n            if (!PACKET_get_bytes(pkt, &sigalgs, 2)) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n                goto err;\n            }\n            rv = tls12_check_peer_sigalg(&md, s, sigalgs, pkey);\n            if (rv == -1) {\n                al = SSL_AD_INTERNAL_ERROR;\n                goto err;\n            } else if (rv == 0) {\n                al = SSL_AD_DECODE_ERROR;\n                goto err;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n        } else if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA) {\n            md = EVP_md5_sha1();\n        } else {\n            md = EVP_sha1();\n        }\n\n        if (!PACKET_get_length_prefixed_2(pkt, &signature)\n            || PACKET_remaining(pkt) != 0) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n        maxsig = EVP_PKEY_size(pkey);\n        if (maxsig < 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        /*\n         * Check signature length\n         */\n        if (PACKET_remaining(&signature) > (size_t)maxsig) {\n            /* wrong packet length */\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                   SSL_R_WRONG_SIGNATURE_LENGTH);\n            goto err;\n        }\n\n        md_ctx = EVP_MD_CTX_new();\n        if (md_ctx == NULL) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (EVP_VerifyInit_ex(md_ctx, md, NULL) <= 0\n            || EVP_VerifyUpdate(md_ctx, &(s->s3->client_random[0]),\n                                SSL3_RANDOM_SIZE) <= 0\n            || EVP_VerifyUpdate(md_ctx, &(s->s3->server_random[0]),\n                                SSL3_RANDOM_SIZE) <= 0\n            || EVP_VerifyUpdate(md_ctx, PACKET_data(&params),\n                                PACKET_remaining(&params)) <= 0) {\n            EVP_MD_CTX_free(md_ctx);\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);\n            goto err;\n        }\n        if (EVP_VerifyFinal(md_ctx, PACKET_data(&signature),\n                            PACKET_remaining(&signature), pkey) <= 0) {\n            /* bad signature */\n            EVP_MD_CTX_free(md_ctx);\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n            goto err;\n        }\n        EVP_MD_CTX_free(md_ctx);\n    } else {\n        /* aNULL, aSRP or PSK do not need public keys */\n        if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n            && !(alg_k & SSL_PSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s)) {\n                /* Otherwise this shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            } else {\n                al = SSL_AD_DECODE_ERROR;\n            }\n            goto err;\n        }\n        /* still data left over */\n        if (PACKET_remaining(pkt) != 0) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto err;\n        }\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n err:\n    if (al != -1)\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_certificate_request(SSL *s, PACKET *pkt)\n{\n    int ret = MSG_PROCESS_ERROR;\n    unsigned int list_len, ctype_num, i, name_len;\n    X509_NAME *xn = NULL;\n    const unsigned char *data;\n    const unsigned char *namestart, *namebytes;\n    STACK_OF(X509_NAME) *ca_sk = NULL;\n\n    if ((ca_sk = sk_X509_NAME_new(ca_dn_cmp)) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* get the certificate types */\n    if (!PACKET_get_1(pkt, &ctype_num)\n        || !PACKET_get_bytes(pkt, &data, ctype_num)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    OPENSSL_free(s->cert->ctypes);\n    s->cert->ctypes = NULL;\n    if (ctype_num > SSL3_CT_NUMBER) {\n        /* If we exceed static buffer copy all to cert structure */\n        s->cert->ctypes = OPENSSL_malloc(ctype_num);\n        if (s->cert->ctypes == NULL) {\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(s->cert->ctypes, data, ctype_num);\n        s->cert->ctype_num = (size_t)ctype_num;\n        ctype_num = SSL3_CT_NUMBER;\n    }\n    for (i = 0; i < ctype_num; i++)\n        s->s3->tmp.ctype[i] = data[i];\n\n    if (SSL_USE_SIGALGS(s)) {\n        if (!PACKET_get_net_2(pkt, &list_len)\n            || !PACKET_get_bytes(pkt, &data, list_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /* Clear certificate digests and validity flags */\n        for (i = 0; i < SSL_PKEY_NUM; i++) {\n            s->s3->tmp.md[i] = NULL;\n            s->s3->tmp.valid_flags[i] = 0;\n        }\n        if ((list_len & 1) || !tls1_save_sigalgs(s, data, list_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_SIGNATURE_ALGORITHMS_ERROR);\n            goto err;\n        }\n        if (!tls1_process_sigalgs(s)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        ssl_set_default_md(s);\n    }\n\n    /* get the CA RDNs */\n    if (!PACKET_get_net_2(pkt, &list_len)\n        || PACKET_remaining(pkt) != list_len) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n\n    while (PACKET_remaining(pkt)) {\n        if (!PACKET_get_net_2(pkt, &name_len)\n            || !PACKET_get_bytes(pkt, &namebytes, name_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        namestart = namebytes;\n\n        if ((xn = d2i_X509_NAME(NULL, (const unsigned char **)&namebytes,\n                                name_len)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (namebytes != (namestart + name_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_CA_DN_LENGTH_MISMATCH);\n            goto err;\n        }\n        if (!sk_X509_NAME_push(ca_sk, xn)) {\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        xn = NULL;\n    }\n\n    /* we should setup a certificate to return.... */\n    s->s3->tmp.cert_req = 1;\n    s->s3->tmp.ctype_num = ctype_num;\n    sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\n    s->s3->tmp.ca_names = ca_sk;\n    ca_sk = NULL;\n\n    ret = MSG_PROCESS_CONTINUE_PROCESSING;\n    goto done;\n err:\n    ossl_statem_set_error(s);\n done:\n    X509_NAME_free(xn);\n    sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);\n    return ret;\n}\n\nstatic int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b)\n{\n    return (X509_NAME_cmp(*a, *b));\n}\n\nMSG_PROCESS_RETURN tls_process_new_session_ticket(SSL *s, PACKET *pkt)\n{\n    int al;\n    unsigned int ticklen;\n    unsigned long ticket_lifetime_hint;\n\n    if (!PACKET_get_net_4(pkt, &ticket_lifetime_hint)\n        || !PACKET_get_net_2(pkt, &ticklen)\n        || PACKET_remaining(pkt) != ticklen) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    /* Server is allowed to change its mind and send an empty ticket. */\n    if (ticklen == 0)\n        return MSG_PROCESS_CONTINUE_READING;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache. We carry on if this fails\n             */\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    OPENSSL_free(s->session->tlsext_tick);\n    s->session->tlsext_ticklen = 0;\n\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (s->session->tlsext_tick == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (!PACKET_copy_bytes(pkt, s->session->tlsext_tick, ticklen)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    s->session->tlsext_tick_lifetime_hint = ticket_lifetime_hint;\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    if (!EVP_Digest(s->session->tlsext_tick, ticklen,\n                    s->session->session_id, &s->session->session_id_length,\n                    EVP_sha256(), NULL)) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_EVP_LIB);\n        goto err;\n    }\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_cert_status(SSL *s, PACKET *pkt)\n{\n    int al;\n    unsigned long resplen;\n    unsigned int type;\n\n    if (!PACKET_get_1(pkt, &type)\n        || type != TLSEXT_STATUSTYPE_ocsp) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, SSL_R_UNSUPPORTED_STATUS_TYPE);\n        goto f_err;\n    }\n    if (!PACKET_get_net_3(pkt, &resplen)\n        || PACKET_remaining(pkt) != resplen) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    s->tlsext_ocsp_resp = OPENSSL_malloc(resplen);\n    if (s->tlsext_ocsp_resp == NULL) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, ERR_R_MALLOC_FAILURE);\n        goto f_err;\n    }\n    if (!PACKET_copy_bytes(pkt, s->tlsext_ocsp_resp, resplen)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    s->tlsext_ocsp_resplen = resplen;\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_server_done(SSL *s, PACKET *pkt)\n{\n    if (PACKET_remaining(pkt) > 0) {\n        /* should contain no data */\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE, SSL_R_LENGTH_MISMATCH);\n        ossl_statem_set_error(s);\n        return MSG_PROCESS_ERROR;\n    }\n#ifndef OPENSSL_NO_SRP\n    if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n        if (SRP_Calc_A_param(s) <= 0) {\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE, SSL_R_SRP_A_CALC);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            ossl_statem_set_error(s);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n#endif\n\n    /*\n     * at this point we check that we have the required stuff from\n     * the server\n     */\n    if (!ssl3_check_cert_and_algorithm(s)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        ossl_statem_set_error(s);\n        return MSG_PROCESS_ERROR;\n    }\n\n    /*\n     * Call the ocsp status callback if needed. The |tlsext_ocsp_resp| and\n     * |tlsext_ocsp_resplen| values will be set if we actually received a status\n     * message, or NULL and -1 otherwise\n     */\n    if (s->tlsext_status_type != -1 && s->ctx->tlsext_status_cb != NULL) {\n        int ret;\n        ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n        if (ret == 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL,\n                            SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE);\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE,\n                   SSL_R_INVALID_STATUS_RESPONSE);\n            return MSG_PROCESS_ERROR;\n        }\n        if (ret < 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE, ERR_R_MALLOC_FAILURE);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n#ifndef OPENSSL_NO_CT\n    if (s->ct_validation_callback != NULL) {\n        /* Note we validate the SCTs whether or not we abort on error */\n        if (!ssl_validate_ct(s) && (s->verify_mode & SSL_VERIFY_PEER)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n#endif\n\n#ifndef OPENSSL_NO_SCTP\n    /* Only applies to renegotiation */\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))\n        && s->renegotiate != 0)\n        return MSG_PROCESS_CONTINUE_PROCESSING;\n    else\n#endif\n        return MSG_PROCESS_FINISHED_READING;\n}\n\nstatic int tls_construct_cke_psk_preamble(SSL *s, unsigned char **p,\n                                          size_t *pskhdrlen, int *al)\n{\n#ifndef OPENSSL_NO_PSK\n    int ret = 0;\n    /*\n     * The callback needs PSK_MAX_IDENTITY_LEN + 1 bytes to return a\n     * \\0-terminated identity. The last byte is for us for simulating\n     * strnlen.\n     */\n    char identity[PSK_MAX_IDENTITY_LEN + 1];\n    size_t identitylen = 0;\n    unsigned char psk[PSK_MAX_PSK_LEN];\n    unsigned char *tmppsk = NULL;\n    char *tmpidentity = NULL;\n    size_t psklen = 0;\n\n    if (s->psk_client_callback == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, SSL_R_PSK_NO_CLIENT_CB);\n        *al = SSL_AD_INTERNAL_ERROR;\n        goto err;\n    }\n\n    memset(identity, 0, sizeof(identity));\n\n    psklen = s->psk_client_callback(s, s->session->psk_identity_hint,\n                                    identity, sizeof(identity) - 1,\n                                    psk, sizeof(psk));\n\n    if (psklen > PSK_MAX_PSK_LEN) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        goto err;\n    } else if (psklen == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE,\n               SSL_R_PSK_IDENTITY_NOT_FOUND);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        goto err;\n    }\n\n    identitylen = strlen(identity);\n    if (identitylen > PSK_MAX_IDENTITY_LEN) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        goto err;\n    }\n\n    tmppsk = OPENSSL_memdup(psk, psklen);\n    tmpidentity = OPENSSL_strdup(identity);\n    if (tmppsk == NULL || tmpidentity == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_MALLOC_FAILURE);\n        *al = SSL_AD_INTERNAL_ERROR;\n        goto err;\n    }\n\n    OPENSSL_free(s->s3->tmp.psk);\n    s->s3->tmp.psk = tmppsk;\n    s->s3->tmp.psklen = psklen;\n    tmppsk = NULL;\n    OPENSSL_free(s->session->psk_identity);\n    s->session->psk_identity = tmpidentity;\n    tmpidentity = NULL;\n    s2n(identitylen, *p);\n    memcpy(*p, identity, identitylen);\n    *pskhdrlen = 2 + identitylen;\n    *p += identitylen;\n\n    ret = 1;\n\n err:\n    OPENSSL_cleanse(psk, psklen);\n    OPENSSL_cleanse(identity, sizeof(identity));\n    OPENSSL_clear_free(tmppsk, psklen);\n    OPENSSL_clear_free(tmpidentity, identitylen);\n\n    return ret;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_rsa(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    size_t enclen;\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    if (s->session->peer == NULL) {\n        /*\n         * We should always have a server certificate with SSL_kRSA.\n         */\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    pkey = X509_get0_pubkey(s->session->peer);\n    if (EVP_PKEY_get0_RSA(pkey) == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    pmslen = SSL_MAX_MASTER_KEY_LENGTH;\n    pms = OPENSSL_malloc(pmslen);\n    if (pms == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_MALLOC_FAILURE);\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n    pms[0] = s->client_version >> 8;\n    pms[1] = s->client_version & 0xff;\n    if (RAND_bytes(pms + 2, pmslen - 2) <= 0) {\n        goto err;\n    }\n\n    q = *p;\n    /* Fix buf for TLS and beyond */\n    if (s->version > SSL3_VERSION)\n        *p += 2;\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (pctx == NULL || EVP_PKEY_encrypt_init(pctx) <= 0\n        || EVP_PKEY_encrypt(pctx, NULL, &enclen, pms, pmslen) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_EVP_LIB);\n        goto err;\n    }\n    if (EVP_PKEY_encrypt(pctx, *p, &enclen, pms, pmslen) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, SSL_R_BAD_RSA_ENCRYPT);\n        goto err;\n    }\n    *len = enclen;\n    EVP_PKEY_CTX_free(pctx);\n    pctx = NULL;\n# ifdef PKCS1_CHECK\n    if (s->options & SSL_OP_PKCS1_CHECK_1)\n        (*p)[1]++;\n    if (s->options & SSL_OP_PKCS1_CHECK_2)\n        tmp_buf[0] = 0x70;\n# endif\n\n    /* Fix buf for TLS and beyond */\n    if (s->version > SSL3_VERSION) {\n        s2n(*len, q);\n        *len += 2;\n    }\n\n    s->s3->tmp.pms = pms;\n    s->s3->tmp.pmslen = pmslen;\n\n    return 1;\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    EVP_PKEY_CTX_free(pctx);\n\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    DH *dh_clnt = NULL;\n    const BIGNUM *pub_key;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    dh_clnt = EVP_PKEY_get0_DH(ckey);\n\n    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ckey);\n        return 0;\n    }\n\n    /* send off the data */\n    DH_get0_key(dh_clnt, &pub_key, NULL);\n    *len = BN_num_bytes(pub_key);\n    s2n(*len, *p);\n    BN_bn2bin(pub_key, *p);\n    *len += 2;\n    EVP_PKEY_free(ckey);\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    ckey = ssl_generate_pkey(skey);\n\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_gost(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_GOST\n    /* GOST key exchange message creation */\n    EVP_PKEY_CTX *pkey_ctx = NULL;\n    X509 *peer_cert;\n    size_t msglen;\n    unsigned int md_len;\n    unsigned char shared_ukm[32], tmp[256];\n    EVP_MD_CTX *ukm_hash = NULL;\n    int dgst_nid = NID_id_GostR3411_94;\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    if ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aGOST12) != 0)\n        dgst_nid = NID_id_GostR3411_2012_256;\n\n    /*\n     * Get server sertificate PKEY and create ctx from it\n     */\n    peer_cert = s->session->peer;\n    if (!peer_cert) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST,\n               SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n        return 0;\n    }\n\n    pkey_ctx = EVP_PKEY_CTX_new(X509_get0_pubkey(peer_cert), NULL);\n    if (pkey_ctx == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    /*\n     * If we have send a certificate, and certificate key\n     * parameters match those of server certificate, use\n     * certificate key for key exchange\n     */\n\n    /* Otherwise, generate ephemeral key pair */\n    pmslen = 32;\n    pms = OPENSSL_malloc(pmslen);\n    if (pms == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_encrypt_init(pkey_ctx) <= 0\n        /* Generate session key */\n        || RAND_bytes(pms, pmslen) <= 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_INTERNAL_ERROR);\n        goto err;\n    };\n    /*\n     * Compute shared IV and store it in algorithm-specific context\n     * data\n     */\n    ukm_hash = EVP_MD_CTX_new();\n    if (ukm_hash == NULL\n        || EVP_DigestInit(ukm_hash, EVP_get_digestbynid(dgst_nid)) <= 0\n        || EVP_DigestUpdate(ukm_hash, s->s3->client_random,\n                            SSL3_RANDOM_SIZE) <= 0\n        || EVP_DigestUpdate(ukm_hash, s->s3->server_random,\n                            SSL3_RANDOM_SIZE) <= 0\n        || EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    EVP_MD_CTX_free(ukm_hash);\n    ukm_hash = NULL;\n    if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT,\n                          EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) < 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, SSL_R_LIBRARY_BUG);\n        goto err;\n    }\n    /* Make GOST keytransport blob message */\n    /*\n     * Encapsulate it into sequence\n     */\n    *((*p)++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;\n    msglen = 255;\n    if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, SSL_R_LIBRARY_BUG);\n        goto err;\n    }\n    if (msglen >= 0x80) {\n        *((*p)++) = 0x81;\n        *((*p)++) = msglen & 0xff;\n        *len = msglen + 3;\n    } else {\n        *((*p)++) = msglen & 0xff;\n        *len = msglen + 2;\n    }\n    memcpy(*p, tmp, msglen);\n\n    EVP_PKEY_CTX_free(pkey_ctx);\n    s->s3->tmp.pms = pms;\n    s->s3->tmp.pmslen = pmslen;\n\n    return 1;\n err:\n    EVP_PKEY_CTX_free(pkey_ctx);\n    OPENSSL_clear_free(pms, pmslen);\n    EVP_MD_CTX_free(ukm_hash);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_srp(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_SRP\n    if (s->srp_ctx.A != NULL) {\n        /* send off the data */\n        *len = BN_num_bytes(s->srp_ctx.A);\n        s2n(*len, *p);\n        BN_bn2bin(s->srp_ctx.A, *p);\n        *len += 2;\n    } else {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_SRP, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    OPENSSL_free(s->session->srp_username);\n    s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login);\n    if (s->session->srp_username == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_SRP, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_SRP, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nint tls_construct_client_key_exchange(SSL *s)\n{\n    unsigned char *p;\n    int len;\n    size_t pskhdrlen = 0;\n    unsigned long alg_k;\n    int al = -1;\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    p = ssl_handshake_start(s);\n\n    if ((alg_k & SSL_PSK)\n        && !tls_construct_cke_psk_preamble(s, &p, &pskhdrlen, &al))\n        goto err;\n\n    if (alg_k & SSL_kPSK) {\n        len = 0;\n    } else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) {\n        if (!tls_construct_cke_rsa(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_construct_cke_dhe(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_construct_cke_ecdhe(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & SSL_kGOST) {\n        if (!tls_construct_cke_gost(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_construct_cke_srp(s, &p, &len, &al))\n            goto err;\n    } else {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    len += pskhdrlen;\n\n    if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, len)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    return 1;\n err:\n    if (al != -1)\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    OPENSSL_clear_free(s->s3->tmp.pms, s->s3->tmp.pmslen);\n    s->s3->tmp.pms = NULL;\n#ifndef OPENSSL_NO_PSK\n    OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen);\n    s->s3->tmp.psk = NULL;\n#endif\n    ossl_statem_set_error(s);\n    return 0;\n}\n\nint tls_client_key_exchange_post_work(SSL *s)\n{\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    pms = s->s3->tmp.pms;\n    pmslen = s->s3->tmp.pmslen;\n\n#ifndef OPENSSL_NO_SRP\n    /* Check for SRP */\n    if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n        if (!srp_generate_client_master_secret(s)) {\n            SSLerr(SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        return 1;\n    }\n#endif\n\n    if (pms == NULL && !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        SSLerr(SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (!ssl_generate_master_secret(s, pms, pmslen, 1)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        SSLerr(SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK, ERR_R_INTERNAL_ERROR);\n        /* ssl_generate_master_secret frees the pms even on error */\n        pms = NULL;\n        pmslen = 0;\n        goto err;\n    }\n    pms = NULL;\n    pmslen = 0;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s)) {\n        unsigned char sctpauthkey[64];\n        char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];\n\n        /*\n         * Add new shared key for SCTP-Auth, will be ignored if no SCTP\n         * used.\n         */\n        memcpy(labelbuffer, DTLS1_SCTP_AUTH_LABEL,\n               sizeof(DTLS1_SCTP_AUTH_LABEL));\n\n        if (SSL_export_keying_material(s, sctpauthkey,\n                                       sizeof(sctpauthkey), labelbuffer,\n                                       sizeof(labelbuffer), NULL, 0, 0) <= 0)\n            goto err;\n\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n                 sizeof(sctpauthkey), sctpauthkey);\n    }\n#endif\n\n    return 1;\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    s->s3->tmp.pms = NULL;\n    return 0;\n}\n\nint tls_construct_client_verify(SSL *s)\n{\n    unsigned char *p;\n    EVP_PKEY *pkey;\n    const EVP_MD *md = s->s3->tmp.md[s->cert->key - s->cert->pkeys];\n    EVP_MD_CTX *mctx;\n    unsigned u = 0;\n    unsigned long n = 0;\n    long hdatalen = 0;\n    void *hdata;\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    p = ssl_handshake_start(s);\n    pkey = s->cert->key->privatekey;\n\n    hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n    if (hdatalen <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (SSL_USE_SIGALGS(s)) {\n        if (!tls12_get_sigandhash(p, pkey, md)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        p += 2;\n        n = 2;\n    }\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"Using client alg %s\\n\", EVP_MD_name(md));\n#endif\n    if (!EVP_SignInit_ex(mctx, md, NULL)\n        || !EVP_SignUpdate(mctx, hdata, hdatalen)\n        || (s->version == SSL3_VERSION\n            && !EVP_MD_CTX_ctrl(mctx, EVP_CTRL_SSL3_MASTER_SECRET,\n                                s->session->master_key_length,\n                                s->session->master_key))\n        || !EVP_SignFinal(mctx, p + 2, &u, pkey)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_EVP_LIB);\n        goto err;\n    }\n#ifndef OPENSSL_NO_GOST\n    {\n        int pktype = EVP_PKEY_id(pkey);\n        if (pktype == NID_id_GostR3410_2001\n            || pktype == NID_id_GostR3410_2012_256\n            || pktype == NID_id_GostR3410_2012_512)\n            BUF_reverse(p + 2, NULL, u);\n    }\n#endif\n\n    s2n(u, p);\n    n += u + 2;\n    /* Digest cached records and discard handshake buffer */\n    if (!ssl3_digest_cached_records(s, 0))\n        goto err;\n    if (!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_VERIFY, n)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    EVP_MD_CTX_free(mctx);\n    return 1;\n err:\n    EVP_MD_CTX_free(mctx);\n    return 0;\n}\n\n/*\n * Check a certificate can be used for client authentication. Currently check\n * cert exists, if we have a suitable digest for TLS 1.2 if static DH client\n * certificates can be used and optionally checks suitability for Suite B.\n */\nstatic int ssl3_check_client_certificate(SSL *s)\n{\n    if (!s->cert || !s->cert->key->x509 || !s->cert->key->privatekey)\n        return 0;\n    /* If no suitable signature algorithm can't use certificate */\n    if (SSL_USE_SIGALGS(s) && !s->s3->tmp.md[s->cert->key - s->cert->pkeys])\n        return 0;\n    /*\n     * If strict mode check suitability of chain before using it. This also\n     * adjusts suite B digest if necessary.\n     */\n    if (s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT &&\n        !tls1_check_chain(s, NULL, NULL, NULL, -2))\n        return 0;\n    return 1;\n}\n\nWORK_STATE tls_prepare_client_certificate(SSL *s, WORK_STATE wst)\n{\n    X509 *x509 = NULL;\n    EVP_PKEY *pkey = NULL;\n    int i;\n\n    if (wst == WORK_MORE_A) {\n        /* Let cert callback update client certificates if required */\n        if (s->cert->cert_cb) {\n            i = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n            if (i < 0) {\n                s->rwstate = SSL_X509_LOOKUP;\n                return WORK_MORE_A;\n            }\n            if (i == 0) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                ossl_statem_set_error(s);\n                return 0;\n            }\n            s->rwstate = SSL_NOTHING;\n        }\n        if (ssl3_check_client_certificate(s))\n            return WORK_FINISHED_CONTINUE;\n\n        /* Fall through to WORK_MORE_B */\n        wst = WORK_MORE_B;\n    }\n\n    /* We need to get a client cert */\n    if (wst == WORK_MORE_B) {\n        /*\n         * If we get an error, we need to ssl->rwstate=SSL_X509_LOOKUP;\n         * return(-1); We then get retied later\n         */\n        i = ssl_do_client_cert_cb(s, &x509, &pkey);\n        if (i < 0) {\n            s->rwstate = SSL_X509_LOOKUP;\n            return WORK_MORE_B;\n        }\n        s->rwstate = SSL_NOTHING;\n        if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {\n            if (!SSL_use_certificate(s, x509) || !SSL_use_PrivateKey(s, pkey))\n                i = 0;\n        } else if (i == 1) {\n            i = 0;\n            SSLerr(SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE,\n                   SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\n        }\n\n        X509_free(x509);\n        EVP_PKEY_free(pkey);\n        if (i && !ssl3_check_client_certificate(s))\n            i = 0;\n        if (i == 0) {\n            if (s->version == SSL3_VERSION) {\n                s->s3->tmp.cert_req = 0;\n                ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE);\n                return WORK_FINISHED_CONTINUE;\n            } else {\n                s->s3->tmp.cert_req = 2;\n                if (!ssl3_digest_cached_records(s, 0)) {\n                    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                    ossl_statem_set_error(s);\n                    return 0;\n                }\n            }\n        }\n\n        return WORK_FINISHED_CONTINUE;\n    }\n\n    /* Shouldn't ever get here */\n    return WORK_ERROR;\n}\n\nint tls_construct_client_certificate(SSL *s)\n{\n    if (!ssl3_output_cert_chain(s,\n                                (s->s3->tmp.cert_req ==\n                                 2) ? NULL : s->cert->key)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n\n    return 1;\n}\n\n#define has_bits(i,m)   (((i)&(m)) == (m))\n\nint ssl3_check_cert_and_algorithm(SSL *s)\n{\n    int i;\n#ifndef OPENSSL_NO_EC\n    int idx;\n#endif\n    long alg_k, alg_a;\n    EVP_PKEY *pkey = NULL;\n    int al = SSL_AD_HANDSHAKE_FAILURE;\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\n    /* we don't have a certificate */\n    if ((alg_a & SSL_aNULL) || (alg_k & SSL_kPSK))\n        return (1);\n\n    /* This is the passed certificate */\n\n#ifndef OPENSSL_NO_EC\n    idx = s->session->peer_type;\n    if (idx == SSL_PKEY_ECC) {\n        if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s) == 0) {\n            /* check failed */\n            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);\n            goto f_err;\n        } else {\n            return 1;\n        }\n    } else if (alg_a & SSL_aECDSA) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_ECDSA_SIGNING_CERT);\n        goto f_err;\n    }\n#endif\n    pkey = X509_get0_pubkey(s->session->peer);\n    i = X509_certificate_type(s->session->peer, pkey);\n\n    /* Check that we have a certificate if we require one */\n    if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_RSA_SIGNING_CERT);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_DSA\n    else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_DSA_SIGNING_CERT);\n        goto f_err;\n    }\n#endif\n#ifndef OPENSSL_NO_RSA\n    if (alg_k & (SSL_kRSA | SSL_kRSAPSK) &&\n        !has_bits(i, EVP_PK_RSA | EVP_PKT_ENC)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n        goto f_err;\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    if ((alg_k & SSL_kDHE) && (s->s3->peer_tmp == NULL)) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n#endif\n\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (0);\n}\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\nint tls_construct_next_proto(SSL *s)\n{\n    unsigned int len, padding_len;\n    unsigned char *d;\n\n    len = s->next_proto_negotiated_len;\n    padding_len = 32 - ((len + 2) % 32);\n    d = (unsigned char *)s->init_buf->data;\n    d[4] = len;\n    memcpy(d + 5, s->next_proto_negotiated, len);\n    d[5 + len] = padding_len;\n    memset(d + 6 + len, 0, padding_len);\n    *(d++) = SSL3_MT_NEXT_PROTO;\n    l2n3(2 + len + padding_len, d);\n    s->init_num = 4 + 2 + len + padding_len;\n    s->init_off = 0;\n\n    return 1;\n}\n#endif\n\nint ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey)\n{\n    int i = 0;\n#ifndef OPENSSL_NO_ENGINE\n    if (s->ctx->client_cert_engine) {\n        i = ENGINE_load_ssl_client_cert(s->ctx->client_cert_engine, s,\n                                        SSL_get_client_CA_list(s),\n                                        px509, ppkey, NULL, NULL, NULL);\n        if (i != 0)\n            return i;\n    }\n#endif\n    if (s->ctx->client_cert_cb)\n        i = s->ctx->client_cert_cb(s, px509, ppkey);\n    return i;\n}\n\nint ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk, unsigned char *p)\n{\n    int i, j = 0;\n    const SSL_CIPHER *c;\n    unsigned char *q;\n    int empty_reneg_info_scsv = !s->renegotiate;\n    /* Set disabled masks for this session */\n    ssl_set_client_disabled(s);\n\n    if (sk == NULL)\n        return (0);\n    q = p;\n\n    for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\n        c = sk_SSL_CIPHER_value(sk, i);\n        /* Skip disabled ciphers */\n        if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_SUPPORTED))\n            continue;\n        j = s->method->put_cipher_by_char(c, p);\n        p += j;\n    }\n    /*\n     * If p == q, no ciphers; caller indicates an error. Otherwise, add\n     * applicable SCSVs.\n     */\n    if (p != q) {\n        if (empty_reneg_info_scsv) {\n            static SSL_CIPHER scsv = {\n                0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0\n            };\n            j = s->method->put_cipher_by_char(&scsv, p);\n            p += j;\n        }\n        if (s->mode & SSL_MODE_SEND_FALLBACK_SCSV) {\n            static SSL_CIPHER scsv = {\n                0, NULL, SSL3_CK_FALLBACK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0\n            };\n            j = s->method->put_cipher_by_char(&scsv, p);\n            p += j;\n        }\n    }\n\n    return (p - q);\n}\n"], "fixing_code": ["/*\n * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/* ====================================================================\n * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n *\n * Portions of the attached software (\"Contribution\") are developed by\n * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.\n *\n * The Contribution is licensed pursuant to the OpenSSL open source\n * license provided above.\n *\n * ECC cipher suite support in OpenSSL originally written by\n * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.\n *\n */\n/* ====================================================================\n * Copyright 2005 Nokia. All rights reserved.\n *\n * The portions of the attached software (\"Contribution\") is developed by\n * Nokia Corporation and is licensed pursuant to the OpenSSL open source\n * license.\n *\n * The Contribution, originally written by Mika Kousa and Pasi Eronen of\n * Nokia Corporation, consists of the \"PSK\" (Pre-Shared Key) ciphersuites\n * support (see RFC 4279) to OpenSSL.\n *\n * No patent licenses or other rights except those expressly stated in\n * the OpenSSL open source license shall be deemed granted or received\n * expressly, by implication, estoppel, or otherwise.\n *\n * No assurances are provided by Nokia that the Contribution does not\n * infringe the patent or other intellectual property rights of any third\n * party or that the license provides you with all the necessary rights\n * to make use of the Contribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. IN\n * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA\n * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY\n * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR\n * OTHERWISE.\n */\n\n#include <stdio.h>\n#include \"../ssl_locl.h\"\n#include \"statem_locl.h\"\n#include <openssl/buffer.h>\n#include <openssl/rand.h>\n#include <openssl/objects.h>\n#include <openssl/evp.h>\n#include <openssl/md5.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <openssl/engine.h>\n\nstatic ossl_inline int cert_req_allowed(SSL *s);\nstatic int key_exchange_expected(SSL *s);\nstatic int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b);\nstatic int ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk,\n                                    unsigned char *p);\n\n/*\n * Is a CertificateRequest message allowed at the moment or not?\n *\n *  Return values are:\n *  1: Yes\n *  0: No\n */\nstatic ossl_inline int cert_req_allowed(SSL *s)\n{\n    /* TLS does not like anon-DH with client cert */\n    if ((s->version > SSL3_VERSION\n         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))\n        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))\n        return 0;\n\n    return 1;\n}\n\n/*\n * Should we expect the ServerKeyExchange message or not?\n *\n *  Return values are:\n *  1: Yes\n *  0: No\n */\nstatic int key_exchange_expected(SSL *s)\n{\n    long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    /*\n     * Can't skip server key exchange if this is an ephemeral\n     * ciphersuite or for SRP\n     */\n    if (alg_k & (SSL_kDHE | SSL_kECDHE | SSL_kDHEPSK | SSL_kECDHEPSK\n                 | SSL_kSRP)) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/*\n * ossl_statem_client_read_transition() encapsulates the logic for the allowed\n * handshake state transitions when the client is reading messages from the\n * server. The message type that the server has sent is provided in |mt|. The\n * current state is in |s->statem.hand_state|.\n *\n *  Return values are:\n *  1: Success (transition allowed)\n *  0: Error (transition not allowed)\n */\nint ossl_statem_client_read_transition(SSL *s, int mt)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ske_expected;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        if (mt == SSL3_MT_SERVER_HELLO) {\n            st->hand_state = TLS_ST_CR_SRVR_HELLO;\n            return 1;\n        }\n\n        if (SSL_IS_DTLS(s)) {\n            if (mt == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n                st->hand_state = DTLS_ST_CR_HELLO_VERIFY_REQUEST;\n                return 1;\n            }\n        }\n        break;\n\n    case TLS_ST_CR_SRVR_HELLO:\n        if (s->hit) {\n            if (s->tlsext_ticket_expected) {\n                if (mt == SSL3_MT_NEWSESSION_TICKET) {\n                    st->hand_state = TLS_ST_CR_SESSION_TICKET;\n                    return 1;\n                }\n            } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n                st->hand_state = TLS_ST_CR_CHANGE;\n                return 1;\n            }\n        } else {\n            if (SSL_IS_DTLS(s) && mt == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n                st->hand_state = DTLS_ST_CR_HELLO_VERIFY_REQUEST;\n                return 1;\n            } else if (s->version >= TLS1_VERSION\n                       && s->tls_session_secret_cb != NULL\n                       && s->session->tlsext_tick != NULL\n                       && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n                /*\n                 * Normally, we can tell if the server is resuming the session\n                 * from the session ID. EAP-FAST (RFC 4851), however, relies on\n                 * the next server message after the ServerHello to determine if\n                 * the server is resuming.\n                 */\n                s->hit = 1;\n                st->hand_state = TLS_ST_CR_CHANGE;\n                return 1;\n            } else if (!(s->s3->tmp.new_cipher->algorithm_auth\n                         & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {\n                if (mt == SSL3_MT_CERTIFICATE) {\n                    st->hand_state = TLS_ST_CR_CERT;\n                    return 1;\n                }\n            } else {\n                ske_expected = key_exchange_expected(s);\n                /* SKE is optional for some PSK ciphersuites */\n                if (ske_expected\n                    || ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)\n                        && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {\n                    if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {\n                        st->hand_state = TLS_ST_CR_KEY_EXCH;\n                        return 1;\n                    }\n                } else if (mt == SSL3_MT_CERTIFICATE_REQUEST\n                           && cert_req_allowed(s)) {\n                    st->hand_state = TLS_ST_CR_CERT_REQ;\n                    return 1;\n                } else if (mt == SSL3_MT_SERVER_DONE) {\n                    st->hand_state = TLS_ST_CR_SRVR_DONE;\n                    return 1;\n                }\n            }\n        }\n        break;\n\n    case TLS_ST_CR_CERT:\n        /*\n         * The CertificateStatus message is optional even if\n         * |tlsext_status_expected| is set\n         */\n        if (s->tlsext_status_expected && mt == SSL3_MT_CERTIFICATE_STATUS) {\n            st->hand_state = TLS_ST_CR_CERT_STATUS;\n            return 1;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_CERT_STATUS:\n        ske_expected = key_exchange_expected(s);\n        /* SKE is optional for some PSK ciphersuites */\n        if (ske_expected || ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)\n                             && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {\n            if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {\n                st->hand_state = TLS_ST_CR_KEY_EXCH;\n                return 1;\n            }\n            goto err;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_KEY_EXCH:\n        if (mt == SSL3_MT_CERTIFICATE_REQUEST) {\n            if (cert_req_allowed(s)) {\n                st->hand_state = TLS_ST_CR_CERT_REQ;\n                return 1;\n            }\n            goto err;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_CERT_REQ:\n        if (mt == SSL3_MT_SERVER_DONE) {\n            st->hand_state = TLS_ST_CR_SRVR_DONE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CW_FINISHED:\n        if (s->tlsext_ticket_expected) {\n            if (mt == SSL3_MT_NEWSESSION_TICKET) {\n                st->hand_state = TLS_ST_CR_SESSION_TICKET;\n                return 1;\n            }\n        } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CR_SESSION_TICKET:\n        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CR_CHANGE:\n        if (mt == SSL3_MT_FINISHED) {\n            st->hand_state = TLS_ST_CR_FINISHED;\n            return 1;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n err:\n    /* No valid transition found */\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL3_AD_UNEXPECTED_MESSAGE);\n    SSLerr(SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;\n}\n\n/*\n * client_write_transition() works out what handshake state to move to next\n * when the client is writing messages to be sent to the server.\n */\nWRITE_TRAN ossl_statem_client_write_transition(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_OK:\n        /* Renegotiation - fall through */\n    case TLS_ST_BEFORE:\n        st->hand_state = TLS_ST_CW_CLNT_HELLO;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CLNT_HELLO:\n        /*\n         * No transition at the end of writing because we don't know what\n         * we will be sent\n         */\n        return WRITE_TRAN_FINISHED;\n\n    case DTLS_ST_CR_HELLO_VERIFY_REQUEST:\n        st->hand_state = TLS_ST_CW_CLNT_HELLO;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CR_SRVR_DONE:\n        if (s->s3->tmp.cert_req)\n            st->hand_state = TLS_ST_CW_CERT;\n        else\n            st->hand_state = TLS_ST_CW_KEY_EXCH;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CERT:\n        st->hand_state = TLS_ST_CW_KEY_EXCH;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_KEY_EXCH:\n        /*\n         * For TLS, cert_req is set to 2, so a cert chain of nothing is\n         * sent, but no verify packet is sent\n         */\n        /*\n         * XXX: For now, we do not support client authentication in ECDH\n         * cipher suites with ECDH (rather than ECDSA) certificates. We\n         * need to skip the certificate verify message when client's\n         * ECDH public key is sent inside the client certificate.\n         */\n        if (s->s3->tmp.cert_req == 1) {\n            st->hand_state = TLS_ST_CW_CERT_VRFY;\n        } else {\n            st->hand_state = TLS_ST_CW_CHANGE;\n        }\n        if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n            st->hand_state = TLS_ST_CW_CHANGE;\n        }\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CERT_VRFY:\n        st->hand_state = TLS_ST_CW_CHANGE;\n        return WRITE_TRAN_CONTINUE;\n\n    case TLS_ST_CW_CHANGE:\n#if defined(OPENSSL_NO_NEXTPROTONEG)\n        st->hand_state = TLS_ST_CW_FINISHED;\n#else\n        if (!SSL_IS_DTLS(s) && s->s3->next_proto_neg_seen)\n            st->hand_state = TLS_ST_CW_NEXT_PROTO;\n        else\n            st->hand_state = TLS_ST_CW_FINISHED;\n#endif\n        return WRITE_TRAN_CONTINUE;\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    case TLS_ST_CW_NEXT_PROTO:\n        st->hand_state = TLS_ST_CW_FINISHED;\n        return WRITE_TRAN_CONTINUE;\n#endif\n\n    case TLS_ST_CW_FINISHED:\n        if (s->hit) {\n            st->hand_state = TLS_ST_OK;\n            ossl_statem_set_in_init(s, 0);\n            return WRITE_TRAN_CONTINUE;\n        } else {\n            return WRITE_TRAN_FINISHED;\n        }\n\n    case TLS_ST_CR_FINISHED:\n        if (s->hit) {\n            st->hand_state = TLS_ST_CW_CHANGE;\n            return WRITE_TRAN_CONTINUE;\n        } else {\n            st->hand_state = TLS_ST_OK;\n            ossl_statem_set_in_init(s, 0);\n            return WRITE_TRAN_CONTINUE;\n        }\n\n    default:\n        /* Shouldn't happen */\n        return WRITE_TRAN_ERROR;\n    }\n}\n\n/*\n * Perform any pre work that needs to be done prior to sending a message from\n * the client to the server.\n */\nWORK_STATE ossl_statem_client_pre_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s)) {\n            /* every DTLS ClientHello resets Finished MAC */\n            if (!ssl3_init_finished_mac(s)) {\n                ossl_statem_set_error(s);\n                return WORK_ERROR;\n            }\n        }\n        break;\n\n    case TLS_ST_CW_CHANGE:\n        if (SSL_IS_DTLS(s)) {\n            if (s->hit) {\n                /*\n                 * We're into the last flight so we don't retransmit these\n                 * messages unless we need to.\n                 */\n                st->use_timer = 0;\n            }\n#ifndef OPENSSL_NO_SCTP\n            if (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n                return dtls_wait_for_dry(s);\n#endif\n        }\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_OK:\n        return tls_finish_handshake(s, wst);\n\n    default:\n        /* No pre work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}\n\n/*\n * Perform any work that needs to be done after sending a message from the\n * client to the server.\n */\nWORK_STATE ossl_statem_client_post_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    s->init_num = 0;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        if (wst == WORK_MORE_A && statem_flush(s) != 1)\n            return WORK_MORE_A;\n\n        if (SSL_IS_DTLS(s)) {\n            /* Treat the next message as the first packet */\n            s->first_packet = 1;\n        }\n        break;\n\n    case TLS_ST_CW_KEY_EXCH:\n        if (tls_client_key_exchange_post_work(s) == 0)\n            return WORK_ERROR;\n        break;\n\n    case TLS_ST_CW_CHANGE:\n        s->session->cipher = s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n        s->session->compress_meth = 0;\n#else\n        if (s->s3->tmp.new_compression == NULL)\n            s->session->compress_meth = 0;\n        else\n            s->session->compress_meth = s->s3->tmp.new_compression->id;\n#endif\n        if (!s->method->ssl3_enc->setup_key_block(s))\n            return WORK_ERROR;\n\n        if (!s->method->ssl3_enc->change_cipher_state(s,\n                                                      SSL3_CHANGE_CIPHER_CLIENT_WRITE))\n            return WORK_ERROR;\n\n        if (SSL_IS_DTLS(s)) {\n#ifndef OPENSSL_NO_SCTP\n            if (s->hit) {\n                /*\n                 * Change to new shared key of SCTP-Auth, will be ignored if\n                 * no SCTP used.\n                 */\n                BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY,\n                         0, NULL);\n            }\n#endif\n\n            dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);\n        }\n        break;\n\n    case TLS_ST_CW_FINISHED:\n#ifndef OPENSSL_NO_SCTP\n        if (wst == WORK_MORE_A && SSL_IS_DTLS(s) && s->hit == 0) {\n            /*\n             * Change to new shared key of SCTP-Auth, will be ignored if\n             * no SCTP used.\n             */\n            BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY,\n                     0, NULL);\n        }\n#endif\n        if (statem_flush(s) != 1)\n            return WORK_MORE_B;\n        break;\n\n    default:\n        /* No post work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}\n\n/*\n * Construct a message to be sent from the client to the server.\n *\n * Valid return values are:\n *   1: Success\n *   0: Error\n */\nint ossl_statem_client_construct_message(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        return tls_construct_client_hello(s);\n\n    case TLS_ST_CW_CERT:\n        return tls_construct_client_certificate(s);\n\n    case TLS_ST_CW_KEY_EXCH:\n        return tls_construct_client_key_exchange(s);\n\n    case TLS_ST_CW_CERT_VRFY:\n        return tls_construct_client_verify(s);\n\n    case TLS_ST_CW_CHANGE:\n        if (SSL_IS_DTLS(s))\n            return dtls_construct_change_cipher_spec(s);\n        else\n            return tls_construct_change_cipher_spec(s);\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    case TLS_ST_CW_NEXT_PROTO:\n        return tls_construct_next_proto(s);\n#endif\n    case TLS_ST_CW_FINISHED:\n        return tls_construct_finished(s,\n                                      s->method->\n                                      ssl3_enc->client_finished_label,\n                                      s->method->\n                                      ssl3_enc->client_finished_label_len);\n\n    default:\n        /* Shouldn't happen */\n        break;\n    }\n\n    return 0;\n}\n\n/*\n * Returns the maximum allowed length for the current message that we are\n * reading. Excludes the message header.\n */\nunsigned long ossl_statem_client_max_message_size(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CR_SRVR_HELLO:\n        return SERVER_HELLO_MAX_LENGTH;\n\n    case DTLS_ST_CR_HELLO_VERIFY_REQUEST:\n        return HELLO_VERIFY_REQUEST_MAX_LENGTH;\n\n    case TLS_ST_CR_CERT:\n        return s->max_cert_list;\n\n    case TLS_ST_CR_CERT_STATUS:\n        return SSL3_RT_MAX_PLAIN_LENGTH;\n\n    case TLS_ST_CR_KEY_EXCH:\n        return SERVER_KEY_EXCH_MAX_LENGTH;\n\n    case TLS_ST_CR_CERT_REQ:\n        /*\n         * Set to s->max_cert_list for compatibility with previous releases. In\n         * practice these messages can get quite long if servers are configured\n         * to provide a long list of acceptable CAs\n         */\n        return s->max_cert_list;\n\n    case TLS_ST_CR_SRVR_DONE:\n        return SERVER_HELLO_DONE_MAX_LENGTH;\n\n    case TLS_ST_CR_CHANGE:\n        if (s->version == DTLS1_BAD_VER)\n            return 3;\n        return CCS_MAX_LENGTH;\n\n    case TLS_ST_CR_SESSION_TICKET:\n        return SSL3_RT_MAX_PLAIN_LENGTH;\n\n    case TLS_ST_CR_FINISHED:\n        return FINISHED_MAX_LENGTH;\n\n    default:\n        /* Shouldn't happen */\n        break;\n    }\n\n    return 0;\n}\n\n/*\n * Process a message that the client has been received from the server.\n */\nMSG_PROCESS_RETURN ossl_statem_client_process_message(SSL *s, PACKET *pkt)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CR_SRVR_HELLO:\n        return tls_process_server_hello(s, pkt);\n\n    case DTLS_ST_CR_HELLO_VERIFY_REQUEST:\n        return dtls_process_hello_verify(s, pkt);\n\n    case TLS_ST_CR_CERT:\n        return tls_process_server_certificate(s, pkt);\n\n    case TLS_ST_CR_CERT_STATUS:\n        return tls_process_cert_status(s, pkt);\n\n    case TLS_ST_CR_KEY_EXCH:\n        return tls_process_key_exchange(s, pkt);\n\n    case TLS_ST_CR_CERT_REQ:\n        return tls_process_certificate_request(s, pkt);\n\n    case TLS_ST_CR_SRVR_DONE:\n        return tls_process_server_done(s, pkt);\n\n    case TLS_ST_CR_CHANGE:\n        return tls_process_change_cipher_spec(s, pkt);\n\n    case TLS_ST_CR_SESSION_TICKET:\n        return tls_process_new_session_ticket(s, pkt);\n\n    case TLS_ST_CR_FINISHED:\n        return tls_process_finished(s, pkt);\n\n    default:\n        /* Shouldn't happen */\n        break;\n    }\n\n    return MSG_PROCESS_ERROR;\n}\n\n/*\n * Perform any further processing required following the receipt of a message\n * from the server\n */\nWORK_STATE ossl_statem_client_post_process_message(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CR_CERT_REQ:\n        return tls_prepare_client_certificate(s, wst);\n\n#ifndef OPENSSL_NO_SCTP\n    case TLS_ST_CR_SRVR_DONE:\n        /* We only get here if we are using SCTP and we are renegotiating */\n        if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {\n            s->s3->in_read_app_data = 2;\n            s->rwstate = SSL_READING;\n            BIO_clear_retry_flags(SSL_get_rbio(s));\n            BIO_set_retry_read(SSL_get_rbio(s));\n            ossl_statem_set_sctp_read_sock(s, 1);\n            return WORK_MORE_A;\n        }\n        ossl_statem_set_sctp_read_sock(s, 0);\n        return WORK_FINISHED_STOP;\n#endif\n\n    default:\n        break;\n    }\n\n    /* Shouldn't happen */\n    return WORK_ERROR;\n}\n\nint tls_construct_client_hello(SSL *s)\n{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    int protverr;\n    unsigned long l;\n    int al = 0;\n#ifndef OPENSSL_NO_COMP\n    int j;\n    SSL_COMP *comp;\n#endif\n    SSL_SESSION *sess = s->session;\n\n    buf = (unsigned char *)s->init_buf->data;\n\n    /* Work out what SSL/TLS/DTLS version to use */\n    protverr = ssl_set_client_hello_version(s);\n    if (protverr != 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, protverr);\n        goto err;\n    }\n\n    if ((sess == NULL) || !ssl_version_supported(s, sess->ssl_version) ||\n        /*\n         * In the case of EAP-FAST, we can have a pre-shared\n         * \"ticket\" without a session ID.\n         */\n        (!sess->session_id_length && !sess->tlsext_tick) ||\n        (sess->not_resumable)) {\n        if (!ssl_get_new_session(s, 0))\n            goto err;\n    }\n    /* else use the pre-loaded session */\n\n    p = s->s3->client_random;\n\n    /*\n     * for DTLS if client_random is initialized, reuse it, we are\n     * required to use same upon reply to HelloVerify\n     */\n    if (SSL_IS_DTLS(s)) {\n        size_t idx;\n        i = 1;\n        for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n            if (p[idx]) {\n                i = 0;\n                break;\n            }\n        }\n    } else\n        i = 1;\n\n    if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random)) <= 0)\n        goto err;\n\n    /* Do the message type and length last */\n    d = p = ssl_handshake_start(s);\n\n    /*-\n     * version indicates the negotiated version: for example from\n     * an SSLv2/v3 compatible client hello). The client_version\n     * field is the maximum version we permit and it is also\n     * used in RSA encrypted premaster secrets. Some servers can\n     * choke if we initially report a higher version then\n     * renegotiate to a lower one in the premaster secret. This\n     * didn't happen with TLS 1.0 as most servers supported it\n     * but it can with TLS 1.1 or later if the server only supports\n     * 1.0.\n     *\n     * Possible scenario with previous logic:\n     *      1. Client hello indicates TLS 1.2\n     *      2. Server hello says TLS 1.0\n     *      3. RSA encrypted premaster secret uses 1.2.\n     *      4. Handshake proceeds using TLS 1.0.\n     *      5. Server sends hello request to renegotiate.\n     *      6. Client hello indicates TLS v1.0 as we now\n     *         know that is maximum server supports.\n     *      7. Server chokes on RSA encrypted premaster secret\n     *         containing version 1.0.\n     *\n     * For interoperability it should be OK to always use the\n     * maximum version we support in client hello and then rely\n     * on the checking of version to ensure the servers isn't\n     * being inconsistent: for example initially negotiating with\n     * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n     * client_version in client hello and not resetting it to\n     * the negotiated version.\n     */\n    *(p++) = s->client_version >> 8;\n    *(p++) = s->client_version & 0xff;\n\n    /* Random stuff */\n    memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n\n    /* Session ID */\n    if (s->new_session)\n        i = 0;\n    else\n        i = s->session->session_id_length;\n    *(p++) = i;\n    if (i != 0) {\n        if (i > (int)sizeof(s->session->session_id)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        memcpy(p, s->session->session_id, i);\n        p += i;\n    }\n\n    /* cookie stuff for DTLS */\n    if (SSL_IS_DTLS(s)) {\n        if (s->d1->cookie_len > sizeof(s->d1->cookie)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        *(p++) = s->d1->cookie_len;\n        memcpy(p, s->d1->cookie, s->d1->cookie_len);\n        p += s->d1->cookie_len;\n    }\n\n    /* Ciphers supported */\n    i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]));\n    if (i == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);\n        goto err;\n    }\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n    /*\n     * Some servers hang if client hello > 256 bytes as hack workaround\n     * chop number of supported ciphers to keep it well below this if we\n     * use TLS v1.2\n     */\n    if (TLS1_get_version(s) >= TLS1_2_VERSION\n        && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n        i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n    s2n(i, p);\n    p += i;\n\n    /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n    *(p++) = 1;\n#else\n\n    if (!ssl_allow_compression(s) || !s->ctx->comp_methods)\n        j = 0;\n    else\n        j = sk_SSL_COMP_num(s->ctx->comp_methods);\n    *(p++) = 1 + j;\n    for (i = 0; i < j; i++) {\n        comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n        *(p++) = comp->id;\n    }\n#endif\n    *(p++) = 0;                 /* Add the NULL method */\n\n    /* TLS extensions */\n    if (ssl_prepare_clienthello_tlsext(s) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n        goto err;\n    }\n    if ((p =\n         ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,\n                                    &al)) == NULL) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    l = p - d;\n    if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    return 1;\n err:\n    ossl_statem_set_error(s);\n    return 0;\n}\n\nMSG_PROCESS_RETURN dtls_process_hello_verify(SSL *s, PACKET *pkt)\n{\n    int al;\n    unsigned int cookie_len;\n    PACKET cookiepkt;\n\n    if (!PACKET_forward(pkt, 2)\n        || !PACKET_get_length_prefixed_1(pkt, &cookiepkt)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_DTLS_PROCESS_HELLO_VERIFY, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    cookie_len = PACKET_remaining(&cookiepkt);\n    if (cookie_len > sizeof(s->d1->cookie)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_DTLS_PROCESS_HELLO_VERIFY, SSL_R_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    if (!PACKET_copy_bytes(&cookiepkt, s->d1->cookie, cookie_len)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_DTLS_PROCESS_HELLO_VERIFY, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    s->d1->cookie_len = cookie_len;\n\n    return MSG_PROCESS_FINISHED_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_server_hello(SSL *s, PACKET *pkt)\n{\n    STACK_OF(SSL_CIPHER) *sk;\n    const SSL_CIPHER *c;\n    PACKET session_id;\n    size_t session_id_len;\n    const unsigned char *cipherchars;\n    int i, al = SSL_AD_INTERNAL_ERROR;\n    unsigned int compression;\n    unsigned int sversion;\n    int protverr;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n\n    if (!PACKET_get_net_2(pkt, &sversion)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    protverr = ssl_choose_client_version(s, sversion);\n    if (protverr != 0) {\n        al = SSL_AD_PROTOCOL_VERSION;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, protverr);\n        goto f_err;\n    }\n\n    /* load the server hello data */\n    /* load the server random */\n    if (!PACKET_copy_bytes(pkt, s->s3->server_random, SSL3_RANDOM_SIZE)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    s->hit = 0;\n\n    /* Get the session-id. */\n    if (!PACKET_get_length_prefixed_1(pkt, &session_id)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    session_id_len = PACKET_remaining(&session_id);\n    if (session_id_len > sizeof s->session->session_id\n        || session_id_len > SSL3_SESSION_ID_SIZE) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);\n        goto f_err;\n    }\n\n    if (!PACKET_get_bytes(pkt, &cipherchars, TLS_CIPHER_LEN)) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n\n    /*\n     * Check if we can resume the session based on external pre-shared secret.\n     * EAP-FAST (RFC 4851) supports two types of session resumption.\n     * Resumption based on server-side state works with session IDs.\n     * Resumption based on pre-shared Protected Access Credentials (PACs)\n     * works by overriding the SessionTicket extension at the application\n     * layer, and does not send a session ID. (We do not know whether EAP-FAST\n     * servers would honour the session ID.) Therefore, the session ID alone\n     * is not a reliable indicator of session resumption, so we first check if\n     * we can resume, and later peek at the next handshake message to see if the\n     * server wants to resume.\n     */\n    if (s->version >= TLS1_VERSION && s->tls_session_secret_cb &&\n        s->session->tlsext_tick) {\n        const SSL_CIPHER *pref_cipher = NULL;\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length,\n                                     NULL, &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->session->cipher = pref_cipher ?\n                pref_cipher : ssl_get_cipher_by_char(s, cipherchars);\n        } else {\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    }\n\n    if (session_id_len != 0 && session_id_len == s->session->session_id_length\n        && memcmp(PACKET_data(&session_id), s->session->session_id,\n                  session_id_len) == 0) {\n        if (s->sid_ctx_length != s->session->sid_ctx_length\n            || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {\n            /* actually a client application bug */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n                   SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n            goto f_err;\n        }\n        s->hit = 1;\n    } else {\n        /*\n         * If we were trying for session-id reuse but the server\n         * didn't echo the ID, make a new SSL_SESSION.\n         * In the case of EAP-FAST and PAC, we do not send a session ID,\n         * so the PAC-based session secret is always preserved. It'll be\n         * overwritten if the server refuses resumption.\n         */\n        if (s->session->session_id_length > 0) {\n            s->ctx->stats.sess_miss++;\n            if (!ssl_get_new_session(s, 0)) {\n                goto f_err;\n            }\n        }\n\n        s->session->ssl_version = s->version;\n        s->session->session_id_length = session_id_len;\n        /* session_id_len could be 0 */\n        memcpy(s->session->session_id, PACKET_data(&session_id),\n               session_id_len);\n    }\n\n    /* Session version and negotiated protocol version should match */\n    if (s->version != s->session->ssl_version) {\n        al = SSL_AD_PROTOCOL_VERSION;\n\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_SSL_SESSION_VERSION_MISMATCH);\n        goto f_err;\n    }\n\n    c = ssl_get_cipher_by_char(s, cipherchars);\n    if (c == NULL) {\n        /* unknown cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);\n        goto f_err;\n    }\n    /*\n     * Now that we know the version, update the check to see if it's an allowed\n     * version.\n     */\n    s->s3->tmp.min_ver = s->version;\n    s->s3->tmp.max_ver = s->version;\n    /*\n     * If it is a disabled cipher we either didn't send it in client hello,\n     * or it's not allowed for the selected protocol. So we return an error.\n     */\n    if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    sk = ssl_get_ciphers_by_id(s);\n    i = sk_SSL_CIPHER_find(sk, c);\n    if (i < 0) {\n        /* we did not say we would use this cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    /*\n     * Depending on the session caching (internal/external), the cipher\n     * and/or cipher_id values may not be set. Make sure that cipher_id is\n     * set and use it for comparison.\n     */\n    if (s->session->cipher)\n        s->session->cipher_id = s->session->cipher->id;\n    if (s->hit && (s->session->cipher_id != c->id)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n        goto f_err;\n    }\n    s->s3->tmp.new_cipher = c;\n    /* lets get the compression algorithm */\n    /* COMPRESSION */\n    if (!PACKET_get_1(pkt, &compression)) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n#ifdef OPENSSL_NO_COMP\n    if (compression != 0) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    }\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#else\n    if (s->hit && compression != s->session->compress_meth) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n        goto f_err;\n    }\n    if (compression == 0)\n        comp = NULL;\n    else if (!ssl_allow_compression(s)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);\n        goto f_err;\n    } else {\n        comp = ssl3_comp_find(s->ctx->comp_methods, compression);\n    }\n\n    if (compression != 0 && comp == NULL) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    } else {\n        s->s3->tmp.new_compression = comp;\n    }\n#endif\n\n    /* TLS extensions */\n    if (!ssl_parse_serverhello_tlsext(s, pkt)) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_PARSE_TLSEXT);\n        goto err;\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        /* wrong packet length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && s->hit) {\n        unsigned char sctpauthkey[64];\n        char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];\n\n        /*\n         * Add new shared key for SCTP-Auth, will be ignored if\n         * no SCTP used.\n         */\n        memcpy(labelbuffer, DTLS1_SCTP_AUTH_LABEL,\n               sizeof(DTLS1_SCTP_AUTH_LABEL));\n\n        if (SSL_export_keying_material(s, sctpauthkey,\n                                       sizeof(sctpauthkey),\n                                       labelbuffer,\n                                       sizeof(labelbuffer), NULL, 0, 0) <= 0)\n            goto err;\n\n        BIO_ctrl(SSL_get_wbio(s),\n                 BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n                 sizeof(sctpauthkey), sctpauthkey);\n    }\n#endif\n\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_server_certificate(SSL *s, PACKET *pkt)\n{\n    int al, i, ret = MSG_PROCESS_ERROR, exp_idx;\n    unsigned long cert_list_len, cert_len;\n    X509 *x = NULL;\n    const unsigned char *certstart, *certbytes;\n    STACK_OF(X509) *sk = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!PACKET_get_net_3(pkt, &cert_list_len)\n        || PACKET_remaining(pkt) != cert_list_len) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    while (PACKET_remaining(pkt)) {\n        if (!PACKET_get_net_3(pkt, &cert_len)\n            || !PACKET_get_bytes(pkt, &certbytes, cert_len)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n        certstart = certbytes;\n        x = d2i_X509(NULL, (const unsigned char **)&certbytes, cert_len);\n        if (x == NULL) {\n            al = SSL_AD_BAD_CERTIFICATE;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto f_err;\n        }\n        if (certbytes != (certstart + cert_len)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if (!sk_X509_push(sk, x)) {\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        x = NULL;\n    }\n\n    i = ssl_verify_cert_chain(s, sk);\n    /*\n     * The documented interface is that SSL_VERIFY_PEER should be set in order\n     * for client side verification of the server certificate to take place.\n     * However, historically the code has only checked that *any* flag is set\n     * to cause server verification to take place. Use of the other flags makes\n     * no sense in client mode. An attempt to clean up the semantics was\n     * reverted because at least one application *only* set\n     * SSL_VERIFY_FAIL_IF_NO_PEER_CERT. Prior to the clean up this still caused\n     * server verification to take place, after the clean up it silently did\n     * nothing. SSL_CTX_set_verify()/SSL_set_verify() cannot validate the flags\n     * sent to them because they are void functions. Therefore, we now use the\n     * (less clean) historic behaviour of performing validation if any flag is\n     * set. The *documented* interface remains the same.\n     */\n    if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n        al = ssl_verify_alarm_type(s->verify_result);\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_CERTIFICATE_VERIFY_FAILED);\n        goto f_err;\n    }\n    ERR_clear_error();          /* but we keep s->verify_result */\n    if (i > 1) {\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE, i);\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        goto f_err;\n    }\n\n    s->session->peer_chain = sk;\n    /*\n     * Inconsistency alert: cert_chain does include the peer's certificate,\n     * which we don't include in statem_srvr.c\n     */\n    x = sk_X509_value(sk, 0);\n    sk = NULL;\n    /*\n     * VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @end\n     */\n\n    pkey = X509_get0_pubkey(x);\n\n    if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n        x = NULL;\n        al = SSL3_AL_FATAL;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n        goto f_err;\n    }\n\n    i = ssl_cert_type(x, pkey);\n    if (i < 0) {\n        x = NULL;\n        al = SSL3_AL_FATAL;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n        goto f_err;\n    }\n\n    exp_idx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);\n    if (exp_idx >= 0 && i != exp_idx\n        && (exp_idx != SSL_PKEY_GOST_EC ||\n            (i != SSL_PKEY_GOST12_512 && i != SSL_PKEY_GOST12_256\n             && i != SSL_PKEY_GOST01))) {\n        x = NULL;\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_CERTIFICATE,\n               SSL_R_WRONG_CERTIFICATE_TYPE);\n        goto f_err;\n    }\n    s->session->peer_type = i;\n\n    X509_free(s->session->peer);\n    X509_up_ref(x);\n    s->session->peer = x;\n    s->session->verify_result = s->verify_result;\n\n    x = NULL;\n    ret = MSG_PROCESS_CONTINUE_READING;\n    goto done;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n done:\n    X509_free(x);\n    sk_X509_pop_free(sk, X509_free);\n    return ret;\n}\n\nstatic int tls_process_ske_psk_preamble(SSL *s, PACKET *pkt, int *al)\n{\n#ifndef OPENSSL_NO_PSK\n    PACKET psk_identity_hint;\n\n    /* PSK ciphersuites are preceded by an identity hint */\n\n    if (!PACKET_get_length_prefixed_2(pkt, &psk_identity_hint)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    /*\n     * Store PSK identity hint for later use, hint is used in\n     * tls_construct_client_key_exchange.  Assume that the maximum length of\n     * a PSK identity hint can be as long as the maximum length of a PSK\n     * identity.\n     */\n    if (PACKET_remaining(&psk_identity_hint) > PSK_MAX_IDENTITY_LEN) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE, SSL_R_DATA_LENGTH_TOO_LONG);\n        return 0;\n    }\n\n    if (PACKET_remaining(&psk_identity_hint) == 0) {\n        OPENSSL_free(s->session->psk_identity_hint);\n        s->session->psk_identity_hint = NULL;\n    } else if (!PACKET_strndup(&psk_identity_hint,\n                               &s->session->psk_identity_hint)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_process_ske_srp(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)\n{\n#ifndef OPENSSL_NO_SRP\n    PACKET prime, generator, salt, server_pub;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_1(pkt, &salt)\n        || !PACKET_get_length_prefixed_2(pkt, &server_pub)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    if ((s->srp_ctx.N =\n         BN_bin2bn(PACKET_data(&prime),\n                   PACKET_remaining(&prime), NULL)) == NULL\n        || (s->srp_ctx.g =\n            BN_bin2bn(PACKET_data(&generator),\n                      PACKET_remaining(&generator), NULL)) == NULL\n        || (s->srp_ctx.s =\n            BN_bin2bn(PACKET_data(&salt),\n                      PACKET_remaining(&salt), NULL)) == NULL\n        || (s->srp_ctx.B =\n            BN_bin2bn(PACKET_data(&server_pub),\n                      PACKET_remaining(&server_pub), NULL)) == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, ERR_R_BN_LIB);\n        return 0;\n    }\n\n    if (!srp_verify_server_param(s, al)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, SSL_R_BAD_SRP_PARAMETERS);\n        return 0;\n    }\n\n    /* We must check if there is a certificate */\n    if (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_SRP, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    PACKET prime, generator, pub_key;\n    EVP_PKEY *peer_tmp = NULL;\n\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    peer_tmp = EVP_PKEY_new();\n    dh = DH_new();\n\n    if (peer_tmp == NULL || dh == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    p = BN_bin2bn(PACKET_data(&prime), PACKET_remaining(&prime), NULL);\n    g = BN_bin2bn(PACKET_data(&generator), PACKET_remaining(&generator), NULL);\n    bnpub_key = BN_bin2bn(PACKET_data(&pub_key), PACKET_remaining(&pub_key),\n                          NULL);\n    if (p == NULL || g == NULL || bnpub_key == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    if (BN_is_zero(p) || BN_is_zero(g) || BN_is_zero(bnpub_key)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, SSL_R_BAD_DH_VALUE);\n        goto err;\n    }\n\n    if (!DH_set0_pqg(dh, p, NULL, g)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_BN_LIB);\n        goto err;\n    }\n    p = g = NULL;\n\n    if (!DH_set0_key(dh, bnpub_key, NULL)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_BN_LIB);\n        goto err;\n    }\n    bnpub_key = NULL;\n\n    if (!ssl_security(s, SSL_SECOP_TMP_DH, DH_security_bits(dh), 0, dh)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, SSL_R_DH_KEY_TOO_SMALL);\n        goto err;\n    }\n\n    if (EVP_PKEY_assign_DH(peer_tmp, dh) == 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    s->s3->peer_tmp = peer_tmp;\n\n    /*\n     * FIXME: This makes assumptions about which ciphersuites come with\n     * public keys. We should have a less ad-hoc way of doing this\n     */\n    if (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aRSA | SSL_aDSS))\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous DH, so no certificate or pkey. */\n\n    return 1;\n\n err:\n    BN_free(p);\n    BN_free(g);\n    BN_free(bnpub_key);\n    DH_free(dh);\n    EVP_PKEY_free(peer_tmp);\n\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_process_ske_ecdhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    PACKET encoded_pt;\n    const unsigned char *ecparams;\n    int curve_nid;\n    unsigned int curve_flags;\n    EVP_PKEY_CTX *pctx = NULL;\n\n    /*\n     * Extract elliptic curve parameters and the server's ephemeral ECDH\n     * public key. For now we only support named (not generic) curves and\n     * ECParameters in this case is just three bytes.\n     */\n    if (!PACKET_get_bytes(pkt, &ecparams, 3)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_LENGTH_TOO_SHORT);\n        return 0;\n    }\n    /*\n     * Check curve is one of our preferences, if not server has sent an\n     * invalid curve. ECParameters is 3 bytes.\n     */\n    if (!tls1_check_curve(s, ecparams, 3)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_WRONG_CURVE);\n        return 0;\n    }\n\n    curve_nid = tls1_ec_curve_id2nid(*(ecparams + 2), &curve_flags);\n\n    if (curve_nid == 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE,\n               SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n        return 0;\n    }\n\n    if ((curve_flags & TLS_CURVE_TYPE) == TLS_CURVE_CUSTOM) {\n        EVP_PKEY *key = EVP_PKEY_new();\n\n        if (key == NULL || !EVP_PKEY_set_type(key, curve_nid)) {\n            *al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_EVP_LIB);\n            EVP_PKEY_free(key);\n            return 0;\n        }\n        s->s3->peer_tmp = key;\n    } else {\n        /* Set up EVP_PKEY with named curve as parameters */\n        pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);\n        if (pctx == NULL\n            || EVP_PKEY_paramgen_init(pctx) <= 0\n            || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, curve_nid) <= 0\n            || EVP_PKEY_paramgen(pctx, &s->s3->peer_tmp) <= 0) {\n            *al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_EVP_LIB);\n            EVP_PKEY_CTX_free(pctx);\n            return 0;\n        }\n        EVP_PKEY_CTX_free(pctx);\n        pctx = NULL;\n    }\n\n    if (!PACKET_get_length_prefixed_1(pkt, &encoded_pt)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n\n    if (!EVP_PKEY_set1_tls_encodedpoint(s->s3->peer_tmp,\n                                        PACKET_data(&encoded_pt),\n                                        PACKET_remaining(&encoded_pt))) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, SSL_R_BAD_ECPOINT);\n        return 0;\n    }\n\n    /*\n     * The ECC/TLS specification does not mention the use of DSA to sign\n     * ECParameters in the server key exchange message. We do support RSA\n     * and ECDSA.\n     */\n    if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aECDSA)\n        *pkey = X509_get0_pubkey(s->session->peer);\n    else if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aRSA)\n        *pkey = X509_get0_pubkey(s->session->peer);\n    /* else anonymous ECDH, so no certificate or pkey. */\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_PROCESS_SKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nMSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)\n{\n    int al = -1;\n    long alg_k;\n    EVP_PKEY *pkey = NULL;\n    PACKET save_param_start, signature;\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    save_param_start = *pkt;\n\n#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)\n    EVP_PKEY_free(s->s3->peer_tmp);\n    s->s3->peer_tmp = NULL;\n#endif\n\n    if (alg_k & SSL_PSK) {\n        if (!tls_process_ske_psk_preamble(s, pkt, &al))\n            goto err;\n    }\n\n    /* Nothing else to do for plain PSK or RSAPSK */\n    if (alg_k & (SSL_kPSK | SSL_kRSAPSK)) {\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_ske_srp(s, pkt, &pkey, &al))\n            goto err;\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_ske_dhe(s, pkt, &pkey, &al))\n            goto err;\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_ske_ecdhe(s, pkt, &pkey, &al))\n            goto err;\n    } else if (alg_k) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        PACKET params;\n        int maxsig;\n        const EVP_MD *md = NULL;\n        EVP_MD_CTX *md_ctx;\n\n        /*\n         * |pkt| now points to the beginning of the signature, so the difference\n         * equals the length of the parameters.\n         */\n        if (!PACKET_get_sub_packet(&save_param_start, &params,\n                                   PACKET_remaining(&save_param_start) -\n                                   PACKET_remaining(pkt))) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (SSL_USE_SIGALGS(s)) {\n            const unsigned char *sigalgs;\n            int rv;\n            if (!PACKET_get_bytes(pkt, &sigalgs, 2)) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n                goto err;\n            }\n            rv = tls12_check_peer_sigalg(&md, s, sigalgs, pkey);\n            if (rv == -1) {\n                al = SSL_AD_INTERNAL_ERROR;\n                goto err;\n            } else if (rv == 0) {\n                al = SSL_AD_DECODE_ERROR;\n                goto err;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n        } else if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA) {\n            md = EVP_md5_sha1();\n        } else {\n            md = EVP_sha1();\n        }\n\n        if (!PACKET_get_length_prefixed_2(pkt, &signature)\n            || PACKET_remaining(pkt) != 0) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n        maxsig = EVP_PKEY_size(pkey);\n        if (maxsig < 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        /*\n         * Check signature length\n         */\n        if (PACKET_remaining(&signature) > (size_t)maxsig) {\n            /* wrong packet length */\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE,\n                   SSL_R_WRONG_SIGNATURE_LENGTH);\n            goto err;\n        }\n\n        md_ctx = EVP_MD_CTX_new();\n        if (md_ctx == NULL) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (EVP_VerifyInit_ex(md_ctx, md, NULL) <= 0\n            || EVP_VerifyUpdate(md_ctx, &(s->s3->client_random[0]),\n                                SSL3_RANDOM_SIZE) <= 0\n            || EVP_VerifyUpdate(md_ctx, &(s->s3->server_random[0]),\n                                SSL3_RANDOM_SIZE) <= 0\n            || EVP_VerifyUpdate(md_ctx, PACKET_data(&params),\n                                PACKET_remaining(&params)) <= 0) {\n            EVP_MD_CTX_free(md_ctx);\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);\n            goto err;\n        }\n        if (EVP_VerifyFinal(md_ctx, PACKET_data(&signature),\n                            PACKET_remaining(&signature), pkey) <= 0) {\n            /* bad signature */\n            EVP_MD_CTX_free(md_ctx);\n            al = SSL_AD_DECRYPT_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n            goto err;\n        }\n        EVP_MD_CTX_free(md_ctx);\n    } else {\n        /* aNULL, aSRP or PSK do not need public keys */\n        if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n            && !(alg_k & SSL_PSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s)) {\n                /* Otherwise this shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            } else {\n                al = SSL_AD_DECODE_ERROR;\n            }\n            goto err;\n        }\n        /* still data left over */\n        if (PACKET_remaining(pkt) != 0) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto err;\n        }\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n err:\n    if (al != -1)\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_certificate_request(SSL *s, PACKET *pkt)\n{\n    int ret = MSG_PROCESS_ERROR;\n    unsigned int list_len, ctype_num, i, name_len;\n    X509_NAME *xn = NULL;\n    const unsigned char *data;\n    const unsigned char *namestart, *namebytes;\n    STACK_OF(X509_NAME) *ca_sk = NULL;\n\n    if ((ca_sk = sk_X509_NAME_new(ca_dn_cmp)) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* get the certificate types */\n    if (!PACKET_get_1(pkt, &ctype_num)\n        || !PACKET_get_bytes(pkt, &data, ctype_num)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    OPENSSL_free(s->cert->ctypes);\n    s->cert->ctypes = NULL;\n    if (ctype_num > SSL3_CT_NUMBER) {\n        /* If we exceed static buffer copy all to cert structure */\n        s->cert->ctypes = OPENSSL_malloc(ctype_num);\n        if (s->cert->ctypes == NULL) {\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(s->cert->ctypes, data, ctype_num);\n        s->cert->ctype_num = (size_t)ctype_num;\n        ctype_num = SSL3_CT_NUMBER;\n    }\n    for (i = 0; i < ctype_num; i++)\n        s->s3->tmp.ctype[i] = data[i];\n\n    if (SSL_USE_SIGALGS(s)) {\n        if (!PACKET_get_net_2(pkt, &list_len)\n            || !PACKET_get_bytes(pkt, &data, list_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /* Clear certificate digests and validity flags */\n        for (i = 0; i < SSL_PKEY_NUM; i++) {\n            s->s3->tmp.md[i] = NULL;\n            s->s3->tmp.valid_flags[i] = 0;\n        }\n        if ((list_len & 1) || !tls1_save_sigalgs(s, data, list_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_SIGNATURE_ALGORITHMS_ERROR);\n            goto err;\n        }\n        if (!tls1_process_sigalgs(s)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        ssl_set_default_md(s);\n    }\n\n    /* get the CA RDNs */\n    if (!PACKET_get_net_2(pkt, &list_len)\n        || PACKET_remaining(pkt) != list_len) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n\n    while (PACKET_remaining(pkt)) {\n        if (!PACKET_get_net_2(pkt, &name_len)\n            || !PACKET_get_bytes(pkt, &namebytes, name_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        namestart = namebytes;\n\n        if ((xn = d2i_X509_NAME(NULL, (const unsigned char **)&namebytes,\n                                name_len)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (namebytes != (namestart + name_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_CA_DN_LENGTH_MISMATCH);\n            goto err;\n        }\n        if (!sk_X509_NAME_push(ca_sk, xn)) {\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        xn = NULL;\n    }\n\n    /* we should setup a certificate to return.... */\n    s->s3->tmp.cert_req = 1;\n    s->s3->tmp.ctype_num = ctype_num;\n    sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\n    s->s3->tmp.ca_names = ca_sk;\n    ca_sk = NULL;\n\n    ret = MSG_PROCESS_CONTINUE_PROCESSING;\n    goto done;\n err:\n    ossl_statem_set_error(s);\n done:\n    X509_NAME_free(xn);\n    sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);\n    return ret;\n}\n\nstatic int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b)\n{\n    return (X509_NAME_cmp(*a, *b));\n}\n\nMSG_PROCESS_RETURN tls_process_new_session_ticket(SSL *s, PACKET *pkt)\n{\n    int al;\n    unsigned int ticklen;\n    unsigned long ticket_lifetime_hint;\n\n    if (!PACKET_get_net_4(pkt, &ticket_lifetime_hint)\n        || !PACKET_get_net_2(pkt, &ticklen)\n        || PACKET_remaining(pkt) != ticklen) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    /* Server is allowed to change its mind and send an empty ticket. */\n    if (ticklen == 0)\n        return MSG_PROCESS_CONTINUE_READING;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache. We carry on if this fails\n             */\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    OPENSSL_free(s->session->tlsext_tick);\n    s->session->tlsext_ticklen = 0;\n\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (s->session->tlsext_tick == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (!PACKET_copy_bytes(pkt, s->session->tlsext_tick, ticklen)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    s->session->tlsext_tick_lifetime_hint = ticket_lifetime_hint;\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    if (!EVP_Digest(s->session->tlsext_tick, ticklen,\n                    s->session->session_id, &s->session->session_id_length,\n                    EVP_sha256(), NULL)) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_EVP_LIB);\n        goto err;\n    }\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_cert_status(SSL *s, PACKET *pkt)\n{\n    int al;\n    unsigned long resplen;\n    unsigned int type;\n\n    if (!PACKET_get_1(pkt, &type)\n        || type != TLSEXT_STATUSTYPE_ocsp) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, SSL_R_UNSUPPORTED_STATUS_TYPE);\n        goto f_err;\n    }\n    if (!PACKET_get_net_3(pkt, &resplen)\n        || PACKET_remaining(pkt) != resplen) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    s->tlsext_ocsp_resp = OPENSSL_malloc(resplen);\n    if (s->tlsext_ocsp_resp == NULL) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, ERR_R_MALLOC_FAILURE);\n        goto f_err;\n    }\n    if (!PACKET_copy_bytes(pkt, s->tlsext_ocsp_resp, resplen)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    s->tlsext_ocsp_resplen = resplen;\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}\n\nMSG_PROCESS_RETURN tls_process_server_done(SSL *s, PACKET *pkt)\n{\n    if (PACKET_remaining(pkt) > 0) {\n        /* should contain no data */\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE, SSL_R_LENGTH_MISMATCH);\n        ossl_statem_set_error(s);\n        return MSG_PROCESS_ERROR;\n    }\n#ifndef OPENSSL_NO_SRP\n    if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n        if (SRP_Calc_A_param(s) <= 0) {\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE, SSL_R_SRP_A_CALC);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            ossl_statem_set_error(s);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n#endif\n\n    /*\n     * at this point we check that we have the required stuff from\n     * the server\n     */\n    if (!ssl3_check_cert_and_algorithm(s)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        ossl_statem_set_error(s);\n        return MSG_PROCESS_ERROR;\n    }\n\n    /*\n     * Call the ocsp status callback if needed. The |tlsext_ocsp_resp| and\n     * |tlsext_ocsp_resplen| values will be set if we actually received a status\n     * message, or NULL and -1 otherwise\n     */\n    if (s->tlsext_status_type != -1 && s->ctx->tlsext_status_cb != NULL) {\n        int ret;\n        ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n        if (ret == 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL,\n                            SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE);\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE,\n                   SSL_R_INVALID_STATUS_RESPONSE);\n            return MSG_PROCESS_ERROR;\n        }\n        if (ret < 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_SERVER_DONE, ERR_R_MALLOC_FAILURE);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n#ifndef OPENSSL_NO_CT\n    if (s->ct_validation_callback != NULL) {\n        /* Note we validate the SCTs whether or not we abort on error */\n        if (!ssl_validate_ct(s) && (s->verify_mode & SSL_VERIFY_PEER)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n#endif\n\n#ifndef OPENSSL_NO_SCTP\n    /* Only applies to renegotiation */\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))\n        && s->renegotiate != 0)\n        return MSG_PROCESS_CONTINUE_PROCESSING;\n    else\n#endif\n        return MSG_PROCESS_FINISHED_READING;\n}\n\nstatic int tls_construct_cke_psk_preamble(SSL *s, unsigned char **p,\n                                          size_t *pskhdrlen, int *al)\n{\n#ifndef OPENSSL_NO_PSK\n    int ret = 0;\n    /*\n     * The callback needs PSK_MAX_IDENTITY_LEN + 1 bytes to return a\n     * \\0-terminated identity. The last byte is for us for simulating\n     * strnlen.\n     */\n    char identity[PSK_MAX_IDENTITY_LEN + 1];\n    size_t identitylen = 0;\n    unsigned char psk[PSK_MAX_PSK_LEN];\n    unsigned char *tmppsk = NULL;\n    char *tmpidentity = NULL;\n    size_t psklen = 0;\n\n    if (s->psk_client_callback == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, SSL_R_PSK_NO_CLIENT_CB);\n        *al = SSL_AD_INTERNAL_ERROR;\n        goto err;\n    }\n\n    memset(identity, 0, sizeof(identity));\n\n    psklen = s->psk_client_callback(s, s->session->psk_identity_hint,\n                                    identity, sizeof(identity) - 1,\n                                    psk, sizeof(psk));\n\n    if (psklen > PSK_MAX_PSK_LEN) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        goto err;\n    } else if (psklen == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE,\n               SSL_R_PSK_IDENTITY_NOT_FOUND);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        goto err;\n    }\n\n    identitylen = strlen(identity);\n    if (identitylen > PSK_MAX_IDENTITY_LEN) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        goto err;\n    }\n\n    tmppsk = OPENSSL_memdup(psk, psklen);\n    tmpidentity = OPENSSL_strdup(identity);\n    if (tmppsk == NULL || tmpidentity == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_MALLOC_FAILURE);\n        *al = SSL_AD_INTERNAL_ERROR;\n        goto err;\n    }\n\n    OPENSSL_free(s->s3->tmp.psk);\n    s->s3->tmp.psk = tmppsk;\n    s->s3->tmp.psklen = psklen;\n    tmppsk = NULL;\n    OPENSSL_free(s->session->psk_identity);\n    s->session->psk_identity = tmpidentity;\n    tmpidentity = NULL;\n    s2n(identitylen, *p);\n    memcpy(*p, identity, identitylen);\n    *pskhdrlen = 2 + identitylen;\n    *p += identitylen;\n\n    ret = 1;\n\n err:\n    OPENSSL_cleanse(psk, psklen);\n    OPENSSL_cleanse(identity, sizeof(identity));\n    OPENSSL_clear_free(tmppsk, psklen);\n    OPENSSL_clear_free(tmpidentity, identitylen);\n\n    return ret;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_rsa(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    size_t enclen;\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    if (s->session->peer == NULL) {\n        /*\n         * We should always have a server certificate with SSL_kRSA.\n         */\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    pkey = X509_get0_pubkey(s->session->peer);\n    if (EVP_PKEY_get0_RSA(pkey) == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    pmslen = SSL_MAX_MASTER_KEY_LENGTH;\n    pms = OPENSSL_malloc(pmslen);\n    if (pms == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_MALLOC_FAILURE);\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n    pms[0] = s->client_version >> 8;\n    pms[1] = s->client_version & 0xff;\n    if (RAND_bytes(pms + 2, pmslen - 2) <= 0) {\n        goto err;\n    }\n\n    q = *p;\n    /* Fix buf for TLS and beyond */\n    if (s->version > SSL3_VERSION)\n        *p += 2;\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (pctx == NULL || EVP_PKEY_encrypt_init(pctx) <= 0\n        || EVP_PKEY_encrypt(pctx, NULL, &enclen, pms, pmslen) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_EVP_LIB);\n        goto err;\n    }\n    if (EVP_PKEY_encrypt(pctx, *p, &enclen, pms, pmslen) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, SSL_R_BAD_RSA_ENCRYPT);\n        goto err;\n    }\n    *len = enclen;\n    EVP_PKEY_CTX_free(pctx);\n    pctx = NULL;\n# ifdef PKCS1_CHECK\n    if (s->options & SSL_OP_PKCS1_CHECK_1)\n        (*p)[1]++;\n    if (s->options & SSL_OP_PKCS1_CHECK_2)\n        tmp_buf[0] = 0x70;\n# endif\n\n    /* Fix buf for TLS and beyond */\n    if (s->version > SSL3_VERSION) {\n        s2n(*len, q);\n        *len += 2;\n    }\n\n    s->s3->tmp.pms = pms;\n    s->s3->tmp.pmslen = pmslen;\n\n    return 1;\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    EVP_PKEY_CTX_free(pctx);\n\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_RSA, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    DH *dh_clnt = NULL;\n    const BIGNUM *pub_key;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    dh_clnt = EVP_PKEY_get0_DH(ckey);\n\n    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ckey);\n        return 0;\n    }\n\n    /* send off the data */\n    DH_get0_key(dh_clnt, &pub_key, NULL);\n    *len = BN_num_bytes(pub_key);\n    s2n(*len, *p);\n    BN_bn2bin(pub_key, *p);\n    *len += 2;\n    EVP_PKEY_free(ckey);\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_gost(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_GOST\n    /* GOST key exchange message creation */\n    EVP_PKEY_CTX *pkey_ctx = NULL;\n    X509 *peer_cert;\n    size_t msglen;\n    unsigned int md_len;\n    unsigned char shared_ukm[32], tmp[256];\n    EVP_MD_CTX *ukm_hash = NULL;\n    int dgst_nid = NID_id_GostR3411_94;\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    if ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aGOST12) != 0)\n        dgst_nid = NID_id_GostR3411_2012_256;\n\n    /*\n     * Get server sertificate PKEY and create ctx from it\n     */\n    peer_cert = s->session->peer;\n    if (!peer_cert) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST,\n               SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n        return 0;\n    }\n\n    pkey_ctx = EVP_PKEY_CTX_new(X509_get0_pubkey(peer_cert), NULL);\n    if (pkey_ctx == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    /*\n     * If we have send a certificate, and certificate key\n     * parameters match those of server certificate, use\n     * certificate key for key exchange\n     */\n\n    /* Otherwise, generate ephemeral key pair */\n    pmslen = 32;\n    pms = OPENSSL_malloc(pmslen);\n    if (pms == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_encrypt_init(pkey_ctx) <= 0\n        /* Generate session key */\n        || RAND_bytes(pms, pmslen) <= 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_INTERNAL_ERROR);\n        goto err;\n    };\n    /*\n     * Compute shared IV and store it in algorithm-specific context\n     * data\n     */\n    ukm_hash = EVP_MD_CTX_new();\n    if (ukm_hash == NULL\n        || EVP_DigestInit(ukm_hash, EVP_get_digestbynid(dgst_nid)) <= 0\n        || EVP_DigestUpdate(ukm_hash, s->s3->client_random,\n                            SSL3_RANDOM_SIZE) <= 0\n        || EVP_DigestUpdate(ukm_hash, s->s3->server_random,\n                            SSL3_RANDOM_SIZE) <= 0\n        || EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    EVP_MD_CTX_free(ukm_hash);\n    ukm_hash = NULL;\n    if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT,\n                          EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) < 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, SSL_R_LIBRARY_BUG);\n        goto err;\n    }\n    /* Make GOST keytransport blob message */\n    /*\n     * Encapsulate it into sequence\n     */\n    *((*p)++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;\n    msglen = 255;\n    if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, SSL_R_LIBRARY_BUG);\n        goto err;\n    }\n    if (msglen >= 0x80) {\n        *((*p)++) = 0x81;\n        *((*p)++) = msglen & 0xff;\n        *len = msglen + 3;\n    } else {\n        *((*p)++) = msglen & 0xff;\n        *len = msglen + 2;\n    }\n    memcpy(*p, tmp, msglen);\n\n    EVP_PKEY_CTX_free(pkey_ctx);\n    s->s3->tmp.pms = pms;\n    s->s3->tmp.pmslen = pmslen;\n\n    return 1;\n err:\n    EVP_PKEY_CTX_free(pkey_ctx);\n    OPENSSL_clear_free(pms, pmslen);\n    EVP_MD_CTX_free(ukm_hash);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_GOST, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nstatic int tls_construct_cke_srp(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_SRP\n    if (s->srp_ctx.A != NULL) {\n        /* send off the data */\n        *len = BN_num_bytes(s->srp_ctx.A);\n        s2n(*len, *p);\n        BN_bn2bin(s->srp_ctx.A, *p);\n        *len += 2;\n    } else {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_SRP, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    OPENSSL_free(s->session->srp_username);\n    s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login);\n    if (s->session->srp_username == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_SRP, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_SRP, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n\nint tls_construct_client_key_exchange(SSL *s)\n{\n    unsigned char *p;\n    int len;\n    size_t pskhdrlen = 0;\n    unsigned long alg_k;\n    int al = -1;\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    p = ssl_handshake_start(s);\n\n    if ((alg_k & SSL_PSK)\n        && !tls_construct_cke_psk_preamble(s, &p, &pskhdrlen, &al))\n        goto err;\n\n    if (alg_k & SSL_kPSK) {\n        len = 0;\n    } else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) {\n        if (!tls_construct_cke_rsa(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_construct_cke_dhe(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_construct_cke_ecdhe(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & SSL_kGOST) {\n        if (!tls_construct_cke_gost(s, &p, &len, &al))\n            goto err;\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_construct_cke_srp(s, &p, &len, &al))\n            goto err;\n    } else {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    len += pskhdrlen;\n\n    if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, len)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    return 1;\n err:\n    if (al != -1)\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    OPENSSL_clear_free(s->s3->tmp.pms, s->s3->tmp.pmslen);\n    s->s3->tmp.pms = NULL;\n#ifndef OPENSSL_NO_PSK\n    OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen);\n    s->s3->tmp.psk = NULL;\n#endif\n    ossl_statem_set_error(s);\n    return 0;\n}\n\nint tls_client_key_exchange_post_work(SSL *s)\n{\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    pms = s->s3->tmp.pms;\n    pmslen = s->s3->tmp.pmslen;\n\n#ifndef OPENSSL_NO_SRP\n    /* Check for SRP */\n    if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n        if (!srp_generate_client_master_secret(s)) {\n            SSLerr(SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        return 1;\n    }\n#endif\n\n    if (pms == NULL && !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        SSLerr(SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (!ssl_generate_master_secret(s, pms, pmslen, 1)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        SSLerr(SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK, ERR_R_INTERNAL_ERROR);\n        /* ssl_generate_master_secret frees the pms even on error */\n        pms = NULL;\n        pmslen = 0;\n        goto err;\n    }\n    pms = NULL;\n    pmslen = 0;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s)) {\n        unsigned char sctpauthkey[64];\n        char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];\n\n        /*\n         * Add new shared key for SCTP-Auth, will be ignored if no SCTP\n         * used.\n         */\n        memcpy(labelbuffer, DTLS1_SCTP_AUTH_LABEL,\n               sizeof(DTLS1_SCTP_AUTH_LABEL));\n\n        if (SSL_export_keying_material(s, sctpauthkey,\n                                       sizeof(sctpauthkey), labelbuffer,\n                                       sizeof(labelbuffer), NULL, 0, 0) <= 0)\n            goto err;\n\n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n                 sizeof(sctpauthkey), sctpauthkey);\n    }\n#endif\n\n    return 1;\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    s->s3->tmp.pms = NULL;\n    return 0;\n}\n\nint tls_construct_client_verify(SSL *s)\n{\n    unsigned char *p;\n    EVP_PKEY *pkey;\n    const EVP_MD *md = s->s3->tmp.md[s->cert->key - s->cert->pkeys];\n    EVP_MD_CTX *mctx;\n    unsigned u = 0;\n    unsigned long n = 0;\n    long hdatalen = 0;\n    void *hdata;\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    p = ssl_handshake_start(s);\n    pkey = s->cert->key->privatekey;\n\n    hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n    if (hdatalen <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (SSL_USE_SIGALGS(s)) {\n        if (!tls12_get_sigandhash(p, pkey, md)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        p += 2;\n        n = 2;\n    }\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"Using client alg %s\\n\", EVP_MD_name(md));\n#endif\n    if (!EVP_SignInit_ex(mctx, md, NULL)\n        || !EVP_SignUpdate(mctx, hdata, hdatalen)\n        || (s->version == SSL3_VERSION\n            && !EVP_MD_CTX_ctrl(mctx, EVP_CTRL_SSL3_MASTER_SECRET,\n                                s->session->master_key_length,\n                                s->session->master_key))\n        || !EVP_SignFinal(mctx, p + 2, &u, pkey)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_EVP_LIB);\n        goto err;\n    }\n#ifndef OPENSSL_NO_GOST\n    {\n        int pktype = EVP_PKEY_id(pkey);\n        if (pktype == NID_id_GostR3410_2001\n            || pktype == NID_id_GostR3410_2012_256\n            || pktype == NID_id_GostR3410_2012_512)\n            BUF_reverse(p + 2, NULL, u);\n    }\n#endif\n\n    s2n(u, p);\n    n += u + 2;\n    /* Digest cached records and discard handshake buffer */\n    if (!ssl3_digest_cached_records(s, 0))\n        goto err;\n    if (!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_VERIFY, n)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    EVP_MD_CTX_free(mctx);\n    return 1;\n err:\n    EVP_MD_CTX_free(mctx);\n    return 0;\n}\n\n/*\n * Check a certificate can be used for client authentication. Currently check\n * cert exists, if we have a suitable digest for TLS 1.2 if static DH client\n * certificates can be used and optionally checks suitability for Suite B.\n */\nstatic int ssl3_check_client_certificate(SSL *s)\n{\n    if (!s->cert || !s->cert->key->x509 || !s->cert->key->privatekey)\n        return 0;\n    /* If no suitable signature algorithm can't use certificate */\n    if (SSL_USE_SIGALGS(s) && !s->s3->tmp.md[s->cert->key - s->cert->pkeys])\n        return 0;\n    /*\n     * If strict mode check suitability of chain before using it. This also\n     * adjusts suite B digest if necessary.\n     */\n    if (s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT &&\n        !tls1_check_chain(s, NULL, NULL, NULL, -2))\n        return 0;\n    return 1;\n}\n\nWORK_STATE tls_prepare_client_certificate(SSL *s, WORK_STATE wst)\n{\n    X509 *x509 = NULL;\n    EVP_PKEY *pkey = NULL;\n    int i;\n\n    if (wst == WORK_MORE_A) {\n        /* Let cert callback update client certificates if required */\n        if (s->cert->cert_cb) {\n            i = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n            if (i < 0) {\n                s->rwstate = SSL_X509_LOOKUP;\n                return WORK_MORE_A;\n            }\n            if (i == 0) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                ossl_statem_set_error(s);\n                return 0;\n            }\n            s->rwstate = SSL_NOTHING;\n        }\n        if (ssl3_check_client_certificate(s))\n            return WORK_FINISHED_CONTINUE;\n\n        /* Fall through to WORK_MORE_B */\n        wst = WORK_MORE_B;\n    }\n\n    /* We need to get a client cert */\n    if (wst == WORK_MORE_B) {\n        /*\n         * If we get an error, we need to ssl->rwstate=SSL_X509_LOOKUP;\n         * return(-1); We then get retied later\n         */\n        i = ssl_do_client_cert_cb(s, &x509, &pkey);\n        if (i < 0) {\n            s->rwstate = SSL_X509_LOOKUP;\n            return WORK_MORE_B;\n        }\n        s->rwstate = SSL_NOTHING;\n        if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {\n            if (!SSL_use_certificate(s, x509) || !SSL_use_PrivateKey(s, pkey))\n                i = 0;\n        } else if (i == 1) {\n            i = 0;\n            SSLerr(SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE,\n                   SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\n        }\n\n        X509_free(x509);\n        EVP_PKEY_free(pkey);\n        if (i && !ssl3_check_client_certificate(s))\n            i = 0;\n        if (i == 0) {\n            if (s->version == SSL3_VERSION) {\n                s->s3->tmp.cert_req = 0;\n                ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE);\n                return WORK_FINISHED_CONTINUE;\n            } else {\n                s->s3->tmp.cert_req = 2;\n                if (!ssl3_digest_cached_records(s, 0)) {\n                    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                    ossl_statem_set_error(s);\n                    return 0;\n                }\n            }\n        }\n\n        return WORK_FINISHED_CONTINUE;\n    }\n\n    /* Shouldn't ever get here */\n    return WORK_ERROR;\n}\n\nint tls_construct_client_certificate(SSL *s)\n{\n    if (!ssl3_output_cert_chain(s,\n                                (s->s3->tmp.cert_req ==\n                                 2) ? NULL : s->cert->key)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n\n    return 1;\n}\n\n#define has_bits(i,m)   (((i)&(m)) == (m))\n\nint ssl3_check_cert_and_algorithm(SSL *s)\n{\n    int i;\n#ifndef OPENSSL_NO_EC\n    int idx;\n#endif\n    long alg_k, alg_a;\n    EVP_PKEY *pkey = NULL;\n    int al = SSL_AD_HANDSHAKE_FAILURE;\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\n    /* we don't have a certificate */\n    if ((alg_a & SSL_aNULL) || (alg_k & SSL_kPSK))\n        return (1);\n\n    /* This is the passed certificate */\n\n#ifndef OPENSSL_NO_EC\n    idx = s->session->peer_type;\n    if (idx == SSL_PKEY_ECC) {\n        if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s) == 0) {\n            /* check failed */\n            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);\n            goto f_err;\n        } else {\n            return 1;\n        }\n    } else if (alg_a & SSL_aECDSA) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_ECDSA_SIGNING_CERT);\n        goto f_err;\n    }\n#endif\n    pkey = X509_get0_pubkey(s->session->peer);\n    i = X509_certificate_type(s->session->peer, pkey);\n\n    /* Check that we have a certificate if we require one */\n    if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_RSA_SIGNING_CERT);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_DSA\n    else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_DSA_SIGNING_CERT);\n        goto f_err;\n    }\n#endif\n#ifndef OPENSSL_NO_RSA\n    if (alg_k & (SSL_kRSA | SSL_kRSAPSK) &&\n        !has_bits(i, EVP_PK_RSA | EVP_PKT_ENC)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n        goto f_err;\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    if ((alg_k & SSL_kDHE) && (s->s3->peer_tmp == NULL)) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n#endif\n\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (0);\n}\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\nint tls_construct_next_proto(SSL *s)\n{\n    unsigned int len, padding_len;\n    unsigned char *d;\n\n    len = s->next_proto_negotiated_len;\n    padding_len = 32 - ((len + 2) % 32);\n    d = (unsigned char *)s->init_buf->data;\n    d[4] = len;\n    memcpy(d + 5, s->next_proto_negotiated, len);\n    d[5 + len] = padding_len;\n    memset(d + 6 + len, 0, padding_len);\n    *(d++) = SSL3_MT_NEXT_PROTO;\n    l2n3(2 + len + padding_len, d);\n    s->init_num = 4 + 2 + len + padding_len;\n    s->init_off = 0;\n\n    return 1;\n}\n#endif\n\nint ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey)\n{\n    int i = 0;\n#ifndef OPENSSL_NO_ENGINE\n    if (s->ctx->client_cert_engine) {\n        i = ENGINE_load_ssl_client_cert(s->ctx->client_cert_engine, s,\n                                        SSL_get_client_CA_list(s),\n                                        px509, ppkey, NULL, NULL, NULL);\n        if (i != 0)\n            return i;\n    }\n#endif\n    if (s->ctx->client_cert_cb)\n        i = s->ctx->client_cert_cb(s, px509, ppkey);\n    return i;\n}\n\nint ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk, unsigned char *p)\n{\n    int i, j = 0;\n    const SSL_CIPHER *c;\n    unsigned char *q;\n    int empty_reneg_info_scsv = !s->renegotiate;\n    /* Set disabled masks for this session */\n    ssl_set_client_disabled(s);\n\n    if (sk == NULL)\n        return (0);\n    q = p;\n\n    for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\n        c = sk_SSL_CIPHER_value(sk, i);\n        /* Skip disabled ciphers */\n        if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_SUPPORTED))\n            continue;\n        j = s->method->put_cipher_by_char(c, p);\n        p += j;\n    }\n    /*\n     * If p == q, no ciphers; caller indicates an error. Otherwise, add\n     * applicable SCSVs.\n     */\n    if (p != q) {\n        if (empty_reneg_info_scsv) {\n            static SSL_CIPHER scsv = {\n                0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0\n            };\n            j = s->method->put_cipher_by_char(&scsv, p);\n            p += j;\n        }\n        if (s->mode & SSL_MODE_SEND_FALLBACK_SCSV) {\n            static SSL_CIPHER scsv = {\n                0, NULL, SSL3_CK_FALLBACK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0\n            };\n            j = s->method->put_cipher_by_char(&scsv, p);\n            p += j;\n        }\n    }\n\n    return (p - q);\n}\n"], "filenames": ["ssl/statem/statem_clnt.c"], "buggy_code_start_loc": [2260], "buggy_code_end_loc": [2298], "fixing_code_start_loc": [2261], "fixing_code_end_loc": [2308], "type": "CWE-476", "message": "In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.", "other": {"cve": {"id": "CVE-2017-3730", "sourceIdentifier": "openssl-security@openssl.org", "published": "2017-05-04T19:29:00.320", "lastModified": "2019-04-25T13:59:36.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack."}, {"lang": "es", "value": "En OpenSSL versi\u00f3n 1.1.0 anterior a 1.1.0d, si un servidor malicioso suministra par\u00e1metros incorrectos para un intercambio de claves DHE o ECDHE, entonces esto puede resultar en que el cliente intente desreferenciar un puntero NULL que conduce a un bloqueo del cliente. Esto podr\u00eda ser explotado en un ataque de denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "73104834-5810-48DD-9B97-549D223853F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:1.1.0a:*:*:*:*:*:*:*", "matchCriteriaId": "C9D7A18A-116B-4F68-BEA3-A4E9DDDA55C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:1.1.0b:*:*:*:*:*:*:*", "matchCriteriaId": "CFC70262-0DCD-4B46-9C96-FD18D0207511"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:1.1.0c:*:*:*:*:*:*:*", "matchCriteriaId": "B2E07A34-08A0-4765-AF81-46A3BDC5648A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:agile_engineering_data_management:6.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "61C5D278-11E5-4A2F-9860-6FFA579398CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:agile_engineering_data_management:6.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "1B21D189-0E7D-4878-91A0-BE38A4ABA1FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "CC967A48-D834-4E9B-8CEC-057E7D5B8174"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F920CDE4-DF29-4611-93E9-A386C89EDB62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_eagle_lnp_application_processor:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "D195BC4C-DAC2-4C71-B83B-4149E86B5F42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_eagle_lnp_application_processor:10.1:*:*:*:*:*:*:*", "matchCriteriaId": "996861FC-0089-4BED-8E46-F2B76037EA65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_eagle_lnp_application_processor:10.2:*:*:*:*:*:*:*", "matchCriteriaId": "37764AF5-E42E-461E-AA43-763D21B3DCE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "D52F557F-D0A0-43D3-85F1-F10B6EBFAEDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3517A27-E6EE-497C-9996-F78171BBE90F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_enterpriseone_tools:9.2:*:*:*:*:*:*:*", "matchCriteriaId": "41684398-18A4-4DC6-B8A2-3EBAA0CBF9A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_world_security:a9.1:*:*:*:*:*:*:*", "matchCriteriaId": "B2ECA28E-E810-4D35-9151-FDBBBE069A81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_world_security:a9.2:*:*:*:*:*:*:*", "matchCriteriaId": "FA144657-7598-46E2-AB0A-FD332EDECEC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_world_security:a9.3:*:*:*:*:*:*:*", "matchCriteriaId": "83800E2F-804C-485D-A8FA-F4B32CDB4548"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_world_security:a9.4:*:*:*:*:*:*:*", "matchCriteriaId": "0B1CAD50-749F-4ADB-A046-BF3585677A58"}]}]}], "references": [{"url": "http://www.oracle.com/technetwork/security-advisory/cpujan2018-3236628.html", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/95812", "source": "openssl-security@openssl.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037717", "source": "openssl-security@openssl.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa", "source": "openssl-security@openssl.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-07", "source": "openssl-security@openssl.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbhf03838en_us", "source": "openssl-security@openssl.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/41192/", "source": "openssl-security@openssl.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.openssl.org/news/secadv/20170126.txt", "source": "openssl-security@openssl.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "openssl-security@openssl.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa"}}