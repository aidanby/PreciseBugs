{"buggy_code": ["<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Css;\n\nuse DOMElement;\nuse DOMXPath;\nuse Dompdf\\Dompdf;\nuse Dompdf\\Helpers;\nuse Dompdf\\Exception;\nuse Dompdf\\FontMetrics;\nuse Dompdf\\Frame\\FrameTree;\n\n/**\n * The master stylesheet class\n *\n * The Stylesheet class is responsible for parsing stylesheets and style\n * tags/attributes.  It also acts as a registry of the individual Style\n * objects generated by the current set of loaded CSS files and style\n * elements.\n *\n * @see Style\n * @package dompdf\n */\nclass Stylesheet\n{\n    /**\n     * The location of the default built-in CSS file.\n     */\n    const DEFAULT_STYLESHEET = \"/lib/res/html.css\";\n\n    /**\n     * User agent stylesheet origin\n     *\n     * @var int\n     */\n    const ORIG_UA = 1;\n\n    /**\n     * User normal stylesheet origin\n     *\n     * @var int\n     */\n    const ORIG_USER = 2;\n\n    /**\n     * Author normal stylesheet origin\n     *\n     * @var int\n     */\n    const ORIG_AUTHOR = 3;\n\n    /*\n     * The highest possible specificity is 0x01000000 (and that is only for author\n     * stylesheets, as it is for inline styles). Origin precedence can be achieved by\n     * adding multiples of 0x10000000 to the actual specificity. Important\n     * declarations are handled in Style; though technically they should be handled\n     * here so that user important declarations can be made to take precedence over\n     * user important declarations, this doesn't matter in practice as Dompdf does\n     * not support user stylesheets, and user agent stylesheets can not include\n     * important declarations.\n     */\n    private static $_stylesheet_origins = [\n        self::ORIG_UA => 0x00000000, // user agent declarations\n        self::ORIG_USER => 0x10000000, // user normal declarations\n        self::ORIG_AUTHOR => 0x30000000, // author normal declarations\n    ];\n\n    /**\n     * Non-CSS presentational hints (i.e. HTML 4 attributes) are handled as if added\n     * to the beginning of an author stylesheet, i.e. anything in author stylesheets\n     * should override them.\n     */\n    const SPEC_NON_CSS = 0x20000000;\n\n    /**\n     * Current dompdf instance\n     *\n     * @var Dompdf\n     */\n    private $_dompdf;\n\n    /**\n     * Array of currently defined styles\n     *\n     * @var Style[]\n     */\n    private $_styles;\n\n    /**\n     * Base protocol of the document being parsed\n     * Used to handle relative urls.\n     *\n     * @var string\n     */\n    private $_protocol = \"\";\n\n    /**\n     * Base hostname of the document being parsed\n     * Used to handle relative urls.\n     *\n     * @var string\n     */\n    private $_base_host = \"\";\n\n    /**\n     * Base path of the document being parsed\n     * Used to handle relative urls.\n     *\n     * @var string\n     */\n    private $_base_path = \"\";\n\n    /**\n     * The styles defined by @page rules\n     *\n     * @var array<Style>\n     */\n    private $_page_styles;\n\n    /**\n     * List of loaded files, used to prevent recursion\n     *\n     * @var array\n     */\n    private $_loaded_files;\n\n    /**\n     * Current stylesheet origin\n     *\n     * @var int\n     */\n    private $_current_origin = self::ORIG_UA;\n\n    /**\n     * Accepted CSS media types\n     * List of types and parsing rules for future extensions:\n     * http://www.w3.org/TR/REC-html40/types.html\n     *   screen, tty, tv, projection, handheld, print, braille, aural, all\n     * The following are non standard extensions for undocumented specific environments.\n     *   static, visual, bitmap, paged, dompdf\n     * Note, even though the generated pdf file is intended for print output,\n     * the desired content might be different (e.g. screen or projection view of html file).\n     * Therefore allow specification of content by dompdf setting Options::defaultMediaType.\n     * If given, replace media \"print\" by Options::defaultMediaType.\n     * (Previous version $ACCEPTED_MEDIA_TYPES = $ACCEPTED_GENERIC_MEDIA_TYPES + $ACCEPTED_DEFAULT_MEDIA_TYPE)\n     */\n    static $ACCEPTED_DEFAULT_MEDIA_TYPE = \"print\";\n    static $ACCEPTED_GENERIC_MEDIA_TYPES = [\"all\", \"static\", \"visual\", \"bitmap\", \"paged\", \"dompdf\"];\n    static $VALID_MEDIA_TYPES = [\"all\", \"aural\", \"bitmap\", \"braille\", \"dompdf\", \"embossed\", \"handheld\", \"paged\", \"print\", \"projection\", \"screen\", \"speech\", \"static\", \"tty\", \"tv\", \"visual\"];\n\n    /**\n     * @var FontMetrics\n     */\n    private $fontMetrics;\n\n    /**\n     * The class constructor.\n     *\n     * The base protocol, host & path are initialized to those of\n     * the current script.\n     */\n    function __construct(Dompdf $dompdf)\n    {\n        $this->_dompdf = $dompdf;\n        $this->setFontMetrics($dompdf->getFontMetrics());\n        $this->_styles = [];\n        $this->_loaded_files = [];\n        $script = __FILE__;\n        if (isset($_SERVER[\"SCRIPT_FILENAME\"])) {\n            $script = $_SERVER[\"SCRIPT_FILENAME\"];\n        }\n        list($this->_protocol, $this->_base_host, $this->_base_path) = Helpers::explode_url($script);\n        $this->_page_styles = [\"base\" => new Style($this)];\n    }\n\n    /**\n     * Set the base protocol\n     *\n     * @param string $protocol\n     */\n    function set_protocol(string $protocol)\n    {\n        $this->_protocol = $protocol;\n    }\n\n    /**\n     * Set the base host\n     *\n     * @param string $host\n     */\n    function set_host(string $host)\n    {\n        $this->_base_host = $host;\n    }\n\n    /**\n     * Set the base path\n     *\n     * @param string $path\n     */\n    function set_base_path(string $path)\n    {\n        $this->_base_path = $path;\n    }\n\n    /**\n     * Return the Dompdf object\n     *\n     * @return Dompdf\n     */\n    function get_dompdf()\n    {\n        return $this->_dompdf;\n    }\n\n    /**\n     * Return the base protocol for this stylesheet\n     *\n     * @return string\n     */\n    function get_protocol()\n    {\n        return $this->_protocol;\n    }\n\n    /**\n     * Return the base host for this stylesheet\n     *\n     * @return string\n     */\n    function get_host()\n    {\n        return $this->_base_host;\n    }\n\n    /**\n     * Return the base path for this stylesheet\n     *\n     * @return string\n     */\n    function get_base_path()\n    {\n        return $this->_base_path;\n    }\n\n    /**\n     * Return the array of page styles\n     *\n     * @return Style[]\n     */\n    function get_page_styles()\n    {\n        return $this->_page_styles;\n    }\n\n    /**\n     * Create a new Style object associated with this stylesheet\n     *\n     * @return Style\n     */\n    function create_style(): Style\n    {\n        return new Style($this, $this->_current_origin);\n    }\n\n    /**\n     * Add a new Style object to the stylesheet\n     *\n     * The style's origin is changed to the current origin of the stylesheet.\n     *\n     * @param string $key the Style's selector\n     * @param Style $style the Style to be added\n     */\n    function add_style(string $key, Style $style): void\n    {\n        if (!isset($this->_styles[$key])) {\n            $this->_styles[$key] = [];\n        }\n\n        $style->set_origin($this->_current_origin);\n        $this->_styles[$key][] = $style;\n    }\n\n    /**\n     * load and parse a CSS string\n     *\n     * @param string $css\n     * @param int $origin\n     */\n    function load_css(&$css, $origin = self::ORIG_AUTHOR)\n    {\n        if ($origin) {\n            $this->_current_origin = $origin;\n        }\n        $this->_parse_css($css);\n    }\n\n    /**\n     * load and parse a CSS file\n     *\n     * @param string $file\n     * @param int $origin\n     */\n    function load_css_file($file, $origin = self::ORIG_AUTHOR)\n    {\n        if ($origin) {\n            $this->_current_origin = $origin;\n        }\n\n        // Prevent circular references\n        if (isset($this->_loaded_files[$file])) {\n            return;\n        }\n\n        $this->_loaded_files[$file] = true;\n\n        if (strpos($file, \"data:\") === 0) {\n            $parsed = Helpers::parse_data_uri($file);\n            $css = $parsed[\"data\"];\n        } else {\n            $parsed_url = Helpers::explode_url($file);\n\n            [$this->_protocol, $this->_base_host, $this->_base_path, $filename] = $parsed_url;\n\n            $file = Helpers::build_url($this->_protocol, $this->_base_host, $this->_base_path, $filename);\n\n            $options = $this->_dompdf->getOptions();\n            // Download the remote file\n            if (!$options->isRemoteEnabled() && ($this->_protocol !== \"\" && $this->_protocol !== \"file://\")) {\n                Helpers::record_warnings(E_USER_WARNING, \"Remote CSS resource '$file' referenced, but remote file download is disabled.\", __FILE__, __LINE__);\n                return;\n            }\n            if ($this->_protocol === \"\" || $this->_protocol === \"file://\") {\n                $realfile = realpath($file);\n\n                $rootDir = realpath($options->getRootDir());\n                if (strpos($realfile, $rootDir) !== 0) {\n                    $chroot = $options->getChroot();\n                    $chrootValid = false;\n                    foreach ($chroot as $chrootPath) {\n                        $chrootPath = realpath($chrootPath);\n                        if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                            $chrootValid = true;\n                            break;\n                        }\n                    }\n                    if ($chrootValid !== true) {\n                        Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $file. The file could not be found under the paths specified by Options::chroot.\", __FILE__, __LINE__);\n                        return;\n                    }\n                }\n\n                if (!$realfile) {\n                    Helpers::record_warnings(E_USER_WARNING, \"File '$realfile' not found.\", __FILE__, __LINE__);\n                    return;\n                }\n\n                $file = $realfile;\n            }\n            \n            [$css, $http_response_header] = Helpers::getFileContent($file, $this->_dompdf->getHttpContext());\n\n            $good_mime_type = true;\n\n            // See http://the-stickman.com/web-development/php/getting-http-response-headers-when-using-file_get_contents/\n            if (isset($http_response_header) && !$this->_dompdf->getQuirksmode()) {\n                foreach ($http_response_header as $_header) {\n                    if (preg_match(\"@Content-Type:\\s*([\\w/]+)@i\", $_header, $matches) &&\n                        ($matches[1] !== \"text/css\")\n                    ) {\n                        $good_mime_type = false;\n                    }\n                }\n            }\n\n            if (!$good_mime_type || $css === null) {\n                Helpers::record_warnings(E_USER_WARNING, \"Unable to load css file $file\", __FILE__, __LINE__);\n                return;\n            }\n        }\n\n        $this->_parse_css($css);\n    }\n\n    /**\n     * @link http://www.w3.org/TR/CSS21/cascade.html#specificity\n     *\n     * @param string $selector\n     * @param int $origin :\n     *    - Stylesheet::ORIG_UA: user agent style sheet\n     *    - Stylesheet::ORIG_USER: user style sheet\n     *    - Stylesheet::ORIG_AUTHOR: author style sheet\n     *\n     * @return int\n     */\n    private function _specificity($selector, $origin = self::ORIG_AUTHOR)\n    {\n        // http://www.w3.org/TR/CSS21/cascade.html#specificity\n        // ignoring the \":\" pseudoclass modifiers\n        // also ignored in _css_selector_to_xpath\n\n        $a = ($selector === \"!attr\") ? 1 : 0;\n\n        $b = min(mb_substr_count($selector, \"#\"), 255);\n\n        $c = min(mb_substr_count($selector, \".\") +\n            mb_substr_count($selector, \"[\"), 255);\n\n        $d = min(mb_substr_count($selector, \" \") +\n            mb_substr_count($selector, \">\") +\n            mb_substr_count($selector, \"+\") +\n            mb_substr_count($selector, \"~\") -\n            mb_substr_count($selector, \"~=\"), 255);\n\n        //If a normal element name is at the beginning of the string,\n        //a leading whitespace might have been removed on whitespace collapsing and removal\n        //therefore there might be one whitespace less as selected element names\n        //this can lead to a too small specificity\n        //see _css_selector_to_xpath\n\n        if (!in_array($selector[0], [\" \", \">\", \".\", \"#\", \"+\", \"~\", \":\", \"[\"]) && $selector !== \"*\") {\n            $d++;\n        }\n\n        if ($this->_dompdf->getOptions()->getDebugCss()) {\n            /*DEBUGCSS*/\n            print \"<pre>\\n\";\n            /*DEBUGCSS*/\n            printf(\"_specificity(): 0x%08x \\\"%s\\\"\\n\", self::$_stylesheet_origins[$origin] + (($a << 24) | ($b << 16) | ($c << 8) | ($d)), $selector);\n            /*DEBUGCSS*/\n            print \"</pre>\";\n        }\n\n        return self::$_stylesheet_origins[$origin] + (($a << 24) | ($b << 16) | ($c << 8) | ($d));\n    }\n\n    /**\n     * Converts a CSS selector to an XPath query.\n     *\n     * @param string $selector\n     * @param bool $first_pass\n     *\n     * @throws Exception\n     * @return array\n     */\n    private function _css_selector_to_xpath(string $selector, bool $first_pass = false): array\n    {\n        // Collapse white space and strip whitespace around delimiters\n        //$search = array(\"/\\\\s+/\", \"/\\\\s+([.>#+:])\\\\s+/\");\n        //$replace = array(\" \", \"\\\\1\");\n        //$selector = preg_replace($search, $replace, trim($selector));\n\n        // Initial query (non-absolute)\n        $query = \"//\";\n\n        // Will contain :before and :after\n        $pseudo_elements = [];\n\n        // Will contain :link, etc\n        $pseudo_classes = [];\n\n        // Parse the selector\n        //$s = preg_split(\"/([ :>.#+])/\", $selector, -1, PREG_SPLIT_DELIM_CAPTURE);\n\n        $delimiters = [\" \", \">\", \".\", \"#\", \"+\", \"~\", \":\", \"[\", \"(\"];\n\n        // Add an implicit * at the beginning of the selector\n        // if it begins with an attribute selector\n        if ($selector[0] === \"[\") {\n            $selector = \"*$selector\";\n        }\n\n        // Add an implicit space at the beginning of the selector if there is no\n        // delimiter there already.\n        if (!in_array($selector[0], $delimiters)) {\n            $selector = \" $selector\";\n        }\n\n        $tok = \"\";\n        $len = mb_strlen($selector);\n        $i = 0;\n\n        while ($i < $len) {\n\n            $s = $selector[$i];\n            $i++;\n\n            // Eat characters up to the next delimiter\n            $tok = \"\";\n            $in_attr = false;\n            $in_func = false;\n\n            while ($i < $len) {\n                $c = $selector[$i];\n                $c_prev = $selector[$i - 1];\n\n                if (!$in_func && !$in_attr && in_array($c, $delimiters) && !(($c == $c_prev) == \":\")) {\n                    break;\n                }\n\n                if ($c_prev === \"[\") {\n                    $in_attr = true;\n                }\n                if ($c_prev === \"(\") {\n                    $in_func = true;\n                }\n\n                $tok .= $selector[$i++];\n\n                if ($in_attr && $c === \"]\") {\n                    $in_attr = false;\n                    break;\n                }\n                if ($in_func && $c === \")\") {\n                    $in_func = false;\n                    break;\n                }\n            }\n\n            switch ($s) {\n\n                case \" \":\n                case \">\":\n                    // All elements matching the next token that are direct children of\n                    // the current token\n                    $expr = $s === \" \" ? \"descendant\" : \"child\";\n\n                    if (mb_substr($query, -1, 1) !== \"/\") {\n                        $query .= \"/\";\n                    }\n\n                    // Tag names are case-insensitive\n                    $tok = strtolower($tok);\n\n                    if (!$tok) {\n                        $tok = \"*\";\n                    }\n\n                    $query .= \"$expr::$tok\";\n                    $tok = \"\";\n                    break;\n\n                case \".\":\n                case \"#\":\n                    // All elements matching the current token with a class/id equal to\n                    // the _next_ token.\n\n                    $attr = $s === \".\" ? \"class\" : \"id\";\n\n                    // empty class/id == *\n                    if (mb_substr($query, -1, 1) === \"/\") {\n                        $query .= \"*\";\n                    }\n\n                    // Match multiple classes: $tok contains the current selected\n                    // class.  Search for class attributes with class=\"$tok\",\n                    // class=\".* $tok .*\" and class=\".* $tok\"\n\n                    // This doesn't work because libxml only supports XPath 1.0...\n                    //$query .= \"[matches(@$attr,\\\"^{$tok}\\$|^{$tok}[ ]+|[ ]+{$tok}\\$|[ ]+{$tok}[ ]+\\\")]\";\n\n                    $query .= \"[contains(concat(' ', normalize-space(@$attr), ' '), concat(' ', '$tok', ' '))]\";\n                    $tok = \"\";\n                    break;\n\n                case \"+\":\n                case \"~\":\n                    // Next-sibling combinator\n                    // Subsequent-sibling combinator\n                    // https://www.w3.org/TR/selectors-3/#sibling-combinators\n                    if (mb_substr($query, -1, 1) !== \"/\") {\n                        $query .= \"/\";\n                    }\n\n                    // Tag names are case-insensitive\n                    $tok = strtolower($tok);\n\n                    if (!$tok) {\n                        $tok = \"*\";\n                    }\n\n                    $query .= \"following-sibling::$tok\";\n\n                    if ($s === \"+\") {\n                        $query .= \"[1]\";\n                    }\n\n                    $tok = \"\";\n                    break;\n\n                case \":\":\n                    $i2 = $i - strlen($tok) - 2; // the char before \":\"\n                    if (($i2 < 0 || !isset($selector[$i2]) || (in_array($selector[$i2], $delimiters) && $selector[$i2] != \":\")) && substr($query, -1) != \"*\") {\n                        $query .= \"*\";\n                    }\n\n                    $last = false;\n\n                    // Pseudo-classes\n                    switch ($tok) {\n\n                        case \"first-child\":\n                            $query .= \"[not(preceding-sibling::*)]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"last-child\":\n                            $query .= \"[not(following-sibling::*)]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"first-of-type\":\n                            $query .= \"[position() = 1]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"last-of-type\":\n                            $query .= \"[position() = last()]\";\n                            $tok = \"\";\n                            break;\n\n                        // an+b, n, odd, and even\n                        /** @noinspection PhpMissingBreakStatementInspection */\n                        case \"nth-last-of-type\":\n                            $last = true;\n                        case \"nth-of-type\":\n                            //FIXME: this fix-up is pretty ugly, would parsing the selector in reverse work better generally?\n                            $descendant_delimeter = strrpos($query, \"::\");\n                            $isChild = substr($query, $descendant_delimeter-5, 5) == \"child\";\n                            $el = substr($query, $descendant_delimeter+2);\n                            $query = substr($query, 0, strrpos($query, \"/\")) . ($isChild ? \"/\" : \"//\") . $el;\n\n                            $pseudo_classes[$tok] = true;\n                            $p = $i + 1;\n                            $nth = trim(mb_substr($selector, $p, strpos($selector, \")\", $i) - $p));\n                            $position = $last ? \"(last()-position()+1)\" : \"position()\";\n\n                            // 1\n                            if (preg_match(\"/^\\d+$/\", $nth)) {\n                                $condition = \"$position = $nth\";\n                            } // odd\n                            elseif ($nth === \"odd\") {\n                                $condition = \"($position mod 2) = 1\";\n                            } // even\n                            elseif ($nth === \"even\") {\n                                $condition = \"($position mod 2) = 0\";\n                            } // an+b\n                            else {\n                                $condition = $this->_selector_an_plus_b($nth, $last);\n                            }\n\n                            $query .= \"[$condition]\";\n                            $tok = \"\";\n                            break;\n                        /** @noinspection PhpMissingBreakStatementInspection */\n                        case \"nth-last-child\":\n                            $last = true;\n                        case \"nth-child\":\n                            //FIXME: this fix-up is pretty ugly, would parsing the selector in reverse work better generally?\n                            $descendant_delimeter = strrpos($query, \"::\");\n                            $isChild = substr($query, $descendant_delimeter-5, 5) == \"child\";\n                            $el = substr($query, $descendant_delimeter+2);\n                            $query = substr($query, 0, strrpos($query, \"/\")) . ($isChild ? \"/\" : \"//\") . \"*\";\n\n                            $pseudo_classes[$tok] = true;\n                            $p = $i + 1;\n                            $nth = trim(mb_substr($selector, $p, strpos($selector, \")\", $i) - $p));\n                            $position = $last ? \"(last()-position()+1)\" : \"position()\";\n\n                            // 1\n                            if (preg_match(\"/^\\d+$/\", $nth)) {\n                                $condition = \"$position = $nth\";\n                            } // odd\n                            elseif ($nth === \"odd\") {\n                                $condition = \"($position mod 2) = 1\";\n                            } // even\n                            elseif ($nth === \"even\") {\n                                $condition = \"($position mod 2) = 0\";\n                            } // an+b\n                            else {\n                                $condition = $this->_selector_an_plus_b($nth, $last);\n                            }\n\n                            $query .= \"[$condition]\";\n                            if ($el != \"*\") {\n                                $query .= \"[name() = '$el']\";\n                            }\n                            $tok = \"\";\n                            break;\n\n                        //TODO: bit of a hack attempt at matches support, currently only matches against elements\n                        case \"matches\":\n                            $pseudo_classes[$tok] = true;\n                            $p = $i + 1;\n                            $matchList = trim(mb_substr($selector, $p, strpos($selector, \")\", $i) - $p));\n\n                            // Tag names are case-insensitive\n                            $elements = array_map(\"trim\", explode(\",\", strtolower($matchList)));\n                            foreach ($elements as &$element) {\n                                $element = \"name() = '$element'\";\n                            }\n\n                            $query .= \"[\" . implode(\" or \", $elements) . \"]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"link\":\n                            $query .= \"[@href]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"first-line\":\n                        case \":first-line\":\n                        case \"first-letter\":\n                        case \":first-letter\":\n                            // TODO\n                            $el = trim($tok, \":\");\n                            $pseudo_elements[$el] = true;\n                            break;\n\n                            // N/A\n                        case \"focus\":\n                        case \"active\":\n                        case \"hover\":\n                        case \"visited\":\n                            $query .= \"[false()]\";\n                            $tok = \"\";\n                            break;\n\n                        /* Pseudo-elements */\n                        case \"before\":\n                        case \":before\":\n                        case \"after\":\n                        case \":after\":\n                            $pos = trim($tok, \":\");\n                            $pseudo_elements[$pos] = true;\n                            if (!$first_pass) {\n                                $query .= \"/*[@$pos]\";\n                            }\n\n                            $tok = \"\";\n                            break;\n\n                        case \"empty\":\n                            $query .= \"[not(*) and not(normalize-space())]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"disabled\":\n                        case \"checked\":\n                            $query .= \"[@$tok]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"enabled\":\n                            $query .= \"[not(@disabled)]\";\n                            $tok = \"\";\n                            break;\n\n                        // the selector is not handled, until we support all possible selectors force an empty set (silent failure)\n                        default:\n                            $query = \"/../..\"; // go up two levels because generated content starts on the body element\n                            $tok = \"\";\n                            break;\n                    }\n\n                    break;\n\n                case \"[\":\n                    // Attribute selectors.  All with an attribute matching the following token(s)\n                    // https://www.w3.org/TR/selectors-3/#attribute-selectors\n                    $attr_delimiters = [\"=\", \"]\", \"~\", \"|\", \"$\", \"^\", \"*\"];\n                    $tok_len = mb_strlen($tok);\n                    $j = 0;\n\n                    $attr = \"\";\n                    $op = \"\";\n                    $value = \"\";\n\n                    while ($j < $tok_len) {\n                        if (in_array($tok[$j], $attr_delimiters)) {\n                            break;\n                        }\n                        $attr .= $tok[$j++];\n                    }\n\n                    switch ($tok[$j]) {\n\n                        case \"~\":\n                        case \"|\":\n                        case \"$\":\n                        case \"^\":\n                        case \"*\":\n                            $op .= $tok[$j++];\n\n                            if ($tok[$j] !== \"=\") {\n                                throw new Exception(\"Invalid CSS selector syntax: invalid attribute selector: $selector\");\n                            }\n\n                            $op .= $tok[$j];\n                            break;\n\n                        case \"=\":\n                            $op = \"=\";\n                            break;\n\n                    }\n\n                    // Read the attribute value, if required\n                    if ($op != \"\") {\n                        $j++;\n                        while ($j < $tok_len) {\n                            if ($tok[$j] === \"]\") {\n                                break;\n                            }\n                            $value .= $tok[$j++];\n                        }\n                    }\n\n                    if ($attr == \"\") {\n                        throw new Exception(\"Invalid CSS selector syntax: missing attribute name\");\n                    }\n\n                    $value = trim($value, \"\\\"'\");\n\n                    switch ($op) {\n\n                        case \"\":\n                            $query .= \"[@$attr]\";\n                            break;\n\n                        case \"=\":\n                            $query .= \"[@$attr=\\\"$value\\\"]\";\n                            break;\n\n                        case \"~=\":\n                            // FIXME: this will break if $value contains quoted strings\n                            // (e.g. [type~=\"a b c\" \"d e f\"])\n                            // FIXME: Don't match anything if value contains\n                            // whitespace or is the empty string\n                            $query .= \"[contains(concat(' ', normalize-space(@$attr), ' '), concat(' ', '$value', ' '))]\";\n                            break;\n\n                        case \"|=\":\n                            $values = explode(\"-\", $value);\n                            $query .= \"[\";\n\n                            foreach ($values as $val) {\n                                $query .= \"starts-with(@$attr, \\\"$val\\\") or \";\n                            }\n\n                            $query = rtrim($query, \" or \") . \"]\";\n                            break;\n\n                        case \"$=\":\n                            $query .= \"[substring(@$attr, string-length(@$attr)-\" . (strlen($value) - 1) . \")=\\\"$value\\\"]\";\n                            break;\n\n                        case \"^=\":\n                            $query .= \"[starts-with(@$attr,\\\"$value\\\")]\";\n                            break;\n\n                        case \"*=\":\n                            $query .= \"[contains(@$attr,\\\"$value\\\")]\";\n                            break;\n                    }\n\n                    break;\n            }\n        }\n        $i++;\n\n//       case \":\":\n//         // Pseudo selectors: ignore for now.  Partially handled directly\n//         // below.\n\n//         // Skip until the next special character, leaving the token as-is\n//         while ( $i < $len ) {\n//           if ( in_array($selector[$i], $delimiters) )\n//             break;\n//           $i++;\n//         }\n//         break;\n\n//       default:\n//         // Add the character to the token\n//         $tok .= $selector[$i++];\n//         break;\n//       }\n\n//    }\n\n\n        // Trim the trailing '/' from the query\n        if (mb_strlen($query) > 2) {\n            $query = rtrim($query, \"/\");\n        }\n\n        return ['query' => $query, 'pseudo_elements' => $pseudo_elements];\n    }\n\n    /**\n     * https://github.com/tenderlove/nokogiri/blob/master/lib/nokogiri/css/xpath_visitor.rb\n     *\n     * @param string $expr\n     * @param bool $last\n     *\n     * @return string\n     */\n    protected function _selector_an_plus_b(string $expr, bool $last = false): string\n    {\n        $expr = preg_replace(\"/\\s/\", \"\", $expr);\n        if (!preg_match(\"/^(?P<a>-?[0-9]*)?n(?P<b>[-+]?[0-9]+)?$/\", $expr, $matches)) {\n            return \"false()\";\n        }\n\n        $a = (isset($matches[\"a\"]) && $matches[\"a\"] !== \"\") ? ($matches[\"a\"] !== \"-\" ? intval($matches[\"a\"]) : -1) : 1;\n        $b = (isset($matches[\"b\"]) && $matches[\"b\"] !== \"\") ? intval($matches[\"b\"]) : 0;\n\n        $position = $last ? \"(last()-position()+1)\" : \"position()\";\n\n        if ($b == 0) {\n            return \"($position mod $a) = 0\";\n        } else {\n            $compare = ($a < 0) ? \"<=\" : \">=\";\n            $b2 = -$b;\n            if ($b2 >= 0) {\n                $b2 = \"+$b2\";\n            }\n            return \"($position $compare $b) and ((($position $b2) mod \" . abs($a) . \") = 0)\";\n        }\n    }\n\n    /**\n     * applies all current styles to a particular document tree\n     *\n     * apply_styles() applies all currently loaded styles to the provided\n     * {@link FrameTree}.  Aside from parsing CSS, this is the main purpose\n     * of this class.\n     *\n     * @param \\Dompdf\\Frame\\FrameTree $tree\n     */\n    function apply_styles(FrameTree $tree)\n    {\n        // Use XPath to select nodes.  This would be easier if we could attach\n        // Frame objects directly to DOMNodes using the setUserData() method, but\n        // we can't do that just yet.  Instead, we set a _node attribute_ in\n        // Frame->set_id() and use that as a handle on the Frame object via\n        // FrameTree::$_registry.\n\n        // We create a scratch array of styles indexed by frame id.  Once all\n        // styles have been assigned, we order the cached styles by specificity\n        // and create a final style object to assign to the frame.\n\n        // FIXME: this is not particularly robust...\n\n        $styles = [];\n        $xp = new DOMXPath($tree->get_dom());\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n\n        // Add generated content\n        foreach ($this->_styles as $selector => $selector_styles) {\n            /** @var Style $style */\n            foreach ($selector_styles as $style) {\n                if (strpos($selector, \":before\") === false && strpos($selector, \":after\") === false) {\n                    continue;\n                }\n\n                $query = $this->_css_selector_to_xpath($selector, true);\n\n                // Retrieve the nodes, limit to body for generated content\n                //TODO: If we use a context node can we remove the leading dot?\n                $nodes = @$xp->query('.' . $query[\"query\"]);\n                if ($nodes === false) {\n                    Helpers::record_warnings(E_USER_WARNING, \"The CSS selector '$selector' is not valid\", __FILE__, __LINE__);\n                    continue;\n                }\n\n                /** @var \\DOMElement $node */\n                foreach ($nodes as $node) {\n                    // Only DOMElements get styles\n                    if ($node->nodeType != XML_ELEMENT_NODE) {\n                        continue;\n                    }\n\n                    foreach (array_keys($query[\"pseudo_elements\"], true, true) as $pos) {\n                        // Do not add a new pseudo element if another one already matched\n                        if ($node->hasAttribute(\"dompdf_{$pos}_frame_id\")) {\n                            continue;\n                        }\n\n                        $content = $style->get_specified(\"content\");\n\n                        // Do not create non-displayed before/after pseudo elements\n                        // https://www.w3.org/TR/CSS21/generate.html#content\n                        // https://www.w3.org/TR/CSS21/generate.html#undisplayed-counters\n                        if ($content === \"normal\" || $content === \"none\") {\n                            continue;\n                        }\n\n                        if (($src = $this->resolve_url($content)) !== \"none\") {\n                            $new_node = $node->ownerDocument->createElement(\"img_generated\");\n                            $new_node->setAttribute(\"src\", $src);\n                        } else {\n                            $new_node = $node->ownerDocument->createElement(\"dompdf_generated\");\n                        }\n\n                        $new_node->setAttribute($pos, $pos);\n                        $new_frame_id = $tree->insert_node($node, $new_node, $pos);\n                        $node->setAttribute(\"dompdf_{$pos}_frame_id\", $new_frame_id);\n                    }\n                }\n            }\n        }\n\n        // Apply all styles in stylesheet\n        foreach ($this->_styles as $selector => $selector_styles) {\n            /** @var Style $style */\n            foreach ($selector_styles as $style) {\n                $query = $this->_css_selector_to_xpath($selector);\n\n                // Retrieve the nodes\n                $nodes = @$xp->query($query[\"query\"]);\n                if ($nodes === false) {\n                    Helpers::record_warnings(E_USER_WARNING, \"The CSS selector '$selector' is not valid\", __FILE__, __LINE__);\n                    continue;\n                }\n\n                $spec = $this->_specificity($selector, $style->get_origin());\n\n                foreach ($nodes as $node) {\n                    // Retrieve the node id\n                    // Only DOMElements get styles\n                    if ($node->nodeType != XML_ELEMENT_NODE) {\n                        continue;\n                    }\n\n                    $id = $node->getAttribute(\"frame_id\");\n\n                    // Assign the current style to the scratch array\n                    $styles[$id][$spec][] = $style;\n                }\n            }\n        }\n\n        // Set the page width, height, and orientation based on the canvas paper size\n        $canvas = $this->_dompdf->getCanvas();\n        $paper_width = $canvas->get_width();\n        $paper_height = $canvas->get_height();\n        $paper_orientation = ($paper_width > $paper_height ? \"landscape\" : \"portrait\");\n\n        if ($this->_page_styles[\"base\"] && is_array($this->_page_styles[\"base\"]->size)) {\n            $paper_width = $this->_page_styles['base']->size[0];\n            $paper_height = $this->_page_styles['base']->size[1];\n            $paper_orientation = ($paper_width > $paper_height ? \"landscape\" : \"portrait\");\n        }\n\n        // Now create the styles and assign them to the appropriate frames. (We\n        // iterate over the tree using an implicit FrameTree iterator.)\n        $root_flg = false;\n        foreach ($tree as $frame) {\n            // Helpers::pre_r($frame->get_node()->nodeName . \":\");\n            if (!$root_flg && $this->_page_styles[\"base\"]) {\n                $style = $this->_page_styles[\"base\"];\n            } else {\n                $style = $this->create_style();\n            }\n\n            // Find nearest DOMElement parent\n            $p = $frame;\n            while ($p = $p->get_parent()) {\n                if ($p->get_node()->nodeType === XML_ELEMENT_NODE) {\n                    break;\n                }\n            }\n\n            // Styles can only be applied directly to DOMElements; anonymous\n            // frames inherit from their parent\n            if ($frame->get_node()->nodeType !== XML_ELEMENT_NODE) {\n                $style->inherit($p ? $p->get_style() : null);\n                $frame->set_style($style);\n                continue;\n            }\n\n            $id = $frame->get_id();\n\n            // Handle HTML 4.0 attributes\n            AttributeTranslator::translate_attributes($frame);\n            if (($str = $frame->get_node()->getAttribute(AttributeTranslator::$_style_attr)) !== \"\") {\n                $styles[$id][self::SPEC_NON_CSS][] = $this->_parse_properties($str);\n            }\n\n            // Locate any additional style attributes\n            if (($str = $frame->get_node()->getAttribute(\"style\")) !== \"\") {\n                // Destroy CSS comments\n                $str = preg_replace(\"'/\\*.*?\\*/'si\", \"\", $str);\n\n                $spec = $this->_specificity(\"!attr\", self::ORIG_AUTHOR);\n                $styles[$id][$spec][] = $this->_parse_properties($str);\n            }\n\n            // Grab the applicable styles\n            if (isset($styles[$id])) {\n\n                /** @var array[][] $applied_styles */\n                $applied_styles = $styles[$id];\n\n                // Sort by specificity\n                ksort($applied_styles);\n\n                if ($DEBUGCSS) {\n                    $debug_nodename = $frame->get_node()->nodeName;\n                    print \"<pre>\\n$debug_nodename [\\n\";\n                    foreach ($applied_styles as $spec => $arr) {\n                        printf(\"  specificity 0x%08x\\n\", $spec);\n                        /** @var Style $s */\n                        foreach ($arr as $s) {\n                            print \"  [\\n\";\n                            $s->debug_print();\n                            print \"  ]\\n\";\n                        }\n                    }\n                }\n\n                // Merge the new styles with the inherited styles\n                $acceptedmedia = self::$ACCEPTED_GENERIC_MEDIA_TYPES;\n                $acceptedmedia[] = $this->_dompdf->getOptions()->getDefaultMediaType();\n                foreach ($applied_styles as $arr) {\n                    /** @var Style $s */\n                    foreach ($arr as $s) {\n                        $media_queries = $s->get_media_queries();\n                        foreach ($media_queries as $media_query) {\n                            list($media_query_feature, $media_query_value) = $media_query;\n                            // if any of the Style's media queries fail then do not apply the style\n                            //TODO: When the media query logic is fully developed we should not apply the Style when any of the media queries fail or are bad, per https://www.w3.org/TR/css3-mediaqueries/#error-handling\n                            if (in_array($media_query_feature, self::$VALID_MEDIA_TYPES)) {\n                                if ((strlen($media_query_feature) === 0 && !in_array($media_query, $acceptedmedia)) || (in_array($media_query, $acceptedmedia) && $media_query_value == \"not\")) {\n                                    continue (3);\n                                }\n                            } else {\n                                switch ($media_query_feature) {\n                                    case \"height\":\n                                        if ($paper_height !== (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"min-height\":\n                                        if ($paper_height < (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"max-height\":\n                                        if ($paper_height > (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"width\":\n                                        if ($paper_width !== (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"min-width\":\n                                        //if (min($paper_width, $media_query_width) === $paper_width) {\n                                        if ($paper_width < (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"max-width\":\n                                        //if (max($paper_width, $media_query_width) === $paper_width) {\n                                        if ($paper_width > (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"orientation\":\n                                        if ($paper_orientation !== $media_query_value) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    default:\n                                        Helpers::record_warnings(E_USER_WARNING, \"Unknown media query: $media_query_feature\", __FILE__, __LINE__);\n                                        break;\n                                }\n                            }\n                        }\n\n                        $style->merge($s);\n                    }\n                }\n            }\n\n            // Handle inheritance\n            if ($p && $DEBUGCSS) {\n                print \"  inherit [\\n\";\n                $p->get_style()->debug_print();\n                print \"  ]\\n\";\n            }\n\n            $style->inherit($p ? $p->get_style() : null);\n\n            if ($DEBUGCSS) {\n                print \"  DomElementStyle [\\n\";\n                $style->debug_print();\n                print \"  ]\\n\";\n                print \"]\\n</pre>\";\n            }\n\n            $style->clear_important();\n            $frame->set_style($style);\n\n            if (!$root_flg && $this->_page_styles[\"base\"]) {\n                $root_flg = true;\n\n                // set the page width, height, and orientation based on the parsed page style\n                if ($style->size !== \"auto\") {\n                    list($paper_width, $paper_height) = $style->size;\n                }\n                $paper_width = $paper_width - (float)$style->length_in_pt($style->margin_left) - (float)$style->length_in_pt($style->margin_right);\n                $paper_height = $paper_height - (float)$style->length_in_pt($style->margin_top) - (float)$style->length_in_pt($style->margin_bottom);\n                $paper_orientation = ($paper_width > $paper_height ? \"landscape\" : \"portrait\");\n            }\n        }\n\n        // We're done!  Clean out the registry of all styles since we\n        // won't be needing this later.\n        foreach (array_keys($this->_styles) as $key) {\n            $this->_styles[$key] = null;\n            unset($this->_styles[$key]);\n        }\n    }\n\n    /**\n     * parse a CSS string using a regex parser\n     * Called by {@link Stylesheet::parse_css()}\n     *\n     * @param string $str\n     *\n     * @throws Exception\n     */\n    private function _parse_css($str)\n    {\n        $str = trim($str);\n\n        // Destroy comments and remove HTML comments\n        $css = preg_replace([\n            \"'/\\*.*?\\*/'si\",\n            \"/^<!--/\",\n            \"/-->$/\"\n        ], \"\", $str);\n\n        // FIXME: handle '{' within strings, e.g. [attr=\"string {}\"]\n\n        // Something more legible:\n        $re =\n            \"/\\s*                                   # Skip leading whitespace                             \\n\" .\n            \"( @([^\\s{]+)\\s*([^{;]*) (?:;|({)) )?   # Match @rules followed by ';' or '{'                 \\n\" .\n            \"(?(1)                                  # Only parse sub-sections if we're in an @rule...     \\n\" .\n            \"  (?(4)                                # ...and if there was a leading '{'                   \\n\" .\n            \"    \\s*( (?:(?>[^{}]+) ({)?            # Parse rulesets and individual @page rules           \\n\" .\n            \"            (?(6) (?>[^}]*) }) \\s*)+?                                                        \\n\" .\n            \"       )                                                                                     \\n\" .\n            \"   })                                  # Balancing '}'                                       \\n\" .\n            \"|                                      # Branch to match regular rules (not preceded by '@') \\n\" .\n            \"([^{]*{[^}]*}))                        # Parse normal rulesets                               \\n\" .\n            \"/xs\";\n\n        if (preg_match_all($re, $css, $matches, PREG_SET_ORDER) === false) {\n            // An error occurred\n            throw new Exception(\"Error parsing css file: preg_match_all() failed.\");\n        }\n\n        // After matching, the array indices are set as follows:\n        //\n        // [0] => complete text of match\n        // [1] => contains '@import ...;' or '@media {' if applicable\n        // [2] => text following @ for cases where [1] is set\n        // [3] => media types or full text following '@import ...;'\n        // [4] => '{', if present\n        // [5] => rulesets within media rules\n        // [6] => '{', within media rules\n        // [7] => individual rules, outside of media rules\n        //\n\n        $media_query_regex = \"/(?:((only|not)?\\s*(\" . implode(\"|\", self::$VALID_MEDIA_TYPES) . \"))|(\\s*\\(\\s*((?:(min|max)-)?([\\w\\-]+))\\s*(?:\\:\\s*(.*?)\\s*)?\\)))/isx\";\n\n        //Helpers::pre_r($matches);\n        foreach ($matches as $match) {\n            $match[2] = trim($match[2]);\n\n            if ($match[2] !== \"\") {\n                // Handle @rules\n                switch ($match[2]) {\n\n                    case \"import\":\n                        $this->_parse_import($match[3]);\n                        break;\n\n                    case \"media\":\n                        $acceptedmedia = self::$ACCEPTED_GENERIC_MEDIA_TYPES;\n                        $acceptedmedia[] = $this->_dompdf->getOptions()->getDefaultMediaType();\n\n                        $media_queries = preg_split(\"/\\s*,\\s*/\", mb_strtolower(trim($match[3])));\n                        foreach ($media_queries as $media_query) {\n                            if (in_array($media_query, $acceptedmedia)) {\n                                //if we have a media type match go ahead and parse the stylesheet\n                                $this->_parse_sections($match[5]);\n                                break;\n                            } elseif (!in_array($media_query, self::$VALID_MEDIA_TYPES)) {\n                                // otherwise conditionally parse the stylesheet assuming there are parseable media queries\n                                if (preg_match_all($media_query_regex, $media_query, $media_query_matches, PREG_SET_ORDER) !== false) {\n                                    $mq = [];\n                                    foreach ($media_query_matches as $media_query_match) {\n                                        if (empty($media_query_match[1]) === false) {\n                                            $media_query_feature = strtolower($media_query_match[3]);\n                                            $media_query_value = strtolower($media_query_match[2]);\n                                            $mq[] = [$media_query_feature, $media_query_value];\n                                        } else if (empty($media_query_match[4]) === false) {\n                                            $media_query_feature = strtolower($media_query_match[5]);\n                                            $media_query_value = (array_key_exists(8, $media_query_match) ? strtolower($media_query_match[8]) : null);\n                                            $mq[] = [$media_query_feature, $media_query_value];\n                                        }\n                                    }\n                                    $this->_parse_sections($match[5], $mq);\n                                    break;\n                                }\n                            }\n                        }\n                        break;\n\n                    case \"page\":\n                        //This handles @page to be applied to page oriented media\n                        //Note: This has a reduced syntax:\n                        //@page { margin:1cm; color:blue; }\n                        //Not a sequence of styles like a full.css, but only the properties\n                        //of a single style, which is applied to the very first \"root\" frame before\n                        //processing other styles of the frame.\n                        //Working properties:\n                        // margin (for margin around edge of paper)\n                        // font-family (default font of pages)\n                        // color (default text color of pages)\n                        //Non working properties:\n                        // border\n                        // padding\n                        // background-color\n                        //Todo:Reason is unknown\n                        //Other properties (like further font or border attributes) not tested.\n                        //If a border or background color around each paper sheet is desired,\n                        //assign it to the <body> tag, possibly only for the css of the correct media type.\n\n                        // If the page has a name, skip the style.\n                        $page_selector = trim($match[3]);\n\n                        $key = null;\n                        switch ($page_selector) {\n                            case \"\":\n                                $key = \"base\";\n                                break;\n\n                            case \":left\":\n                            case \":right\":\n                            case \":odd\":\n                            case \":even\":\n                            /** @noinspection PhpMissingBreakStatementInspection */\n                            case \":first\":\n                                $key = $page_selector;\n                                break;\n\n                            default:\n                                break 2;\n                        }\n\n                        // Store the style for later...\n                        if (empty($this->_page_styles[$key])) {\n                            $this->_page_styles[$key] = $this->_parse_properties($match[5]);\n                        } else {\n                            $this->_page_styles[$key]->merge($this->_parse_properties($match[5]));\n                        }\n                        break;\n\n                    case \"font-face\":\n                        $this->_parse_font_face($match[5]);\n                        break;\n\n                    default:\n                        // ignore everything else\n                        break;\n                }\n\n                continue;\n            }\n\n            if ($match[7] !== \"\") {\n                $this->_parse_sections($match[7]);\n            }\n        }\n    }\n\n    /**\n     * Resolve the given `url()` declaration to an absolute URL.\n     *\n     * @param string|null $val The declaration to resolve in the context of the stylesheet.\n     * @return string The resolved URL, or `none`, if the value is `none`,\n     *         invalid, or points to a non-existent local file.\n     */\n    public function resolve_url($val): string\n    {\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n        $parsed_url = \"none\";\n\n        if (empty($val) || $val === \"none\") {\n            $path = \"none\";\n        } elseif (mb_strpos($val, \"url\") === false) {\n            $path = \"none\"; //Don't resolve no image -> otherwise would prefix path and no longer recognize as none\n        } else {\n            $val = preg_replace(\"/url\\(\\s*['\\\"]?([^'\\\")]+)['\\\"]?\\s*\\)/\", \"\\\\1\", trim($val));\n\n            // Resolve the url now in the context of the current stylesheet\n            $parsed_url = Helpers::explode_url($val);\n            $path = Helpers::build_url($this->_protocol,\n                $this->_base_host,\n                $this->_base_path,\n                $val);\n            if (($parsed_url[\"protocol\"] === \"\" || $parsed_url[\"protocol\"] === \"file://\") && ($this->_protocol === \"\" || $this->_protocol === \"file://\")) {\n                $path = realpath($path);\n                // If realpath returns FALSE then specifically state that there is no background image\n                if ($path === false) {\n                    $path = \"none\";\n                }\n            }\n        }\n        if ($DEBUGCSS) {\n            print \"<pre>[_image\\n\";\n            print_r($parsed_url);\n            print $this->_protocol . \"\\n\" . $this->_base_path . \"\\n\" . $path . \"\\n\";\n            print \"_image]</pre>\";\n        }\n        return $path;\n    }\n\n    /**\n     * parse @import{} sections\n     *\n     * @param string $url the url of the imported CSS file\n     */\n    private function _parse_import($url)\n    {\n        $arr = preg_split(\"/[\\s\\n,]/\", $url, -1, PREG_SPLIT_NO_EMPTY);\n        $url = array_shift($arr);\n        $accept = false;\n\n        if (count($arr) > 0) {\n            $acceptedmedia = self::$ACCEPTED_GENERIC_MEDIA_TYPES;\n            $acceptedmedia[] = $this->_dompdf->getOptions()->getDefaultMediaType();\n\n            // @import url media_type [media_type...]\n            foreach ($arr as $type) {\n                if (in_array(mb_strtolower(trim($type)), $acceptedmedia)) {\n                    $accept = true;\n                    break;\n                }\n            }\n\n        } else {\n            // unconditional import\n            $accept = true;\n        }\n\n        if ($accept) {\n            // Store our current base url properties in case the new url is elsewhere\n            $protocol = $this->_protocol;\n            $host = $this->_base_host;\n            $path = $this->_base_path;\n\n            // $url = str_replace(array('\"',\"url\", \"(\", \")\"), \"\", $url);\n            // If the protocol is php, assume that we will import using file://\n            // $url = Helpers::build_url($protocol === \"php://\" ? \"file://\" : $protocol, $host, $path, $url);\n            // Above does not work for subfolders and absolute urls.\n            // Todo: As above, do we need to replace php or file to an empty protocol for local files?\n\n            $url = $this->resolve_url($url);\n\n            $this->load_css_file($url);\n\n            // Restore the current base url\n            $this->_protocol = $protocol;\n            $this->_base_host = $host;\n            $this->_base_path = $path;\n        }\n    }\n\n    /**\n     * parse @font-face{} sections\n     * http://www.w3.org/TR/css3-fonts/#the-font-face-rule\n     *\n     * @param string $str CSS @font-face rules\n     */\n    private function _parse_font_face($str)\n    {\n        $descriptors = $this->_parse_properties($str);\n\n        preg_match_all(\"/(url|local)\\s*\\([\\\"\\']?([^\\\"\\'\\)]+)[\\\"\\']?\\)\\s*(format\\s*\\([\\\"\\']?([^\\\"\\'\\)]+)[\\\"\\']?\\))?/i\", $descriptors->src, $src);\n\n        $sources = [];\n        $valid_sources = [];\n\n        foreach ($src[0] as $i => $value) {\n            $source = [\n                \"local\" => strtolower($src[1][$i]) === \"local\",\n                \"uri\" => $src[2][$i],\n                \"format\" => strtolower($src[4][$i]),\n                \"path\" => Helpers::build_url($this->_protocol, $this->_base_host, $this->_base_path, $src[2][$i]),\n            ];\n\n            if (!$source[\"local\"] && in_array($source[\"format\"], [\"\", \"truetype\"])) {\n                $valid_sources[] = $source;\n            }\n\n            $sources[] = $source;\n        }\n\n        // No valid sources\n        if (empty($valid_sources)) {\n            return;\n        }\n\n        $style = [\n            \"family\" => $descriptors->get_font_family_raw(),\n            \"weight\" => $descriptors->font_weight,\n            \"style\" => $descriptors->font_style,\n        ];\n\n        $this->getFontMetrics()->registerFont($style, $valid_sources[0][\"path\"], $this->_dompdf->getHttpContext());\n    }\n\n    /**\n     * parse regular CSS blocks\n     *\n     * _parse_properties() creates a new Style object based on the provided\n     * CSS rules.\n     *\n     * @param string $str CSS rules\n     * @return Style\n     */\n    private function _parse_properties($str)\n    {\n        $properties = preg_split(\"/;(?=(?:[^\\(]*\\([^\\)]*\\))*(?![^\\)]*\\)))/\", $str);\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n\n        if ($DEBUGCSS) {\n            print '[_parse_properties';\n        }\n\n        // Create the style\n        $style = new Style($this, Stylesheet::ORIG_AUTHOR);\n\n        foreach ($properties as $prop) {\n            // If the $prop contains an url, the regex may be wrong\n            // @todo: fix the regex so that it works every time\n            /*if (strpos($prop, \"url(\") === false) {\n              if (preg_match(\"/([a-z-]+)\\s*:\\s*[^:]+$/i\", $prop, $m))\n                $prop = $m[0];\n            }*/\n\n            //A css property can have \" ! important\" appended (whitespace optional)\n            //strip this off to decode core of the property correctly.\n\n            /* Instead of short code, prefer the typical case with fast code\n          $important = preg_match(\"/(.*?)!\\s*important/\",$prop,$match);\n            if ( $important ) {\n              $prop = $match[1];\n            }\n            $prop = trim($prop);\n            */\n            if ($DEBUGCSS) print '(';\n\n            $important = false;\n            $prop = trim($prop);\n\n            if (substr($prop, -9) === 'important') {\n                $prop_tmp = rtrim(substr($prop, 0, -9));\n\n                if (substr($prop_tmp, -1) === '!') {\n                    $prop = rtrim(substr($prop_tmp, 0, -1));\n                    $important = true;\n                }\n            }\n\n            if ($prop === \"\") {\n                if ($DEBUGCSS) print 'empty)';\n                continue;\n            }\n\n            $i = mb_strpos($prop, \":\");\n            if ($i === false) {\n                if ($DEBUGCSS) print 'novalue' . $prop . ')';\n                continue;\n            }\n\n            $prop_name = rtrim(mb_strtolower(mb_substr($prop, 0, $i)));\n            $value = ltrim(mb_substr($prop, $i + 1));\n\n            if ($DEBUGCSS) print $prop_name . ':=' . $value . ($important ? '!IMPORTANT' : '') . ')';\n\n            $style->set_prop($prop_name, $value, $important, false);\n        }\n        if ($DEBUGCSS) print '_parse_properties]';\n\n        return $style;\n    }\n\n    /**\n     * parse selector + rulesets\n     *\n     * @param string $str CSS selectors and rulesets\n     * @param array $media_queries\n     */\n    private function _parse_sections($str, $media_queries = [])\n    {\n        // Pre-process selectors: collapse all whitespace and strip whitespace\n        // around '>', '.', ':', '+', '~', '#'\n        $patterns = [\"/\\s+/\", \"/\\s+([>.:+~#])\\s+/\"];\n        $replacements = [\" \", \"\\\\1\"];\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n\n        $sections = explode(\"}\", $str);\n        if ($DEBUGCSS) print '[_parse_sections';\n        foreach ($sections as $sect) {\n            $i = mb_strpos($sect, \"{\");\n            if ($i === false) { continue; }\n\n            if ($DEBUGCSS) print '[section';\n\n            $selector_str = preg_replace($patterns, $replacements, mb_substr($sect, 0, $i));\n            $selectors = preg_split(\"/,(?![^\\(]*\\))/\", $selector_str, 0, PREG_SPLIT_NO_EMPTY);\n            $style = $this->_parse_properties(trim(mb_substr($sect, $i + 1)));\n\n            // Assign it to the selected elements\n            foreach ($selectors as $selector) {\n                $selector = trim($selector);\n\n                if ($selector == \"\") {\n                    if ($DEBUGCSS) print '#empty#';\n                    continue;\n                }\n                if ($DEBUGCSS) print '#' . $selector . '#';\n                //if ($DEBUGCSS) { if (strpos($selector,'p') !== false) print '!!!p!!!#'; }\n\n                //FIXME: tag the selector with a hash of the media query to separate it from non-conditional styles (?), xpath comments are probably not what we want to do here\n                if (count($media_queries) > 0) {\n                    $style->set_media_queries($media_queries);\n                }\n                $this->add_style($selector, $style);\n            }\n\n            if ($DEBUGCSS) {\n                print 'section]';\n            }\n        }\n\n        if ($DEBUGCSS) {\n            print \"_parse_sections]\\n\";\n        }\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultStylesheet()\n    {\n        $options = $this->_dompdf->getOptions();\n        $rootDir = realpath($options->getRootDir());\n        return $rootDir . self::DEFAULT_STYLESHEET;\n    }\n\n    /**\n     * @param FontMetrics $fontMetrics\n     * @return $this\n     */\n    public function setFontMetrics(FontMetrics $fontMetrics)\n    {\n        $this->fontMetrics = $fontMetrics;\n        return $this;\n    }\n\n    /**\n     * @return FontMetrics\n     */\n    public function getFontMetrics()\n    {\n        return $this->fontMetrics;\n    }\n\n    /**\n     * dumps the entire stylesheet as a string\n     *\n     * Generates a string of each selector and associated style in the\n     * Stylesheet.  Useful for debugging.\n     *\n     * @return string\n     */\n    function __toString()\n    {\n        $str = \"\";\n        foreach ($this->_styles as $selector => $selector_styles) {\n            /** @var Style $style */\n            foreach ($selector_styles as $style) {\n                $str .= \"$selector => \" . $style->__toString() . \"\\n\";\n            }\n        }\n\n        return $str;\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf;\n\nuse DOMDocument;\nuse DOMNode;\nuse Dompdf\\Adapter\\CPDF;\nuse DOMXPath;\nuse Dompdf\\Frame\\Factory;\nuse Dompdf\\Frame\\FrameTree;\nuse Dompdf\\Image\\Cache;\nuse Dompdf\\Css\\Stylesheet;\nuse Dompdf\\Helpers;\nuse Masterminds\\HTML5;\n\n/**\n * Dompdf - PHP5 HTML to PDF renderer\n *\n * Dompdf loads HTML and does its best to render it as a PDF.  It gets its\n * name from the new DomDocument PHP5 extension.  Source HTML is first\n * parsed by a DomDocument object.  Dompdf takes the resulting DOM tree and\n * attaches a {@link Frame} object to each node.  {@link Frame} objects store\n * positioning and layout information and each has a reference to a {@link\n * Style} object.\n *\n * Style information is loaded and parsed (see {@link Stylesheet}) and is\n * applied to the frames in the tree by using XPath.  CSS selectors are\n * converted into XPath queries, and the computed {@link Style} objects are\n * applied to the {@link Frame}s.\n *\n * {@link Frame}s are then decorated (in the design pattern sense of the\n * word) based on their CSS display property ({@link\n * http://www.w3.org/TR/CSS21/visuren.html#propdef-display}).\n * Frame_Decorators augment the basic {@link Frame} class by adding\n * additional properties and methods specific to the particular type of\n * {@link Frame}.  For example, in the CSS layout model, block frames\n * (display: block;) contain line boxes that are usually filled with text or\n * other inline frames.  The Block therefore adds a $lines\n * property as well as methods to add {@link Frame}s to lines and to add\n * additional lines.  {@link Frame}s also are attached to specific\n * AbstractPositioner and {@link AbstractFrameReflower} objects that contain the\n * positioining and layout algorithm for a specific type of frame,\n * respectively.  This is an application of the Strategy pattern.\n *\n * Layout, or reflow, proceeds recursively (post-order) starting at the root\n * of the document.  Space constraints (containing block width & height) are\n * pushed down, and resolved positions and sizes bubble up.  Thus, every\n * {@link Frame} in the document tree is traversed once (except for tables\n * which use a two-pass layout algorithm).  If you are interested in the\n * details, see the reflow() method of the Reflower classes.\n *\n * Rendering is relatively straightforward once layout is complete. {@link\n * Frame}s are rendered using an adapted {@link Cpdf} class, originally\n * written by Wayne Munro, http://www.ros.co.nz/pdf/.  (Some performance\n * related changes have been made to the original {@link Cpdf} class, and\n * the {@link Dompdf\\Adapter\\CPDF} class provides a simple, stateless interface to\n * PDF generation.)  PDFLib support has now also been added, via the {@link\n * Dompdf\\Adapter\\PDFLib}.\n *\n *\n * @package dompdf\n */\nclass Dompdf\n{\n    /**\n     * Version string for dompdf\n     *\n     * @var string\n     */\n    private $version = 'dompdf';\n\n    /**\n     * DomDocument representing the HTML document\n     *\n     * @var DOMDocument\n     */\n    private $dom;\n\n    /**\n     * FrameTree derived from the DOM tree\n     *\n     * @var FrameTree\n     */\n    private $tree;\n\n    /**\n     * Stylesheet for the document\n     *\n     * @var Stylesheet\n     */\n    private $css;\n\n    /**\n     * Actual PDF renderer\n     *\n     * @var Canvas\n     */\n    private $canvas;\n\n    /**\n     * Desired paper size ('letter', 'legal', 'A4', etc.)\n     *\n     * @var string|array\n     */\n    private $paperSize;\n\n    /**\n     * Paper orientation ('portrait' or 'landscape')\n     *\n     * @var string\n     */\n    private $paperOrientation = \"portrait\";\n\n    /**\n     * Callbacks on new page and new element\n     *\n     * @var array\n     */\n    private $callbacks = [];\n\n    /**\n     * Experimental caching capability\n     *\n     * @var string\n     */\n    private $cacheId;\n\n    /**\n     * Base hostname\n     *\n     * Used for relative paths/urls\n     * @var string\n     */\n    private $baseHost = \"\";\n\n    /**\n     * Absolute base path\n     *\n     * Used for relative paths/urls\n     * @var string\n     */\n    private $basePath = \"\";\n\n    /**\n     * Protocol used to request file (file://, http://, etc)\n     *\n     * @var string\n     */\n    private $protocol = \"\";\n\n    /**\n     * The system's locale\n     *\n     * @var string\n     */\n    private $systemLocale = null;\n\n    /**\n     * The system's mbstring internal encoding\n     *\n     * @var string\n     */\n    private $mbstringEncoding = null;\n\n    /**\n     * The system's PCRE JIT configuration\n     *\n     * @var string\n     */\n    private $pcreJit = null;\n\n    /**\n     * The default view of the PDF in the viewer\n     *\n     * @var string\n     */\n    private $defaultView = \"Fit\";\n\n    /**\n     * The default view options of the PDF in the viewer\n     *\n     * @var array\n     */\n    private $defaultViewOptions = [];\n\n    /**\n     * Tells whether the DOM document is in quirksmode (experimental)\n     *\n     * @var bool\n     */\n    private $quirksmode = false;\n\n    /**\n    * Protocol whitelist\n    *\n    * Protocols and PHP wrappers allowed in URLs. Full support is not\n    * guaranteed for the protocols/wrappers contained in this array.\n    *\n    * @var array\n    */\n    private $allowedProtocols = [\"\", \"file://\", \"http://\", \"https://\"];\n\n    /**\n    * Local file extension whitelist\n    *\n    * File extensions supported by dompdf for local files.\n    *\n    * @var array\n    */\n    private $allowedLocalFileExtensions = [\"htm\", \"html\"];\n\n    /**\n     * @var array\n     */\n    private $messages = [];\n\n    /**\n     * @var Options\n     */\n    private $options;\n\n    /**\n     * @var FontMetrics\n     */\n    private $fontMetrics;\n\n    /**\n     * The list of built-in fonts\n     *\n     * @var array\n     * @deprecated\n     */\n    public static $native_fonts = [\n        \"courier\", \"courier-bold\", \"courier-oblique\", \"courier-boldoblique\",\n        \"helvetica\", \"helvetica-bold\", \"helvetica-oblique\", \"helvetica-boldoblique\",\n        \"times-roman\", \"times-bold\", \"times-italic\", \"times-bolditalic\",\n        \"symbol\", \"zapfdinbats\"\n    ];\n\n    /**\n     * The list of built-in fonts\n     *\n     * @var array\n     */\n    public static $nativeFonts = [\n        \"courier\", \"courier-bold\", \"courier-oblique\", \"courier-boldoblique\",\n        \"helvetica\", \"helvetica-bold\", \"helvetica-oblique\", \"helvetica-boldoblique\",\n        \"times-roman\", \"times-bold\", \"times-italic\", \"times-bolditalic\",\n        \"symbol\", \"zapfdinbats\"\n    ];\n\n    /**\n     * Class constructor\n     *\n     * @param Options|array|null $options\n     */\n    public function __construct($options = null)\n    {\n        if (isset($options) && $options instanceof Options) {\n            $this->setOptions($options);\n        } elseif (is_array($options)) {\n            $this->setOptions(new Options($options));\n        } else {\n            $this->setOptions(new Options());\n        }\n\n        $versionFile = realpath(__DIR__ . '/../VERSION');\n        if (file_exists($versionFile) && ($version = trim(file_get_contents($versionFile))) !== false && $version !== '$Format:<%h>$') {\n            $this->version = sprintf('dompdf %s', $version);\n        }\n\n        $this->setPhpConfig();\n\n        $this->paperSize = $this->options->getDefaultPaperSize();\n        $this->paperOrientation = $this->options->getDefaultPaperOrientation();\n\n        $this->canvas = CanvasFactory::get_instance($this, $this->paperSize, $this->paperOrientation);\n        $this->fontMetrics = new FontMetrics($this->canvas, $this->options);\n        $this->css = new Stylesheet($this);\n\n        $this->restorePhpConfig();\n    }\n\n    /**\n     * Save the system's existing locale, PCRE JIT, and MBString encoding\n     * configuration and configure the system for Dompdf processing\n     */\n    private function setPhpConfig()\n    {\n        if (sprintf('%.1f', 1.0) !== '1.0') {\n            $this->systemLocale = setlocale(LC_NUMERIC, \"0\");\n            setlocale(LC_NUMERIC, \"C\");\n        }\n\n        $this->pcreJit = @ini_get('pcre.jit');\n        @ini_set('pcre.jit', '0');\n\n        $this->mbstringEncoding = mb_internal_encoding();\n        mb_internal_encoding('UTF-8');\n    }\n\n    /**\n     * Restore the system's locale configuration\n     */\n    private function restorePhpConfig()\n    {\n        if ($this->systemLocale !== null) {\n            setlocale(LC_NUMERIC, $this->systemLocale);\n            $this->systemLocale = null;\n        }\n\n        if ($this->pcreJit !== null) {\n            @ini_set('pcre.jit', $this->pcreJit);\n            $this->pcreJit = null;\n        }\n\n        if ($this->mbstringEncoding !== null) {\n            mb_internal_encoding($this->mbstringEncoding);\n            $this->mbstringEncoding = null;\n        }\n    }\n\n    /**\n     * @param $file\n     * @deprecated\n     */\n    public function load_html_file($file)\n    {\n        $this->loadHtmlFile($file);\n    }\n\n    /**\n     * Loads an HTML file\n     * Parse errors are stored in the global array _dompdf_warnings.\n     *\n     * @param string $file a filename or url to load\n     * @param string $encoding Encoding of $file\n     *\n     * @throws Exception\n     */\n    public function loadHtmlFile($file, $encoding = null)\n    {\n        $this->setPhpConfig();\n\n        if (!$this->protocol && !$this->baseHost && !$this->basePath) {\n            [$this->protocol, $this->baseHost, $this->basePath] = Helpers::explode_url($file);\n        }\n        $protocol = strtolower($this->protocol);\n        \n        $uri = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $file);\n\n        if (!in_array($protocol, $this->allowedProtocols, true)) {\n            throw new Exception(\"Permission denied on $file. The communication protocol is not supported.\");\n        }\n\n        if (!$this->options->isRemoteEnabled() && ($protocol !== \"\" && $protocol !== \"file://\")) {\n            throw new Exception(\"Remote file requested, but remote file download is disabled.\");\n        }\n\n        if ($protocol === \"\" || $protocol === \"file://\") {\n            $realfile = realpath($uri);\n\n            $chroot = $this->options->getChroot();\n            $chrootValid = false;\n            foreach ($chroot as $chrootPath) {\n                $chrootPath = realpath($chrootPath);\n                if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                    $chrootValid = true;\n                    break;\n                }\n            }\n            if ($chrootValid !== true) {\n                throw new Exception(\"Permission denied on $file. The file could not be found under the paths specified by Options::chroot.\");\n            }\n\n            $ext = strtolower(pathinfo($realfile, PATHINFO_EXTENSION));\n            if (!in_array($ext, $this->allowedLocalFileExtensions)) {\n                throw new Exception(\"Permission denied on $file. This file extension is forbidden\");\n            }\n\n            if (!$realfile) {\n                throw new Exception(\"File '$file' not found.\");\n            }\n\n            $uri = $realfile;\n        }\n\n        [$contents, $http_response_header] = Helpers::getFileContent($uri, $this->options->getHttpContext());\n        if ($contents === null) {\n            throw new Exception(\"File '$file' not found.\");\n        }\n\n        // See http://the-stickman.com/web-development/php/getting-http-response-headers-when-using-file_get_contents/\n        if (isset($http_response_header)) {\n            foreach ($http_response_header as $_header) {\n                if (preg_match(\"@Content-Type:\\s*[\\w/]+;\\s*?charset=([^\\s]+)@i\", $_header, $matches)) {\n                    $encoding = strtoupper($matches[1]);\n                    break;\n                }\n            }\n        }\n\n        $this->restorePhpConfig();\n\n        $this->loadHtml($contents, $encoding);\n    }\n\n    /**\n     * @param string $str\n     * @param string $encoding\n     * @deprecated\n     */\n    public function load_html($str, $encoding = null)\n    {\n        $this->loadHtml($str, $encoding);\n    }\n\n    public function loadDOM($doc, $quirksmode = false) {\n        // Remove #text children nodes in nodes that shouldn't have\n        $tag_names = [\"html\", \"head\", \"table\", \"tbody\", \"thead\", \"tfoot\", \"tr\"];\n        foreach ($tag_names as $tag_name) {\n            $nodes = $doc->getElementsByTagName($tag_name);\n\n            foreach ($nodes as $node) {\n                self::removeTextNodes($node);\n            }\n        }\n\n        $this->dom = $doc;\n        $this->quirksmode = $quirksmode;\n        $this->tree = new FrameTree($this->dom);\n    }\n\n    /**\n     * Loads an HTML string\n     * Parse errors are stored in the global array _dompdf_warnings.\n     *\n     * @param string $str HTML text to load\n     * @param string $encoding Encoding of $str\n     */\n    public function loadHtml($str, $encoding = null)\n    {\n        $this->setPhpConfig();\n\n        // Determine character encoding when $encoding parameter not used\n        if ($encoding === null) {\n            mb_detect_order('auto');\n            if (($encoding = mb_detect_encoding($str, null, true)) === false) {\n\n                //\"auto\" is expanded to \"ASCII,JIS,UTF-8,EUC-JP,SJIS\"\n                $encoding = \"auto\";\n            }\n        }\n\n        if (in_array(strtoupper($encoding), array('UTF-8','UTF8')) === false) {\n            $str = mb_convert_encoding($str, 'UTF-8', $encoding);\n\n            //Update encoding after converting\n            $encoding = 'UTF-8';\n        }\n\n        $metatags = [\n            '@<meta\\s+http-equiv=\"Content-Type\"\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))?@i',\n            '@<meta\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))\"?\\s+http-equiv=\"Content-Type\"@i',\n            '@<meta [^>]*charset\\s*=\\s*[\"\\']?\\s*([^\"\\' ]+)@i',\n        ];\n        foreach ($metatags as $metatag) {\n            if (preg_match($metatag, $str, $matches)) {\n                if (isset($matches[1]) && in_array($matches[1], mb_list_encodings())) {\n                    $document_encoding = $matches[1];\n                    break;\n                }\n            }\n        }\n        if (isset($document_encoding) && in_array(strtoupper($document_encoding), ['UTF-8','UTF8']) === false) {\n            $str = preg_replace('/charset=([^\\s\"]+)/i', 'charset=UTF-8', $str);\n        } elseif (isset($document_encoding) === false && strpos($str, '<head>') !== false) {\n            $str = str_replace('<head>', '<head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">', $str);\n        } elseif (isset($document_encoding) === false) {\n            $str = '<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">' . $str;\n        }\n\n        // remove BOM mark from UTF-8, it's treated as document text by DOMDocument\n        // FIXME: roll this into the encoding detection using UTF-8/16/32 BOM (http://us2.php.net/manual/en/function.mb-detect-encoding.php#91051)?\n        if (substr($str, 0, 3) == chr(0xEF) . chr(0xBB) . chr(0xBF)) {\n            $str = substr($str, 3);\n        }\n\n        // Store parsing warnings as messages\n        set_error_handler([Helpers::class, 'record_warnings']);\n\n        try {\n            // @todo Take the quirksmode into account\n            // https://quirks.spec.whatwg.org/\n            // http://hsivonen.iki.fi/doctype/\n            $quirksmode = false;\n\n            $html5 = new HTML5(['encoding' => $encoding, 'disable_html_ns' => true]);\n            $dom = $html5->loadHTML($str);\n\n            // extra step to normalize the HTML document structure\n            // see Masterminds/html5-php#166\n            $doc = new DOMDocument(\"1.0\", $encoding);\n            $doc->preserveWhiteSpace = true;\n            $doc->loadHTML($html5->saveHTML($dom), LIBXML_NOWARNING | LIBXML_NOERROR);\n\n            $this->loadDOM($doc, $quirksmode);\n        } finally {\n            restore_error_handler();\n            $this->restorePhpConfig();\n        }\n    }\n\n    /**\n     * @param DOMNode $node\n     * @deprecated\n     */\n    public static function remove_text_nodes(DOMNode $node)\n    {\n        self::removeTextNodes($node);\n    }\n\n    /**\n     * @param DOMNode $node\n     */\n    public static function removeTextNodes(DOMNode $node)\n    {\n        $children = [];\n        for ($i = 0; $i < $node->childNodes->length; $i++) {\n            $child = $node->childNodes->item($i);\n            if ($child->nodeName === \"#text\") {\n                $children[] = $child;\n            }\n        }\n\n        foreach ($children as $child) {\n            $node->removeChild($child);\n        }\n    }\n\n    /**\n     * Builds the {@link FrameTree}, loads any CSS and applies the styles to\n     * the {@link FrameTree}\n     */\n    private function processHtml()\n    {\n        $this->tree->build_tree();\n\n        $this->css->load_css_file($this->css->getDefaultStylesheet(), Stylesheet::ORIG_UA);\n\n        $acceptedmedia = Stylesheet::$ACCEPTED_GENERIC_MEDIA_TYPES;\n        $acceptedmedia[] = $this->options->getDefaultMediaType();\n\n        // <base href=\"\" />\n        /** @var \\DOMElement|null */\n        $baseNode = $this->dom->getElementsByTagName(\"base\")->item(0);\n        $baseHref = $baseNode ? $baseNode->getAttribute(\"href\") : \"\";\n        if ($baseHref !== \"\") {\n            [$this->protocol, $this->baseHost, $this->basePath] = Helpers::explode_url($baseHref);\n        }\n\n        // Set the base path of the Stylesheet to that of the file being processed\n        $this->css->set_protocol($this->protocol);\n        $this->css->set_host($this->baseHost);\n        $this->css->set_base_path($this->basePath);\n\n        // Get all the stylesheets so that they are processed in document order\n        $xpath = new DOMXPath($this->dom);\n        $stylesheets = $xpath->query(\"//*[name() = 'link' or name() = 'style']\");\n\n        /** @var \\DOMElement $tag */\n        foreach ($stylesheets as $tag) {\n            switch (strtolower($tag->nodeName)) {\n                // load <link rel=\"STYLESHEET\" ... /> tags\n                case \"link\":\n                    if (mb_strtolower(stripos($tag->getAttribute(\"rel\"), \"stylesheet\") !== false) || // may be \"appendix stylesheet\"\n                        mb_strtolower($tag->getAttribute(\"type\")) === \"text/css\"\n                    ) {\n                        //Check if the css file is for an accepted media type\n                        //media not given then always valid\n                        $formedialist = preg_split(\"/[\\s\\n,]/\", $tag->getAttribute(\"media\"), -1, PREG_SPLIT_NO_EMPTY);\n                        if (count($formedialist) > 0) {\n                            $accept = false;\n                            foreach ($formedialist as $type) {\n                                if (in_array(mb_strtolower(trim($type)), $acceptedmedia)) {\n                                    $accept = true;\n                                    break;\n                                }\n                            }\n\n                            if (!$accept) {\n                                //found at least one mediatype, but none of the accepted ones\n                                //Skip this css file.\n                                break;\n                            }\n                        }\n\n                        $url = $tag->getAttribute(\"href\");\n                        $url = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $url);\n\n                        $this->css->load_css_file($url, Stylesheet::ORIG_AUTHOR);\n                    }\n                    break;\n\n                // load <style> tags\n                case \"style\":\n                    // Accept all <style> tags by default (note this is contrary to W3C\n                    // HTML 4.0 spec:\n                    // http://www.w3.org/TR/REC-html40/present/styles.html#adef-media\n                    // which states that the default media type is 'screen'\n                    if ($tag->hasAttributes() &&\n                        ($media = $tag->getAttribute(\"media\")) &&\n                        !in_array($media, $acceptedmedia)\n                    ) {\n                        break;\n                    }\n\n                    $css = \"\";\n                    if ($tag->hasChildNodes()) {\n                        $child = $tag->firstChild;\n                        while ($child) {\n                            $css .= $child->nodeValue; // Handle <style><!-- blah --></style>\n                            $child = $child->nextSibling;\n                        }\n                    } else {\n                        $css = $tag->nodeValue;\n                    }\n\n                    // Set the base path of the Stylesheet to that of the file being processed\n                    $this->css->set_protocol($this->protocol);\n                    $this->css->set_host($this->baseHost);\n                    $this->css->set_base_path($this->basePath);\n\n                    $this->css->load_css($css, Stylesheet::ORIG_AUTHOR);\n                    break;\n            }\n\n            // Set the base path of the Stylesheet to that of the file being processed\n            $this->css->set_protocol($this->protocol);\n            $this->css->set_host($this->baseHost);\n            $this->css->set_base_path($this->basePath);\n        }\n    }\n\n    /**\n     * @param string $cacheId\n     * @deprecated\n     */\n    public function enable_caching($cacheId)\n    {\n        $this->enableCaching($cacheId);\n    }\n\n    /**\n     * Enable experimental caching capability\n     *\n     * @param string $cacheId\n     */\n    public function enableCaching($cacheId)\n    {\n        $this->cacheId = $cacheId;\n    }\n\n    /**\n     * @param string $value\n     * @return bool\n     * @deprecated\n     */\n    public function parse_default_view($value)\n    {\n        return $this->parseDefaultView($value);\n    }\n\n    /**\n     * @param string $value\n     * @return bool\n     */\n    public function parseDefaultView($value)\n    {\n        $valid = [\"XYZ\", \"Fit\", \"FitH\", \"FitV\", \"FitR\", \"FitB\", \"FitBH\", \"FitBV\"];\n\n        $options = preg_split(\"/\\s*,\\s*/\", trim($value));\n        $defaultView = array_shift($options);\n\n        if (!in_array($defaultView, $valid)) {\n            return false;\n        }\n\n        $this->setDefaultView($defaultView, $options);\n        return true;\n    }\n\n    /**\n     * Renders the HTML to PDF\n     */\n    public function render()\n    {\n        $this->setPhpConfig();\n\n        $logOutputFile = $this->options->getLogOutputFile();\n        if ($logOutputFile) {\n            if (!file_exists($logOutputFile) && is_writable(dirname($logOutputFile))) {\n                touch($logOutputFile);\n            }\n\n            $startTime = microtime(true);\n            if (is_writable($logOutputFile)) {\n                ob_start();\n            }\n        }\n\n        $this->processHtml();\n\n        $this->css->apply_styles($this->tree);\n\n        // @page style rules : size, margins\n        $pageStyles = $this->css->get_page_styles();\n        $basePageStyle = $pageStyles[\"base\"];\n        unset($pageStyles[\"base\"]);\n\n        foreach ($pageStyles as $pageStyle) {\n            $pageStyle->inherit($basePageStyle);\n        }\n\n        // Set paper size if defined via CSS\n        if (is_array($basePageStyle->size)) {\n            [$width, $height] = $basePageStyle->size;\n            $this->setPaper([0, 0, $width, $height]);\n        }\n\n        // Create a new canvas instance if the current one does not match the\n        // desired paper size\n        $canvasWidth = $this->canvas->get_width();\n        $canvasHeight = $this->canvas->get_height();\n        $size = $this->getPaperSize();\n\n        if ($canvasWidth !== $size[2] || $canvasHeight !== $size[3]) {\n            $this->canvas = CanvasFactory::get_instance($this, $this->paperSize, $this->paperOrientation);\n            $this->fontMetrics->setCanvas($this->canvas);\n        }\n\n        $canvas = $this->canvas;\n        $root = null;\n\n        foreach ($this->tree as $frame) {\n            // Set up the root frame\n            if (is_null($root)) {\n                $root = Factory::decorate_root($this->tree->get_root(), $this);\n                continue;\n            }\n\n            // Create the appropriate decorators, reflowers & positioners.\n            Factory::decorate_frame($frame, $this, $root);\n        }\n\n        // Add meta information\n        $title = $this->dom->getElementsByTagName(\"title\");\n        if ($title->length) {\n            $canvas->add_info(\"Title\", trim($title->item(0)->nodeValue));\n        }\n\n        $metas = $this->dom->getElementsByTagName(\"meta\");\n        $labels = [\n            \"author\" => \"Author\",\n            \"keywords\" => \"Keywords\",\n            \"description\" => \"Subject\",\n        ];\n        /** @var \\DOMElement $meta */\n        foreach ($metas as $meta) {\n            $name = mb_strtolower($meta->getAttribute(\"name\"));\n            $value = trim($meta->getAttribute(\"content\"));\n\n            if (isset($labels[$name])) {\n                $canvas->add_info($labels[$name], $value);\n                continue;\n            }\n\n            if ($name === \"dompdf.view\" && $this->parseDefaultView($value)) {\n                $canvas->set_default_view($this->defaultView, $this->defaultViewOptions);\n            }\n        }\n\n        $root->set_containing_block(0, 0, $canvas->get_width(), $canvas->get_height());\n        $root->set_renderer(new Renderer($this));\n\n        // This is where the magic happens:\n        $root->reflow();\n\n        // Clean up cached images\n        if (!$this->options->getDebugKeepTemp()) {\n            Cache::clear($this->options->getDebugPng());\n        }\n\n        global $_dompdf_warnings, $_dompdf_show_warnings;\n        if ($_dompdf_show_warnings && isset($_dompdf_warnings)) {\n            echo '<b>Dompdf Warnings</b><br><pre>';\n            foreach ($_dompdf_warnings as $msg) {\n                echo $msg . \"\\n\";\n            }\n\n            if ($canvas instanceof CPDF) {\n                echo $canvas->get_cpdf()->messages;\n            }\n            echo '</pre>';\n            flush();\n        }\n\n        if ($logOutputFile && is_writable($logOutputFile)) {\n            $this->writeLog($logOutputFile, $startTime);\n            ob_end_clean();\n        }\n\n        $this->restorePhpConfig();\n    }\n\n    /**\n     * Writes the output buffer in the log file\n     *\n     * @param string $logOutputFile\n     * @param float $startTime\n     */\n    private function writeLog(string $logOutputFile, float $startTime): void\n    {\n        $frames = Frame::$ID_COUNTER;\n        $memory = memory_get_peak_usage(true) / 1024;\n        $time = (microtime(true) - $startTime) * 1000;\n\n        $out = sprintf(\n            \"<span style='color: #000' title='Frames'>%6d</span>\" .\n            \"<span style='color: #009' title='Memory'>%10.2f KB</span>\" .\n            \"<span style='color: #900' title='Time'>%10.2f ms</span>\" .\n            \"<span  title='Quirksmode'>  \" .\n            ($this->quirksmode ? \"<span style='color: #d00'> ON</span>\" : \"<span style='color: #0d0'>OFF</span>\") .\n            \"</span><br />\", $frames, $memory, $time);\n\n        $out .= ob_get_contents();\n        ob_clean();\n\n        file_put_contents($logOutputFile, $out);\n    }\n\n    /**\n     * Add meta information to the PDF after rendering.\n     *\n     * @deprecated\n     */\n    public function add_info($label, $value)\n    {\n        $this->addInfo($label, $value);\n    }\n\n    /**\n     * Add meta information to the PDF after rendering.\n     *\n     * @param string $label Label of the value (Creator, Producer, etc.)\n     * @param string $value The text to set\n     */\n    public function addInfo(string $label, string $value): void\n    {\n        $this->canvas->add_info($label, $value);\n    }\n\n    /**\n     * Streams the PDF to the client.\n     *\n     * The file will open a download dialog by default. The options\n     * parameter controls the output. Accepted options (array keys) are:\n     *\n     * 'compress' = > 1 (=default) or 0:\n     *   Apply content stream compression\n     *\n     * 'Attachment' => 1 (=default) or 0:\n     *   Set the 'Content-Disposition:' HTTP header to 'attachment'\n     *   (thereby causing the browser to open a download dialog)\n     *\n     * @param string $filename the name of the streamed file\n     * @param array $options header options (see above)\n     */\n    public function stream($filename = \"document.pdf\", $options = [])\n    {\n        $this->setPhpConfig();\n\n        $this->canvas->stream($filename, $options);\n\n        $this->restorePhpConfig();\n    }\n\n    /**\n     * Returns the PDF as a string.\n     *\n     * The options parameter controls the output. Accepted options are:\n     *\n     * 'compress' = > 1 or 0 - apply content stream compression, this is\n     *    on (1) by default\n     *\n     * @param array $options options (see above)\n     *\n     * @return string|null\n     */\n    public function output($options = [])\n    {\n        $this->setPhpConfig();\n\n        $output = $this->canvas->output($options);\n\n        $this->restorePhpConfig();\n\n        return $output;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function output_html()\n    {\n        return $this->outputHtml();\n    }\n\n    /**\n     * Returns the underlying HTML document as a string\n     *\n     * @return string\n     */\n    public function outputHtml()\n    {\n        return $this->dom->saveHTML();\n    }\n\n    /**\n     * Get the dompdf option value\n     *\n     * @param string $key\n     * @return mixed\n     * @deprecated\n     */\n    public function get_option($key)\n    {\n        return $this->options->get($key);\n    }\n\n    /**\n     * @param string $key\n     * @param mixed $value\n     * @return $this\n     * @deprecated\n     */\n    public function set_option($key, $value)\n    {\n        $this->options->set($key, $value);\n        return $this;\n    }\n\n    /**\n     * @param array $options\n     * @return $this\n     * @deprecated\n     */\n    public function set_options(array $options)\n    {\n        $this->options->set($options);\n        return $this;\n    }\n\n    /**\n     * @param string $size\n     * @param string $orientation\n     * @deprecated\n     */\n    public function set_paper($size, $orientation = \"portrait\")\n    {\n        $this->setPaper($size, $orientation);\n    }\n\n    /**\n     * Sets the paper size & orientation\n     *\n     * @param string|float[] $size 'letter', 'legal', 'A4', etc. {@link Dompdf\\Adapter\\CPDF::$PAPER_SIZES}\n     * @param string $orientation 'portrait' or 'landscape'\n     * @return $this\n     */\n    public function setPaper($size, $orientation = \"portrait\")\n    {\n        $this->paperSize = $size;\n        $this->paperOrientation = $orientation;\n        return $this;\n    }\n\n    /**\n     * Gets the paper size\n     *\n     * @return float[] A four-element float array\n     */\n    public function getPaperSize()\n    {\n        $paper = $this->paperSize;\n        $orientation = $this->paperOrientation;\n\n        if (is_array($paper)) {\n            $size = array_map(\"floatval\", $paper);\n        } else {\n            $paper = strtolower($paper);\n            $size = CPDF::$PAPER_SIZES[$paper] ?? CPDF::$PAPER_SIZES[\"letter\"];\n        }\n\n        if (strtolower($orientation) === \"landscape\") {\n            [$size[2], $size[3]] = [$size[3], $size[2]];\n        }\n\n        return $size;\n    }\n\n    /**\n     * Gets the paper orientation\n     *\n     * @return string Either \"portrait\" or \"landscape\"\n     */\n    public function getPaperOrientation()\n    {\n        return $this->paperOrientation;\n    }\n\n    /**\n     * @param FrameTree $tree\n     * @return $this\n     */\n    public function setTree(FrameTree $tree)\n    {\n        $this->tree = $tree;\n        return $this;\n    }\n\n    /**\n     * @return FrameTree\n     * @deprecated\n     */\n    public function get_tree()\n    {\n        return $this->getTree();\n    }\n\n    /**\n     * Returns the underlying {@link FrameTree} object\n     *\n     * @return FrameTree\n     */\n    public function getTree()\n    {\n        return $this->tree;\n    }\n\n    /**\n     * @param string $protocol\n     * @return $this\n     * @deprecated\n     */\n    public function set_protocol($protocol)\n    {\n        return $this->setProtocol($protocol);\n    }\n\n    /**\n     * Sets the protocol to use\n     * FIXME validate these\n     *\n     * @param string $protocol\n     * @return $this\n     */\n    public function setProtocol(string $protocol)\n    {\n        $this->protocol = $protocol;\n        return $this;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function get_protocol()\n    {\n        return $this->getProtocol();\n    }\n\n    /**\n     * Returns the protocol in use\n     *\n     * @return string\n     */\n    public function getProtocol()\n    {\n        return $this->protocol;\n    }\n\n    /**\n     * @param string $host\n     * @deprecated\n     */\n    public function set_host($host)\n    {\n        $this->setBaseHost($host);\n    }\n\n    /**\n     * Sets the base hostname\n     *\n     * @param string $baseHost\n     * @return $this\n     */\n    public function setBaseHost(string $baseHost)\n    {\n        $this->baseHost = $baseHost;\n        return $this;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function get_host()\n    {\n        return $this->getBaseHost();\n    }\n\n    /**\n     * Returns the base hostname\n     *\n     * @return string\n     */\n    public function getBaseHost()\n    {\n        return $this->baseHost;\n    }\n\n    /**\n     * Sets the base path\n     *\n     * @param string $path\n     * @deprecated\n     */\n    public function set_base_path($path)\n    {\n        $this->setBasePath($path);\n    }\n\n    /**\n     * Sets the base path\n     *\n     * @param string $basePath\n     * @return $this\n     */\n    public function setBasePath(string $basePath)\n    {\n        $this->basePath = $basePath;\n        return $this;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function get_base_path()\n    {\n        return $this->getBasePath();\n    }\n\n    /**\n     * Returns the base path\n     *\n     * @return string\n     */\n    public function getBasePath()\n    {\n        return $this->basePath;\n    }\n\n    /**\n     * @param string $default_view The default document view\n     * @param array $options The view's options\n     * @return $this\n     * @deprecated\n     */\n    public function set_default_view($default_view, $options)\n    {\n        return $this->setDefaultView($default_view, $options);\n    }\n\n    /**\n     * Sets the default view\n     *\n     * @param string $defaultView The default document view\n     * @param array $options The view's options\n     * @return $this\n     */\n    public function setDefaultView($defaultView, $options)\n    {\n        $this->defaultView = $defaultView;\n        $this->defaultViewOptions = $options;\n        return $this;\n    }\n\n    /**\n     * @param resource $http_context\n     * @return $this\n     * @deprecated\n     */\n    public function set_http_context($http_context)\n    {\n        return $this->setHttpContext($http_context);\n    }\n\n    /**\n     * Sets the HTTP context\n     *\n     * @param resource|array $httpContext\n     * @return $this\n     */\n    public function setHttpContext($httpContext)\n    {\n        $this->options->setHttpContext($httpContext);\n        return $this;\n    }\n\n    /**\n     * @return resource\n     * @deprecated\n     */\n    public function get_http_context()\n    {\n        return $this->getHttpContext();\n    }\n\n    /**\n     * Returns the HTTP context\n     *\n     * @return resource\n     */\n    public function getHttpContext()\n    {\n        return $this->options->getHttpContext();\n    }\n\n    /**\n     * Set a custom `Canvas` instance to render the document to.\n     *\n     * Be aware that the instance will be replaced on render if the document\n     * defines a paper size different from the canvas.\n     *\n     * @param Canvas $canvas\n     * @return $this\n     */\n    public function setCanvas(Canvas $canvas)\n    {\n        $this->canvas = $canvas;\n        return $this;\n    }\n\n    /**\n     * @return Canvas\n     * @deprecated\n     */\n    public function get_canvas()\n    {\n        return $this->getCanvas();\n    }\n\n    /**\n     * Return the underlying Canvas instance (e.g. Dompdf\\Adapter\\CPDF, Dompdf\\Adapter\\GD)\n     *\n     * @return Canvas\n     */\n    public function getCanvas()\n    {\n        return $this->canvas;\n    }\n\n    /**\n     * @param Stylesheet $css\n     * @return $this\n     */\n    public function setCss(Stylesheet $css)\n    {\n        $this->css = $css;\n        return $this;\n    }\n\n    /**\n     * @return Stylesheet\n     * @deprecated\n     */\n    public function get_css()\n    {\n        return $this->getCss();\n    }\n\n    /**\n     * Returns the stylesheet\n     *\n     * @return Stylesheet\n     */\n    public function getCss()\n    {\n        return $this->css;\n    }\n\n    /**\n     * @param DOMDocument $dom\n     * @return $this\n     */\n    public function setDom(DOMDocument $dom)\n    {\n        $this->dom = $dom;\n        return $this;\n    }\n\n    /**\n     * @return DOMDocument\n     * @deprecated\n     */\n    public function get_dom()\n    {\n        return $this->getDom();\n    }\n\n    /**\n     * @return DOMDocument\n     */\n    public function getDom()\n    {\n        return $this->dom;\n    }\n\n    /**\n     * @param Options $options\n     * @return $this\n     */\n    public function setOptions(Options $options)\n    {\n        // For backwards compatibility\n        if ($this->options && $this->options->getHttpContext() && !$options->getHttpContext()) {\n            $options->setHttpContext($this->options->getHttpContext());\n        }\n\n        $this->options = $options;\n        $fontMetrics = $this->fontMetrics;\n        if (isset($fontMetrics)) {\n            $fontMetrics->setOptions($options);\n        }\n        return $this;\n    }\n\n    /**\n     * @return Options\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * @return array\n     * @deprecated\n     */\n    public function get_callbacks()\n    {\n        return $this->getCallbacks();\n    }\n\n    /**\n     * Returns the callbacks array\n     *\n     * @return array\n     */\n    public function getCallbacks()\n    {\n        return $this->callbacks;\n    }\n\n    /**\n     * @param array $callbacks the set of callbacks to set\n     * @deprecated\n     */\n    public function set_callbacks($callbacks)\n    {\n        $this->setCallbacks($callbacks);\n    }\n\n    /**\n     * Sets callbacks for events like rendering of pages and elements.\n     *\n     * The callbacks array should contain arrays with `event` set to a callback\n     * event name and `f` set to a function or any other callable.\n     *\n     * The available callback events are:\n     * * `begin_page_reflow`: called before page reflow\n     * * `begin_frame`: called before a frame is rendered\n     * * `end_frame`: called after frame rendering is complete\n     * * `begin_page_render`: called before a page is rendered\n     * * `end_page_render`: called after page rendering is complete\n     *\n     * The function `f` must take an array as argument, which contains info\n     * about the event (`[0 => Canvas, 1 => Frame, \"canvas\" => Canvas,\n     * \"frame\" => Frame]`).\n     *\n     * @param array $callbacks The set of callbacks to set\n     */\n    public function setCallbacks($callbacks)\n    {\n        if (is_array($callbacks)) {\n            $this->callbacks = [];\n            foreach ($callbacks as $c) {\n                if (is_array($c) && isset($c[\"event\"]) && isset($c[\"f\"])) {\n                    $event = $c[\"event\"];\n                    $f = $c[\"f\"];\n                    if (is_string($event) && is_callable($f)) {\n                        $this->callbacks[$event][] = $f;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @return boolean\n     * @deprecated\n     */\n    public function get_quirksmode()\n    {\n        return $this->getQuirksmode();\n    }\n\n    /**\n     * Get the quirks mode\n     *\n     * @return boolean true if quirks mode is active\n     */\n    public function getQuirksmode()\n    {\n        return $this->quirksmode;\n    }\n\n    /**\n     * @param FontMetrics $fontMetrics\n     * @return $this\n     */\n    public function setFontMetrics(FontMetrics $fontMetrics)\n    {\n        $this->fontMetrics = $fontMetrics;\n        return $this;\n    }\n\n    /**\n     * @return FontMetrics\n     */\n    public function getFontMetrics()\n    {\n        return $this->fontMetrics;\n    }\n\n    /**\n     * PHP5 overloaded getter\n     * Along with {@link Dompdf::__set()} __get() provides access to all\n     * properties directly.  Typically __get() is not called directly outside\n     * of this class.\n     *\n     * @param string $prop\n     *\n     * @throws Exception\n     * @return mixed\n     */\n    function __get($prop)\n    {\n        switch ($prop) {\n            case 'version':\n                return $this->version;\n            default:\n                throw new Exception('Invalid property: ' . $prop);\n        }\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\nnamespace Dompdf;\n\nuse FontLib\\Font;\n\n/**\n * The font metrics class\n *\n * This class provides information about fonts and text.  It can resolve\n * font names into actual installed font files, as well as determine the\n * size of text in a particular font and size.\n *\n * @static\n * @package dompdf\n */\nclass FontMetrics\n{\n    /**\n     * Name of the user font families file\n     *\n     * This file must be writable by the webserver process only to update it\n     * with save_font_families() after adding the .afm file references of a new font family\n     * with FontMetrics::saveFontFamilies().\n     * This is typically done only from command line with load_font.php on converting\n     * ttf fonts to ufm with php-font-lib.\n     */\n    const USER_FONTS_FILE = \"installed-fonts.json\";\n\n\n    /**\n     * Underlying {@link Canvas} object to perform text size calculations\n     *\n     * @var Canvas\n     */\n    protected $canvas;\n\n    /**\n     * Array of bundled font family names to variants\n     *\n     * @var array\n     */\n    protected $bundledFonts = [];\n\n    /**\n     * Array of user defined font family names to variants\n     *\n     * @var array\n     */\n    protected $userFonts = [];\n\n    /**\n     * combined list of all font families with absolute paths\n     *\n     * @var array\n     */\n    protected $fontFamilies;\n\n    /**\n     * @var Options\n     */\n    private $options;\n\n    /**\n     * Class initialization\n     */\n    public function __construct(Canvas $canvas, Options $options)\n    {\n        $this->setCanvas($canvas);\n        $this->setOptions($options);\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * @deprecated\n     */\n    public function save_font_families()\n    {\n        $this->saveFontFamilies();\n    }\n\n    /**\n     * Saves the stored font family cache\n     *\n     * The name and location of the cache file are determined by {@link\n     * FontMetrics::USER_FONTS_FILE}. This file should be writable by the\n     * webserver process.\n     *\n     * @see FontMetrics::loadFontFamilies()\n     */\n    public function saveFontFamilies()\n    {\n        file_put_contents($this->getUserFontsFilePath(), json_encode($this->userFonts, JSON_PRETTY_PRINT));\n    }\n\n    /**\n     * @deprecated\n     */\n    public function load_font_families()\n    {\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * Loads the stored font family cache\n     *\n     * @see FontMetrics::saveFontFamilies()\n     */\n    public function loadFontFamilies()\n    {\n        $file = $this->options->getRootDir() . \"/lib/fonts/installed-fonts.dist.json\";\n        $this->bundledFonts = json_decode(file_get_contents($file), true);\n\n        if (is_readable($this->getUserFontsFilePath())) {\n            $this->userFonts = json_decode(file_get_contents($this->getUserFontsFilePath()), true);\n        } else {\n            $this->loadFontFamiliesLegacy();\n        }\n    }\n\n    private function loadFontFamiliesLegacy()\n    {\n        $legacyCacheFile = $this->options->getFontDir() . '/dompdf_font_family_cache.php';\n        if (is_readable($legacyCacheFile)) {\n            $fontDir = $this->options->getFontDir();\n            $rootDir = $this->options->getRootDir();\n    \n            if (!defined(\"DOMPDF_DIR\")) { define(\"DOMPDF_DIR\", $rootDir); }\n            if (!defined(\"DOMPDF_FONT_DIR\")) { define(\"DOMPDF_FONT_DIR\", $fontDir); }\n    \n            $cacheDataClosure = require $legacyCacheFile;\n            $cacheData = is_array($cacheDataClosure) ? $cacheDataClosure : $cacheDataClosure($fontDir, $rootDir);\n            if (is_array($cacheData)) {\n                foreach ($cacheData as $family => $variants) {\n                    if (!isset($this->bundledFonts[$family]) && is_array($variants)) {\n                        foreach ($variants as $variant => $variantPath) {\n                            $variantName = basename($variantPath);\n                            $variantDir = dirname($variantPath);\n                            if ($variantDir == $fontDir) {\n                                $this->userFonts[$family][$variant] = $variantName;\n                            } else {\n                                $this->userFonts[$family][$variant] = $variantPath;\n                            }\n                        }\n                    }\n                }\n                $this->saveFontFamilies();\n            }\n        }\n    }\n\n    /**\n     * @param array $style\n     * @param string $remote_file\n     * @param resource $context\n     * @return bool\n     * @deprecated\n     */\n    public function register_font($style, $remote_file, $context = null)\n    {\n        return $this->registerFont($style, $remote_file);\n    }\n\n    /**\n     * @param array $style\n     * @param string $remoteFile\n     * @param resource $context\n     * @return bool\n     */\n    public function registerFont($style, $remoteFile, $context = null)\n    {\n        $fontname = mb_strtolower($style[\"family\"]);\n        $families = $this->getFontFamilies();\n\n        $entry = [];\n        if (isset($families[$fontname])) {\n            $entry = $families[$fontname];\n        }\n\n        $styleString = $this->getType(\"{$style['weight']} {$style['style']}\");\n\n        $remoteHash = md5($remoteFile);\n\n        $prefix = $fontname . \"_\" . $styleString;\n        $prefix = trim($prefix, \"-\");\n        if (function_exists('iconv')) {\n            $prefix = @iconv('utf-8', 'us-ascii//TRANSLIT', $prefix);\n        }\n        $prefix_encoding = mb_detect_encoding($prefix, mb_detect_order(), true);\n        $substchar = mb_substitute_character();\n        mb_substitute_character(0x005F);\n        $prefix = mb_convert_encoding($prefix, \"ISO-8859-1\", $prefix_encoding);\n        mb_substitute_character($substchar);\n        $prefix = preg_replace(\"[\\W]\", \"_\", $prefix);\n        $prefix = preg_replace(\"/[^-_\\w]+/\", \"\", $prefix);\n\n        $localFile = $prefix . \"_\" . $remoteHash;\n        $localFilePath = $this->getOptions()->getFontDir() . \"/\" . $localFile;\n\n        if (isset($entry[$styleString]) && $localFilePath == $entry[$styleString]) {\n            return true;\n        }\n\n\n        $entry[$styleString] = $localFile;\n\n        // Download the remote file\n        [$protocol] = Helpers::explode_url($remoteFile);\n        if (!$this->options->isRemoteEnabled() && ($protocol !== \"\" && $protocol !== \"file://\")) {\n            Helpers::record_warnings(E_USER_WARNING, \"Remote font resource $remoteFile referenced, but remote file download is disabled.\", __FILE__, __LINE__);\n            return false;\n        }\n        if ($protocol === \"\" || $protocol === \"file://\") {\n            $realfile = realpath($remoteFile);\n\n            $rootDir = realpath($this->options->getRootDir());\n            if (strpos($realfile, $rootDir) !== 0) {\n                $chroot = $this->options->getChroot();\n                $chrootValid = false;\n                foreach ($chroot as $chrootPath) {\n                    $chrootPath = realpath($chrootPath);\n                    if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                        $chrootValid = true;\n                        break;\n                    }\n                }\n                if ($chrootValid !== true) {\n                    Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $remoteFile. The file could not be found under the paths specified by Options::chroot.\", __FILE__, __LINE__);\n                    return false;\n                }\n            }\n\n            if (!$realfile) {\n                Helpers::record_warnings(E_USER_WARNING, \"File '$realfile' not found.\", __FILE__, __LINE__);\n                return false;\n            }\n\n            $remoteFile = $realfile;\n        }\n        list($remoteFileContent, $http_response_header) = @Helpers::getFileContent($remoteFile, $context);\n        if ($remoteFileContent === null) {\n            return false;\n        }\n\n        $localTempFile = @tempnam($this->options->get(\"tempDir\"), \"dompdf-font-\");\n        file_put_contents($localTempFile, $remoteFileContent);\n\n        $font = Font::load($localTempFile);\n\n        if (!$font) {\n            unlink($localTempFile);\n            return false;\n        }\n\n        $font->parse();\n        $font->saveAdobeFontMetrics(\"$localFilePath.ufm\");\n        $font->close();\n\n        unlink($localTempFile);\n\n        if ( !file_exists(\"$localFilePath.ufm\") ) {\n            return false;\n        }\n\n        $fontExtension = \".ttf\";\n        switch ($font->getFontType()) {\n            case \"TrueType\":\n            default:\n                $fontExtension = \".ttf\";\n                break;\n        }\n\n        // Save the changes\n        file_put_contents($localFilePath.$fontExtension, $remoteFileContent);\n\n        if ( !file_exists($localFilePath.$fontExtension) ) {\n            unlink(\"$localFilePath.ufm\");\n            return false;\n        }\n\n        $this->setFontFamily($fontname, $entry);\n\n        return true;\n    }\n\n    /**\n     * @param $text\n     * @param $font\n     * @param $size\n     * @param float $word_spacing\n     * @param float $char_spacing\n     * @return float\n     * @deprecated\n     */\n    public function get_text_width($text, $font, $size, $word_spacing = 0.0, $char_spacing = 0.0)\n    {\n        //return self::$_pdf->get_text_width($text, $font, $size, $word_spacing, $char_spacing);\n        return $this->getTextWidth($text, $font, $size, $word_spacing, $char_spacing);\n    }\n\n    /**\n     * Calculates text size, in points\n     *\n     * @param string $text        the text to be sized\n     * @param string $font        the desired font\n     * @param float  $size        the desired font size\n     * @param float  $wordSpacing word spacing, if any\n     * @param float  $charSpacing char spacing, if any\n     *\n     * @return float\n     */\n    public function getTextWidth(string $text, $font, float $size, float $wordSpacing = 0.0, float $charSpacing = 0.0): float\n    {\n        // @todo Make sure this cache is efficient before enabling it\n        static $cache = [];\n\n        if ($text === \"\") {\n            return 0;\n        }\n\n        // Don't cache long strings\n        $useCache = !isset($text[50]); // Faster than strlen\n\n        // Text-size calculations depend on the canvas used. Make sure to not\n        // return wrong values when switching canvas backends\n        $canvasClass = get_class($this->canvas);\n        $key = \"$canvasClass/$font/$size/$wordSpacing/$charSpacing\";\n\n        if ($useCache && isset($cache[$key][$text])) {\n            return $cache[$key][$text];\n        }\n\n        $width = $this->canvas->get_text_width($text, $font, $size, $wordSpacing, $charSpacing);\n\n        if ($useCache) {\n            $cache[$key][$text] = $width;\n        }\n\n        return $width;\n    }\n\n    /**\n     * @param $font\n     * @param $size\n     * @return float\n     * @deprecated\n     */\n    public function get_font_height($font, $size)\n    {\n        return $this->getFontHeight($font, $size);\n    }\n\n    /**\n     * Calculates font height, in points\n     *\n     * @param string $font\n     * @param float  $size\n     *\n     * @return float\n     */\n    public function getFontHeight($font, float $size): float\n    {\n        return $this->canvas->get_font_height($font, $size);\n    }\n\n    /**\n     * Calculates font baseline, in points\n     *\n     * @param string $font\n     * @param float  $size\n     *\n     * @return float\n     */\n    public function getFontBaseline($font, float $size): float\n    {\n        return $this->canvas->get_font_baseline($font, $size);\n    }\n\n    /**\n     * @param $family_raw\n     * @param string $subtype_raw\n     * @return string\n     * @deprecated\n     */\n    public function get_font($family_raw, $subtype_raw = \"normal\")\n    {\n        return $this->getFont($family_raw, $subtype_raw);\n    }\n\n    /**\n     * Resolves a font family & subtype into an actual font file\n     * Subtype can be one of 'normal', 'bold', 'italic' or 'bold_italic'.  If\n     * the particular font family has no suitable font file, the default font\n     * ({@link Options::defaultFont}) is used.  The font file returned\n     * is the absolute pathname to the font file on the system.\n     *\n     * @param string|null $familyRaw\n     * @param string      $subtypeRaw\n     *\n     * @return string|null\n     */\n    public function getFont($familyRaw, $subtypeRaw = \"normal\")\n    {\n        static $cache = [];\n\n        if (isset($cache[$familyRaw][$subtypeRaw])) {\n            return $cache[$familyRaw][$subtypeRaw];\n        }\n\n        /* Allow calling for various fonts in search path. Therefore not immediately\n         * return replacement on non match.\n         * Only when called with NULL try replacement.\n         * When this is also missing there is really trouble.\n         * If only the subtype fails, nevertheless return failure.\n         * Only on checking the fallback font, check various subtypes on same font.\n         */\n\n        $subtype = strtolower($subtypeRaw);\n\n        $families = $this->getFontFamilies();\n        if ($familyRaw) {\n            $family = str_replace([\"'\", '\"'], \"\", strtolower($familyRaw));\n\n            if (isset($families[$family][$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $families[$family][$subtype];\n            }\n\n            return null;\n        }\n\n        $fallback_families = [strtolower($this->options->getDefaultFont()), \"serif\"];\n        foreach ($fallback_families as $family) {\n            if (isset($families[$family][$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $families[$family][$subtype];\n            }\n    \n            if (!isset($families[$family])) {\n                continue;\n            }\n    \n            $family = $families[$family];\n    \n            foreach ($family as $sub => $font) {\n                if (strpos($subtype, $sub) !== false) {\n                    return $cache[$familyRaw][$subtypeRaw] = $font;\n                }\n            }\n    \n            if ($subtype !== \"normal\") {\n                foreach ($family as $sub => $font) {\n                    if ($sub !== \"normal\") {\n                        return $cache[$familyRaw][$subtypeRaw] = $font;\n                    }\n                }\n            }\n    \n            $subtype = \"normal\";\n    \n            if (isset($family[$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $family[$subtype];\n            }\n        }\n        \n        return null;\n    }\n\n    /**\n     * @param $family\n     * @return null|string\n     * @deprecated\n     */\n    public function get_family($family)\n    {\n        return $this->getFamily($family);\n    }\n\n    /**\n     * @param string $family\n     * @return null|string\n     */\n    public function getFamily($family)\n    {\n        $family = str_replace([\"'\", '\"'], \"\", mb_strtolower($family));\n        $families = $this->getFontFamilies();\n\n        if (isset($families[$family])) {\n            return $families[$family];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $type\n     * @return string\n     * @deprecated\n     */\n    public function get_type($type)\n    {\n        return $this->getType($type);\n    }\n\n    /**\n     * @param string $type\n     * @return string\n     */\n    public function getType($type)\n    {\n        if (preg_match('/bold/i', $type)) {\n            $weight = 700;\n        } elseif (preg_match('/([1-9]00)/', $type, $match)) {\n            $weight = (int)$match[0];\n        } else {\n            $weight = 400;\n        }\n        $weight = $weight === 400 ? 'normal' : $weight;\n        $weight = $weight === 700 ? 'bold' : $weight;\n\n        $style = preg_match('/italic|oblique/i', $type) ? 'italic' : null;\n\n        if ($weight === 'normal' && $style !== null) {\n            return $style;\n        }\n\n        return $style === null\n            ? $weight\n            : $weight.'_'.$style;\n    }\n\n    /**\n     * @return array\n     * @deprecated\n     */\n    public function get_font_families()\n    {\n        return $this->getFontFamilies();\n    }\n\n    /**\n     * Returns the current font lookup table\n     *\n     * @return array\n     */\n    public function getFontFamilies()\n    {\n        if (!isset($this->fontFamilies)) {\n            $this->setFontFamilies();\n        }\n        return $this->fontFamilies;\n    }\n\n    /**\n     * Convert loaded fonts to font lookup table\n     *\n     * @return array\n     */\n    public function setFontFamilies()\n    {\n        $fontFamilies = [];\n        if (isset($this->bundledFonts) && is_array($this->bundledFonts)) {\n            foreach ($this->bundledFonts as $family => $variants) {\n                if (!isset($fontFamilies[$family])) {\n                    $fontFamilies[$family] = array_map(function($variant) {\n                        return $this->getOptions()->getRootDir() . '/lib/fonts/' . $variant;\n                    }, $variants);\n                }\n            }\n        }\n        if (isset($this->userFonts) && is_array($this->userFonts)) {\n            foreach ($this->userFonts as $family => $variants) {\n                $fontFamilies[$family] = array_map(function($variant) {\n                    $variantName = basename($variant);\n                    if ($variantName === $variant) {\n                        return $this->getOptions()->getFontDir() . '/' . $variant;\n                    }\n                    return $variant;\n                }, $variants);\n            }\n        }\n        $this->fontFamilies = $fontFamilies;\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     * @deprecated\n     */\n    public function set_font_family($fontname, $entry)\n    {\n        $this->setFontFamily($fontname, $entry);\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     */\n    public function setFontFamily($fontname, $entry)\n    {\n        $this->userFonts[mb_strtolower($fontname)] = $entry;\n        $this->saveFontFamilies();\n        unset($this->fontFamilies);\n    }\n\n    /**\n     * @return string\n     */\n    public function getUserFontsFilePath()\n    {\n        return $this->options->getFontDir() . '/' . self::USER_FONTS_FILE;\n    }\n\n    /**\n     * @param Options $options\n     * @return $this\n     */\n    public function setOptions(Options $options)\n    {\n        $this->options = $options;\n        unset($this->fontFamilies);\n        return $this;\n    }\n\n    /**\n     * @return Options\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * @param Canvas $canvas\n     * @return $this\n     */\n    public function setCanvas(Canvas $canvas)\n    {\n        $this->canvas = $canvas;\n        return $this;\n    }\n\n    /**\n     * @return Canvas\n     */\n    public function getCanvas()\n    {\n        return $this->canvas;\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\FrameDecorator;\n\nuse Dompdf\\Dompdf;\nuse Dompdf\\Frame;\nuse Dompdf\\Helpers;\nuse Dompdf\\Image\\Cache;\n\n/**\n * Decorates frames for image layout and rendering\n *\n * @package dompdf\n */\nclass Image extends AbstractFrameDecorator\n{\n\n    /**\n     * The path to the image file (note that remote images are\n     * downloaded locally to Options:tempDir).\n     *\n     * @var string\n     */\n    protected $_image_url;\n\n    /**\n     * The image's file error message\n     *\n     * @var string\n     */\n    protected $_image_msg;\n\n    /**\n     * Class constructor\n     *\n     * @param Frame $frame the frame to decorate\n     * @param DOMPDF $dompdf the document's dompdf object (required to resolve relative & remote urls)\n     */\n    function __construct(Frame $frame, Dompdf $dompdf)\n    {\n        parent::__construct($frame, $dompdf);\n        $url = $frame->get_node()->getAttribute(\"src\");\n\n        $debug_png = $dompdf->getOptions()->getDebugPng();\n        if ($debug_png) {\n            print '[__construct ' . $url . ']';\n        }\n\n        list($this->_image_url, /*$type*/, $this->_image_msg) = Cache::resolve_url(\n            $url,\n            $dompdf->getProtocol(),\n            $dompdf->getBaseHost(),\n            $dompdf->getBasePath(),\n            $dompdf\n        );\n\n        if (Cache::is_broken($this->_image_url) &&\n            $alt = $frame->get_node()->getAttribute(\"alt\")\n        ) {\n            $fontMetrics = $dompdf->getFontMetrics();\n            $style = $frame->get_style();\n            $font = $style->font_family;\n            $size = $style->font_size;\n            $word_spacing = $style->word_spacing;\n            $letter_spacing = $style->letter_spacing;\n\n            $style->width = (4 / 3) * $fontMetrics->getTextWidth($alt, $font, $size, $word_spacing, $letter_spacing);\n            $style->height = $fontMetrics->getFontHeight($font, $size);\n        }\n    }\n\n    /**\n     * Get the intrinsic pixel dimensions of the image.\n     *\n     * @return array Width and height as `float|int`.\n     */\n    public function get_intrinsic_dimensions(): array\n    {\n        [$width, $height] = Helpers::dompdf_getimagesize($this->_image_url, $this->_dompdf->getHttpContext());\n\n        return [$width, $height];\n    }\n\n    /**\n     * Resample the given pixel length according to dpi.\n     *\n     * @param float|int $length\n     * @return float\n     */\n    public function resample($length): float\n    {\n        $dpi = $this->_dompdf->getOptions()->getDpi();\n        return ($length * 72) / $dpi;\n    }\n\n    /**\n     * Return the image's url\n     *\n     * @return string The url of this image\n     */\n    function get_image_url()\n    {\n        return $this->_image_url;\n    }\n\n    /**\n     * Return the image's error message\n     *\n     * @return string The image's error message\n     */\n    function get_image_msg()\n    {\n        return $this->_image_msg;\n    }\n\n}\n", "<?php\nnamespace Dompdf;\n\nclass Helpers\n{\n    /**\n     * print_r wrapper for html/cli output\n     *\n     * Wraps print_r() output in < pre > tags if the current sapi is not 'cli'.\n     * Returns the output string instead of displaying it if $return is true.\n     *\n     * @param mixed $mixed variable or expression to display\n     * @param bool $return\n     *\n     * @return string|null\n     */\n    public static function pre_r($mixed, $return = false)\n    {\n        if ($return) {\n            return \"<pre>\" . print_r($mixed, true) . \"</pre>\";\n        }\n\n        if (php_sapi_name() !== \"cli\") {\n            echo \"<pre>\";\n        }\n\n        print_r($mixed);\n\n        if (php_sapi_name() !== \"cli\") {\n            echo \"</pre>\";\n        } else {\n            echo \"\\n\";\n        }\n\n        flush();\n\n        return null;\n    }\n\n    /**\n     * builds a full url given a protocol, hostname, base path and url\n     *\n     * @param string $protocol\n     * @param string $host\n     * @param string $base_path\n     * @param string $url\n     * @return string\n     *\n     * Initially the trailing slash of $base_path was optional, and conditionally appended.\n     * However on dynamically created sites, where the page is given as url parameter,\n     * the base path might not end with an url.\n     * Therefore do not append a slash, and **require** the $base_url to ending in a slash\n     * when needed.\n     * Vice versa, on using the local file system path of a file, make sure that the slash\n     * is appended (o.k. also for Windows)\n     */\n    public static function build_url($protocol, $host, $base_path, $url)\n    {\n        $protocol = mb_strtolower($protocol);\n        if ($url === \"\") {\n            //return $protocol . $host . rtrim($base_path, \"/\\\\\") . \"/\";\n            return $protocol . $host . $base_path;\n        }\n\n        // Is the url already fully qualified, a Data URI, or a reference to a named anchor?\n        // File-protocol URLs may require additional processing (e.g. for URLs with a relative path)\n        if ((mb_strpos($url, \"://\") !== false && substr($url, 0, 7) !== \"file://\") || mb_substr($url, 0, 1) === \"#\" || mb_strpos($url, \"data:\") === 0 || mb_strpos($url, \"mailto:\") === 0 || mb_strpos($url, \"tel:\") === 0) {\n            return $url;\n        }\n\n        if (strpos($url, \"file://\") === 0) {\n            $url = substr($url, 7);\n            $protocol = \"\";\n        }\n\n        $ret = \"\";\n        if ($protocol !== \"file://\") {\n            $ret = $protocol;\n        }\n\n        if (!in_array(mb_strtolower($protocol), [\"http://\", \"https://\", \"ftp://\", \"ftps://\"], true)) {\n            //On Windows local file, an abs path can begin also with a '\\' or a drive letter and colon\n            //drive: followed by a relative path would be a drive specific default folder.\n            //not known in php app code, treat as abs path\n            //($url[1] !== ':' || ($url[2]!=='\\\\' && $url[2]!=='/'))\n            if ($url[0] !== '/' && (strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN' || (mb_strlen($url) > 1 && $url[0] !== '\\\\' && $url[1] !== ':'))) {\n                // For rel path and local access we ignore the host, and run the path through realpath()\n                $ret .= realpath($base_path) . '/';\n            }\n            $ret .= $url;\n            $ret = preg_replace('/\\?(.*)$/', \"\", $ret);\n            return $ret;\n        }\n\n        // Protocol relative urls (e.g. \"//example.org/style.css\")\n        if (strpos($url, '//') === 0) {\n            $ret .= substr($url, 2);\n            //remote urls with backslash in html/css are not really correct, but lets be genereous\n        } elseif ($url[0] === '/' || $url[0] === '\\\\') {\n            // Absolute path\n            $ret .= $host . $url;\n        } else {\n            // Relative path\n            //$base_path = $base_path !== \"\" ? rtrim($base_path, \"/\\\\\") . \"/\" : \"\";\n            $ret .= $host . $base_path . $url;\n        }\n\n        // URL should now be complete, final cleanup\n        $parsed_url = parse_url($ret);\n\n        // reproduced from https://www.php.net/manual/en/function.parse-url.php#106731\n        $scheme   = isset($parsed_url['scheme']) ? $parsed_url['scheme'] . '://' : '';\n        $host     = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $port     = isset($parsed_url['port']) ? ':' . $parsed_url['port'] : '';\n        $user     = isset($parsed_url['user']) ? $parsed_url['user'] : '';\n        $pass     = isset($parsed_url['pass']) ? ':' . $parsed_url['pass']  : '';\n        $pass     = ($user || $pass) ? \"$pass@\" : '';\n        $path     = isset($parsed_url['path']) ? $parsed_url['path'] : '';\n        $query    = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';\n        $fragment = isset($parsed_url['fragment']) ? '#' . $parsed_url['fragment'] : '';\n        \n        // partially reproduced from https://stackoverflow.com/a/1243431/264628\n        /* replace '//' or '/./' or '/foo/../' with '/' */\n        $re = array('#(/\\.?/)#', '#/(?!\\.\\.)[^/]+/\\.\\./#');\n        for ($n=1; $n>0; $path=preg_replace($re, '/', $path, -1, $n)) {}\n\n        $ret = \"$scheme$user$pass$host$port$path$query$fragment\";\n\n        return $ret;\n    }\n\n    /**\n     * Builds a HTTP Content-Disposition header string using `$dispositionType`\n     * and `$filename`.\n     *\n     * If the filename contains any characters not in the ISO-8859-1 character\n     * set, a fallback filename will be included for clients not supporting the\n     * `filename*` parameter.\n     *\n     * @param string $dispositionType\n     * @param string $filename\n     * @return string\n     */\n    public static function buildContentDispositionHeader($dispositionType, $filename)\n    {\n        $encoding = mb_detect_encoding($filename);\n        $fallbackfilename = mb_convert_encoding($filename, \"ISO-8859-1\", $encoding);\n        $fallbackfilename = str_replace(\"\\\"\", \"\", $fallbackfilename);\n        $encodedfilename = rawurlencode($filename);\n\n        $contentDisposition = \"Content-Disposition: $dispositionType; filename=\\\"$fallbackfilename\\\"\";\n        if ($fallbackfilename !== $filename) {\n            $contentDisposition .= \"; filename*=UTF-8''$encodedfilename\";\n        }\n\n        return $contentDisposition;\n    }\n\n    /**\n     * Converts decimal numbers to roman numerals.\n     *\n     * As numbers larger than 3999 (and smaller than 1) cannot be represented in\n     * the standard form of roman numerals, those are left in decimal form.\n     *\n     * See https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n     *\n     * @param int|string $num\n     *\n     * @throws Exception\n     * @return string\n     */\n    public static function dec2roman($num): string\n    {\n\n        static $ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n        static $tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n        static $hund = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n        static $thou = [\"\", \"m\", \"mm\", \"mmm\"];\n\n        if (!is_numeric($num)) {\n            throw new Exception(\"dec2roman() requires a numeric argument.\");\n        }\n\n        if ($num >= 4000 || $num <= 0) {\n            return (string) $num;\n        }\n\n        $num = strrev((string)$num);\n\n        $ret = \"\";\n        switch (mb_strlen($num)) {\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 4:\n                $ret .= $thou[$num[3]];\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 3:\n                $ret .= $hund[$num[2]];\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 2:\n                $ret .= $tens[$num[1]];\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 1:\n                $ret .= $ones[$num[0]];\n            default:\n                break;\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Restrict a length to the given range.\n     *\n     * If min > max, the result is min.\n     *\n     * @param float $length\n     * @param float $min\n     * @param float $max\n     *\n     * @return float\n     */\n    public static function clamp(float $length, float $min, float $max): float\n    {\n        return max($min, min($length, $max));\n    }\n\n    /**\n     * Determines whether $value is a percentage or not\n     *\n     * @param string|float|int $value\n     *\n     * @return bool\n     */\n    public static function is_percent($value): bool\n    {\n        return is_string($value) && false !== mb_strpos($value, \"%\");\n    }\n\n    /**\n     * Parses a data URI scheme\n     * http://en.wikipedia.org/wiki/Data_URI_scheme\n     *\n     * @param string $data_uri The data URI to parse\n     *\n     * @return array|bool The result with charset, mime type and decoded data\n     */\n    public static function parse_data_uri($data_uri)\n    {\n        if (!preg_match('/^data:(?P<mime>[a-z0-9\\/+-.]+)(;charset=(?P<charset>[a-z0-9-])+)?(?P<base64>;base64)?\\,(?P<data>.*)?/is', $data_uri, $match)) {\n            return false;\n        }\n\n        $match['data'] = rawurldecode($match['data']);\n        $result = [\n            'charset' => $match['charset'] ? $match['charset'] : 'US-ASCII',\n            'mime' => $match['mime'] ? $match['mime'] : 'text/plain',\n            'data' => $match['base64'] ? base64_decode($match['data']) : $match['data'],\n        ];\n\n        return $result;\n    }\n\n    /**\n     * Encodes a Uniform Resource Identifier (URI) by replacing non-alphanumeric\n     * characters with a percent (%) sign followed by two hex digits, excepting\n     * characters in the URI reserved character set.\n     *\n     * Assumes that the URI is a complete URI, so does not encode reserved\n     * characters that have special meaning in the URI.\n     *\n     * Simulates the encodeURI function available in JavaScript\n     * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/encodeURI\n     *\n     * Source: http://stackoverflow.com/q/4929584/264628\n     *\n     * @param string $uri The URI to encode\n     * @return string The original URL with special characters encoded\n     */\n    public static function encodeURI($uri) {\n        $unescaped = [\n            '%2D'=>'-','%5F'=>'_','%2E'=>'.','%21'=>'!', '%7E'=>'~',\n            '%2A'=>'*', '%27'=>\"'\", '%28'=>'(', '%29'=>')'\n        ];\n        $reserved = [\n            '%3B'=>';','%2C'=>',','%2F'=>'/','%3F'=>'?','%3A'=>':',\n            '%40'=>'@','%26'=>'&','%3D'=>'=','%2B'=>'+','%24'=>'$'\n        ];\n        $score = [\n            '%23'=>'#'\n        ];\n        return strtr(rawurlencode(rawurldecode($uri)), array_merge($reserved, $unescaped, $score));\n    }\n\n    /**\n     * Decoder for RLE8 compression in windows bitmaps\n     * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_6x0u.asp\n     *\n     * @param string $str Data to decode\n     * @param int $width Image width\n     *\n     * @return string\n     */\n    public static function rle8_decode($str, $width)\n    {\n        $lineWidth = $width + (3 - ($width - 1) % 4);\n        $out = '';\n        $cnt = strlen($str);\n\n        for ($i = 0; $i < $cnt; $i++) {\n            $o = ord($str[$i]);\n            switch ($o) {\n                case 0: # ESCAPE\n                    $i++;\n                    switch (ord($str[$i])) {\n                        case 0: # NEW LINE\n                            $padCnt = $lineWidth - strlen($out) % $lineWidth;\n                            if ($padCnt < $lineWidth) {\n                                $out .= str_repeat(chr(0), $padCnt); # pad line\n                            }\n                            break;\n                        case 1: # END OF FILE\n                            $padCnt = $lineWidth - strlen($out) % $lineWidth;\n                            if ($padCnt < $lineWidth) {\n                                $out .= str_repeat(chr(0), $padCnt); # pad line\n                            }\n                            break 3;\n                        case 2: # DELTA\n                            $i += 2;\n                            break;\n                        default: # ABSOLUTE MODE\n                            $num = ord($str[$i]);\n                            for ($j = 0; $j < $num; $j++) {\n                                $out .= $str[++$i];\n                            }\n                            if ($num % 2) {\n                                $i++;\n                            }\n                    }\n                    break;\n                default:\n                    $out .= str_repeat($str[++$i], $o);\n            }\n        }\n        return $out;\n    }\n\n    /**\n     * Decoder for RLE4 compression in windows bitmaps\n     * see http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_6x0u.asp\n     *\n     * @param string $str Data to decode\n     * @param int $width Image width\n     *\n     * @return string\n     */\n    public static function rle4_decode($str, $width)\n    {\n        $w = floor($width / 2) + ($width % 2);\n        $lineWidth = $w + (3 - (($width - 1) / 2) % 4);\n        $pixels = [];\n        $cnt = strlen($str);\n        $c = 0;\n\n        for ($i = 0; $i < $cnt; $i++) {\n            $o = ord($str[$i]);\n            switch ($o) {\n                case 0: # ESCAPE\n                    $i++;\n                    switch (ord($str[$i])) {\n                        case 0: # NEW LINE\n                            while (count($pixels) % $lineWidth != 0) {\n                                $pixels[] = 0;\n                            }\n                            break;\n                        case 1: # END OF FILE\n                            while (count($pixels) % $lineWidth != 0) {\n                                $pixels[] = 0;\n                            }\n                            break 3;\n                        case 2: # DELTA\n                            $i += 2;\n                            break;\n                        default: # ABSOLUTE MODE\n                            $num = ord($str[$i]);\n                            for ($j = 0; $j < $num; $j++) {\n                                if ($j % 2 == 0) {\n                                    $c = ord($str[++$i]);\n                                    $pixels[] = ($c & 240) >> 4;\n                                } else {\n                                    $pixels[] = $c & 15;\n                                }\n                            }\n\n                            if ($num % 2 == 0) {\n                                $i++;\n                            }\n                    }\n                    break;\n                default:\n                    $c = ord($str[++$i]);\n                    for ($j = 0; $j < $o; $j++) {\n                        $pixels[] = ($j % 2 == 0 ? ($c & 240) >> 4 : $c & 15);\n                    }\n            }\n        }\n\n        $out = '';\n        if (count($pixels) % 2) {\n            $pixels[] = 0;\n        }\n\n        $cnt = count($pixels) / 2;\n\n        for ($i = 0; $i < $cnt; $i++) {\n            $out .= chr(16 * $pixels[2 * $i] + $pixels[2 * $i + 1]);\n        }\n\n        return $out;\n    }\n\n    /**\n     * parse a full url or pathname and return an array(protocol, host, path,\n     * file + query + fragment)\n     *\n     * @param string $url\n     * @return array\n     */\n    public static function explode_url($url)\n    {\n        $protocol = \"\";\n        $host = \"\";\n        $path = \"\";\n        $file = \"\";\n\n        $arr = parse_url($url);\n        if ( isset($arr[\"scheme\"]) ) {\n            $arr[\"scheme\"] = mb_strtolower($arr[\"scheme\"]);\n        }\n\n        // Exclude windows drive letters...\n        if (isset($arr[\"scheme\"]) && $arr[\"scheme\"] !== \"file\" && strlen($arr[\"scheme\"]) > 1) {\n            $protocol = $arr[\"scheme\"] . \"://\";\n\n            if (isset($arr[\"user\"])) {\n                $host .= $arr[\"user\"];\n\n                if (isset($arr[\"pass\"])) {\n                    $host .= \":\" . $arr[\"pass\"];\n                }\n\n                $host .= \"@\";\n            }\n\n            if (isset($arr[\"host\"])) {\n                $host .= $arr[\"host\"];\n            }\n\n            if (isset($arr[\"port\"])) {\n                $host .= \":\" . $arr[\"port\"];\n            }\n\n            if (isset($arr[\"path\"]) && $arr[\"path\"] !== \"\") {\n                // Do we have a trailing slash?\n                if ($arr[\"path\"][mb_strlen($arr[\"path\"]) - 1] === \"/\") {\n                    $path = $arr[\"path\"];\n                    $file = \"\";\n                } else {\n                    $path = rtrim(dirname($arr[\"path\"]), '/\\\\') . \"/\";\n                    $file = basename($arr[\"path\"]);\n                }\n            }\n\n            if (isset($arr[\"query\"])) {\n                $file .= \"?\" . $arr[\"query\"];\n            }\n\n            if (isset($arr[\"fragment\"])) {\n                $file .= \"#\" . $arr[\"fragment\"];\n            }\n\n        } else {\n\n            $i = mb_stripos($url, \"file://\");\n            if ($i !== false) {\n                $url = mb_substr($url, $i + 7);\n            }\n\n            $protocol = \"\"; // \"file://\"; ? why doesn't this work... It's because of\n            // network filenames like //COMPU/SHARENAME\n\n            $host = \"\"; // localhost, really\n            $file = basename($url);\n\n            $path = dirname($url);\n\n            // Check that the path exists\n            if ($path !== false) {\n                $path .= '/';\n\n            } else {\n                // generate a url to access the file if no real path found.\n                $protocol = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? 'https://' : 'http://';\n\n                $host = isset($_SERVER[\"HTTP_HOST\"]) ? $_SERVER[\"HTTP_HOST\"] : php_uname(\"n\");\n\n                if (substr($arr[\"path\"], 0, 1) === '/') {\n                    $path = dirname($arr[\"path\"]);\n                } else {\n                    $path = '/' . rtrim(dirname($_SERVER[\"SCRIPT_NAME\"]), '/') . '/' . $arr[\"path\"];\n                }\n            }\n        }\n\n        $ret = [$protocol, $host, $path, $file,\n            \"protocol\" => $protocol,\n            \"host\" => $host,\n            \"path\" => $path,\n            \"file\" => $file];\n        return $ret;\n    }\n\n    /**\n     * Print debug messages\n     *\n     * @param string $type The type of debug messages to print\n     * @param string $msg The message to show\n     */\n    public static function dompdf_debug($type, $msg)\n    {\n        global $_DOMPDF_DEBUG_TYPES, $_dompdf_show_warnings, $_dompdf_debug;\n        if (isset($_DOMPDF_DEBUG_TYPES[$type]) && ($_dompdf_show_warnings || $_dompdf_debug)) {\n            $arr = debug_backtrace();\n\n            echo basename($arr[0][\"file\"]) . \" (\" . $arr[0][\"line\"] . \"): \" . $arr[1][\"function\"] . \": \";\n            Helpers::pre_r($msg);\n        }\n    }\n\n    /**\n     * Stores warnings in an array for display later\n     * This function allows warnings generated by the DomDocument parser\n     * and CSS loader ({@link Stylesheet}) to be captured and displayed\n     * later.  Without this function, errors are displayed immediately and\n     * PDF streaming is impossible.\n     * @see http://www.php.net/manual/en/function.set-error_handler.php\n     *\n     * @param int $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param string $errline\n     *\n     * @throws Exception\n     */\n    public static function record_warnings($errno, $errstr, $errfile, $errline)\n    {\n        // Not a warning or notice\n        if (!($errno & (E_WARNING | E_NOTICE | E_USER_NOTICE | E_USER_WARNING | E_STRICT | E_DEPRECATED | E_USER_DEPRECATED))) {\n            throw new Exception($errstr . \" $errno\");\n        }\n\n        global $_dompdf_warnings;\n        global $_dompdf_show_warnings;\n\n        if ($_dompdf_show_warnings) {\n            echo $errstr . \"\\n\";\n        }\n\n        $_dompdf_warnings[] = $errstr;\n    }\n\n    /**\n     * @param $c\n     * @return bool|string\n     */\n    public static function unichr($c)\n    {\n        if ($c <= 0x7F) {\n            return chr($c);\n        } else if ($c <= 0x7FF) {\n            return chr(0xC0 | $c >> 6) . chr(0x80 | $c & 0x3F);\n        } else if ($c <= 0xFFFF) {\n            return chr(0xE0 | $c >> 12) . chr(0x80 | $c >> 6 & 0x3F)\n            . chr(0x80 | $c & 0x3F);\n        } else if ($c <= 0x10FFFF) {\n            return chr(0xF0 | $c >> 18) . chr(0x80 | $c >> 12 & 0x3F)\n            . chr(0x80 | $c >> 6 & 0x3F)\n            . chr(0x80 | $c & 0x3F);\n        }\n        return false;\n    }\n\n    /**\n     * Converts a CMYK color to RGB\n     *\n     * @param float|float[] $c\n     * @param float $m\n     * @param float $y\n     * @param float $k\n     *\n     * @return float[]\n     */\n    public static function cmyk_to_rgb($c, $m = null, $y = null, $k = null)\n    {\n        if (is_array($c)) {\n            [$c, $m, $y, $k] = $c;\n        }\n\n        $c *= 255;\n        $m *= 255;\n        $y *= 255;\n        $k *= 255;\n\n        $r = (1 - round(2.55 * ($c + $k)));\n        $g = (1 - round(2.55 * ($m + $k)));\n        $b = (1 - round(2.55 * ($y + $k)));\n\n        if ($r < 0) {\n            $r = 0;\n        }\n        if ($g < 0) {\n            $g = 0;\n        }\n        if ($b < 0) {\n            $b = 0;\n        }\n\n        return [\n            $r, $g, $b,\n            \"r\" => $r, \"g\" => $g, \"b\" => $b\n        ];\n    }\n\n    /**\n     * getimagesize doesn't give a good size for 32bit BMP image v5\n     *\n     * @param string $filename\n     * @param resource $context\n     * @return array An array of three elements: width and height as\n     *         `float|int`, and image type as `string|null`.\n     */\n    public static function dompdf_getimagesize($filename, $context = null)\n    {\n        static $cache = [];\n\n        if (isset($cache[$filename])) {\n            return $cache[$filename];\n        }\n\n        [$width, $height, $type] = getimagesize($filename);\n\n        // Custom types\n        $types = [\n            IMAGETYPE_JPEG => \"jpeg\",\n            IMAGETYPE_GIF  => \"gif\",\n            IMAGETYPE_BMP  => \"bmp\",\n            IMAGETYPE_PNG  => \"png\",\n            IMAGETYPE_WEBP => \"webp\",\n        ];\n\n        $type = $types[$type] ?? null;\n\n        if ($width == null || $height == null) {\n            [$data] = Helpers::getFileContent($filename, $context);\n\n            if ($data !== null) {\n                if (substr($data, 0, 2) === \"BM\") {\n                    $meta = unpack(\"vtype/Vfilesize/Vreserved/Voffset/Vheadersize/Vwidth/Vheight\", $data);\n                    $width = (int) $meta[\"width\"];\n                    $height = (int) $meta[\"height\"];\n                    $type = \"bmp\";\n                } elseif (strpos($data, \"<svg\") !== false) {\n                    $doc = new \\Svg\\Document();\n                    $doc->loadFile($filename);\n\n                    [$width, $height] = $doc->getDimensions();\n                    $width = (float) $width;\n                    $height = (float) $height;\n                    $type = \"svg\";\n                }\n            }\n        }\n\n        return $cache[$filename] = [$width ?? 0, $height ?? 0, $type];\n    }\n\n    /**\n     * Credit goes to mgutt\n     * http://www.programmierer-forum.de/function-imagecreatefrombmp-welche-variante-laeuft-t143137.htm\n     * Modified by Fabien Menager to support RGB555 BMP format\n     */\n    public static function imagecreatefrombmp($filename, $context = null)\n    {\n        if (!function_exists(\"imagecreatetruecolor\")) {\n            trigger_error(\"The PHP GD extension is required, but is not installed.\", E_ERROR);\n            return false;\n        }\n\n        // version 1.00\n        if (!($fh = fopen($filename, 'rb'))) {\n            trigger_error('imagecreatefrombmp: Can not open ' . $filename, E_USER_WARNING);\n            return false;\n        }\n\n        $bytes_read = 0;\n\n        // read file header\n        $meta = unpack('vtype/Vfilesize/Vreserved/Voffset', fread($fh, 14));\n\n        // check for bitmap\n        if ($meta['type'] != 19778) {\n            trigger_error('imagecreatefrombmp: ' . $filename . ' is not a bitmap!', E_USER_WARNING);\n            return false;\n        }\n\n        // read image header\n        $meta += unpack('Vheadersize/Vwidth/Vheight/vplanes/vbits/Vcompression/Vimagesize/Vxres/Vyres/Vcolors/Vimportant', fread($fh, 40));\n        $bytes_read += 40;\n\n        // read additional bitfield header\n        if ($meta['compression'] == 3) {\n            $meta += unpack('VrMask/VgMask/VbMask', fread($fh, 12));\n            $bytes_read += 12;\n        }\n\n        // set bytes and padding\n        $meta['bytes'] = $meta['bits'] / 8;\n        $meta['decal'] = 4 - (4 * (($meta['width'] * $meta['bytes'] / 4) - floor($meta['width'] * $meta['bytes'] / 4)));\n        if ($meta['decal'] == 4) {\n            $meta['decal'] = 0;\n        }\n\n        // obtain imagesize\n        if ($meta['imagesize'] < 1) {\n            $meta['imagesize'] = $meta['filesize'] - $meta['offset'];\n            // in rare cases filesize is equal to offset so we need to read physical size\n            if ($meta['imagesize'] < 1) {\n                $meta['imagesize'] = @filesize($filename) - $meta['offset'];\n                if ($meta['imagesize'] < 1) {\n                    trigger_error('imagecreatefrombmp: Can not obtain filesize of ' . $filename . '!', E_USER_WARNING);\n                    return false;\n                }\n            }\n        }\n\n        // calculate colors\n        $meta['colors'] = !$meta['colors'] ? pow(2, $meta['bits']) : $meta['colors'];\n\n        // read color palette\n        $palette = [];\n        if ($meta['bits'] < 16) {\n            $palette = unpack('l' . $meta['colors'], fread($fh, $meta['colors'] * 4));\n            // in rare cases the color value is signed\n            if ($palette[1] < 0) {\n                foreach ($palette as $i => $color) {\n                    $palette[$i] = $color + 16777216;\n                }\n            }\n        }\n\n        // ignore extra bitmap headers\n        if ($meta['headersize'] > $bytes_read) {\n            fread($fh, $meta['headersize'] - $bytes_read);\n        }\n\n        // create gd image\n        $im = imagecreatetruecolor($meta['width'], $meta['height']);\n        $data = fread($fh, $meta['imagesize']);\n\n        // uncompress data\n        switch ($meta['compression']) {\n            case 1:\n                $data = Helpers::rle8_decode($data, $meta['width']);\n                break;\n            case 2:\n                $data = Helpers::rle4_decode($data, $meta['width']);\n                break;\n        }\n\n        $p = 0;\n        $vide = chr(0);\n        $y = $meta['height'] - 1;\n        $error = 'imagecreatefrombmp: ' . $filename . ' has not enough data!';\n\n        // loop through the image data beginning with the lower left corner\n        while ($y >= 0) {\n            $x = 0;\n            while ($x < $meta['width']) {\n                switch ($meta['bits']) {\n                    case 32:\n                    case 24:\n                        if (!($part = substr($data, $p, 3 /*$meta['bytes']*/))) {\n                            trigger_error($error, E_USER_WARNING);\n                            return $im;\n                        }\n                        $color = unpack('V', $part . $vide);\n                        break;\n                    case 16:\n                        if (!($part = substr($data, $p, 2 /*$meta['bytes']*/))) {\n                            trigger_error($error, E_USER_WARNING);\n                            return $im;\n                        }\n                        $color = unpack('v', $part);\n\n                        if (empty($meta['rMask']) || $meta['rMask'] != 0xf800) {\n                            $color[1] = (($color[1] & 0x7c00) >> 7) * 65536 + (($color[1] & 0x03e0) >> 2) * 256 + (($color[1] & 0x001f) << 3); // 555\n                        } else {\n                            $color[1] = (($color[1] & 0xf800) >> 8) * 65536 + (($color[1] & 0x07e0) >> 3) * 256 + (($color[1] & 0x001f) << 3); // 565\n                        }\n                        break;\n                    case 8:\n                        $color = unpack('n', $vide . substr($data, $p, 1));\n                        $color[1] = $palette[$color[1] + 1];\n                        break;\n                    case 4:\n                        $color = unpack('n', $vide . substr($data, floor($p), 1));\n                        $color[1] = ($p * 2) % 2 == 0 ? $color[1] >> 4 : $color[1] & 0x0F;\n                        $color[1] = $palette[$color[1] + 1];\n                        break;\n                    case 1:\n                        $color = unpack('n', $vide . substr($data, floor($p), 1));\n                        switch (($p * 8) % 8) {\n                            case 0:\n                                $color[1] = $color[1] >> 7;\n                                break;\n                            case 1:\n                                $color[1] = ($color[1] & 0x40) >> 6;\n                                break;\n                            case 2:\n                                $color[1] = ($color[1] & 0x20) >> 5;\n                                break;\n                            case 3:\n                                $color[1] = ($color[1] & 0x10) >> 4;\n                                break;\n                            case 4:\n                                $color[1] = ($color[1] & 0x8) >> 3;\n                                break;\n                            case 5:\n                                $color[1] = ($color[1] & 0x4) >> 2;\n                                break;\n                            case 6:\n                                $color[1] = ($color[1] & 0x2) >> 1;\n                                break;\n                            case 7:\n                                $color[1] = ($color[1] & 0x1);\n                                break;\n                        }\n                        $color[1] = $palette[$color[1] + 1];\n                        break;\n                    default:\n                        trigger_error('imagecreatefrombmp: ' . $filename . ' has ' . $meta['bits'] . ' bits and this is not supported!', E_USER_WARNING);\n                        return false;\n                }\n                imagesetpixel($im, $x, $y, $color[1]);\n                $x++;\n                $p += $meta['bytes'];\n            }\n            $y--;\n            $p += $meta['decal'];\n        }\n        fclose($fh);\n        return $im;\n    }\n\n    /**\n     * Gets the content of the file at the specified path using one of\n     * the following methods, in preferential order:\n     *  - file_get_contents: if allow_url_fopen is true or the file is local\n     *  - curl: if allow_url_fopen is false and curl is available\n     *\n     * @param string $uri\n     * @param resource $context\n     * @param int $offset\n     * @param int $maxlen\n     * @return string[]\n     */\n    public static function getFileContent($uri, $context = null, $offset = 0, $maxlen = null)\n    {\n        $content = null;\n        $headers = null;\n        [$protocol] = Helpers::explode_url($uri);\n        $is_local_path = ($protocol === \"\" || $protocol === \"file://\");\n\n        set_error_handler([self::class, 'record_warnings']);\n\n        try {\n            if ($is_local_path || ini_get('allow_url_fopen')) {\n                if ($is_local_path === false) {\n                    $uri = Helpers::encodeURI($uri);\n                }\n                if (isset($maxlen)) {\n                    $result = file_get_contents($uri, false, $context, $offset, $maxlen);\n                } else {\n                    $result = file_get_contents($uri, false, $context, $offset);\n                }\n                if ($result !== false) {\n                    $content = $result;\n                }\n                if (isset($http_response_header)) {\n                    $headers = $http_response_header;\n                }\n\n            } elseif (function_exists('curl_exec')) {\n                $curl = curl_init($uri);\n\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n                curl_setopt($curl, CURLOPT_HEADER, true);\n                if ($offset > 0) {\n                    curl_setopt($curl, CURLOPT_RESUME_FROM, $offset);\n                }\n\n                if ($maxlen > 0) {\n                    curl_setopt($curl, CURLOPT_BUFFERSIZE, 128);\n                    curl_setopt($curl, CURLOPT_NOPROGRESS, false);\n                    curl_setopt($curl, CURLOPT_PROGRESSFUNCTION, function ($res, $download_size_total, $download_size, $upload_size_total, $upload_size) use ($maxlen) {\n                        return ($download_size > $maxlen) ? 1 : 0;\n                    });\n                }\n\n                $context_options = [];\n                if (!is_null($context)) {\n                    $context_options = stream_context_get_options($context);\n                }\n                foreach ($context_options as $stream => $options) {\n                    foreach ($options as $option => $value) {\n                        $key = strtolower($stream) . \":\" . strtolower($option);\n                        switch ($key) {\n                            case \"curl:curl_verify_ssl_host\":\n                                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, !$value ? 0 : 2);\n                                break;\n                            case \"curl:max_redirects\":\n                                curl_setopt($curl, CURLOPT_MAXREDIRS, $value);\n                                break;\n                            case \"http:follow_location\":\n                                curl_setopt($curl, CURLOPT_FOLLOWLOCATION, $value);\n                                break;\n                            case \"http:header\":\n                                if (is_string($value)) {\n                                    curl_setopt($curl, CURLOPT_HTTPHEADER, [$value]);\n                                } else {\n                                    curl_setopt($curl, CURLOPT_HTTPHEADER, $value);\n                                }\n                                break;\n                            case \"http:timeout\":\n                                curl_setopt($curl, CURLOPT_TIMEOUT, $value);\n                                break;\n                            case \"http:user_agent\":\n                                curl_setopt($curl, CURLOPT_USERAGENT, $value);\n                                break;\n                            case \"curl:curl_verify_ssl_peer\":\n                            case \"ssl:verify_peer\":\n                                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, $value);\n                                break;\n                        }\n                    }\n                }\n\n                $data = curl_exec($curl);\n\n                if ($data !== false && !curl_errno($curl)) {\n                    switch ($http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE)) {\n                        case 200:\n                            $raw_headers = substr($data, 0, curl_getinfo($curl, CURLINFO_HEADER_SIZE));\n                            $headers = preg_split(\"/[\\n\\r]+/\", trim($raw_headers));\n                            $content = substr($data, curl_getinfo($curl, CURLINFO_HEADER_SIZE));\n                            break;\n                    }\n                }\n                curl_close($curl);\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        return [$content, $headers];\n    }\n\n    /**\n     * @param string $str\n     * @return string\n     */\n    public static function mb_ucwords(string $str): string\n    {\n        $max_len = mb_strlen($str);\n        if ($max_len === 1) {\n            return mb_strtoupper($str);\n        }\n\n        $str = mb_strtoupper(mb_substr($str, 0, 1)) . mb_substr($str, 1);\n\n        foreach ([' ', '.', ',', '!', '?', '-', '+'] as $s) {\n            $pos = 0;\n            while (($pos = mb_strpos($str, $s, $pos)) !== false) {\n                $pos++;\n                // Nothing to do if the separator is the last char of the string\n                if ($pos !== false && $pos < $max_len) {\n                    // If the char we want to upper is the last char there is nothing to append behind\n                    if ($pos + 1 < $max_len) {\n                        $str = mb_substr($str, 0, $pos) . mb_strtoupper(mb_substr($str, $pos, 1)) . mb_substr($str, $pos + 1);\n                    } else {\n                        $str = mb_substr($str, 0, $pos) . mb_strtoupper(mb_substr($str, $pos, 1));\n                    }\n                }\n            }\n        }\n\n        return $str;\n    }\n\n    /**\n     * Check whether two lengths should be considered equal, accounting for\n     * inaccuracies in float computation.\n     *\n     * The implementation relies on the fact that we are neither dealing with\n     * very large, nor with very small numbers in layout. Adapted from\n     * https://floating-point-gui.de/errors/comparison/.\n     *\n     * @param float $a\n     * @param float $b\n     *\n     * @return bool\n     */\n    public static function lengthEqual(float $a, float $b): bool\n    {\n        // The epsilon results in a precision of at least:\n        // * 7 decimal digits at around 1\n        // * 4 decimal digits at around 1000 (around the size of common paper formats)\n        // * 2 decimal digits at around 100,000 (100,000pt ~ 35.28m)\n        static $epsilon = 1e-8;\n        static $almostZero = 1e-12;\n\n        $diff = abs($a - $b);\n\n        if ($a === $b || $diff < $almostZero) {\n            return true;\n        }\n\n        return $diff < $epsilon * max(abs($a), abs($b));\n    }\n\n    /**\n     * Check `$a < $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthLess(float $a, float $b): bool\n    {\n        return $a < $b && !self::lengthEqual($a, $b);\n    }\n\n    /**\n     * Check `$a <= $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthLessOrEqual(float $a, float $b): bool\n    {\n        return $a <= $b || self::lengthEqual($a, $b);\n    }\n\n    /**\n     * Check `$a > $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthGreater(float $a, float $b): bool\n    {\n        return $a > $b && !self::lengthEqual($a, $b);\n    }\n\n    /**\n     * Check `$a >= $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthGreaterOrEqual(float $a, float $b): bool\n    {\n        return $a >= $b || self::lengthEqual($a, $b);\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Image;\n\nuse Dompdf\\Dompdf;\nuse Dompdf\\Helpers;\nuse Dompdf\\Exception\\ImageException;\n\n/**\n * Static class that resolves image urls and downloads and caches\n * remote images if required.\n *\n * @package dompdf\n */\nclass Cache\n{\n    /**\n     * Array of downloaded images.  Cached so that identical images are\n     * not needlessly downloaded.\n     *\n     * @var array\n     */\n    protected static $_cache = [];\n\n    /**\n     * @var array\n     */\n    protected static $tempImages = [];\n\n    /**\n     * The url to the \"broken image\" used when images can't be loaded\n     *\n     * @var string\n     */\n    public static $broken_image = \"data:image/svg+xml;charset=utf8,%3C?xml version='1.0'?%3E%3Csvg width='64' height='64' xmlns='http://www.w3.org/2000/svg'%3E%3Cg%3E%3Crect stroke='%23666666' id='svg_1' height='60.499994' width='60.166667' y='1.666669' x='1.999998' stroke-width='1.5' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_3' y2='59.333253' x2='59.749916' y1='4.333415' x1='4.250079' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_4' y2='59.999665' x2='4.062838' y1='3.750342' x1='60.062164' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3C/g%3E%3C/svg%3E\";\n\n    public static $error_message = \"Image not found or type unknown\";\n    \n    /**\n     * Current dompdf instance\n     *\n     * @var Dompdf\n     */\n    protected static $_dompdf;\n\n    /**\n     * Resolve and fetch an image for use.\n     *\n     * @param string $url       The url of the image\n     * @param string $protocol  Default protocol if none specified in $url\n     * @param string $host      Default host if none specified in $url\n     * @param string $base_path Default path if none specified in $url\n     * @param Dompdf $dompdf    The Dompdf instance\n     *\n     * @throws ImageException\n     * @return array             An array with two elements: The local path to the image and the image extension\n     */\n    static function resolve_url($url, $protocol, $host, $base_path, Dompdf $dompdf)\n    {\n        self::$_dompdf = $dompdf;\n        \n        $protocol = mb_strtolower($protocol);\n        $parsed_url = Helpers::explode_url($url);\n        $message = null;\n\n        $remote = ($protocol && $protocol !== \"file://\") || ($parsed_url['protocol'] !== \"\");\n\n        $data_uri = strpos($parsed_url['protocol'], \"data:\") === 0;\n        $full_url = null;\n        $enable_remote = $dompdf->getOptions()->getIsRemoteEnabled();\n        $tempfile = false;\n\n        try {\n\n            // Remote not allowed and is not DataURI\n            if (!$enable_remote && $remote && !$data_uri) {\n                throw new ImageException(\"Remote file access is disabled.\", E_WARNING);\n            }\n            \n            // remote allowed or DataURI\n            if (($enable_remote && $remote) || $data_uri) {\n                // Download remote files to a temporary directory\n                $full_url = Helpers::build_url($protocol, $host, $base_path, $url);\n\n                // From cache\n                if (isset(self::$_cache[$full_url])) {\n                    $resolved_url = self::$_cache[$full_url];\n                } // From remote\n                else {\n                    $tmp_dir = $dompdf->getOptions()->getTempDir();\n                    if (($resolved_url = @tempnam($tmp_dir, \"ca_dompdf_img_\")) === false) {\n                        throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                    }\n                    $tempfile = $resolved_url;\n                    $image = null;\n\n                    if ($data_uri) {\n                        if ($parsed_data_uri = Helpers::parse_data_uri($url)) {\n                            $image = $parsed_data_uri['data'];\n                        }\n                    } else {\n                        list($image, $http_response_header) = Helpers::getFileContent($full_url, $dompdf->getHttpContext());\n                    }\n\n                    // Image not found or invalid\n                    if ($image === null) {\n                        $msg = ($data_uri ? \"Data-URI could not be parsed\" : \"Image not found\");\n                        throw new ImageException($msg, E_WARNING);\n                    } // Image found, put in cache and process\n                    else {\n                        //e.g. fetch.php?media=url.jpg&cache=1\n                        //- Image file name might be one of the dynamic parts of the url, don't strip off!\n                        //- a remote url does not need to have a file extension at all\n                        //- local cached file does not have a matching file extension\n                        //Therefore get image type from the content\n                        if (@file_put_contents($resolved_url, $image) === false) {\n                            throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                        }\n                    }\n                }\n            } // Not remote, local image\n            else {\n                $resolved_url = Helpers::build_url($protocol, $host, $base_path, $url);\n\n                if ($protocol === \"\" || $protocol === \"file://\") {\n                    $realfile = realpath($resolved_url);\n        \n                    $rootDir = realpath($dompdf->getOptions()->getRootDir());\n                    if (strpos($realfile, $rootDir) !== 0) {\n                        $chroot = $dompdf->getOptions()->getChroot();\n                        $chrootValid = false;\n                        foreach ($chroot as $chrootPath) {\n                            $chrootPath = realpath($chrootPath);\n                            if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                                $chrootValid = true;\n                                break;\n                            }\n                        }\n                        if ($chrootValid !== true) {\n                            throw new ImageException(\"Permission denied on $resolved_url. The file could not be found under the paths specified by Options::chroot.\", E_WARNING);\n                        }\n                    }\n        \n                    if (!$realfile) {\n                        throw new ImageException(\"File '$realfile' not found.\", E_WARNING);\n                    }\n        \n                    $resolved_url = $realfile;\n                }\n            }\n\n            // Check if the local file is readable\n            if (!is_readable($resolved_url) || !filesize($resolved_url)) {\n                throw new ImageException(\"Image not readable or empty\", E_WARNING);\n            } // Check is the file is an image\n            else {\n                list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $dompdf->getHttpContext());\n\n                // Known image type\n                if ($width && $height && in_array($type, [\"gif\", \"png\", \"jpeg\", \"bmp\", \"svg\",\"webp\"], true)) {\n                    //Don't put replacement image into cache - otherwise it will be deleted on cache cleanup.\n                    //Only execute on successful caching of remote image.\n                    if ($enable_remote && $remote || $data_uri) {\n                        self::$_cache[$full_url] = $resolved_url;\n                    }\n                } // Unknown image type\n                else {\n                    throw new ImageException(\"Image type unknown\", E_WARNING);\n                }\n            }\n        } catch (ImageException $e) {\n            if ($tempfile) {\n                unlink($tempfile);\n            }\n            $resolved_url = self::$broken_image;\n            $type = \"png\";\n            $message = self::$error_message;\n            Helpers::record_warnings($e->getCode(), $e->getMessage() . \" \\n $url\", $e->getFile(), $e->getLine());\n            self::$_cache[$full_url] = $resolved_url;\n        }\n\n        return [$resolved_url, $type, $message];\n    }\n\n    /**\n     * Register a temp file for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $tempPath The path of the temp file to register.\n     * @param string $key      An optional key to register the temp file at.\n     */\n    static function addTempImage(string $filePath, string $tempPath, string $key = \"default\"): void\n    {\n        if (!isset(self::$tempImages[$filePath])) {\n            self::$tempImages[$filePath] = [];\n        }\n\n        self::$tempImages[$filePath][$key] = $tempPath;\n    }\n\n    /**\n     * Get the path of a temp file registered for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $key      The key the temp file is registered at.\n     */\n    static function getTempImage(string $filePath, string $key = \"default\"): ?string\n    {\n        return self::$tempImages[$filePath][$key] ?? null;\n    }\n\n    /**\n     * Unlink all cached images (i.e. temporary images either downloaded\n     * or converted) except for the bundled \"broken image\"\n     */\n    static function clear(bool $debugPng = false)\n    {\n        foreach (self::$_cache as $file) {\n            if ($file === self::$broken_image) {\n                continue;\n            }\n            if ($debugPng) {\n                print \"[clear unlink $file]\";\n            }\n            unlink($file);\n        }\n\n        foreach (self::$tempImages as $versions) {\n            foreach ($versions as $file) {\n                if ($file === self::$broken_image) {\n                    continue;\n                }\n                if ($debugPng) {\n                    print \"[unlink temp image $file]\";\n                }\n                if (file_exists($file)) {\n                    unlink($file);\n                }\n            }\n        }\n\n        self::$_cache = [];\n        self::$tempImages = [];\n    }\n\n    static function detect_type($file, $context = null)\n    {\n        list(, , $type) = Helpers::dompdf_getimagesize($file, $context);\n\n        return $type;\n    }\n\n    static function is_broken($url)\n    {\n        return $url === self::$broken_image;\n    }\n}\n\nif (file_exists(realpath(__DIR__ . \"/../../lib/res/broken_image.svg\"))) {\n    Cache::$broken_image = realpath(__DIR__ . \"/../../lib/res/broken_image.svg\");\n}\n", "<?php\nnamespace Dompdf;\n\nclass Options\n{\n    /**\n     * The root of your DOMPDF installation\n     *\n     * @var string\n     */\n    private $rootDir;\n\n    /**\n     * The location of a temporary directory.\n     *\n     * The directory specified must be writable by the webserver process.\n     * The temporary directory is required to download remote images and when\n     * using the PFDLib back end.\n     *\n     * @var string\n     */\n    private $tempDir;\n\n    /**\n     * The location of the DOMPDF font directory\n     *\n     * The location of the directory where DOMPDF will store fonts and font metrics\n     * Note: This directory must exist and be writable by the webserver process.\n     *\n     * @var string\n     */\n    private $fontDir;\n\n    /**\n     * The location of the DOMPDF font cache directory\n     *\n     * This directory contains the cached font metrics for the fonts used by DOMPDF.\n     * This directory can be the same as $fontDir\n     *\n     * Note: This directory must exist and be writable by the webserver process.\n     *\n     * @var string\n     */\n    private $fontCache;\n\n    /**\n     * dompdf's \"chroot\"\n     *\n     * Prevents dompdf from accessing system files or other files on the webserver.\n     * All local files opened by dompdf must be in a subdirectory of this directory\n     * or array of directories.\n     * DO NOT set it to '/' since this could allow an attacker to use dompdf to\n     * read any files on the server.  This should be an absolute path.\n     *\n     * ==== IMPORTANT ====\n     * This setting may increase the risk of system exploit. Do not change\n     * this settings without understanding the consequences. Additional\n     * documentation is available on the dompdf wiki at:\n     * https://github.com/dompdf/dompdf/wiki\n     *\n     * @var array\n     */\n    private $chroot;\n\n    /**\n     * @var string\n     */\n    private $logOutputFile;\n\n    /**\n     * html target media view which should be rendered into pdf.\n     * List of types and parsing rules for future extensions:\n     * http://www.w3.org/TR/REC-html40/types.html\n     *   screen, tty, tv, projection, handheld, print, braille, aural, all\n     * Note: aural is deprecated in CSS 2.1 because it is replaced by speech in CSS 3.\n     * Note, even though the generated pdf file is intended for print output,\n     * the desired content might be different (e.g. screen or projection view of html file).\n     * Therefore allow specification of content here.\n     *\n     * @var string\n     */\n    private $defaultMediaType = \"screen\";\n\n    /**\n     * The default paper size.\n     *\n     * North America standard is \"letter\"; other countries generally \"a4\"\n     * @see \\Dompdf\\Adapter\\CPDF::PAPER_SIZES for valid sizes\n     *\n     * @var string\n     */\n    private $defaultPaperSize = \"letter\";\n\n    /**\n     * The default paper orientation.\n     *\n     * The orientation of the page (portrait or landscape).\n     *\n     * @var string\n     */\n    private $defaultPaperOrientation = \"portrait\";\n\n    /**\n     * The default font family\n     *\n     * Used if no suitable fonts can be found. This must exist in the font folder.\n     *\n     * @var string\n     */\n    private $defaultFont = \"serif\";\n\n    /**\n     * Image DPI setting\n     *\n     * This setting determines the default DPI setting for images and fonts.  The\n     * DPI may be overridden for inline images by explicitly setting the\n     * image's width & height style attributes (i.e. if the image's native\n     * width is 600 pixels and you specify the image's width as 72 points,\n     * the image will have a DPI of 600 in the rendered PDF.  The DPI of\n     * background images can not be overridden and is controlled entirely\n     * via this parameter.\n     *\n     * For the purposes of DOMPDF, pixels per inch (PPI) = dots per inch (DPI).\n     * If a size in html is given as px (or without unit as image size),\n     * this tells the corresponding size in pt at 72 DPI.\n     * This adjusts the relative sizes to be similar to the rendering of the\n     * html page in a reference browser.\n     *\n     * In pdf, always 1 pt = 1/72 inch\n     *\n     * @var int\n     */\n    private $dpi = 96;\n\n    /**\n     * A ratio applied to the fonts height to be more like browsers' line height\n     *\n     * @var float\n     */\n    private $fontHeightRatio = 1.1;\n\n    /**\n     * Enable embedded PHP\n     *\n     * If this setting is set to true then DOMPDF will automatically evaluate\n     * embedded PHP contained within <script type=\"text/php\"> ... </script> tags.\n     *\n     * ==== IMPORTANT ====\n     * Enabling this for documents you do not trust (e.g. arbitrary remote html\n     * pages) is a security risk. Embedded scripts are run with the same level of\n     * system access available to dompdf. Set this option to false (recommended)\n     * if you wish to process untrusted documents.\n     *\n     * This setting may increase the risk of system exploit. Do not change\n     * this settings without understanding the consequences. Additional\n     * documentation is available on the dompdf wiki at:\n     * https://github.com/dompdf/dompdf/wiki\n     *\n     * @var bool\n     */\n    private $isPhpEnabled = false;\n\n    /**\n     * Enable remote file access\n     *\n     * If this setting is set to true, DOMPDF will access remote sites for\n     * images and CSS files as required.\n     *\n     * ==== IMPORTANT ====\n     * This can be a security risk, in particular in combination with isPhpEnabled and\n     * allowing remote html code to be passed to $dompdf = new DOMPDF(); $dompdf->load_html(...);\n     * This allows anonymous users to download legally doubtful internet content which on\n     * tracing back appears to being downloaded by your server, or allows malicious php code\n     * in remote html pages to be executed by your server with your account privileges.\n     *\n     * This setting may increase the risk of system exploit. Do not change\n     * this settings without understanding the consequences. Additional\n     * documentation is available on the dompdf wiki at:\n     * https://github.com/dompdf/dompdf/wiki\n     *\n     * @var bool\n     */\n    private $isRemoteEnabled = false;\n\n    /**\n     * Enable inline Javascript\n     *\n     * If this setting is set to true then DOMPDF will automatically insert\n     * JavaScript code contained within <script type=\"text/javascript\"> ... </script> tags.\n     *\n     * @var bool\n     */\n    private $isJavascriptEnabled = true;\n\n    /**\n     * Use the HTML5 Lib parser\n     *\n     * @deprecated\n     * @var bool\n     */\n    private $isHtml5ParserEnabled = true;\n\n    /**\n     * Whether to enable font subsetting or not.\n     *\n     * @var bool\n     */\n    private $isFontSubsettingEnabled = true;\n\n    /**\n     * @var bool\n     */\n    private $debugPng = false;\n\n    /**\n     * @var bool\n     */\n    private $debugKeepTemp = false;\n\n    /**\n     * @var bool\n     */\n    private $debugCss = false;\n\n    /**\n     * @var bool\n     */\n    private $debugLayout = false;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutLines = true;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutBlocks = true;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutInline = true;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutPaddingBox = true;\n\n    /**\n     * The PDF rendering backend to use\n     *\n     * Valid settings are 'PDFLib', 'CPDF', 'GD', and 'auto'. 'auto' will\n     * look for PDFLib and use it if found, or if not it will fall back on\n     * CPDF. 'GD' renders PDFs to graphic files. {@link Dompdf\\CanvasFactory}\n     * ultimately determines which rendering class to instantiate\n     * based on this setting.\n     *\n     * @var string\n     */\n    private $pdfBackend = \"CPDF\";\n\n    /**\n     * PDFlib license key\n     *\n     * If you are using a licensed, commercial version of PDFlib, specify\n     * your license key here.  If you are using PDFlib-Lite or are evaluating\n     * the commercial version of PDFlib, comment out this setting.\n     *\n     * @link http://www.pdflib.com\n     *\n     * If pdflib present in web server and auto or selected explicitly above,\n     * a real license code must exist!\n     *\n     * @var string\n     */\n    private $pdflibLicense = \"\";\n\n    /**\n     * HTTP context created with stream_context_create()\n     * Will be used for file_get_contents\n     *\n     * @link https://www.php.net/manual/context.php\n     *\n     * @var resource\n     */\n    private $httpContext;\n\n    /**\n     * @param array $attributes\n     */\n    public function __construct(array $attributes = null)\n    {\n        $rootDir = realpath(__DIR__ . \"/../\");\n        $this->setChroot(array($rootDir));\n        $this->setRootDir($rootDir);\n        $this->setTempDir(sys_get_temp_dir());\n        $this->setFontDir($rootDir . \"/lib/fonts\");\n        $this->setFontCache($this->getFontDir());\n\n        $ver = \"\";\n        $versionFile = realpath(__DIR__ . \"/../VERSION\");\n        if (file_exists($versionFile) && ($version = trim(file_get_contents($versionFile))) !== false && $version !== '$Format:<%h>$') {\n            $ver = \"/$version\";\n        }\n        $this->setHttpContext([\n            \"http\" => [\n                \"follow_location\" => false,\n                \"user_agent\" => \"Dompdf$ver https://github.com/dompdf/dompdf\"\n            ]\n        ]);\n\n        if (null !== $attributes) {\n            $this->set($attributes);\n        }\n    }\n\n    /**\n     * @param array|string $attributes\n     * @param null|mixed $value\n     * @return $this\n     */\n    public function set($attributes, $value = null)\n    {\n        if (!is_array($attributes)) {\n            $attributes = [$attributes => $value];\n        }\n        foreach ($attributes as $key => $value) {\n            if ($key === 'tempDir' || $key === 'temp_dir') {\n                $this->setTempDir($value);\n            } elseif ($key === 'fontDir' || $key === 'font_dir') {\n                $this->setFontDir($value);\n            } elseif ($key === 'fontCache' || $key === 'font_cache') {\n                $this->setFontCache($value);\n            } elseif ($key === 'chroot') {\n                $this->setChroot($value);\n            } elseif ($key === 'logOutputFile' || $key === 'log_output_file') {\n                $this->setLogOutputFile($value);\n            } elseif ($key === 'defaultMediaType' || $key === 'default_media_type') {\n                $this->setDefaultMediaType($value);\n            } elseif ($key === 'defaultPaperSize' || $key === 'default_paper_size') {\n                $this->setDefaultPaperSize($value);\n            } elseif ($key === 'defaultPaperOrientation' || $key === 'default_paper_orientation') {\n                $this->setDefaultPaperOrientation($value);\n            } elseif ($key === 'defaultFont' || $key === 'default_font') {\n                $this->setDefaultFont($value);\n            } elseif ($key === 'dpi') {\n                $this->setDpi($value);\n            } elseif ($key === 'fontHeightRatio' || $key === 'font_height_ratio') {\n                $this->setFontHeightRatio($value);\n            } elseif ($key === 'isPhpEnabled' || $key === 'is_php_enabled' || $key === 'enable_php') {\n                $this->setIsPhpEnabled($value);\n            } elseif ($key === 'isRemoteEnabled' || $key === 'is_remote_enabled' || $key === 'enable_remote') {\n                $this->setIsRemoteEnabled($value);\n            } elseif ($key === 'isJavascriptEnabled' || $key === 'is_javascript_enabled' || $key === 'enable_javascript') {\n                $this->setIsJavascriptEnabled($value);\n            } elseif ($key === 'isHtml5ParserEnabled' || $key === 'is_html5_parser_enabled' || $key === 'enable_html5_parser') {\n                $this->setIsHtml5ParserEnabled($value);\n            } elseif ($key === 'isFontSubsettingEnabled' || $key === 'is_font_subsetting_enabled' || $key === 'enable_font_subsetting') {\n                $this->setIsFontSubsettingEnabled($value);\n            } elseif ($key === 'debugPng' || $key === 'debug_png') {\n                $this->setDebugPng($value);\n            } elseif ($key === 'debugKeepTemp' || $key === 'debug_keep_temp') {\n                $this->setDebugKeepTemp($value);\n            } elseif ($key === 'debugCss' || $key === 'debug_css') {\n                $this->setDebugCss($value);\n            } elseif ($key === 'debugLayout' || $key === 'debug_layout') {\n                $this->setDebugLayout($value);\n            } elseif ($key === 'debugLayoutLines' || $key === 'debug_layout_lines') {\n                $this->setDebugLayoutLines($value);\n            } elseif ($key === 'debugLayoutBlocks' || $key === 'debug_layout_blocks') {\n                $this->setDebugLayoutBlocks($value);\n            } elseif ($key === 'debugLayoutInline' || $key === 'debug_layout_inline') {\n                $this->setDebugLayoutInline($value);\n            } elseif ($key === 'debugLayoutPaddingBox' || $key === 'debug_layout_padding_box') {\n                $this->setDebugLayoutPaddingBox($value);\n            } elseif ($key === 'pdfBackend' || $key === 'pdf_backend') {\n                $this->setPdfBackend($value);\n            } elseif ($key === 'pdflibLicense' || $key === 'pdflib_license') {\n                $this->setPdflibLicense($value);\n            } elseif ($key === 'httpContext' || $key === 'http_context') {\n                $this->setHttpContext($value);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * @param string $key\n     * @return mixed\n     */\n    public function get($key)\n    {\n        if ($key === 'tempDir' || $key === 'temp_dir') {\n            return $this->getTempDir();\n        } elseif ($key === 'fontDir' || $key === 'font_dir') {\n            return $this->getFontDir();\n        } elseif ($key === 'fontCache' || $key === 'font_cache') {\n            return $this->getFontCache();\n        } elseif ($key === 'chroot') {\n            return $this->getChroot();\n        } elseif ($key === 'logOutputFile' || $key === 'log_output_file') {\n            return $this->getLogOutputFile();\n        } elseif ($key === 'defaultMediaType' || $key === 'default_media_type') {\n            return $this->getDefaultMediaType();\n        } elseif ($key === 'defaultPaperSize' || $key === 'default_paper_size') {\n            return $this->getDefaultPaperSize();\n        } elseif ($key === 'defaultPaperOrientation' || $key === 'default_paper_orientation') {\n            return $this->getDefaultPaperOrientation();\n        } elseif ($key === 'defaultFont' || $key === 'default_font') {\n            return $this->getDefaultFont();\n        } elseif ($key === 'dpi') {\n            return $this->getDpi();\n        } elseif ($key === 'fontHeightRatio' || $key === 'font_height_ratio') {\n            return $this->getFontHeightRatio();\n        } elseif ($key === 'isPhpEnabled' || $key === 'is_php_enabled' || $key === 'enable_php') {\n            return $this->getIsPhpEnabled();\n        } elseif ($key === 'isRemoteEnabled' || $key === 'is_remote_enabled' || $key === 'enable_remote') {\n            return $this->getIsRemoteEnabled();\n        } elseif ($key === 'isJavascriptEnabled' || $key === 'is_javascript_enabled' || $key === 'enable_javascript') {\n            return $this->getIsJavascriptEnabled();\n        } elseif ($key === 'isHtml5ParserEnabled' || $key === 'is_html5_parser_enabled' || $key === 'enable_html5_parser') {\n            return $this->getIsHtml5ParserEnabled();\n        } elseif ($key === 'isFontSubsettingEnabled' || $key === 'is_font_subsetting_enabled' || $key === 'enable_font_subsetting') {\n            return $this->getIsFontSubsettingEnabled();\n        } elseif ($key === 'debugPng' || $key === 'debug_png') {\n            return $this->getDebugPng();\n        } elseif ($key === 'debugKeepTemp' || $key === 'debug_keep_temp') {\n            return $this->getDebugKeepTemp();\n        } elseif ($key === 'debugCss' || $key === 'debug_css') {\n            return $this->getDebugCss();\n        } elseif ($key === 'debugLayout' || $key === 'debug_layout') {\n            return $this->getDebugLayout();\n        } elseif ($key === 'debugLayoutLines' || $key === 'debug_layout_lines') {\n            return $this->getDebugLayoutLines();\n        } elseif ($key === 'debugLayoutBlocks' || $key === 'debug_layout_blocks') {\n            return $this->getDebugLayoutBlocks();\n        } elseif ($key === 'debugLayoutInline' || $key === 'debug_layout_inline') {\n            return $this->getDebugLayoutInline();\n        } elseif ($key === 'debugLayoutPaddingBox' || $key === 'debug_layout_padding_box') {\n            return $this->getDebugLayoutPaddingBox();\n        } elseif ($key === 'pdfBackend' || $key === 'pdf_backend') {\n            return $this->getPdfBackend();\n        } elseif ($key === 'pdflibLicense' || $key === 'pdflib_license') {\n            return $this->getPdflibLicense();\n        } elseif ($key === 'httpContext' || $key === 'http_context') {\n            return $this->getHttpContext();\n        }\n        return null;\n    }\n\n    /**\n     * @param string $pdfBackend\n     * @return $this\n     */\n    public function setPdfBackend($pdfBackend)\n    {\n        $this->pdfBackend = $pdfBackend;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getPdfBackend()\n    {\n        return $this->pdfBackend;\n    }\n\n    /**\n     * @param string $pdflibLicense\n     * @return $this\n     */\n    public function setPdflibLicense($pdflibLicense)\n    {\n        $this->pdflibLicense = $pdflibLicense;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getPdflibLicense()\n    {\n        return $this->pdflibLicense;\n    }\n\n    /**\n     * @param array|string $chroot\n     * @return $this\n     */\n    public function setChroot($chroot, $delimiter = ',')\n    {\n        if (is_string($chroot)) {\n            $this->chroot = explode($delimiter, $chroot);\n        } elseif (is_array($chroot)) {\n            $this->chroot = $chroot;\n        }\n        return $this;\n    }\n\n    /**\n     * @return array\n     */\n    public function getChroot()\n    {\n        $chroot = [];\n        if (is_array($this->chroot)) {\n            $chroot = $this->chroot;\n        }\n        return $chroot;\n    }\n\n    /**\n     * @param boolean $debugCss\n     * @return $this\n     */\n    public function setDebugCss($debugCss)\n    {\n        $this->debugCss = $debugCss;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugCss()\n    {\n        return $this->debugCss;\n    }\n\n    /**\n     * @param boolean $debugKeepTemp\n     * @return $this\n     */\n    public function setDebugKeepTemp($debugKeepTemp)\n    {\n        $this->debugKeepTemp = $debugKeepTemp;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugKeepTemp()\n    {\n        return $this->debugKeepTemp;\n    }\n\n    /**\n     * @param boolean $debugLayout\n     * @return $this\n     */\n    public function setDebugLayout($debugLayout)\n    {\n        $this->debugLayout = $debugLayout;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayout()\n    {\n        return $this->debugLayout;\n    }\n\n    /**\n     * @param boolean $debugLayoutBlocks\n     * @return $this\n     */\n    public function setDebugLayoutBlocks($debugLayoutBlocks)\n    {\n        $this->debugLayoutBlocks = $debugLayoutBlocks;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutBlocks()\n    {\n        return $this->debugLayoutBlocks;\n    }\n\n    /**\n     * @param boolean $debugLayoutInline\n     * @return $this\n     */\n    public function setDebugLayoutInline($debugLayoutInline)\n    {\n        $this->debugLayoutInline = $debugLayoutInline;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutInline()\n    {\n        return $this->debugLayoutInline;\n    }\n\n    /**\n     * @param boolean $debugLayoutLines\n     * @return $this\n     */\n    public function setDebugLayoutLines($debugLayoutLines)\n    {\n        $this->debugLayoutLines = $debugLayoutLines;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutLines()\n    {\n        return $this->debugLayoutLines;\n    }\n\n    /**\n     * @param boolean $debugLayoutPaddingBox\n     * @return $this\n     */\n    public function setDebugLayoutPaddingBox($debugLayoutPaddingBox)\n    {\n        $this->debugLayoutPaddingBox = $debugLayoutPaddingBox;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutPaddingBox()\n    {\n        return $this->debugLayoutPaddingBox;\n    }\n\n    /**\n     * @param boolean $debugPng\n     * @return $this\n     */\n    public function setDebugPng($debugPng)\n    {\n        $this->debugPng = $debugPng;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugPng()\n    {\n        return $this->debugPng;\n    }\n\n    /**\n     * @param string $defaultFont\n     * @return $this\n     */\n    public function setDefaultFont($defaultFont)\n    {\n        if (!($defaultFont === null || trim($defaultFont) === \"\")) {\n            $this->defaultFont = $defaultFont;\n        } else {\n            $this->defaultFont = \"serif\";\n        }\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultFont()\n    {\n        return $this->defaultFont;\n    }\n\n    /**\n     * @param string $defaultMediaType\n     * @return $this\n     */\n    public function setDefaultMediaType($defaultMediaType)\n    {\n        $this->defaultMediaType = $defaultMediaType;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultMediaType()\n    {\n        return $this->defaultMediaType;\n    }\n\n    /**\n     * @param string $defaultPaperSize\n     * @return $this\n     */\n    public function setDefaultPaperSize($defaultPaperSize)\n    {\n        $this->defaultPaperSize = $defaultPaperSize;\n        return $this;\n    }\n\n    /**\n     * @param string $defaultPaperOrientation\n     * @return $this\n     */\n    public function setDefaultPaperOrientation($defaultPaperOrientation)\n    {\n        $this->defaultPaperOrientation = $defaultPaperOrientation;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultPaperSize()\n    {\n        return $this->defaultPaperSize;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultPaperOrientation()\n    {\n        return $this->defaultPaperOrientation;\n    }\n\n    /**\n     * @param int $dpi\n     * @return $this\n     */\n    public function setDpi($dpi)\n    {\n        $this->dpi = $dpi;\n        return $this;\n    }\n\n    /**\n     * @return int\n     */\n    public function getDpi()\n    {\n        return $this->dpi;\n    }\n\n    /**\n     * @param string $fontCache\n     * @return $this\n     */\n    public function setFontCache($fontCache)\n    {\n        $this->fontCache = $fontCache;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getFontCache()\n    {\n        return $this->fontCache;\n    }\n\n    /**\n     * @param string $fontDir\n     * @return $this\n     */\n    public function setFontDir($fontDir)\n    {\n        $this->fontDir = $fontDir;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getFontDir()\n    {\n        return $this->fontDir;\n    }\n\n    /**\n     * @param float $fontHeightRatio\n     * @return $this\n     */\n    public function setFontHeightRatio($fontHeightRatio)\n    {\n        $this->fontHeightRatio = $fontHeightRatio;\n        return $this;\n    }\n\n    /**\n     * @return float\n     */\n    public function getFontHeightRatio()\n    {\n        return $this->fontHeightRatio;\n    }\n\n    /**\n     * @param boolean $isFontSubsettingEnabled\n     * @return $this\n     */\n    public function setIsFontSubsettingEnabled($isFontSubsettingEnabled)\n    {\n        $this->isFontSubsettingEnabled = $isFontSubsettingEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsFontSubsettingEnabled()\n    {\n        return $this->isFontSubsettingEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isFontSubsettingEnabled()\n    {\n        return $this->getIsFontSubsettingEnabled();\n    }\n\n    /**\n     * @deprecated\n     * @param boolean $isHtml5ParserEnabled\n     * @return $this\n     */\n    public function setIsHtml5ParserEnabled($isHtml5ParserEnabled)\n    {\n        $this->isHtml5ParserEnabled = $isHtml5ParserEnabled;\n        return $this;\n    }\n\n    /**\n     * @deprecated\n     * @return boolean\n     */\n    public function getIsHtml5ParserEnabled()\n    {\n        return $this->isHtml5ParserEnabled;\n    }\n\n    /**\n     * @deprecated\n     * @return boolean\n     */\n    public function isHtml5ParserEnabled()\n    {\n        return $this->getIsHtml5ParserEnabled();\n    }\n\n    /**\n     * @param boolean $isJavascriptEnabled\n     * @return $this\n     */\n    public function setIsJavascriptEnabled($isJavascriptEnabled)\n    {\n        $this->isJavascriptEnabled = $isJavascriptEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsJavascriptEnabled()\n    {\n        return $this->isJavascriptEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isJavascriptEnabled()\n    {\n        return $this->getIsJavascriptEnabled();\n    }\n\n    /**\n     * @param boolean $isPhpEnabled\n     * @return $this\n     */\n    public function setIsPhpEnabled($isPhpEnabled)\n    {\n        $this->isPhpEnabled = $isPhpEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsPhpEnabled()\n    {\n        return $this->isPhpEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isPhpEnabled()\n    {\n        return $this->getIsPhpEnabled();\n    }\n\n    /**\n     * @param boolean $isRemoteEnabled\n     * @return $this\n     */\n    public function setIsRemoteEnabled($isRemoteEnabled)\n    {\n        $this->isRemoteEnabled = $isRemoteEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsRemoteEnabled()\n    {\n        return $this->isRemoteEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isRemoteEnabled()\n    {\n        return $this->getIsRemoteEnabled();\n    }\n\n    /**\n     * @param string $logOutputFile\n     * @return $this\n     */\n    public function setLogOutputFile($logOutputFile)\n    {\n        $this->logOutputFile = $logOutputFile;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getLogOutputFile()\n    {\n        return $this->logOutputFile;\n    }\n\n    /**\n     * @param string $tempDir\n     * @return $this\n     */\n    public function setTempDir($tempDir)\n    {\n        $this->tempDir = $tempDir;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getTempDir()\n    {\n        return $this->tempDir;\n    }\n\n    /**\n     * @param string $rootDir\n     * @return $this\n     */\n    public function setRootDir($rootDir)\n    {\n        $this->rootDir = $rootDir;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getRootDir()\n    {\n        return $this->rootDir;\n    }\n\n    /**\n     * Sets the HTTP context\n     *\n     * @param resource|array $httpContext\n     * @return $this\n     */\n    public function setHttpContext($httpContext)\n    {\n        $this->httpContext = is_array($httpContext) ? stream_context_create($httpContext) : $httpContext;\n        return $this;\n    }\n\n    /**\n     * Returns the HTTP context\n     *\n     * @return resource\n     */\n    public function getHttpContext()\n    {\n        return $this->httpContext;\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Renderer;\n\nuse Dompdf\\Adapter\\CPDF;\nuse Dompdf\\Css\\Color;\nuse Dompdf\\Css\\Style;\nuse Dompdf\\Dompdf;\nuse Dompdf\\Helpers;\nuse Dompdf\\Frame;\nuse Dompdf\\Image\\Cache;\n\n/**\n * Base renderer class\n *\n * @package dompdf\n */\nabstract class AbstractRenderer\n{\n\n    /**\n     * Rendering backend\n     *\n     * @var \\Dompdf\\Canvas\n     */\n    protected $_canvas;\n\n    /**\n     * Current dompdf instance\n     *\n     * @var Dompdf\n     */\n    protected $_dompdf;\n\n    /**\n     * Class constructor\n     *\n     * @param Dompdf $dompdf The current dompdf instance\n     */\n    function __construct(Dompdf $dompdf)\n    {\n        $this->_dompdf = $dompdf;\n        $this->_canvas = $dompdf->getCanvas();\n    }\n\n    /**\n     * Render a frame.\n     *\n     * Specialized in child classes\n     *\n     * @param Frame $frame The frame to render\n     */\n    abstract function render(Frame $frame);\n\n    /**\n     * Render a background image over a rectangular area\n     *\n     * @param string $url   The background image to load\n     * @param float $x      The left edge of the rectangular area\n     * @param float $y      The top edge of the rectangular area\n     * @param float $width  The width of the rectangular area\n     * @param float $height The height of the rectangular area\n     * @param Style $style  The associated Style object\n     *\n     * @throws \\Exception\n     */\n    protected function _background_image($url, $x, $y, $width, $height, $style)\n    {\n        if (!function_exists(\"imagecreatetruecolor\")) {\n            throw new \\Exception(\"The PHP GD extension is required, but is not installed.\");\n        }\n\n        $sheet = $style->get_stylesheet();\n\n        // Skip degenerate cases\n        if ($width == 0 || $height == 0) {\n            return;\n        }\n\n        $box_width = $width;\n        $box_height = $height;\n\n        //debugpng\n        if ($this->_dompdf->getOptions()->getDebugPng()) {\n            print '[_background_image ' . $url . ']';\n        }\n\n        list($img, $type, /*$msg*/) = Cache::resolve_url(\n            $url,\n            $sheet->get_protocol(),\n            $sheet->get_host(),\n            $sheet->get_base_path(),\n            $this->_dompdf\n        );\n\n        // Bail if the image is no good\n        if (Cache::is_broken($img)) {\n            return;\n        }\n\n        //Try to optimize away reading and composing of same background multiple times\n        //Postponing read with imagecreatefrom   ...()\n        //final composition parameters and name not known yet\n        //Therefore read dimension directly from file, instead of creating gd object first.\n        //$img_w = imagesx($src); $img_h = imagesy($src);\n\n        list($img_w, $img_h) = Helpers::dompdf_getimagesize($img, $this->_dompdf->getHttpContext());\n        if ($img_w == 0 || $img_h == 0) {\n            return;\n        }\n\n        // save for later check if file needs to be resized.\n        $org_img_w = $img_w;\n        $org_img_h = $img_h;\n\n        $repeat = $style->background_repeat;\n        $dpi = $this->_dompdf->getOptions()->getDpi();\n\n        //Increase background resolution and dependent box size according to image resolution to be placed in\n        //Then image can be copied in without resize\n        $bg_width = round((float)($width * $dpi) / 72);\n        $bg_height = round((float)($height * $dpi) / 72);\n\n        list($img_w, $img_h) = $this->_resize_background_image(\n            $img_w,\n            $img_h,\n            $bg_width,\n            $bg_height,\n            $style->background_size,\n            $dpi\n        );\n        //Need %bg_x, $bg_y as background pos, where img starts, converted to pixel\n\n        list($bg_x, $bg_y) = $style->background_position;\n\n        if (Helpers::is_percent($bg_x)) {\n            // The point $bg_x % from the left edge of the image is placed\n            // $bg_x % from the left edge of the background rectangle\n            $p = ((float)$bg_x) / 100.0;\n            $x1 = $p * $img_w;\n            $x2 = $p * $bg_width;\n\n            $bg_x = $x2 - $x1;\n        } else {\n            $bg_x = (float)($style->length_in_pt($bg_x) * $dpi) / 72;\n        }\n\n        $bg_x = round($bg_x + (float)$style->length_in_pt($style->border_left_width) * $dpi / 72);\n\n        if (Helpers::is_percent($bg_y)) {\n            // The point $bg_y % from the left edge of the image is placed\n            // $bg_y % from the left edge of the background rectangle\n            $p = ((float)$bg_y) / 100.0;\n            $y1 = $p * $img_h;\n            $y2 = $p * $bg_height;\n\n            $bg_y = $y2 - $y1;\n        } else {\n            $bg_y = (float)($style->length_in_pt($bg_y) * $dpi) / 72;\n        }\n\n        $bg_y = round($bg_y + (float)$style->length_in_pt($style->border_top_width) * $dpi / 72);\n\n        //clip background to the image area on partial repeat. Nothing to do if img off area\n        //On repeat, normalize start position to the tile at immediate left/top or 0/0 of area\n        //On no repeat with positive offset: move size/start to have offset==0\n        //Handle x/y Dimensions separately\n\n        if ($repeat !== \"repeat\" && $repeat !== \"repeat-x\") {\n            //No repeat x\n            if ($bg_x < 0) {\n                $bg_width = $img_w + $bg_x;\n            } else {\n                $x += ($bg_x * 72) / $dpi;\n                $bg_width = $bg_width - $bg_x;\n                if ($bg_width > $img_w) {\n                    $bg_width = $img_w;\n                }\n                $bg_x = 0;\n            }\n\n            if ($bg_width <= 0) {\n                return;\n            }\n\n            $width = (float)($bg_width * 72) / $dpi;\n        } else {\n            //repeat x\n            if ($bg_x < 0) {\n                $bg_x = -((-$bg_x) % $img_w);\n            } else {\n                $bg_x = $bg_x % $img_w;\n                if ($bg_x > 0) {\n                    $bg_x -= $img_w;\n                }\n            }\n        }\n\n        if ($repeat !== \"repeat\" && $repeat !== \"repeat-y\") {\n            //no repeat y\n            if ($bg_y < 0) {\n                $bg_height = $img_h + $bg_y;\n            } else {\n                $y += ($bg_y * 72) / $dpi;\n                $bg_height = $bg_height - $bg_y;\n                if ($bg_height > $img_h) {\n                    $bg_height = $img_h;\n                }\n                $bg_y = 0;\n            }\n            if ($bg_height <= 0) {\n                return;\n            }\n            $height = (float)($bg_height * 72) / $dpi;\n        } else {\n            //repeat y\n            if ($bg_y < 0) {\n                $bg_y = -((-$bg_y) % $img_h);\n            } else {\n                $bg_y = $bg_y % $img_h;\n                if ($bg_y > 0) {\n                    $bg_y -= $img_h;\n                }\n            }\n        }\n\n        //Optimization, if repeat has no effect\n        if ($repeat === \"repeat\" && $bg_y <= 0 && $img_h + $bg_y >= $bg_height) {\n            $repeat = \"repeat-x\";\n        }\n\n        if ($repeat === \"repeat\" && $bg_x <= 0 && $img_w + $bg_x >= $bg_width) {\n            $repeat = \"repeat-y\";\n        }\n\n        if (($repeat === \"repeat-x\" && $bg_x <= 0 && $img_w + $bg_x >= $bg_width) ||\n            ($repeat === \"repeat-y\" && $bg_y <= 0 && $img_h + $bg_y >= $bg_height)\n        ) {\n            $repeat = \"no-repeat\";\n        }\n\n        // Avoid rendering identical background-image variants multiple times\n        // This is not dependent of background color of box! .'_'.(is_array($bg_color) ? $bg_color[\"hex\"] : $bg_color)\n        // Note: Here, bg_* are the start values, not end values after going through the tile loops!\n\n        $key = implode(\"_\", [$bg_width, $bg_height, $img_w, $img_h, $bg_x, $bg_y, $repeat]);\n        // FIXME: This will fail when a file with that exact name exists in the\n        // same directory, included in the document as regular image\n        $cpdfKey = $img . \"_\" . $key;\n        $tmpFile = Cache::getTempImage($img, $key);\n        $cached = ($this->_canvas instanceof CPDF && $this->_canvas->get_cpdf()->image_iscached($cpdfKey))\n            || ($tmpFile !== null && file_exists($tmpFile));\n\n        if (!$cached) {\n            // img: image url string\n            // img_w, img_h: original image size in px\n            // width, height: box size in pt\n            // bg_width, bg_height: box size in px\n            // x, y: left/top edge of box on page in pt\n            // start_x, start_y: placement of image relative to pattern\n            // $repeat: repeat mode\n            // $bg: GD object of result image\n            // $src: GD object of original image\n\n            // Create a new image to fit over the background rectangle\n            $bg = imagecreatetruecolor($bg_width, $bg_height);\n            $cpdfFromGd = true;\n\n            switch (strtolower($type)) {\n                case \"png\":\n                    $cpdfFromGd = false;\n                    imagesavealpha($bg, true);\n                    imagealphablending($bg, false);\n                    $src = @imagecreatefrompng($img);\n                    break;\n\n                case \"jpeg\":\n                    $src = @imagecreatefromjpeg($img);\n                    break;\n\n                case \"webp\":\n                    $src = @imagecreatefromwebp($img);\n                    break;\n\n                case \"gif\":\n                    $src = @imagecreatefromgif($img);\n                    break;\n\n                case \"bmp\":\n                    $src = @Helpers::imagecreatefrombmp($img);\n                    break;\n\n                default:\n                    return; // Unsupported image type\n            }\n\n            if ($src == null) {\n                return;\n            }\n\n            if ($img_w != $org_img_w || $img_h != $org_img_h) {\n                $newSrc = imagescale($src, $img_w, $img_h);\n                imagedestroy($src);\n                $src = $newSrc;\n            }\n\n            if ($src == null) {\n                return;\n            }\n\n            //Background color if box is not relevant here\n            //Non transparent image: box clipped to real size. Background non relevant.\n            //Transparent image: The image controls the transparency and lets shine through whatever background.\n            //However on transparent image preset the composed image with the transparency color,\n            //to keep the transparency when copying over the non transparent parts of the tiles.\n            $ti = imagecolortransparent($src);\n            $palletsize = imagecolorstotal($src);\n\n            if ($ti >= 0 && $ti < $palletsize) {\n                $tc = imagecolorsforindex($src, $ti);\n                $ti = imagecolorallocate($bg, $tc['red'], $tc['green'], $tc['blue']);\n                imagefill($bg, 0, 0, $ti);\n                imagecolortransparent($bg, $ti);\n            }\n\n            //This has only an effect for the non repeatable dimension.\n            //compute start of src and dest coordinates of the single copy\n            if ($bg_x < 0) {\n                $dst_x = 0;\n                $src_x = -$bg_x;\n            } else {\n                $src_x = 0;\n                $dst_x = $bg_x;\n            }\n\n            if ($bg_y < 0) {\n                $dst_y = 0;\n                $src_y = -$bg_y;\n            } else {\n                $src_y = 0;\n                $dst_y = $bg_y;\n            }\n\n            //For historical reasons exchange meanings of variables:\n            //start_* will be the start values, while bg_* will be the temporary start values in the loops\n            $start_x = $bg_x;\n            $start_y = $bg_y;\n\n            // Copy regions from the source image to the background\n            if ($repeat === \"no-repeat\") {\n                // Simply place the image on the background\n                imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $img_w, $img_h);\n\n            } else if ($repeat === \"repeat-x\") {\n                for ($bg_x = $start_x; $bg_x < $bg_width; $bg_x += $img_w) {\n                    if ($bg_x < 0) {\n                        $dst_x = 0;\n                        $src_x = -$bg_x;\n                        $w = $img_w + $bg_x;\n                    } else {\n                        $dst_x = $bg_x;\n                        $src_x = 0;\n                        $w = $img_w;\n                    }\n                    imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $w, $img_h);\n                }\n            } else if ($repeat === \"repeat-y\") {\n\n                for ($bg_y = $start_y; $bg_y < $bg_height; $bg_y += $img_h) {\n                    if ($bg_y < 0) {\n                        $dst_y = 0;\n                        $src_y = -$bg_y;\n                        $h = $img_h + $bg_y;\n                    } else {\n                        $dst_y = $bg_y;\n                        $src_y = 0;\n                        $h = $img_h;\n                    }\n                    imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $img_w, $h);\n                }\n            } else if ($repeat === \"repeat\") {\n                for ($bg_y = $start_y; $bg_y < $bg_height; $bg_y += $img_h) {\n                    for ($bg_x = $start_x; $bg_x < $bg_width; $bg_x += $img_w) {\n                        if ($bg_x < 0) {\n                            $dst_x = 0;\n                            $src_x = -$bg_x;\n                            $w = $img_w + $bg_x;\n                        } else {\n                            $dst_x = $bg_x;\n                            $src_x = 0;\n                            $w = $img_w;\n                        }\n\n                        if ($bg_y < 0) {\n                            $dst_y = 0;\n                            $src_y = -$bg_y;\n                            $h = $img_h + $bg_y;\n                        } else {\n                            $dst_y = $bg_y;\n                            $src_y = 0;\n                            $h = $img_h;\n                        }\n                        imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $w, $h);\n                    }\n                }\n            } else {\n                print 'Unknown repeat!';\n            }\n\n            imagedestroy($src);\n\n            if ($cpdfFromGd && $this->_canvas instanceof CPDF) {\n                // Skip writing temp file as the GD object is added directly\n            } else {\n                $tmpDir = $this->_dompdf->getOptions()->getTempDir();\n                $tmpName = @tempnam($tmpDir, \"bg_dompdf_img_\");\n                @unlink($tmpName);\n                $tmpFile = \"$tmpName.png\";\n\n                imagepng($bg, $tmpFile);\n                imagedestroy($bg);\n\n                Cache::addTempImage($img, $tmpFile, $key);\n            }\n        } else {\n            $bg = null;\n            $cpdfFromGd = $tmpFile === null;\n        }\n\n        if ($this->_dompdf->getOptions()->getDebugPng()) {\n            print '[_background_image ' . $tmpFile . ']';\n        }\n\n        $this->_canvas->clipping_rectangle($x, $y, $box_width, $box_height);\n\n        // When using cpdf and optimization to direct png creation from gd object is available,\n        // don't create temp file, but place gd object directly into the pdf\n        if ($cpdfFromGd && $this->_canvas instanceof CPDF) {\n            // Note: CPDF_Adapter image converts y position\n            $this->_canvas->get_cpdf()->addImagePng($bg, $cpdfKey, $x, $this->_canvas->get_height() - $y - $height, $width, $height);\n\n            if (isset($bg)) {\n                imagedestroy($bg);\n            }\n        } else {\n            $this->_canvas->image($tmpFile, $x, $y, $width, $height);\n        }\n\n        $this->_canvas->clipping_end();\n    }\n\n    /**\n     * @param $style\n     * @param $width\n     * @return array\n     */\n    protected function _get_dash_pattern($style, $width)\n    {\n        $pattern = [];\n\n        switch ($style) {\n            default:\n                /*case \"solid\":\n                case \"double\":\n                case \"groove\":\n                case \"inset\":\n                case \"outset\":\n                case \"ridge\":*/\n            case \"none\":\n                break;\n\n            case \"dotted\":\n                if ($width <= 1) {\n                    $pattern = [$width, $width * 2];\n                } else {\n                    $pattern = [$width];\n                }\n                break;\n\n            case \"dashed\":\n                $pattern = [3 * $width];\n                break;\n        }\n\n        return $pattern;\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_none($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        return;\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_hidden($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        return;\n    }\n\n    // Border rendering functions\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_dotted($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        $this->_border_line($x, $y, $length, $color, $widths, $side, $corner_style, \"dotted\", $r1, $r2);\n    }\n\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_dashed($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        $this->_border_line($x, $y, $length, $color, $widths, $side, $corner_style, \"dashed\", $r1, $r2);\n    }\n\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_solid($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        // TODO: Solve rendering where one corner is beveled (radius == 0), one corner isn't.\n        if ($corner_style !== \"bevel\" || $r1 > 0 || $r2 > 0) {\n            // do it the simple way\n            $this->_border_line($x, $y, $length, $color, $widths, $side, $corner_style, \"solid\", $r1, $r2);\n            return;\n        }\n\n        list($top, $right, $bottom, $left) = $widths;\n\n        // All this polygon business is for beveled corners...\n        switch ($side) {\n            case \"top\":\n                $points = [$x, $y,\n                    $x + $length, $y,\n                    $x + $length - $right, $y + $top,\n                    $x + $left, $y + $top];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            case \"bottom\":\n                $points = [$x, $y,\n                    $x + $length, $y,\n                    $x + $length - $right, $y - $bottom,\n                    $x + $left, $y - $bottom];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            case \"left\":\n                $points = [$x, $y,\n                    $x, $y + $length,\n                    $x + $left, $y + $length - $bottom,\n                    $x + $left, $y + $top];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            case \"right\":\n                $points = [$x, $y,\n                    $x, $y + $length,\n                    $x - $right, $y + $length - $bottom,\n                    $x - $right, $y + $top];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * @param $side\n     * @param $ratio\n     * @param $top\n     * @param $right\n     * @param $bottom\n     * @param $left\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $r1\n     * @param $r2\n     */\n    protected function _apply_ratio($side, $ratio, $top, $right, $bottom, $left, &$x, &$y, &$length, &$r1, &$r2)\n    {\n        switch ($side) {\n            case \"top\":\n                $r1 -= $left * $ratio;\n                $r2 -= $right * $ratio;\n                $x += $left * $ratio;\n                $y += $top * $ratio;\n                $length -= $left * $ratio + $right * $ratio;\n                break;\n\n            case \"bottom\":\n                $r1 -= $right * $ratio;\n                $r2 -= $left * $ratio;\n                $x += $left * $ratio;\n                $y -= $bottom * $ratio;\n                $length -= $left * $ratio + $right * $ratio;\n                break;\n\n            case \"left\":\n                $r1 -= $top * $ratio;\n                $r2 -= $bottom * $ratio;\n                $x += $left * $ratio;\n                $y += $top * $ratio;\n                $length -= $top * $ratio + $bottom * $ratio;\n                break;\n\n            case \"right\":\n                $r1 -= $bottom * $ratio;\n                $r2 -= $top * $ratio;\n                $x -= $right * $ratio;\n                $y += $top * $ratio;\n                $length -= $top * $ratio + $bottom * $ratio;\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_double($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        list($top, $right, $bottom, $left) = $widths;\n\n        $third_widths = [$top / 3, $right / 3, $bottom / 3, $left / 3];\n\n        // draw the outer border\n        $this->_border_solid($x, $y, $length, $color, $third_widths, $side, $corner_style, $r1, $r2);\n\n        $this->_apply_ratio($side, 2 / 3, $top, $right, $bottom, $left, $x, $y, $length, $r1, $r2);\n\n        $this->_border_solid($x, $y, $length, $color, $third_widths, $side, $corner_style, $r1, $r2);\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_groove($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        list($top, $right, $bottom, $left) = $widths;\n\n        $half_widths = [$top / 2, $right / 2, $bottom / 2, $left / 2];\n\n        $this->_border_inset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n\n        $this->_apply_ratio($side, 0.5, $top, $right, $bottom, $left, $x, $y, $length, $r1, $r2);\n\n        $this->_border_outset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_ridge($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        list($top, $right, $bottom, $left) = $widths;\n\n        $half_widths = [$top / 2, $right / 2, $bottom / 2, $left / 2];\n\n        $this->_border_outset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n\n        $this->_apply_ratio($side, 0.5, $top, $right, $bottom, $left, $x, $y, $length, $r1, $r2);\n\n        $this->_border_inset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n    }\n\n    /**\n     * @param $c\n     * @return mixed\n     */\n    protected function _tint($c)\n    {\n        if (!is_numeric($c)) {\n            return $c;\n        }\n\n        return min(1, $c + 0.16);\n    }\n\n    /**\n     * @param $c\n     * @return mixed\n     */\n    protected function _shade($c)\n    {\n        if (!is_numeric($c)) {\n            return $c;\n        }\n\n        return max(0, $c - 0.33);\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_inset($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        switch ($side) {\n            case \"top\":\n            case \"left\":\n                $shade = array_map([$this, \"_shade\"], $color);\n                $this->_border_solid($x, $y, $length, $shade, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            case \"bottom\":\n            case \"right\":\n                $tint = array_map([$this, \"_tint\"], $color);\n                $this->_border_solid($x, $y, $length, $tint, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_outset($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        switch ($side) {\n            case \"top\":\n            case \"left\":\n                $tint = array_map([$this, \"_tint\"], $color);\n                $this->_border_solid($x, $y, $length, $tint, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            case \"bottom\":\n            case \"right\":\n                $shade = array_map([$this, \"_shade\"], $color);\n                $this->_border_solid($x, $y, $length, $shade, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * Draws a solid, dotted, or dashed line, observing the border radius\n     *\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param $pattern_name\n     * @param int $r1\n     * @param int $r2\n     *\n     * @var $top\n     */\n    protected function _border_line($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $pattern_name = \"none\", $r1 = 0, $r2 = 0)\n    {\n        /** used by $$side */\n        list($top, $right, $bottom, $left) = $widths;\n        $width = $$side;\n\n        $pattern = $this->_get_dash_pattern($pattern_name, $width);\n\n        $half_width = $width / 2;\n        $r1 -= $half_width;\n        $r2 -= $half_width;\n        $adjust = $r1 / 80;\n        $length -= $width;\n\n        switch ($side) {\n            case \"top\":\n                $x += $half_width;\n                $y += $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x + $r1, $y + $r1, $r1, $r1, 90 - $adjust, 135 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x + $r1, $y, $x + $length - $r2, $y, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x + $length - $r2, $y + $r2, $r2, $r2, 45 - $adjust, 90 + $adjust, $color, $width, $pattern);\n                }\n                break;\n\n            case \"bottom\":\n                $x += $half_width;\n                $y -= $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x + $r1, $y - $r1, $r1, $r1, 225 - $adjust, 270 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x + $r1, $y, $x + $length - $r2, $y, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x + $length - $r2, $y - $r2, $r2, $r2, 270 - $adjust, 315 + $adjust, $color, $width, $pattern);\n                }\n                break;\n\n            case \"left\":\n                $y += $half_width;\n                $x += $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x + $r1, $y + $r1, $r1, $r1, 135 - $adjust, 180 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x, $y + $r1, $x, $y + $length - $r2, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x + $r2, $y + $length - $r2, $r2, $r2, 180 - $adjust, 225 + $adjust, $color, $width, $pattern);\n                }\n                break;\n\n            case \"right\":\n                $y += $half_width;\n                $x -= $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x - $r1, $y + $r1, $r1, $r1, 0 - $adjust, 45 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x, $y + $r1, $x, $y + $length - $r2, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x - $r2, $y + $length - $r2, $r2, $r2, 315 - $adjust, 360 + $adjust, $color, $width, $pattern);\n                }\n                break;\n        }\n    }\n\n    /**\n     * @param float $opacity\n     */\n    protected function _set_opacity(float $opacity): void\n    {\n        if ($opacity >= 0.0 && $opacity <= 1.0) {\n            $this->_canvas->set_opacity($opacity);\n        }\n    }\n\n    /**\n     * @param array $box\n     * @param string $color\n     * @param array $style\n     */\n    protected function _debug_layout($box, $color = \"red\", $style = [])\n    {\n        $this->_canvas->rectangle($box[0], $box[1], $box[2], $box[3], Color::parse($color), 0.1, $style);\n    }\n\n    /**\n     * @param float $img_width\n     * @param float $img_height\n     * @param float $container_width\n     * @param float $container_height\n     * @param array|string $bg_resize\n     * @param int $dpi\n     * @return array\n     */\n    protected function _resize_background_image(\n        $img_width,\n        $img_height,\n        $container_width,\n        $container_height,\n        $bg_resize,\n        $dpi\n    ) {\n        // We got two some specific numbers and/or auto definitions\n        if (is_array($bg_resize)) {\n            $is_auto_width = $bg_resize[0] === 'auto';\n            if ($is_auto_width) {\n                $new_img_width = $img_width;\n            } else {\n                $new_img_width = $bg_resize[0];\n                if (Helpers::is_percent($new_img_width)) {\n                    $new_img_width = round(($container_width / 100) * (float)$new_img_width);\n                } else {\n                    $new_img_width = round($new_img_width * $dpi / 72);\n                }\n            }\n\n            $is_auto_height = $bg_resize[1] === 'auto';\n            if ($is_auto_height) {\n                $new_img_height = $img_height;\n            } else {\n                $new_img_height = $bg_resize[1];\n                if (Helpers::is_percent($new_img_height)) {\n                    $new_img_height = round(($container_height / 100) * (float)$new_img_height);\n                } else {\n                    $new_img_height = round($new_img_height * $dpi / 72);\n                }\n            }\n\n            // if one of both was set to auto the other one needs to scale proportionally\n            if ($is_auto_width !== $is_auto_height) {\n                if ($is_auto_height) {\n                    $new_img_height = round($new_img_width * ($img_height / $img_width));\n                } else {\n                    $new_img_width = round($new_img_height * ($img_width / $img_height));\n                }\n            }\n        } else {\n            $container_ratio = $container_height / $container_width;\n\n            if ($bg_resize === 'cover' || $bg_resize === 'contain') {\n                $img_ratio = $img_height / $img_width;\n\n                if (\n                    ($bg_resize === 'cover' && $container_ratio > $img_ratio) ||\n                    ($bg_resize === 'contain' && $container_ratio < $img_ratio)\n                ) {\n                    $new_img_height = $container_height;\n                    $new_img_width = round($container_height / $img_ratio);\n                } else {\n                    $new_img_width = $container_width;\n                    $new_img_height = round($container_width * $img_ratio);\n                }\n            } else {\n                $new_img_width = $img_width;\n                $new_img_height = $img_height;\n            }\n        }\n\n        return [$new_img_width, $new_img_height];\n    }\n}\n", "<?php\nnamespace Dompdf\\Tests\\Css;\n\nuse Dompdf\\Dompdf;\nuse Dompdf\\Css\\Style;\nuse Dompdf\\Css\\Stylesheet;\nuse Dompdf\\Options;\nuse Dompdf\\Tests\\TestCase;\n\nclass StyleTest extends TestCase\n{\n    public function lengthInPtProvider(): array\n    {\n        return [\n            [\"auto\", null, \"auto\"],\n            [\"none\", null, \"none\"],\n            [\"100px\", null, 75.0],\n            [\"100PX\", null, 75.0], // Also check caps\n            [\"100pt\", null, 100.0],\n            [\"1.5e2pt\", null, 150.0], // Exponential notation\n            [\"1.5e+2pt\", null, 150.0],\n            [\"15E-2pT\", null, 0.15],\n            [\"1.5em\", 20, 18.0], // Default font size is 12pt\n            [\"100%\", null, 12.0],\n            [\"50%\", 360, 180.0]\n        ];\n    }\n\n    /**\n     * @dataProvider lengthInPtProvider\n     */\n    public function testLengthInPt(string $length, ?float $ref_size, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $s = new Style($sheet);\n\n        $result = $s->length_in_pt($length, $ref_size);\n        $this->assertSame($expected, $result);\n    }\n\n    public function cssImageBasicProvider(): array\n    {\n        return [\n            \"no value\" => [\"\", \"none\"],\n            \"keyword none\" => [\"none\", \"none\"],\n            \"bare url\" => [\"http://example.com/test.png\", \"none\"],\n            \"http\" => [\"url(http://example.com/test.png)\", \"http://example.com/test.png\"]\n        ];\n    }\n\n    public function cssImageNoBaseHrefProvider(): array\n    {\n        $basePath = realpath(__DIR__ . \"/..\");\n        return [\n            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n            \"local relative\" => [\"url(../_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n        ];\n    }\n\n    public function cssImageWithBaseHrefProvider(): array\n    {\n        $basePath = realpath(__DIR__ . \"/..\");\n        return [\n            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n            \"local relative\" => [\"url(../_files/jamaica.jpg)\", $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n        ];\n    }\n\n    public function cssImageWithStylesheetBaseHrefProvider(): array\n    {\n        return [\n            \"local absolute\" => [\"url(/_files/jamaica.jpg)\", \"https://example.com/_files/jamaica.jpg\"],\n            \"local relative\" => [\"url(../_files/jamaica.jpg)\", \"https://example.com/../_files/jamaica.jpg\"]\n        ];\n    }\n\n    /**\n     * @dataProvider cssImageBasicProvider\n     * @dataProvider cssImageNoBaseHrefProvider\n     * @group regression\n     */\n    public function testCssImageNoBaseHref(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $sheet->set_base_path(__DIR__); // Treat stylesheet as being located in this directory\n        $s = new Style($sheet);\n\n        $s->set_prop(\"background_image\", $value);\n        $this->assertSame($expected, $s->background_image);\n    }\n\n    /**\n     * @dataProvider cssImageBasicProvider\n     * @dataProvider cssImageWithBaseHrefProvider\n     * @group regression\n     */\n    public function testCssImageWithBaseHref(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $dompdf->setProtocol(\"https://\");\n        $dompdf->setBaseHost(\"example.com\");\n        $dompdf->setBasePath(\"/\");\n        $sheet = new Stylesheet($dompdf);\n        $sheet->set_base_path(__DIR__); // Treat stylesheet as being located in this directory\n        $s = new Style($sheet);\n\n        $s->set_prop(\"background_image\", $value);\n        $this->assertSame($expected, $s->background_image);\n    }\n\n    /**\n     * @dataProvider cssImageBasicProvider\n     * @dataProvider cssImageWithStylesheetBaseHrefProvider\n     * @group regression\n     */\n    public function testCssImageWithStylesheetBaseHref(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $sheet->set_protocol(\"https://\");\n        $sheet->set_host(\"example.com\");\n        $sheet->set_base_path(\"/\");\n        $s = new Style($sheet);\n\n        $s->set_prop(\"background_image\", $value);\n        $this->assertSame($expected, $s->background_image);\n    }\n\n    public function contentProvider(): array\n    {\n        return [\n            [\"normal\", \"normal\"],\n            [\"none\", \"none\"],\n            [\n                \"'\u2013' attr(title) '\u2013'\",\n                [\"'\u2013'\", \"attr(title)\", \"'\u2013'\"]\n            ],\n            [\n                'counter(page)\" / {PAGES}\"',\n                [\"counter(page)\", '\" / {PAGES}\"']\n            ],\n            [\n                \"counter(li1, decimal)\\\".\\\"counter(li2, upper-roman)  ')'url('image.png')\",\n                [\"counter(li1, decimal)\", '\".\"', \"counter(li2, upper-roman)\", \"')'\", \"url('image.png')\"]\n            ],\n            [\n                '\"url(\\' \\')\"open-quote url(\" \")close-quote',\n                ['\"url(\\' \\')\"', \"open-quote\", 'url(\" \")', \"close-quote\"]\n            ]\n        ];\n    }\n\n    /**\n     * @dataProvider contentProvider\n     */\n    public function testContent(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"content\", $value);\n        $this->assertSame($expected, $style->content);\n    }\n\n    public function sizeProvider(): array\n    {\n        return [\n            // Valid values\n            [\"auto\", \"auto\"],\n            [\"letter\", [612.00, 792.00]],\n            [\"portrait\", [419.53, 595.28]],\n            [\"landscape\", [595.28, 419.53]],\n            [\"A4 portrait\", [595.28, 841.89]],\n            [\"landscape a4\", [841.89, 595.28]],\n            [\"200pt\", [200.0, 200.0]],\n            [\"400pt 300pt\", [400.0, 300.0]],\n            [\"400pt 300pt portrait\", [300.0, 400.0]],\n            [\"landscape 300pt 400pt\", [400.0, 300.0]],\n            [\"landscape 400pt 300pt\", [400.0, 300.0]],\n\n            // Invalid values\n            [\"\", \"auto\"],\n            [\"letter auto\", \"auto\"],\n            [\"landscape landscape a4\", \"auto\"],\n            [\"letter 300mm 300mm\", \"auto\"]\n        ];\n    }\n\n    /**\n     * @dataProvider sizeProvider\n     */\n    public function testSize(string $value, $expected): void\n    {\n        $options = new Options();\n        $options->setDefaultPaperSize(\"A5\");\n        $dompdf = new Dompdf($options);\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"size\", $value);\n        $this->assertSame($expected, $style->size);\n    }\n\n    public function opacityProvider(): array\n    {\n        return [\n            // Valid values\n            [\"0\", 0.0],\n            [\"1\", 1.0],\n            [\"+1.0\", 1.0],\n            [\"0.5\", 0.5],\n            [\".5\", 0.5],\n            [\"100%\", 1.0],\n            [\"23.78%\", 0.2378],\n            [\"2e-2%\", 0.0002],\n\n            // Out-of-range values (clamped instead of invalid)\n            [\"500.95\", 1.0],\n            [\"300%\", 1.0],\n            [\"-100\", 0.0],\n            [\"-23.3%\", 0.0],\n\n            // Invalid values\n            [\"\", 1.0],\n            [\"auto\", 1.0],\n            [\"invalid\", 1.0],\n            [\"0.5pt\", 1.0]\n        ];\n    }\n\n    /**\n     * @dataProvider opacityProvider\n     */\n    public function testOpacity(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"opacity\", $value);\n        $this->assertSame($expected, $style->opacity);\n    }\n\n    public function zIndexProvider(): array\n    {\n        return [\n            // Valid values\n            [\"auto\", \"auto\"],\n            [\"0\", 0],\n            [\"1\", 1],\n            [\"+23\", 23],\n            [\"-100\", -100],\n\n            // Invalid values\n            [\"\", \"auto\"],\n            [\"5.5\", \"auto\"],\n            [\"invalid\", \"auto\"]\n        ];\n    }\n\n    /**\n     * @dataProvider zIndexProvider\n     */\n    public function testZIndex(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"z_index\", $value);\n        $this->assertSame($expected, $style->z_index);\n    }\n\n    public function valueCaseProvider(): array\n    {\n        return [\n            [\"width\", \"Auto\",           \"width\", \"auto\"],\n            [\"list-style-type\", \"A\",    \"list_style_type\", \"A\"],\n        ];\n    }\n\n    /**\n     * @dataProvider valueCaseProvider\n     */\n    public function testValueCase(string $cssProp, string $inputValue, string $phpProp, string $expectValue): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop($cssProp, $inputValue);\n        $this->assertSame($expectValue, $style->$phpProp);\n    }\n\n    public function testWordBreakBreakWord(): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"overflow_wrap\", \"break-word\");\n        $style->set_prop(\"word_break\", \"break-word\");\n        \n        $this->assertSame(\"normal\", $style->word_break);\n        $this->assertSame(\"anywhere\", $style->overflow_wrap);\n    }\n}\n", "<?php\nnamespace Dompdf\\Tests;\n\nuse Dompdf\\Helpers;\nuse Dompdf\\Tests\\TestCase;\n\nclass HelpersTest extends TestCase\n{\n    public function testParseDataUriBase64Image(): void\n    {\n        $imageParts = [\n            'mime' => 'data:image/png;base64,',\n            'data' => 'iVBORw0KGgoAAAANSUhEUgAAAAUA\nAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n9TXL0Y4OHwAAAABJRU5ErkJggg=='\n        ];\n        $result = Helpers::parse_data_uri(implode('', $imageParts));\n        $this->assertEquals(\n            $result['data'],\n            base64_decode($imageParts['data'])\n        );\n    }\n\n    public function dec2RomanProvider(): array\n    {\n        return [\n            [-5, \"-5\"],\n            [0, \"0\"],\n            [1, \"i\"],\n            [5, \"v\"],\n            [3999, \"mmmcmxcix\"],\n            [4000, \"4000\"],\n            [50000, \"50000\"],\n        ];\n    }\n\n    /**\n     * @dataProvider dec2RomanProvider\n     */\n    public function testDec2Roman($number, string $expected): void\n    {\n        $roman = Helpers::dec2roman($number);\n        $this->assertSame($expected, $roman);\n    }\n\n    public function lengthEqualProvider(): array\n    {\n        // Adapted from\n        // https://floating-point-gui.de/errors/NearlyEqualsTest.java\n        return [\n            [0.0, 0.3 - 0.2 - 0.1, true],\n            [0.3, 0.1 + 0.1 + 0.1, true],\n\n            // Large numbers\n            [100000000.0, 100000001.0, true],\n            [100000.0001, 100000.0002, true],\n            [100000.01, 100000.02, false],\n            [1000.0001, 1000.0002, false],\n\n            // Numbers around 1\n            [1.000000001, 1.000000002, true],\n            [1.0000001, 1.0000002, false],\n\n            // Numbers between 1 and 0\n            [0.00000010000001, 0.00000010000002, true],\n            [0.00000000001001, 0.00000000001002, true],\n            [0.000000100001, 0.000000100002, false],\n\n            // Close to zero\n            [0.0, 0.0, true],\n            [0.0, -0.0, true],\n            [1e-38, 1e-37, true],\n            [1e-38, -1e-37, true],\n            [1e-38, 0.0, true],\n            [1e-13, 1e-38, true],\n            [1e-13, 0.0, true],\n            [1e-13, -1e-13, true],\n            [1e-12, -1e-12, false],\n            [1e-12, 0.0, false],\n\n            // Very large numbers\n            [1e38, 1e38, true],\n            [1e38, 1.000001e38, false],\n\n            // Infinity and NaN\n            [INF, INF, true],\n            [INF, -INF, false],\n            [INF, 1e38, false],\n            [NAN, NAN, false],\n            [NAN, 0.0, false],\n        ];\n    }\n\n    /**\n     * @dataProvider lengthEqualProvider\n     */\n    public function testLengthEqual(float $a, float $b, bool $expected): void\n    {\n        $this->assertSame($expected, Helpers::lengthEqual($a, $b));\n        $this->assertSame($expected, Helpers::lengthEqual($b, $a));\n        $this->assertSame($expected, Helpers::lengthEqual(-$a, -$b));\n        $this->assertSame($expected, Helpers::lengthEqual(-$b, -$a));\n    }\n}\n", "<?php\nnamespace Dompdf\\Tests;\n\nuse Dompdf\\Options;\nuse Dompdf\\Tests\\TestCase;\n\nclass OptionsTest extends TestCase\n{\n    public function testConstructor()\n    {\n        $root = realpath(dirname(__DIR__));\n        $option = new Options();\n        $this->assertEquals(sys_get_temp_dir(), $option->getTempDir());\n        $this->assertEquals($root . '/lib/fonts', $option->getFontDir());\n        $this->assertEquals($root . '/lib/fonts', $option->getFontCache());\n        $this->assertEquals([$root], $option->getChroot());\n        $this->assertEmpty($option->getLogOutputFile());\n        $this->assertEquals('screen', $option->getDefaultMediaType());\n        $this->assertEquals('letter', $option->getDefaultPaperSize());\n        $this->assertEquals('serif', $option->getDefaultFont());\n        $this->assertEquals(96, $option->getDpi());\n        $this->assertEquals(1.1, $option->getFontHeightRatio());\n        $this->assertFalse($option->getIsPhpEnabled());\n        $this->assertFalse($option->getIsRemoteEnabled());\n        $this->assertTrue($option->getIsJavascriptEnabled());\n        $this->assertTrue($option->getIsHtml5ParserEnabled());\n        $this->assertTrue($option->getIsFontSubsettingEnabled());\n        $this->assertFalse($option->getDebugPng());\n        $this->assertFalse($option->getDebugKeepTemp());\n        $this->assertFalse($option->getDebugCss());\n        $this->assertFalse($option->getDebugLayout());\n        $this->assertTrue($option->getDebugLayoutLines());\n        $this->assertTrue($option->getDebugLayoutBlocks());\n        $this->assertTrue($option->getDebugLayoutInline());\n        $this->assertTrue($option->getDebugLayoutPaddingBox());\n\n        $option = new Options(['tempDir' => 'test1']);\n        $this->assertEquals('test1', $option->getTempDir());\n    }\n\n    public function testSetters()\n    {\n        $option = new Options();\n        $option->set([\n            'tempDir' => 'test1',\n            'fontDir' => 'test2',\n            'fontCache' => 'test3',\n            'chroot' => 'test4,test4a',\n            'logOutputFile' => 'test5',\n            'defaultMediaType' => 'test6',\n            'defaultPaperSize' => 'test7',\n            'defaultFont' => 'test8',\n            'dpi' => 300,\n            'fontHeightRatio' => 1.2,\n            'isPhpEnabled' => true,\n            'isRemoteEnabled' => true,\n            'isJavascriptEnabled' => false,\n            'isHtml5ParserEnabled' => true,\n            'isFontSubsettingEnabled' => false,\n            'debugPng' => true,\n            'debugKeepTemp' => true,\n            'debugCss' => true,\n            'debugLayout' => true,\n            'debugLayoutLines' => false,\n            'debugLayoutBlocks' => false,\n            'debugLayoutInline' => false,\n            'debugLayoutPaddingBox' => false,\n            'httpContext' => ['ssl' => ['verify_peer' => false]],\n        ]);\n        $this->assertEquals('test1', $option->getTempDir());\n        $this->assertEquals('test2', $option->getFontDir());\n        $this->assertEquals('test3', $option->getFontCache());\n        $this->assertEquals(['test4','test4a'], $option->getChroot());\n        $this->assertEquals('test5', $option->getLogOutputFile());\n        $this->assertEquals('test6', $option->getDefaultMediaType());\n        $this->assertEquals('test7', $option->getDefaultPaperSize());\n        $this->assertEquals('test8', $option->getDefaultFont());\n        $this->assertEquals(300, $option->getDpi());\n        $this->assertEquals(1.2, $option->getFontHeightRatio());\n        $this->assertTrue($option->getIsPhpEnabled());\n        $this->assertTrue($option->getIsRemoteEnabled());\n        $this->assertFalse($option->getIsJavascriptEnabled());\n        $this->assertTrue($option->getIsHtml5ParserEnabled());\n        $this->assertFalse($option->getIsFontSubsettingEnabled());\n        $this->assertTrue($option->getDebugPng());\n        $this->assertTrue($option->getDebugKeepTemp());\n        $this->assertTrue($option->getDebugCss());\n        $this->assertTrue($option->getDebugLayout());\n        $this->assertFalse($option->getDebugLayoutLines());\n        $this->assertFalse($option->getDebugLayoutBlocks());\n        $this->assertFalse($option->getDebugLayoutInline());\n        $this->assertFalse($option->getDebugLayoutPaddingBox());\n        $this->assertIsResource($option->getHttpContext());\n\n        $option->setChroot(['test11']);\n        $this->assertEquals(['test11'], $option->getChroot());\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Css;\n\nuse DOMElement;\nuse DOMXPath;\nuse Dompdf\\Dompdf;\nuse Dompdf\\Helpers;\nuse Dompdf\\Exception;\nuse Dompdf\\FontMetrics;\nuse Dompdf\\Frame\\FrameTree;\n\n/**\n * The master stylesheet class\n *\n * The Stylesheet class is responsible for parsing stylesheets and style\n * tags/attributes.  It also acts as a registry of the individual Style\n * objects generated by the current set of loaded CSS files and style\n * elements.\n *\n * @see Style\n * @package dompdf\n */\nclass Stylesheet\n{\n    /**\n     * The location of the default built-in CSS file.\n     */\n    const DEFAULT_STYLESHEET = \"/lib/res/html.css\";\n\n    /**\n     * User agent stylesheet origin\n     *\n     * @var int\n     */\n    const ORIG_UA = 1;\n\n    /**\n     * User normal stylesheet origin\n     *\n     * @var int\n     */\n    const ORIG_USER = 2;\n\n    /**\n     * Author normal stylesheet origin\n     *\n     * @var int\n     */\n    const ORIG_AUTHOR = 3;\n\n    /*\n     * The highest possible specificity is 0x01000000 (and that is only for author\n     * stylesheets, as it is for inline styles). Origin precedence can be achieved by\n     * adding multiples of 0x10000000 to the actual specificity. Important\n     * declarations are handled in Style; though technically they should be handled\n     * here so that user important declarations can be made to take precedence over\n     * user important declarations, this doesn't matter in practice as Dompdf does\n     * not support user stylesheets, and user agent stylesheets can not include\n     * important declarations.\n     */\n    private static $_stylesheet_origins = [\n        self::ORIG_UA => 0x00000000, // user agent declarations\n        self::ORIG_USER => 0x10000000, // user normal declarations\n        self::ORIG_AUTHOR => 0x30000000, // author normal declarations\n    ];\n\n    /**\n     * Non-CSS presentational hints (i.e. HTML 4 attributes) are handled as if added\n     * to the beginning of an author stylesheet, i.e. anything in author stylesheets\n     * should override them.\n     */\n    const SPEC_NON_CSS = 0x20000000;\n\n    /**\n     * Current dompdf instance\n     *\n     * @var Dompdf\n     */\n    private $_dompdf;\n\n    /**\n     * Array of currently defined styles\n     *\n     * @var Style[]\n     */\n    private $_styles;\n\n    /**\n     * Base protocol of the document being parsed\n     * Used to handle relative urls.\n     *\n     * @var string\n     */\n    private $_protocol = \"\";\n\n    /**\n     * Base hostname of the document being parsed\n     * Used to handle relative urls.\n     *\n     * @var string\n     */\n    private $_base_host = \"\";\n\n    /**\n     * Base path of the document being parsed\n     * Used to handle relative urls.\n     *\n     * @var string\n     */\n    private $_base_path = \"\";\n\n    /**\n     * The styles defined by @page rules\n     *\n     * @var array<Style>\n     */\n    private $_page_styles;\n\n    /**\n     * List of loaded files, used to prevent recursion\n     *\n     * @var array\n     */\n    private $_loaded_files;\n\n    /**\n     * Current stylesheet origin\n     *\n     * @var int\n     */\n    private $_current_origin = self::ORIG_UA;\n\n    /**\n     * Accepted CSS media types\n     * List of types and parsing rules for future extensions:\n     * http://www.w3.org/TR/REC-html40/types.html\n     *   screen, tty, tv, projection, handheld, print, braille, aural, all\n     * The following are non standard extensions for undocumented specific environments.\n     *   static, visual, bitmap, paged, dompdf\n     * Note, even though the generated pdf file is intended for print output,\n     * the desired content might be different (e.g. screen or projection view of html file).\n     * Therefore allow specification of content by dompdf setting Options::defaultMediaType.\n     * If given, replace media \"print\" by Options::defaultMediaType.\n     * (Previous version $ACCEPTED_MEDIA_TYPES = $ACCEPTED_GENERIC_MEDIA_TYPES + $ACCEPTED_DEFAULT_MEDIA_TYPE)\n     */\n    static $ACCEPTED_DEFAULT_MEDIA_TYPE = \"print\";\n    static $ACCEPTED_GENERIC_MEDIA_TYPES = [\"all\", \"static\", \"visual\", \"bitmap\", \"paged\", \"dompdf\"];\n    static $VALID_MEDIA_TYPES = [\"all\", \"aural\", \"bitmap\", \"braille\", \"dompdf\", \"embossed\", \"handheld\", \"paged\", \"print\", \"projection\", \"screen\", \"speech\", \"static\", \"tty\", \"tv\", \"visual\"];\n\n    /**\n     * @var FontMetrics\n     */\n    private $fontMetrics;\n\n    /**\n     * The class constructor.\n     *\n     * The base protocol, host & path are initialized to those of\n     * the current script.\n     */\n    function __construct(Dompdf $dompdf)\n    {\n        $this->_dompdf = $dompdf;\n        $this->setFontMetrics($dompdf->getFontMetrics());\n        $this->_styles = [];\n        $this->_loaded_files = [];\n        $script = __FILE__;\n        if (isset($_SERVER[\"SCRIPT_FILENAME\"])) {\n            $script = $_SERVER[\"SCRIPT_FILENAME\"];\n        }\n        list($this->_protocol, $this->_base_host, $this->_base_path) = Helpers::explode_url($script);\n        $this->_page_styles = [\"base\" => new Style($this)];\n    }\n\n    /**\n     * Set the base protocol\n     *\n     * @param string $protocol\n     */\n    function set_protocol(string $protocol)\n    {\n        $this->_protocol = $protocol;\n    }\n\n    /**\n     * Set the base host\n     *\n     * @param string $host\n     */\n    function set_host(string $host)\n    {\n        $this->_base_host = $host;\n    }\n\n    /**\n     * Set the base path\n     *\n     * @param string $path\n     */\n    function set_base_path(string $path)\n    {\n        $this->_base_path = $path;\n    }\n\n    /**\n     * Return the Dompdf object\n     *\n     * @return Dompdf\n     */\n    function get_dompdf()\n    {\n        return $this->_dompdf;\n    }\n\n    /**\n     * Return the base protocol for this stylesheet\n     *\n     * @return string\n     */\n    function get_protocol()\n    {\n        return $this->_protocol;\n    }\n\n    /**\n     * Return the base host for this stylesheet\n     *\n     * @return string\n     */\n    function get_host()\n    {\n        return $this->_base_host;\n    }\n\n    /**\n     * Return the base path for this stylesheet\n     *\n     * @return string\n     */\n    function get_base_path()\n    {\n        return $this->_base_path;\n    }\n\n    /**\n     * Return the array of page styles\n     *\n     * @return Style[]\n     */\n    function get_page_styles()\n    {\n        return $this->_page_styles;\n    }\n\n    /**\n     * Create a new Style object associated with this stylesheet\n     *\n     * @return Style\n     */\n    function create_style(): Style\n    {\n        return new Style($this, $this->_current_origin);\n    }\n\n    /**\n     * Add a new Style object to the stylesheet\n     *\n     * The style's origin is changed to the current origin of the stylesheet.\n     *\n     * @param string $key the Style's selector\n     * @param Style $style the Style to be added\n     */\n    function add_style(string $key, Style $style): void\n    {\n        if (!isset($this->_styles[$key])) {\n            $this->_styles[$key] = [];\n        }\n\n        $style->set_origin($this->_current_origin);\n        $this->_styles[$key][] = $style;\n    }\n\n    /**\n     * load and parse a CSS string\n     *\n     * @param string $css\n     * @param int $origin\n     */\n    function load_css(&$css, $origin = self::ORIG_AUTHOR)\n    {\n        if ($origin) {\n            $this->_current_origin = $origin;\n        }\n        $this->_parse_css($css);\n    }\n\n    /**\n     * load and parse a CSS file\n     *\n     * @param string $file\n     * @param int $origin\n     */\n    function load_css_file($file, $origin = self::ORIG_AUTHOR)\n    {\n        if ($origin) {\n            $this->_current_origin = $origin;\n        }\n\n        // Prevent circular references\n        if (isset($this->_loaded_files[$file])) {\n            return;\n        }\n\n        $this->_loaded_files[$file] = true;\n\n        if (strpos($file, \"data:\") === 0) {\n            $parsed = Helpers::parse_data_uri($file);\n            $css = $parsed[\"data\"];\n        } else {\n            $options = $this->_dompdf->getOptions();\n\n            $parsed_url = Helpers::explode_url($file);\n            $protocol = $parsed_url[\"protocol\"];\n\n            if ($file !== $this->getDefaultStylesheet()) {\n                $allowed_protocols = $options->getAllowedProtocols();\n                if (!array_key_exists($protocol, $allowed_protocols)) {\n                    Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $file. The communication protocol is not supported.\", __FILE__, __LINE__);\n                    return;\n                }\n                foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n                    [$result, $message] = $rule($file);\n                    if (!$result) {\n                        Helpers::record_warnings(E_USER_WARNING, \"Error loading $file: $message\", __FILE__, __LINE__);\n                        return;\n                    }\n                }\n            }\n\n            [$css, $http_response_header] = Helpers::getFileContent($file, $this->_dompdf->getHttpContext());\n\n            $good_mime_type = true;\n\n            // See http://the-stickman.com/web-development/php/getting-http-response-headers-when-using-file_get_contents/\n            if (isset($http_response_header) && !$this->_dompdf->getQuirksmode()) {\n                foreach ($http_response_header as $_header) {\n                    if (preg_match(\"@Content-Type:\\s*([\\w/]+)@i\", $_header, $matches) &&\n                        ($matches[1] !== \"text/css\")\n                    ) {\n                        $good_mime_type = false;\n                    }\n                }\n            }\n            if (!$good_mime_type || $css === null) {\n                Helpers::record_warnings(E_USER_WARNING, \"Unable to load css file $file\", __FILE__, __LINE__);\n                return;\n            }\n\n            [$this->_protocol, $this->_base_host, $this->_base_path] = $parsed_url;\n        }\n\n        $this->_parse_css($css);\n    }\n\n    /**\n     * @link http://www.w3.org/TR/CSS21/cascade.html#specificity\n     *\n     * @param string $selector\n     * @param int $origin :\n     *    - Stylesheet::ORIG_UA: user agent style sheet\n     *    - Stylesheet::ORIG_USER: user style sheet\n     *    - Stylesheet::ORIG_AUTHOR: author style sheet\n     *\n     * @return int\n     */\n    private function _specificity($selector, $origin = self::ORIG_AUTHOR)\n    {\n        // http://www.w3.org/TR/CSS21/cascade.html#specificity\n        // ignoring the \":\" pseudoclass modifiers\n        // also ignored in _css_selector_to_xpath\n\n        $a = ($selector === \"!attr\") ? 1 : 0;\n\n        $b = min(mb_substr_count($selector, \"#\"), 255);\n\n        $c = min(mb_substr_count($selector, \".\") +\n            mb_substr_count($selector, \"[\"), 255);\n\n        $d = min(mb_substr_count($selector, \" \") +\n            mb_substr_count($selector, \">\") +\n            mb_substr_count($selector, \"+\") +\n            mb_substr_count($selector, \"~\") -\n            mb_substr_count($selector, \"~=\"), 255);\n\n        //If a normal element name is at the beginning of the string,\n        //a leading whitespace might have been removed on whitespace collapsing and removal\n        //therefore there might be one whitespace less as selected element names\n        //this can lead to a too small specificity\n        //see _css_selector_to_xpath\n\n        if (!in_array($selector[0], [\" \", \">\", \".\", \"#\", \"+\", \"~\", \":\", \"[\"]) && $selector !== \"*\") {\n            $d++;\n        }\n\n        if ($this->_dompdf->getOptions()->getDebugCss()) {\n            /*DEBUGCSS*/\n            print \"<pre>\\n\";\n            /*DEBUGCSS*/\n            printf(\"_specificity(): 0x%08x \\\"%s\\\"\\n\", self::$_stylesheet_origins[$origin] + (($a << 24) | ($b << 16) | ($c << 8) | ($d)), $selector);\n            /*DEBUGCSS*/\n            print \"</pre>\";\n        }\n\n        return self::$_stylesheet_origins[$origin] + (($a << 24) | ($b << 16) | ($c << 8) | ($d));\n    }\n\n    /**\n     * Converts a CSS selector to an XPath query.\n     *\n     * @param string $selector\n     * @param bool $first_pass\n     *\n     * @throws Exception\n     * @return array\n     */\n    private function _css_selector_to_xpath(string $selector, bool $first_pass = false): array\n    {\n        // Collapse white space and strip whitespace around delimiters\n        //$search = array(\"/\\\\s+/\", \"/\\\\s+([.>#+:])\\\\s+/\");\n        //$replace = array(\" \", \"\\\\1\");\n        //$selector = preg_replace($search, $replace, trim($selector));\n\n        // Initial query (non-absolute)\n        $query = \"//\";\n\n        // Will contain :before and :after\n        $pseudo_elements = [];\n\n        // Will contain :link, etc\n        $pseudo_classes = [];\n\n        // Parse the selector\n        //$s = preg_split(\"/([ :>.#+])/\", $selector, -1, PREG_SPLIT_DELIM_CAPTURE);\n\n        $delimiters = [\" \", \">\", \".\", \"#\", \"+\", \"~\", \":\", \"[\", \"(\"];\n\n        // Add an implicit * at the beginning of the selector\n        // if it begins with an attribute selector\n        if ($selector[0] === \"[\") {\n            $selector = \"*$selector\";\n        }\n\n        // Add an implicit space at the beginning of the selector if there is no\n        // delimiter there already.\n        if (!in_array($selector[0], $delimiters)) {\n            $selector = \" $selector\";\n        }\n\n        $tok = \"\";\n        $len = mb_strlen($selector);\n        $i = 0;\n\n        while ($i < $len) {\n\n            $s = $selector[$i];\n            $i++;\n\n            // Eat characters up to the next delimiter\n            $tok = \"\";\n            $in_attr = false;\n            $in_func = false;\n\n            while ($i < $len) {\n                $c = $selector[$i];\n                $c_prev = $selector[$i - 1];\n\n                if (!$in_func && !$in_attr && in_array($c, $delimiters) && !(($c == $c_prev) == \":\")) {\n                    break;\n                }\n\n                if ($c_prev === \"[\") {\n                    $in_attr = true;\n                }\n                if ($c_prev === \"(\") {\n                    $in_func = true;\n                }\n\n                $tok .= $selector[$i++];\n\n                if ($in_attr && $c === \"]\") {\n                    $in_attr = false;\n                    break;\n                }\n                if ($in_func && $c === \")\") {\n                    $in_func = false;\n                    break;\n                }\n            }\n\n            switch ($s) {\n\n                case \" \":\n                case \">\":\n                    // All elements matching the next token that are direct children of\n                    // the current token\n                    $expr = $s === \" \" ? \"descendant\" : \"child\";\n\n                    if (mb_substr($query, -1, 1) !== \"/\") {\n                        $query .= \"/\";\n                    }\n\n                    // Tag names are case-insensitive\n                    $tok = strtolower($tok);\n\n                    if (!$tok) {\n                        $tok = \"*\";\n                    }\n\n                    $query .= \"$expr::$tok\";\n                    $tok = \"\";\n                    break;\n\n                case \".\":\n                case \"#\":\n                    // All elements matching the current token with a class/id equal to\n                    // the _next_ token.\n\n                    $attr = $s === \".\" ? \"class\" : \"id\";\n\n                    // empty class/id == *\n                    if (mb_substr($query, -1, 1) === \"/\") {\n                        $query .= \"*\";\n                    }\n\n                    // Match multiple classes: $tok contains the current selected\n                    // class.  Search for class attributes with class=\"$tok\",\n                    // class=\".* $tok .*\" and class=\".* $tok\"\n\n                    // This doesn't work because libxml only supports XPath 1.0...\n                    //$query .= \"[matches(@$attr,\\\"^{$tok}\\$|^{$tok}[ ]+|[ ]+{$tok}\\$|[ ]+{$tok}[ ]+\\\")]\";\n\n                    $query .= \"[contains(concat(' ', normalize-space(@$attr), ' '), concat(' ', '$tok', ' '))]\";\n                    $tok = \"\";\n                    break;\n\n                case \"+\":\n                case \"~\":\n                    // Next-sibling combinator\n                    // Subsequent-sibling combinator\n                    // https://www.w3.org/TR/selectors-3/#sibling-combinators\n                    if (mb_substr($query, -1, 1) !== \"/\") {\n                        $query .= \"/\";\n                    }\n\n                    // Tag names are case-insensitive\n                    $tok = strtolower($tok);\n\n                    if (!$tok) {\n                        $tok = \"*\";\n                    }\n\n                    $query .= \"following-sibling::$tok\";\n\n                    if ($s === \"+\") {\n                        $query .= \"[1]\";\n                    }\n\n                    $tok = \"\";\n                    break;\n\n                case \":\":\n                    $i2 = $i - strlen($tok) - 2; // the char before \":\"\n                    if (($i2 < 0 || !isset($selector[$i2]) || (in_array($selector[$i2], $delimiters) && $selector[$i2] != \":\")) && substr($query, -1) != \"*\") {\n                        $query .= \"*\";\n                    }\n\n                    $last = false;\n\n                    // Pseudo-classes\n                    switch ($tok) {\n\n                        case \"first-child\":\n                            $query .= \"[not(preceding-sibling::*)]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"last-child\":\n                            $query .= \"[not(following-sibling::*)]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"first-of-type\":\n                            $query .= \"[position() = 1]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"last-of-type\":\n                            $query .= \"[position() = last()]\";\n                            $tok = \"\";\n                            break;\n\n                        // an+b, n, odd, and even\n                        /** @noinspection PhpMissingBreakStatementInspection */\n                        case \"nth-last-of-type\":\n                            $last = true;\n                        case \"nth-of-type\":\n                            //FIXME: this fix-up is pretty ugly, would parsing the selector in reverse work better generally?\n                            $descendant_delimeter = strrpos($query, \"::\");\n                            $isChild = substr($query, $descendant_delimeter-5, 5) == \"child\";\n                            $el = substr($query, $descendant_delimeter+2);\n                            $query = substr($query, 0, strrpos($query, \"/\")) . ($isChild ? \"/\" : \"//\") . $el;\n\n                            $pseudo_classes[$tok] = true;\n                            $p = $i + 1;\n                            $nth = trim(mb_substr($selector, $p, strpos($selector, \")\", $i) - $p));\n                            $position = $last ? \"(last()-position()+1)\" : \"position()\";\n\n                            // 1\n                            if (preg_match(\"/^\\d+$/\", $nth)) {\n                                $condition = \"$position = $nth\";\n                            } // odd\n                            elseif ($nth === \"odd\") {\n                                $condition = \"($position mod 2) = 1\";\n                            } // even\n                            elseif ($nth === \"even\") {\n                                $condition = \"($position mod 2) = 0\";\n                            } // an+b\n                            else {\n                                $condition = $this->_selector_an_plus_b($nth, $last);\n                            }\n\n                            $query .= \"[$condition]\";\n                            $tok = \"\";\n                            break;\n                        /** @noinspection PhpMissingBreakStatementInspection */\n                        case \"nth-last-child\":\n                            $last = true;\n                        case \"nth-child\":\n                            //FIXME: this fix-up is pretty ugly, would parsing the selector in reverse work better generally?\n                            $descendant_delimeter = strrpos($query, \"::\");\n                            $isChild = substr($query, $descendant_delimeter-5, 5) == \"child\";\n                            $el = substr($query, $descendant_delimeter+2);\n                            $query = substr($query, 0, strrpos($query, \"/\")) . ($isChild ? \"/\" : \"//\") . \"*\";\n\n                            $pseudo_classes[$tok] = true;\n                            $p = $i + 1;\n                            $nth = trim(mb_substr($selector, $p, strpos($selector, \")\", $i) - $p));\n                            $position = $last ? \"(last()-position()+1)\" : \"position()\";\n\n                            // 1\n                            if (preg_match(\"/^\\d+$/\", $nth)) {\n                                $condition = \"$position = $nth\";\n                            } // odd\n                            elseif ($nth === \"odd\") {\n                                $condition = \"($position mod 2) = 1\";\n                            } // even\n                            elseif ($nth === \"even\") {\n                                $condition = \"($position mod 2) = 0\";\n                            } // an+b\n                            else {\n                                $condition = $this->_selector_an_plus_b($nth, $last);\n                            }\n\n                            $query .= \"[$condition]\";\n                            if ($el != \"*\") {\n                                $query .= \"[name() = '$el']\";\n                            }\n                            $tok = \"\";\n                            break;\n\n                        //TODO: bit of a hack attempt at matches support, currently only matches against elements\n                        case \"matches\":\n                            $pseudo_classes[$tok] = true;\n                            $p = $i + 1;\n                            $matchList = trim(mb_substr($selector, $p, strpos($selector, \")\", $i) - $p));\n\n                            // Tag names are case-insensitive\n                            $elements = array_map(\"trim\", explode(\",\", strtolower($matchList)));\n                            foreach ($elements as &$element) {\n                                $element = \"name() = '$element'\";\n                            }\n\n                            $query .= \"[\" . implode(\" or \", $elements) . \"]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"link\":\n                            $query .= \"[@href]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"first-line\":\n                        case \":first-line\":\n                        case \"first-letter\":\n                        case \":first-letter\":\n                            // TODO\n                            $el = trim($tok, \":\");\n                            $pseudo_elements[$el] = true;\n                            break;\n\n                            // N/A\n                        case \"focus\":\n                        case \"active\":\n                        case \"hover\":\n                        case \"visited\":\n                            $query .= \"[false()]\";\n                            $tok = \"\";\n                            break;\n\n                        /* Pseudo-elements */\n                        case \"before\":\n                        case \":before\":\n                        case \"after\":\n                        case \":after\":\n                            $pos = trim($tok, \":\");\n                            $pseudo_elements[$pos] = true;\n                            if (!$first_pass) {\n                                $query .= \"/*[@$pos]\";\n                            }\n\n                            $tok = \"\";\n                            break;\n\n                        case \"empty\":\n                            $query .= \"[not(*) and not(normalize-space())]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"disabled\":\n                        case \"checked\":\n                            $query .= \"[@$tok]\";\n                            $tok = \"\";\n                            break;\n\n                        case \"enabled\":\n                            $query .= \"[not(@disabled)]\";\n                            $tok = \"\";\n                            break;\n\n                        // the selector is not handled, until we support all possible selectors force an empty set (silent failure)\n                        default:\n                            $query = \"/../..\"; // go up two levels because generated content starts on the body element\n                            $tok = \"\";\n                            break;\n                    }\n\n                    break;\n\n                case \"[\":\n                    // Attribute selectors.  All with an attribute matching the following token(s)\n                    // https://www.w3.org/TR/selectors-3/#attribute-selectors\n                    $attr_delimiters = [\"=\", \"]\", \"~\", \"|\", \"$\", \"^\", \"*\"];\n                    $tok_len = mb_strlen($tok);\n                    $j = 0;\n\n                    $attr = \"\";\n                    $op = \"\";\n                    $value = \"\";\n\n                    while ($j < $tok_len) {\n                        if (in_array($tok[$j], $attr_delimiters)) {\n                            break;\n                        }\n                        $attr .= $tok[$j++];\n                    }\n\n                    switch ($tok[$j]) {\n\n                        case \"~\":\n                        case \"|\":\n                        case \"$\":\n                        case \"^\":\n                        case \"*\":\n                            $op .= $tok[$j++];\n\n                            if ($tok[$j] !== \"=\") {\n                                throw new Exception(\"Invalid CSS selector syntax: invalid attribute selector: $selector\");\n                            }\n\n                            $op .= $tok[$j];\n                            break;\n\n                        case \"=\":\n                            $op = \"=\";\n                            break;\n\n                    }\n\n                    // Read the attribute value, if required\n                    if ($op != \"\") {\n                        $j++;\n                        while ($j < $tok_len) {\n                            if ($tok[$j] === \"]\") {\n                                break;\n                            }\n                            $value .= $tok[$j++];\n                        }\n                    }\n\n                    if ($attr == \"\") {\n                        throw new Exception(\"Invalid CSS selector syntax: missing attribute name\");\n                    }\n\n                    $value = trim($value, \"\\\"'\");\n\n                    switch ($op) {\n\n                        case \"\":\n                            $query .= \"[@$attr]\";\n                            break;\n\n                        case \"=\":\n                            $query .= \"[@$attr=\\\"$value\\\"]\";\n                            break;\n\n                        case \"~=\":\n                            // FIXME: this will break if $value contains quoted strings\n                            // (e.g. [type~=\"a b c\" \"d e f\"])\n                            // FIXME: Don't match anything if value contains\n                            // whitespace or is the empty string\n                            $query .= \"[contains(concat(' ', normalize-space(@$attr), ' '), concat(' ', '$value', ' '))]\";\n                            break;\n\n                        case \"|=\":\n                            $values = explode(\"-\", $value);\n                            $query .= \"[\";\n\n                            foreach ($values as $val) {\n                                $query .= \"starts-with(@$attr, \\\"$val\\\") or \";\n                            }\n\n                            $query = rtrim($query, \" or \") . \"]\";\n                            break;\n\n                        case \"$=\":\n                            $query .= \"[substring(@$attr, string-length(@$attr)-\" . (strlen($value) - 1) . \")=\\\"$value\\\"]\";\n                            break;\n\n                        case \"^=\":\n                            $query .= \"[starts-with(@$attr,\\\"$value\\\")]\";\n                            break;\n\n                        case \"*=\":\n                            $query .= \"[contains(@$attr,\\\"$value\\\")]\";\n                            break;\n                    }\n\n                    break;\n            }\n        }\n        $i++;\n\n//       case \":\":\n//         // Pseudo selectors: ignore for now.  Partially handled directly\n//         // below.\n\n//         // Skip until the next special character, leaving the token as-is\n//         while ( $i < $len ) {\n//           if ( in_array($selector[$i], $delimiters) )\n//             break;\n//           $i++;\n//         }\n//         break;\n\n//       default:\n//         // Add the character to the token\n//         $tok .= $selector[$i++];\n//         break;\n//       }\n\n//    }\n\n\n        // Trim the trailing '/' from the query\n        if (mb_strlen($query) > 2) {\n            $query = rtrim($query, \"/\");\n        }\n\n        return ['query' => $query, 'pseudo_elements' => $pseudo_elements];\n    }\n\n    /**\n     * https://github.com/tenderlove/nokogiri/blob/master/lib/nokogiri/css/xpath_visitor.rb\n     *\n     * @param string $expr\n     * @param bool $last\n     *\n     * @return string\n     */\n    protected function _selector_an_plus_b(string $expr, bool $last = false): string\n    {\n        $expr = preg_replace(\"/\\s/\", \"\", $expr);\n        if (!preg_match(\"/^(?P<a>-?[0-9]*)?n(?P<b>[-+]?[0-9]+)?$/\", $expr, $matches)) {\n            return \"false()\";\n        }\n\n        $a = (isset($matches[\"a\"]) && $matches[\"a\"] !== \"\") ? ($matches[\"a\"] !== \"-\" ? intval($matches[\"a\"]) : -1) : 1;\n        $b = (isset($matches[\"b\"]) && $matches[\"b\"] !== \"\") ? intval($matches[\"b\"]) : 0;\n\n        $position = $last ? \"(last()-position()+1)\" : \"position()\";\n\n        if ($b == 0) {\n            return \"($position mod $a) = 0\";\n        } else {\n            $compare = ($a < 0) ? \"<=\" : \">=\";\n            $b2 = -$b;\n            if ($b2 >= 0) {\n                $b2 = \"+$b2\";\n            }\n            return \"($position $compare $b) and ((($position $b2) mod \" . abs($a) . \") = 0)\";\n        }\n    }\n\n    /**\n     * applies all current styles to a particular document tree\n     *\n     * apply_styles() applies all currently loaded styles to the provided\n     * {@link FrameTree}.  Aside from parsing CSS, this is the main purpose\n     * of this class.\n     *\n     * @param \\Dompdf\\Frame\\FrameTree $tree\n     */\n    function apply_styles(FrameTree $tree)\n    {\n        // Use XPath to select nodes.  This would be easier if we could attach\n        // Frame objects directly to DOMNodes using the setUserData() method, but\n        // we can't do that just yet.  Instead, we set a _node attribute_ in\n        // Frame->set_id() and use that as a handle on the Frame object via\n        // FrameTree::$_registry.\n\n        // We create a scratch array of styles indexed by frame id.  Once all\n        // styles have been assigned, we order the cached styles by specificity\n        // and create a final style object to assign to the frame.\n\n        // FIXME: this is not particularly robust...\n\n        $styles = [];\n        $xp = new DOMXPath($tree->get_dom());\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n\n        // Add generated content\n        foreach ($this->_styles as $selector => $selector_styles) {\n            /** @var Style $style */\n            foreach ($selector_styles as $style) {\n                if (strpos($selector, \":before\") === false && strpos($selector, \":after\") === false) {\n                    continue;\n                }\n\n                $query = $this->_css_selector_to_xpath($selector, true);\n\n                // Retrieve the nodes, limit to body for generated content\n                //TODO: If we use a context node can we remove the leading dot?\n                $nodes = @$xp->query('.' . $query[\"query\"]);\n                if ($nodes === false) {\n                    Helpers::record_warnings(E_USER_WARNING, \"The CSS selector '$selector' is not valid\", __FILE__, __LINE__);\n                    continue;\n                }\n\n                /** @var \\DOMElement $node */\n                foreach ($nodes as $node) {\n                    // Only DOMElements get styles\n                    if ($node->nodeType != XML_ELEMENT_NODE) {\n                        continue;\n                    }\n\n                    foreach (array_keys($query[\"pseudo_elements\"], true, true) as $pos) {\n                        // Do not add a new pseudo element if another one already matched\n                        if ($node->hasAttribute(\"dompdf_{$pos}_frame_id\")) {\n                            continue;\n                        }\n\n                        $content = $style->get_specified(\"content\");\n\n                        // Do not create non-displayed before/after pseudo elements\n                        // https://www.w3.org/TR/CSS21/generate.html#content\n                        // https://www.w3.org/TR/CSS21/generate.html#undisplayed-counters\n                        if ($content === \"normal\" || $content === \"none\") {\n                            continue;\n                        }\n\n                        if (($src = $this->resolve_url($content)) !== \"none\") {\n                            $new_node = $node->ownerDocument->createElement(\"img_generated\");\n                            $new_node->setAttribute(\"src\", $src);\n                        } else {\n                            $new_node = $node->ownerDocument->createElement(\"dompdf_generated\");\n                        }\n\n                        $new_node->setAttribute($pos, $pos);\n                        $new_frame_id = $tree->insert_node($node, $new_node, $pos);\n                        $node->setAttribute(\"dompdf_{$pos}_frame_id\", $new_frame_id);\n                    }\n                }\n            }\n        }\n\n        // Apply all styles in stylesheet\n        foreach ($this->_styles as $selector => $selector_styles) {\n            /** @var Style $style */\n            foreach ($selector_styles as $style) {\n                $query = $this->_css_selector_to_xpath($selector);\n\n                // Retrieve the nodes\n                $nodes = @$xp->query($query[\"query\"]);\n                if ($nodes === false) {\n                    Helpers::record_warnings(E_USER_WARNING, \"The CSS selector '$selector' is not valid\", __FILE__, __LINE__);\n                    continue;\n                }\n\n                $spec = $this->_specificity($selector, $style->get_origin());\n\n                foreach ($nodes as $node) {\n                    // Retrieve the node id\n                    // Only DOMElements get styles\n                    if ($node->nodeType != XML_ELEMENT_NODE) {\n                        continue;\n                    }\n\n                    $id = $node->getAttribute(\"frame_id\");\n\n                    // Assign the current style to the scratch array\n                    $styles[$id][$spec][] = $style;\n                }\n            }\n        }\n\n        // Set the page width, height, and orientation based on the canvas paper size\n        $canvas = $this->_dompdf->getCanvas();\n        $paper_width = $canvas->get_width();\n        $paper_height = $canvas->get_height();\n        $paper_orientation = ($paper_width > $paper_height ? \"landscape\" : \"portrait\");\n\n        if ($this->_page_styles[\"base\"] && is_array($this->_page_styles[\"base\"]->size)) {\n            $paper_width = $this->_page_styles['base']->size[0];\n            $paper_height = $this->_page_styles['base']->size[1];\n            $paper_orientation = ($paper_width > $paper_height ? \"landscape\" : \"portrait\");\n        }\n\n        // Now create the styles and assign them to the appropriate frames. (We\n        // iterate over the tree using an implicit FrameTree iterator.)\n        $root_flg = false;\n        foreach ($tree as $frame) {\n            // Helpers::pre_r($frame->get_node()->nodeName . \":\");\n            if (!$root_flg && $this->_page_styles[\"base\"]) {\n                $style = $this->_page_styles[\"base\"];\n            } else {\n                $style = $this->create_style();\n            }\n\n            // Find nearest DOMElement parent\n            $p = $frame;\n            while ($p = $p->get_parent()) {\n                if ($p->get_node()->nodeType === XML_ELEMENT_NODE) {\n                    break;\n                }\n            }\n\n            // Styles can only be applied directly to DOMElements; anonymous\n            // frames inherit from their parent\n            if ($frame->get_node()->nodeType !== XML_ELEMENT_NODE) {\n                $style->inherit($p ? $p->get_style() : null);\n                $frame->set_style($style);\n                continue;\n            }\n\n            $id = $frame->get_id();\n\n            // Handle HTML 4.0 attributes\n            AttributeTranslator::translate_attributes($frame);\n            if (($str = $frame->get_node()->getAttribute(AttributeTranslator::$_style_attr)) !== \"\") {\n                $styles[$id][self::SPEC_NON_CSS][] = $this->_parse_properties($str);\n            }\n\n            // Locate any additional style attributes\n            if (($str = $frame->get_node()->getAttribute(\"style\")) !== \"\") {\n                // Destroy CSS comments\n                $str = preg_replace(\"'/\\*.*?\\*/'si\", \"\", $str);\n\n                $spec = $this->_specificity(\"!attr\", self::ORIG_AUTHOR);\n                $styles[$id][$spec][] = $this->_parse_properties($str);\n            }\n\n            // Grab the applicable styles\n            if (isset($styles[$id])) {\n\n                /** @var array[][] $applied_styles */\n                $applied_styles = $styles[$id];\n\n                // Sort by specificity\n                ksort($applied_styles);\n\n                if ($DEBUGCSS) {\n                    $debug_nodename = $frame->get_node()->nodeName;\n                    print \"<pre>\\n$debug_nodename [\\n\";\n                    foreach ($applied_styles as $spec => $arr) {\n                        printf(\"  specificity 0x%08x\\n\", $spec);\n                        /** @var Style $s */\n                        foreach ($arr as $s) {\n                            print \"  [\\n\";\n                            $s->debug_print();\n                            print \"  ]\\n\";\n                        }\n                    }\n                }\n\n                // Merge the new styles with the inherited styles\n                $acceptedmedia = self::$ACCEPTED_GENERIC_MEDIA_TYPES;\n                $acceptedmedia[] = $this->_dompdf->getOptions()->getDefaultMediaType();\n                foreach ($applied_styles as $arr) {\n                    /** @var Style $s */\n                    foreach ($arr as $s) {\n                        $media_queries = $s->get_media_queries();\n                        foreach ($media_queries as $media_query) {\n                            list($media_query_feature, $media_query_value) = $media_query;\n                            // if any of the Style's media queries fail then do not apply the style\n                            //TODO: When the media query logic is fully developed we should not apply the Style when any of the media queries fail or are bad, per https://www.w3.org/TR/css3-mediaqueries/#error-handling\n                            if (in_array($media_query_feature, self::$VALID_MEDIA_TYPES)) {\n                                if ((strlen($media_query_feature) === 0 && !in_array($media_query, $acceptedmedia)) || (in_array($media_query, $acceptedmedia) && $media_query_value == \"not\")) {\n                                    continue (3);\n                                }\n                            } else {\n                                switch ($media_query_feature) {\n                                    case \"height\":\n                                        if ($paper_height !== (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"min-height\":\n                                        if ($paper_height < (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"max-height\":\n                                        if ($paper_height > (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"width\":\n                                        if ($paper_width !== (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"min-width\":\n                                        //if (min($paper_width, $media_query_width) === $paper_width) {\n                                        if ($paper_width < (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"max-width\":\n                                        //if (max($paper_width, $media_query_width) === $paper_width) {\n                                        if ($paper_width > (float)$style->length_in_pt($media_query_value)) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    case \"orientation\":\n                                        if ($paper_orientation !== $media_query_value) {\n                                            continue (3);\n                                        }\n                                        break;\n                                    default:\n                                        Helpers::record_warnings(E_USER_WARNING, \"Unknown media query: $media_query_feature\", __FILE__, __LINE__);\n                                        break;\n                                }\n                            }\n                        }\n\n                        $style->merge($s);\n                    }\n                }\n            }\n\n            // Handle inheritance\n            if ($p && $DEBUGCSS) {\n                print \"  inherit [\\n\";\n                $p->get_style()->debug_print();\n                print \"  ]\\n\";\n            }\n\n            $style->inherit($p ? $p->get_style() : null);\n\n            if ($DEBUGCSS) {\n                print \"  DomElementStyle [\\n\";\n                $style->debug_print();\n                print \"  ]\\n\";\n                print \"]\\n</pre>\";\n            }\n\n            $style->clear_important();\n            $frame->set_style($style);\n\n            if (!$root_flg && $this->_page_styles[\"base\"]) {\n                $root_flg = true;\n\n                // set the page width, height, and orientation based on the parsed page style\n                if ($style->size !== \"auto\") {\n                    list($paper_width, $paper_height) = $style->size;\n                }\n                $paper_width = $paper_width - (float)$style->length_in_pt($style->margin_left) - (float)$style->length_in_pt($style->margin_right);\n                $paper_height = $paper_height - (float)$style->length_in_pt($style->margin_top) - (float)$style->length_in_pt($style->margin_bottom);\n                $paper_orientation = ($paper_width > $paper_height ? \"landscape\" : \"portrait\");\n            }\n        }\n\n        // We're done!  Clean out the registry of all styles since we\n        // won't be needing this later.\n        foreach (array_keys($this->_styles) as $key) {\n            $this->_styles[$key] = null;\n            unset($this->_styles[$key]);\n        }\n    }\n\n    /**\n     * parse a CSS string using a regex parser\n     * Called by {@link Stylesheet::parse_css()}\n     *\n     * @param string $str\n     *\n     * @throws Exception\n     */\n    private function _parse_css($str)\n    {\n        $str = trim($str);\n\n        // Destroy comments and remove HTML comments\n        $css = preg_replace([\n            \"'/\\*.*?\\*/'si\",\n            \"/^<!--/\",\n            \"/-->$/\"\n        ], \"\", $str);\n\n        // FIXME: handle '{' within strings, e.g. [attr=\"string {}\"]\n\n        // Something more legible:\n        $re =\n            \"/\\s*                                   # Skip leading whitespace                             \\n\" .\n            \"( @([^\\s{]+)\\s*([^{;]*) (?:;|({)) )?   # Match @rules followed by ';' or '{'                 \\n\" .\n            \"(?(1)                                  # Only parse sub-sections if we're in an @rule...     \\n\" .\n            \"  (?(4)                                # ...and if there was a leading '{'                   \\n\" .\n            \"    \\s*( (?:(?>[^{}]+) ({)?            # Parse rulesets and individual @page rules           \\n\" .\n            \"            (?(6) (?>[^}]*) }) \\s*)+?                                                        \\n\" .\n            \"       )                                                                                     \\n\" .\n            \"   })                                  # Balancing '}'                                       \\n\" .\n            \"|                                      # Branch to match regular rules (not preceded by '@') \\n\" .\n            \"([^{]*{[^}]*}))                        # Parse normal rulesets                               \\n\" .\n            \"/xs\";\n\n        if (preg_match_all($re, $css, $matches, PREG_SET_ORDER) === false) {\n            // An error occurred\n            throw new Exception(\"Error parsing css file: preg_match_all() failed.\");\n        }\n\n        // After matching, the array indices are set as follows:\n        //\n        // [0] => complete text of match\n        // [1] => contains '@import ...;' or '@media {' if applicable\n        // [2] => text following @ for cases where [1] is set\n        // [3] => media types or full text following '@import ...;'\n        // [4] => '{', if present\n        // [5] => rulesets within media rules\n        // [6] => '{', within media rules\n        // [7] => individual rules, outside of media rules\n        //\n\n        $media_query_regex = \"/(?:((only|not)?\\s*(\" . implode(\"|\", self::$VALID_MEDIA_TYPES) . \"))|(\\s*\\(\\s*((?:(min|max)-)?([\\w\\-]+))\\s*(?:\\:\\s*(.*?)\\s*)?\\)))/isx\";\n\n        //Helpers::pre_r($matches);\n        foreach ($matches as $match) {\n            $match[2] = trim($match[2]);\n\n            if ($match[2] !== \"\") {\n                // Handle @rules\n                switch ($match[2]) {\n\n                    case \"import\":\n                        $this->_parse_import($match[3]);\n                        break;\n\n                    case \"media\":\n                        $acceptedmedia = self::$ACCEPTED_GENERIC_MEDIA_TYPES;\n                        $acceptedmedia[] = $this->_dompdf->getOptions()->getDefaultMediaType();\n\n                        $media_queries = preg_split(\"/\\s*,\\s*/\", mb_strtolower(trim($match[3])));\n                        foreach ($media_queries as $media_query) {\n                            if (in_array($media_query, $acceptedmedia)) {\n                                //if we have a media type match go ahead and parse the stylesheet\n                                $this->_parse_sections($match[5]);\n                                break;\n                            } elseif (!in_array($media_query, self::$VALID_MEDIA_TYPES)) {\n                                // otherwise conditionally parse the stylesheet assuming there are parseable media queries\n                                if (preg_match_all($media_query_regex, $media_query, $media_query_matches, PREG_SET_ORDER) !== false) {\n                                    $mq = [];\n                                    foreach ($media_query_matches as $media_query_match) {\n                                        if (empty($media_query_match[1]) === false) {\n                                            $media_query_feature = strtolower($media_query_match[3]);\n                                            $media_query_value = strtolower($media_query_match[2]);\n                                            $mq[] = [$media_query_feature, $media_query_value];\n                                        } else if (empty($media_query_match[4]) === false) {\n                                            $media_query_feature = strtolower($media_query_match[5]);\n                                            $media_query_value = (array_key_exists(8, $media_query_match) ? strtolower($media_query_match[8]) : null);\n                                            $mq[] = [$media_query_feature, $media_query_value];\n                                        }\n                                    }\n                                    $this->_parse_sections($match[5], $mq);\n                                    break;\n                                }\n                            }\n                        }\n                        break;\n\n                    case \"page\":\n                        //This handles @page to be applied to page oriented media\n                        //Note: This has a reduced syntax:\n                        //@page { margin:1cm; color:blue; }\n                        //Not a sequence of styles like a full.css, but only the properties\n                        //of a single style, which is applied to the very first \"root\" frame before\n                        //processing other styles of the frame.\n                        //Working properties:\n                        // margin (for margin around edge of paper)\n                        // font-family (default font of pages)\n                        // color (default text color of pages)\n                        //Non working properties:\n                        // border\n                        // padding\n                        // background-color\n                        //Todo:Reason is unknown\n                        //Other properties (like further font or border attributes) not tested.\n                        //If a border or background color around each paper sheet is desired,\n                        //assign it to the <body> tag, possibly only for the css of the correct media type.\n\n                        // If the page has a name, skip the style.\n                        $page_selector = trim($match[3]);\n\n                        $key = null;\n                        switch ($page_selector) {\n                            case \"\":\n                                $key = \"base\";\n                                break;\n\n                            case \":left\":\n                            case \":right\":\n                            case \":odd\":\n                            case \":even\":\n                            /** @noinspection PhpMissingBreakStatementInspection */\n                            case \":first\":\n                                $key = $page_selector;\n                                break;\n\n                            default:\n                                break 2;\n                        }\n\n                        // Store the style for later...\n                        if (empty($this->_page_styles[$key])) {\n                            $this->_page_styles[$key] = $this->_parse_properties($match[5]);\n                        } else {\n                            $this->_page_styles[$key]->merge($this->_parse_properties($match[5]));\n                        }\n                        break;\n\n                    case \"font-face\":\n                        $this->_parse_font_face($match[5]);\n                        break;\n\n                    default:\n                        // ignore everything else\n                        break;\n                }\n\n                continue;\n            }\n\n            if ($match[7] !== \"\") {\n                $this->_parse_sections($match[7]);\n            }\n        }\n    }\n\n    /**\n     * Resolve the given `url()` declaration to an absolute URL.\n     *\n     * @param string|null $val The declaration to resolve in the context of the stylesheet.\n     * @return string The resolved URL, or `none`, if the value is `none`,\n     *         invalid, or points to a non-existent local file.\n     */\n    public function resolve_url($val): string\n    {\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n        $parsed_url = \"none\";\n\n        if (empty($val) || $val === \"none\") {\n            $path = \"none\";\n        } elseif (mb_strpos($val, \"url\") === false) {\n            $path = \"none\"; //Don't resolve no image -> otherwise would prefix path and no longer recognize as none\n        } else {\n            $val = preg_replace(\"/url\\(\\s*['\\\"]?([^'\\\")]+)['\\\"]?\\s*\\)/\", \"\\\\1\", trim($val));\n\n            // Resolve the url now in the context of the current stylesheet\n            $path = Helpers::build_url($this->_protocol,\n                $this->_base_host,\n                $this->_base_path,\n                $val);\n            if ($path === null) {\n                $path = \"none\";\n            }\n        }\n        if ($DEBUGCSS) {\n            $parsed_url = Helpers::explode_url($path);\n            print \"<pre>[_image\\n\";\n            print_r($parsed_url);\n            print $this->_protocol . \"\\n\" . $this->_base_path . \"\\n\" . $path . \"\\n\";\n            print \"_image]</pre>\";\n        }\n        return $path;\n    }\n\n    /**\n     * parse @import{} sections\n     *\n     * @param string $url the url of the imported CSS file\n     */\n    private function _parse_import($url)\n    {\n        $arr = preg_split(\"/[\\s\\n,]/\", $url, -1, PREG_SPLIT_NO_EMPTY);\n        $url = array_shift($arr);\n        $accept = false;\n\n        if (count($arr) > 0) {\n            $acceptedmedia = self::$ACCEPTED_GENERIC_MEDIA_TYPES;\n            $acceptedmedia[] = $this->_dompdf->getOptions()->getDefaultMediaType();\n\n            // @import url media_type [media_type...]\n            foreach ($arr as $type) {\n                if (in_array(mb_strtolower(trim($type)), $acceptedmedia)) {\n                    $accept = true;\n                    break;\n                }\n            }\n\n        } else {\n            // unconditional import\n            $accept = true;\n        }\n\n        if ($accept) {\n            // Store our current base url properties in case the new url is elsewhere\n            $protocol = $this->_protocol;\n            $host = $this->_base_host;\n            $path = $this->_base_path;\n\n            // $url = str_replace(array('\"',\"url\", \"(\", \")\"), \"\", $url);\n            // If the protocol is php, assume that we will import using file://\n            // $url = Helpers::build_url($protocol === \"php://\" ? \"file://\" : $protocol, $host, $path, $url);\n            // Above does not work for subfolders and absolute urls.\n            // Todo: As above, do we need to replace php or file to an empty protocol for local files?\n\n            if (($url = $this->resolve_url($url)) !== \"none\") {\n                $this->load_css_file($url);\n            }\n\n            // Restore the current base url\n            $this->_protocol = $protocol;\n            $this->_base_host = $host;\n            $this->_base_path = $path;\n        }\n    }\n\n    /**\n     * parse @font-face{} sections\n     * http://www.w3.org/TR/css3-fonts/#the-font-face-rule\n     *\n     * @param string $str CSS @font-face rules\n     */\n    private function _parse_font_face($str)\n    {\n        $descriptors = $this->_parse_properties($str);\n\n        preg_match_all(\"/(url|local)\\s*\\([\\\"\\']?([^\\\"\\'\\)]+)[\\\"\\']?\\)\\s*(format\\s*\\([\\\"\\']?([^\\\"\\'\\)]+)[\\\"\\']?\\))?/i\", $descriptors->src, $src);\n\n        $sources = [];\n        $valid_sources = [];\n\n        foreach ($src[0] as $i => $value) {\n            $source = [\n                \"local\" => strtolower($src[1][$i]) === \"local\",\n                \"uri\" => $src[2][$i],\n                \"format\" => strtolower($src[4][$i]),\n                \"path\" => Helpers::build_url($this->_protocol, $this->_base_host, $this->_base_path, $src[2][$i]),\n            ];\n\n            if (!$source[\"local\"] && in_array($source[\"format\"], [\"\", \"truetype\"])) {\n                $valid_sources[] = $source;\n            }\n\n            $sources[] = $source;\n        }\n\n        // No valid sources\n        if (empty($valid_sources)) {\n            return;\n        }\n\n        $style = [\n            \"family\" => $descriptors->get_font_family_raw(),\n            \"weight\" => $descriptors->font_weight,\n            \"style\" => $descriptors->font_style,\n        ];\n\n        $this->getFontMetrics()->registerFont($style, $valid_sources[0][\"path\"], $this->_dompdf->getHttpContext());\n    }\n\n    /**\n     * parse regular CSS blocks\n     *\n     * _parse_properties() creates a new Style object based on the provided\n     * CSS rules.\n     *\n     * @param string $str CSS rules\n     * @return Style\n     */\n    private function _parse_properties($str)\n    {\n        $properties = preg_split(\"/;(?=(?:[^\\(]*\\([^\\)]*\\))*(?![^\\)]*\\)))/\", $str);\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n\n        if ($DEBUGCSS) {\n            print '[_parse_properties';\n        }\n\n        // Create the style\n        $style = new Style($this, Stylesheet::ORIG_AUTHOR);\n\n        foreach ($properties as $prop) {\n            // If the $prop contains an url, the regex may be wrong\n            // @todo: fix the regex so that it works every time\n            /*if (strpos($prop, \"url(\") === false) {\n              if (preg_match(\"/([a-z-]+)\\s*:\\s*[^:]+$/i\", $prop, $m))\n                $prop = $m[0];\n            }*/\n\n            //A css property can have \" ! important\" appended (whitespace optional)\n            //strip this off to decode core of the property correctly.\n\n            /* Instead of short code, prefer the typical case with fast code\n          $important = preg_match(\"/(.*?)!\\s*important/\",$prop,$match);\n            if ( $important ) {\n              $prop = $match[1];\n            }\n            $prop = trim($prop);\n            */\n            if ($DEBUGCSS) print '(';\n\n            $important = false;\n            $prop = trim($prop);\n\n            if (substr($prop, -9) === 'important') {\n                $prop_tmp = rtrim(substr($prop, 0, -9));\n\n                if (substr($prop_tmp, -1) === '!') {\n                    $prop = rtrim(substr($prop_tmp, 0, -1));\n                    $important = true;\n                }\n            }\n\n            if ($prop === \"\") {\n                if ($DEBUGCSS) print 'empty)';\n                continue;\n            }\n\n            $i = mb_strpos($prop, \":\");\n            if ($i === false) {\n                if ($DEBUGCSS) print 'novalue' . $prop . ')';\n                continue;\n            }\n\n            $prop_name = rtrim(mb_strtolower(mb_substr($prop, 0, $i)));\n            $value = ltrim(mb_substr($prop, $i + 1));\n\n            if ($DEBUGCSS) print $prop_name . ':=' . $value . ($important ? '!IMPORTANT' : '') . ')';\n\n            $style->set_prop($prop_name, $value, $important, false);\n        }\n        if ($DEBUGCSS) print '_parse_properties]';\n\n        return $style;\n    }\n\n    /**\n     * parse selector + rulesets\n     *\n     * @param string $str CSS selectors and rulesets\n     * @param array $media_queries\n     */\n    private function _parse_sections($str, $media_queries = [])\n    {\n        // Pre-process selectors: collapse all whitespace and strip whitespace\n        // around '>', '.', ':', '+', '~', '#'\n        $patterns = [\"/\\s+/\", \"/\\s+([>.:+~#])\\s+/\"];\n        $replacements = [\" \", \"\\\\1\"];\n        $DEBUGCSS = $this->_dompdf->getOptions()->getDebugCss();\n\n        $sections = explode(\"}\", $str);\n        if ($DEBUGCSS) print '[_parse_sections';\n        foreach ($sections as $sect) {\n            $i = mb_strpos($sect, \"{\");\n            if ($i === false) { continue; }\n\n            if ($DEBUGCSS) print '[section';\n\n            $selector_str = preg_replace($patterns, $replacements, mb_substr($sect, 0, $i));\n            $selectors = preg_split(\"/,(?![^\\(]*\\))/\", $selector_str, 0, PREG_SPLIT_NO_EMPTY);\n            $style = $this->_parse_properties(trim(mb_substr($sect, $i + 1)));\n\n            // Assign it to the selected elements\n            foreach ($selectors as $selector) {\n                $selector = trim($selector);\n\n                if ($selector == \"\") {\n                    if ($DEBUGCSS) print '#empty#';\n                    continue;\n                }\n                if ($DEBUGCSS) print '#' . $selector . '#';\n                //if ($DEBUGCSS) { if (strpos($selector,'p') !== false) print '!!!p!!!#'; }\n\n                //FIXME: tag the selector with a hash of the media query to separate it from non-conditional styles (?), xpath comments are probably not what we want to do here\n                if (count($media_queries) > 0) {\n                    $style->set_media_queries($media_queries);\n                }\n                $this->add_style($selector, $style);\n            }\n\n            if ($DEBUGCSS) {\n                print 'section]';\n            }\n        }\n\n        if ($DEBUGCSS) {\n            print \"_parse_sections]\\n\";\n        }\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultStylesheet()\n    {\n        $options = $this->_dompdf->getOptions();\n        $rootDir = realpath($options->getRootDir());\n        return Helpers::build_url(\"file://\", \"\", $rootDir, $rootDir . self::DEFAULT_STYLESHEET);\n    }\n\n    /**\n     * @param FontMetrics $fontMetrics\n     * @return $this\n     */\n    public function setFontMetrics(FontMetrics $fontMetrics)\n    {\n        $this->fontMetrics = $fontMetrics;\n        return $this;\n    }\n\n    /**\n     * @return FontMetrics\n     */\n    public function getFontMetrics()\n    {\n        return $this->fontMetrics;\n    }\n\n    /**\n     * dumps the entire stylesheet as a string\n     *\n     * Generates a string of each selector and associated style in the\n     * Stylesheet.  Useful for debugging.\n     *\n     * @return string\n     */\n    function __toString()\n    {\n        $str = \"\";\n        foreach ($this->_styles as $selector => $selector_styles) {\n            /** @var Style $style */\n            foreach ($selector_styles as $style) {\n                $str .= \"$selector => \" . $style->__toString() . \"\\n\";\n            }\n        }\n\n        return $str;\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf;\n\nuse DOMDocument;\nuse DOMNode;\nuse Dompdf\\Adapter\\CPDF;\nuse DOMXPath;\nuse Dompdf\\Frame\\Factory;\nuse Dompdf\\Frame\\FrameTree;\nuse Dompdf\\Image\\Cache;\nuse Dompdf\\Css\\Stylesheet;\nuse Dompdf\\Helpers;\nuse Masterminds\\HTML5;\n\n/**\n * Dompdf - PHP5 HTML to PDF renderer\n *\n * Dompdf loads HTML and does its best to render it as a PDF.  It gets its\n * name from the new DomDocument PHP5 extension.  Source HTML is first\n * parsed by a DomDocument object.  Dompdf takes the resulting DOM tree and\n * attaches a {@link Frame} object to each node.  {@link Frame} objects store\n * positioning and layout information and each has a reference to a {@link\n * Style} object.\n *\n * Style information is loaded and parsed (see {@link Stylesheet}) and is\n * applied to the frames in the tree by using XPath.  CSS selectors are\n * converted into XPath queries, and the computed {@link Style} objects are\n * applied to the {@link Frame}s.\n *\n * {@link Frame}s are then decorated (in the design pattern sense of the\n * word) based on their CSS display property ({@link\n * http://www.w3.org/TR/CSS21/visuren.html#propdef-display}).\n * Frame_Decorators augment the basic {@link Frame} class by adding\n * additional properties and methods specific to the particular type of\n * {@link Frame}.  For example, in the CSS layout model, block frames\n * (display: block;) contain line boxes that are usually filled with text or\n * other inline frames.  The Block therefore adds a $lines\n * property as well as methods to add {@link Frame}s to lines and to add\n * additional lines.  {@link Frame}s also are attached to specific\n * AbstractPositioner and {@link AbstractFrameReflower} objects that contain the\n * positioining and layout algorithm for a specific type of frame,\n * respectively.  This is an application of the Strategy pattern.\n *\n * Layout, or reflow, proceeds recursively (post-order) starting at the root\n * of the document.  Space constraints (containing block width & height) are\n * pushed down, and resolved positions and sizes bubble up.  Thus, every\n * {@link Frame} in the document tree is traversed once (except for tables\n * which use a two-pass layout algorithm).  If you are interested in the\n * details, see the reflow() method of the Reflower classes.\n *\n * Rendering is relatively straightforward once layout is complete. {@link\n * Frame}s are rendered using an adapted {@link Cpdf} class, originally\n * written by Wayne Munro, http://www.ros.co.nz/pdf/.  (Some performance\n * related changes have been made to the original {@link Cpdf} class, and\n * the {@link Dompdf\\Adapter\\CPDF} class provides a simple, stateless interface to\n * PDF generation.)  PDFLib support has now also been added, via the {@link\n * Dompdf\\Adapter\\PDFLib}.\n *\n *\n * @package dompdf\n */\nclass Dompdf\n{\n    /**\n     * Version string for dompdf\n     *\n     * @var string\n     */\n    private $version = 'dompdf';\n\n    /**\n     * DomDocument representing the HTML document\n     *\n     * @var DOMDocument\n     */\n    private $dom;\n\n    /**\n     * FrameTree derived from the DOM tree\n     *\n     * @var FrameTree\n     */\n    private $tree;\n\n    /**\n     * Stylesheet for the document\n     *\n     * @var Stylesheet\n     */\n    private $css;\n\n    /**\n     * Actual PDF renderer\n     *\n     * @var Canvas\n     */\n    private $canvas;\n\n    /**\n     * Desired paper size ('letter', 'legal', 'A4', etc.)\n     *\n     * @var string|array\n     */\n    private $paperSize;\n\n    /**\n     * Paper orientation ('portrait' or 'landscape')\n     *\n     * @var string\n     */\n    private $paperOrientation = \"portrait\";\n\n    /**\n     * Callbacks on new page and new element\n     *\n     * @var array\n     */\n    private $callbacks = [];\n\n    /**\n     * Experimental caching capability\n     *\n     * @var string\n     */\n    private $cacheId;\n\n    /**\n     * Base hostname\n     *\n     * Used for relative paths/urls\n     * @var string\n     */\n    private $baseHost = \"\";\n\n    /**\n     * Absolute base path\n     *\n     * Used for relative paths/urls\n     * @var string\n     */\n    private $basePath = \"\";\n\n    /**\n     * Protocol used to request file (file://, http://, etc)\n     *\n     * @var string\n     */\n    private $protocol = \"\";\n\n    /**\n     * The system's locale\n     *\n     * @var string\n     */\n    private $systemLocale = null;\n\n    /**\n     * The system's mbstring internal encoding\n     *\n     * @var string\n     */\n    private $mbstringEncoding = null;\n\n    /**\n     * The system's PCRE JIT configuration\n     *\n     * @var string\n     */\n    private $pcreJit = null;\n\n    /**\n     * The default view of the PDF in the viewer\n     *\n     * @var string\n     */\n    private $defaultView = \"Fit\";\n\n    /**\n     * The default view options of the PDF in the viewer\n     *\n     * @var array\n     */\n    private $defaultViewOptions = [];\n\n    /**\n     * Tells whether the DOM document is in quirksmode (experimental)\n     *\n     * @var bool\n     */\n    private $quirksmode = false;\n\n    /**\n    * Local file extension whitelist\n    *\n    * File extensions supported by dompdf for local files.\n    *\n    * @var array\n    */\n    private $allowedLocalFileExtensions = [\"htm\", \"html\"];\n\n    /**\n     * @var array\n     */\n    private $messages = [];\n\n    /**\n     * @var Options\n     */\n    private $options;\n\n    /**\n     * @var FontMetrics\n     */\n    private $fontMetrics;\n\n    /**\n     * The list of built-in fonts\n     *\n     * @var array\n     * @deprecated\n     */\n    public static $native_fonts = [\n        \"courier\", \"courier-bold\", \"courier-oblique\", \"courier-boldoblique\",\n        \"helvetica\", \"helvetica-bold\", \"helvetica-oblique\", \"helvetica-boldoblique\",\n        \"times-roman\", \"times-bold\", \"times-italic\", \"times-bolditalic\",\n        \"symbol\", \"zapfdinbats\"\n    ];\n\n    /**\n     * The list of built-in fonts\n     *\n     * @var array\n     */\n    public static $nativeFonts = [\n        \"courier\", \"courier-bold\", \"courier-oblique\", \"courier-boldoblique\",\n        \"helvetica\", \"helvetica-bold\", \"helvetica-oblique\", \"helvetica-boldoblique\",\n        \"times-roman\", \"times-bold\", \"times-italic\", \"times-bolditalic\",\n        \"symbol\", \"zapfdinbats\"\n    ];\n\n    /**\n     * Class constructor\n     *\n     * @param Options|array|null $options\n     */\n    public function __construct($options = null)\n    {\n        if (isset($options) && $options instanceof Options) {\n            $this->setOptions($options);\n        } elseif (is_array($options)) {\n            $this->setOptions(new Options($options));\n        } else {\n            $this->setOptions(new Options());\n        }\n\n        $versionFile = realpath(__DIR__ . '/../VERSION');\n        if (($version = file_get_contents($versionFile)) !== false) {\n            $version = trim($version);\n            if ($version !== '$Format:<%h>$') {\n                $this->version = sprintf('dompdf %s', $version);\n            }\n        }\n\n        $this->setPhpConfig();\n\n        $this->paperSize = $this->options->getDefaultPaperSize();\n        $this->paperOrientation = $this->options->getDefaultPaperOrientation();\n\n        $this->canvas = CanvasFactory::get_instance($this, $this->paperSize, $this->paperOrientation);\n        $this->fontMetrics = new FontMetrics($this->canvas, $this->options);\n        $this->css = new Stylesheet($this);\n\n        $this->restorePhpConfig();\n    }\n\n    /**\n     * Save the system's existing locale, PCRE JIT, and MBString encoding\n     * configuration and configure the system for Dompdf processing\n     */\n    private function setPhpConfig()\n    {\n        if (sprintf('%.1f', 1.0) !== '1.0') {\n            $this->systemLocale = setlocale(LC_NUMERIC, \"0\");\n            setlocale(LC_NUMERIC, \"C\");\n        }\n\n        $this->pcreJit = @ini_get('pcre.jit');\n        @ini_set('pcre.jit', '0');\n\n        $this->mbstringEncoding = mb_internal_encoding();\n        mb_internal_encoding('UTF-8');\n    }\n\n    /**\n     * Restore the system's locale configuration\n     */\n    private function restorePhpConfig()\n    {\n        if ($this->systemLocale !== null) {\n            setlocale(LC_NUMERIC, $this->systemLocale);\n            $this->systemLocale = null;\n        }\n\n        if ($this->pcreJit !== null) {\n            @ini_set('pcre.jit', $this->pcreJit);\n            $this->pcreJit = null;\n        }\n\n        if ($this->mbstringEncoding !== null) {\n            mb_internal_encoding($this->mbstringEncoding);\n            $this->mbstringEncoding = null;\n        }\n    }\n\n    /**\n     * @param $file\n     * @deprecated\n     */\n    public function load_html_file($file)\n    {\n        $this->loadHtmlFile($file);\n    }\n\n    /**\n     * Loads an HTML file\n     * Parse errors are stored in the global array _dompdf_warnings.\n     *\n     * @param string $file a filename or url to load\n     * @param string $encoding Encoding of $file\n     *\n     * @throws Exception\n     */\n    public function loadHtmlFile($file, $encoding = null)\n    {\n        $this->setPhpConfig();\n\n        if (!$this->protocol && !$this->baseHost && !$this->basePath) {\n            [$this->protocol, $this->baseHost, $this->basePath] = Helpers::explode_url($file);\n        }\n        $protocol = strtolower($this->protocol);\n        $uri = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $file);\n\n        $allowed_protocols = $this->options->getAllowedProtocols();\n        if (!array_key_exists($protocol, $allowed_protocols)) {\n            throw new Exception(\"Permission denied on $file. The communication protocol is not supported.\");\n        }\n\n        if ($protocol === \"file://\") {\n            $ext = strtolower(pathinfo($uri, PATHINFO_EXTENSION));\n            if (!in_array($ext, $this->allowedLocalFileExtensions)) {\n                throw new Exception(\"Permission denied on $file: The file extension is forbidden.\");\n            }\n        }\n\n        foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n            [$result, $message] = $rule($uri);\n            if (!$result) {\n                throw new Exception(\"Error loading $file: $message\");\n            }\n        }\n\n        [$contents, $http_response_header] = Helpers::getFileContent($uri, $this->options->getHttpContext());\n        if ($contents === null) {\n            throw new Exception(\"File '$file' not found.\");\n        }\n\n        // See http://the-stickman.com/web-development/php/getting-http-response-headers-when-using-file_get_contents/\n        if (isset($http_response_header)) {\n            foreach ($http_response_header as $_header) {\n                if (preg_match(\"@Content-Type:\\s*[\\w/]+;\\s*?charset=([^\\s]+)@i\", $_header, $matches)) {\n                    $encoding = strtoupper($matches[1]);\n                    break;\n                }\n            }\n        }\n\n        $this->restorePhpConfig();\n\n        $this->loadHtml($contents, $encoding);\n    }\n\n    /**\n     * @param string $str\n     * @param string $encoding\n     * @deprecated\n     */\n    public function load_html($str, $encoding = null)\n    {\n        $this->loadHtml($str, $encoding);\n    }\n\n    public function loadDOM($doc, $quirksmode = false) {\n        // Remove #text children nodes in nodes that shouldn't have\n        $tag_names = [\"html\", \"head\", \"table\", \"tbody\", \"thead\", \"tfoot\", \"tr\"];\n        foreach ($tag_names as $tag_name) {\n            $nodes = $doc->getElementsByTagName($tag_name);\n\n            foreach ($nodes as $node) {\n                self::removeTextNodes($node);\n            }\n        }\n\n        $this->dom = $doc;\n        $this->quirksmode = $quirksmode;\n        $this->tree = new FrameTree($this->dom);\n    }\n\n    /**\n     * Loads an HTML string\n     * Parse errors are stored in the global array _dompdf_warnings.\n     *\n     * @param string $str HTML text to load\n     * @param string $encoding Encoding of $str\n     */\n    public function loadHtml($str, $encoding = null)\n    {\n        $this->setPhpConfig();\n\n        // Determine character encoding when $encoding parameter not used\n        if ($encoding === null) {\n            mb_detect_order('auto');\n            if (($encoding = mb_detect_encoding($str, null, true)) === false) {\n\n                //\"auto\" is expanded to \"ASCII,JIS,UTF-8,EUC-JP,SJIS\"\n                $encoding = \"auto\";\n            }\n        }\n\n        if (in_array(strtoupper($encoding), array('UTF-8','UTF8')) === false) {\n            $str = mb_convert_encoding($str, 'UTF-8', $encoding);\n\n            //Update encoding after converting\n            $encoding = 'UTF-8';\n        }\n\n        $metatags = [\n            '@<meta\\s+http-equiv=\"Content-Type\"\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))?@i',\n            '@<meta\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))\"?\\s+http-equiv=\"Content-Type\"@i',\n            '@<meta [^>]*charset\\s*=\\s*[\"\\']?\\s*([^\"\\' ]+)@i',\n        ];\n        foreach ($metatags as $metatag) {\n            if (preg_match($metatag, $str, $matches)) {\n                if (isset($matches[1]) && in_array($matches[1], mb_list_encodings())) {\n                    $document_encoding = $matches[1];\n                    break;\n                }\n            }\n        }\n        if (isset($document_encoding) && in_array(strtoupper($document_encoding), ['UTF-8','UTF8']) === false) {\n            $str = preg_replace('/charset=([^\\s\"]+)/i', 'charset=UTF-8', $str);\n        } elseif (isset($document_encoding) === false && strpos($str, '<head>') !== false) {\n            $str = str_replace('<head>', '<head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">', $str);\n        } elseif (isset($document_encoding) === false) {\n            $str = '<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">' . $str;\n        }\n\n        // remove BOM mark from UTF-8, it's treated as document text by DOMDocument\n        // FIXME: roll this into the encoding detection using UTF-8/16/32 BOM (http://us2.php.net/manual/en/function.mb-detect-encoding.php#91051)?\n        if (substr($str, 0, 3) == chr(0xEF) . chr(0xBB) . chr(0xBF)) {\n            $str = substr($str, 3);\n        }\n\n        // Store parsing warnings as messages\n        set_error_handler([Helpers::class, 'record_warnings']);\n\n        try {\n            // @todo Take the quirksmode into account\n            // https://quirks.spec.whatwg.org/\n            // http://hsivonen.iki.fi/doctype/\n            $quirksmode = false;\n\n            $html5 = new HTML5(['encoding' => $encoding, 'disable_html_ns' => true]);\n            $dom = $html5->loadHTML($str);\n\n            // extra step to normalize the HTML document structure\n            // see Masterminds/html5-php#166\n            $doc = new DOMDocument(\"1.0\", $encoding);\n            $doc->preserveWhiteSpace = true;\n            $doc->loadHTML($html5->saveHTML($dom), LIBXML_NOWARNING | LIBXML_NOERROR);\n\n            $this->loadDOM($doc, $quirksmode);\n        } finally {\n            restore_error_handler();\n            $this->restorePhpConfig();\n        }\n    }\n\n    /**\n     * @param DOMNode $node\n     * @deprecated\n     */\n    public static function remove_text_nodes(DOMNode $node)\n    {\n        self::removeTextNodes($node);\n    }\n\n    /**\n     * @param DOMNode $node\n     */\n    public static function removeTextNodes(DOMNode $node)\n    {\n        $children = [];\n        for ($i = 0; $i < $node->childNodes->length; $i++) {\n            $child = $node->childNodes->item($i);\n            if ($child->nodeName === \"#text\") {\n                $children[] = $child;\n            }\n        }\n\n        foreach ($children as $child) {\n            $node->removeChild($child);\n        }\n    }\n\n    /**\n     * Builds the {@link FrameTree}, loads any CSS and applies the styles to\n     * the {@link FrameTree}\n     */\n    private function processHtml()\n    {\n        $this->tree->build_tree();\n\n        $this->css->load_css_file($this->css->getDefaultStylesheet(), Stylesheet::ORIG_UA);\n\n        $acceptedmedia = Stylesheet::$ACCEPTED_GENERIC_MEDIA_TYPES;\n        $acceptedmedia[] = $this->options->getDefaultMediaType();\n\n        // <base href=\"\" />\n        /** @var \\DOMElement|null */\n        $baseNode = $this->dom->getElementsByTagName(\"base\")->item(0);\n        $baseHref = $baseNode ? $baseNode->getAttribute(\"href\") : \"\";\n        if ($baseHref !== \"\") {\n            [$this->protocol, $this->baseHost, $this->basePath] = Helpers::explode_url($baseHref);\n        }\n\n        // Set the base path of the Stylesheet to that of the file being processed\n        $this->css->set_protocol($this->protocol);\n        $this->css->set_host($this->baseHost);\n        $this->css->set_base_path($this->basePath);\n\n        // Get all the stylesheets so that they are processed in document order\n        $xpath = new DOMXPath($this->dom);\n        $stylesheets = $xpath->query(\"//*[name() = 'link' or name() = 'style']\");\n\n        /** @var \\DOMElement $tag */\n        foreach ($stylesheets as $tag) {\n            switch (strtolower($tag->nodeName)) {\n                // load <link rel=\"STYLESHEET\" ... /> tags\n                case \"link\":\n                    if (mb_strtolower(stripos($tag->getAttribute(\"rel\"), \"stylesheet\") !== false) || // may be \"appendix stylesheet\"\n                        mb_strtolower($tag->getAttribute(\"type\")) === \"text/css\"\n                    ) {\n                        //Check if the css file is for an accepted media type\n                        //media not given then always valid\n                        $formedialist = preg_split(\"/[\\s\\n,]/\", $tag->getAttribute(\"media\"), -1, PREG_SPLIT_NO_EMPTY);\n                        if (count($formedialist) > 0) {\n                            $accept = false;\n                            foreach ($formedialist as $type) {\n                                if (in_array(mb_strtolower(trim($type)), $acceptedmedia)) {\n                                    $accept = true;\n                                    break;\n                                }\n                            }\n\n                            if (!$accept) {\n                                //found at least one mediatype, but none of the accepted ones\n                                //Skip this css file.\n                                break;\n                            }\n                        }\n\n                        $url = $tag->getAttribute(\"href\");\n                        $url = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $url);\n\n                        if ($url !== null) {\n                            $this->css->load_css_file($url, Stylesheet::ORIG_AUTHOR);\n                        }\n                    }\n                    break;\n\n                // load <style> tags\n                case \"style\":\n                    // Accept all <style> tags by default (note this is contrary to W3C\n                    // HTML 4.0 spec:\n                    // http://www.w3.org/TR/REC-html40/present/styles.html#adef-media\n                    // which states that the default media type is 'screen'\n                    if ($tag->hasAttributes() &&\n                        ($media = $tag->getAttribute(\"media\")) &&\n                        !in_array($media, $acceptedmedia)\n                    ) {\n                        break;\n                    }\n\n                    $css = \"\";\n                    if ($tag->hasChildNodes()) {\n                        $child = $tag->firstChild;\n                        while ($child) {\n                            $css .= $child->nodeValue; // Handle <style><!-- blah --></style>\n                            $child = $child->nextSibling;\n                        }\n                    } else {\n                        $css = $tag->nodeValue;\n                    }\n\n                    // Set the base path of the Stylesheet to that of the file being processed\n                    $this->css->set_protocol($this->protocol);\n                    $this->css->set_host($this->baseHost);\n                    $this->css->set_base_path($this->basePath);\n\n                    $this->css->load_css($css, Stylesheet::ORIG_AUTHOR);\n                    break;\n            }\n\n            // Set the base path of the Stylesheet to that of the file being processed\n            $this->css->set_protocol($this->protocol);\n            $this->css->set_host($this->baseHost);\n            $this->css->set_base_path($this->basePath);\n        }\n    }\n\n    /**\n     * @param string $cacheId\n     * @deprecated\n     */\n    public function enable_caching($cacheId)\n    {\n        $this->enableCaching($cacheId);\n    }\n\n    /**\n     * Enable experimental caching capability\n     *\n     * @param string $cacheId\n     */\n    public function enableCaching($cacheId)\n    {\n        $this->cacheId = $cacheId;\n    }\n\n    /**\n     * @param string $value\n     * @return bool\n     * @deprecated\n     */\n    public function parse_default_view($value)\n    {\n        return $this->parseDefaultView($value);\n    }\n\n    /**\n     * @param string $value\n     * @return bool\n     */\n    public function parseDefaultView($value)\n    {\n        $valid = [\"XYZ\", \"Fit\", \"FitH\", \"FitV\", \"FitR\", \"FitB\", \"FitBH\", \"FitBV\"];\n\n        $options = preg_split(\"/\\s*,\\s*/\", trim($value));\n        $defaultView = array_shift($options);\n\n        if (!in_array($defaultView, $valid)) {\n            return false;\n        }\n\n        $this->setDefaultView($defaultView, $options);\n        return true;\n    }\n\n    /**\n     * Renders the HTML to PDF\n     */\n    public function render()\n    {\n        $this->setPhpConfig();\n\n        $logOutputFile = $this->options->getLogOutputFile();\n        if ($logOutputFile) {\n            if (!file_exists($logOutputFile) && is_writable(dirname($logOutputFile))) {\n                touch($logOutputFile);\n            }\n\n            $startTime = microtime(true);\n            if (is_writable($logOutputFile)) {\n                ob_start();\n            }\n        }\n\n        $this->processHtml();\n\n        $this->css->apply_styles($this->tree);\n\n        // @page style rules : size, margins\n        $pageStyles = $this->css->get_page_styles();\n        $basePageStyle = $pageStyles[\"base\"];\n        unset($pageStyles[\"base\"]);\n\n        foreach ($pageStyles as $pageStyle) {\n            $pageStyle->inherit($basePageStyle);\n        }\n\n        // Set paper size if defined via CSS\n        if (is_array($basePageStyle->size)) {\n            [$width, $height] = $basePageStyle->size;\n            $this->setPaper([0, 0, $width, $height]);\n        }\n\n        // Create a new canvas instance if the current one does not match the\n        // desired paper size\n        $canvasWidth = $this->canvas->get_width();\n        $canvasHeight = $this->canvas->get_height();\n        $size = $this->getPaperSize();\n\n        if ($canvasWidth !== $size[2] || $canvasHeight !== $size[3]) {\n            $this->canvas = CanvasFactory::get_instance($this, $this->paperSize, $this->paperOrientation);\n            $this->fontMetrics->setCanvas($this->canvas);\n        }\n\n        $canvas = $this->canvas;\n        $root = null;\n\n        foreach ($this->tree as $frame) {\n            // Set up the root frame\n            if (is_null($root)) {\n                $root = Factory::decorate_root($this->tree->get_root(), $this);\n                continue;\n            }\n\n            // Create the appropriate decorators, reflowers & positioners.\n            Factory::decorate_frame($frame, $this, $root);\n        }\n\n        // Add meta information\n        $title = $this->dom->getElementsByTagName(\"title\");\n        if ($title->length) {\n            $canvas->add_info(\"Title\", trim($title->item(0)->nodeValue));\n        }\n\n        $metas = $this->dom->getElementsByTagName(\"meta\");\n        $labels = [\n            \"author\" => \"Author\",\n            \"keywords\" => \"Keywords\",\n            \"description\" => \"Subject\",\n        ];\n        /** @var \\DOMElement $meta */\n        foreach ($metas as $meta) {\n            $name = mb_strtolower($meta->getAttribute(\"name\"));\n            $value = trim($meta->getAttribute(\"content\"));\n\n            if (isset($labels[$name])) {\n                $canvas->add_info($labels[$name], $value);\n                continue;\n            }\n\n            if ($name === \"dompdf.view\" && $this->parseDefaultView($value)) {\n                $canvas->set_default_view($this->defaultView, $this->defaultViewOptions);\n            }\n        }\n\n        $root->set_containing_block(0, 0, $canvas->get_width(), $canvas->get_height());\n        $root->set_renderer(new Renderer($this));\n\n        // This is where the magic happens:\n        $root->reflow();\n\n        // Clean up cached images\n        if (!$this->options->getDebugKeepTemp()) {\n            Cache::clear($this->options->getDebugPng());\n        }\n\n        global $_dompdf_warnings, $_dompdf_show_warnings;\n        if ($_dompdf_show_warnings && isset($_dompdf_warnings)) {\n            echo '<b>Dompdf Warnings</b><br><pre>';\n            foreach ($_dompdf_warnings as $msg) {\n                echo $msg . \"\\n\";\n            }\n\n            if ($canvas instanceof CPDF) {\n                echo $canvas->get_cpdf()->messages;\n            }\n            echo '</pre>';\n            flush();\n        }\n\n        if ($logOutputFile && is_writable($logOutputFile)) {\n            $this->writeLog($logOutputFile, $startTime);\n            ob_end_clean();\n        }\n\n        $this->restorePhpConfig();\n    }\n\n    /**\n     * Writes the output buffer in the log file\n     *\n     * @param string $logOutputFile\n     * @param float $startTime\n     */\n    private function writeLog(string $logOutputFile, float $startTime): void\n    {\n        $frames = Frame::$ID_COUNTER;\n        $memory = memory_get_peak_usage(true) / 1024;\n        $time = (microtime(true) - $startTime) * 1000;\n\n        $out = sprintf(\n            \"<span style='color: #000' title='Frames'>%6d</span>\" .\n            \"<span style='color: #009' title='Memory'>%10.2f KB</span>\" .\n            \"<span style='color: #900' title='Time'>%10.2f ms</span>\" .\n            \"<span  title='Quirksmode'>  \" .\n            ($this->quirksmode ? \"<span style='color: #d00'> ON</span>\" : \"<span style='color: #0d0'>OFF</span>\") .\n            \"</span><br />\", $frames, $memory, $time);\n\n        $out .= ob_get_contents();\n        ob_clean();\n\n        file_put_contents($logOutputFile, $out);\n    }\n\n    /**\n     * Add meta information to the PDF after rendering.\n     *\n     * @deprecated\n     */\n    public function add_info($label, $value)\n    {\n        $this->addInfo($label, $value);\n    }\n\n    /**\n     * Add meta information to the PDF after rendering.\n     *\n     * @param string $label Label of the value (Creator, Producer, etc.)\n     * @param string $value The text to set\n     */\n    public function addInfo(string $label, string $value): void\n    {\n        $this->canvas->add_info($label, $value);\n    }\n\n    /**\n     * Streams the PDF to the client.\n     *\n     * The file will open a download dialog by default. The options\n     * parameter controls the output. Accepted options (array keys) are:\n     *\n     * 'compress' = > 1 (=default) or 0:\n     *   Apply content stream compression\n     *\n     * 'Attachment' => 1 (=default) or 0:\n     *   Set the 'Content-Disposition:' HTTP header to 'attachment'\n     *   (thereby causing the browser to open a download dialog)\n     *\n     * @param string $filename the name of the streamed file\n     * @param array $options header options (see above)\n     */\n    public function stream($filename = \"document.pdf\", $options = [])\n    {\n        $this->setPhpConfig();\n\n        $this->canvas->stream($filename, $options);\n\n        $this->restorePhpConfig();\n    }\n\n    /**\n     * Returns the PDF as a string.\n     *\n     * The options parameter controls the output. Accepted options are:\n     *\n     * 'compress' = > 1 or 0 - apply content stream compression, this is\n     *    on (1) by default\n     *\n     * @param array $options options (see above)\n     *\n     * @return string|null\n     */\n    public function output($options = [])\n    {\n        $this->setPhpConfig();\n\n        $output = $this->canvas->output($options);\n\n        $this->restorePhpConfig();\n\n        return $output;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function output_html()\n    {\n        return $this->outputHtml();\n    }\n\n    /**\n     * Returns the underlying HTML document as a string\n     *\n     * @return string\n     */\n    public function outputHtml()\n    {\n        return $this->dom->saveHTML();\n    }\n\n    /**\n     * Get the dompdf option value\n     *\n     * @param string $key\n     * @return mixed\n     * @deprecated\n     */\n    public function get_option($key)\n    {\n        return $this->options->get($key);\n    }\n\n    /**\n     * @param string $key\n     * @param mixed $value\n     * @return $this\n     * @deprecated\n     */\n    public function set_option($key, $value)\n    {\n        $this->options->set($key, $value);\n        return $this;\n    }\n\n    /**\n     * @param array $options\n     * @return $this\n     * @deprecated\n     */\n    public function set_options(array $options)\n    {\n        $this->options->set($options);\n        return $this;\n    }\n\n    /**\n     * @param string $size\n     * @param string $orientation\n     * @deprecated\n     */\n    public function set_paper($size, $orientation = \"portrait\")\n    {\n        $this->setPaper($size, $orientation);\n    }\n\n    /**\n     * Sets the paper size & orientation\n     *\n     * @param string|float[] $size 'letter', 'legal', 'A4', etc. {@link Dompdf\\Adapter\\CPDF::$PAPER_SIZES}\n     * @param string $orientation 'portrait' or 'landscape'\n     * @return $this\n     */\n    public function setPaper($size, $orientation = \"portrait\")\n    {\n        $this->paperSize = $size;\n        $this->paperOrientation = $orientation;\n        return $this;\n    }\n\n    /**\n     * Gets the paper size\n     *\n     * @return float[] A four-element float array\n     */\n    public function getPaperSize()\n    {\n        $paper = $this->paperSize;\n        $orientation = $this->paperOrientation;\n\n        if (is_array($paper)) {\n            $size = array_map(\"floatval\", $paper);\n        } else {\n            $paper = strtolower($paper);\n            $size = CPDF::$PAPER_SIZES[$paper] ?? CPDF::$PAPER_SIZES[\"letter\"];\n        }\n\n        if (strtolower($orientation) === \"landscape\") {\n            [$size[2], $size[3]] = [$size[3], $size[2]];\n        }\n\n        return $size;\n    }\n\n    /**\n     * Gets the paper orientation\n     *\n     * @return string Either \"portrait\" or \"landscape\"\n     */\n    public function getPaperOrientation()\n    {\n        return $this->paperOrientation;\n    }\n\n    /**\n     * @param FrameTree $tree\n     * @return $this\n     */\n    public function setTree(FrameTree $tree)\n    {\n        $this->tree = $tree;\n        return $this;\n    }\n\n    /**\n     * @return FrameTree\n     * @deprecated\n     */\n    public function get_tree()\n    {\n        return $this->getTree();\n    }\n\n    /**\n     * Returns the underlying {@link FrameTree} object\n     *\n     * @return FrameTree\n     */\n    public function getTree()\n    {\n        return $this->tree;\n    }\n\n    /**\n     * @param string $protocol\n     * @return $this\n     * @deprecated\n     */\n    public function set_protocol($protocol)\n    {\n        return $this->setProtocol($protocol);\n    }\n\n    /**\n     * Sets the protocol to use\n     * FIXME validate these\n     *\n     * @param string $protocol\n     * @return $this\n     */\n    public function setProtocol(string $protocol)\n    {\n        $this->protocol = $protocol;\n        return $this;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function get_protocol()\n    {\n        return $this->getProtocol();\n    }\n\n    /**\n     * Returns the protocol in use\n     *\n     * @return string\n     */\n    public function getProtocol()\n    {\n        return $this->protocol;\n    }\n\n    /**\n     * @param string $host\n     * @deprecated\n     */\n    public function set_host($host)\n    {\n        $this->setBaseHost($host);\n    }\n\n    /**\n     * Sets the base hostname\n     *\n     * @param string $baseHost\n     * @return $this\n     */\n    public function setBaseHost(string $baseHost)\n    {\n        $this->baseHost = $baseHost;\n        return $this;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function get_host()\n    {\n        return $this->getBaseHost();\n    }\n\n    /**\n     * Returns the base hostname\n     *\n     * @return string\n     */\n    public function getBaseHost()\n    {\n        return $this->baseHost;\n    }\n\n    /**\n     * Sets the base path\n     *\n     * @param string $path\n     * @deprecated\n     */\n    public function set_base_path($path)\n    {\n        $this->setBasePath($path);\n    }\n\n    /**\n     * Sets the base path\n     *\n     * @param string $basePath\n     * @return $this\n     */\n    public function setBasePath(string $basePath)\n    {\n        $this->basePath = $basePath;\n        return $this;\n    }\n\n    /**\n     * @return string\n     * @deprecated\n     */\n    public function get_base_path()\n    {\n        return $this->getBasePath();\n    }\n\n    /**\n     * Returns the base path\n     *\n     * @return string\n     */\n    public function getBasePath()\n    {\n        return $this->basePath;\n    }\n\n    /**\n     * @param string $default_view The default document view\n     * @param array $options The view's options\n     * @return $this\n     * @deprecated\n     */\n    public function set_default_view($default_view, $options)\n    {\n        return $this->setDefaultView($default_view, $options);\n    }\n\n    /**\n     * Sets the default view\n     *\n     * @param string $defaultView The default document view\n     * @param array $options The view's options\n     * @return $this\n     */\n    public function setDefaultView($defaultView, $options)\n    {\n        $this->defaultView = $defaultView;\n        $this->defaultViewOptions = $options;\n        return $this;\n    }\n\n    /**\n     * @param resource $http_context\n     * @return $this\n     * @deprecated\n     */\n    public function set_http_context($http_context)\n    {\n        return $this->setHttpContext($http_context);\n    }\n\n    /**\n     * Sets the HTTP context\n     *\n     * @param resource|array $httpContext\n     * @return $this\n     */\n    public function setHttpContext($httpContext)\n    {\n        $this->options->setHttpContext($httpContext);\n        return $this;\n    }\n\n    /**\n     * @return resource\n     * @deprecated\n     */\n    public function get_http_context()\n    {\n        return $this->getHttpContext();\n    }\n\n    /**\n     * Returns the HTTP context\n     *\n     * @return resource\n     */\n    public function getHttpContext()\n    {\n        return $this->options->getHttpContext();\n    }\n\n    /**\n     * Set a custom `Canvas` instance to render the document to.\n     *\n     * Be aware that the instance will be replaced on render if the document\n     * defines a paper size different from the canvas.\n     *\n     * @param Canvas $canvas\n     * @return $this\n     */\n    public function setCanvas(Canvas $canvas)\n    {\n        $this->canvas = $canvas;\n        return $this;\n    }\n\n    /**\n     * @return Canvas\n     * @deprecated\n     */\n    public function get_canvas()\n    {\n        return $this->getCanvas();\n    }\n\n    /**\n     * Return the underlying Canvas instance (e.g. Dompdf\\Adapter\\CPDF, Dompdf\\Adapter\\GD)\n     *\n     * @return Canvas\n     */\n    public function getCanvas()\n    {\n        return $this->canvas;\n    }\n\n    /**\n     * @param Stylesheet $css\n     * @return $this\n     */\n    public function setCss(Stylesheet $css)\n    {\n        $this->css = $css;\n        return $this;\n    }\n\n    /**\n     * @return Stylesheet\n     * @deprecated\n     */\n    public function get_css()\n    {\n        return $this->getCss();\n    }\n\n    /**\n     * Returns the stylesheet\n     *\n     * @return Stylesheet\n     */\n    public function getCss()\n    {\n        return $this->css;\n    }\n\n    /**\n     * @param DOMDocument $dom\n     * @return $this\n     */\n    public function setDom(DOMDocument $dom)\n    {\n        $this->dom = $dom;\n        return $this;\n    }\n\n    /**\n     * @return DOMDocument\n     * @deprecated\n     */\n    public function get_dom()\n    {\n        return $this->getDom();\n    }\n\n    /**\n     * @return DOMDocument\n     */\n    public function getDom()\n    {\n        return $this->dom;\n    }\n\n    /**\n     * @param Options $options\n     * @return $this\n     */\n    public function setOptions(Options $options)\n    {\n        // For backwards compatibility\n        if ($this->options && $this->options->getHttpContext() && !$options->getHttpContext()) {\n            $options->setHttpContext($this->options->getHttpContext());\n        }\n\n        $this->options = $options;\n        $fontMetrics = $this->fontMetrics;\n        if (isset($fontMetrics)) {\n            $fontMetrics->setOptions($options);\n        }\n        return $this;\n    }\n\n    /**\n     * @return Options\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * @return array\n     * @deprecated\n     */\n    public function get_callbacks()\n    {\n        return $this->getCallbacks();\n    }\n\n    /**\n     * Returns the callbacks array\n     *\n     * @return array\n     */\n    public function getCallbacks()\n    {\n        return $this->callbacks;\n    }\n\n    /**\n     * @param array $callbacks the set of callbacks to set\n     * @deprecated\n     */\n    public function set_callbacks($callbacks)\n    {\n        $this->setCallbacks($callbacks);\n    }\n\n    /**\n     * Sets callbacks for events like rendering of pages and elements.\n     *\n     * The callbacks array should contain arrays with `event` set to a callback\n     * event name and `f` set to a function or any other callable.\n     *\n     * The available callback events are:\n     * * `begin_page_reflow`: called before page reflow\n     * * `begin_frame`: called before a frame is rendered\n     * * `end_frame`: called after frame rendering is complete\n     * * `begin_page_render`: called before a page is rendered\n     * * `end_page_render`: called after page rendering is complete\n     *\n     * The function `f` must take an array as argument, which contains info\n     * about the event (`[0 => Canvas, 1 => Frame, \"canvas\" => Canvas,\n     * \"frame\" => Frame]`).\n     *\n     * @param array $callbacks The set of callbacks to set\n     */\n    public function setCallbacks($callbacks)\n    {\n        if (is_array($callbacks)) {\n            $this->callbacks = [];\n            foreach ($callbacks as $c) {\n                if (is_array($c) && isset($c[\"event\"]) && isset($c[\"f\"])) {\n                    $event = $c[\"event\"];\n                    $f = $c[\"f\"];\n                    if (is_string($event) && is_callable($f)) {\n                        $this->callbacks[$event][] = $f;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @return boolean\n     * @deprecated\n     */\n    public function get_quirksmode()\n    {\n        return $this->getQuirksmode();\n    }\n\n    /**\n     * Get the quirks mode\n     *\n     * @return boolean true if quirks mode is active\n     */\n    public function getQuirksmode()\n    {\n        return $this->quirksmode;\n    }\n\n    /**\n     * @param FontMetrics $fontMetrics\n     * @return $this\n     */\n    public function setFontMetrics(FontMetrics $fontMetrics)\n    {\n        $this->fontMetrics = $fontMetrics;\n        return $this;\n    }\n\n    /**\n     * @return FontMetrics\n     */\n    public function getFontMetrics()\n    {\n        return $this->fontMetrics;\n    }\n\n    /**\n     * PHP5 overloaded getter\n     * Along with {@link Dompdf::__set()} __get() provides access to all\n     * properties directly.  Typically __get() is not called directly outside\n     * of this class.\n     *\n     * @param string $prop\n     *\n     * @throws Exception\n     * @return mixed\n     */\n    function __get($prop)\n    {\n        switch ($prop) {\n            case 'version':\n                return $this->version;\n            default:\n                throw new Exception('Invalid property: ' . $prop);\n        }\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\nnamespace Dompdf;\n\nuse FontLib\\Font;\n\n/**\n * The font metrics class\n *\n * This class provides information about fonts and text.  It can resolve\n * font names into actual installed font files, as well as determine the\n * size of text in a particular font and size.\n *\n * @static\n * @package dompdf\n */\nclass FontMetrics\n{\n    /**\n     * Name of the user font families file\n     *\n     * This file must be writable by the webserver process only to update it\n     * with save_font_families() after adding the .afm file references of a new font family\n     * with FontMetrics::saveFontFamilies().\n     * This is typically done only from command line with load_font.php on converting\n     * ttf fonts to ufm with php-font-lib.\n     */\n    const USER_FONTS_FILE = \"installed-fonts.json\";\n\n\n    /**\n     * Underlying {@link Canvas} object to perform text size calculations\n     *\n     * @var Canvas\n     */\n    protected $canvas;\n\n    /**\n     * Array of bundled font family names to variants\n     *\n     * @var array\n     */\n    protected $bundledFonts = [];\n\n    /**\n     * Array of user defined font family names to variants\n     *\n     * @var array\n     */\n    protected $userFonts = [];\n\n    /**\n     * combined list of all font families with absolute paths\n     *\n     * @var array\n     */\n    protected $fontFamilies;\n\n    /**\n     * @var Options\n     */\n    private $options;\n\n    /**\n     * Class initialization\n     */\n    public function __construct(Canvas $canvas, Options $options)\n    {\n        $this->setCanvas($canvas);\n        $this->setOptions($options);\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * @deprecated\n     */\n    public function save_font_families()\n    {\n        $this->saveFontFamilies();\n    }\n\n    /**\n     * Saves the stored font family cache\n     *\n     * The name and location of the cache file are determined by {@link\n     * FontMetrics::USER_FONTS_FILE}. This file should be writable by the\n     * webserver process.\n     *\n     * @see FontMetrics::loadFontFamilies()\n     */\n    public function saveFontFamilies()\n    {\n        file_put_contents($this->getUserFontsFilePath(), json_encode($this->userFonts, JSON_PRETTY_PRINT));\n    }\n\n    /**\n     * @deprecated\n     */\n    public function load_font_families()\n    {\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * Loads the stored font family cache\n     *\n     * @see FontMetrics::saveFontFamilies()\n     */\n    public function loadFontFamilies()\n    {\n        $file = $this->options->getRootDir() . \"/lib/fonts/installed-fonts.dist.json\";\n        $this->bundledFonts = json_decode(file_get_contents($file), true);\n\n        if (is_readable($this->getUserFontsFilePath())) {\n            $this->userFonts = json_decode(file_get_contents($this->getUserFontsFilePath()), true);\n        } else {\n            $this->loadFontFamiliesLegacy();\n        }\n    }\n\n    private function loadFontFamiliesLegacy()\n    {\n        $legacyCacheFile = $this->options->getFontDir() . '/dompdf_font_family_cache.php';\n        if (is_readable($legacyCacheFile)) {\n            $fontDir = $this->options->getFontDir();\n            $rootDir = $this->options->getRootDir();\n    \n            if (!defined(\"DOMPDF_DIR\")) { define(\"DOMPDF_DIR\", $rootDir); }\n            if (!defined(\"DOMPDF_FONT_DIR\")) { define(\"DOMPDF_FONT_DIR\", $fontDir); }\n    \n            $cacheDataClosure = require $legacyCacheFile;\n            $cacheData = is_array($cacheDataClosure) ? $cacheDataClosure : $cacheDataClosure($fontDir, $rootDir);\n            if (is_array($cacheData)) {\n                foreach ($cacheData as $family => $variants) {\n                    if (!isset($this->bundledFonts[$family]) && is_array($variants)) {\n                        foreach ($variants as $variant => $variantPath) {\n                            $variantName = basename($variantPath);\n                            $variantDir = dirname($variantPath);\n                            if ($variantDir == $fontDir) {\n                                $this->userFonts[$family][$variant] = $variantName;\n                            } else {\n                                $this->userFonts[$family][$variant] = $variantPath;\n                            }\n                        }\n                    }\n                }\n                $this->saveFontFamilies();\n            }\n        }\n    }\n\n    /**\n     * @param array $style\n     * @param string $remote_file\n     * @param resource $context\n     * @return bool\n     * @deprecated\n     */\n    public function register_font($style, $remote_file, $context = null)\n    {\n        return $this->registerFont($style, $remote_file);\n    }\n\n    /**\n     * @param array $style\n     * @param string $remoteFile\n     * @param resource $context\n     * @return bool\n     */\n    public function registerFont($style, $remoteFile, $context = null)\n    {\n        $fontname = mb_strtolower($style[\"family\"]);\n        $families = $this->getFontFamilies();\n\n        $entry = [];\n        if (isset($families[$fontname])) {\n            $entry = $families[$fontname];\n        }\n\n        $styleString = $this->getType(\"{$style['weight']} {$style['style']}\");\n\n        $remoteHash = md5($remoteFile);\n\n        $prefix = $fontname . \"_\" . $styleString;\n        $prefix = trim($prefix, \"-\");\n        if (function_exists('iconv')) {\n            $prefix = @iconv('utf-8', 'us-ascii//TRANSLIT', $prefix);\n        }\n        $prefix_encoding = mb_detect_encoding($prefix, mb_detect_order(), true);\n        $substchar = mb_substitute_character();\n        mb_substitute_character(0x005F);\n        $prefix = mb_convert_encoding($prefix, \"ISO-8859-1\", $prefix_encoding);\n        mb_substitute_character($substchar);\n        $prefix = preg_replace(\"[\\W]\", \"_\", $prefix);\n        $prefix = preg_replace(\"/[^-_\\w]+/\", \"\", $prefix);\n\n        $localFile = $prefix . \"_\" . $remoteHash;\n        $localFilePath = $this->getOptions()->getFontDir() . \"/\" . $localFile;\n\n        if (isset($entry[$styleString]) && $localFilePath == $entry[$styleString]) {\n            return true;\n        }\n\n\n        $entry[$styleString] = $localFile;\n\n        // Download the remote file\n        [$protocol] = Helpers::explode_url($remoteFile);\n        $allowed_protocols = $this->options->getAllowedProtocols();\n        if (!array_key_exists($protocol, $allowed_protocols)) {\n            Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $remoteFile. The communication protocol is not supported.\", __FILE__, __LINE__);\n        }\n\n        foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n            [$result, $message] = $rule($remoteFile);\n            if ($result !== true) {\n                Helpers::record_warnings(E_USER_WARNING, \"Error loading $remoteFile: $message\", __FILE__, __LINE__);\n            }\n        }\n\n        list($remoteFileContent, $http_response_header) = @Helpers::getFileContent($remoteFile, $context);\n        if ($remoteFileContent === null) {\n            return false;\n        }\n\n        $localTempFile = @tempnam($this->options->get(\"tempDir\"), \"dompdf-font-\");\n        file_put_contents($localTempFile, $remoteFileContent);\n\n        $font = Font::load($localTempFile);\n\n        if (!$font) {\n            unlink($localTempFile);\n            return false;\n        }\n\n        $font->parse();\n        $font->saveAdobeFontMetrics(\"$localFilePath.ufm\");\n        $font->close();\n\n        unlink($localTempFile);\n\n        if ( !file_exists(\"$localFilePath.ufm\") ) {\n            return false;\n        }\n\n        $fontExtension = \".ttf\";\n        switch ($font->getFontType()) {\n            case \"TrueType\":\n            default:\n                $fontExtension = \".ttf\";\n                break;\n        }\n\n        // Save the changes\n        file_put_contents($localFilePath.$fontExtension, $remoteFileContent);\n\n        if ( !file_exists($localFilePath.$fontExtension) ) {\n            unlink(\"$localFilePath.ufm\");\n            return false;\n        }\n\n        $this->setFontFamily($fontname, $entry);\n\n        return true;\n    }\n\n    /**\n     * @param $text\n     * @param $font\n     * @param $size\n     * @param float $word_spacing\n     * @param float $char_spacing\n     * @return float\n     * @deprecated\n     */\n    public function get_text_width($text, $font, $size, $word_spacing = 0.0, $char_spacing = 0.0)\n    {\n        //return self::$_pdf->get_text_width($text, $font, $size, $word_spacing, $char_spacing);\n        return $this->getTextWidth($text, $font, $size, $word_spacing, $char_spacing);\n    }\n\n    /**\n     * Calculates text size, in points\n     *\n     * @param string $text        the text to be sized\n     * @param string $font        the desired font\n     * @param float  $size        the desired font size\n     * @param float  $wordSpacing word spacing, if any\n     * @param float  $charSpacing char spacing, if any\n     *\n     * @return float\n     */\n    public function getTextWidth(string $text, $font, float $size, float $wordSpacing = 0.0, float $charSpacing = 0.0): float\n    {\n        // @todo Make sure this cache is efficient before enabling it\n        static $cache = [];\n\n        if ($text === \"\") {\n            return 0;\n        }\n\n        // Don't cache long strings\n        $useCache = !isset($text[50]); // Faster than strlen\n\n        // Text-size calculations depend on the canvas used. Make sure to not\n        // return wrong values when switching canvas backends\n        $canvasClass = get_class($this->canvas);\n        $key = \"$canvasClass/$font/$size/$wordSpacing/$charSpacing\";\n\n        if ($useCache && isset($cache[$key][$text])) {\n            return $cache[$key][$text];\n        }\n\n        $width = $this->canvas->get_text_width($text, $font, $size, $wordSpacing, $charSpacing);\n\n        if ($useCache) {\n            $cache[$key][$text] = $width;\n        }\n\n        return $width;\n    }\n\n    /**\n     * @param $font\n     * @param $size\n     * @return float\n     * @deprecated\n     */\n    public function get_font_height($font, $size)\n    {\n        return $this->getFontHeight($font, $size);\n    }\n\n    /**\n     * Calculates font height, in points\n     *\n     * @param string $font\n     * @param float  $size\n     *\n     * @return float\n     */\n    public function getFontHeight($font, float $size): float\n    {\n        return $this->canvas->get_font_height($font, $size);\n    }\n\n    /**\n     * Calculates font baseline, in points\n     *\n     * @param string $font\n     * @param float  $size\n     *\n     * @return float\n     */\n    public function getFontBaseline($font, float $size): float\n    {\n        return $this->canvas->get_font_baseline($font, $size);\n    }\n\n    /**\n     * @param $family_raw\n     * @param string $subtype_raw\n     * @return string\n     * @deprecated\n     */\n    public function get_font($family_raw, $subtype_raw = \"normal\")\n    {\n        return $this->getFont($family_raw, $subtype_raw);\n    }\n\n    /**\n     * Resolves a font family & subtype into an actual font file\n     * Subtype can be one of 'normal', 'bold', 'italic' or 'bold_italic'.  If\n     * the particular font family has no suitable font file, the default font\n     * ({@link Options::defaultFont}) is used.  The font file returned\n     * is the absolute pathname to the font file on the system.\n     *\n     * @param string|null $familyRaw\n     * @param string      $subtypeRaw\n     *\n     * @return string|null\n     */\n    public function getFont($familyRaw, $subtypeRaw = \"normal\")\n    {\n        static $cache = [];\n\n        if (isset($cache[$familyRaw][$subtypeRaw])) {\n            return $cache[$familyRaw][$subtypeRaw];\n        }\n\n        /* Allow calling for various fonts in search path. Therefore not immediately\n         * return replacement on non match.\n         * Only when called with NULL try replacement.\n         * When this is also missing there is really trouble.\n         * If only the subtype fails, nevertheless return failure.\n         * Only on checking the fallback font, check various subtypes on same font.\n         */\n\n        $subtype = strtolower($subtypeRaw);\n\n        $families = $this->getFontFamilies();\n        if ($familyRaw) {\n            $family = str_replace([\"'\", '\"'], \"\", strtolower($familyRaw));\n\n            if (isset($families[$family][$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $families[$family][$subtype];\n            }\n\n            return null;\n        }\n\n        $fallback_families = [strtolower($this->options->getDefaultFont()), \"serif\"];\n        foreach ($fallback_families as $family) {\n            if (isset($families[$family][$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $families[$family][$subtype];\n            }\n    \n            if (!isset($families[$family])) {\n                continue;\n            }\n    \n            $family = $families[$family];\n    \n            foreach ($family as $sub => $font) {\n                if (strpos($subtype, $sub) !== false) {\n                    return $cache[$familyRaw][$subtypeRaw] = $font;\n                }\n            }\n    \n            if ($subtype !== \"normal\") {\n                foreach ($family as $sub => $font) {\n                    if ($sub !== \"normal\") {\n                        return $cache[$familyRaw][$subtypeRaw] = $font;\n                    }\n                }\n            }\n    \n            $subtype = \"normal\";\n    \n            if (isset($family[$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $family[$subtype];\n            }\n        }\n        \n        return null;\n    }\n\n    /**\n     * @param $family\n     * @return null|string\n     * @deprecated\n     */\n    public function get_family($family)\n    {\n        return $this->getFamily($family);\n    }\n\n    /**\n     * @param string $family\n     * @return null|string\n     */\n    public function getFamily($family)\n    {\n        $family = str_replace([\"'\", '\"'], \"\", mb_strtolower($family));\n        $families = $this->getFontFamilies();\n\n        if (isset($families[$family])) {\n            return $families[$family];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $type\n     * @return string\n     * @deprecated\n     */\n    public function get_type($type)\n    {\n        return $this->getType($type);\n    }\n\n    /**\n     * @param string $type\n     * @return string\n     */\n    public function getType($type)\n    {\n        if (preg_match('/bold/i', $type)) {\n            $weight = 700;\n        } elseif (preg_match('/([1-9]00)/', $type, $match)) {\n            $weight = (int)$match[0];\n        } else {\n            $weight = 400;\n        }\n        $weight = $weight === 400 ? 'normal' : $weight;\n        $weight = $weight === 700 ? 'bold' : $weight;\n\n        $style = preg_match('/italic|oblique/i', $type) ? 'italic' : null;\n\n        if ($weight === 'normal' && $style !== null) {\n            return $style;\n        }\n\n        return $style === null\n            ? $weight\n            : $weight.'_'.$style;\n    }\n\n    /**\n     * @return array\n     * @deprecated\n     */\n    public function get_font_families()\n    {\n        return $this->getFontFamilies();\n    }\n\n    /**\n     * Returns the current font lookup table\n     *\n     * @return array\n     */\n    public function getFontFamilies()\n    {\n        if (!isset($this->fontFamilies)) {\n            $this->setFontFamilies();\n        }\n        return $this->fontFamilies;\n    }\n\n    /**\n     * Convert loaded fonts to font lookup table\n     *\n     * @return array\n     */\n    public function setFontFamilies()\n    {\n        $fontFamilies = [];\n        if (isset($this->bundledFonts) && is_array($this->bundledFonts)) {\n            foreach ($this->bundledFonts as $family => $variants) {\n                if (!isset($fontFamilies[$family])) {\n                    $fontFamilies[$family] = array_map(function($variant) {\n                        return $this->getOptions()->getRootDir() . '/lib/fonts/' . $variant;\n                    }, $variants);\n                }\n            }\n        }\n        if (isset($this->userFonts) && is_array($this->userFonts)) {\n            foreach ($this->userFonts as $family => $variants) {\n                $fontFamilies[$family] = array_map(function($variant) {\n                    $variantName = basename($variant);\n                    if ($variantName === $variant) {\n                        return $this->getOptions()->getFontDir() . '/' . $variant;\n                    }\n                    return $variant;\n                }, $variants);\n            }\n        }\n        $this->fontFamilies = $fontFamilies;\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     * @deprecated\n     */\n    public function set_font_family($fontname, $entry)\n    {\n        $this->setFontFamily($fontname, $entry);\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     */\n    public function setFontFamily($fontname, $entry)\n    {\n        $this->userFonts[mb_strtolower($fontname)] = $entry;\n        $this->saveFontFamilies();\n        unset($this->fontFamilies);\n    }\n\n    /**\n     * @return string\n     */\n    public function getUserFontsFilePath()\n    {\n        return $this->options->getFontDir() . '/' . self::USER_FONTS_FILE;\n    }\n\n    /**\n     * @param Options $options\n     * @return $this\n     */\n    public function setOptions(Options $options)\n    {\n        $this->options = $options;\n        unset($this->fontFamilies);\n        return $this;\n    }\n\n    /**\n     * @return Options\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * @param Canvas $canvas\n     * @return $this\n     */\n    public function setCanvas(Canvas $canvas)\n    {\n        $this->canvas = $canvas;\n        return $this;\n    }\n\n    /**\n     * @return Canvas\n     */\n    public function getCanvas()\n    {\n        return $this->canvas;\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\FrameDecorator;\n\nuse Dompdf\\Dompdf;\nuse Dompdf\\Frame;\nuse Dompdf\\Helpers;\nuse Dompdf\\Image\\Cache;\n\n/**\n * Decorates frames for image layout and rendering\n *\n * @package dompdf\n */\nclass Image extends AbstractFrameDecorator\n{\n\n    /**\n     * The path to the image file (note that remote images are\n     * downloaded locally to Options:tempDir).\n     *\n     * @var string\n     */\n    protected $_image_url;\n\n    /**\n     * The image's file error message\n     *\n     * @var string\n     */\n    protected $_image_msg;\n\n    /**\n     * Class constructor\n     *\n     * @param Frame $frame the frame to decorate\n     * @param DOMPDF $dompdf the document's dompdf object (required to resolve relative & remote urls)\n     */\n    function __construct(Frame $frame, Dompdf $dompdf)\n    {\n        parent::__construct($frame, $dompdf);\n        $url = $frame->get_node()->getAttribute(\"src\");\n\n        $debug_png = $dompdf->getOptions()->getDebugPng();\n        if ($debug_png) {\n            print '[__construct ' . $url . ']';\n        }\n\n        list($this->_image_url, /*$type*/, $this->_image_msg) = Cache::resolve_url(\n            $url,\n            $dompdf->getProtocol(),\n            $dompdf->getBaseHost(),\n            $dompdf->getBasePath(),\n            $dompdf->getOptions()\n        );\n\n        if (Cache::is_broken($this->_image_url) &&\n            $alt = $frame->get_node()->getAttribute(\"alt\")\n        ) {\n            $fontMetrics = $dompdf->getFontMetrics();\n            $style = $frame->get_style();\n            $font = $style->font_family;\n            $size = $style->font_size;\n            $word_spacing = $style->word_spacing;\n            $letter_spacing = $style->letter_spacing;\n\n            $style->width = (4 / 3) * $fontMetrics->getTextWidth($alt, $font, $size, $word_spacing, $letter_spacing);\n            $style->height = $fontMetrics->getFontHeight($font, $size);\n        }\n    }\n\n    /**\n     * Get the intrinsic pixel dimensions of the image.\n     *\n     * @return array Width and height as `float|int`.\n     */\n    public function get_intrinsic_dimensions(): array\n    {\n        [$width, $height] = Helpers::dompdf_getimagesize($this->_image_url, $this->_dompdf->getHttpContext());\n\n        return [$width, $height];\n    }\n\n    /**\n     * Resample the given pixel length according to dpi.\n     *\n     * @param float|int $length\n     * @return float\n     */\n    public function resample($length): float\n    {\n        $dpi = $this->_dompdf->getOptions()->getDpi();\n        return ($length * 72) / $dpi;\n    }\n\n    /**\n     * Return the image's url\n     *\n     * @return string The url of this image\n     */\n    function get_image_url()\n    {\n        return $this->_image_url;\n    }\n\n    /**\n     * Return the image's error message\n     *\n     * @return string The image's error message\n     */\n    function get_image_msg()\n    {\n        return $this->_image_msg;\n    }\n\n}\n", "<?php\nnamespace Dompdf;\n\nclass Helpers\n{\n    /**\n     * print_r wrapper for html/cli output\n     *\n     * Wraps print_r() output in < pre > tags if the current sapi is not 'cli'.\n     * Returns the output string instead of displaying it if $return is true.\n     *\n     * @param mixed $mixed variable or expression to display\n     * @param bool $return\n     *\n     * @return string|null\n     */\n    public static function pre_r($mixed, $return = false)\n    {\n        if ($return) {\n            return \"<pre>\" . print_r($mixed, true) . \"</pre>\";\n        }\n\n        if (php_sapi_name() !== \"cli\") {\n            echo \"<pre>\";\n        }\n\n        print_r($mixed);\n\n        if (php_sapi_name() !== \"cli\") {\n            echo \"</pre>\";\n        } else {\n            echo \"\\n\";\n        }\n\n        flush();\n\n        return null;\n    }\n\n    /**\n     * builds a full url given a protocol, hostname, base path and url\n     *\n     * @param string $protocol\n     * @param string $host\n     * @param string $base_path\n     * @param string $url\n     * @return string\n     *\n     * Initially the trailing slash of $base_path was optional, and conditionally appended.\n     * However on dynamically created sites, where the page is given as url parameter,\n     * the base path might not end with an url.\n     * Therefore do not append a slash, and **require** the $base_url to ending in a slash\n     * when needed.\n     * Vice versa, on using the local file system path of a file, make sure that the slash\n     * is appended (o.k. also for Windows)\n     */\n    public static function build_url($protocol, $host, $base_path, $url)\n    {\n        $protocol = mb_strtolower($protocol);\n        if (empty($protocol)) {\n            $protocol = \"file://\";\n        }\n        if ($url === \"\") {\n            return null;\n        }\n\n        $url_lc = mb_strtolower($url);\n\n        // Is the url already fully qualified, a Data URI, or a reference to a named anchor?\n        // File-protocol URLs may require additional processing (e.g. for URLs with a relative path)\n        if (\n            (\n                mb_strpos($url_lc, \"://\") !== false\n                && !in_array(substr($url_lc, 0, 7), [\"file://\", \"phar://\"], true)\n            )\n            || mb_substr($url_lc, 0, 1) === \"#\"\n            || mb_strpos($url_lc, \"data:\") === 0\n            || mb_strpos($url_lc, \"mailto:\") === 0\n            || mb_strpos($url_lc, \"tel:\") === 0\n        ) {\n            return $url;\n        }\n\n        $res = \"\";\n        if (strpos($url_lc, \"file://\") === 0) {\n            $url = substr($url, 7);\n            $protocol = \"file://\";\n        } elseif (strpos($url_lc, \"phar://\") === 0) {\n            $res = substr($url, strpos($url_lc, \".phar\")+5);\n            $url = substr($url, 7, strpos($url_lc, \".phar\")-2);\n            $protocol = \"phar://\";\n        }\n\n        $ret = \"\";\n\n        $is_local_path = in_array($protocol, [\"file://\", \"phar://\"], true);\n\n        if ($is_local_path) {\n            //On Windows local file, an abs path can begin also with a '\\' or a drive letter and colon\n            //drive: followed by a relative path would be a drive specific default folder.\n            //not known in php app code, treat as abs path\n            //($url[1] !== ':' || ($url[2]!=='\\\\' && $url[2]!=='/'))\n            if ($url[0] !== '/' && (strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN' || (mb_strlen($url) > 1 && $url[0] !== '\\\\' && $url[1] !== ':'))) {\n                // For rel path and local access we ignore the host, and run the path through realpath()\n                $ret .= realpath($base_path) . '/';\n            }\n            $ret .= $url;\n            $ret = preg_replace('/\\?(.*)$/', \"\", $ret);\n\n            $filepath = realpath($ret);\n            if ($filepath === false) {\n                return null;\n            }\n\n            $ret = \"$protocol$filepath$res\";\n\n            return $ret;\n        }\n\n        $ret = $protocol;\n        // Protocol relative urls (e.g. \"//example.org/style.css\")\n        if (strpos($url, '//') === 0) {\n            $ret .= substr($url, 2);\n            //remote urls with backslash in html/css are not really correct, but lets be genereous\n        } elseif ($url[0] === '/' || $url[0] === '\\\\') {\n            // Absolute path\n            $ret .= $host . $url;\n        } else {\n            // Relative path\n            //$base_path = $base_path !== \"\" ? rtrim($base_path, \"/\\\\\") . \"/\" : \"\";\n            $ret .= $host . $base_path . $url;\n        }\n\n        // URL should now be complete, final cleanup\n        $parsed_url = parse_url($ret);\n\n        // reproduced from https://www.php.net/manual/en/function.parse-url.php#106731\n        $scheme   = isset($parsed_url['scheme']) ? $parsed_url['scheme'] . '://' : '';\n        $host     = isset($parsed_url['host']) ? $parsed_url['host'] : '';\n        $port     = isset($parsed_url['port']) ? ':' . $parsed_url['port'] : '';\n        $user     = isset($parsed_url['user']) ? $parsed_url['user'] : '';\n        $pass     = isset($parsed_url['pass']) ? ':' . $parsed_url['pass']  : '';\n        $pass     = ($user || $pass) ? \"$pass@\" : '';\n        $path     = isset($parsed_url['path']) ? $parsed_url['path'] : '';\n        $query    = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';\n        $fragment = isset($parsed_url['fragment']) ? '#' . $parsed_url['fragment'] : '';\n        \n        // partially reproduced from https://stackoverflow.com/a/1243431/264628\n        /* replace '//' or '/./' or '/foo/../' with '/' */\n        $re = array('#(/\\.?/)#', '#/(?!\\.\\.)[^/]+/\\.\\./#');\n        for ($n=1; $n>0; $path=preg_replace($re, '/', $path, -1, $n)) {}\n\n        $ret = \"$scheme$user$pass$host$port$path$query$fragment\";\n\n        return $ret;\n    }\n\n    /**\n     * Builds a HTTP Content-Disposition header string using `$dispositionType`\n     * and `$filename`.\n     *\n     * If the filename contains any characters not in the ISO-8859-1 character\n     * set, a fallback filename will be included for clients not supporting the\n     * `filename*` parameter.\n     *\n     * @param string $dispositionType\n     * @param string $filename\n     * @return string\n     */\n    public static function buildContentDispositionHeader($dispositionType, $filename)\n    {\n        $encoding = mb_detect_encoding($filename);\n        $fallbackfilename = mb_convert_encoding($filename, \"ISO-8859-1\", $encoding);\n        $fallbackfilename = str_replace(\"\\\"\", \"\", $fallbackfilename);\n        $encodedfilename = rawurlencode($filename);\n\n        $contentDisposition = \"Content-Disposition: $dispositionType; filename=\\\"$fallbackfilename\\\"\";\n        if ($fallbackfilename !== $filename) {\n            $contentDisposition .= \"; filename*=UTF-8''$encodedfilename\";\n        }\n\n        return $contentDisposition;\n    }\n\n    /**\n     * Converts decimal numbers to roman numerals.\n     *\n     * As numbers larger than 3999 (and smaller than 1) cannot be represented in\n     * the standard form of roman numerals, those are left in decimal form.\n     *\n     * See https://en.wikipedia.org/wiki/Roman_numerals#Standard_form\n     *\n     * @param int|string $num\n     *\n     * @throws Exception\n     * @return string\n     */\n    public static function dec2roman($num): string\n    {\n\n        static $ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n        static $tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n        static $hund = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n        static $thou = [\"\", \"m\", \"mm\", \"mmm\"];\n\n        if (!is_numeric($num)) {\n            throw new Exception(\"dec2roman() requires a numeric argument.\");\n        }\n\n        if ($num >= 4000 || $num <= 0) {\n            return (string) $num;\n        }\n\n        $num = strrev((string)$num);\n\n        $ret = \"\";\n        switch (mb_strlen($num)) {\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 4:\n                $ret .= $thou[$num[3]];\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 3:\n                $ret .= $hund[$num[2]];\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 2:\n                $ret .= $tens[$num[1]];\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 1:\n                $ret .= $ones[$num[0]];\n            default:\n                break;\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Restrict a length to the given range.\n     *\n     * If min > max, the result is min.\n     *\n     * @param float $length\n     * @param float $min\n     * @param float $max\n     *\n     * @return float\n     */\n    public static function clamp(float $length, float $min, float $max): float\n    {\n        return max($min, min($length, $max));\n    }\n\n    /**\n     * Determines whether $value is a percentage or not\n     *\n     * @param string|float|int $value\n     *\n     * @return bool\n     */\n    public static function is_percent($value): bool\n    {\n        return is_string($value) && false !== mb_strpos($value, \"%\");\n    }\n\n    /**\n     * Parses a data URI scheme\n     * http://en.wikipedia.org/wiki/Data_URI_scheme\n     *\n     * @param string $data_uri The data URI to parse\n     *\n     * @return array|bool The result with charset, mime type and decoded data\n     */\n    public static function parse_data_uri($data_uri)\n    {\n        if (!preg_match('/^data:(?P<mime>[a-z0-9\\/+-.]+)(;charset=(?P<charset>[a-z0-9-])+)?(?P<base64>;base64)?\\,(?P<data>.*)?/is', $data_uri, $match)) {\n            return false;\n        }\n\n        $match['data'] = rawurldecode($match['data']);\n        $result = [\n            'charset' => $match['charset'] ? $match['charset'] : 'US-ASCII',\n            'mime' => $match['mime'] ? $match['mime'] : 'text/plain',\n            'data' => $match['base64'] ? base64_decode($match['data']) : $match['data'],\n        ];\n\n        return $result;\n    }\n\n    /**\n     * Encodes a Uniform Resource Identifier (URI) by replacing non-alphanumeric\n     * characters with a percent (%) sign followed by two hex digits, excepting\n     * characters in the URI reserved character set.\n     *\n     * Assumes that the URI is a complete URI, so does not encode reserved\n     * characters that have special meaning in the URI.\n     *\n     * Simulates the encodeURI function available in JavaScript\n     * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/encodeURI\n     *\n     * Source: http://stackoverflow.com/q/4929584/264628\n     *\n     * @param string $uri The URI to encode\n     * @return string The original URL with special characters encoded\n     */\n    public static function encodeURI($uri) {\n        $unescaped = [\n            '%2D'=>'-','%5F'=>'_','%2E'=>'.','%21'=>'!', '%7E'=>'~',\n            '%2A'=>'*', '%27'=>\"'\", '%28'=>'(', '%29'=>')'\n        ];\n        $reserved = [\n            '%3B'=>';','%2C'=>',','%2F'=>'/','%3F'=>'?','%3A'=>':',\n            '%40'=>'@','%26'=>'&','%3D'=>'=','%2B'=>'+','%24'=>'$'\n        ];\n        $score = [\n            '%23'=>'#'\n        ];\n        return strtr(rawurlencode(rawurldecode($uri)), array_merge($reserved, $unescaped, $score));\n    }\n\n    /**\n     * Decoder for RLE8 compression in windows bitmaps\n     * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_6x0u.asp\n     *\n     * @param string $str Data to decode\n     * @param int $width Image width\n     *\n     * @return string\n     */\n    public static function rle8_decode($str, $width)\n    {\n        $lineWidth = $width + (3 - ($width - 1) % 4);\n        $out = '';\n        $cnt = strlen($str);\n\n        for ($i = 0; $i < $cnt; $i++) {\n            $o = ord($str[$i]);\n            switch ($o) {\n                case 0: # ESCAPE\n                    $i++;\n                    switch (ord($str[$i])) {\n                        case 0: # NEW LINE\n                            $padCnt = $lineWidth - strlen($out) % $lineWidth;\n                            if ($padCnt < $lineWidth) {\n                                $out .= str_repeat(chr(0), $padCnt); # pad line\n                            }\n                            break;\n                        case 1: # END OF FILE\n                            $padCnt = $lineWidth - strlen($out) % $lineWidth;\n                            if ($padCnt < $lineWidth) {\n                                $out .= str_repeat(chr(0), $padCnt); # pad line\n                            }\n                            break 3;\n                        case 2: # DELTA\n                            $i += 2;\n                            break;\n                        default: # ABSOLUTE MODE\n                            $num = ord($str[$i]);\n                            for ($j = 0; $j < $num; $j++) {\n                                $out .= $str[++$i];\n                            }\n                            if ($num % 2) {\n                                $i++;\n                            }\n                    }\n                    break;\n                default:\n                    $out .= str_repeat($str[++$i], $o);\n            }\n        }\n        return $out;\n    }\n\n    /**\n     * Decoder for RLE4 compression in windows bitmaps\n     * see http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_6x0u.asp\n     *\n     * @param string $str Data to decode\n     * @param int $width Image width\n     *\n     * @return string\n     */\n    public static function rle4_decode($str, $width)\n    {\n        $w = floor($width / 2) + ($width % 2);\n        $lineWidth = $w + (3 - (($width - 1) / 2) % 4);\n        $pixels = [];\n        $cnt = strlen($str);\n        $c = 0;\n\n        for ($i = 0; $i < $cnt; $i++) {\n            $o = ord($str[$i]);\n            switch ($o) {\n                case 0: # ESCAPE\n                    $i++;\n                    switch (ord($str[$i])) {\n                        case 0: # NEW LINE\n                            while (count($pixels) % $lineWidth != 0) {\n                                $pixels[] = 0;\n                            }\n                            break;\n                        case 1: # END OF FILE\n                            while (count($pixels) % $lineWidth != 0) {\n                                $pixels[] = 0;\n                            }\n                            break 3;\n                        case 2: # DELTA\n                            $i += 2;\n                            break;\n                        default: # ABSOLUTE MODE\n                            $num = ord($str[$i]);\n                            for ($j = 0; $j < $num; $j++) {\n                                if ($j % 2 == 0) {\n                                    $c = ord($str[++$i]);\n                                    $pixels[] = ($c & 240) >> 4;\n                                } else {\n                                    $pixels[] = $c & 15;\n                                }\n                            }\n\n                            if ($num % 2 == 0) {\n                                $i++;\n                            }\n                    }\n                    break;\n                default:\n                    $c = ord($str[++$i]);\n                    for ($j = 0; $j < $o; $j++) {\n                        $pixels[] = ($j % 2 == 0 ? ($c & 240) >> 4 : $c & 15);\n                    }\n            }\n        }\n\n        $out = '';\n        if (count($pixels) % 2) {\n            $pixels[] = 0;\n        }\n\n        $cnt = count($pixels) / 2;\n\n        for ($i = 0; $i < $cnt; $i++) {\n            $out .= chr(16 * $pixels[2 * $i] + $pixels[2 * $i + 1]);\n        }\n\n        return $out;\n    }\n\n    /**\n     * parse a full url or pathname and return an array(protocol, host, path,\n     * file + query + fragment)\n     *\n     * @param string $url\n     * @return array\n     */\n    public static function explode_url($url)\n    {\n        $protocol = \"\";\n        $host = \"\";\n        $path = \"\";\n        $file = \"\";\n        $res = \"\";\n\n        $arr = parse_url($url);\n        if ( isset($arr[\"scheme\"]) ) {\n            $arr[\"scheme\"] = mb_strtolower($arr[\"scheme\"]);\n        }\n\n        if (isset($arr[\"scheme\"]) && $arr[\"scheme\"] !== \"file\" && $arr[\"scheme\"] !== \"phar\" && strlen($arr[\"scheme\"]) > 1) {\n            $protocol = $arr[\"scheme\"] . \"://\";\n\n            if (isset($arr[\"user\"])) {\n                $host .= $arr[\"user\"];\n\n                if (isset($arr[\"pass\"])) {\n                    $host .= \":\" . $arr[\"pass\"];\n                }\n\n                $host .= \"@\";\n            }\n\n            if (isset($arr[\"host\"])) {\n                $host .= $arr[\"host\"];\n            }\n\n            if (isset($arr[\"port\"])) {\n                $host .= \":\" . $arr[\"port\"];\n            }\n\n            if (isset($arr[\"path\"]) && $arr[\"path\"] !== \"\") {\n                // Do we have a trailing slash?\n                if ($arr[\"path\"][mb_strlen($arr[\"path\"]) - 1] === \"/\") {\n                    $path = $arr[\"path\"];\n                    $file = \"\";\n                } else {\n                    $path = rtrim(dirname($arr[\"path\"]), '/\\\\') . \"/\";\n                    $file = basename($arr[\"path\"]);\n                }\n            }\n\n            if (isset($arr[\"query\"])) {\n                $file .= \"?\" . $arr[\"query\"];\n            }\n\n            if (isset($arr[\"fragment\"])) {\n                $file .= \"#\" . $arr[\"fragment\"];\n            }\n\n        } else {\n\n            $protocol = \"\";\n            $host = \"\"; // localhost, really\n\n            $i = mb_stripos($url, \"://\");\n            if ($i !== false) {\n                $protocol = mb_strtolower(mb_substr($url, 0, $i + 3));\n                $url = mb_substr($url, $i + 3);\n            } else {\n                $protocol = \"file://\";\n            }\n\n            if ($protocol === \"phar://\") {\n                $res = substr($url, stripos($url, \".phar\")+5);\n                $url = substr($url, 7, stripos($url, \".phar\")-2);\n            }\n\n            $file = basename($url);\n            $path = dirname($url) . \"/\";\n        }\n\n        $ret = [$protocol, $host, $path, $file,\n            \"protocol\" => $protocol,\n            \"host\" => $host,\n            \"path\" => $path,\n            \"file\" => $file,\n            \"resource\" => $res];\n        return $ret;\n    }\n\n    /**\n     * Print debug messages\n     *\n     * @param string $type The type of debug messages to print\n     * @param string $msg The message to show\n     */\n    public static function dompdf_debug($type, $msg)\n    {\n        global $_DOMPDF_DEBUG_TYPES, $_dompdf_show_warnings, $_dompdf_debug;\n        if (isset($_DOMPDF_DEBUG_TYPES[$type]) && ($_dompdf_show_warnings || $_dompdf_debug)) {\n            $arr = debug_backtrace();\n\n            echo basename($arr[0][\"file\"]) . \" (\" . $arr[0][\"line\"] . \"): \" . $arr[1][\"function\"] . \": \";\n            Helpers::pre_r($msg);\n        }\n    }\n\n    /**\n     * Stores warnings in an array for display later\n     * This function allows warnings generated by the DomDocument parser\n     * and CSS loader ({@link Stylesheet}) to be captured and displayed\n     * later.  Without this function, errors are displayed immediately and\n     * PDF streaming is impossible.\n     * @see http://www.php.net/manual/en/function.set-error_handler.php\n     *\n     * @param int $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param string $errline\n     *\n     * @throws Exception\n     */\n    public static function record_warnings($errno, $errstr, $errfile, $errline)\n    {\n        // Not a warning or notice\n        if (!($errno & (E_WARNING | E_NOTICE | E_USER_NOTICE | E_USER_WARNING | E_STRICT | E_DEPRECATED | E_USER_DEPRECATED))) {\n            throw new Exception($errstr . \" $errno\");\n        }\n\n        global $_dompdf_warnings;\n        global $_dompdf_show_warnings;\n\n        if ($_dompdf_show_warnings) {\n            echo $errstr . \"\\n\";\n        }\n\n        $_dompdf_warnings[] = $errstr;\n    }\n\n    /**\n     * @param $c\n     * @return bool|string\n     */\n    public static function unichr($c)\n    {\n        if ($c <= 0x7F) {\n            return chr($c);\n        } else if ($c <= 0x7FF) {\n            return chr(0xC0 | $c >> 6) . chr(0x80 | $c & 0x3F);\n        } else if ($c <= 0xFFFF) {\n            return chr(0xE0 | $c >> 12) . chr(0x80 | $c >> 6 & 0x3F)\n            . chr(0x80 | $c & 0x3F);\n        } else if ($c <= 0x10FFFF) {\n            return chr(0xF0 | $c >> 18) . chr(0x80 | $c >> 12 & 0x3F)\n            . chr(0x80 | $c >> 6 & 0x3F)\n            . chr(0x80 | $c & 0x3F);\n        }\n        return false;\n    }\n\n    /**\n     * Converts a CMYK color to RGB\n     *\n     * @param float|float[] $c\n     * @param float $m\n     * @param float $y\n     * @param float $k\n     *\n     * @return float[]\n     */\n    public static function cmyk_to_rgb($c, $m = null, $y = null, $k = null)\n    {\n        if (is_array($c)) {\n            [$c, $m, $y, $k] = $c;\n        }\n\n        $c *= 255;\n        $m *= 255;\n        $y *= 255;\n        $k *= 255;\n\n        $r = (1 - round(2.55 * ($c + $k)));\n        $g = (1 - round(2.55 * ($m + $k)));\n        $b = (1 - round(2.55 * ($y + $k)));\n\n        if ($r < 0) {\n            $r = 0;\n        }\n        if ($g < 0) {\n            $g = 0;\n        }\n        if ($b < 0) {\n            $b = 0;\n        }\n\n        return [\n            $r, $g, $b,\n            \"r\" => $r, \"g\" => $g, \"b\" => $b\n        ];\n    }\n\n    /**\n     * getimagesize doesn't give a good size for 32bit BMP image v5\n     *\n     * @param string $filename\n     * @param resource $context\n     * @return array An array of three elements: width and height as\n     *         `float|int`, and image type as `string|null`.\n     */\n    public static function dompdf_getimagesize($filename, $context = null)\n    {\n        static $cache = [];\n\n        if (isset($cache[$filename])) {\n            return $cache[$filename];\n        }\n\n        [$width, $height, $type] = getimagesize($filename);\n\n        // Custom types\n        $types = [\n            IMAGETYPE_JPEG => \"jpeg\",\n            IMAGETYPE_GIF  => \"gif\",\n            IMAGETYPE_BMP  => \"bmp\",\n            IMAGETYPE_PNG  => \"png\",\n            IMAGETYPE_WEBP => \"webp\",\n        ];\n\n        $type = $types[$type] ?? null;\n\n        if ($width == null || $height == null) {\n            [$data] = Helpers::getFileContent($filename, $context);\n\n            if ($data !== null) {\n                if (substr($data, 0, 2) === \"BM\") {\n                    $meta = unpack(\"vtype/Vfilesize/Vreserved/Voffset/Vheadersize/Vwidth/Vheight\", $data);\n                    $width = (int) $meta[\"width\"];\n                    $height = (int) $meta[\"height\"];\n                    $type = \"bmp\";\n                } elseif (strpos($data, \"<svg\") !== false) {\n                    $doc = new \\Svg\\Document();\n                    $doc->loadFile($filename);\n\n                    [$width, $height] = $doc->getDimensions();\n                    $width = (float) $width;\n                    $height = (float) $height;\n                    $type = \"svg\";\n                }\n            }\n        }\n\n        return $cache[$filename] = [$width ?? 0, $height ?? 0, $type];\n    }\n\n    /**\n     * Credit goes to mgutt\n     * http://www.programmierer-forum.de/function-imagecreatefrombmp-welche-variante-laeuft-t143137.htm\n     * Modified by Fabien Menager to support RGB555 BMP format\n     */\n    public static function imagecreatefrombmp($filename, $context = null)\n    {\n        if (!function_exists(\"imagecreatetruecolor\")) {\n            trigger_error(\"The PHP GD extension is required, but is not installed.\", E_ERROR);\n            return false;\n        }\n\n        // version 1.00\n        if (!($fh = fopen($filename, 'rb'))) {\n            trigger_error('imagecreatefrombmp: Can not open ' . $filename, E_USER_WARNING);\n            return false;\n        }\n\n        $bytes_read = 0;\n\n        // read file header\n        $meta = unpack('vtype/Vfilesize/Vreserved/Voffset', fread($fh, 14));\n\n        // check for bitmap\n        if ($meta['type'] != 19778) {\n            trigger_error('imagecreatefrombmp: ' . $filename . ' is not a bitmap!', E_USER_WARNING);\n            return false;\n        }\n\n        // read image header\n        $meta += unpack('Vheadersize/Vwidth/Vheight/vplanes/vbits/Vcompression/Vimagesize/Vxres/Vyres/Vcolors/Vimportant', fread($fh, 40));\n        $bytes_read += 40;\n\n        // read additional bitfield header\n        if ($meta['compression'] == 3) {\n            $meta += unpack('VrMask/VgMask/VbMask', fread($fh, 12));\n            $bytes_read += 12;\n        }\n\n        // set bytes and padding\n        $meta['bytes'] = $meta['bits'] / 8;\n        $meta['decal'] = 4 - (4 * (($meta['width'] * $meta['bytes'] / 4) - floor($meta['width'] * $meta['bytes'] / 4)));\n        if ($meta['decal'] == 4) {\n            $meta['decal'] = 0;\n        }\n\n        // obtain imagesize\n        if ($meta['imagesize'] < 1) {\n            $meta['imagesize'] = $meta['filesize'] - $meta['offset'];\n            // in rare cases filesize is equal to offset so we need to read physical size\n            if ($meta['imagesize'] < 1) {\n                $meta['imagesize'] = @filesize($filename) - $meta['offset'];\n                if ($meta['imagesize'] < 1) {\n                    trigger_error('imagecreatefrombmp: Can not obtain filesize of ' . $filename . '!', E_USER_WARNING);\n                    return false;\n                }\n            }\n        }\n\n        // calculate colors\n        $meta['colors'] = !$meta['colors'] ? pow(2, $meta['bits']) : $meta['colors'];\n\n        // read color palette\n        $palette = [];\n        if ($meta['bits'] < 16) {\n            $palette = unpack('l' . $meta['colors'], fread($fh, $meta['colors'] * 4));\n            // in rare cases the color value is signed\n            if ($palette[1] < 0) {\n                foreach ($palette as $i => $color) {\n                    $palette[$i] = $color + 16777216;\n                }\n            }\n        }\n\n        // ignore extra bitmap headers\n        if ($meta['headersize'] > $bytes_read) {\n            fread($fh, $meta['headersize'] - $bytes_read);\n        }\n\n        // create gd image\n        $im = imagecreatetruecolor($meta['width'], $meta['height']);\n        $data = fread($fh, $meta['imagesize']);\n\n        // uncompress data\n        switch ($meta['compression']) {\n            case 1:\n                $data = Helpers::rle8_decode($data, $meta['width']);\n                break;\n            case 2:\n                $data = Helpers::rle4_decode($data, $meta['width']);\n                break;\n        }\n\n        $p = 0;\n        $vide = chr(0);\n        $y = $meta['height'] - 1;\n        $error = 'imagecreatefrombmp: ' . $filename . ' has not enough data!';\n\n        // loop through the image data beginning with the lower left corner\n        while ($y >= 0) {\n            $x = 0;\n            while ($x < $meta['width']) {\n                switch ($meta['bits']) {\n                    case 32:\n                    case 24:\n                        if (!($part = substr($data, $p, 3 /*$meta['bytes']*/))) {\n                            trigger_error($error, E_USER_WARNING);\n                            return $im;\n                        }\n                        $color = unpack('V', $part . $vide);\n                        break;\n                    case 16:\n                        if (!($part = substr($data, $p, 2 /*$meta['bytes']*/))) {\n                            trigger_error($error, E_USER_WARNING);\n                            return $im;\n                        }\n                        $color = unpack('v', $part);\n\n                        if (empty($meta['rMask']) || $meta['rMask'] != 0xf800) {\n                            $color[1] = (($color[1] & 0x7c00) >> 7) * 65536 + (($color[1] & 0x03e0) >> 2) * 256 + (($color[1] & 0x001f) << 3); // 555\n                        } else {\n                            $color[1] = (($color[1] & 0xf800) >> 8) * 65536 + (($color[1] & 0x07e0) >> 3) * 256 + (($color[1] & 0x001f) << 3); // 565\n                        }\n                        break;\n                    case 8:\n                        $color = unpack('n', $vide . substr($data, $p, 1));\n                        $color[1] = $palette[$color[1] + 1];\n                        break;\n                    case 4:\n                        $color = unpack('n', $vide . substr($data, floor($p), 1));\n                        $color[1] = ($p * 2) % 2 == 0 ? $color[1] >> 4 : $color[1] & 0x0F;\n                        $color[1] = $palette[$color[1] + 1];\n                        break;\n                    case 1:\n                        $color = unpack('n', $vide . substr($data, floor($p), 1));\n                        switch (($p * 8) % 8) {\n                            case 0:\n                                $color[1] = $color[1] >> 7;\n                                break;\n                            case 1:\n                                $color[1] = ($color[1] & 0x40) >> 6;\n                                break;\n                            case 2:\n                                $color[1] = ($color[1] & 0x20) >> 5;\n                                break;\n                            case 3:\n                                $color[1] = ($color[1] & 0x10) >> 4;\n                                break;\n                            case 4:\n                                $color[1] = ($color[1] & 0x8) >> 3;\n                                break;\n                            case 5:\n                                $color[1] = ($color[1] & 0x4) >> 2;\n                                break;\n                            case 6:\n                                $color[1] = ($color[1] & 0x2) >> 1;\n                                break;\n                            case 7:\n                                $color[1] = ($color[1] & 0x1);\n                                break;\n                        }\n                        $color[1] = $palette[$color[1] + 1];\n                        break;\n                    default:\n                        trigger_error('imagecreatefrombmp: ' . $filename . ' has ' . $meta['bits'] . ' bits and this is not supported!', E_USER_WARNING);\n                        return false;\n                }\n                imagesetpixel($im, $x, $y, $color[1]);\n                $x++;\n                $p += $meta['bytes'];\n            }\n            $y--;\n            $p += $meta['decal'];\n        }\n        fclose($fh);\n        return $im;\n    }\n\n    /**\n     * Gets the content of the file at the specified path using one of\n     * the following methods, in preferential order:\n     *  - file_get_contents: if allow_url_fopen is true or the file is local\n     *  - curl: if allow_url_fopen is false and curl is available\n     *\n     * @param string $uri\n     * @param resource $context\n     * @param int $offset\n     * @param int $maxlen\n     * @return string[]\n     */\n    public static function getFileContent($uri, $context = null, $offset = 0, $maxlen = null)\n    {\n        $content = null;\n        $headers = null;\n        [$protocol] = Helpers::explode_url($uri);\n        $is_local_path = in_array(strtolower($protocol), [\"\", \"file://\", \"phar://\"], true);\n        $can_use_curl = in_array(strtolower($protocol), [\"http://\", \"https://\"], true);\n\n        set_error_handler([self::class, 'record_warnings']);\n\n        try {\n            if ($is_local_path || ini_get('allow_url_fopen') || !$can_use_curl) {\n                if ($is_local_path === false) {\n                    $uri = Helpers::encodeURI($uri);\n                }\n                if (isset($maxlen)) {\n                    $result = file_get_contents($uri, false, $context, $offset, $maxlen);\n                } else {\n                    $result = file_get_contents($uri, false, $context, $offset);\n                }\n                if ($result !== false) {\n                    $content = $result;\n                }\n                if (isset($http_response_header)) {\n                    $headers = $http_response_header;\n                }\n\n            } elseif ($can_use_curl && function_exists('curl_exec')) {\n                $curl = curl_init($uri);\n\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);\n                curl_setopt($curl, CURLOPT_HEADER, true);\n                if ($offset > 0) {\n                    curl_setopt($curl, CURLOPT_RESUME_FROM, $offset);\n                }\n\n                if ($maxlen > 0) {\n                    curl_setopt($curl, CURLOPT_BUFFERSIZE, 128);\n                    curl_setopt($curl, CURLOPT_NOPROGRESS, false);\n                    curl_setopt($curl, CURLOPT_PROGRESSFUNCTION, function ($res, $download_size_total, $download_size, $upload_size_total, $upload_size) use ($maxlen) {\n                        return ($download_size > $maxlen) ? 1 : 0;\n                    });\n                }\n\n                $context_options = [];\n                if (!is_null($context)) {\n                    $context_options = stream_context_get_options($context);\n                }\n                foreach ($context_options as $stream => $options) {\n                    foreach ($options as $option => $value) {\n                        $key = strtolower($stream) . \":\" . strtolower($option);\n                        switch ($key) {\n                            case \"curl:curl_verify_ssl_host\":\n                                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, !$value ? 0 : 2);\n                                break;\n                            case \"curl:max_redirects\":\n                                curl_setopt($curl, CURLOPT_MAXREDIRS, $value);\n                                break;\n                            case \"http:follow_location\":\n                                curl_setopt($curl, CURLOPT_FOLLOWLOCATION, $value);\n                                break;\n                            case \"http:header\":\n                                if (is_string($value)) {\n                                    curl_setopt($curl, CURLOPT_HTTPHEADER, [$value]);\n                                } else {\n                                    curl_setopt($curl, CURLOPT_HTTPHEADER, $value);\n                                }\n                                break;\n                            case \"http:timeout\":\n                                curl_setopt($curl, CURLOPT_TIMEOUT, $value);\n                                break;\n                            case \"http:user_agent\":\n                                curl_setopt($curl, CURLOPT_USERAGENT, $value);\n                                break;\n                            case \"curl:curl_verify_ssl_peer\":\n                            case \"ssl:verify_peer\":\n                                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, $value);\n                                break;\n                        }\n                    }\n                }\n\n                $data = curl_exec($curl);\n\n                if ($data !== false && !curl_errno($curl)) {\n                    switch ($http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE)) {\n                        case 200:\n                            $raw_headers = substr($data, 0, curl_getinfo($curl, CURLINFO_HEADER_SIZE));\n                            $headers = preg_split(\"/[\\n\\r]+/\", trim($raw_headers));\n                            $content = substr($data, curl_getinfo($curl, CURLINFO_HEADER_SIZE));\n                            break;\n                    }\n                }\n                curl_close($curl);\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        return [$content, $headers];\n    }\n\n    /**\n     * @param string $str\n     * @return string\n     */\n    public static function mb_ucwords(string $str): string\n    {\n        $max_len = mb_strlen($str);\n        if ($max_len === 1) {\n            return mb_strtoupper($str);\n        }\n\n        $str = mb_strtoupper(mb_substr($str, 0, 1)) . mb_substr($str, 1);\n\n        foreach ([' ', '.', ',', '!', '?', '-', '+'] as $s) {\n            $pos = 0;\n            while (($pos = mb_strpos($str, $s, $pos)) !== false) {\n                $pos++;\n                // Nothing to do if the separator is the last char of the string\n                if ($pos !== false && $pos < $max_len) {\n                    // If the char we want to upper is the last char there is nothing to append behind\n                    if ($pos + 1 < $max_len) {\n                        $str = mb_substr($str, 0, $pos) . mb_strtoupper(mb_substr($str, $pos, 1)) . mb_substr($str, $pos + 1);\n                    } else {\n                        $str = mb_substr($str, 0, $pos) . mb_strtoupper(mb_substr($str, $pos, 1));\n                    }\n                }\n            }\n        }\n\n        return $str;\n    }\n\n    /**\n     * Check whether two lengths should be considered equal, accounting for\n     * inaccuracies in float computation.\n     *\n     * The implementation relies on the fact that we are neither dealing with\n     * very large, nor with very small numbers in layout. Adapted from\n     * https://floating-point-gui.de/errors/comparison/.\n     *\n     * @param float $a\n     * @param float $b\n     *\n     * @return bool\n     */\n    public static function lengthEqual(float $a, float $b): bool\n    {\n        // The epsilon results in a precision of at least:\n        // * 7 decimal digits at around 1\n        // * 4 decimal digits at around 1000 (around the size of common paper formats)\n        // * 2 decimal digits at around 100,000 (100,000pt ~ 35.28m)\n        static $epsilon = 1e-8;\n        static $almostZero = 1e-12;\n\n        $diff = abs($a - $b);\n\n        if ($a === $b || $diff < $almostZero) {\n            return true;\n        }\n\n        return $diff < $epsilon * max(abs($a), abs($b));\n    }\n\n    /**\n     * Check `$a < $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthLess(float $a, float $b): bool\n    {\n        return $a < $b && !self::lengthEqual($a, $b);\n    }\n\n    /**\n     * Check `$a <= $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthLessOrEqual(float $a, float $b): bool\n    {\n        return $a <= $b || self::lengthEqual($a, $b);\n    }\n\n    /**\n     * Check `$a > $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthGreater(float $a, float $b): bool\n    {\n        return $a > $b && !self::lengthEqual($a, $b);\n    }\n\n    /**\n     * Check `$a >= $b`, accounting for inaccuracies in float computation.\n     */\n    public static function lengthGreaterOrEqual(float $a, float $b): bool\n    {\n        return $a >= $b || self::lengthEqual($a, $b);\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Image;\n\nuse Dompdf\\Options;\nuse Dompdf\\Helpers;\nuse Dompdf\\Exception\\ImageException;\n\n/**\n * Static class that resolves image urls and downloads and caches\n * remote images if required.\n *\n * @package dompdf\n */\nclass Cache\n{\n    /**\n     * Array of downloaded images.  Cached so that identical images are\n     * not needlessly downloaded.\n     *\n     * @var array\n     */\n    protected static $_cache = [];\n\n    /**\n     * @var array\n     */\n    protected static $tempImages = [];\n\n    /**\n     * The url to the \"broken image\" used when images can't be loaded\n     *\n     * @var string\n     */\n    public static $broken_image = \"data:image/svg+xml;charset=utf8,%3C?xml version='1.0'?%3E%3Csvg width='64' height='64' xmlns='http://www.w3.org/2000/svg'%3E%3Cg%3E%3Crect stroke='%23666666' id='svg_1' height='60.499994' width='60.166667' y='1.666669' x='1.999998' stroke-width='1.5' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_3' y2='59.333253' x2='59.749916' y1='4.333415' x1='4.250079' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3Cline stroke-linecap='null' stroke-linejoin='null' id='svg_4' y2='59.999665' x2='4.062838' y1='3.750342' x1='60.062164' stroke-width='1.5' stroke='%23999999' fill='none'/%3E%3C/g%3E%3C/svg%3E\";\n\n    public static $error_message = \"Image not found or type unknown\";\n    \n    /**\n     * Resolve and fetch an image for use.\n     *\n     * @param string $url       The url of the image\n     * @param string $protocol  Default protocol if none specified in $url\n     * @param string $host      Default host if none specified in $url\n     * @param string $base_path Default path if none specified in $url\n     * @param Options $options  An instance of Dompdf\\Options\n     *\n     * @return array            An array with three elements: The local path to the image, the image\n     *                          extension, and an error message if the image could not be cached\n     */\n    static function resolve_url($url, $protocol, $host, $base_path, Options $options)\n    {\n        $tempfile = null;\n        $resolved_url = null;\n        $type = null;\n        $message = null;\n        \n        try {\n            $full_url = Helpers::build_url($protocol, $host, $base_path, $url);\n\n            if ($full_url === null) {\n                throw new ImageException(\"Unable to parse image URL $url.\", E_WARNING);\n            }\n\n            $parsed_url = Helpers::explode_url($full_url);\n            $protocol = strtolower($parsed_url[\"protocol\"]);\n            $is_data_uri = strpos($protocol, \"data:\") === 0;\n            \n            if (!$is_data_uri) {\n                $allowed_protocols = $options->getAllowedProtocols();\n                if (!array_key_exists($protocol, $allowed_protocols)) {\n                    throw new ImageException(\"Permission denied on $url. The communication protocol is not supported.\", E_WARNING);\n                }\n                foreach ($allowed_protocols[$protocol][\"rules\"] as $rule) {\n                    [$result, $message] = $rule($full_url);\n                    if (!$result) {\n                        throw new ImageException(\"Error loading $url: $message\", E_WARNING);\n                    }\n                }\n            }\n\n            if ($protocol === \"file://\") {\n                $resolved_url = $full_url;\n            } elseif (isset(self::$_cache[$full_url])) {\n                $resolved_url = self::$_cache[$full_url];\n            } else {\n                $tmp_dir = $options->getTempDir();\n                if (($resolved_url = @tempnam($tmp_dir, \"ca_dompdf_img_\")) === false) {\n                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                }\n                $tempfile = $resolved_url;\n\n                $image = null;\n                if ($is_data_uri) {\n                    if (($parsed_data_uri = Helpers::parse_data_uri($url)) !== false) {\n                        $image = $parsed_data_uri[\"data\"];\n                    }\n                } else {\n                    list($image, $http_response_header) = Helpers::getFileContent($full_url, $options->getHttpContext());\n                }\n\n                // Image not found or invalid\n                if ($image === null) {\n                    $msg = ($is_data_uri ? \"Data-URI could not be parsed\" : \"Image not found\");\n                    throw new ImageException($msg, E_WARNING);\n                }\n\n                if (@file_put_contents($resolved_url, $image) === false) {\n                    throw new ImageException(\"Unable to create temporary image in \" . $tmp_dir, E_WARNING);\n                }\n\n                self::$_cache[$full_url] = $resolved_url;\n            }\n\n            // Check if the local file is readable\n            if (!is_readable($resolved_url) || !filesize($resolved_url)) {\n                throw new ImageException(\"Image not readable or empty\", E_WARNING);\n            }\n\n            list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $options->getHttpContext());\n\n            if (($width && $height && in_array($type, [\"gif\", \"png\", \"jpeg\", \"bmp\", \"svg\",\"webp\"], true)) === false) {\n                throw new ImageException(\"Image type unknown\", E_WARNING);\n            }\n        } catch (ImageException $e) {\n            if ($tempfile) {\n                unlink($tempfile);\n            }\n            $resolved_url = self::$broken_image;\n            $type = \"svg\";\n            $message = self::$error_message;\n            Helpers::record_warnings($e->getCode(), $e->getMessage() . \" \\n $url\", $e->getFile(), $e->getLine());\n            self::$_cache[$full_url] = $resolved_url;\n        }\n\n        return [$resolved_url, $type, $message];\n    }\n\n    /**\n     * Register a temp file for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $tempPath The path of the temp file to register.\n     * @param string $key      An optional key to register the temp file at.\n     */\n    static function addTempImage(string $filePath, string $tempPath, string $key = \"default\"): void\n    {\n        if (!isset(self::$tempImages[$filePath])) {\n            self::$tempImages[$filePath] = [];\n        }\n\n        self::$tempImages[$filePath][$key] = $tempPath;\n    }\n\n    /**\n     * Get the path of a temp file registered for the given original image file.\n     *\n     * @param string $filePath The path of the original image.\n     * @param string $key      The key the temp file is registered at.\n     */\n    static function getTempImage(string $filePath, string $key = \"default\"): ?string\n    {\n        return self::$tempImages[$filePath][$key] ?? null;\n    }\n\n    /**\n     * Unlink all cached images (i.e. temporary images either downloaded\n     * or converted) except for the bundled \"broken image\"\n     */\n    static function clear(bool $debugPng = false)\n    {\n        foreach (self::$_cache as $file) {\n            if ($file === self::$broken_image) {\n                continue;\n            }\n            if ($debugPng) {\n                print \"[clear unlink $file]\";\n            }\n            if (file_exists($file)) {\n                unlink($file);\n            }\n        }\n\n        foreach (self::$tempImages as $versions) {\n            foreach ($versions as $file) {\n                if ($file === self::$broken_image) {\n                    continue;\n                }\n                if ($debugPng) {\n                    print \"[unlink temp image $file]\";\n                }\n                if (file_exists($file)) {\n                    unlink($file);\n                }\n            }\n        }\n\n        self::$_cache = [];\n        self::$tempImages = [];\n    }\n\n    static function detect_type($file, $context = null)\n    {\n        list(, , $type) = Helpers::dompdf_getimagesize($file, $context);\n\n        return $type;\n    }\n\n    static function is_broken($url)\n    {\n        return $url === self::$broken_image;\n    }\n}\n\nif (file_exists(realpath(__DIR__ . \"/../../lib/res/broken_image.svg\"))) {\n    Cache::$broken_image = realpath(__DIR__ . \"/../../lib/res/broken_image.svg\");\n}\n", "<?php\nnamespace Dompdf;\n\nclass Options\n{\n    /**\n     * The root of your DOMPDF installation\n     *\n     * @var string\n     */\n    private $rootDir;\n\n    /**\n     * The location of a temporary directory.\n     *\n     * The directory specified must be writable by the webserver process.\n     * The temporary directory is required to download remote images and when\n     * using the PFDLib back end.\n     *\n     * @var string\n     */\n    private $tempDir;\n\n    /**\n     * The location of the DOMPDF font directory\n     *\n     * The location of the directory where DOMPDF will store fonts and font metrics\n     * Note: This directory must exist and be writable by the webserver process.\n     *\n     * @var string\n     */\n    private $fontDir;\n\n    /**\n     * The location of the DOMPDF font cache directory\n     *\n     * This directory contains the cached font metrics for the fonts used by DOMPDF.\n     * This directory can be the same as $fontDir\n     *\n     * Note: This directory must exist and be writable by the webserver process.\n     *\n     * @var string\n     */\n    private $fontCache;\n\n    /**\n     * dompdf's \"chroot\"\n     *\n     * Prevents dompdf from accessing system files or other files on the webserver.\n     * All local files opened by dompdf must be in a subdirectory of this directory\n     * or array of directories.\n     * DO NOT set it to '/' since this could allow an attacker to use dompdf to\n     * read any files on the server.  This should be an absolute path.\n     *\n     * ==== IMPORTANT ====\n     * This setting may increase the risk of system exploit. Do not change\n     * this settings without understanding the consequences. Additional\n     * documentation is available on the dompdf wiki at:\n     * https://github.com/dompdf/dompdf/wiki\n     *\n     * @var array\n     */\n    private $chroot;\n\n    /**\n    * Protocol whitelist\n    *\n    * Protocols and PHP wrappers allowed in URIs. Full support is not\n    * guaranteed for the protocols/wrappers specified by this array.\n    *\n    * @var array\n    */\n    private $allowedProtocols = [\n        \"file://\" => [\"rules\" => []],\n        \"http://\" => [\"rules\" => []],\n        \"https://\" => [\"rules\" => []]\n    ];\n\n    /**\n     * @var string\n     */\n    private $logOutputFile;\n\n    /**\n     * html target media view which should be rendered into pdf.\n     * List of types and parsing rules for future extensions:\n     * http://www.w3.org/TR/REC-html40/types.html\n     *   screen, tty, tv, projection, handheld, print, braille, aural, all\n     * Note: aural is deprecated in CSS 2.1 because it is replaced by speech in CSS 3.\n     * Note, even though the generated pdf file is intended for print output,\n     * the desired content might be different (e.g. screen or projection view of html file).\n     * Therefore allow specification of content here.\n     *\n     * @var string\n     */\n    private $defaultMediaType = \"screen\";\n\n    /**\n     * The default paper size.\n     *\n     * North America standard is \"letter\"; other countries generally \"a4\"\n     * @see \\Dompdf\\Adapter\\CPDF::PAPER_SIZES for valid sizes\n     *\n     * @var string\n     */\n    private $defaultPaperSize = \"letter\";\n\n    /**\n     * The default paper orientation.\n     *\n     * The orientation of the page (portrait or landscape).\n     *\n     * @var string\n     */\n    private $defaultPaperOrientation = \"portrait\";\n\n    /**\n     * The default font family\n     *\n     * Used if no suitable fonts can be found. This must exist in the font folder.\n     *\n     * @var string\n     */\n    private $defaultFont = \"serif\";\n\n    /**\n     * Image DPI setting\n     *\n     * This setting determines the default DPI setting for images and fonts.  The\n     * DPI may be overridden for inline images by explicitly setting the\n     * image's width & height style attributes (i.e. if the image's native\n     * width is 600 pixels and you specify the image's width as 72 points,\n     * the image will have a DPI of 600 in the rendered PDF.  The DPI of\n     * background images can not be overridden and is controlled entirely\n     * via this parameter.\n     *\n     * For the purposes of DOMPDF, pixels per inch (PPI) = dots per inch (DPI).\n     * If a size in html is given as px (or without unit as image size),\n     * this tells the corresponding size in pt at 72 DPI.\n     * This adjusts the relative sizes to be similar to the rendering of the\n     * html page in a reference browser.\n     *\n     * In pdf, always 1 pt = 1/72 inch\n     *\n     * @var int\n     */\n    private $dpi = 96;\n\n    /**\n     * A ratio applied to the fonts height to be more like browsers' line height\n     *\n     * @var float\n     */\n    private $fontHeightRatio = 1.1;\n\n    /**\n     * Enable embedded PHP\n     *\n     * If this setting is set to true then DOMPDF will automatically evaluate\n     * embedded PHP contained within <script type=\"text/php\"> ... </script> tags.\n     *\n     * ==== IMPORTANT ====\n     * Enabling this for documents you do not trust (e.g. arbitrary remote html\n     * pages) is a security risk. Embedded scripts are run with the same level of\n     * system access available to dompdf. Set this option to false (recommended)\n     * if you wish to process untrusted documents.\n     *\n     * This setting may increase the risk of system exploit. Do not change\n     * this settings without understanding the consequences. Additional\n     * documentation is available on the dompdf wiki at:\n     * https://github.com/dompdf/dompdf/wiki\n     *\n     * @var bool\n     */\n    private $isPhpEnabled = false;\n\n    /**\n     * Enable remote file access\n     *\n     * If this setting is set to true, DOMPDF will access remote sites for\n     * images and CSS files as required.\n     *\n     * ==== IMPORTANT ====\n     * This can be a security risk, in particular in combination with isPhpEnabled and\n     * allowing remote html code to be passed to $dompdf = new DOMPDF(); $dompdf->load_html(...);\n     * This allows anonymous users to download legally doubtful internet content which on\n     * tracing back appears to being downloaded by your server, or allows malicious php code\n     * in remote html pages to be executed by your server with your account privileges.\n     *\n     * This setting may increase the risk of system exploit. Do not change\n     * this settings without understanding the consequences. Additional\n     * documentation is available on the dompdf wiki at:\n     * https://github.com/dompdf/dompdf/wiki\n     *\n     * @var bool\n     */\n    private $isRemoteEnabled = false;\n\n    /**\n     * Enable inline Javascript\n     *\n     * If this setting is set to true then DOMPDF will automatically insert\n     * JavaScript code contained within <script type=\"text/javascript\"> ... </script> tags.\n     *\n     * @var bool\n     */\n    private $isJavascriptEnabled = true;\n\n    /**\n     * Use the HTML5 Lib parser\n     *\n     * @deprecated\n     * @var bool\n     */\n    private $isHtml5ParserEnabled = true;\n\n    /**\n     * Whether to enable font subsetting or not.\n     *\n     * @var bool\n     */\n    private $isFontSubsettingEnabled = true;\n\n    /**\n     * @var bool\n     */\n    private $debugPng = false;\n\n    /**\n     * @var bool\n     */\n    private $debugKeepTemp = false;\n\n    /**\n     * @var bool\n     */\n    private $debugCss = false;\n\n    /**\n     * @var bool\n     */\n    private $debugLayout = false;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutLines = true;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutBlocks = true;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutInline = true;\n\n    /**\n     * @var bool\n     */\n    private $debugLayoutPaddingBox = true;\n\n    /**\n     * The PDF rendering backend to use\n     *\n     * Valid settings are 'PDFLib', 'CPDF', 'GD', and 'auto'. 'auto' will\n     * look for PDFLib and use it if found, or if not it will fall back on\n     * CPDF. 'GD' renders PDFs to graphic files. {@link Dompdf\\CanvasFactory}\n     * ultimately determines which rendering class to instantiate\n     * based on this setting.\n     *\n     * @var string\n     */\n    private $pdfBackend = \"CPDF\";\n\n    /**\n     * PDFlib license key\n     *\n     * If you are using a licensed, commercial version of PDFlib, specify\n     * your license key here.  If you are using PDFlib-Lite or are evaluating\n     * the commercial version of PDFlib, comment out this setting.\n     *\n     * @link http://www.pdflib.com\n     *\n     * If pdflib present in web server and auto or selected explicitly above,\n     * a real license code must exist!\n     *\n     * @var string\n     */\n    private $pdflibLicense = \"\";\n\n    /**\n     * HTTP context created with stream_context_create()\n     * Will be used for file_get_contents\n     *\n     * @link https://www.php.net/manual/context.php\n     *\n     * @var resource\n     */\n    private $httpContext;\n\n    /**\n     * @param array $attributes\n     */\n    public function __construct(array $attributes = null)\n    {\n        $rootDir = realpath(__DIR__ . \"/../\");\n        $this->setChroot(array($rootDir));\n        $this->setRootDir($rootDir);\n        $this->setTempDir(sys_get_temp_dir());\n        $this->setFontDir($rootDir . \"/lib/fonts\");\n        $this->setFontCache($this->getFontDir());\n\n        $ver = \"\";\n        $versionFile = realpath(__DIR__ . '/../VERSION');\n        if (($version = file_get_contents($versionFile)) !== false) {\n            $version = trim($version);\n            if ($version !== '$Format:<%h>$') {\n                $ver = \"/$version\";\n            }\n        }\n        $this->setHttpContext([\n            \"http\" => [\n                \"follow_location\" => false,\n                \"user_agent\" => \"Dompdf$ver https://github.com/dompdf/dompdf\"\n            ]\n        ]);\n\n        $this->setAllowedProtocols([\"file://\", \"http://\", \"https://\"]);\n\n        if (null !== $attributes) {\n            $this->set($attributes);\n        }\n    }\n\n    /**\n     * @param array|string $attributes\n     * @param null|mixed $value\n     * @return $this\n     */\n    public function set($attributes, $value = null)\n    {\n        if (!is_array($attributes)) {\n            $attributes = [$attributes => $value];\n        }\n        foreach ($attributes as $key => $value) {\n            if ($key === 'tempDir' || $key === 'temp_dir') {\n                $this->setTempDir($value);\n            } elseif ($key === 'fontDir' || $key === 'font_dir') {\n                $this->setFontDir($value);\n            } elseif ($key === 'fontCache' || $key === 'font_cache') {\n                $this->setFontCache($value);\n            } elseif ($key === 'chroot') {\n                $this->setChroot($value);\n            } elseif ($key === 'allowedProtocols') {\n                $this->setAllowedProtocols($value);\n            } elseif ($key === 'logOutputFile' || $key === 'log_output_file') {\n                $this->setLogOutputFile($value);\n            } elseif ($key === 'defaultMediaType' || $key === 'default_media_type') {\n                $this->setDefaultMediaType($value);\n            } elseif ($key === 'defaultPaperSize' || $key === 'default_paper_size') {\n                $this->setDefaultPaperSize($value);\n            } elseif ($key === 'defaultPaperOrientation' || $key === 'default_paper_orientation') {\n                $this->setDefaultPaperOrientation($value);\n            } elseif ($key === 'defaultFont' || $key === 'default_font') {\n                $this->setDefaultFont($value);\n            } elseif ($key === 'dpi') {\n                $this->setDpi($value);\n            } elseif ($key === 'fontHeightRatio' || $key === 'font_height_ratio') {\n                $this->setFontHeightRatio($value);\n            } elseif ($key === 'isPhpEnabled' || $key === 'is_php_enabled' || $key === 'enable_php') {\n                $this->setIsPhpEnabled($value);\n            } elseif ($key === 'isRemoteEnabled' || $key === 'is_remote_enabled' || $key === 'enable_remote') {\n                $this->setIsRemoteEnabled($value);\n            } elseif ($key === 'isJavascriptEnabled' || $key === 'is_javascript_enabled' || $key === 'enable_javascript') {\n                $this->setIsJavascriptEnabled($value);\n            } elseif ($key === 'isHtml5ParserEnabled' || $key === 'is_html5_parser_enabled' || $key === 'enable_html5_parser') {\n                $this->setIsHtml5ParserEnabled($value);\n            } elseif ($key === 'isFontSubsettingEnabled' || $key === 'is_font_subsetting_enabled' || $key === 'enable_font_subsetting') {\n                $this->setIsFontSubsettingEnabled($value);\n            } elseif ($key === 'debugPng' || $key === 'debug_png') {\n                $this->setDebugPng($value);\n            } elseif ($key === 'debugKeepTemp' || $key === 'debug_keep_temp') {\n                $this->setDebugKeepTemp($value);\n            } elseif ($key === 'debugCss' || $key === 'debug_css') {\n                $this->setDebugCss($value);\n            } elseif ($key === 'debugLayout' || $key === 'debug_layout') {\n                $this->setDebugLayout($value);\n            } elseif ($key === 'debugLayoutLines' || $key === 'debug_layout_lines') {\n                $this->setDebugLayoutLines($value);\n            } elseif ($key === 'debugLayoutBlocks' || $key === 'debug_layout_blocks') {\n                $this->setDebugLayoutBlocks($value);\n            } elseif ($key === 'debugLayoutInline' || $key === 'debug_layout_inline') {\n                $this->setDebugLayoutInline($value);\n            } elseif ($key === 'debugLayoutPaddingBox' || $key === 'debug_layout_padding_box') {\n                $this->setDebugLayoutPaddingBox($value);\n            } elseif ($key === 'pdfBackend' || $key === 'pdf_backend') {\n                $this->setPdfBackend($value);\n            } elseif ($key === 'pdflibLicense' || $key === 'pdflib_license') {\n                $this->setPdflibLicense($value);\n            } elseif ($key === 'httpContext' || $key === 'http_context') {\n                $this->setHttpContext($value);\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * @param string $key\n     * @return mixed\n     */\n    public function get($key)\n    {\n        if ($key === 'tempDir' || $key === 'temp_dir') {\n            return $this->getTempDir();\n        } elseif ($key === 'fontDir' || $key === 'font_dir') {\n            return $this->getFontDir();\n        } elseif ($key === 'fontCache' || $key === 'font_cache') {\n            return $this->getFontCache();\n        } elseif ($key === 'chroot') {\n            return $this->getChroot();\n        } elseif ($key === 'allowedProtocols') {\n            return $this->getAllowedProtocols();\n        } elseif ($key === 'logOutputFile' || $key === 'log_output_file') {\n            return $this->getLogOutputFile();\n        } elseif ($key === 'defaultMediaType' || $key === 'default_media_type') {\n            return $this->getDefaultMediaType();\n        } elseif ($key === 'defaultPaperSize' || $key === 'default_paper_size') {\n            return $this->getDefaultPaperSize();\n        } elseif ($key === 'defaultPaperOrientation' || $key === 'default_paper_orientation') {\n            return $this->getDefaultPaperOrientation();\n        } elseif ($key === 'defaultFont' || $key === 'default_font') {\n            return $this->getDefaultFont();\n        } elseif ($key === 'dpi') {\n            return $this->getDpi();\n        } elseif ($key === 'fontHeightRatio' || $key === 'font_height_ratio') {\n            return $this->getFontHeightRatio();\n        } elseif ($key === 'isPhpEnabled' || $key === 'is_php_enabled' || $key === 'enable_php') {\n            return $this->getIsPhpEnabled();\n        } elseif ($key === 'isRemoteEnabled' || $key === 'is_remote_enabled' || $key === 'enable_remote') {\n            return $this->getIsRemoteEnabled();\n        } elseif ($key === 'isJavascriptEnabled' || $key === 'is_javascript_enabled' || $key === 'enable_javascript') {\n            return $this->getIsJavascriptEnabled();\n        } elseif ($key === 'isHtml5ParserEnabled' || $key === 'is_html5_parser_enabled' || $key === 'enable_html5_parser') {\n            return $this->getIsHtml5ParserEnabled();\n        } elseif ($key === 'isFontSubsettingEnabled' || $key === 'is_font_subsetting_enabled' || $key === 'enable_font_subsetting') {\n            return $this->getIsFontSubsettingEnabled();\n        } elseif ($key === 'debugPng' || $key === 'debug_png') {\n            return $this->getDebugPng();\n        } elseif ($key === 'debugKeepTemp' || $key === 'debug_keep_temp') {\n            return $this->getDebugKeepTemp();\n        } elseif ($key === 'debugCss' || $key === 'debug_css') {\n            return $this->getDebugCss();\n        } elseif ($key === 'debugLayout' || $key === 'debug_layout') {\n            return $this->getDebugLayout();\n        } elseif ($key === 'debugLayoutLines' || $key === 'debug_layout_lines') {\n            return $this->getDebugLayoutLines();\n        } elseif ($key === 'debugLayoutBlocks' || $key === 'debug_layout_blocks') {\n            return $this->getDebugLayoutBlocks();\n        } elseif ($key === 'debugLayoutInline' || $key === 'debug_layout_inline') {\n            return $this->getDebugLayoutInline();\n        } elseif ($key === 'debugLayoutPaddingBox' || $key === 'debug_layout_padding_box') {\n            return $this->getDebugLayoutPaddingBox();\n        } elseif ($key === 'pdfBackend' || $key === 'pdf_backend') {\n            return $this->getPdfBackend();\n        } elseif ($key === 'pdflibLicense' || $key === 'pdflib_license') {\n            return $this->getPdflibLicense();\n        } elseif ($key === 'httpContext' || $key === 'http_context') {\n            return $this->getHttpContext();\n        }\n        return null;\n    }\n\n    /**\n     * @param string $pdfBackend\n     * @return $this\n     */\n    public function setPdfBackend($pdfBackend)\n    {\n        $this->pdfBackend = $pdfBackend;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getPdfBackend()\n    {\n        return $this->pdfBackend;\n    }\n\n    /**\n     * @param string $pdflibLicense\n     * @return $this\n     */\n    public function setPdflibLicense($pdflibLicense)\n    {\n        $this->pdflibLicense = $pdflibLicense;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getPdflibLicense()\n    {\n        return $this->pdflibLicense;\n    }\n\n    /**\n     * @param array|string $chroot\n     * @return $this\n     */\n    public function setChroot($chroot, $delimiter = ',')\n    {\n        if (is_string($chroot)) {\n            $this->chroot = explode($delimiter, $chroot);\n        } elseif (is_array($chroot)) {\n            $this->chroot = $chroot;\n        }\n        return $this;\n    }\n\n    /**\n     * @return array\n     */\n    public function getAllowedProtocols()\n    {\n        return $this->allowedProtocols;\n    }\n\n    /**\n     * @param array $allowedProtocols The protocols to allow as an array ([\"protocol://\" => [\"rules\" => [callable]]], ...) or a string list of the protocols\n     * @return $this\n     */\n    public function setAllowedProtocols(array $allowedProtocols)\n    {\n        $protocols = [];\n        foreach ($allowedProtocols as $protocol => $config) {\n            if (is_string($protocol)) {\n                $protocols[$protocol] = [];\n                if (is_array($config)) {\n                    $protocols[$protocol] = $config;\n                }\n            } elseif (is_string($config)) {\n                $protocols[$config] = [];\n            }\n        }\n        $this->allowedProtocols = [];\n        foreach ($protocols as $protocol => $config) {\n            $this->addAllowedProtocol($protocol, ...($config[\"rules\"] ?? []));\n        }\n        return $this;\n    }\n\n    /**\n     * Adds a new protocol to the allowed protocols collection\n     *\n     * @param string $protocol The scheme to add (e.g. \"http://\")\n     * @param callable $rule A callable that validates the protocol\n     * @return $this\n     */\n    public function addAllowedProtocol(string $protocol, callable ...$rules)\n    {\n        $protocol = strtolower($protocol);\n        if (empty($rules)) {\n            $rules = [];\n            switch ($protocol) {\n                case \"file://\":\n                    $rules[] = [$this, \"validateLocalUri\"];\n                    break;\n                case \"http://\":\n                case \"https://\":\n                    $rules[] = [$this, \"validateRemoteUri\"];\n                    break;\n                case \"phar://\":\n                    $rules[] = [$this, \"validatePharUri\"];\n                    break;\n            }\n        }\n        $this->allowedProtocols[$protocol] = [\"rules\" => $rules];\n        return $this;\n    }\n\n    /**\n     * @return array\n     */\n    public function getChroot()\n    {\n        $chroot = [];\n        if (is_array($this->chroot)) {\n            $chroot = $this->chroot;\n        }\n        return $chroot;\n    }\n\n    /**\n     * @param boolean $debugCss\n     * @return $this\n     */\n    public function setDebugCss($debugCss)\n    {\n        $this->debugCss = $debugCss;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugCss()\n    {\n        return $this->debugCss;\n    }\n\n    /**\n     * @param boolean $debugKeepTemp\n     * @return $this\n     */\n    public function setDebugKeepTemp($debugKeepTemp)\n    {\n        $this->debugKeepTemp = $debugKeepTemp;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugKeepTemp()\n    {\n        return $this->debugKeepTemp;\n    }\n\n    /**\n     * @param boolean $debugLayout\n     * @return $this\n     */\n    public function setDebugLayout($debugLayout)\n    {\n        $this->debugLayout = $debugLayout;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayout()\n    {\n        return $this->debugLayout;\n    }\n\n    /**\n     * @param boolean $debugLayoutBlocks\n     * @return $this\n     */\n    public function setDebugLayoutBlocks($debugLayoutBlocks)\n    {\n        $this->debugLayoutBlocks = $debugLayoutBlocks;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutBlocks()\n    {\n        return $this->debugLayoutBlocks;\n    }\n\n    /**\n     * @param boolean $debugLayoutInline\n     * @return $this\n     */\n    public function setDebugLayoutInline($debugLayoutInline)\n    {\n        $this->debugLayoutInline = $debugLayoutInline;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutInline()\n    {\n        return $this->debugLayoutInline;\n    }\n\n    /**\n     * @param boolean $debugLayoutLines\n     * @return $this\n     */\n    public function setDebugLayoutLines($debugLayoutLines)\n    {\n        $this->debugLayoutLines = $debugLayoutLines;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutLines()\n    {\n        return $this->debugLayoutLines;\n    }\n\n    /**\n     * @param boolean $debugLayoutPaddingBox\n     * @return $this\n     */\n    public function setDebugLayoutPaddingBox($debugLayoutPaddingBox)\n    {\n        $this->debugLayoutPaddingBox = $debugLayoutPaddingBox;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugLayoutPaddingBox()\n    {\n        return $this->debugLayoutPaddingBox;\n    }\n\n    /**\n     * @param boolean $debugPng\n     * @return $this\n     */\n    public function setDebugPng($debugPng)\n    {\n        $this->debugPng = $debugPng;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getDebugPng()\n    {\n        return $this->debugPng;\n    }\n\n    /**\n     * @param string $defaultFont\n     * @return $this\n     */\n    public function setDefaultFont($defaultFont)\n    {\n        if (!($defaultFont === null || trim($defaultFont) === \"\")) {\n            $this->defaultFont = $defaultFont;\n        } else {\n            $this->defaultFont = \"serif\";\n        }\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultFont()\n    {\n        return $this->defaultFont;\n    }\n\n    /**\n     * @param string $defaultMediaType\n     * @return $this\n     */\n    public function setDefaultMediaType($defaultMediaType)\n    {\n        $this->defaultMediaType = $defaultMediaType;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultMediaType()\n    {\n        return $this->defaultMediaType;\n    }\n\n    /**\n     * @param string $defaultPaperSize\n     * @return $this\n     */\n    public function setDefaultPaperSize($defaultPaperSize)\n    {\n        $this->defaultPaperSize = $defaultPaperSize;\n        return $this;\n    }\n\n    /**\n     * @param string $defaultPaperOrientation\n     * @return $this\n     */\n    public function setDefaultPaperOrientation($defaultPaperOrientation)\n    {\n        $this->defaultPaperOrientation = $defaultPaperOrientation;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultPaperSize()\n    {\n        return $this->defaultPaperSize;\n    }\n\n    /**\n     * @return string\n     */\n    public function getDefaultPaperOrientation()\n    {\n        return $this->defaultPaperOrientation;\n    }\n\n    /**\n     * @param int $dpi\n     * @return $this\n     */\n    public function setDpi($dpi)\n    {\n        $this->dpi = $dpi;\n        return $this;\n    }\n\n    /**\n     * @return int\n     */\n    public function getDpi()\n    {\n        return $this->dpi;\n    }\n\n    /**\n     * @param string $fontCache\n     * @return $this\n     */\n    public function setFontCache($fontCache)\n    {\n        $this->fontCache = $fontCache;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getFontCache()\n    {\n        return $this->fontCache;\n    }\n\n    /**\n     * @param string $fontDir\n     * @return $this\n     */\n    public function setFontDir($fontDir)\n    {\n        $this->fontDir = $fontDir;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getFontDir()\n    {\n        return $this->fontDir;\n    }\n\n    /**\n     * @param float $fontHeightRatio\n     * @return $this\n     */\n    public function setFontHeightRatio($fontHeightRatio)\n    {\n        $this->fontHeightRatio = $fontHeightRatio;\n        return $this;\n    }\n\n    /**\n     * @return float\n     */\n    public function getFontHeightRatio()\n    {\n        return $this->fontHeightRatio;\n    }\n\n    /**\n     * @param boolean $isFontSubsettingEnabled\n     * @return $this\n     */\n    public function setIsFontSubsettingEnabled($isFontSubsettingEnabled)\n    {\n        $this->isFontSubsettingEnabled = $isFontSubsettingEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsFontSubsettingEnabled()\n    {\n        return $this->isFontSubsettingEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isFontSubsettingEnabled()\n    {\n        return $this->getIsFontSubsettingEnabled();\n    }\n\n    /**\n     * @deprecated\n     * @param boolean $isHtml5ParserEnabled\n     * @return $this\n     */\n    public function setIsHtml5ParserEnabled($isHtml5ParserEnabled)\n    {\n        $this->isHtml5ParserEnabled = $isHtml5ParserEnabled;\n        return $this;\n    }\n\n    /**\n     * @deprecated\n     * @return boolean\n     */\n    public function getIsHtml5ParserEnabled()\n    {\n        return $this->isHtml5ParserEnabled;\n    }\n\n    /**\n     * @deprecated\n     * @return boolean\n     */\n    public function isHtml5ParserEnabled()\n    {\n        return $this->getIsHtml5ParserEnabled();\n    }\n\n    /**\n     * @param boolean $isJavascriptEnabled\n     * @return $this\n     */\n    public function setIsJavascriptEnabled($isJavascriptEnabled)\n    {\n        $this->isJavascriptEnabled = $isJavascriptEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsJavascriptEnabled()\n    {\n        return $this->isJavascriptEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isJavascriptEnabled()\n    {\n        return $this->getIsJavascriptEnabled();\n    }\n\n    /**\n     * @param boolean $isPhpEnabled\n     * @return $this\n     */\n    public function setIsPhpEnabled($isPhpEnabled)\n    {\n        $this->isPhpEnabled = $isPhpEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsPhpEnabled()\n    {\n        return $this->isPhpEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isPhpEnabled()\n    {\n        return $this->getIsPhpEnabled();\n    }\n\n    /**\n     * @param boolean $isRemoteEnabled\n     * @return $this\n     */\n    public function setIsRemoteEnabled($isRemoteEnabled)\n    {\n        $this->isRemoteEnabled = $isRemoteEnabled;\n        return $this;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function getIsRemoteEnabled()\n    {\n        return $this->isRemoteEnabled;\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isRemoteEnabled()\n    {\n        return $this->getIsRemoteEnabled();\n    }\n\n    /**\n     * @param string $logOutputFile\n     * @return $this\n     */\n    public function setLogOutputFile($logOutputFile)\n    {\n        $this->logOutputFile = $logOutputFile;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getLogOutputFile()\n    {\n        return $this->logOutputFile;\n    }\n\n    /**\n     * @param string $tempDir\n     * @return $this\n     */\n    public function setTempDir($tempDir)\n    {\n        $this->tempDir = $tempDir;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getTempDir()\n    {\n        return $this->tempDir;\n    }\n\n    /**\n     * @param string $rootDir\n     * @return $this\n     */\n    public function setRootDir($rootDir)\n    {\n        $this->rootDir = $rootDir;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getRootDir()\n    {\n        return $this->rootDir;\n    }\n\n    /**\n     * Sets the HTTP context\n     *\n     * @param resource|array $httpContext\n     * @return $this\n     */\n    public function setHttpContext($httpContext)\n    {\n        $this->httpContext = is_array($httpContext) ? stream_context_create($httpContext) : $httpContext;\n        return $this;\n    }\n\n    /**\n     * Returns the HTTP context\n     *\n     * @return resource\n     */\n    public function getHttpContext()\n    {\n        return $this->httpContext;\n    }\n\n    public function validateLocalUri(string $uri)\n    {\n        if ($uri === null || strlen($uri) === 0) {\n            return [false, \"The URI must not be empty.\"];\n        }\n\n        $realfile = realpath(str_replace(\"file://\", \"\", $uri));\n\n        $dirs = $this->chroot;\n        $dirs[] = $this->rootDir;\n        $chrootValid = false;\n        foreach ($dirs as $chrootPath) {\n            $chrootPath = realpath($chrootPath);\n            if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                $chrootValid = true;\n                break;\n            }\n        }\n        if ($chrootValid !== true) {\n            return [false, \"Permission denied. The file could not be found under the paths specified by Options::chroot.\"];\n        }\n\n        if (!$realfile) {\n            return [false, \"File not found.\"];\n        }\n\n        return [true, null];\n    }\n\n    public function validatePharUri(string $uri)\n    {\n        if ($uri === null || strlen($uri) === 0) {\n            return [false, \"The URI must not be empty.\"];\n        }\n\n        $file = substr(substr($uri, 0, strpos($uri, \".phar\") + 5), 7);\n        return $this->validateLocalUri($file);\n    }\n\n    public function validateRemoteUri(string $uri)\n    {\n        if ($uri === null || strlen($uri) === 0) {\n            return [false, \"The URI must not be empty.\"];\n        }\n\n        if (!$this->isRemoteEnabled) {\n            return [false, \"Remote file requested, but remote file download is disabled.\"];\n        }\n\n        return [true, null];\n    }\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\nnamespace Dompdf\\Renderer;\n\nuse Dompdf\\Adapter\\CPDF;\nuse Dompdf\\Css\\Color;\nuse Dompdf\\Css\\Style;\nuse Dompdf\\Dompdf;\nuse Dompdf\\Helpers;\nuse Dompdf\\Frame;\nuse Dompdf\\Image\\Cache;\n\n/**\n * Base renderer class\n *\n * @package dompdf\n */\nabstract class AbstractRenderer\n{\n\n    /**\n     * Rendering backend\n     *\n     * @var \\Dompdf\\Canvas\n     */\n    protected $_canvas;\n\n    /**\n     * Current dompdf instance\n     *\n     * @var Dompdf\n     */\n    protected $_dompdf;\n\n    /**\n     * Class constructor\n     *\n     * @param Dompdf $dompdf The current dompdf instance\n     */\n    function __construct(Dompdf $dompdf)\n    {\n        $this->_dompdf = $dompdf;\n        $this->_canvas = $dompdf->getCanvas();\n    }\n\n    /**\n     * Render a frame.\n     *\n     * Specialized in child classes\n     *\n     * @param Frame $frame The frame to render\n     */\n    abstract function render(Frame $frame);\n\n    /**\n     * Render a background image over a rectangular area\n     *\n     * @param string $url   The background image to load\n     * @param float $x      The left edge of the rectangular area\n     * @param float $y      The top edge of the rectangular area\n     * @param float $width  The width of the rectangular area\n     * @param float $height The height of the rectangular area\n     * @param Style $style  The associated Style object\n     *\n     * @throws \\Exception\n     */\n    protected function _background_image($url, $x, $y, $width, $height, $style)\n    {\n        if (!function_exists(\"imagecreatetruecolor\")) {\n            throw new \\Exception(\"The PHP GD extension is required, but is not installed.\");\n        }\n\n        $sheet = $style->get_stylesheet();\n\n        // Skip degenerate cases\n        if ($width == 0 || $height == 0) {\n            return;\n        }\n\n        $box_width = $width;\n        $box_height = $height;\n\n        //debugpng\n        if ($this->_dompdf->getOptions()->getDebugPng()) {\n            print '[_background_image ' . $url . ']';\n        }\n\n        list($img, $type, /*$msg*/) = Cache::resolve_url(\n            $url,\n            $sheet->get_protocol(),\n            $sheet->get_host(),\n            $sheet->get_base_path(),\n            $this->_dompdf->getOptions()\n        );\n\n        // Bail if the image is no good\n        if (Cache::is_broken($img)) {\n            return;\n        }\n\n        //Try to optimize away reading and composing of same background multiple times\n        //Postponing read with imagecreatefrom   ...()\n        //final composition parameters and name not known yet\n        //Therefore read dimension directly from file, instead of creating gd object first.\n        //$img_w = imagesx($src); $img_h = imagesy($src);\n\n        list($img_w, $img_h) = Helpers::dompdf_getimagesize($img, $this->_dompdf->getHttpContext());\n        if ($img_w == 0 || $img_h == 0) {\n            return;\n        }\n\n        // save for later check if file needs to be resized.\n        $org_img_w = $img_w;\n        $org_img_h = $img_h;\n\n        $repeat = $style->background_repeat;\n        $dpi = $this->_dompdf->getOptions()->getDpi();\n\n        //Increase background resolution and dependent box size according to image resolution to be placed in\n        //Then image can be copied in without resize\n        $bg_width = round((float)($width * $dpi) / 72);\n        $bg_height = round((float)($height * $dpi) / 72);\n\n        list($img_w, $img_h) = $this->_resize_background_image(\n            $img_w,\n            $img_h,\n            $bg_width,\n            $bg_height,\n            $style->background_size,\n            $dpi\n        );\n        //Need %bg_x, $bg_y as background pos, where img starts, converted to pixel\n\n        list($bg_x, $bg_y) = $style->background_position;\n\n        if (Helpers::is_percent($bg_x)) {\n            // The point $bg_x % from the left edge of the image is placed\n            // $bg_x % from the left edge of the background rectangle\n            $p = ((float)$bg_x) / 100.0;\n            $x1 = $p * $img_w;\n            $x2 = $p * $bg_width;\n\n            $bg_x = $x2 - $x1;\n        } else {\n            $bg_x = (float)($style->length_in_pt($bg_x) * $dpi) / 72;\n        }\n\n        $bg_x = round($bg_x + (float)$style->length_in_pt($style->border_left_width) * $dpi / 72);\n\n        if (Helpers::is_percent($bg_y)) {\n            // The point $bg_y % from the left edge of the image is placed\n            // $bg_y % from the left edge of the background rectangle\n            $p = ((float)$bg_y) / 100.0;\n            $y1 = $p * $img_h;\n            $y2 = $p * $bg_height;\n\n            $bg_y = $y2 - $y1;\n        } else {\n            $bg_y = (float)($style->length_in_pt($bg_y) * $dpi) / 72;\n        }\n\n        $bg_y = round($bg_y + (float)$style->length_in_pt($style->border_top_width) * $dpi / 72);\n\n        //clip background to the image area on partial repeat. Nothing to do if img off area\n        //On repeat, normalize start position to the tile at immediate left/top or 0/0 of area\n        //On no repeat with positive offset: move size/start to have offset==0\n        //Handle x/y Dimensions separately\n\n        if ($repeat !== \"repeat\" && $repeat !== \"repeat-x\") {\n            //No repeat x\n            if ($bg_x < 0) {\n                $bg_width = $img_w + $bg_x;\n            } else {\n                $x += ($bg_x * 72) / $dpi;\n                $bg_width = $bg_width - $bg_x;\n                if ($bg_width > $img_w) {\n                    $bg_width = $img_w;\n                }\n                $bg_x = 0;\n            }\n\n            if ($bg_width <= 0) {\n                return;\n            }\n\n            $width = (float)($bg_width * 72) / $dpi;\n        } else {\n            //repeat x\n            if ($bg_x < 0) {\n                $bg_x = -((-$bg_x) % $img_w);\n            } else {\n                $bg_x = $bg_x % $img_w;\n                if ($bg_x > 0) {\n                    $bg_x -= $img_w;\n                }\n            }\n        }\n\n        if ($repeat !== \"repeat\" && $repeat !== \"repeat-y\") {\n            //no repeat y\n            if ($bg_y < 0) {\n                $bg_height = $img_h + $bg_y;\n            } else {\n                $y += ($bg_y * 72) / $dpi;\n                $bg_height = $bg_height - $bg_y;\n                if ($bg_height > $img_h) {\n                    $bg_height = $img_h;\n                }\n                $bg_y = 0;\n            }\n            if ($bg_height <= 0) {\n                return;\n            }\n            $height = (float)($bg_height * 72) / $dpi;\n        } else {\n            //repeat y\n            if ($bg_y < 0) {\n                $bg_y = -((-$bg_y) % $img_h);\n            } else {\n                $bg_y = $bg_y % $img_h;\n                if ($bg_y > 0) {\n                    $bg_y -= $img_h;\n                }\n            }\n        }\n\n        //Optimization, if repeat has no effect\n        if ($repeat === \"repeat\" && $bg_y <= 0 && $img_h + $bg_y >= $bg_height) {\n            $repeat = \"repeat-x\";\n        }\n\n        if ($repeat === \"repeat\" && $bg_x <= 0 && $img_w + $bg_x >= $bg_width) {\n            $repeat = \"repeat-y\";\n        }\n\n        if (($repeat === \"repeat-x\" && $bg_x <= 0 && $img_w + $bg_x >= $bg_width) ||\n            ($repeat === \"repeat-y\" && $bg_y <= 0 && $img_h + $bg_y >= $bg_height)\n        ) {\n            $repeat = \"no-repeat\";\n        }\n\n        // Avoid rendering identical background-image variants multiple times\n        // This is not dependent of background color of box! .'_'.(is_array($bg_color) ? $bg_color[\"hex\"] : $bg_color)\n        // Note: Here, bg_* are the start values, not end values after going through the tile loops!\n\n        $key = implode(\"_\", [$bg_width, $bg_height, $img_w, $img_h, $bg_x, $bg_y, $repeat]);\n        // FIXME: This will fail when a file with that exact name exists in the\n        // same directory, included in the document as regular image\n        $cpdfKey = $img . \"_\" . $key;\n        $tmpFile = Cache::getTempImage($img, $key);\n        $cached = ($this->_canvas instanceof CPDF && $this->_canvas->get_cpdf()->image_iscached($cpdfKey))\n            || ($tmpFile !== null && file_exists($tmpFile));\n\n        if (!$cached) {\n            // img: image url string\n            // img_w, img_h: original image size in px\n            // width, height: box size in pt\n            // bg_width, bg_height: box size in px\n            // x, y: left/top edge of box on page in pt\n            // start_x, start_y: placement of image relative to pattern\n            // $repeat: repeat mode\n            // $bg: GD object of result image\n            // $src: GD object of original image\n\n            // Create a new image to fit over the background rectangle\n            $bg = imagecreatetruecolor($bg_width, $bg_height);\n            $cpdfFromGd = true;\n\n            switch (strtolower($type)) {\n                case \"png\":\n                    $cpdfFromGd = false;\n                    imagesavealpha($bg, true);\n                    imagealphablending($bg, false);\n                    $src = @imagecreatefrompng($img);\n                    break;\n\n                case \"jpeg\":\n                    $src = @imagecreatefromjpeg($img);\n                    break;\n\n                case \"webp\":\n                    $src = @imagecreatefromwebp($img);\n                    break;\n\n                case \"gif\":\n                    $src = @imagecreatefromgif($img);\n                    break;\n\n                case \"bmp\":\n                    $src = @Helpers::imagecreatefrombmp($img);\n                    break;\n\n                default:\n                    return; // Unsupported image type\n            }\n\n            if ($src == null) {\n                return;\n            }\n\n            if ($img_w != $org_img_w || $img_h != $org_img_h) {\n                $newSrc = imagescale($src, $img_w, $img_h);\n                imagedestroy($src);\n                $src = $newSrc;\n            }\n\n            if ($src == null) {\n                return;\n            }\n\n            //Background color if box is not relevant here\n            //Non transparent image: box clipped to real size. Background non relevant.\n            //Transparent image: The image controls the transparency and lets shine through whatever background.\n            //However on transparent image preset the composed image with the transparency color,\n            //to keep the transparency when copying over the non transparent parts of the tiles.\n            $ti = imagecolortransparent($src);\n            $palletsize = imagecolorstotal($src);\n\n            if ($ti >= 0 && $ti < $palletsize) {\n                $tc = imagecolorsforindex($src, $ti);\n                $ti = imagecolorallocate($bg, $tc['red'], $tc['green'], $tc['blue']);\n                imagefill($bg, 0, 0, $ti);\n                imagecolortransparent($bg, $ti);\n            }\n\n            //This has only an effect for the non repeatable dimension.\n            //compute start of src and dest coordinates of the single copy\n            if ($bg_x < 0) {\n                $dst_x = 0;\n                $src_x = -$bg_x;\n            } else {\n                $src_x = 0;\n                $dst_x = $bg_x;\n            }\n\n            if ($bg_y < 0) {\n                $dst_y = 0;\n                $src_y = -$bg_y;\n            } else {\n                $src_y = 0;\n                $dst_y = $bg_y;\n            }\n\n            //For historical reasons exchange meanings of variables:\n            //start_* will be the start values, while bg_* will be the temporary start values in the loops\n            $start_x = $bg_x;\n            $start_y = $bg_y;\n\n            // Copy regions from the source image to the background\n            if ($repeat === \"no-repeat\") {\n                // Simply place the image on the background\n                imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $img_w, $img_h);\n\n            } else if ($repeat === \"repeat-x\") {\n                for ($bg_x = $start_x; $bg_x < $bg_width; $bg_x += $img_w) {\n                    if ($bg_x < 0) {\n                        $dst_x = 0;\n                        $src_x = -$bg_x;\n                        $w = $img_w + $bg_x;\n                    } else {\n                        $dst_x = $bg_x;\n                        $src_x = 0;\n                        $w = $img_w;\n                    }\n                    imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $w, $img_h);\n                }\n            } else if ($repeat === \"repeat-y\") {\n\n                for ($bg_y = $start_y; $bg_y < $bg_height; $bg_y += $img_h) {\n                    if ($bg_y < 0) {\n                        $dst_y = 0;\n                        $src_y = -$bg_y;\n                        $h = $img_h + $bg_y;\n                    } else {\n                        $dst_y = $bg_y;\n                        $src_y = 0;\n                        $h = $img_h;\n                    }\n                    imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $img_w, $h);\n                }\n            } else if ($repeat === \"repeat\") {\n                for ($bg_y = $start_y; $bg_y < $bg_height; $bg_y += $img_h) {\n                    for ($bg_x = $start_x; $bg_x < $bg_width; $bg_x += $img_w) {\n                        if ($bg_x < 0) {\n                            $dst_x = 0;\n                            $src_x = -$bg_x;\n                            $w = $img_w + $bg_x;\n                        } else {\n                            $dst_x = $bg_x;\n                            $src_x = 0;\n                            $w = $img_w;\n                        }\n\n                        if ($bg_y < 0) {\n                            $dst_y = 0;\n                            $src_y = -$bg_y;\n                            $h = $img_h + $bg_y;\n                        } else {\n                            $dst_y = $bg_y;\n                            $src_y = 0;\n                            $h = $img_h;\n                        }\n                        imagecopy($bg, $src, $dst_x, $dst_y, $src_x, $src_y, $w, $h);\n                    }\n                }\n            } else {\n                print 'Unknown repeat!';\n            }\n\n            imagedestroy($src);\n\n            if ($cpdfFromGd && $this->_canvas instanceof CPDF) {\n                // Skip writing temp file as the GD object is added directly\n            } else {\n                $tmpDir = $this->_dompdf->getOptions()->getTempDir();\n                $tmpName = @tempnam($tmpDir, \"bg_dompdf_img_\");\n                @unlink($tmpName);\n                $tmpFile = \"$tmpName.png\";\n\n                imagepng($bg, $tmpFile);\n                imagedestroy($bg);\n\n                Cache::addTempImage($img, $tmpFile, $key);\n            }\n        } else {\n            $bg = null;\n            $cpdfFromGd = $tmpFile === null;\n        }\n\n        if ($this->_dompdf->getOptions()->getDebugPng()) {\n            print '[_background_image ' . $tmpFile . ']';\n        }\n\n        $this->_canvas->clipping_rectangle($x, $y, $box_width, $box_height);\n\n        // When using cpdf and optimization to direct png creation from gd object is available,\n        // don't create temp file, but place gd object directly into the pdf\n        if ($cpdfFromGd && $this->_canvas instanceof CPDF) {\n            // Note: CPDF_Adapter image converts y position\n            $this->_canvas->get_cpdf()->addImagePng($bg, $cpdfKey, $x, $this->_canvas->get_height() - $y - $height, $width, $height);\n\n            if (isset($bg)) {\n                imagedestroy($bg);\n            }\n        } else {\n            $this->_canvas->image($tmpFile, $x, $y, $width, $height);\n        }\n\n        $this->_canvas->clipping_end();\n    }\n\n    /**\n     * @param $style\n     * @param $width\n     * @return array\n     */\n    protected function _get_dash_pattern($style, $width)\n    {\n        $pattern = [];\n\n        switch ($style) {\n            default:\n                /*case \"solid\":\n                case \"double\":\n                case \"groove\":\n                case \"inset\":\n                case \"outset\":\n                case \"ridge\":*/\n            case \"none\":\n                break;\n\n            case \"dotted\":\n                if ($width <= 1) {\n                    $pattern = [$width, $width * 2];\n                } else {\n                    $pattern = [$width];\n                }\n                break;\n\n            case \"dashed\":\n                $pattern = [3 * $width];\n                break;\n        }\n\n        return $pattern;\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_none($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        return;\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_hidden($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        return;\n    }\n\n    // Border rendering functions\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_dotted($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        $this->_border_line($x, $y, $length, $color, $widths, $side, $corner_style, \"dotted\", $r1, $r2);\n    }\n\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_dashed($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        $this->_border_line($x, $y, $length, $color, $widths, $side, $corner_style, \"dashed\", $r1, $r2);\n    }\n\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_solid($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        // TODO: Solve rendering where one corner is beveled (radius == 0), one corner isn't.\n        if ($corner_style !== \"bevel\" || $r1 > 0 || $r2 > 0) {\n            // do it the simple way\n            $this->_border_line($x, $y, $length, $color, $widths, $side, $corner_style, \"solid\", $r1, $r2);\n            return;\n        }\n\n        list($top, $right, $bottom, $left) = $widths;\n\n        // All this polygon business is for beveled corners...\n        switch ($side) {\n            case \"top\":\n                $points = [$x, $y,\n                    $x + $length, $y,\n                    $x + $length - $right, $y + $top,\n                    $x + $left, $y + $top];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            case \"bottom\":\n                $points = [$x, $y,\n                    $x + $length, $y,\n                    $x + $length - $right, $y - $bottom,\n                    $x + $left, $y - $bottom];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            case \"left\":\n                $points = [$x, $y,\n                    $x, $y + $length,\n                    $x + $left, $y + $length - $bottom,\n                    $x + $left, $y + $top];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            case \"right\":\n                $points = [$x, $y,\n                    $x, $y + $length,\n                    $x - $right, $y + $length - $bottom,\n                    $x - $right, $y + $top];\n                $this->_canvas->polygon($points, $color, null, null, true);\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * @param $side\n     * @param $ratio\n     * @param $top\n     * @param $right\n     * @param $bottom\n     * @param $left\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $r1\n     * @param $r2\n     */\n    protected function _apply_ratio($side, $ratio, $top, $right, $bottom, $left, &$x, &$y, &$length, &$r1, &$r2)\n    {\n        switch ($side) {\n            case \"top\":\n                $r1 -= $left * $ratio;\n                $r2 -= $right * $ratio;\n                $x += $left * $ratio;\n                $y += $top * $ratio;\n                $length -= $left * $ratio + $right * $ratio;\n                break;\n\n            case \"bottom\":\n                $r1 -= $right * $ratio;\n                $r2 -= $left * $ratio;\n                $x += $left * $ratio;\n                $y -= $bottom * $ratio;\n                $length -= $left * $ratio + $right * $ratio;\n                break;\n\n            case \"left\":\n                $r1 -= $top * $ratio;\n                $r2 -= $bottom * $ratio;\n                $x += $left * $ratio;\n                $y += $top * $ratio;\n                $length -= $top * $ratio + $bottom * $ratio;\n                break;\n\n            case \"right\":\n                $r1 -= $bottom * $ratio;\n                $r2 -= $top * $ratio;\n                $x -= $right * $ratio;\n                $y += $top * $ratio;\n                $length -= $top * $ratio + $bottom * $ratio;\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_double($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        list($top, $right, $bottom, $left) = $widths;\n\n        $third_widths = [$top / 3, $right / 3, $bottom / 3, $left / 3];\n\n        // draw the outer border\n        $this->_border_solid($x, $y, $length, $color, $third_widths, $side, $corner_style, $r1, $r2);\n\n        $this->_apply_ratio($side, 2 / 3, $top, $right, $bottom, $left, $x, $y, $length, $r1, $r2);\n\n        $this->_border_solid($x, $y, $length, $color, $third_widths, $side, $corner_style, $r1, $r2);\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_groove($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        list($top, $right, $bottom, $left) = $widths;\n\n        $half_widths = [$top / 2, $right / 2, $bottom / 2, $left / 2];\n\n        $this->_border_inset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n\n        $this->_apply_ratio($side, 0.5, $top, $right, $bottom, $left, $x, $y, $length, $r1, $r2);\n\n        $this->_border_outset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_ridge($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        list($top, $right, $bottom, $left) = $widths;\n\n        $half_widths = [$top / 2, $right / 2, $bottom / 2, $left / 2];\n\n        $this->_border_outset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n\n        $this->_apply_ratio($side, 0.5, $top, $right, $bottom, $left, $x, $y, $length, $r1, $r2);\n\n        $this->_border_inset($x, $y, $length, $color, $half_widths, $side, $corner_style, $r1, $r2);\n    }\n\n    /**\n     * @param $c\n     * @return mixed\n     */\n    protected function _tint($c)\n    {\n        if (!is_numeric($c)) {\n            return $c;\n        }\n\n        return min(1, $c + 0.16);\n    }\n\n    /**\n     * @param $c\n     * @return mixed\n     */\n    protected function _shade($c)\n    {\n        if (!is_numeric($c)) {\n            return $c;\n        }\n\n        return max(0, $c - 0.33);\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_inset($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        switch ($side) {\n            case \"top\":\n            case \"left\":\n                $shade = array_map([$this, \"_shade\"], $color);\n                $this->_border_solid($x, $y, $length, $shade, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            case \"bottom\":\n            case \"right\":\n                $tint = array_map([$this, \"_tint\"], $color);\n                $this->_border_solid($x, $y, $length, $tint, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param int $r1\n     * @param int $r2\n     */\n    protected function _border_outset($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $r1 = 0, $r2 = 0)\n    {\n        switch ($side) {\n            case \"top\":\n            case \"left\":\n                $tint = array_map([$this, \"_tint\"], $color);\n                $this->_border_solid($x, $y, $length, $tint, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            case \"bottom\":\n            case \"right\":\n                $shade = array_map([$this, \"_shade\"], $color);\n                $this->_border_solid($x, $y, $length, $shade, $widths, $side, $corner_style, $r1, $r2);\n                break;\n\n            default:\n                return;\n        }\n    }\n\n    /**\n     * Draws a solid, dotted, or dashed line, observing the border radius\n     *\n     * @param $x\n     * @param $y\n     * @param $length\n     * @param $color\n     * @param $widths\n     * @param $side\n     * @param string $corner_style\n     * @param $pattern_name\n     * @param int $r1\n     * @param int $r2\n     *\n     * @var $top\n     */\n    protected function _border_line($x, $y, $length, $color, $widths, $side, $corner_style = \"bevel\", $pattern_name = \"none\", $r1 = 0, $r2 = 0)\n    {\n        /** used by $$side */\n        list($top, $right, $bottom, $left) = $widths;\n        $width = $$side;\n\n        $pattern = $this->_get_dash_pattern($pattern_name, $width);\n\n        $half_width = $width / 2;\n        $r1 -= $half_width;\n        $r2 -= $half_width;\n        $adjust = $r1 / 80;\n        $length -= $width;\n\n        switch ($side) {\n            case \"top\":\n                $x += $half_width;\n                $y += $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x + $r1, $y + $r1, $r1, $r1, 90 - $adjust, 135 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x + $r1, $y, $x + $length - $r2, $y, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x + $length - $r2, $y + $r2, $r2, $r2, 45 - $adjust, 90 + $adjust, $color, $width, $pattern);\n                }\n                break;\n\n            case \"bottom\":\n                $x += $half_width;\n                $y -= $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x + $r1, $y - $r1, $r1, $r1, 225 - $adjust, 270 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x + $r1, $y, $x + $length - $r2, $y, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x + $length - $r2, $y - $r2, $r2, $r2, 270 - $adjust, 315 + $adjust, $color, $width, $pattern);\n                }\n                break;\n\n            case \"left\":\n                $y += $half_width;\n                $x += $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x + $r1, $y + $r1, $r1, $r1, 135 - $adjust, 180 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x, $y + $r1, $x, $y + $length - $r2, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x + $r2, $y + $length - $r2, $r2, $r2, 180 - $adjust, 225 + $adjust, $color, $width, $pattern);\n                }\n                break;\n\n            case \"right\":\n                $y += $half_width;\n                $x -= $half_width;\n\n                if ($r1 > 0) {\n                    $this->_canvas->arc($x - $r1, $y + $r1, $r1, $r1, 0 - $adjust, 45 + $adjust, $color, $width, $pattern);\n                }\n\n                $this->_canvas->line($x, $y + $r1, $x, $y + $length - $r2, $color, $width, $pattern);\n\n                if ($r2 > 0) {\n                    $this->_canvas->arc($x - $r2, $y + $length - $r2, $r2, $r2, 315 - $adjust, 360 + $adjust, $color, $width, $pattern);\n                }\n                break;\n        }\n    }\n\n    /**\n     * @param float $opacity\n     */\n    protected function _set_opacity(float $opacity): void\n    {\n        if ($opacity >= 0.0 && $opacity <= 1.0) {\n            $this->_canvas->set_opacity($opacity);\n        }\n    }\n\n    /**\n     * @param array $box\n     * @param string $color\n     * @param array $style\n     */\n    protected function _debug_layout($box, $color = \"red\", $style = [])\n    {\n        $this->_canvas->rectangle($box[0], $box[1], $box[2], $box[3], Color::parse($color), 0.1, $style);\n    }\n\n    /**\n     * @param float $img_width\n     * @param float $img_height\n     * @param float $container_width\n     * @param float $container_height\n     * @param array|string $bg_resize\n     * @param int $dpi\n     * @return array\n     */\n    protected function _resize_background_image(\n        $img_width,\n        $img_height,\n        $container_width,\n        $container_height,\n        $bg_resize,\n        $dpi\n    ) {\n        // We got two some specific numbers and/or auto definitions\n        if (is_array($bg_resize)) {\n            $is_auto_width = $bg_resize[0] === 'auto';\n            if ($is_auto_width) {\n                $new_img_width = $img_width;\n            } else {\n                $new_img_width = $bg_resize[0];\n                if (Helpers::is_percent($new_img_width)) {\n                    $new_img_width = round(($container_width / 100) * (float)$new_img_width);\n                } else {\n                    $new_img_width = round($new_img_width * $dpi / 72);\n                }\n            }\n\n            $is_auto_height = $bg_resize[1] === 'auto';\n            if ($is_auto_height) {\n                $new_img_height = $img_height;\n            } else {\n                $new_img_height = $bg_resize[1];\n                if (Helpers::is_percent($new_img_height)) {\n                    $new_img_height = round(($container_height / 100) * (float)$new_img_height);\n                } else {\n                    $new_img_height = round($new_img_height * $dpi / 72);\n                }\n            }\n\n            // if one of both was set to auto the other one needs to scale proportionally\n            if ($is_auto_width !== $is_auto_height) {\n                if ($is_auto_height) {\n                    $new_img_height = round($new_img_width * ($img_height / $img_width));\n                } else {\n                    $new_img_width = round($new_img_height * ($img_width / $img_height));\n                }\n            }\n        } else {\n            $container_ratio = $container_height / $container_width;\n\n            if ($bg_resize === 'cover' || $bg_resize === 'contain') {\n                $img_ratio = $img_height / $img_width;\n\n                if (\n                    ($bg_resize === 'cover' && $container_ratio > $img_ratio) ||\n                    ($bg_resize === 'contain' && $container_ratio < $img_ratio)\n                ) {\n                    $new_img_height = $container_height;\n                    $new_img_width = round($container_height / $img_ratio);\n                } else {\n                    $new_img_width = $container_width;\n                    $new_img_height = round($container_width * $img_ratio);\n                }\n            } else {\n                $new_img_width = $img_width;\n                $new_img_height = $img_height;\n            }\n        }\n\n        return [$new_img_width, $new_img_height];\n    }\n}\n", "<?php\nnamespace Dompdf\\Tests\\Css;\n\nuse Dompdf\\Dompdf;\nuse Dompdf\\Css\\Style;\nuse Dompdf\\Css\\Stylesheet;\nuse Dompdf\\Options;\nuse Dompdf\\Tests\\TestCase;\n\nclass StyleTest extends TestCase\n{\n    public function lengthInPtProvider(): array\n    {\n        return [\n            [\"auto\", null, \"auto\"],\n            [\"none\", null, \"none\"],\n            [\"100px\", null, 75.0],\n            [\"100PX\", null, 75.0], // Also check caps\n            [\"100pt\", null, 100.0],\n            [\"1.5e2pt\", null, 150.0], // Exponential notation\n            [\"1.5e+2pt\", null, 150.0],\n            [\"15E-2pT\", null, 0.15],\n            [\"1.5em\", 20, 18.0], // Default font size is 12pt\n            [\"100%\", null, 12.0],\n            [\"50%\", 360, 180.0]\n        ];\n    }\n\n    /**\n     * @dataProvider lengthInPtProvider\n     */\n    public function testLengthInPt(string $length, ?float $ref_size, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $s = new Style($sheet);\n\n        $result = $s->length_in_pt($length, $ref_size);\n        $this->assertSame($expected, $result);\n    }\n\n    public function cssImageBasicProvider(): array\n    {\n        return [\n            \"no value\" => [\"\", \"none\"],\n            \"keyword none\" => [\"none\", \"none\"],\n            \"bare url\" => [\"http://example.com/test.png\", \"none\"],\n            \"http\" => [\"url(http://example.com/test.png)\", \"http://example.com/test.png\"]\n        ];\n    }\n\n    public function cssImageNoBaseHrefProvider(): array\n    {\n        $basePath = realpath(__DIR__ . \"/..\");\n        return [\n            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n            \"local relative\" => [\"url(../_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n        ];\n    }\n\n    public function cssImageWithBaseHrefProvider(): array\n    {\n        $basePath = realpath(__DIR__ . \"/..\");\n        return [\n            \"local absolute\" => [\"url($basePath/_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"],\n            \"local relative\" => [\"url(../_files/jamaica.jpg)\", \"file://\" . $basePath . DIRECTORY_SEPARATOR . \"_files\" . DIRECTORY_SEPARATOR . \"jamaica.jpg\"]\n        ];\n    }\n\n    public function cssImageWithStylesheetBaseHrefProvider(): array\n    {\n        return [\n            \"local absolute\" => [\"url(/_files/jamaica.jpg)\", \"https://example.com/_files/jamaica.jpg\"],\n            \"local relative\" => [\"url(../_files/jamaica.jpg)\", \"https://example.com/../_files/jamaica.jpg\"]\n        ];\n    }\n\n    /**\n     * @dataProvider cssImageBasicProvider\n     * @dataProvider cssImageNoBaseHrefProvider\n     * @group regression\n     */\n    public function testCssImageNoBaseHref(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $sheet->set_base_path(__DIR__); // Treat stylesheet as being located in this directory\n        $s = new Style($sheet);\n\n        $s->set_prop(\"background_image\", $value);\n        $this->assertSame($expected, $s->background_image);\n    }\n\n    /**\n     * @dataProvider cssImageBasicProvider\n     * @dataProvider cssImageWithBaseHrefProvider\n     * @group regression\n     */\n    public function testCssImageWithBaseHref(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $dompdf->setProtocol(\"https://\");\n        $dompdf->setBaseHost(\"example.com\");\n        $dompdf->setBasePath(\"/\");\n        $sheet = new Stylesheet($dompdf);\n        $sheet->set_base_path(__DIR__); // Treat stylesheet as being located in this directory\n        $s = new Style($sheet);\n\n        $s->set_prop(\"background_image\", $value);\n        $this->assertSame($expected, $s->background_image);\n    }\n\n    /**\n     * @dataProvider cssImageBasicProvider\n     * @dataProvider cssImageWithStylesheetBaseHrefProvider\n     * @group regression\n     */\n    public function testCssImageWithStylesheetBaseHref(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $sheet->set_protocol(\"https://\");\n        $sheet->set_host(\"example.com\");\n        $sheet->set_base_path(\"/\");\n        $s = new Style($sheet);\n\n        $s->set_prop(\"background_image\", $value);\n        $this->assertSame($expected, $s->background_image);\n    }\n\n    public function contentProvider(): array\n    {\n        return [\n            [\"normal\", \"normal\"],\n            [\"none\", \"none\"],\n            [\n                \"'\u2013' attr(title) '\u2013'\",\n                [\"'\u2013'\", \"attr(title)\", \"'\u2013'\"]\n            ],\n            [\n                'counter(page)\" / {PAGES}\"',\n                [\"counter(page)\", '\" / {PAGES}\"']\n            ],\n            [\n                \"counter(li1, decimal)\\\".\\\"counter(li2, upper-roman)  ')'url('image.png')\",\n                [\"counter(li1, decimal)\", '\".\"', \"counter(li2, upper-roman)\", \"')'\", \"url('image.png')\"]\n            ],\n            [\n                '\"url(\\' \\')\"open-quote url(\" \")close-quote',\n                ['\"url(\\' \\')\"', \"open-quote\", 'url(\" \")', \"close-quote\"]\n            ]\n        ];\n    }\n\n    /**\n     * @dataProvider contentProvider\n     */\n    public function testContent(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"content\", $value);\n        $this->assertSame($expected, $style->content);\n    }\n\n    public function sizeProvider(): array\n    {\n        return [\n            // Valid values\n            [\"auto\", \"auto\"],\n            [\"letter\", [612.00, 792.00]],\n            [\"portrait\", [419.53, 595.28]],\n            [\"landscape\", [595.28, 419.53]],\n            [\"A4 portrait\", [595.28, 841.89]],\n            [\"landscape a4\", [841.89, 595.28]],\n            [\"200pt\", [200.0, 200.0]],\n            [\"400pt 300pt\", [400.0, 300.0]],\n            [\"400pt 300pt portrait\", [300.0, 400.0]],\n            [\"landscape 300pt 400pt\", [400.0, 300.0]],\n            [\"landscape 400pt 300pt\", [400.0, 300.0]],\n\n            // Invalid values\n            [\"\", \"auto\"],\n            [\"letter auto\", \"auto\"],\n            [\"landscape landscape a4\", \"auto\"],\n            [\"letter 300mm 300mm\", \"auto\"]\n        ];\n    }\n\n    /**\n     * @dataProvider sizeProvider\n     */\n    public function testSize(string $value, $expected): void\n    {\n        $options = new Options();\n        $options->setDefaultPaperSize(\"A5\");\n        $dompdf = new Dompdf($options);\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"size\", $value);\n        $this->assertSame($expected, $style->size);\n    }\n\n    public function opacityProvider(): array\n    {\n        return [\n            // Valid values\n            [\"0\", 0.0],\n            [\"1\", 1.0],\n            [\"+1.0\", 1.0],\n            [\"0.5\", 0.5],\n            [\".5\", 0.5],\n            [\"100%\", 1.0],\n            [\"23.78%\", 0.2378],\n            [\"2e-2%\", 0.0002],\n\n            // Out-of-range values (clamped instead of invalid)\n            [\"500.95\", 1.0],\n            [\"300%\", 1.0],\n            [\"-100\", 0.0],\n            [\"-23.3%\", 0.0],\n\n            // Invalid values\n            [\"\", 1.0],\n            [\"auto\", 1.0],\n            [\"invalid\", 1.0],\n            [\"0.5pt\", 1.0]\n        ];\n    }\n\n    /**\n     * @dataProvider opacityProvider\n     */\n    public function testOpacity(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"opacity\", $value);\n        $this->assertSame($expected, $style->opacity);\n    }\n\n    public function zIndexProvider(): array\n    {\n        return [\n            // Valid values\n            [\"auto\", \"auto\"],\n            [\"0\", 0],\n            [\"1\", 1],\n            [\"+23\", 23],\n            [\"-100\", -100],\n\n            // Invalid values\n            [\"\", \"auto\"],\n            [\"5.5\", \"auto\"],\n            [\"invalid\", \"auto\"]\n        ];\n    }\n\n    /**\n     * @dataProvider zIndexProvider\n     */\n    public function testZIndex(string $value, $expected): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"z_index\", $value);\n        $this->assertSame($expected, $style->z_index);\n    }\n\n    public function valueCaseProvider(): array\n    {\n        return [\n            [\"width\", \"Auto\",           \"width\", \"auto\"],\n            [\"list-style-type\", \"A\",    \"list_style_type\", \"A\"],\n        ];\n    }\n\n    /**\n     * @dataProvider valueCaseProvider\n     */\n    public function testValueCase(string $cssProp, string $inputValue, string $phpProp, string $expectValue): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop($cssProp, $inputValue);\n        $this->assertSame($expectValue, $style->$phpProp);\n    }\n\n    public function testWordBreakBreakWord(): void\n    {\n        $dompdf = new Dompdf();\n        $sheet = new Stylesheet($dompdf);\n        $style = new Style($sheet);\n\n        $style->set_prop(\"overflow_wrap\", \"break-word\");\n        $style->set_prop(\"word_break\", \"break-word\");\n        \n        $this->assertSame(\"normal\", $style->word_break);\n        $this->assertSame(\"anywhere\", $style->overflow_wrap);\n    }\n}\n", "<?php\nnamespace Dompdf\\Tests;\n\nuse Dompdf\\Helpers;\nuse Dompdf\\Tests\\TestCase;\n\nclass HelpersTest extends TestCase\n{\n    public function testParseDataUriBase64Image(): void\n    {\n        $imageParts = [\n            'mime' => 'data:image/png;base64,',\n            'data' => 'iVBORw0KGgoAAAANSUhEUgAAAAUA\nAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n9TXL0Y4OHwAAAABJRU5ErkJggg=='\n        ];\n        $result = Helpers::parse_data_uri(implode('', $imageParts));\n        $this->assertEquals(\n            $result['data'],\n            base64_decode($imageParts['data'])\n        );\n    }\n\n    public function dec2RomanProvider(): array\n    {\n        return [\n            [-5, \"-5\"],\n            [0, \"0\"],\n            [1, \"i\"],\n            [5, \"v\"],\n            [3999, \"mmmcmxcix\"],\n            [4000, \"4000\"],\n            [50000, \"50000\"],\n        ];\n    }\n\n    /**\n     * @dataProvider dec2RomanProvider\n     */\n    public function testDec2Roman($number, string $expected): void\n    {\n        $roman = Helpers::dec2roman($number);\n        $this->assertSame($expected, $roman);\n    }\n\n    public function lengthEqualProvider(): array\n    {\n        // Adapted from\n        // https://floating-point-gui.de/errors/NearlyEqualsTest.java\n        return [\n            [0.0, 0.3 - 0.2 - 0.1, true],\n            [0.3, 0.1 + 0.1 + 0.1, true],\n\n            // Large numbers\n            [100000000.0, 100000001.0, true],\n            [100000.0001, 100000.0002, true],\n            [100000.01, 100000.02, false],\n            [1000.0001, 1000.0002, false],\n\n            // Numbers around 1\n            [1.000000001, 1.000000002, true],\n            [1.0000001, 1.0000002, false],\n\n            // Numbers between 1 and 0\n            [0.00000010000001, 0.00000010000002, true],\n            [0.00000000001001, 0.00000000001002, true],\n            [0.000000100001, 0.000000100002, false],\n\n            // Close to zero\n            [0.0, 0.0, true],\n            [0.0, -0.0, true],\n            [1e-38, 1e-37, true],\n            [1e-38, -1e-37, true],\n            [1e-38, 0.0, true],\n            [1e-13, 1e-38, true],\n            [1e-13, 0.0, true],\n            [1e-13, -1e-13, true],\n            [1e-12, -1e-12, false],\n            [1e-12, 0.0, false],\n\n            // Very large numbers\n            [1e38, 1e38, true],\n            [1e38, 1.000001e38, false],\n\n            // Infinity and NaN\n            [INF, INF, true],\n            [INF, -INF, false],\n            [INF, 1e38, false],\n            [NAN, NAN, false],\n            [NAN, 0.0, false],\n        ];\n    }\n\n    /**\n     * @dataProvider lengthEqualProvider\n     */\n    public function testLengthEqual(float $a, float $b, bool $expected): void\n    {\n        $this->assertSame($expected, Helpers::lengthEqual($a, $b));\n        $this->assertSame($expected, Helpers::lengthEqual($b, $a));\n        $this->assertSame($expected, Helpers::lengthEqual(-$a, -$b));\n        $this->assertSame($expected, Helpers::lengthEqual(-$b, -$a));\n    }\n\n    \n    public function testCustomProtocolParsing(): void\n    {\n        $uri = \"mock://path/to/resource\";\n        $this->assertSame($uri, Helpers::build_url(\"\", \"\", \"\", $uri));\n    }\n}\n", "<?php\nnamespace Dompdf\\Tests;\n\nuse Dompdf\\Options;\nuse Dompdf\\Tests\\TestCase;\n\nclass OptionsTest extends TestCase\n{\n    public function testConstructor()\n    {\n        $root = realpath(dirname(__DIR__));\n        $option = new Options();\n        $this->assertEquals(sys_get_temp_dir(), $option->getTempDir());\n        $this->assertEquals($root . '/lib/fonts', $option->getFontDir());\n        $this->assertEquals($root . '/lib/fonts', $option->getFontCache());\n        $this->assertEquals([$root], $option->getChroot());\n        $this->assertEmpty($option->getLogOutputFile());\n        $this->assertEquals('screen', $option->getDefaultMediaType());\n        $this->assertEquals('letter', $option->getDefaultPaperSize());\n        $this->assertEquals('serif', $option->getDefaultFont());\n        $this->assertEquals(96, $option->getDpi());\n        $this->assertEquals(1.1, $option->getFontHeightRatio());\n        $this->assertFalse($option->getIsPhpEnabled());\n        $this->assertFalse($option->getIsRemoteEnabled());\n        $this->assertTrue($option->getIsJavascriptEnabled());\n        $this->assertTrue($option->getIsHtml5ParserEnabled());\n        $this->assertTrue($option->getIsFontSubsettingEnabled());\n        $this->assertFalse($option->getDebugPng());\n        $this->assertFalse($option->getDebugKeepTemp());\n        $this->assertFalse($option->getDebugCss());\n        $this->assertFalse($option->getDebugLayout());\n        $this->assertTrue($option->getDebugLayoutLines());\n        $this->assertTrue($option->getDebugLayoutBlocks());\n        $this->assertTrue($option->getDebugLayoutInline());\n        $this->assertTrue($option->getDebugLayoutPaddingBox());\n\n        $option = new Options(['tempDir' => 'test1']);\n        $this->assertEquals('test1', $option->getTempDir());\n    }\n\n    public function testSetters()\n    {\n        $option = new Options();\n        $option->set([\n            'tempDir' => 'test1',\n            'fontDir' => 'test2',\n            'fontCache' => 'test3',\n            'chroot' => 'test4,test4a',\n            'logOutputFile' => 'test5',\n            'defaultMediaType' => 'test6',\n            'defaultPaperSize' => 'test7',\n            'defaultFont' => 'test8',\n            'dpi' => 300,\n            'fontHeightRatio' => 1.2,\n            'isPhpEnabled' => true,\n            'isRemoteEnabled' => true,\n            'isJavascriptEnabled' => false,\n            'isHtml5ParserEnabled' => true,\n            'isFontSubsettingEnabled' => false,\n            'debugPng' => true,\n            'debugKeepTemp' => true,\n            'debugCss' => true,\n            'debugLayout' => true,\n            'debugLayoutLines' => false,\n            'debugLayoutBlocks' => false,\n            'debugLayoutInline' => false,\n            'debugLayoutPaddingBox' => false,\n            'httpContext' => ['ssl' => ['verify_peer' => false]],\n        ]);\n        $this->assertEquals('test1', $option->getTempDir());\n        $this->assertEquals('test2', $option->getFontDir());\n        $this->assertEquals('test3', $option->getFontCache());\n        $this->assertEquals(['test4','test4a'], $option->getChroot());\n        $this->assertEquals('test5', $option->getLogOutputFile());\n        $this->assertEquals('test6', $option->getDefaultMediaType());\n        $this->assertEquals('test7', $option->getDefaultPaperSize());\n        $this->assertEquals('test8', $option->getDefaultFont());\n        $this->assertEquals(300, $option->getDpi());\n        $this->assertEquals(1.2, $option->getFontHeightRatio());\n        $this->assertTrue($option->getIsPhpEnabled());\n        $this->assertTrue($option->getIsRemoteEnabled());\n        $this->assertFalse($option->getIsJavascriptEnabled());\n        $this->assertTrue($option->getIsHtml5ParserEnabled());\n        $this->assertFalse($option->getIsFontSubsettingEnabled());\n        $this->assertTrue($option->getDebugPng());\n        $this->assertTrue($option->getDebugKeepTemp());\n        $this->assertTrue($option->getDebugCss());\n        $this->assertTrue($option->getDebugLayout());\n        $this->assertFalse($option->getDebugLayoutLines());\n        $this->assertFalse($option->getDebugLayoutBlocks());\n        $this->assertFalse($option->getDebugLayoutInline());\n        $this->assertFalse($option->getDebugLayoutPaddingBox());\n        $this->assertIsResource($option->getHttpContext());\n\n        $option->setChroot(['test11']);\n        $this->assertEquals(['test11'], $option->getChroot());\n    }\n\n    public function testAllowedProtocols()\n    {\n        $options = new Options([\"isRemoteEnabled\" => false]);\n        $options->setAllowedProtocols([\"http://\"]);\n        $allowedProtocols = $options->getAllowedProtocols();\n        $this->assertIsArray($allowedProtocols);\n        $this->assertEquals(1, count($allowedProtocols));\n        $this->assertArrayHasKey(\"http://\", $allowedProtocols);\n        $this->assertIsArray($allowedProtocols[\"http://\"]);\n        $this->assertArrayHasKey(\"rules\", $allowedProtocols[\"http://\"]);\n        $this->assertIsArray($allowedProtocols[\"http://\"][\"rules\"]);\n        $this->assertEquals(1, count($allowedProtocols[\"http://\"][\"rules\"]));\n        $this->assertEquals([$options, \"validateRemoteUri\"], $allowedProtocols[\"http://\"][\"rules\"][0]);\n\n        [$validation_result] = $allowedProtocols[\"http://\"][\"rules\"][0](\"http://example.com/\");\n        $this->assertFalse($validation_result);\n\n        \n        $mock_protocol = [\n            \"mock://\" => [\n                \"rules\" => [\n                    function ($uri) { return [true, null]; }\n                ]\n            ]\n        ];\n        $options->setAllowedProtocols($mock_protocol);\n        $allowedProtocols = $options->getAllowedProtocols();\n        $this->assertIsArray($allowedProtocols);\n        $this->assertEquals(1, count($allowedProtocols));\n        $this->assertArrayHasKey(\"mock://\", $allowedProtocols);\n        $this->assertIsArray($allowedProtocols[\"mock://\"]);\n        $this->assertArrayHasKey(\"rules\", $allowedProtocols[\"mock://\"]);\n        $this->assertIsArray($allowedProtocols[\"mock://\"][\"rules\"]);\n        $this->assertEquals(1, count($allowedProtocols[\"mock://\"][\"rules\"]));\n        $this->assertEquals($mock_protocol[\"mock://\"][\"rules\"][0], $allowedProtocols[\"mock://\"][\"rules\"][0]);\n\n        [$validation_result] = $allowedProtocols[\"mock://\"][\"rules\"][0](\"mock://example.com/\");\n        $this->assertTrue($validation_result);\n    }\n}\n"], "filenames": ["src/Css/Stylesheet.php", "src/Dompdf.php", "src/FontMetrics.php", "src/FrameDecorator/Image.php", "src/Helpers.php", "src/Image/Cache.php", "src/Options.php", "src/Renderer/AbstractRenderer.php", "tests/Css/StyleTest.php", "tests/HelpersTest.php", "tests/OptionsTest.php"], "buggy_code_start_loc": [327, 200, 217, 60, 59, 12, 63, 100, 56, 103, 97], "buggy_code_end_loc": [1679, 608, 248, 61, 903, 233, 1013, 101, 67, 103, 97], "fixing_code_start_loc": [328, 199, 217, 60, 60, 12, 64, 100, 56, 104, 98], "fixing_code_end_loc": [1656, 585, 229, 61, 920, 189, 1150, 101, 67, 111, 138], "type": "CWE-73", "message": "External Control of File Name or Path in GitHub repository dompdf/dompdf prior to 2.0.0.", "other": {"cve": {"id": "CVE-2022-2400", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-18T15:15:08.153", "lastModified": "2022-07-23T02:21:55.900", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "External Control of File Name or Path in GitHub repository dompdf/dompdf prior to 2.0.0."}, {"lang": "es", "value": "Un Control Externo del Nombre o la Ruta del Archivo en el repositorio de GitHub dompdf/dompdf versiones anteriores a 2.0.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-73"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dompdf_project:dompdf:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "CF3441FB-3B15-4935-8A8F-964D7DDFBCAD"}]}]}], "references": [{"url": "https://github.com/dompdf/dompdf/commit/99aeec1efec9213e87098d42eb09439e7ee0bb6a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a6da5e5e-86be-499a-a3c3-2950f749202a", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dompdf/dompdf/commit/99aeec1efec9213e87098d42eb09439e7ee0bb6a"}}