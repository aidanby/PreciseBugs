{"buggy_code": ["/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/record/EncryptedRecordLayer.h>\n#include <fizz/crypto/aead/IOBufUtil.h>\n\nnamespace fizz {\n\nusing ContentTypeType = typename std::underlying_type<ContentType>::type;\nusing ProtocolVersionType =\n    typename std::underlying_type<ProtocolVersion>::type;\n\nstatic constexpr uint16_t kMaxEncryptedRecordSize = 0x4000 + 256; // 16k + 256\nstatic constexpr size_t kEncryptedHeaderSize =\n    sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n\nEncryptedReadRecordLayer::EncryptedReadRecordLayer(\n    EncryptionLevel encryptionLevel)\n    : encryptionLevel_(encryptionLevel) {}\n\nfolly::Optional<Buf> EncryptedReadRecordLayer::getDecryptedBuf(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    // Cache the front buffer, calling front may invoke and update\n    // of the tail cache.\n    auto frontBuf = buf.front();\n    folly::io::Cursor cursor(frontBuf);\n\n    if (buf.empty() || !cursor.canAdvance(kEncryptedHeaderSize)) {\n      return folly::none;\n    }\n\n    std::array<uint8_t, kEncryptedHeaderSize> ad;\n    folly::io::Cursor adCursor(cursor);\n    adCursor.pull(ad.data(), ad.size());\n    folly::IOBuf adBuf{folly::IOBuf::wrapBufferAsValue(folly::range(ad))};\n\n    auto contentType =\n        static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    cursor.skip(sizeof(ProtocolVersion));\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length == 0) {\n      throw std::runtime_error(\"received 0 length encrypted record\");\n    }\n    if (length > kMaxEncryptedRecordSize) {\n      throw std::runtime_error(\"received too long encrypted record\");\n    }\n    auto consumedBytes = cursor - frontBuf;\n    if (buf.chainLength() < consumedBytes + length) {\n      return folly::none;\n    }\n\n    if (contentType == ContentType::alert && length == 2) {\n      auto alert = decode<Alert>(cursor);\n      throw std::runtime_error(folly::to<std::string>(\n          \"received plaintext alert in encrypted record: \",\n          toString(alert.description)));\n    }\n\n    // If we already know that the length of the buffer is the\n    // same as the number of bytes we need, move the entire buffer.\n    std::unique_ptr<folly::IOBuf> encrypted;\n    if (buf.chainLength() == consumedBytes + length) {\n      encrypted = buf.move();\n    } else {\n      encrypted = buf.split(consumedBytes + length);\n    }\n    trimStart(*encrypted, consumedBytes);\n\n    if (contentType == ContentType::change_cipher_spec) {\n      encrypted->coalesce();\n      if (encrypted->length() == 1 && *encrypted->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    TLSMessage msg;\n    if (seqNum_ == std::numeric_limits<uint64_t>::max()) {\n      throw std::runtime_error(\"max read seq num\");\n    }\n    if (skipFailedDecryption_) {\n      auto decryptAttempt = aead_->tryDecrypt(\n          std::move(encrypted), useAdditionalData_ ? &adBuf : nullptr, seqNum_);\n      if (decryptAttempt) {\n        seqNum_++;\n        skipFailedDecryption_ = false;\n        return decryptAttempt;\n      } else {\n        continue;\n      }\n    } else {\n      return aead_->decrypt(\n          std::move(encrypted),\n          useAdditionalData_ ? &adBuf : nullptr,\n          seqNum_++);\n    }\n  }\n}\n\nfolly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}\n\nEncryptionLevel EncryptedReadRecordLayer::getEncryptionLevel() const {\n  return encryptionLevel_;\n}\n\nEncryptedWriteRecordLayer::EncryptedWriteRecordLayer(\n    EncryptionLevel encryptionLevel)\n    : encryptionLevel_(encryptionLevel) {}\n\nTLSContent EncryptedWriteRecordLayer::write(TLSMessage&& msg) const {\n  folly::IOBufQueue queue;\n  queue.append(std::move(msg.fragment));\n  std::unique_ptr<folly::IOBuf> outBuf;\n  std::array<uint8_t, kEncryptedHeaderSize> headerBuf;\n  auto header = folly::IOBuf::wrapBufferAsValue(folly::range(headerBuf));\n  aead_->setEncryptedBufferHeadroom(kEncryptedHeaderSize);\n  while (!queue.empty()) {\n    auto dataBuf = getBufToEncrypt(queue);\n    // Currently we never send padding.\n\n    // check if we have enough room to add the encrypted footer.\n    if (!dataBuf->isShared() &&\n        dataBuf->prev()->tailroom() >= sizeof(ContentType)) {\n      // extend it and add it\n      folly::io::Appender appender(dataBuf.get(), 0);\n      appender.writeBE(static_cast<ContentTypeType>(msg.type));\n    } else {\n      // not enough or shared - let's add enough for the tag as well\n      auto encryptedFooter = folly::IOBuf::create(\n          sizeof(ContentType) + aead_->getCipherOverhead());\n      folly::io::Appender appender(encryptedFooter.get(), 0);\n      appender.writeBE(static_cast<ContentTypeType>(msg.type));\n      dataBuf->prependChain(std::move(encryptedFooter));\n    }\n\n    if (seqNum_ == std::numeric_limits<uint64_t>::max()) {\n      throw std::runtime_error(\"max write seq num\");\n    }\n\n    // we will either be able to memcpy directly into the ciphertext or\n    // need to create a new buf to insert before the ciphertext but we need\n    // it for additional data\n    header.clear();\n    folly::io::Appender appender(&header, 0);\n    appender.writeBE(\n        static_cast<ContentTypeType>(ContentType::application_data));\n    appender.writeBE(\n        static_cast<ProtocolVersionType>(ProtocolVersion::tls_1_2));\n    auto ciphertextLength =\n        dataBuf->computeChainDataLength() + aead_->getCipherOverhead();\n    appender.writeBE<uint16_t>(ciphertextLength);\n\n    auto cipherText = aead_->encrypt(\n        std::move(dataBuf), useAdditionalData_ ? &header : nullptr, seqNum_++);\n\n    std::unique_ptr<folly::IOBuf> record;\n    if (!cipherText->isShared() &&\n        cipherText->headroom() >= kEncryptedHeaderSize) {\n      // prepend and then write it in\n      cipherText->prepend(kEncryptedHeaderSize);\n      memcpy(cipherText->writableData(), header.data(), header.length());\n      record = std::move(cipherText);\n    } else {\n      record = folly::IOBuf::copyBuffer(header.data(), header.length());\n      record->prependChain(std::move(cipherText));\n    }\n\n    if (!outBuf) {\n      outBuf = std::move(record);\n    } else {\n      outBuf->prependChain(std::move(record));\n    }\n  }\n\n  if (!outBuf) {\n    outBuf = folly::IOBuf::create(0);\n  }\n\n  TLSContent content;\n  content.data = std::move(outBuf);\n  content.contentType = msg.type;\n  content.encryptionLevel = encryptionLevel_;\n  return content;\n}\n\nBuf EncryptedWriteRecordLayer::getBufToEncrypt(folly::IOBufQueue& queue) const {\n  if (queue.front()->length() > maxRecord_) {\n    return queue.splitAtMost(maxRecord_);\n  } else if (queue.front()->length() >= desiredMinRecord_) {\n    return queue.pop_front();\n  } else {\n    return queue.splitAtMost(desiredMinRecord_);\n  }\n}\n\nEncryptionLevel EncryptedWriteRecordLayer::getEncryptionLevel() const {\n  return encryptionLevel_;\n}\n} // namespace fizz\n", "/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/record/RecordLayer.h>\n\nnamespace fizz {\n\nusing HandshakeTypeType = typename std::underlying_type<HandshakeType>::type;\n\nstatic constexpr size_t kHandshakeHeaderSize =\n    sizeof(HandshakeType) + detail::bits24::size;\n\nfolly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n\n  while (true) {\n    // Read one record. We read one record at a time since records could cause\n    // a change in the record layer.\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          // If we read handshake data but didn't have enough to get a full\n          // message we immediately try to read another record.\n          // TODO: add limits on number of records we buffer\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}\n\ntemplate <typename T>\nstatic Param parse(Buf handshakeMsg, Buf original) {\n  auto msg = decode<T>(std::move(handshakeMsg));\n  msg.originalEncoding = std::move(original);\n  return std::move(msg);\n}\n\ntemplate <>\nParam parse<ServerHello>(Buf handshakeMsg, Buf original) {\n  auto shlo = decode<ServerHello>(std::move(handshakeMsg));\n  if (shlo.random == HelloRetryRequest::HrrRandom) {\n    HelloRetryRequest hrr;\n    hrr.legacy_version = shlo.legacy_version;\n    hrr.legacy_session_id_echo = std::move(shlo.legacy_session_id_echo);\n    hrr.cipher_suite = shlo.cipher_suite;\n    hrr.legacy_compression_method = shlo.legacy_compression_method;\n    hrr.extensions = std::move(shlo.extensions);\n\n    hrr.originalEncoding = std::move(original);\n    return std::move(hrr);\n  } else {\n    shlo.originalEncoding = std::move(original);\n    return std::move(shlo);\n  }\n}\n\nfolly::Optional<Param> ReadRecordLayer::decodeHandshakeMessage(\n    folly::IOBufQueue& buf) {\n  folly::io::Cursor cursor(buf.front());\n\n  if (!cursor.canAdvance(kHandshakeHeaderSize)) {\n    return folly::none;\n  }\n\n  auto handshakeType =\n      static_cast<HandshakeType>(cursor.readBE<HandshakeTypeType>());\n  auto length = detail::readBits24(cursor);\n\n  if (length > kMaxHandshakeSize) {\n    throw std::runtime_error(\"handshake record too big\");\n  }\n  if (buf.chainLength() < (cursor - buf.front()) + length) {\n    return folly::none;\n  }\n\n  Buf handshakeMsg;\n  cursor.clone(handshakeMsg, length);\n  auto original = buf.split(kHandshakeHeaderSize + length);\n\n  switch (handshakeType) {\n    case HandshakeType::client_hello:\n      return parse<ClientHello>(std::move(handshakeMsg), std::move(original));\n    case HandshakeType::server_hello:\n      return parse<ServerHello>(std::move(handshakeMsg), std::move(original));\n    case HandshakeType::end_of_early_data:\n      return parse<EndOfEarlyData>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::new_session_ticket:\n      return parse<NewSessionTicket>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::encrypted_extensions:\n      return parse<EncryptedExtensions>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::certificate:\n      return parse<CertificateMsg>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::compressed_certificate:\n      return parse<CompressedCertificate>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::certificate_request:\n      return parse<CertificateRequest>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::certificate_verify:\n      return parse<CertificateVerify>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::finished:\n      return parse<Finished>(std::move(handshakeMsg), std::move(original));\n    case HandshakeType::key_update:\n      return parse<KeyUpdate>(std::move(handshakeMsg), std::move(original));\n    default:\n      throw std::runtime_error(\"unknown handshake type\");\n  };\n}\n\nbool ReadRecordLayer::hasUnparsedHandshakeData() const {\n  return !unparsedHandshakeData_.empty();\n}\n} // namespace fizz\n"], "fixing_code": ["/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/record/EncryptedRecordLayer.h>\n#include <fizz/crypto/aead/IOBufUtil.h>\n\nnamespace fizz {\n\nusing ContentTypeType = typename std::underlying_type<ContentType>::type;\nusing ProtocolVersionType =\n    typename std::underlying_type<ProtocolVersion>::type;\n\nstatic constexpr uint16_t kMaxEncryptedRecordSize = 0x4000 + 256; // 16k + 256\nstatic constexpr size_t kEncryptedHeaderSize =\n    sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n\nEncryptedReadRecordLayer::EncryptedReadRecordLayer(\n    EncryptionLevel encryptionLevel)\n    : encryptionLevel_(encryptionLevel) {}\n\nfolly::Optional<Buf> EncryptedReadRecordLayer::getDecryptedBuf(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    // Cache the front buffer, calling front may invoke and update\n    // of the tail cache.\n    auto frontBuf = buf.front();\n    folly::io::Cursor cursor(frontBuf);\n\n    if (buf.empty() || !cursor.canAdvance(kEncryptedHeaderSize)) {\n      return folly::none;\n    }\n\n    std::array<uint8_t, kEncryptedHeaderSize> ad;\n    folly::io::Cursor adCursor(cursor);\n    adCursor.pull(ad.data(), ad.size());\n    folly::IOBuf adBuf{folly::IOBuf::wrapBufferAsValue(folly::range(ad))};\n\n    auto contentType =\n        static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    cursor.skip(sizeof(ProtocolVersion));\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length == 0) {\n      throw std::runtime_error(\"received 0 length encrypted record\");\n    }\n    if (length > kMaxEncryptedRecordSize) {\n      throw std::runtime_error(\"received too long encrypted record\");\n    }\n    auto consumedBytes = cursor - frontBuf;\n    if (buf.chainLength() < consumedBytes + length) {\n      return folly::none;\n    }\n\n    if (contentType == ContentType::alert && length == 2) {\n      auto alert = decode<Alert>(cursor);\n      throw std::runtime_error(folly::to<std::string>(\n          \"received plaintext alert in encrypted record: \",\n          toString(alert.description)));\n    }\n\n    // If we already know that the length of the buffer is the\n    // same as the number of bytes we need, move the entire buffer.\n    std::unique_ptr<folly::IOBuf> encrypted;\n    if (buf.chainLength() == consumedBytes + length) {\n      encrypted = buf.move();\n    } else {\n      encrypted = buf.split(consumedBytes + length);\n    }\n    trimStart(*encrypted, consumedBytes);\n\n    if (contentType == ContentType::change_cipher_spec) {\n      encrypted->coalesce();\n      if (encrypted->length() == 1 && *encrypted->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    TLSMessage msg;\n    if (seqNum_ == std::numeric_limits<uint64_t>::max()) {\n      throw std::runtime_error(\"max read seq num\");\n    }\n    if (skipFailedDecryption_) {\n      auto decryptAttempt = aead_->tryDecrypt(\n          std::move(encrypted), useAdditionalData_ ? &adBuf : nullptr, seqNum_);\n      if (decryptAttempt) {\n        seqNum_++;\n        skipFailedDecryption_ = false;\n        return decryptAttempt;\n      } else {\n        continue;\n      }\n    } else {\n      return aead_->decrypt(\n          std::move(encrypted),\n          useAdditionalData_ ? &adBuf : nullptr,\n          seqNum_++);\n    }\n  }\n}\n\nfolly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg{};\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}\n\nEncryptionLevel EncryptedReadRecordLayer::getEncryptionLevel() const {\n  return encryptionLevel_;\n}\n\nEncryptedWriteRecordLayer::EncryptedWriteRecordLayer(\n    EncryptionLevel encryptionLevel)\n    : encryptionLevel_(encryptionLevel) {}\n\nTLSContent EncryptedWriteRecordLayer::write(TLSMessage&& msg) const {\n  folly::IOBufQueue queue;\n  queue.append(std::move(msg.fragment));\n  std::unique_ptr<folly::IOBuf> outBuf;\n  std::array<uint8_t, kEncryptedHeaderSize> headerBuf;\n  auto header = folly::IOBuf::wrapBufferAsValue(folly::range(headerBuf));\n  aead_->setEncryptedBufferHeadroom(kEncryptedHeaderSize);\n  while (!queue.empty()) {\n    auto dataBuf = getBufToEncrypt(queue);\n    // Currently we never send padding.\n\n    // check if we have enough room to add the encrypted footer.\n    if (!dataBuf->isShared() &&\n        dataBuf->prev()->tailroom() >= sizeof(ContentType)) {\n      // extend it and add it\n      folly::io::Appender appender(dataBuf.get(), 0);\n      appender.writeBE(static_cast<ContentTypeType>(msg.type));\n    } else {\n      // not enough or shared - let's add enough for the tag as well\n      auto encryptedFooter = folly::IOBuf::create(\n          sizeof(ContentType) + aead_->getCipherOverhead());\n      folly::io::Appender appender(encryptedFooter.get(), 0);\n      appender.writeBE(static_cast<ContentTypeType>(msg.type));\n      dataBuf->prependChain(std::move(encryptedFooter));\n    }\n\n    if (seqNum_ == std::numeric_limits<uint64_t>::max()) {\n      throw std::runtime_error(\"max write seq num\");\n    }\n\n    // we will either be able to memcpy directly into the ciphertext or\n    // need to create a new buf to insert before the ciphertext but we need\n    // it for additional data\n    header.clear();\n    folly::io::Appender appender(&header, 0);\n    appender.writeBE(\n        static_cast<ContentTypeType>(ContentType::application_data));\n    appender.writeBE(\n        static_cast<ProtocolVersionType>(ProtocolVersion::tls_1_2));\n    auto ciphertextLength =\n        dataBuf->computeChainDataLength() + aead_->getCipherOverhead();\n    appender.writeBE<uint16_t>(ciphertextLength);\n\n    auto cipherText = aead_->encrypt(\n        std::move(dataBuf), useAdditionalData_ ? &header : nullptr, seqNum_++);\n\n    std::unique_ptr<folly::IOBuf> record;\n    if (!cipherText->isShared() &&\n        cipherText->headroom() >= kEncryptedHeaderSize) {\n      // prepend and then write it in\n      cipherText->prepend(kEncryptedHeaderSize);\n      memcpy(cipherText->writableData(), header.data(), header.length());\n      record = std::move(cipherText);\n    } else {\n      record = folly::IOBuf::copyBuffer(header.data(), header.length());\n      record->prependChain(std::move(cipherText));\n    }\n\n    if (!outBuf) {\n      outBuf = std::move(record);\n    } else {\n      outBuf->prependChain(std::move(record));\n    }\n  }\n\n  if (!outBuf) {\n    outBuf = folly::IOBuf::create(0);\n  }\n\n  TLSContent content;\n  content.data = std::move(outBuf);\n  content.contentType = msg.type;\n  content.encryptionLevel = encryptionLevel_;\n  return content;\n}\n\nBuf EncryptedWriteRecordLayer::getBufToEncrypt(folly::IOBufQueue& queue) const {\n  if (queue.front()->length() > maxRecord_) {\n    return queue.splitAtMost(maxRecord_);\n  } else if (queue.front()->length() >= desiredMinRecord_) {\n    return queue.pop_front();\n  } else {\n    return queue.splitAtMost(desiredMinRecord_);\n  }\n}\n\nEncryptionLevel EncryptedWriteRecordLayer::getEncryptionLevel() const {\n  return encryptionLevel_;\n}\n} // namespace fizz\n", "/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/record/RecordLayer.h>\n\nnamespace fizz {\n\nusing HandshakeTypeType = typename std::underlying_type<HandshakeType>::type;\n\nstatic constexpr size_t kHandshakeHeaderSize =\n    sizeof(HandshakeType) + detail::bits24::size;\n\nfolly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n\n  while (true) {\n    // Read one record. We read one record at a time since records could cause\n    // a change in the record layer.\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        std::unique_ptr<folly::IOBuf> handshakeMessage =\n            unparsedHandshakeData_.move();\n        // It is possible that a peer might send us records in a manner such\n        // that there is a 16KB record and only 1 byte of handshake message in\n        // each record. Since we normally just trim the IOBuf, we would end up\n        // holding 16K of data. To prevent this we allocate a contiguous\n        // buffer to copy over these bytes. We supply kExtraAlloc bytes in\n        // order to avoid needing to re-allocate a lot of times if we receive\n        // a lot of small messages. There might be more optimal reallocation\n        // policies, but this should be fine.\n        message->fragment->coalesce();\n        constexpr size_t kExtraAlloc = 1024;\n        if (!handshakeMessage) {\n          handshakeMessage =\n              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);\n        } else if (handshakeMessage->tailroom() < message->fragment->length()) {\n          handshakeMessage->reserve(\n              0, message->fragment->length() + kExtraAlloc);\n        }\n        memcpy(\n            handshakeMessage->writableTail(),\n            message->fragment->data(),\n            message->fragment->length());\n        handshakeMessage->append(message->fragment->length());\n        unparsedHandshakeData_.append(std::move(handshakeMessage));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          // If we read handshake data but didn't have enough to get a full\n          // message we immediately try to read another record.\n          // TODO: add limits on number of records we buffer\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}\n\ntemplate <typename T>\nstatic Param parse(Buf handshakeMsg, Buf original) {\n  auto msg = decode<T>(std::move(handshakeMsg));\n  msg.originalEncoding = std::move(original);\n  return std::move(msg);\n}\n\ntemplate <>\nParam parse<ServerHello>(Buf handshakeMsg, Buf original) {\n  auto shlo = decode<ServerHello>(std::move(handshakeMsg));\n  if (shlo.random == HelloRetryRequest::HrrRandom) {\n    HelloRetryRequest hrr;\n    hrr.legacy_version = shlo.legacy_version;\n    hrr.legacy_session_id_echo = std::move(shlo.legacy_session_id_echo);\n    hrr.cipher_suite = shlo.cipher_suite;\n    hrr.legacy_compression_method = shlo.legacy_compression_method;\n    hrr.extensions = std::move(shlo.extensions);\n\n    hrr.originalEncoding = std::move(original);\n    return std::move(hrr);\n  } else {\n    shlo.originalEncoding = std::move(original);\n    return std::move(shlo);\n  }\n}\n\nfolly::Optional<Param> ReadRecordLayer::decodeHandshakeMessage(\n    folly::IOBufQueue& buf) {\n  folly::io::Cursor cursor(buf.front());\n\n  if (!cursor.canAdvance(kHandshakeHeaderSize)) {\n    return folly::none;\n  }\n\n  auto handshakeType =\n      static_cast<HandshakeType>(cursor.readBE<HandshakeTypeType>());\n  auto length = detail::readBits24(cursor);\n\n  if (length > kMaxHandshakeSize) {\n    throw std::runtime_error(\"handshake record too big\");\n  }\n  if (buf.chainLength() < (cursor - buf.front()) + length) {\n    return folly::none;\n  }\n\n  Buf handshakeMsg;\n  cursor.clone(handshakeMsg, length);\n  auto original = buf.split(kHandshakeHeaderSize + length);\n\n  switch (handshakeType) {\n    case HandshakeType::client_hello:\n      return parse<ClientHello>(std::move(handshakeMsg), std::move(original));\n    case HandshakeType::server_hello:\n      return parse<ServerHello>(std::move(handshakeMsg), std::move(original));\n    case HandshakeType::end_of_early_data:\n      return parse<EndOfEarlyData>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::new_session_ticket:\n      return parse<NewSessionTicket>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::encrypted_extensions:\n      return parse<EncryptedExtensions>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::certificate:\n      return parse<CertificateMsg>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::compressed_certificate:\n      return parse<CompressedCertificate>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::certificate_request:\n      return parse<CertificateRequest>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::certificate_verify:\n      return parse<CertificateVerify>(\n          std::move(handshakeMsg), std::move(original));\n    case HandshakeType::finished:\n      return parse<Finished>(std::move(handshakeMsg), std::move(original));\n    case HandshakeType::key_update:\n      return parse<KeyUpdate>(std::move(handshakeMsg), std::move(original));\n    default:\n      throw std::runtime_error(\"unknown handshake type\");\n  };\n}\n\nbool ReadRecordLayer::hasUnparsedHandshakeData() const {\n  return !unparsedHandshakeData_.empty();\n}\n} // namespace fizz\n"], "filenames": ["fizz/record/EncryptedRecordLayer.cpp", "fizz/record/RecordLayer.cpp"], "buggy_code_start_loc": [116, 52], "buggy_code_end_loc": [117, 53], "fixing_code_start_loc": [116, 52], "fixing_code_end_loc": [117, 77], "type": "CWE-770", "message": "A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.", "other": {"cve": {"id": "CVE-2019-11924", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-08-20T20:15:11.290", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00."}, {"lang": "es", "value": "Un peer podr\u00eda enviar fragmentos vac\u00edos de negociaci\u00f3n que contienen solo relleno (paddig) que se mantendr\u00edan en la memoria hasta que se recibiera una negociaci\u00f3n completa, resultando en el agotamiento de la memoria. Este problema afecta a las versiones v2019.01.28.00 y superiores de fizz, hasta la versi\u00f3n v2019.08.05.00."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:fizz:*:*:*:*:*:*:*:*", "versionStartIncluding": "2019.01.28.00", "versionEndIncluding": "2019.08.05.00", "matchCriteriaId": "B867692C-91C4-4E64-8B9C-1E5FAC5A5070"}]}]}], "references": [{"url": "https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/facebookincubator/fizz/commit/6bf67137ef1ee5cd70c842b014c322b7deaf994b", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11924", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f"}}