{"buggy_code": ["using System;\nusing System.Runtime.CompilerServices;\nusing BenchmarkDotNet.Attributes;\nusing Snappier.Internal;\n\nnamespace Snappier.Benchmarks\n{\n    public class FindMatchLength\n    {\n        private static readonly byte[] s_fourByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n            1, 2, 3, 4, 4, 6, 7, 8, 9, 10, 11, 13,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        private static readonly byte[] s_sevenByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n            1, 2, 3, 4, 5, 6, 7, 7, 9, 10, 11, 13,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        private static readonly byte[] s_elevenByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        private static readonly byte[] s_thirtyTwoByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        [Params(4, 7, 11, 32)]\n        public int MatchLength { get; set; }\n\n        private byte[] _array;\n\n        [GlobalSetup]\n        public void GlobalSetup()\n        {\n            _array = MatchLength switch\n            {\n                4 => s_fourByteMatch,\n                7 => s_sevenByteMatch,\n                11 => s_elevenByteMatch,\n                32 => s_thirtyTwoByteMatch,\n                _ => throw new InvalidOperationException()\n            };\n        }\n\n        [Benchmark(Baseline = true)]\n        public (long, bool) Regular()\n        {\n            ulong data = 0;\n\n            ref byte s1 = ref _array[0];\n            ref byte s2 = ref Unsafe.Add(ref s1, 12);\n            ref byte s2Limit = ref Unsafe.Add(ref s1, _array.Length - 1);\n\n            return SnappyCompressor.FindMatchLength(ref s1, ref s2, ref s2Limit, ref data);\n        }\n    }\n}\n", "using System;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing Snappier.Internal;\nusing Xunit;\n\nnamespace Snappier.Tests.Internal\n{\n    public class SnappyCompressorTests\n    {\n        #region FindMatchLength\n\n        [Theory]\n        [InlineData(6, \"012345\", \"012345\", 6)]\n        [InlineData(11, \"01234567abc\", \"01234567abc\", 11)]\n\n        // Hit s1_limit in 64-bit loop, find a non-match in single-character loop.\n        [InlineData(9, \"01234567abc\", \"01234567axc\", 9)]\n\n        // Same, but edge cases.\n        [InlineData(11, \"01234567abc!\", \"01234567abc!\", 11)]\n        [InlineData(11, \"01234567abc!\", \"01234567abc?\", 11)]\n\n        // Find non-match at once in first loop.\n        [InlineData(0, \"01234567xxxxxxxx\", \"?1234567xxxxxxxx\", 16)]\n        [InlineData(1, \"01234567xxxxxxxx\", \"0?234567xxxxxxxx\", 16)]\n        [InlineData(4, \"01234567xxxxxxxx\", \"01237654xxxxxxxx\", 16)]\n        [InlineData(7, \"01234567xxxxxxxx\", \"0123456?xxxxxxxx\", 16)]\n\n        // Find non-match in first loop after one block.\n        [InlineData(8, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh?1234567xxxxxxxx\", 24)]\n        [InlineData(9, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh0?234567xxxxxxxx\", 24)]\n        [InlineData(12, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh01237654xxxxxxxx\", 24)]\n        [InlineData(15, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh0123456?xxxxxxxx\", 24)]\n\n        // 32-bit version:\n\n        // Short matches.\n        [InlineData(0, \"01234567\", \"?1234567\", 8)]\n        [InlineData(1, \"01234567\", \"0?234567\", 8)]\n        [InlineData(2, \"01234567\", \"01?34567\", 8)]\n        [InlineData(3, \"01234567\", \"012?4567\", 8)]\n        [InlineData(4, \"01234567\", \"0123?567\", 8)]\n        [InlineData(5, \"01234567\", \"01234?67\", 8)]\n        [InlineData(6, \"01234567\", \"012345?7\", 8)]\n        [InlineData(7, \"01234567\", \"0123456?\", 8)]\n        [InlineData(7, \"01234567\", \"0123456?\", 7)]\n        [InlineData(7, \"01234567!\", \"0123456??\", 7)]\n\n        // Hit s1_limit in 32-bit loop, hit s1_limit in single-character loop.\n        [InlineData(10, \"xxxxxxabcd\", \"xxxxxxabcd\", 10)]\n        [InlineData(10, \"xxxxxxabcd?\", \"xxxxxxabcd?\", 10)]\n        [InlineData(13, \"xxxxxxabcdef\", \"xxxxxxabcdefx\", 13)]\n\n        // Same, but edge cases.\n        [InlineData(12, \"xxxxxx0123abc!\", \"xxxxxx0123abc!\", 12)]\n        [InlineData(12, \"xxxxxx0123abc!\", \"xxxxxx0123abc?\", 12)]\n\n        // Hit s1_limit in 32-bit loop, find a non-match in single-character loop.\n        [InlineData(11, \"xxxxxx0123abc\", \"xxxxxx0123axc\", 13)]\n\n        // Find non-match at once in first loop.\n        [InlineData(6, \"xxxxxx0123xxxxxxxx\", \"xxxxxx?123xxxxxxxx\", 18)]\n        [InlineData(7, \"xxxxxx0123xxxxxxxx\", \"xxxxxx0?23xxxxxxxx\", 18)]\n        [InlineData(8, \"xxxxxx0123xxxxxxxx\", \"xxxxxx0132xxxxxxxx\", 18)]\n        [InlineData(9, \"xxxxxx0123xxxxxxxx\", \"xxxxxx012?xxxxxxxx\", 18)]\n\n        // Same, but edge cases.\n        [InlineData(6, \"xxxxxx0123\", \"xxxxxx?123\", 10)]\n        [InlineData(7, \"xxxxxx0123\", \"xxxxxx0?23\", 10)]\n        [InlineData(8, \"xxxxxx0123\", \"xxxxxx0132\", 10)]\n        [InlineData(9, \"xxxxxx0123\", \"xxxxxx012?\", 10)]\n\n        // Find non-match in first loop after one block.\n        [InlineData(10, \"xxxxxxabcd0123xx\", \"xxxxxxabcd?123xx\", 16)]\n        [InlineData(11, \"xxxxxxabcd0123xx\", \"xxxxxxabcd0?23xx\", 16)]\n        [InlineData(12, \"xxxxxxabcd0123xx\", \"xxxxxxabcd0132xx\", 16)]\n        [InlineData(13, \"xxxxxxabcd0123xx\", \"xxxxxxabcd012?xx\", 16)]\n\n        // Same, but edge cases.\n        [InlineData(10, \"xxxxxxabcd0123\", \"xxxxxxabcd?123\", 14)]\n        [InlineData(11, \"xxxxxxabcd0123\", \"xxxxxxabcd0?23\", 14)]\n        [InlineData(12, \"xxxxxxabcd0123\", \"xxxxxxabcd0132\", 14)]\n        [InlineData(13, \"xxxxxxabcd0123\", \"xxxxxxabcd012?\", 14)]\n        public void FindMatchLength(int expectedResult, string s1String, string s2String, int length)\n        {\n            var array = Encoding.ASCII.GetBytes(s1String + s2String\n                                                         + new string('\\0', Math.Max(0, length - s2String.Length)));\n\n            ulong data = 0;\n            ref byte s1 = ref array[0];\n            ref byte s2 = ref Unsafe.Add(ref s1, s1String.Length);\n\n            var result =\n                SnappyCompressor.FindMatchLength(ref s1, ref s2, ref Unsafe.Add(ref s2, length - 1), ref data);\n\n            Assert.Equal(result.matchLength < 8, result.matchLengthLessThan8);\n            Assert.Equal(expectedResult, result.matchLength);\n        }\n\n        #endregion\n    }\n}\n", "using System;\nusing System.Buffers;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nnamespace Snappier.Internal\n{\n    internal class SnappyCompressor : IDisposable\n    {\n        private HashTable? _workingMemory = new();\n\n        public int Compress(ReadOnlySpan<byte> input, Span<byte> output)\n        {\n            if (_workingMemory == null)\n            {\n                ThrowHelper.ThrowObjectDisposedException(nameof(SnappyCompressor));\n            }\n\n            _workingMemory.EnsureCapacity(input.Length);\n\n            int bytesWritten = WriteUncompressedLength(output, input.Length);\n            output = output.Slice(bytesWritten);\n\n            while (input.Length > 0)\n            {\n                var fragment = input.Slice(0, Math.Min(input.Length, (int)Constants.BlockSize));\n\n                var hashTable = _workingMemory.GetHashTable(fragment.Length);\n\n                var maxOutput = Helpers.MaxCompressedLength(fragment.Length);\n\n                if (output.Length >= maxOutput)\n                {\n                    var written = CompressFragment(fragment, output, hashTable);\n\n                    output = output.Slice(written);\n                    bytesWritten += written;\n                }\n                else\n                {\n                    var scratch = ArrayPool<byte>.Shared.Rent(maxOutput);\n                    try\n                    {\n                        int written = CompressFragment(fragment, scratch.AsSpan(), hashTable);\n                        if (output.Length < written)\n                        {\n                            ThrowHelper.ThrowArgumentException(\"Insufficient output buffer\", nameof(output));\n                        }\n\n                        scratch.AsSpan(0, written).CopyTo(output);\n                        output = output.Slice(written);\n                        bytesWritten += written;\n                    }\n                    finally\n                    {\n                        ArrayPool<byte>.Shared.Return(scratch);\n                    }\n                }\n\n                input = input.Slice(fragment.Length);\n            }\n\n            return bytesWritten;\n        }\n\n        public void Dispose()\n        {\n            _workingMemory?.Dispose();\n            _workingMemory = null;\n        }\n\n        private static int WriteUncompressedLength(Span<byte> output, int length)\n        {\n            const int b = 0b1000_0000;\n\n            unchecked\n            {\n                if (length < (1 << 7))\n                {\n                    output[0] = (byte) length;\n                    return 1;\n                }\n                else if (length < (1 << 14))\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) (length >> 7);\n                    return 2;\n                }\n                else if (length < (1 << 21))\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) ((length >> 7) | b);\n                    output[2] = (byte) (length >> 14);\n                    return 3;\n                }\n                else if (length < (1 << 28))\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) ((length >> 7) | b);\n                    output[2] = (byte) ((length >> 14) | b);\n                    output[3] = (byte) (length >> 21);\n                    return 4;\n                }\n                else\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) ((length >> 7) | b);\n                    output[2] = (byte) ((length >> 14) | b);\n                    output[3] = (byte) ((length >> 21) | b);\n                    output[4] = (byte) (length >> 28);\n                    return 5;\n                }\n            }\n        }\n\n        #region CompressFragment\n\n        private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output, Span<ushort> tableSpan)\n        {\n            unchecked\n            {\n                Debug.Assert(input.Length <= Constants.BlockSize);\n                Debug.Assert((tableSpan.Length & (tableSpan.Length - 1)) == 0); // table must be power of two\n\n                uint mask = (uint)(2 * (tableSpan.Length - 1));\n\n                ref byte inputStart = ref Unsafe.AsRef(in input[0]);\n                // Last byte of the input, not one byte past the end, to avoid issues on GC moves\n                ref byte inputEnd = ref Unsafe.Add(ref inputStart, input.Length - 1);\n                ref byte ip = ref inputStart;\n\n                ref byte op = ref output[0];\n                ref ushort table = ref tableSpan[0];\n\n                if (input.Length >= Constants.InputMarginBytes)\n                {\n                    ref byte ipLimit = ref Unsafe.Subtract(ref inputEnd, Constants.InputMarginBytes - 1);\n\n                    for (uint preload = Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, 1));;)\n                    {\n                        // Bytes in [nextEmit, ip) will be emitted as literal bytes.  Or\n                        // [nextEmit, ipEnd) after the main loop.\n                        ref byte nextEmit = ref ip;\n                        ip = ref Unsafe.Add(ref ip, 1);\n                        ulong data = Helpers.UnsafeReadUInt64(ref ip);\n\n                        // The body of this loop calls EmitLiteral once and then EmitCopy one or\n                        // more times.  (The exception is that when we're close to exhausting\n                        // the input we goto emit_remainder.)\n                        //\n                        // In the first iteration of this loop we're just starting, so\n                        // there's nothing to copy, so calling EmitLiteral once is\n                        // necessary.  And we only start a new iteration when the\n                        // current iteration has determined that a call to EmitLiteral will\n                        // precede the next call to EmitCopy (if any).\n                        //\n                        // Step 1: Scan forward in the input looking for a 4-byte-long match.\n                        // If we get close to exhausting the input then goto emit_remainder.\n                        //\n                        // Heuristic match skipping: If 32 bytes are scanned with no matches\n                        // found, start looking only at every other byte. If 32 more bytes are\n                        // scanned (or skipped), look at every third byte, etc.. When a match is\n                        // found, immediately go back to looking at every byte. This is a small\n                        // loss (~5% performance, ~0.1% density) for compressible data due to more\n                        // bookkeeping, but for non-compressible data (such as JPEG) it's a huge\n                        // win since the compressor quickly \"realizes\" the data is incompressible\n                        // and doesn't bother looking for matches everywhere.\n                        //\n                        // The \"skip\" variable keeps track of how many bytes there are since the\n                        // last match; dividing it by 32 (ie. right-shifting by five) gives the\n                        // number of bytes to move ahead for each iteration.\n                        int skip = 32;\n\n                        ref byte candidate = ref Unsafe.NullRef<byte>();\n                        if (Unsafe.ByteOffset(ref ip, ref ipLimit) >= (nint) 16)\n                        {\n                            nint delta = Unsafe.ByteOffset(ref inputStart, ref ip);\n                            for (int j = 0; j < 16; j += 4)\n                            {\n                                // Manually unroll this loop into chunks of 4\n\n                                uint dword = j == 0 ? preload : (uint) data;\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, j)));\n                                ref ushort tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, j)));\n                                tableEntry = (ushort) (delta + j);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (j << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op,  1));\n                                    ip = ref Unsafe.Add(ref ip, j);\n                                    op = ref Unsafe.Add(ref op, j + 2);\n                                    goto emit_match;\n                                }\n\n                                int i1 = j + 1;\n                                dword = (uint)(data >> 8);\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, i1)));\n                                tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, i1)));\n                                tableEntry = (ushort) (delta + i1);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (i1 << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op, 1));\n                                    ip = ref Unsafe.Add(ref ip, i1);\n                                    op = ref Unsafe.Add(ref op, i1 + 2);\n                                    goto emit_match;\n                                }\n\n                                int i2 = j + 2;\n                                dword = (uint)(data >> 16);\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, i2)));\n                                tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, i2)));\n                                tableEntry = (ushort) (delta + i2);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (i2 << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op, 1));\n                                    ip = ref Unsafe.Add(ref ip, i2);\n                                    op = ref Unsafe.Add(ref op, i2 + 2);\n                                    goto emit_match;\n                                }\n\n                                int i3 = j + 3;\n                                dword = (uint)(data >> 24);\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, i3)));\n                                tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, i3)));\n                                tableEntry = (ushort) (delta + i3);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (i3 << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op, 1));\n                                    ip = ref Unsafe.Add(ref ip, i3);\n                                    op = ref Unsafe.Add(ref op, i3 + 2);\n                                    goto emit_match;\n                                }\n\n                                data = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref ip, j + 4));\n                            }\n\n                            ip = ref Unsafe.Add(ref ip, 16);\n                            skip += 16;\n                        }\n\n                        while (true)\n                        {\n                            Debug.Assert((uint) data == Helpers.UnsafeReadUInt32(ref ip));\n                            ref ushort tableEntry = ref HashTable.TableEntry(ref table, (uint) data, mask);\n                            int bytesBetweenHashLookups = skip >> 5;\n                            skip += bytesBetweenHashLookups;\n\n                            ref byte nextIp = ref Unsafe.Add(ref ip, bytesBetweenHashLookups);\n                            if (Unsafe.IsAddressGreaterThan(ref nextIp, ref ipLimit))\n                            {\n                                ip = ref nextEmit;\n                                goto emit_remainder;\n                            }\n\n                            candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                            Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                            Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref ip));\n\n                            tableEntry = (ushort) Unsafe.ByteOffset(ref inputStart, ref ip);\n                            if ((uint) data == Helpers.UnsafeReadUInt32(ref candidate))\n                            {\n                                break;\n                            }\n\n                            data = Helpers.UnsafeReadUInt32(ref nextIp);\n                            ip = ref nextIp;\n                        }\n\n                        // Step 2: A 4-byte match has been found.  We'll later see if more\n                        // than 4 bytes match.  But, prior to the match, input\n                        // bytes [next_emit, ip) are unmatched.  Emit them as \"literal bytes.\"\n                        Debug.Assert(!Unsafe.IsAddressGreaterThan(ref Unsafe.Add(ref nextEmit, 16), ref Unsafe.Add(ref inputEnd, 1)));\n                        op = ref EmitLiteralFast(ref op, ref nextEmit, (uint) Unsafe.ByteOffset(ref nextEmit, ref ip));\n\n                        // Step 3: Call EmitCopy, and then see if another EmitCopy could\n                        // be our next move.  Repeat until we find no match for the\n                        // input immediately after what was consumed by the last EmitCopy call.\n                        //\n                        // If we exit this loop normally then we need to call EmitLiteral next,\n                        // though we don't yet know how big the literal will be.  We handle that\n                        // by proceeding to the next iteration of the main loop.  We also can exit\n                        // this loop via goto if we get close to exhausting the input.\n\n                        emit_match:\n                        do\n                        {\n                            // We have a 4-byte match at ip, and no need to emit any\n                            // \"literal bytes\" prior to ip.\n                            ref byte emitBase = ref ip;\n\n                            var (matchLength, matchLengthLessThan8) =\n                                FindMatchLength(ref Unsafe.Add(ref candidate, 4), ref Unsafe.Add(ref ip, 4), ref inputEnd, ref data);\n\n                            int matched = 4 + matchLength;\n                            ip = ref Unsafe.Add(ref ip, matched);\n\n                            nint offset = Unsafe.ByteOffset(ref candidate, ref emitBase);\n                            if (matchLengthLessThan8)\n                            {\n                                op = ref EmitCopyLenLessThan12(ref op, offset, matched);\n                            }\n                            else\n                            {\n                                op = ref EmitCopyLenGreaterThanOrEqualTo12(ref op, offset, matched);\n                            }\n\n                            if (!Unsafe.IsAddressLessThan(ref ip, ref ipLimit))\n                            {\n                                goto emit_remainder;\n                            }\n\n                            // Expect 5 bytes to match\n                            Debug.Assert((data & 0xfffffffffful) ==\n                                         (Helpers.UnsafeReadUInt64(ref ip) & 0xfffffffffful));\n\n                            // We are now looking for a 4-byte match again.  We read\n                            // table[Hash(ip, mask)] for that.  To improve compression,\n                            // we also update table[Hash(ip - 1, mask)] and table[Hash(ip, mask)].\n                            HashTable.TableEntry(ref table, Helpers.UnsafeReadUInt32(ref Unsafe.Subtract(ref ip, 1)), mask) =\n                                (ushort) (Unsafe.ByteOffset(ref inputStart, ref ip) - 1);\n                            ref ushort tableEntry = ref HashTable.TableEntry(ref table, (uint) data, mask);\n                            candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                            tableEntry = (ushort) Unsafe.ByteOffset(ref inputStart, ref ip);\n                        } while ((uint) data == Helpers.UnsafeReadUInt32(ref candidate));\n\n                        // Because the least significant 5 bytes matched, we can utilize data\n                        // for the next iteration.\n                        preload = (uint) (data >> 8);\n                    }\n                }\n\n                emit_remainder:\n                // Emit the remaining bytes as a literal\n                if (!Unsafe.IsAddressGreaterThan(ref ip, ref inputEnd))\n                {\n                    op = ref EmitLiteralSlow(ref op, ref ip, (uint) Unsafe.ByteOffset(ref ip, ref inputEnd) + 1);\n                }\n\n                return (int) Unsafe.ByteOffset(ref output[0], ref op);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitLiteralFast(ref byte op, ref byte literal, uint length)\n        {\n            Debug.Assert(length > 0);\n\n            if (length <= 16)\n            {\n                uint n = length - 1;\n                op = unchecked((byte)(Constants.Literal | (n << 2)));\n                op = ref Unsafe.Add(ref op, 1);\n\n                CopyHelpers.UnalignedCopy128(in literal, ref op);\n                return ref Unsafe.Add(ref op, length);\n            }\n\n            return ref EmitLiteralSlow(ref op, ref literal, length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitLiteralSlow(ref byte op, ref byte literal, uint length)\n        {\n            uint n = length - 1;\n            if (n < 60)\n            {\n                op = unchecked((byte) (Constants.Literal | (n << 2)));\n                op = ref Unsafe.Add(ref op, 1);\n            }\n            else\n            {\n                int count = (Helpers.Log2Floor(n) >> 3) + 1;\n\n                Debug.Assert(count >= 1);\n                Debug.Assert(count <= 4);\n                op = unchecked((byte)(Constants.Literal | ((59 + count) << 2)));\n                op = ref Unsafe.Add(ref op, 1);\n\n                // Encode in upcoming bytes.\n                // Write 4 bytes, though we may care about only 1 of them. The output buffer\n                // is guaranteed to have at least 3 more spaces left as 'len >= 61' holds\n                // here and there is a std::memcpy() of size 'len' below.\n                Helpers.UnsafeWriteUInt32(ref op, n);\n                op = ref Unsafe.Add(ref op, count);\n            }\n\n            Unsafe.CopyBlockUnaligned(ref op, ref literal, length);\n            return ref Unsafe.Add(ref op,  length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyAtMost64LenLessThan12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length <= 64);\n            Debug.Assert(length >= 4);\n            Debug.Assert(offset < 65536);\n            Debug.Assert(length < 12);\n\n            unchecked\n            {\n                uint u = (uint) ((length << 2) + (offset << 8));\n                uint copy1 = (uint) (Constants.Copy1ByteOffset - (4 << 2) + ((offset >> 3) & 0xe0));\n                uint copy2 = (uint) (Constants.Copy2ByteOffset - (1 << 2));\n\n                // It turns out that offset < 2048 is a difficult to predict branch.\n                // `perf record` shows this is the highest percentage of branch misses in\n                // benchmarks. This code produces branch free code, the data dependency\n                // chain that bottlenecks the throughput is so long that a few extra\n                // instructions are completely free (IPC << 6 because of data deps).\n                u += offset < 2048 ? copy1 : copy2;\n                Helpers.UnsafeWriteUInt32(ref op, u);\n            }\n\n            return ref Unsafe.Add(ref op, offset < 2048 ? 2 : 3);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length <= 64);\n            Debug.Assert(length >= 4);\n            Debug.Assert(offset < 65536);\n            Debug.Assert(length >= 12);\n\n            // Write 4 bytes, though we only care about 3 of them.  The output buffer\n            // is required to have some slack, so the extra byte won't overrun it.\n            var u = unchecked((uint)(Constants.Copy2ByteOffset + ((length - 1) << 2) + (offset << 8)));\n            Helpers.UnsafeWriteUInt32(ref op, u);\n            return ref Unsafe.Add(ref op, 3);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyLenLessThan12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length < 12);\n\n            return ref EmitCopyAtMost64LenLessThan12(ref op, offset, length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyLenGreaterThanOrEqualTo12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length >= 12);\n\n            // A special case for len <= 64 might help, but so far measurements suggest\n            // it's in the noise.\n\n            // Emit 64 byte copies but make sure to keep at least four bytes reserved.\n            while (length >= 68)\n            {\n                op = ref EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref op, offset, 64);\n                length -= 64;\n            }\n\n            // One or two copies will now finish the job.\n            if (length > 64) {\n                op = ref EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref op, offset, 60);\n                length -= 60;\n            }\n\n            // Emit remainder.\n            if (length < 12) {\n                op = ref EmitCopyAtMost64LenLessThan12(ref op, offset, length);\n            } else {\n                op = ref EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref op, offset, length);\n            }\n            return ref op;\n        }\n\n        /// <summary>\n        /// Find the largest n such that\n        ///\n        ///   s1[0,n-1] == s2[0,n-1]\n        ///   and n &lt;= (s2_limit - s2 + 1).\n        ///\n        /// Return (n, n &lt; 8).\n        /// Reads up to and including *s2_limit but not beyond.\n        /// Does not read *(s1 + (s2_limit - s2 + 1)) or beyond.\n        /// Requires that s2_limit+1 &gt;= s2.\n        ///\n        /// In addition populate *data with the next 5 bytes from the end of the match.\n        /// This is only done if 8 bytes are available (s2_limit - s2 &gt;= 8). The point is\n        /// that on some arch's this can be done faster in this routine than subsequent\n        /// loading from s2 + n.\n        /// </summary>\n        /// <remarks>\n        /// The reference implementation has s2Limit as one byte past the end of the input,\n        /// but this implementation has it at the end of the input. This ensures that it always\n        /// points within the array in case GC moves the array.\n        /// </remarks>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength(\n            ref byte s1, ref byte s2, ref byte s2Limit, ref ulong data)\n        {\n            Debug.Assert(!Unsafe.IsAddressLessThan(ref Unsafe.Add(ref s2Limit, 1), ref s2));\n\n            if (BitConverter.IsLittleEndian && IntPtr.Size == 8)\n            {\n                // Special implementation for 64-bit little endian processors (i.e. Intel/AMD x64)\n                return FindMatchLengthX64(ref s1, ref s2, ref s2Limit, ref data);\n            }\n\n            int matched = 0;\n\n            while (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 3))\n                   && Helpers.UnsafeReadUInt32(ref s2) == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched)))\n            {\n                s2 = ref Unsafe.Add(ref s2, 4);\n                matched += 4;\n            }\n\n            if (BitConverter.IsLittleEndian && !Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 3)))\n            {\n                uint x = Helpers.UnsafeReadUInt32(ref s2) ^ Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched));\n                int matchingBits = Helpers.FindLsbSetNonZero(x);\n                matched += matchingBits >> 3;\n                s2 = ref Unsafe.Add(ref s2, matchingBits >> 3);\n            }\n            else\n            {\n                while (!Unsafe.IsAddressGreaterThan(ref s2, ref s2Limit) && Unsafe.Add(ref s1, matched) == s2)\n                {\n                    s2 = ref Unsafe.Add(ref s2, 1);\n                    ++matched;\n                }\n            }\n\n            if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 7)))\n            {\n                data = Helpers.UnsafeReadUInt64(ref s2);\n            }\n\n            return (matched, matched < 8);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64(\n            ref byte s1, ref byte s2, ref byte s2Limit, ref ulong data)\n        {\n            nint matched = 0;\n\n            // This block isn't necessary for correctness; we could just start looping\n            // immediately.  As an optimization though, it is useful.  It creates some not\n            // uncommon code paths that determine, without extra effort, whether the match\n            // length is less than 8.\n            if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 15)))\n            {\n                ulong a1 = Helpers.UnsafeReadUInt64(ref s1);\n                ulong a2 = Helpers.UnsafeReadUInt64(ref s2);\n\n                if (a1 != a2)\n                {\n                    ulong xorval = a1 ^ a2;\n                    int shift = Helpers.FindLsbSetNonZero(xorval);\n                    int matchedBytes = shift >> 3;\n\n                    ulong a3 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s2, 4));\n                    a2 = unchecked((uint)xorval) == 0 ? a3 : a2;\n\n                    data = a2 >> (shift & (3 * 8));\n                    return (matchedBytes, true);\n                }\n                else\n                {\n                    matched = 8;\n                    s2 = ref Unsafe.Add(ref s2, 8);\n                }\n            }\n\n            // Find out how long the match is. We loop over the data 64 bits at a\n            // time until we find a 64-bit block that doesn't match; then we find\n            // the first non-matching bit and use that to calculate the total\n            // length of the match.\n            while (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 15)))\n            {\n                ulong a1 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s1, matched));\n                ulong a2 = Helpers.UnsafeReadUInt64(ref s2);\n                if (a1 == a2)\n                {\n                    s2 = ref Unsafe.Add(ref s2, 8);\n                    matched += 8;\n                }\n                else\n                {\n                    ulong xorval = a1 ^ a2;\n                    int shift = Helpers.FindLsbSetNonZero(xorval);\n                    int matchedBytes = shift >> 3;\n\n                    ulong a3 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s2, 4));\n                    a2 = unchecked((uint)xorval) == 0 ? a3 : a2;\n\n                    data = a2 >> (shift & (3 * 8));\n                    matched += matchedBytes;\n                    Debug.Assert(matched >= 8);\n                    return ((int)matched, false);\n                }\n            }\n\n            while (!Unsafe.IsAddressGreaterThan(ref s2, ref s2Limit))\n            {\n                if (Unsafe.Add(ref s1, matched) == s2)\n                {\n                    s2 = ref Unsafe.Add(ref s2, 1);\n                    matched++;\n                }\n                else\n                {\n                    if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 7)))\n                    {\n                        data = Helpers.UnsafeReadUInt64(ref s2);\n                    }\n\n                    return ((int)matched, matched < 8);\n                }\n            }\n\n            return ((int)matched, matched < 8);\n        }\n\n        #endregion\n    }\n}\n", "using System;\nusing System.Buffers;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.CompilerServices;\n\nnamespace Snappier.Internal\n{\n    internal sealed class SnappyDecompressor : IDisposable\n    {\n        private byte[] _scratch = new byte[Constants.MaximumTagLength];\n        private uint _scratchLength = 0;\n\n        private int _remainingLiteral;\n\n        private int _uncompressedLengthShift;\n        private int _uncompressedLength;\n\n        public bool NeedMoreData => !AllDataDecompressed && UnreadBytes == 0;\n\n        /// <summary>\n        /// Decompress a portion of the input.\n        /// </summary>\n        /// <param name=\"input\">Input to process.</param>\n        /// <returns>Number of bytes processed from the input.</returns>\n        /// <remarks>\n        /// The first call to this method after construction or after a call to <see cref=\"Reset\"/> start at the\n        /// beginning of a new Snappy block, leading with the encoded block size. It may be called multiple times\n        /// as more data becomes available. <see cref=\"AllDataDecompressed\"/> will be true once the entire block\n        /// has been processed.\n        /// </remarks>\n        public void Decompress(ReadOnlySpan<byte> input)\n        {\n            if (!ExpectedLength.HasValue)\n            {\n                var readLength = ReadUncompressedLength(ref input);\n                if (readLength.HasValue)\n                {\n                    ExpectedLength = readLength.GetValueOrDefault();\n                }\n                else\n                {\n                    // Not enough data yet to process the length\n                    return;\n                }\n            }\n\n            // Process any input into the write buffer\n\n            if (input.Length > 0)\n            {\n                if (_remainingLiteral > 0)\n                {\n                    int toWrite = Math.Min(_remainingLiteral, input.Length);\n\n                    Append(input.Slice(0, toWrite));\n                    input = input.Slice(toWrite);\n                    _remainingLiteral -= toWrite;\n                }\n\n                if (!AllDataDecompressed && input.Length > 0)\n                {\n                    DecompressAllTags(input);\n                }\n            }\n        }\n\n        public void Reset()\n        {\n            _scratchLength = 0;\n            _remainingLiteral = 0;\n\n            _uncompressedLength = 0;\n            _uncompressedLengthShift = 0;\n\n            _lookbackPosition = 0;\n            _readPosition = 0;\n            ExpectedLength = null;\n        }\n\n        /// <summary>\n        /// Read the uncompressed length stored at the start of the compressed data.\n        /// </summary>\n        /// <param name=\"input\">Input data, which should begin with the varint encoded uncompressed length.</param>\n        /// <returns>The length of the compressed data, or null if the length is not yet complete.</returns>\n        /// <remarks>\n        /// This variant is used when reading a stream, and will pause if there aren't enough bytes available\n        /// in the input. Subsequent calls with more data will resume processing.\n        /// </remarks>\n        private int? ReadUncompressedLength(ref ReadOnlySpan<byte> input)\n        {\n            int result = _uncompressedLength;\n            int shift = _uncompressedLengthShift;\n            bool foundEnd = false;\n\n            var i = 0;\n            while (input.Length > i)\n            {\n                byte c = input[i];\n                i += 1;\n\n                int val = c & 0x7f;\n                if (Helpers.LeftShiftOverflows((byte) val, shift))\n                {\n                    ThrowHelper.ThrowInvalidOperationException(\"Invalid stream length\");\n                }\n\n                result |= val << shift;\n\n                if (c < 128)\n                {\n                    foundEnd = true;\n                    break;\n                }\n\n                shift += 7;\n\n                if (shift >= 32)\n                {\n                    ThrowHelper.ThrowInvalidOperationException(\"Invalid stream length\");\n                }\n            }\n\n            input = input.Slice(i);\n            _uncompressedLength = result;\n            _uncompressedLengthShift = shift;\n\n            return foundEnd ? (int?)result : null;\n        }\n\n        /// <summary>\n        /// Read the uncompressed length stored at the start of the compressed data.\n        /// </summary>\n        /// <param name=\"input\">Input data, which should begin with the varint encoded uncompressed length.</param>\n        /// <returns>The length of the uncompressed data.</returns>\n        /// <exception cref=\"InvalidDataException\">Invalid stream length</exception>\n        public static int ReadUncompressedLength(ReadOnlySpan<byte> input)\n        {\n            int result = 0;\n            int shift = 0;\n            bool foundEnd = false;\n\n            var i = 0;\n            while (input.Length > 0)\n            {\n                byte c = input[i];\n                i += 1;\n\n                int val = c & 0x7f;\n                if (Helpers.LeftShiftOverflows((byte) val, shift))\n                {\n                    ThrowHelper.ThrowInvalidDataException(\"Invalid stream length\");\n                }\n\n                result |= val << shift;\n\n                if (c < 128)\n                {\n                    foundEnd = true;\n                    break;\n                }\n\n                shift += 7;\n\n                if (shift >= 32)\n                {\n                    ThrowHelper.ThrowInvalidDataException(\"Invalid stream length\");\n                }\n            }\n\n            if (!foundEnd)\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Invalid stream length\");\n            }\n\n            return result;\n        }\n\n        internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n        {\n            // Put Constants.CharTable on the stack to simplify lookups within the loops below.\n            // Slicing with length 256 here allows the JIT compiler to recognize the size is greater than\n            // the size of the byte we're indexing with and optimize out range checks.\n            ReadOnlySpan<ushort> charTable = Constants.CharTable.AsSpan(0, 256);\n\n            unchecked\n            {\n                ref byte input = ref Unsafe.AsRef(in inputSpan[0]);\n\n                // The reference Snappy implementation uses inputEnd as a pointer one byte past the end of the buffer.\n                // However, this is not safe when using ref locals. The ref must point to somewhere within the array\n                // so that GC can adjust the ref if the memory is moved.\n                ref byte inputEnd = ref Unsafe.Add(ref input, inputSpan.Length - 1);\n\n                // Track the point in the input before which input is guaranteed to have at least Constants.MaxTagLength bytes left\n                ref byte inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, Math.Min(inputSpan.Length, Constants.MaximumTagLength - 1) - 1);\n\n                // We always allocate buffer with at least one extra byte on the end, so bufferEnd doesn't have the same\n                // restrictions as inputEnd.\n                ref byte buffer = ref _lookbackBuffer.Span[0];\n                ref byte bufferEnd = ref Unsafe.Add(ref buffer, _lookbackBuffer.Length);\n                ref byte op = ref Unsafe.Add(ref buffer, _lookbackPosition);\n\n                // Get a reference to the first byte in the scratch buffer, we'll reuse this so that we don't repeat range checks every time\n                ref byte scratch = ref _scratch[0];\n\n                if (_scratchLength > 0)\n                {\n                    // Have partial tag remaining from a previous decompress run\n                    // Get the combined tag in the scratch buffer, then run through\n                    // special case processing that gets the tag from the scratch buffer\n                    // and any literal data from the _input buffer\n\n                    // This is not a hot path, so it's more efficient to process this as a separate method\n                    // so that the stack size of this method is smaller and JIT can produce better results\n\n                    (uint inputUsed, uint bytesWritten) =\n                        DecompressTagFromScratch(ref input, ref inputEnd, ref op, ref buffer, ref bufferEnd, ref scratch);\n                    if (inputUsed == 0)\n                    {\n                        // There was insufficient data to read an entire tag. Some data was moved to scratch\n                        // but short circuit for another pass when we have more data.\n                        return;\n                    }\n\n                    input = ref Unsafe.Add(ref input, inputUsed);\n                    op = ref Unsafe.Add(ref op, bytesWritten);\n                }\n\n                if (!Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength))\n                {\n                    uint newScratchLength = RefillTag(ref input, ref inputEnd, ref scratch);\n                    if (newScratchLength == uint.MaxValue)\n                    {\n                        goto exit;\n                    }\n\n                    if (newScratchLength > 0)\n                    {\n                        // Data has been moved to the scratch buffer\n                        input = ref scratch;\n                        inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1);\n                        inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n                            Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1);\n                    }\n                }\n\n                uint preload = Helpers.UnsafeReadUInt32(ref input);\n\n                while (true)\n                {\n                    byte c = (byte) preload;\n                    input = ref Unsafe.Add(ref input, 1);\n\n                    if ((c & 0x03) == Constants.Literal)\n                    {\n                        nint literalLength = unchecked((c >> 2) + 1);\n\n                        if (TryFastAppend(ref op, ref bufferEnd, in input, Unsafe.ByteOffset(ref input, ref inputEnd) + 1, literalLength))\n                        {\n                            Debug.Assert(literalLength < 61);\n                            op = ref Unsafe.Add(ref op, literalLength);\n                            input = ref Unsafe.Add(ref input, literalLength);\n                            // NOTE: There is no RefillTag here, as TryFastAppend()\n                            // will not return true unless there's already at least five spare\n                            // bytes in addition to the literal.\n                            preload = Helpers.UnsafeReadUInt32(ref input);\n                            continue;\n                        }\n\n                        if (literalLength >= 61)\n                        {\n                            // Long literal.\n                            nint literalLengthLength = literalLength - 60;\n                            uint literalLengthTemp = Helpers.UnsafeReadUInt32(ref input);\n\n                            literalLength = (nint) Helpers.ExtractLowBytes(literalLengthTemp,\n                                (int) literalLengthLength) + 1;\n\n                            input = ref Unsafe.Add(ref input, literalLengthLength);\n                        }\n\n                        nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd) + 1;\n                        if (inputRemaining < literalLength)\n                        {\n                            Append(ref op, ref bufferEnd, in input, inputRemaining);\n                            op = ref Unsafe.Add(ref op, inputRemaining);\n                            _remainingLiteral = (int) (literalLength - inputRemaining);\n                            goto exit;\n                        }\n                        else\n                        {\n                            Append(ref op, ref bufferEnd, in input, literalLength);\n                            op = ref Unsafe.Add(ref op, literalLength);\n                            input = ref Unsafe.Add(ref input, literalLength);\n\n                            if (!Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength))\n                            {\n                                uint newScratchLength = RefillTag(ref input, ref inputEnd, ref scratch);\n                                if (newScratchLength == uint.MaxValue)\n                                {\n                                    goto exit;\n                                }\n\n                                if (newScratchLength > 0)\n                                {\n                                    // Data has been moved to the scratch buffer\n                                    input = ref scratch;\n                                    inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1);\n                                    inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n                                        Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1);\n\n                                }\n                            }\n\n                            preload = Helpers.UnsafeReadUInt32(ref input);\n                        }\n                    }\n                    else\n                    {\n                        if ((c & 3) == Constants.Copy4ByteOffset)\n                        {\n                            uint copyOffset = Helpers.UnsafeReadUInt32(ref input);\n                            input = ref Unsafe.Add(ref input, 4);\n\n                            nint length = (c >> 2) + 1;\n                            AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n                            op = ref Unsafe.Add(ref op, length);\n                        }\n                        else\n                        {\n                            ushort entry = charTable[c];\n\n                            // We don't use BitConverter to read because we might be reading past the end of the span\n                            // But we know that's safe because we'll be doing it in _scratch with extra data on the end.\n                            // This reduces this step by several operations\n                            preload = Helpers.UnsafeReadUInt32(ref input);\n\n                            uint trailer = Helpers.ExtractLowBytes(preload, c & 3);\n                            nint length = entry & 0xff;\n\n                            // copy_offset/256 is encoded in bits 8..10.  By just fetching\n                            // those bits, we get copy_offset (since the bit-field starts at\n                            // bit 8).\n                            uint copyOffset = (entry & 0x700u) + trailer;\n\n                            AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n                            op = ref Unsafe.Add(ref op, length);\n\n                            input = ref Unsafe.Add(ref input, c & 3);\n\n                            // By using the result of the previous load we reduce the critical\n                            // dependency chain of ip to 4 cycles.\n                            preload >>= (c & 3) * 8;\n                            if (Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength)) continue;\n                        }\n\n                        if (!Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength))\n                        {\n                            uint newScratchLength = RefillTag(ref input, ref inputEnd, ref scratch);\n                            if (newScratchLength == uint.MaxValue)\n                            {\n                                goto exit;\n                            }\n\n                            if (newScratchLength > 0)\n                            {\n                                // Data has been moved to the scratch buffer\n                                input = ref scratch;\n                                inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1);\n                                inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n                                    Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1);\n                            }\n                        }\n\n                        preload = Helpers.UnsafeReadUInt32(ref input);\n                    }\n                }\n\n                exit: ; // All input data is processed\n                _lookbackPosition = (int)Unsafe.ByteOffset(ref buffer, ref op);\n            }\n        }\n\n        // Returns the amount of the input used, 0 indicates there was insufficient data.\n        // Some of the input may have been used if 0 is returned, but it isn't relevant because\n        // DecompressAllTags will short circuit.\n        private (uint inputUsed, uint bytesWritten) DecompressTagFromScratch(ref byte input, ref byte inputEnd, ref byte op,\n            ref byte buffer, ref byte bufferEnd, ref byte scratch)\n        {\n            // scratch will be the scratch buffer with only the tag if true is returned\n            uint inputUsed = RefillTagFromScratch(ref input, ref inputEnd, ref scratch);\n            if (inputUsed == 0)\n            {\n                return (0, 0);\n            }\n            input = ref Unsafe.Add(ref input, inputUsed);\n\n            // No more scratch for next cycle, we have a full buffer we're about to use\n            _scratchLength = 0;\n\n            byte c = scratch;\n            scratch = ref Unsafe.Add(ref scratch, 1);\n\n            if ((c & 0x03) == Constants.Literal)\n            {\n                uint literalLength = (uint)((c >> 2) + 1);\n                if (literalLength >= 61)\n                {\n                    // Long literal.\n                    uint literalLengthLength = literalLength - 60;\n                    uint literalLengthTemp = Helpers.UnsafeReadUInt32(ref scratch);\n\n                    literalLength = Helpers.ExtractLowBytes(literalLengthTemp,\n                        (int) literalLengthLength) + 1;\n                }\n\n                nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd) + 1;\n                if (inputRemaining < literalLength)\n                {\n                    Append(ref op, ref bufferEnd, in input, inputRemaining);\n                    _remainingLiteral = (int) (literalLength - inputRemaining);\n                    _lookbackPosition += (int)Unsafe.ByteOffset(ref buffer, ref op);\n\n                    // Insufficient data in this case as well, trigger a short circuit\n                    return (0, 0);\n                }\n                else\n                {\n                    Append(ref op, ref bufferEnd, in input, (nint)literalLength);\n\n                    return (inputUsed + literalLength, literalLength);\n                }\n            }\n            else if ((c & 3) == Constants.Copy4ByteOffset)\n            {\n                uint copyOffset = Helpers.UnsafeReadUInt32(ref scratch);\n\n                nint length = (c >> 2) + 1;\n\n                AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n\n                return (inputUsed, (uint) length);\n            }\n            else\n            {\n                ushort entry = Constants.CharTable[c];\n                uint data = Helpers.UnsafeReadUInt32(ref scratch);\n\n                uint trailer = Helpers.ExtractLowBytes(data, c & 3);\n                nint length = entry & 0xff;\n\n                // copy_offset/256 is encoded in bits 8..10.  By just fetching\n                // those bits, we get copy_offset (since the bit-field starts at\n                // bit 8).\n                uint copyOffset = (entry & 0x700u) + trailer;\n\n                AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n\n                return (inputUsed, (uint) length);\n            }\n        }\n\n        // Returns the amount of the input used, 0 indicates there was insufficient data.\n        // Some of the input may have been used if 0 is returned, but it isn't relevant because\n        // DecompressAllTags will short circuit.\n        private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte scratch)\n        {\n            Debug.Assert(_scratchLength > 0);\n\n            if (Unsafe.IsAddressGreaterThan(ref input, ref inputEnd))\n            {\n                return 0;\n            }\n\n            // Read the tag character\n            uint entry = Constants.CharTable[scratch];\n            uint needed = (entry >> 11) + 1; // +1 byte for 'c'\n\n            uint toCopy = Math.Min((uint)Unsafe.ByteOffset(ref input, ref inputEnd) + 1, needed - _scratchLength);\n            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref scratch, _scratchLength), ref input, toCopy);\n\n            _scratchLength += toCopy;\n\n            if (_scratchLength < needed)\n            {\n                // Still insufficient\n                return 0;\n            }\n\n            return toCopy;\n        }\n\n        // Returns 0 if there is sufficient data available in the input buffer for the next tag AND enough extra padding to\n        // safely read preload without overrunning the buffer.\n        //\n        // Returns uint.MaxValue if there is insufficient data and the decompression should stop until more data is available.\n        // In this case any dangling unused bytes will be moved to scratch and _scratchLength for the next iteration.\n        //\n        // Returns a small number if we have enough data for this tag but not enough to safely load preload without a buffer\n        // overrun. In this case, further reads should be from scratch with a length up to the returned number. Scratch will\n        // always have some extra bytes on the end so we don't risk buffer overruns.\n        private uint RefillTag(ref byte input, ref byte inputEnd, ref byte scratch)\n        {\n            if (Unsafe.IsAddressGreaterThan(ref input, ref inputEnd))\n            {\n                return uint.MaxValue;\n            }\n\n            // Read the tag character\n            uint entry = Constants.CharTable[input];\n            uint needed = (entry >> 11) + 1; // +1 byte for 'c'\n\n            uint inputLength = (uint)Unsafe.ByteOffset(ref input, ref inputEnd) + 1;\n            if (inputLength < needed)\n            {\n                // Data is insufficient, copy to scratch\n                Unsafe.CopyBlockUnaligned(ref scratch, ref input, inputLength);\n\n                _scratchLength = inputLength;\n                return uint.MaxValue;\n            }\n\n            if (inputLength < Constants.MaximumTagLength)\n            {\n                // Have enough bytes, but copy to scratch so that we do not\n                // read past end of input\n                Unsafe.CopyBlockUnaligned(ref scratch, ref input, inputLength);\n\n                return inputLength;\n            }\n\n            return 0;\n        }\n\n        #region Loopback Writer\n\n        private byte[]? _lookbackBufferArray;\n        private Memory<byte> _lookbackBuffer;\n        private int _lookbackPosition = 0;\n        private int _readPosition = 0;\n\n        private int? _expectedLength;\n        private int? ExpectedLength\n        {\n            get => _expectedLength;\n            set\n            {\n                _expectedLength = value;\n\n                if (value.HasValue && _lookbackBuffer.Length < value.GetValueOrDefault())\n                {\n                    if (_lookbackBufferArray is not null)\n                    {\n                        ArrayPool<byte>.Shared.Return(_lookbackBufferArray);\n                    }\n\n                    // Always pad the lookback buffer with an extra byte that we don't use. This allows a \"ref byte\" reference past\n                    // the end of the perceived buffer that still points within the array. This is a requirement so that GC can recognize\n                    // the \"ref byte\" points within the array and adjust it if the array is moved.\n                    _lookbackBufferArray = ArrayPool<byte>.Shared.Rent(value.GetValueOrDefault() + 1);\n                    _lookbackBuffer = _lookbackBufferArray.AsMemory(0, _lookbackBufferArray.Length - 1);\n                }\n            }\n        }\n\n        public int UnreadBytes\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => (int)_lookbackPosition - _readPosition;\n        }\n\n        public bool EndOfFile\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => ExpectedLength.HasValue && _readPosition >= ExpectedLength.GetValueOrDefault();\n        }\n\n        public bool AllDataDecompressed\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => ExpectedLength.HasValue && _lookbackPosition >= ExpectedLength.GetValueOrDefault();\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void Append(ReadOnlySpan<byte> input)\n        {\n            ref readonly byte inputPtr = ref input[0];\n\n            var lookbackSpan = _lookbackBuffer.Span;\n            ref byte op = ref lookbackSpan[_lookbackPosition];\n\n            Append(ref op, ref Unsafe.Add(ref lookbackSpan[0], lookbackSpan.Length), in inputPtr, input.Length);\n            _lookbackPosition += input.Length;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void Append(ref byte op, ref byte bufferEnd, in byte input, nint length)\n        {\n            if (length > Unsafe.ByteOffset(ref op, ref bufferEnd))\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Data too long\");\n            }\n\n            Unsafe.CopyBlockUnaligned(ref op, ref Unsafe.AsRef(in input), (uint) length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint available, nint length)\n        {\n            if (length <= 16 && available >= 16 + Constants.MaximumTagLength &&\n                Unsafe.ByteOffset(ref op, ref bufferEnd) >= (nint) 16)\n            {\n                CopyHelpers.UnalignedCopy128(in input, ref op);\n                return true;\n            }\n\n            return false;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, uint copyOffset, nint length)\n        {\n            ref byte source = ref Unsafe.Subtract(ref op, copyOffset);\n            if (!Unsafe.IsAddressLessThan(ref source, ref op) || Unsafe.IsAddressLessThan(ref source, ref buffer))\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Invalid copy offset\");\n            }\n\n            if (length > Unsafe.ByteOffset(ref op, ref bufferEnd))\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Data too long\");\n            }\n\n            CopyHelpers.IncrementalCopy(ref source, ref op,\n                ref Unsafe.Add(ref op, length), ref bufferEnd);\n        }\n\n        public int Read(Span<byte> destination)\n        {\n            var unreadBytes = UnreadBytes;\n            if (unreadBytes == 0)\n            {\n                return 0;\n            }\n\n            if (unreadBytes >= destination.Length)\n            {\n                _lookbackBuffer.Span.Slice(_readPosition, destination.Length).CopyTo(destination);\n                _readPosition += destination.Length;\n                return destination.Length;\n            }\n            else\n            {\n                _lookbackBuffer.Span.Slice(_readPosition, unreadBytes).CopyTo(destination);\n                _readPosition += unreadBytes;\n                return unreadBytes;\n            }\n        }\n\n        /// <summary>\n        /// Extracts the data from from the block, returning a block of memory and resetting the block.\n        /// </summary>\n        /// <returns>An block of memory. Caller is responsible for disposing.</returns>\n        /// <remarks>\n        /// This provides a more efficient way to decompress an entire block in scenarios where the caller\n        /// wants an owned block of memory and isn't going to reuse the SnappyDecompressor. It avoids the\n        /// need to copy a block of memory calling <see cref=\"Read\"/>.\n        /// </remarks>\n        public IMemoryOwner<byte> ExtractData()\n        {\n            byte[]? data = _lookbackBufferArray;\n            if (!ExpectedLength.HasValue)\n            {\n                ThrowHelper.ThrowInvalidOperationException(\"No data present.\");\n            }\n            else if (data is null || ExpectedLength.GetValueOrDefault() == 0)\n            {\n                // Length was 0, so we've allocated nothing\n                return new ByteArrayPoolMemoryOwner();\n            }\n\n            if (!AllDataDecompressed)\n            {\n                ThrowHelper.ThrowInvalidOperationException(\"Block is not fully decompressed.\");\n            }\n\n            // Build the return before we reset and clear ExpectedLength\n            var returnBuffer = new ByteArrayPoolMemoryOwner(data, ExpectedLength.GetValueOrDefault());\n\n            // Clear the buffer so we don't return it\n            _lookbackBufferArray = null;\n            _lookbackBuffer = default;\n\n            Reset();\n\n            return returnBuffer;\n        }\n\n        #endregion\n\n        #region Test Helpers\n\n        /// <summary>\n        /// Load some data into the output buffer, only used for testing.\n        /// </summary>\n        /// <param name=\"toWrite\"></param>\n        internal void WriteToBufferForTest(ReadOnlySpan<byte> toWrite)\n        {\n            Append(toWrite);\n        }\n\n        /// <summary>\n        /// Load a byte array into _scratch, only used for testing.\n        /// </summary>\n        internal void LoadScratchForTest(byte[] newScratch, uint newScratchLength)\n        {\n            ThrowHelper.ThrowIfNull(newScratch);\n            _scratch = newScratch;\n            _scratchLength = newScratchLength;\n        }\n\n        /// <summary>\n        /// Only used for testing.\n        /// </summary>\n        internal void SetExpectedLengthForTest(int expectedLength)\n        {\n            ExpectedLength = expectedLength;\n        }\n\n        #endregion\n\n        public void Dispose()\n        {\n            if (_lookbackBufferArray is not null)\n            {\n                ArrayPool<byte>.Shared.Return(_lookbackBufferArray);\n                _lookbackBufferArray = null;\n                _lookbackBuffer = default;\n            }\n        }\n    }\n}\n"], "fixing_code": ["using System;\nusing System.Runtime.CompilerServices;\nusing BenchmarkDotNet.Attributes;\nusing Snappier.Internal;\n\nnamespace Snappier.Benchmarks\n{\n    public class FindMatchLength\n    {\n        private static readonly byte[] s_fourByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n            1, 2, 3, 4, 4, 6, 7, 8, 9, 10, 11, 13,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        private static readonly byte[] s_sevenByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n            1, 2, 3, 4, 5, 6, 7, 7, 9, 10, 11, 13,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        private static readonly byte[] s_elevenByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        private static readonly byte[] s_thirtyTwoByteMatch =\n        {\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            // Padding so we ensure we're hitting the hot (and fast) path where there is plenty more data in the input buffer\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        };\n\n        [Params(4, 7, 11, 32)]\n        public int MatchLength { get; set; }\n\n        private byte[] _array;\n\n        [GlobalSetup]\n        public void GlobalSetup()\n        {\n            _array = MatchLength switch\n            {\n                4 => s_fourByteMatch,\n                7 => s_sevenByteMatch,\n                11 => s_elevenByteMatch,\n                32 => s_thirtyTwoByteMatch,\n                _ => throw new InvalidOperationException()\n            };\n        }\n\n        [Benchmark(Baseline = true)]\n        public (long, bool) Regular()\n        {\n            ulong data = 0;\n\n            ref byte s1 = ref _array[0];\n            ref byte s2 = ref Unsafe.Add(ref s1, 12);\n            ref byte s2Limit = ref Unsafe.Add(ref s1, _array.Length);\n\n            return SnappyCompressor.FindMatchLength(ref s1, ref s2, ref s2Limit, ref data);\n        }\n    }\n}\n", "using System;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing Snappier.Internal;\nusing Xunit;\n\nnamespace Snappier.Tests.Internal\n{\n    public class SnappyCompressorTests\n    {\n        #region FindMatchLength\n\n        [Theory]\n        [InlineData(6, \"012345\", \"012345\", 6)]\n        [InlineData(11, \"01234567abc\", \"01234567abc\", 11)]\n\n        // Hit s1_limit in 64-bit loop, find a non-match in single-character loop.\n        [InlineData(9, \"01234567abc\", \"01234567axc\", 9)]\n\n        // Same, but edge cases.\n        [InlineData(11, \"01234567abc!\", \"01234567abc!\", 11)]\n        [InlineData(11, \"01234567abc!\", \"01234567abc?\", 11)]\n\n        // Find non-match at once in first loop.\n        [InlineData(0, \"01234567xxxxxxxx\", \"?1234567xxxxxxxx\", 16)]\n        [InlineData(1, \"01234567xxxxxxxx\", \"0?234567xxxxxxxx\", 16)]\n        [InlineData(4, \"01234567xxxxxxxx\", \"01237654xxxxxxxx\", 16)]\n        [InlineData(7, \"01234567xxxxxxxx\", \"0123456?xxxxxxxx\", 16)]\n\n        // Find non-match in first loop after one block.\n        [InlineData(8, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh?1234567xxxxxxxx\", 24)]\n        [InlineData(9, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh0?234567xxxxxxxx\", 24)]\n        [InlineData(12, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh01237654xxxxxxxx\", 24)]\n        [InlineData(15, \"abcdefgh01234567xxxxxxxx\", \"abcdefgh0123456?xxxxxxxx\", 24)]\n\n        // 32-bit version:\n\n        // Short matches.\n        [InlineData(0, \"01234567\", \"?1234567\", 8)]\n        [InlineData(1, \"01234567\", \"0?234567\", 8)]\n        [InlineData(2, \"01234567\", \"01?34567\", 8)]\n        [InlineData(3, \"01234567\", \"012?4567\", 8)]\n        [InlineData(4, \"01234567\", \"0123?567\", 8)]\n        [InlineData(5, \"01234567\", \"01234?67\", 8)]\n        [InlineData(6, \"01234567\", \"012345?7\", 8)]\n        [InlineData(7, \"01234567\", \"0123456?\", 8)]\n        [InlineData(7, \"01234567\", \"0123456?\", 7)]\n        [InlineData(7, \"01234567!\", \"0123456??\", 7)]\n\n        // Hit s1_limit in 32-bit loop, hit s1_limit in single-character loop.\n        [InlineData(10, \"xxxxxxabcd\", \"xxxxxxabcd\", 10)]\n        [InlineData(10, \"xxxxxxabcd?\", \"xxxxxxabcd?\", 10)]\n        [InlineData(13, \"xxxxxxabcdef\", \"xxxxxxabcdefx\", 13)]\n\n        // Same, but edge cases.\n        [InlineData(12, \"xxxxxx0123abc!\", \"xxxxxx0123abc!\", 12)]\n        [InlineData(12, \"xxxxxx0123abc!\", \"xxxxxx0123abc?\", 12)]\n\n        // Hit s1_limit in 32-bit loop, find a non-match in single-character loop.\n        [InlineData(11, \"xxxxxx0123abc\", \"xxxxxx0123axc\", 13)]\n\n        // Find non-match at once in first loop.\n        [InlineData(6, \"xxxxxx0123xxxxxxxx\", \"xxxxxx?123xxxxxxxx\", 18)]\n        [InlineData(7, \"xxxxxx0123xxxxxxxx\", \"xxxxxx0?23xxxxxxxx\", 18)]\n        [InlineData(8, \"xxxxxx0123xxxxxxxx\", \"xxxxxx0132xxxxxxxx\", 18)]\n        [InlineData(9, \"xxxxxx0123xxxxxxxx\", \"xxxxxx012?xxxxxxxx\", 18)]\n\n        // Same, but edge cases.\n        [InlineData(6, \"xxxxxx0123\", \"xxxxxx?123\", 10)]\n        [InlineData(7, \"xxxxxx0123\", \"xxxxxx0?23\", 10)]\n        [InlineData(8, \"xxxxxx0123\", \"xxxxxx0132\", 10)]\n        [InlineData(9, \"xxxxxx0123\", \"xxxxxx012?\", 10)]\n\n        // Find non-match in first loop after one block.\n        [InlineData(10, \"xxxxxxabcd0123xx\", \"xxxxxxabcd?123xx\", 16)]\n        [InlineData(11, \"xxxxxxabcd0123xx\", \"xxxxxxabcd0?23xx\", 16)]\n        [InlineData(12, \"xxxxxxabcd0123xx\", \"xxxxxxabcd0132xx\", 16)]\n        [InlineData(13, \"xxxxxxabcd0123xx\", \"xxxxxxabcd012?xx\", 16)]\n\n        // Same, but edge cases.\n        [InlineData(10, \"xxxxxxabcd0123\", \"xxxxxxabcd?123\", 14)]\n        [InlineData(11, \"xxxxxxabcd0123\", \"xxxxxxabcd0?23\", 14)]\n        [InlineData(12, \"xxxxxxabcd0123\", \"xxxxxxabcd0132\", 14)]\n        [InlineData(13, \"xxxxxxabcd0123\", \"xxxxxxabcd012?\", 14)]\n        public void FindMatchLength(int expectedResult, string s1String, string s2String, int length)\n        {\n            var array = Encoding.ASCII.GetBytes(s1String + s2String\n                                                         + new string('\\0', Math.Max(0, length - s2String.Length)));\n\n            ulong data = 0;\n            ref byte s1 = ref array[0];\n            ref byte s2 = ref Unsafe.Add(ref s1, s1String.Length);\n\n            var result =\n                SnappyCompressor.FindMatchLength(ref s1, ref s2, ref Unsafe.Add(ref s2, length), ref data);\n\n            Assert.Equal(result.matchLength < 8, result.matchLengthLessThan8);\n            Assert.Equal(expectedResult, result.matchLength);\n        }\n\n        #endregion\n    }\n}\n", "using System;\nusing System.Buffers;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nnamespace Snappier.Internal\n{\n    internal class SnappyCompressor : IDisposable\n    {\n        private HashTable? _workingMemory = new();\n\n        public int Compress(ReadOnlySpan<byte> input, Span<byte> output)\n        {\n            if (_workingMemory == null)\n            {\n                ThrowHelper.ThrowObjectDisposedException(nameof(SnappyCompressor));\n            }\n\n            _workingMemory.EnsureCapacity(input.Length);\n\n            int bytesWritten = WriteUncompressedLength(output, input.Length);\n            output = output.Slice(bytesWritten);\n\n            while (input.Length > 0)\n            {\n                var fragment = input.Slice(0, Math.Min(input.Length, (int)Constants.BlockSize));\n\n                var hashTable = _workingMemory.GetHashTable(fragment.Length);\n\n                var maxOutput = Helpers.MaxCompressedLength(fragment.Length);\n\n                if (output.Length >= maxOutput)\n                {\n                    var written = CompressFragment(fragment, output, hashTable);\n\n                    output = output.Slice(written);\n                    bytesWritten += written;\n                }\n                else\n                {\n                    var scratch = ArrayPool<byte>.Shared.Rent(maxOutput);\n                    try\n                    {\n                        int written = CompressFragment(fragment, scratch.AsSpan(), hashTable);\n                        if (output.Length < written)\n                        {\n                            ThrowHelper.ThrowArgumentException(\"Insufficient output buffer\", nameof(output));\n                        }\n\n                        scratch.AsSpan(0, written).CopyTo(output);\n                        output = output.Slice(written);\n                        bytesWritten += written;\n                    }\n                    finally\n                    {\n                        ArrayPool<byte>.Shared.Return(scratch);\n                    }\n                }\n\n                input = input.Slice(fragment.Length);\n            }\n\n            return bytesWritten;\n        }\n\n        public void Dispose()\n        {\n            _workingMemory?.Dispose();\n            _workingMemory = null;\n        }\n\n        private static int WriteUncompressedLength(Span<byte> output, int length)\n        {\n            const int b = 0b1000_0000;\n\n            unchecked\n            {\n                if (length < (1 << 7))\n                {\n                    output[0] = (byte) length;\n                    return 1;\n                }\n                else if (length < (1 << 14))\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) (length >> 7);\n                    return 2;\n                }\n                else if (length < (1 << 21))\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) ((length >> 7) | b);\n                    output[2] = (byte) (length >> 14);\n                    return 3;\n                }\n                else if (length < (1 << 28))\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) ((length >> 7) | b);\n                    output[2] = (byte) ((length >> 14) | b);\n                    output[3] = (byte) (length >> 21);\n                    return 4;\n                }\n                else\n                {\n                    output[0] = (byte) (length | b);\n                    output[1] = (byte) ((length >> 7) | b);\n                    output[2] = (byte) ((length >> 14) | b);\n                    output[3] = (byte) ((length >> 21) | b);\n                    output[4] = (byte) (length >> 28);\n                    return 5;\n                }\n            }\n        }\n\n        #region CompressFragment\n\n        private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output, Span<ushort> tableSpan)\n        {\n            unchecked\n            {\n                Debug.Assert(input.Length <= Constants.BlockSize);\n                Debug.Assert((tableSpan.Length & (tableSpan.Length - 1)) == 0); // table must be power of two\n\n                uint mask = (uint)(2 * (tableSpan.Length - 1));\n\n                ref byte inputStart = ref Unsafe.AsRef(in input[0]);\n                ref byte inputEnd = ref Unsafe.Add(ref inputStart, input.Length);\n                ref byte ip = ref inputStart;\n\n                ref byte op = ref output[0];\n                ref ushort table = ref tableSpan[0];\n\n                if (input.Length >= Constants.InputMarginBytes)\n                {\n                    ref byte ipLimit = ref Unsafe.Subtract(ref inputEnd, Constants.InputMarginBytes);\n\n                    for (uint preload = Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, 1));;)\n                    {\n                        // Bytes in [nextEmit, ip) will be emitted as literal bytes.  Or\n                        // [nextEmit, ipEnd) after the main loop.\n                        ref byte nextEmit = ref ip;\n                        ip = ref Unsafe.Add(ref ip, 1);\n                        ulong data = Helpers.UnsafeReadUInt64(ref ip);\n\n                        // The body of this loop calls EmitLiteral once and then EmitCopy one or\n                        // more times.  (The exception is that when we're close to exhausting\n                        // the input we goto emit_remainder.)\n                        //\n                        // In the first iteration of this loop we're just starting, so\n                        // there's nothing to copy, so calling EmitLiteral once is\n                        // necessary.  And we only start a new iteration when the\n                        // current iteration has determined that a call to EmitLiteral will\n                        // precede the next call to EmitCopy (if any).\n                        //\n                        // Step 1: Scan forward in the input looking for a 4-byte-long match.\n                        // If we get close to exhausting the input then goto emit_remainder.\n                        //\n                        // Heuristic match skipping: If 32 bytes are scanned with no matches\n                        // found, start looking only at every other byte. If 32 more bytes are\n                        // scanned (or skipped), look at every third byte, etc.. When a match is\n                        // found, immediately go back to looking at every byte. This is a small\n                        // loss (~5% performance, ~0.1% density) for compressible data due to more\n                        // bookkeeping, but for non-compressible data (such as JPEG) it's a huge\n                        // win since the compressor quickly \"realizes\" the data is incompressible\n                        // and doesn't bother looking for matches everywhere.\n                        //\n                        // The \"skip\" variable keeps track of how many bytes there are since the\n                        // last match; dividing it by 32 (ie. right-shifting by five) gives the\n                        // number of bytes to move ahead for each iteration.\n                        int skip = 32;\n\n                        ref byte candidate = ref Unsafe.NullRef<byte>();\n                        if (Unsafe.ByteOffset(ref ip, ref ipLimit) >= (nint) 16)\n                        {\n                            nint delta = Unsafe.ByteOffset(ref inputStart, ref ip);\n                            for (int j = 0; j < 16; j += 4)\n                            {\n                                // Manually unroll this loop into chunks of 4\n\n                                uint dword = j == 0 ? preload : (uint) data;\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, j)));\n                                ref ushort tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, j)));\n                                tableEntry = (ushort) (delta + j);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (j << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op,  1));\n                                    ip = ref Unsafe.Add(ref ip, j);\n                                    op = ref Unsafe.Add(ref op, j + 2);\n                                    goto emit_match;\n                                }\n\n                                int i1 = j + 1;\n                                dword = (uint)(data >> 8);\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, i1)));\n                                tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, i1)));\n                                tableEntry = (ushort) (delta + i1);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (i1 << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op, 1));\n                                    ip = ref Unsafe.Add(ref ip, i1);\n                                    op = ref Unsafe.Add(ref op, i1 + 2);\n                                    goto emit_match;\n                                }\n\n                                int i2 = j + 2;\n                                dword = (uint)(data >> 16);\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, i2)));\n                                tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, i2)));\n                                tableEntry = (ushort) (delta + i2);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (i2 << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op, 1));\n                                    ip = ref Unsafe.Add(ref ip, i2);\n                                    op = ref Unsafe.Add(ref op, i2 + 2);\n                                    goto emit_match;\n                                }\n\n                                int i3 = j + 3;\n                                dword = (uint)(data >> 24);\n                                Debug.Assert(dword == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, i3)));\n                                tableEntry = ref HashTable.TableEntry(ref table, dword, mask);\n                                candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                                Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                                Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref Unsafe.Add(ref ip, i3)));\n                                tableEntry = (ushort) (delta + i3);\n\n                                if (Helpers.UnsafeReadUInt32(ref candidate) == dword)\n                                {\n                                    op = (byte) (Constants.Literal | (i3 << 2));\n                                    CopyHelpers.UnalignedCopy128(in nextEmit, ref Unsafe.Add(ref op, 1));\n                                    ip = ref Unsafe.Add(ref ip, i3);\n                                    op = ref Unsafe.Add(ref op, i3 + 2);\n                                    goto emit_match;\n                                }\n\n                                data = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref ip, j + 4));\n                            }\n\n                            ip = ref Unsafe.Add(ref ip, 16);\n                            skip += 16;\n                        }\n\n                        while (true)\n                        {\n                            Debug.Assert((uint) data == Helpers.UnsafeReadUInt32(ref ip));\n                            ref ushort tableEntry = ref HashTable.TableEntry(ref table, (uint) data, mask);\n                            int bytesBetweenHashLookups = skip >> 5;\n                            skip += bytesBetweenHashLookups;\n\n                            ref byte nextIp = ref Unsafe.Add(ref ip, bytesBetweenHashLookups);\n                            if (Unsafe.IsAddressGreaterThan(ref nextIp, ref ipLimit))\n                            {\n                                ip = ref nextEmit;\n                                goto emit_remainder;\n                            }\n\n                            candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                            Debug.Assert(!Unsafe.IsAddressLessThan(ref candidate, ref inputStart));\n                            Debug.Assert(Unsafe.IsAddressLessThan(ref candidate, ref ip));\n\n                            tableEntry = (ushort) Unsafe.ByteOffset(ref inputStart, ref ip);\n                            if ((uint) data == Helpers.UnsafeReadUInt32(ref candidate))\n                            {\n                                break;\n                            }\n\n                            data = Helpers.UnsafeReadUInt32(ref nextIp);\n                            ip = ref nextIp;\n                        }\n\n                        // Step 2: A 4-byte match has been found.  We'll later see if more\n                        // than 4 bytes match.  But, prior to the match, input\n                        // bytes [next_emit, ip) are unmatched.  Emit them as \"literal bytes.\"\n                        Debug.Assert(!Unsafe.IsAddressGreaterThan(ref Unsafe.Add(ref nextEmit, 16), ref inputEnd));\n                        op = ref EmitLiteralFast(ref op, ref nextEmit, (uint) Unsafe.ByteOffset(ref nextEmit, ref ip));\n\n                        // Step 3: Call EmitCopy, and then see if another EmitCopy could\n                        // be our next move.  Repeat until we find no match for the\n                        // input immediately after what was consumed by the last EmitCopy call.\n                        //\n                        // If we exit this loop normally then we need to call EmitLiteral next,\n                        // though we don't yet know how big the literal will be.  We handle that\n                        // by proceeding to the next iteration of the main loop.  We also can exit\n                        // this loop via goto if we get close to exhausting the input.\n\n                        emit_match:\n                        do\n                        {\n                            // We have a 4-byte match at ip, and no need to emit any\n                            // \"literal bytes\" prior to ip.\n                            ref byte emitBase = ref ip;\n\n                            var (matchLength, matchLengthLessThan8) =\n                                FindMatchLength(ref Unsafe.Add(ref candidate, 4), ref Unsafe.Add(ref ip, 4), ref inputEnd, ref data);\n\n                            int matched = 4 + matchLength;\n                            ip = ref Unsafe.Add(ref ip, matched);\n\n                            nint offset = Unsafe.ByteOffset(ref candidate, ref emitBase);\n                            if (matchLengthLessThan8)\n                            {\n                                op = ref EmitCopyLenLessThan12(ref op, offset, matched);\n                            }\n                            else\n                            {\n                                op = ref EmitCopyLenGreaterThanOrEqualTo12(ref op, offset, matched);\n                            }\n\n                            if (!Unsafe.IsAddressLessThan(ref ip, ref ipLimit))\n                            {\n                                goto emit_remainder;\n                            }\n\n                            // Expect 5 bytes to match\n                            Debug.Assert((data & 0xfffffffffful) ==\n                                         (Helpers.UnsafeReadUInt64(ref ip) & 0xfffffffffful));\n\n                            // We are now looking for a 4-byte match again.  We read\n                            // table[Hash(ip, mask)] for that.  To improve compression,\n                            // we also update table[Hash(ip - 1, mask)] and table[Hash(ip, mask)].\n                            HashTable.TableEntry(ref table, Helpers.UnsafeReadUInt32(ref Unsafe.Subtract(ref ip, 1)), mask) =\n                                (ushort) (Unsafe.ByteOffset(ref inputStart, ref ip) - 1);\n                            ref ushort tableEntry = ref HashTable.TableEntry(ref table, (uint) data, mask);\n                            candidate = ref Unsafe.Add(ref inputStart, tableEntry);\n                            tableEntry = (ushort) Unsafe.ByteOffset(ref inputStart, ref ip);\n                        } while ((uint) data == Helpers.UnsafeReadUInt32(ref candidate));\n\n                        // Because the least significant 5 bytes matched, we can utilize data\n                        // for the next iteration.\n                        preload = (uint) (data >> 8);\n                    }\n                }\n\n                emit_remainder:\n                // Emit the remaining bytes as a literal\n                if (Unsafe.IsAddressLessThan(ref ip, ref inputEnd))\n                {\n                    op = ref EmitLiteralSlow(ref op, ref ip, (uint) Unsafe.ByteOffset(ref ip, ref inputEnd));\n                }\n\n                return (int) Unsafe.ByteOffset(ref output[0], ref op);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitLiteralFast(ref byte op, ref byte literal, uint length)\n        {\n            Debug.Assert(length > 0);\n\n            if (length <= 16)\n            {\n                uint n = length - 1;\n                op = unchecked((byte)(Constants.Literal | (n << 2)));\n                op = ref Unsafe.Add(ref op, 1);\n\n                CopyHelpers.UnalignedCopy128(in literal, ref op);\n                return ref Unsafe.Add(ref op, length);\n            }\n\n            return ref EmitLiteralSlow(ref op, ref literal, length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitLiteralSlow(ref byte op, ref byte literal, uint length)\n        {\n            uint n = length - 1;\n            if (n < 60)\n            {\n                op = unchecked((byte) (Constants.Literal | (n << 2)));\n                op = ref Unsafe.Add(ref op, 1);\n            }\n            else\n            {\n                int count = (Helpers.Log2Floor(n) >> 3) + 1;\n\n                Debug.Assert(count >= 1);\n                Debug.Assert(count <= 4);\n                op = unchecked((byte)(Constants.Literal | ((59 + count) << 2)));\n                op = ref Unsafe.Add(ref op, 1);\n\n                // Encode in upcoming bytes.\n                // Write 4 bytes, though we may care about only 1 of them. The output buffer\n                // is guaranteed to have at least 3 more spaces left as 'len >= 61' holds\n                // here and there is a std::memcpy() of size 'len' below.\n                Helpers.UnsafeWriteUInt32(ref op, n);\n                op = ref Unsafe.Add(ref op, count);\n            }\n\n            Unsafe.CopyBlockUnaligned(ref op, ref literal, length);\n            return ref Unsafe.Add(ref op,  length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyAtMost64LenLessThan12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length <= 64);\n            Debug.Assert(length >= 4);\n            Debug.Assert(offset < 65536);\n            Debug.Assert(length < 12);\n\n            unchecked\n            {\n                uint u = (uint) ((length << 2) + (offset << 8));\n                uint copy1 = (uint) (Constants.Copy1ByteOffset - (4 << 2) + ((offset >> 3) & 0xe0));\n                uint copy2 = (uint) (Constants.Copy2ByteOffset - (1 << 2));\n\n                // It turns out that offset < 2048 is a difficult to predict branch.\n                // `perf record` shows this is the highest percentage of branch misses in\n                // benchmarks. This code produces branch free code, the data dependency\n                // chain that bottlenecks the throughput is so long that a few extra\n                // instructions are completely free (IPC << 6 because of data deps).\n                u += offset < 2048 ? copy1 : copy2;\n                Helpers.UnsafeWriteUInt32(ref op, u);\n            }\n\n            return ref Unsafe.Add(ref op, offset < 2048 ? 2 : 3);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length <= 64);\n            Debug.Assert(length >= 4);\n            Debug.Assert(offset < 65536);\n            Debug.Assert(length >= 12);\n\n            // Write 4 bytes, though we only care about 3 of them.  The output buffer\n            // is required to have some slack, so the extra byte won't overrun it.\n            var u = unchecked((uint)(Constants.Copy2ByteOffset + ((length - 1) << 2) + (offset << 8)));\n            Helpers.UnsafeWriteUInt32(ref op, u);\n            return ref Unsafe.Add(ref op, 3);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyLenLessThan12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length < 12);\n\n            return ref EmitCopyAtMost64LenLessThan12(ref op, offset, length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ref byte EmitCopyLenGreaterThanOrEqualTo12(ref byte op, long offset, long length)\n        {\n            Debug.Assert(length >= 12);\n\n            // A special case for len <= 64 might help, but so far measurements suggest\n            // it's in the noise.\n\n            // Emit 64 byte copies but make sure to keep at least four bytes reserved.\n            while (length >= 68)\n            {\n                op = ref EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref op, offset, 64);\n                length -= 64;\n            }\n\n            // One or two copies will now finish the job.\n            if (length > 64) {\n                op = ref EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref op, offset, 60);\n                length -= 60;\n            }\n\n            // Emit remainder.\n            if (length < 12) {\n                op = ref EmitCopyAtMost64LenLessThan12(ref op, offset, length);\n            } else {\n                op = ref EmitCopyAtMost64LenGreaterThanOrEqualTo12(ref op, offset, length);\n            }\n            return ref op;\n        }\n\n        /// <summary>\n        /// Find the largest n such that\n        ///\n        ///   s1[0,n-1] == s2[0,n-1]\n        ///   and n &lt;= (s2_limit - s2).\n        ///\n        /// Return (n, n &lt; 8).\n        /// Reads up to and including *s2_limit but not beyond.\n        /// Does not read *(s1 + (s2_limit - s2)) or beyond.\n        /// Requires that s2_limit &gt;= s2.\n        ///\n        /// In addition populate *data with the next 5 bytes from the end of the match.\n        /// This is only done if 8 bytes are available (s2_limit - s2 &gt;= 8). The point is\n        /// that on some arch's this can be done faster in this routine than subsequent\n        /// loading from s2 + n.\n        /// </summary>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength(\n            ref byte s1, ref byte s2, ref byte s2Limit, ref ulong data)\n        {\n            Debug.Assert(!Unsafe.IsAddressLessThan(ref s2Limit, ref s2));\n\n            if (BitConverter.IsLittleEndian && IntPtr.Size == 8)\n            {\n                // Special implementation for 64-bit little endian processors (i.e. Intel/AMD x64)\n                return FindMatchLengthX64(ref s1, ref s2, ref s2Limit, ref data);\n            }\n\n            int matched = 0;\n\n            while (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)4\n                   && Helpers.UnsafeReadUInt32(ref s2) == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched)))\n            {\n                s2 = ref Unsafe.Add(ref s2, 4);\n                matched += 4;\n            }\n\n            if (BitConverter.IsLittleEndian && Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)4)\n            {\n                uint x = Helpers.UnsafeReadUInt32(ref s2) ^ Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched));\n                int matchingBits = Helpers.FindLsbSetNonZero(x);\n                matched += matchingBits >> 3;\n                s2 = ref Unsafe.Add(ref s2, matchingBits >> 3);\n            }\n            else\n            {\n                while (Unsafe.IsAddressLessThan(ref s2, ref s2Limit) && Unsafe.Add(ref s1, matched) == s2)\n                {\n                    s2 = ref Unsafe.Add(ref s2, 1);\n                    ++matched;\n                }\n            }\n\n            if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)8)\n            {\n                data = Helpers.UnsafeReadUInt64(ref s2);\n            }\n\n            return (matched, matched < 8);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64(\n            ref byte s1, ref byte s2, ref byte s2Limit, ref ulong data)\n        {\n            nint matched = 0;\n\n            // This block isn't necessary for correctness; we could just start looping\n            // immediately.  As an optimization though, it is useful.  It creates some not\n            // uncommon code paths that determine, without extra effort, whether the match\n            // length is less than 8.\n            if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)16)\n            {\n                ulong a1 = Helpers.UnsafeReadUInt64(ref s1);\n                ulong a2 = Helpers.UnsafeReadUInt64(ref s2);\n\n                if (a1 != a2)\n                {\n                    ulong xorval = a1 ^ a2;\n                    int shift = Helpers.FindLsbSetNonZero(xorval);\n                    int matchedBytes = shift >> 3;\n\n                    ulong a3 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s2, 4));\n                    a2 = unchecked((uint)xorval) == 0 ? a3 : a2;\n\n                    data = a2 >> (shift & (3 * 8));\n                    return (matchedBytes, true);\n                }\n                else\n                {\n                    matched = 8;\n                    s2 = ref Unsafe.Add(ref s2, 8);\n                }\n            }\n\n            // Find out how long the match is. We loop over the data 64 bits at a\n            // time until we find a 64-bit block that doesn't match; then we find\n            // the first non-matching bit and use that to calculate the total\n            // length of the match.\n            while (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)16)\n            {\n                ulong a1 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s1, matched));\n                ulong a2 = Helpers.UnsafeReadUInt64(ref s2);\n                if (a1 == a2)\n                {\n                    s2 = ref Unsafe.Add(ref s2, 8);\n                    matched += 8;\n                }\n                else\n                {\n                    ulong xorval = a1 ^ a2;\n                    int shift = Helpers.FindLsbSetNonZero(xorval);\n                    int matchedBytes = shift >> 3;\n\n                    ulong a3 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s2, 4));\n                    a2 = unchecked((uint)xorval) == 0 ? a3 : a2;\n\n                    data = a2 >> (shift & (3 * 8));\n                    matched += matchedBytes;\n                    Debug.Assert(matched >= 8);\n                    return ((int)matched, false);\n                }\n            }\n\n            while (Unsafe.IsAddressLessThan(ref s2, ref s2Limit))\n            {\n                if (Unsafe.Add(ref s1, matched) == s2)\n                {\n                    s2 = ref Unsafe.Add(ref s2, 1);\n                    matched++;\n                }\n                else\n                {\n                    if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)8)\n                    {\n                        data = Helpers.UnsafeReadUInt64(ref s2);\n                    }\n\n                    return ((int)matched, matched < 8);\n                }\n            }\n\n            return ((int)matched, matched < 8);\n        }\n\n        #endregion\n    }\n}\n", "using System;\nusing System.Buffers;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.CompilerServices;\n\nnamespace Snappier.Internal\n{\n    internal sealed class SnappyDecompressor : IDisposable\n    {\n        private byte[] _scratch = new byte[Constants.MaximumTagLength];\n        private uint _scratchLength = 0;\n\n        private int _remainingLiteral;\n\n        private int _uncompressedLengthShift;\n        private int _uncompressedLength;\n\n        public bool NeedMoreData => !AllDataDecompressed && UnreadBytes == 0;\n\n        /// <summary>\n        /// Decompress a portion of the input.\n        /// </summary>\n        /// <param name=\"input\">Input to process.</param>\n        /// <returns>Number of bytes processed from the input.</returns>\n        /// <remarks>\n        /// The first call to this method after construction or after a call to <see cref=\"Reset\"/> start at the\n        /// beginning of a new Snappy block, leading with the encoded block size. It may be called multiple times\n        /// as more data becomes available. <see cref=\"AllDataDecompressed\"/> will be true once the entire block\n        /// has been processed.\n        /// </remarks>\n        public void Decompress(ReadOnlySpan<byte> input)\n        {\n            if (!ExpectedLength.HasValue)\n            {\n                var readLength = ReadUncompressedLength(ref input);\n                if (readLength.HasValue)\n                {\n                    ExpectedLength = readLength.GetValueOrDefault();\n                }\n                else\n                {\n                    // Not enough data yet to process the length\n                    return;\n                }\n            }\n\n            // Process any input into the write buffer\n\n            if (input.Length > 0)\n            {\n                if (_remainingLiteral > 0)\n                {\n                    int toWrite = Math.Min(_remainingLiteral, input.Length);\n\n                    Append(input.Slice(0, toWrite));\n                    input = input.Slice(toWrite);\n                    _remainingLiteral -= toWrite;\n                }\n\n                if (!AllDataDecompressed && input.Length > 0)\n                {\n                    DecompressAllTags(input);\n                }\n            }\n        }\n\n        public void Reset()\n        {\n            _scratchLength = 0;\n            _remainingLiteral = 0;\n\n            _uncompressedLength = 0;\n            _uncompressedLengthShift = 0;\n\n            _lookbackPosition = 0;\n            _readPosition = 0;\n            ExpectedLength = null;\n        }\n\n        /// <summary>\n        /// Read the uncompressed length stored at the start of the compressed data.\n        /// </summary>\n        /// <param name=\"input\">Input data, which should begin with the varint encoded uncompressed length.</param>\n        /// <returns>The length of the compressed data, or null if the length is not yet complete.</returns>\n        /// <remarks>\n        /// This variant is used when reading a stream, and will pause if there aren't enough bytes available\n        /// in the input. Subsequent calls with more data will resume processing.\n        /// </remarks>\n        private int? ReadUncompressedLength(ref ReadOnlySpan<byte> input)\n        {\n            int result = _uncompressedLength;\n            int shift = _uncompressedLengthShift;\n            bool foundEnd = false;\n\n            var i = 0;\n            while (input.Length > i)\n            {\n                byte c = input[i];\n                i += 1;\n\n                int val = c & 0x7f;\n                if (Helpers.LeftShiftOverflows((byte) val, shift))\n                {\n                    ThrowHelper.ThrowInvalidOperationException(\"Invalid stream length\");\n                }\n\n                result |= val << shift;\n\n                if (c < 128)\n                {\n                    foundEnd = true;\n                    break;\n                }\n\n                shift += 7;\n\n                if (shift >= 32)\n                {\n                    ThrowHelper.ThrowInvalidOperationException(\"Invalid stream length\");\n                }\n            }\n\n            input = input.Slice(i);\n            _uncompressedLength = result;\n            _uncompressedLengthShift = shift;\n\n            return foundEnd ? (int?)result : null;\n        }\n\n        /// <summary>\n        /// Read the uncompressed length stored at the start of the compressed data.\n        /// </summary>\n        /// <param name=\"input\">Input data, which should begin with the varint encoded uncompressed length.</param>\n        /// <returns>The length of the uncompressed data.</returns>\n        /// <exception cref=\"InvalidDataException\">Invalid stream length</exception>\n        public static int ReadUncompressedLength(ReadOnlySpan<byte> input)\n        {\n            int result = 0;\n            int shift = 0;\n            bool foundEnd = false;\n\n            var i = 0;\n            while (input.Length > 0)\n            {\n                byte c = input[i];\n                i += 1;\n\n                int val = c & 0x7f;\n                if (Helpers.LeftShiftOverflows((byte) val, shift))\n                {\n                    ThrowHelper.ThrowInvalidDataException(\"Invalid stream length\");\n                }\n\n                result |= val << shift;\n\n                if (c < 128)\n                {\n                    foundEnd = true;\n                    break;\n                }\n\n                shift += 7;\n\n                if (shift >= 32)\n                {\n                    ThrowHelper.ThrowInvalidDataException(\"Invalid stream length\");\n                }\n            }\n\n            if (!foundEnd)\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Invalid stream length\");\n            }\n\n            return result;\n        }\n\n        internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n        {\n            // Put Constants.CharTable on the stack to simplify lookups within the loops below.\n            // Slicing with length 256 here allows the JIT compiler to recognize the size is greater than\n            // the size of the byte we're indexing with and optimize out range checks.\n            ReadOnlySpan<ushort> charTable = Constants.CharTable.AsSpan(0, 256);\n\n            unchecked\n            {\n                ref byte input = ref Unsafe.AsRef(in inputSpan[0]);\n                ref byte inputEnd = ref Unsafe.Add(ref input, inputSpan.Length);\n\n                // Track the point in the input before which input is guaranteed to have at least Constants.MaxTagLength bytes left\n                ref byte inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, Math.Min(inputSpan.Length, Constants.MaximumTagLength - 1));\n\n                ref byte buffer = ref _lookbackBuffer.Span[0];\n                ref byte bufferEnd = ref Unsafe.Add(ref buffer, _lookbackBuffer.Length);\n                ref byte op = ref Unsafe.Add(ref buffer, _lookbackPosition);\n\n                // Get a reference to the first byte in the scratch buffer, we'll reuse this so that we don't repeat range checks every time\n                ref byte scratch = ref _scratch[0];\n\n                if (_scratchLength > 0)\n                {\n                    // Have partial tag remaining from a previous decompress run\n                    // Get the combined tag in the scratch buffer, then run through\n                    // special case processing that gets the tag from the scratch buffer\n                    // and any literal data from the _input buffer\n\n                    // This is not a hot path, so it's more efficient to process this as a separate method\n                    // so that the stack size of this method is smaller and JIT can produce better results\n\n                    (uint inputUsed, uint bytesWritten) =\n                        DecompressTagFromScratch(ref input, ref inputEnd, ref op, ref buffer, ref bufferEnd, ref scratch);\n                    if (inputUsed == 0)\n                    {\n                        // There was insufficient data to read an entire tag. Some data was moved to scratch\n                        // but short circuit for another pass when we have more data.\n                        return;\n                    }\n\n                    input = ref Unsafe.Add(ref input, inputUsed);\n                    op = ref Unsafe.Add(ref op, bytesWritten);\n                }\n\n                if (!Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength))\n                {\n                    uint newScratchLength = RefillTag(ref input, ref inputEnd, ref scratch);\n                    if (newScratchLength == uint.MaxValue)\n                    {\n                        goto exit;\n                    }\n\n                    if (newScratchLength > 0)\n                    {\n                        // Data has been moved to the scratch buffer\n                        input = ref scratch;\n                        inputEnd = ref Unsafe.Add(ref input, newScratchLength);\n                        inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n                            Math.Min(newScratchLength, Constants.MaximumTagLength - 1));\n                    }\n                }\n\n                uint preload = Helpers.UnsafeReadUInt32(ref input);\n\n                while (true)\n                {\n                    byte c = (byte) preload;\n                    input = ref Unsafe.Add(ref input, 1);\n\n                    if ((c & 0x03) == Constants.Literal)\n                    {\n                        nint literalLength = unchecked((c >> 2) + 1);\n\n                        if (TryFastAppend(ref op, ref bufferEnd, in input, Unsafe.ByteOffset(ref input, ref inputEnd), literalLength))\n                        {\n                            Debug.Assert(literalLength < 61);\n                            op = ref Unsafe.Add(ref op, literalLength);\n                            input = ref Unsafe.Add(ref input, literalLength);\n                            // NOTE: There is no RefillTag here, as TryFastAppend()\n                            // will not return true unless there's already at least five spare\n                            // bytes in addition to the literal.\n                            preload = Helpers.UnsafeReadUInt32(ref input);\n                            continue;\n                        }\n\n                        if (literalLength >= 61)\n                        {\n                            // Long literal.\n                            nint literalLengthLength = literalLength - 60;\n                            uint literalLengthTemp = Helpers.UnsafeReadUInt32(ref input);\n\n                            literalLength = (nint) Helpers.ExtractLowBytes(literalLengthTemp,\n                                (int) literalLengthLength) + 1;\n\n                            input = ref Unsafe.Add(ref input, literalLengthLength);\n                        }\n\n                        nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd);\n                        if (inputRemaining < literalLength)\n                        {\n                            Append(ref op, ref bufferEnd, in input, inputRemaining);\n                            op = ref Unsafe.Add(ref op, inputRemaining);\n                            _remainingLiteral = (int) (literalLength - inputRemaining);\n                            goto exit;\n                        }\n                        else\n                        {\n                            Append(ref op, ref bufferEnd, in input, literalLength);\n                            op = ref Unsafe.Add(ref op, literalLength);\n                            input = ref Unsafe.Add(ref input, literalLength);\n\n                            if (!Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength))\n                            {\n                                uint newScratchLength = RefillTag(ref input, ref inputEnd, ref scratch);\n                                if (newScratchLength == uint.MaxValue)\n                                {\n                                    goto exit;\n                                }\n\n                                if (newScratchLength > 0)\n                                {\n                                    // Data has been moved to the scratch buffer\n                                    input = ref scratch;\n                                    inputEnd = ref Unsafe.Add(ref input, newScratchLength);\n                                    inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n                                        Math.Min(newScratchLength, Constants.MaximumTagLength - 1));\n\n                                }\n                            }\n\n                            preload = Helpers.UnsafeReadUInt32(ref input);\n                        }\n                    }\n                    else\n                    {\n                        if ((c & 3) == Constants.Copy4ByteOffset)\n                        {\n                            uint copyOffset = Helpers.UnsafeReadUInt32(ref input);\n                            input = ref Unsafe.Add(ref input, 4);\n\n                            nint length = (c >> 2) + 1;\n                            AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n                            op = ref Unsafe.Add(ref op, length);\n                        }\n                        else\n                        {\n                            ushort entry = charTable[c];\n\n                            // We don't use BitConverter to read because we might be reading past the end of the span\n                            // But we know that's safe because we'll be doing it in _scratch with extra data on the end.\n                            // This reduces this step by several operations\n                            preload = Helpers.UnsafeReadUInt32(ref input);\n\n                            uint trailer = Helpers.ExtractLowBytes(preload, c & 3);\n                            nint length = entry & 0xff;\n\n                            // copy_offset/256 is encoded in bits 8..10.  By just fetching\n                            // those bits, we get copy_offset (since the bit-field starts at\n                            // bit 8).\n                            uint copyOffset = (entry & 0x700u) + trailer;\n\n                            AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n                            op = ref Unsafe.Add(ref op, length);\n\n                            input = ref Unsafe.Add(ref input, c & 3);\n\n                            // By using the result of the previous load we reduce the critical\n                            // dependency chain of ip to 4 cycles.\n                            preload >>= (c & 3) * 8;\n                            if (Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength)) continue;\n                        }\n\n                        if (!Unsafe.IsAddressLessThan(ref input, ref inputLimitMinMaxTagLength))\n                        {\n                            uint newScratchLength = RefillTag(ref input, ref inputEnd, ref scratch);\n                            if (newScratchLength == uint.MaxValue)\n                            {\n                                goto exit;\n                            }\n\n                            if (newScratchLength > 0)\n                            {\n                                // Data has been moved to the scratch buffer\n                                input = ref scratch;\n                                inputEnd = ref Unsafe.Add(ref input, newScratchLength);\n                                inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n                                    Math.Min(newScratchLength, Constants.MaximumTagLength - 1));\n                            }\n                        }\n\n                        preload = Helpers.UnsafeReadUInt32(ref input);\n                    }\n                }\n\n                exit: ; // All input data is processed\n                _lookbackPosition = (int)Unsafe.ByteOffset(ref buffer, ref op);\n            }\n        }\n\n        // Returns the amount of the input used, 0 indicates there was insufficient data.\n        // Some of the input may have been used if 0 is returned, but it isn't relevant because\n        // DecompressAllTags will short circuit.\n        private (uint inputUsed, uint bytesWritten) DecompressTagFromScratch(ref byte input, ref byte inputEnd, ref byte op,\n            ref byte buffer, ref byte bufferEnd, ref byte scratch)\n        {\n            // scratch will be the scratch buffer with only the tag if true is returned\n            uint inputUsed = RefillTagFromScratch(ref input, ref inputEnd, ref scratch);\n            if (inputUsed == 0)\n            {\n                return (0, 0);\n            }\n            input = ref Unsafe.Add(ref input, inputUsed);\n\n            // No more scratch for next cycle, we have a full buffer we're about to use\n            _scratchLength = 0;\n\n            byte c = scratch;\n            scratch = ref Unsafe.Add(ref scratch, 1);\n\n            if ((c & 0x03) == Constants.Literal)\n            {\n                uint literalLength = (uint)((c >> 2) + 1);\n                if (literalLength >= 61)\n                {\n                    // Long literal.\n                    uint literalLengthLength = literalLength - 60;\n                    uint literalLengthTemp = Helpers.UnsafeReadUInt32(ref scratch);\n\n                    literalLength = Helpers.ExtractLowBytes(literalLengthTemp,\n                        (int) literalLengthLength) + 1;\n                }\n\n                nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd);\n                if (inputRemaining < literalLength)\n                {\n                    Append(ref op, ref bufferEnd, in input, inputRemaining);\n                    _remainingLiteral = (int) (literalLength - inputRemaining);\n                    _lookbackPosition += (int)Unsafe.ByteOffset(ref buffer, ref op);\n\n                    // Insufficient data in this case as well, trigger a short circuit\n                    return (0, 0);\n                }\n                else\n                {\n                    Append(ref op, ref bufferEnd, in input, (nint)literalLength);\n\n                    return (inputUsed + literalLength, literalLength);\n                }\n            }\n            else if ((c & 3) == Constants.Copy4ByteOffset)\n            {\n                uint copyOffset = Helpers.UnsafeReadUInt32(ref scratch);\n\n                nint length = (c >> 2) + 1;\n\n                AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n\n                return (inputUsed, (uint) length);\n            }\n            else\n            {\n                ushort entry = Constants.CharTable[c];\n                uint data = Helpers.UnsafeReadUInt32(ref scratch);\n\n                uint trailer = Helpers.ExtractLowBytes(data, c & 3);\n                nint length = entry & 0xff;\n\n                // copy_offset/256 is encoded in bits 8..10.  By just fetching\n                // those bits, we get copy_offset (since the bit-field starts at\n                // bit 8).\n                uint copyOffset = (entry & 0x700u) + trailer;\n\n                AppendFromSelf(ref op, ref buffer, ref bufferEnd, copyOffset, length);\n\n                return (inputUsed, (uint) length);\n            }\n        }\n\n        // Returns the amount of the input used, 0 indicates there was insufficient data.\n        // Some of the input may have been used if 0 is returned, but it isn't relevant because\n        // DecompressAllTags will short circuit.\n        private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte scratch)\n        {\n            Debug.Assert(_scratchLength > 0);\n\n            if (!Unsafe.IsAddressLessThan(ref input, ref inputEnd))\n            {\n                return 0;\n            }\n\n            // Read the tag character\n            uint entry = Constants.CharTable[scratch];\n            uint needed = (entry >> 11) + 1; // +1 byte for 'c'\n\n            uint toCopy = Math.Min((uint)Unsafe.ByteOffset(ref input, ref inputEnd), needed - _scratchLength);\n            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref scratch, _scratchLength), ref input, toCopy);\n\n            _scratchLength += toCopy;\n\n            if (_scratchLength < needed)\n            {\n                // Still insufficient\n                return 0;\n            }\n\n            return toCopy;\n        }\n\n        // Returns 0 if there is sufficient data available in the input buffer for the next tag AND enough extra padding to\n        // safely read preload without overrunning the buffer.\n        //\n        // Returns uint.MaxValue if there is insufficient data and the decompression should stop until more data is available.\n        // In this case any dangling unused bytes will be moved to scratch and _scratchLength for the next iteration.\n        //\n        // Returns a small number if we have enough data for this tag but not enough to safely load preload without a buffer\n        // overrun. In this case, further reads should be from scratch with a length up to the returned number. Scratch will\n        // always have some extra bytes on the end so we don't risk buffer overruns.\n        private uint RefillTag(ref byte input, ref byte inputEnd, ref byte scratch)\n        {\n            if (!Unsafe.IsAddressLessThan(ref input, ref inputEnd))\n            {\n                return uint.MaxValue;\n            }\n\n            // Read the tag character\n            uint entry = Constants.CharTable[input];\n            uint needed = (entry >> 11) + 1; // +1 byte for 'c'\n\n            uint inputLength = (uint)Unsafe.ByteOffset(ref input, ref inputEnd);\n            if (inputLength < needed)\n            {\n                // Data is insufficient, copy to scratch\n                Unsafe.CopyBlockUnaligned(ref scratch, ref input, inputLength);\n\n                _scratchLength = inputLength;\n                return uint.MaxValue;\n            }\n\n            if (inputLength < Constants.MaximumTagLength)\n            {\n                // Have enough bytes, but copy to scratch so that we do not\n                // read past end of input\n                Unsafe.CopyBlockUnaligned(ref scratch, ref input, inputLength);\n\n                return inputLength;\n            }\n\n            return 0;\n        }\n\n        #region Loopback Writer\n\n        private byte[]? _lookbackBufferArray;\n        private Memory<byte> _lookbackBuffer;\n        private int _lookbackPosition = 0;\n        private int _readPosition = 0;\n\n        private int? _expectedLength;\n        private int? ExpectedLength\n        {\n            get => _expectedLength;\n            set\n            {\n                _expectedLength = value;\n\n                if (value.HasValue && _lookbackBuffer.Length < value.GetValueOrDefault())\n                {\n                    if (_lookbackBufferArray is not null)\n                    {\n                        ArrayPool<byte>.Shared.Return(_lookbackBufferArray);\n                    }\n\n                    _lookbackBufferArray = ArrayPool<byte>.Shared.Rent(value.GetValueOrDefault());\n                    _lookbackBuffer = _lookbackBufferArray.AsMemory(0, _lookbackBufferArray.Length);\n                }\n            }\n        }\n\n        public int UnreadBytes\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => (int)_lookbackPosition - _readPosition;\n        }\n\n        public bool EndOfFile\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => ExpectedLength.HasValue && _readPosition >= ExpectedLength.GetValueOrDefault();\n        }\n\n        public bool AllDataDecompressed\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => ExpectedLength.HasValue && _lookbackPosition >= ExpectedLength.GetValueOrDefault();\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void Append(ReadOnlySpan<byte> input)\n        {\n            ref readonly byte inputPtr = ref input[0];\n\n            var lookbackSpan = _lookbackBuffer.Span;\n            ref byte op = ref lookbackSpan[_lookbackPosition];\n\n            Append(ref op, ref Unsafe.Add(ref lookbackSpan[0], lookbackSpan.Length), in inputPtr, input.Length);\n            _lookbackPosition += input.Length;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static void Append(ref byte op, ref byte bufferEnd, in byte input, nint length)\n        {\n            if (length > Unsafe.ByteOffset(ref op, ref bufferEnd))\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Data too long\");\n            }\n\n            Unsafe.CopyBlockUnaligned(ref op, ref Unsafe.AsRef(in input), (uint) length);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint available, nint length)\n        {\n            if (length <= 16 && available >= 16 + Constants.MaximumTagLength &&\n                Unsafe.ByteOffset(ref op, ref bufferEnd) >= (nint) 16)\n            {\n                CopyHelpers.UnalignedCopy128(in input, ref op);\n                return true;\n            }\n\n            return false;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, uint copyOffset, nint length)\n        {\n            // ToInt64() ensures that this logic works correctly on x86 (with a slight perf hit on x86, though). This is because\n            // nint is only 32-bit on x86, so casting uint copyOffset to an nint for the comparison can result in a negative number with some\n            // forms of illegal data. This would then bypass the exception and cause unsafe memory access. Performing the comparison\n            // as a long ensures we have enough bits to not lose data. On 64-bit platforms this is effectively a no-op.\n            if (copyOffset == 0 || Unsafe.ByteOffset(ref buffer, ref op).ToInt64() < copyOffset)\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Invalid copy offset\");\n            }\n\n            if (length > Unsafe.ByteOffset(ref op, ref bufferEnd))\n            {\n                ThrowHelper.ThrowInvalidDataException(\"Data too long\");\n            }\n\n            ref byte source = ref Unsafe.Subtract(ref op, copyOffset);\n            CopyHelpers.IncrementalCopy(ref source, ref op,\n                ref Unsafe.Add(ref op, length), ref bufferEnd);\n        }\n\n        public int Read(Span<byte> destination)\n        {\n            var unreadBytes = UnreadBytes;\n            if (unreadBytes == 0)\n            {\n                return 0;\n            }\n\n            if (unreadBytes >= destination.Length)\n            {\n                _lookbackBuffer.Span.Slice(_readPosition, destination.Length).CopyTo(destination);\n                _readPosition += destination.Length;\n                return destination.Length;\n            }\n            else\n            {\n                _lookbackBuffer.Span.Slice(_readPosition, unreadBytes).CopyTo(destination);\n                _readPosition += unreadBytes;\n                return unreadBytes;\n            }\n        }\n\n        /// <summary>\n        /// Extracts the data from from the block, returning a block of memory and resetting the block.\n        /// </summary>\n        /// <returns>An block of memory. Caller is responsible for disposing.</returns>\n        /// <remarks>\n        /// This provides a more efficient way to decompress an entire block in scenarios where the caller\n        /// wants an owned block of memory and isn't going to reuse the SnappyDecompressor. It avoids the\n        /// need to copy a block of memory calling <see cref=\"Read\"/>.\n        /// </remarks>\n        public IMemoryOwner<byte> ExtractData()\n        {\n            byte[]? data = _lookbackBufferArray;\n            if (!ExpectedLength.HasValue)\n            {\n                ThrowHelper.ThrowInvalidOperationException(\"No data present.\");\n            }\n            else if (data is null || ExpectedLength.GetValueOrDefault() == 0)\n            {\n                // Length was 0, so we've allocated nothing\n                return new ByteArrayPoolMemoryOwner();\n            }\n\n            if (!AllDataDecompressed)\n            {\n                ThrowHelper.ThrowInvalidOperationException(\"Block is not fully decompressed.\");\n            }\n\n            // Build the return before we reset and clear ExpectedLength\n            var returnBuffer = new ByteArrayPoolMemoryOwner(data, ExpectedLength.GetValueOrDefault());\n\n            // Clear the buffer so we don't return it\n            _lookbackBufferArray = null;\n            _lookbackBuffer = default;\n\n            Reset();\n\n            return returnBuffer;\n        }\n\n        #endregion\n\n        #region Test Helpers\n\n        /// <summary>\n        /// Load some data into the output buffer, only used for testing.\n        /// </summary>\n        /// <param name=\"toWrite\"></param>\n        internal void WriteToBufferForTest(ReadOnlySpan<byte> toWrite)\n        {\n            Append(toWrite);\n        }\n\n        /// <summary>\n        /// Load a byte array into _scratch, only used for testing.\n        /// </summary>\n        internal void LoadScratchForTest(byte[] newScratch, uint newScratchLength)\n        {\n            ThrowHelper.ThrowIfNull(newScratch);\n            _scratch = newScratch;\n            _scratchLength = newScratchLength;\n        }\n\n        /// <summary>\n        /// Only used for testing.\n        /// </summary>\n        internal void SetExpectedLengthForTest(int expectedLength)\n        {\n            ExpectedLength = expectedLength;\n        }\n\n        #endregion\n\n        public void Dispose()\n        {\n            if (_lookbackBufferArray is not null)\n            {\n                ArrayPool<byte>.Shared.Return(_lookbackBufferArray);\n                _lookbackBufferArray = null;\n                _lookbackBuffer = default;\n            }\n        }\n    }\n}\n"], "filenames": ["Snappier.Benchmarks/FindMatchLength.cs", "Snappier.Tests/Internal/SnappyCompressorTests.cs", "Snappier/Internal/SnappyCompressor.cs", "Snappier/Internal/SnappyDecompressor.cs"], "buggy_code_start_loc": [67, 95, 128, 189], "buggy_code_end_loc": [68, 96, 628, 635], "fixing_code_start_loc": [67, 95, 128, 189], "fixing_code_end_loc": [68, 96, 622, 629], "type": "CWE-119", "message": "Snappier is a high performance C# implementation of the Snappy compression algorithm. This is a buffer overrun vulnerability that can affect any user of Snappier 1.1.0. In this release, much of the code was rewritten to use byte references rather than pointers to pinned buffers. This change generally improves performance and reduces workload on the garbage collector. However, when the garbage collector performs compaction and rearranges memory, it must update any byte references on the stack to refer to the updated location. The .NET garbage collector can only update these byte references if they still point within the buffer or to a point one byte past the end of the buffer. If they point outside this area, the buffer itself may be moved while the byte reference stays the same. There are several places in 1.1.0 where byte references very briefly point outside the valid areas of buffers. These are at locations in the code being used for buffer range checks. While the invalid references are never dereferenced directly, if a GC compaction were to occur during the brief window when they are on the stack then it could invalidate the buffer range check and allow other operations to overrun the buffer. This should be very difficult for an attacker to trigger intentionally. It would require a repetitive bulk attack with the hope that a GC compaction would occur at precisely the right moment during one of the requests. However, one of the range checks with this problem is a check based on input data in the decompression buffer, meaning malformed input data could be used to increase the chance of success. Note that any resulting buffer overrun is likely to cause access to protected memory, which will then cause an exception and the process to be terminated. Therefore, the most likely result of an attack is a denial of service. This issue has been patched in release 1.1.1. Users are advised to upgrade. Users unable to upgrade may pin buffers to a fixed location before using them for compression or decompression to mitigate some, but not all, of these cases. At least one temporary decompression buffer is internal to the library and never pinned.", "other": {"cve": {"id": "CVE-2023-28638", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-27T21:15:12.603", "lastModified": "2023-04-03T13:19:07.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Snappier is a high performance C# implementation of the Snappy compression algorithm. This is a buffer overrun vulnerability that can affect any user of Snappier 1.1.0. In this release, much of the code was rewritten to use byte references rather than pointers to pinned buffers. This change generally improves performance and reduces workload on the garbage collector. However, when the garbage collector performs compaction and rearranges memory, it must update any byte references on the stack to refer to the updated location. The .NET garbage collector can only update these byte references if they still point within the buffer or to a point one byte past the end of the buffer. If they point outside this area, the buffer itself may be moved while the byte reference stays the same. There are several places in 1.1.0 where byte references very briefly point outside the valid areas of buffers. These are at locations in the code being used for buffer range checks. While the invalid references are never dereferenced directly, if a GC compaction were to occur during the brief window when they are on the stack then it could invalidate the buffer range check and allow other operations to overrun the buffer. This should be very difficult for an attacker to trigger intentionally. It would require a repetitive bulk attack with the hope that a GC compaction would occur at precisely the right moment during one of the requests. However, one of the range checks with this problem is a check based on input data in the decompression buffer, meaning malformed input data could be used to increase the chance of success. Note that any resulting buffer overrun is likely to cause access to protected memory, which will then cause an exception and the process to be terminated. Therefore, the most likely result of an attack is a denial of service. This issue has been patched in release 1.1.1. Users are advised to upgrade. Users unable to upgrade may pin buffers to a fixed location before using them for compression or decompression to mitigate some, but not all, of these cases. At least one temporary decompression buffer is internal to the library and never pinned."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snappier_project:snappier:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "99256ABC-36CA-44D3-A2B1-CAB26F1B2EC9"}]}]}], "references": [{"url": "https://github.com/brantburnett/Snappier/commit/d7ac5267b5b18439e6d108f8138edf48c436b32f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/brantburnett/Snappier/security/advisories/GHSA-838x-pcvx-6p5w", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/brantburnett/Snappier/commit/d7ac5267b5b18439e6d108f8138edf48c436b32f"}}