{"buggy_code": ["require 'erb'\nrequire 'active_support/core_ext/kernel/singleton_class'\n\nclass ERB\n  module Util\n    HTML_ESCAPE = { '&' => '&amp;',  '>' => '&gt;',   '<' => '&lt;', '\"' => '&quot;' }\n    JSON_ESCAPE = { '&' => '\\u0026', '>' => '\\u003E', '<' => '\\u003C' }\n\n    # A utility method for escaping HTML tag characters.\n    # This method is also aliased as <tt>h</tt>.\n    #\n    # In your ERB templates, use this method to escape any unsafe content. For example:\n    #   <%=h @person.name %>\n    #\n    # ==== Example:\n    #   puts html_escape(\"is a > 0 & a < 10?\")\n    #   # => is a &gt; 0 &amp; a &lt; 10?\n    def html_escape(s)\n      s = s.to_s\n      if s.html_safe?\n        s\n      else\n        s.gsub(/[&\"><]/) { |special| HTML_ESCAPE[special] }.html_safe\n      end\n    end\n\n    # Aliasing twice issues a warning \"discarding old...\". Remove first to avoid it.\n    remove_method(:h)\n    alias h html_escape\n\n    module_function :h\n\n    singleton_class.send(:remove_method, :html_escape)\n    module_function :html_escape\n\n    # A utility method for escaping HTML entities in JSON strings\n    # using \\uXXXX JavaScript escape sequences for string literals:\n    #\n    #   json_escape(\"is a > 0 & a < 10?\")\n    #   # => is a \\u003E 0 \\u0026 a \\u003C 10?\n    #\n    # Note that after this operation is performed the output is not\n    # valid JSON. In particular double quotes are removed:\n    #\n    #   json_escape('{\"name\":\"john\",\"created_at\":\"2010-04-28T01:39:31Z\",\"id\":1}')\n    #   # => {name:john,created_at:2010-04-28T01:39:31Z,id:1}\n    #\n    # This method is also aliased as +j+, and available as a helper\n    # in Rails templates:\n    #\n    #   <%=j @person.to_json %>\n    #\n    def json_escape(s)\n      result = s.to_s.gsub(/[&\"><]/) { |special| JSON_ESCAPE[special] }\n      s.html_safe? ? result.html_safe : result\n    end\n\n    alias j json_escape\n    module_function :j\n    module_function :json_escape\n  end\nend\n\nclass Object\n  def html_safe?\n    false\n  end\nend\n\nclass Numeric\n  def html_safe?\n    true\n  end\nend\n\nmodule ActiveSupport #:nodoc:\n  class SafeBuffer < String\n    UNSAFE_STRING_METHODS = [\"capitalize\", \"chomp\", \"chop\", \"delete\", \"downcase\", \"gsub\", \"lstrip\", \"next\", \"reverse\", \"rstrip\", \"slice\", \"squeeze\", \"strip\", \"sub\", \"succ\", \"swapcase\", \"tr\", \"tr_s\", \"upcase\"].freeze\n\n    alias_method :original_concat, :concat\n    private :original_concat\n\n    class SafeConcatError < StandardError\n      def initialize\n        super \"Could not concatenate to the buffer because it is not html safe.\"\n      end\n    end\n\n    def[](*args)\n      new_safe_buffer = super\n      new_safe_buffer.instance_eval { @dirty = false }\n      new_safe_buffer\n    end\n\n    def safe_concat(value)\n      raise SafeConcatError if dirty?\n      original_concat(value)\n    end\n\n    def initialize(*)\n      @dirty = false\n      super\n    end\n\n    def initialize_copy(other)\n      super\n      @dirty = other.dirty?\n    end\n\n    def concat(value)\n      if dirty? || value.html_safe?\n        super(value)\n      else\n        super(ERB::Util.h(value))\n      end\n    end\n    alias << concat\n\n    def +(other)\n      dup.concat(other)\n    end\n\n    def html_safe?\n      !dirty?\n    end\n\n    def to_s\n      self\n    end\n\n    def to_param\n      to_str\n    end\n\n    def encode_with(coder)\n      coder.represent_scalar nil, to_str\n    end\n\n    def to_yaml(*args)\n      return super() if defined?(YAML::ENGINE) && !YAML::ENGINE.syck?\n      to_str.to_yaml(*args)\n    end\n\n    UNSAFE_STRING_METHODS.each do |unsafe_method|\n      class_eval <<-EOT, __FILE__, __LINE__\n        def #{unsafe_method}(*args, &block)       # def gsub(*args, &block)\n          to_str.#{unsafe_method}(*args, &block)  #   to_str.gsub(*args, &block)\n        end                                       # end\n\n        def #{unsafe_method}!(*args)              # def gsub!(*args)\n          @dirty = true                           #   @dirty = true\n          super                                   #   super\n        end                                       # end\n      EOT\n    end\n\n    protected\n\n    def dirty?\n      @dirty\n    end\n  end\nend\n\nclass String\n  def html_safe\n    ActiveSupport::SafeBuffer.new(self)\n  end\nend\n", "# encoding: utf-8\nrequire 'date'\nrequire 'abstract_unit'\nrequire 'inflector_test_cases'\n\nrequire 'active_support/inflector'\nrequire 'active_support/core_ext/string'\nrequire 'active_support/time'\nrequire 'active_support/core_ext/string/strip'\n\nclass StringInflectionsTest < Test::Unit::TestCase\n  include InflectorTestCases\n\n  def test_strip_heredoc_on_an_empty_string\n    assert_equal '', ''.strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_string_with_no_lines\n    assert_equal 'x', 'x'.strip_heredoc\n    assert_equal 'x', '    x'.strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_heredoc_with_no_margin\n    assert_equal \"foo\\nbar\", \"foo\\nbar\".strip_heredoc\n    assert_equal \"foo\\n  bar\", \"foo\\n  bar\".strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_regular_indented_heredoc\n    assert_equal \"foo\\n  bar\\nbaz\\n\", <<-EOS.strip_heredoc\n      foo\n        bar\n      baz\n    EOS\n  end\n\n  def test_strip_heredoc_on_a_regular_indented_heredoc_with_blank_lines\n    assert_equal \"foo\\n  bar\\n\\nbaz\\n\", <<-EOS.strip_heredoc\n      foo\n        bar\n\n      baz\n    EOS\n  end\n\n  def test_pluralize\n    SingularToPlural.each do |singular, plural|\n      assert_equal(plural, singular.pluralize)\n    end\n\n    assert_equal(\"plurals\", \"plurals\".pluralize)\n  end\n\n  def test_singularize\n    SingularToPlural.each do |singular, plural|\n      assert_equal(singular, plural.singularize)\n    end\n  end\n\n  def test_titleize\n    MixtureToTitleCase.each do |before, titleized|\n      assert_equal(titleized, before.titleize)\n    end\n  end\n\n  def test_camelize\n    CamelToUnderscore.each do |camel, underscore|\n      assert_equal(camel, underscore.camelize)\n    end\n  end\n\n  def test_camelize_lower\n    assert_equal('capital', 'Capital'.camelize(:lower))\n  end\n\n  def test_underscore\n    CamelToUnderscore.each do |camel, underscore|\n      assert_equal(underscore, camel.underscore)\n    end\n\n    assert_equal \"html_tidy\", \"HTMLTidy\".underscore\n    assert_equal \"html_tidy_generator\", \"HTMLTidyGenerator\".underscore\n  end\n\n  def test_underscore_to_lower_camel\n    UnderscoreToLowerCamel.each do |underscored, lower_camel|\n      assert_equal(lower_camel, underscored.camelize(:lower))\n    end\n  end\n\n  def test_demodulize\n    assert_equal \"Account\", \"MyApplication::Billing::Account\".demodulize\n  end\n\n  def test_foreign_key\n    ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|\n      assert_equal(foreign_key, klass.foreign_key)\n    end\n\n    ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|\n      assert_equal(foreign_key, klass.foreign_key(false))\n    end\n  end\n\n  def test_tableize\n    ClassNameToTableName.each do |class_name, table_name|\n      assert_equal(table_name, class_name.tableize)\n    end\n  end\n\n  def test_classify\n    ClassNameToTableName.each do |class_name, table_name|\n      assert_equal(class_name, table_name.classify)\n    end\n  end\n\n  def test_string_parameterized_normal\n    StringToParameterized.each do |normal, slugged|\n      assert_equal(normal.parameterize, slugged)\n    end\n  end\n\n  def test_string_parameterized_no_separator\n    StringToParameterizeWithNoSeparator.each do |normal, slugged|\n      assert_equal(normal.parameterize(''), slugged)\n    end\n  end\n\n  def test_string_parameterized_underscore\n    StringToParameterizeWithUnderscore.each do |normal, slugged|\n      assert_equal(normal.parameterize('_'), slugged)\n    end\n  end\n\n  def test_humanize\n    UnderscoreToHuman.each do |underscore, human|\n      assert_equal(human, underscore.humanize)\n    end\n  end\n\n  def test_ord\n    assert_equal 97, 'a'.ord\n    assert_equal 97, 'abc'.ord\n  end\n\n  if RUBY_VERSION < '1.9'\n    def test_getbyte\n      assert_equal 97, 'a'.getbyte(0)\n      assert_equal 99, 'abc'.getbyte(2)\n      assert_nil   'abc'.getbyte(3)\n    end\n  end\n\n  def test_string_to_time\n    assert_equal Time.utc(2005, 2, 27, 23, 50), \"2005-02-27 23:50\".to_time\n    assert_equal Time.local(2005, 2, 27, 23, 50), \"2005-02-27 23:50\".to_time(:local)\n    assert_equal Time.utc(2005, 2, 27, 23, 50, 19, 275038), \"2005-02-27T23:50:19.275038\".to_time\n    assert_equal Time.local(2005, 2, 27, 23, 50, 19, 275038), \"2005-02-27T23:50:19.275038\".to_time(:local)\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_time\n    assert_equal Time.local_time(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_time(:local)\n    assert_equal Time.utc(2011, 2, 27, 23, 50), \"2011-02-27 22:50 -0100\".to_time\n    assert_nil \"\".to_time\n  end\n\n  def test_string_to_datetime\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_datetime\n    assert_equal 0, \"2039-02-27 23:50\".to_datetime.offset # use UTC offset\n    assert_equal ::Date::ITALY, \"2039-02-27 23:50\".to_datetime.start # use Ruby's default start value\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50, 19 + Rational(275038, 1000000), \"-04:00\"), \"2039-02-27T23:50:19.275038-04:00\".to_datetime\n    assert_nil \"\".to_datetime\n  end\n\n  def test_string_to_date\n    assert_equal Date.new(2005, 2, 27), \"2005-02-27\".to_date\n    assert_nil \"\".to_date\n  end\n\n  def test_access\n    s = \"hello\"\n    assert_equal \"h\", s.at(0)\n\n    assert_equal \"llo\", s.from(2)\n    assert_equal \"hel\", s.to(2)\n\n    assert_equal \"h\", s.first\n    assert_equal \"he\", s.first(2)\n    assert_equal \"\", s.first(0)\n\n    assert_equal \"o\", s.last\n    assert_equal \"llo\", s.last(3)\n    assert_equal \"hello\", s.last(10)\n    assert_equal \"\", s.last(0)\n\n    assert_equal 'x', 'x'.first\n    assert_equal 'x', 'x'.first(4)\n\n    assert_equal 'x', 'x'.last\n    assert_equal 'x', 'x'.last(4)\n  end\n\n  def test_access_returns_a_real_string\n    hash = {}\n    hash[\"h\"] = true\n    hash[\"hello123\".at(0)] = true\n    assert_equal %w(h), hash.keys\n\n    hash = {}\n    hash[\"llo\"] = true\n    hash[\"hello\".from(2)] = true\n    assert_equal %w(llo), hash.keys\n\n    hash = {}\n    hash[\"hel\"] = true\n    hash[\"hello\".to(2)] = true\n    assert_equal %w(hel), hash.keys\n\n    hash = {}\n    hash[\"hello\"] = true\n    hash[\"123hello\".last(5)] = true\n    assert_equal %w(hello), hash.keys\n\n    hash = {}\n    hash[\"hello\"] = true\n    hash[\"hello123\".first(5)] = true\n    assert_equal %w(hello), hash.keys\n  end\n\n  def test_starts_ends_with_alias\n    s = \"hello\"\n    assert s.starts_with?('h')\n    assert s.starts_with?('hel')\n    assert !s.starts_with?('el')\n\n    assert s.ends_with?('o')\n    assert s.ends_with?('lo')\n    assert !s.ends_with?('el')\n  end\n\n  def test_string_squish\n    original = %{ A string with tabs(\\t\\t), newlines(\\n\\n), and\n                  many spaces(  ). }\n\n    expected = \"A string with tabs( ), newlines( ), and many spaces( ).\"\n\n    # Make sure squish returns what we expect:\n    assert_equal original.squish,  expected\n    # But doesn't modify the original string:\n    assert_not_equal original, expected\n\n    # Make sure squish! returns what we expect:\n    assert_equal original.squish!, expected\n    # And changes the original string:\n    assert_equal original, expected\n  end\n\n  def test_string_inquiry\n    assert \"production\".inquiry.production?\n    assert !\"production\".inquiry.development?\n  end\n\n  def test_truncate\n    assert_equal \"Hello World!\", \"Hello World!\".truncate(12)\n    assert_equal \"Hello Wor...\", \"Hello World!!\".truncate(12)\n  end\n\n  def test_truncate_with_omission_and_seperator\n    assert_equal \"Hello[...]\", \"Hello World!\".truncate(10, :omission => \"[...]\")\n    assert_equal \"Hello[...]\", \"Hello Big World!\".truncate(13, :omission => \"[...]\", :separator => ' ')\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(14, :omission => \"[...]\", :separator => ' ')\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(15, :omission => \"[...]\", :separator => ' ')\n  end\n\n  if RUBY_VERSION < '1.9.0'\n    def test_truncate_multibyte\n      with_kcode 'none' do\n        assert_equal \"\\354\\225\\210\\353\\205\\225\\355...\", \"\\354\\225\\210\\353\\205\\225\\355\\225\\230\\354\\204\\270\\354\\232\\224\".truncate(10)\n      end\n      with_kcode 'u' do\n        assert_equal \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 ...\",\n          \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 \\354\\225\\204\\353\\235\\274\\353\\246\\254\\354\\230\\244\".truncate(10)\n      end\n    end\n  else\n    def test_truncate_multibyte\n      assert_equal \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 ...\".force_encoding('UTF-8'),\n        \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 \\354\\225\\204\\353\\235\\274\\353\\246\\254\\354\\230\\244\".force_encoding('UTF-8').truncate(10)\n    end\n  end\nend\n\nclass StringBehaviourTest < Test::Unit::TestCase\n  def test_acts_like_string\n    assert 'Bambi'.acts_like_string?\n  end\nend\n\nclass CoreExtStringMultibyteTest < ActiveSupport::TestCase\n  UNICODE_STRING = '\u3053\u306b\u3061\u308f'\n  ASCII_STRING = 'ohayo'\n  BYTE_STRING = \"\\270\\236\\010\\210\\245\"\n\n  def test_core_ext_adds_mb_chars\n    assert_respond_to UNICODE_STRING, :mb_chars\n  end\n\n  def test_string_should_recognize_utf8_strings\n    assert UNICODE_STRING.is_utf8?\n    assert ASCII_STRING.is_utf8?\n    assert !BYTE_STRING.is_utf8?\n  end\n\n  if RUBY_VERSION < '1.9'\n    def test_mb_chars_returns_self_when_kcode_not_set\n      with_kcode('none') do\n        assert_kind_of String, UNICODE_STRING.mb_chars\n      end\n    end\n\n    def test_mb_chars_returns_an_instance_of_the_chars_proxy_when_kcode_utf8\n      with_kcode('UTF8') do\n        assert_kind_of ActiveSupport::Multibyte.proxy_class, UNICODE_STRING.mb_chars\n      end\n    end\n  else\n    def test_mb_chars_returns_instance_of_proxy_class\n      assert_kind_of ActiveSupport::Multibyte.proxy_class, UNICODE_STRING.mb_chars\n    end\n  end\nend\n\nclass OutputSafetyTest < ActiveSupport::TestCase\n  def setup\n    @string = \"hello\"\n    @object = Class.new(Object) do\n      def to_s\n        \"other\"\n      end\n    end.new\n  end\n\n  test \"A string is unsafe by default\" do\n    assert !@string.html_safe?\n  end\n\n  test \"A string can be marked safe\" do\n    string = @string.html_safe\n    assert string.html_safe?\n  end\n\n  test \"Marking a string safe returns the string\" do\n    assert_equal @string, @string.html_safe\n  end\n\n  test \"A fixnum is safe by default\" do\n    assert 5.html_safe?\n  end\n  \n  test \"a float is safe by default\" do\n    assert 5.7.html_safe?\n  end\n\n  test \"An object is unsafe by default\" do\n    assert !@object.html_safe?\n  end\n\n  test \"Adding an object to a safe string returns a safe string\" do\n    string = @string.html_safe\n    string << @object\n\n    assert_equal \"helloother\", string\n    assert string.html_safe?\n  end\n\n  test \"Adding a safe string to another safe string returns a safe string\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n    @combination = @other_string + string\n\n    assert_equal \"otherhello\", @combination\n    assert @combination.html_safe?\n  end\n\n  test \"Adding an unsafe string to a safe string escapes it and returns a safe string\" do\n    @other_string = \"other\".html_safe\n    @combination = @other_string + \"<foo>\"\n    @other_combination = @string + \"<foo>\"\n\n    assert_equal \"other&lt;foo&gt;\", @combination\n    assert_equal \"hello<foo>\", @other_combination\n\n    assert @combination.html_safe?\n    assert !@other_combination.html_safe?\n  end\n\n  test \"Concatting safe onto unsafe yields unsafe\" do\n    @other_string = \"other\"\n\n    string = @string.html_safe\n    @other_string.concat(string)\n    assert !@other_string.html_safe?\n  end\n\n  test \"Concatting unsafe onto safe yields escaped safe\" do\n    @other_string = \"other\".html_safe\n    string = @other_string.concat(\"<foo>\")\n    assert_equal \"other&lt;foo&gt;\", string\n    assert string.html_safe?\n  end\n\n  test \"Concatting safe onto safe yields safe\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n\n    @other_string.concat(string)\n    assert @other_string.html_safe?\n  end\n\n  test \"Concatting safe onto unsafe with << yields unsafe\" do\n    @other_string = \"other\"\n    string = @string.html_safe\n\n    @other_string << string\n    assert !@other_string.html_safe?\n  end\n\n  test \"Concatting unsafe onto safe with << yields escaped safe\" do\n    @other_string = \"other\".html_safe\n    string = @other_string << \"<foo>\"\n    assert_equal \"other&lt;foo&gt;\", string\n    assert string.html_safe?\n  end\n\n  test \"Concatting safe onto safe with << yields safe\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n\n    @other_string << string\n    assert @other_string.html_safe?\n  end\n\n  test \"Concatting a fixnum to safe always yields safe\" do\n    string = @string.html_safe\n    string = string.concat(13)\n    assert_equal \"hello\".concat(13), string\n    assert string.html_safe?\n  end\n\n  test 'emits normal string yaml' do\n    assert_equal 'foo'.to_yaml, 'foo'.html_safe.to_yaml(:foo => 1)\n  end\n\n  test 'knows whether it is encoding aware' do\n    if RUBY_VERSION >= \"1.9\"\n      assert 'ruby'.encoding_aware?\n    else\n      assert !'ruby'.encoding_aware?\n    end\n  end\n\n  test \"call to_param returns a normal string\" do\n    string = @string.html_safe\n    assert string.html_safe?\n    assert !string.to_param.html_safe?\n  end\nend\n\nclass StringExcludeTest < ActiveSupport::TestCase\n  test 'inverse of #include' do\n    assert_equal false, 'foo'.exclude?('o')\n    assert_equal true, 'foo'.exclude?('p')\n  end\nend\n"], "fixing_code": ["require 'erb'\nrequire 'active_support/core_ext/kernel/singleton_class'\n\nclass ERB\n  module Util\n    HTML_ESCAPE = { '&' => '&amp;',  '>' => '&gt;',   '<' => '&lt;', '\"' => '&quot;' }\n    JSON_ESCAPE = { '&' => '\\u0026', '>' => '\\u003E', '<' => '\\u003C' }\n\n    # A utility method for escaping HTML tag characters.\n    # This method is also aliased as <tt>h</tt>.\n    #\n    # In your ERB templates, use this method to escape any unsafe content. For example:\n    #   <%=h @person.name %>\n    #\n    # ==== Example:\n    #   puts html_escape(\"is a > 0 & a < 10?\")\n    #   # => is a &gt; 0 &amp; a &lt; 10?\n    def html_escape(s)\n      s = s.to_s\n      if s.html_safe?\n        s\n      else\n        s.to_s.gsub(/&/, \"&amp;\").gsub(/\\\"/, \"&quot;\").gsub(/>/, \"&gt;\").gsub(/</, \"&lt;\").html_safe\n      end\n    end\n\n    # Aliasing twice issues a warning \"discarding old...\". Remove first to avoid it.\n    remove_method(:h)\n    alias h html_escape\n\n    module_function :h\n\n    singleton_class.send(:remove_method, :html_escape)\n    module_function :html_escape\n\n    # A utility method for escaping HTML entities in JSON strings\n    # using \\uXXXX JavaScript escape sequences for string literals:\n    #\n    #   json_escape(\"is a > 0 & a < 10?\")\n    #   # => is a \\u003E 0 \\u0026 a \\u003C 10?\n    #\n    # Note that after this operation is performed the output is not\n    # valid JSON. In particular double quotes are removed:\n    #\n    #   json_escape('{\"name\":\"john\",\"created_at\":\"2010-04-28T01:39:31Z\",\"id\":1}')\n    #   # => {name:john,created_at:2010-04-28T01:39:31Z,id:1}\n    #\n    # This method is also aliased as +j+, and available as a helper\n    # in Rails templates:\n    #\n    #   <%=j @person.to_json %>\n    #\n    def json_escape(s)\n      result = s.to_s.gsub(/[&\"><]/) { |special| JSON_ESCAPE[special] }\n      s.html_safe? ? result.html_safe : result\n    end\n\n    alias j json_escape\n    module_function :j\n    module_function :json_escape\n  end\nend\n\nclass Object\n  def html_safe?\n    false\n  end\nend\n\nclass Numeric\n  def html_safe?\n    true\n  end\nend\n\nmodule ActiveSupport #:nodoc:\n  class SafeBuffer < String\n    UNSAFE_STRING_METHODS = [\"capitalize\", \"chomp\", \"chop\", \"delete\", \"downcase\", \"gsub\", \"lstrip\", \"next\", \"reverse\", \"rstrip\", \"slice\", \"squeeze\", \"strip\", \"sub\", \"succ\", \"swapcase\", \"tr\", \"tr_s\", \"upcase\"].freeze\n\n    alias_method :original_concat, :concat\n    private :original_concat\n\n    class SafeConcatError < StandardError\n      def initialize\n        super \"Could not concatenate to the buffer because it is not html safe.\"\n      end\n    end\n\n    def[](*args)\n      new_safe_buffer = super\n      new_safe_buffer.instance_eval { @dirty = false }\n      new_safe_buffer\n    end\n\n    def safe_concat(value)\n      raise SafeConcatError if dirty?\n      original_concat(value)\n    end\n\n    def initialize(*)\n      @dirty = false\n      super\n    end\n\n    def initialize_copy(other)\n      super\n      @dirty = other.dirty?\n    end\n\n    def concat(value)\n      if dirty? || value.html_safe?\n        super(value)\n      else\n        super(ERB::Util.h(value))\n      end\n    end\n    alias << concat\n\n    def +(other)\n      dup.concat(other)\n    end\n\n    def html_safe?\n      !dirty?\n    end\n\n    def to_s\n      self\n    end\n\n    def to_param\n      to_str\n    end\n\n    def encode_with(coder)\n      coder.represent_scalar nil, to_str\n    end\n\n    def to_yaml(*args)\n      return super() if defined?(YAML::ENGINE) && !YAML::ENGINE.syck?\n      to_str.to_yaml(*args)\n    end\n\n    UNSAFE_STRING_METHODS.each do |unsafe_method|\n      class_eval <<-EOT, __FILE__, __LINE__\n        def #{unsafe_method}(*args, &block)       # def gsub(*args, &block)\n          to_str.#{unsafe_method}(*args, &block)  #   to_str.gsub(*args, &block)\n        end                                       # end\n\n        def #{unsafe_method}!(*args)              # def gsub!(*args)\n          @dirty = true                           #   @dirty = true\n          super                                   #   super\n        end                                       # end\n      EOT\n    end\n\n    protected\n\n    def dirty?\n      @dirty\n    end\n  end\nend\n\nclass String\n  def html_safe\n    ActiveSupport::SafeBuffer.new(self)\n  end\nend\n", "# encoding: utf-8\nrequire 'date'\nrequire 'abstract_unit'\nrequire 'inflector_test_cases'\n\nrequire 'active_support/inflector'\nrequire 'active_support/core_ext/string'\nrequire 'active_support/time'\nrequire 'active_support/core_ext/string/strip'\nrequire 'active_support/core_ext/string/output_safety'\n\nclass StringInflectionsTest < Test::Unit::TestCase\n  include InflectorTestCases\n\n  def test_erb_escape\n    string = [192, 60].pack('CC')\n    expected = 192.chr + \"&lt;\"\n    assert_equal expected, ERB::Util.html_escape(string)\n  end\n\n  def test_strip_heredoc_on_an_empty_string\n    assert_equal '', ''.strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_string_with_no_lines\n    assert_equal 'x', 'x'.strip_heredoc\n    assert_equal 'x', '    x'.strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_heredoc_with_no_margin\n    assert_equal \"foo\\nbar\", \"foo\\nbar\".strip_heredoc\n    assert_equal \"foo\\n  bar\", \"foo\\n  bar\".strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_regular_indented_heredoc\n    assert_equal \"foo\\n  bar\\nbaz\\n\", <<-EOS.strip_heredoc\n      foo\n        bar\n      baz\n    EOS\n  end\n\n  def test_strip_heredoc_on_a_regular_indented_heredoc_with_blank_lines\n    assert_equal \"foo\\n  bar\\n\\nbaz\\n\", <<-EOS.strip_heredoc\n      foo\n        bar\n\n      baz\n    EOS\n  end\n\n  def test_pluralize\n    SingularToPlural.each do |singular, plural|\n      assert_equal(plural, singular.pluralize)\n    end\n\n    assert_equal(\"plurals\", \"plurals\".pluralize)\n  end\n\n  def test_singularize\n    SingularToPlural.each do |singular, plural|\n      assert_equal(singular, plural.singularize)\n    end\n  end\n\n  def test_titleize\n    MixtureToTitleCase.each do |before, titleized|\n      assert_equal(titleized, before.titleize)\n    end\n  end\n\n  def test_camelize\n    CamelToUnderscore.each do |camel, underscore|\n      assert_equal(camel, underscore.camelize)\n    end\n  end\n\n  def test_camelize_lower\n    assert_equal('capital', 'Capital'.camelize(:lower))\n  end\n\n  def test_underscore\n    CamelToUnderscore.each do |camel, underscore|\n      assert_equal(underscore, camel.underscore)\n    end\n\n    assert_equal \"html_tidy\", \"HTMLTidy\".underscore\n    assert_equal \"html_tidy_generator\", \"HTMLTidyGenerator\".underscore\n  end\n\n  def test_underscore_to_lower_camel\n    UnderscoreToLowerCamel.each do |underscored, lower_camel|\n      assert_equal(lower_camel, underscored.camelize(:lower))\n    end\n  end\n\n  def test_demodulize\n    assert_equal \"Account\", \"MyApplication::Billing::Account\".demodulize\n  end\n\n  def test_foreign_key\n    ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|\n      assert_equal(foreign_key, klass.foreign_key)\n    end\n\n    ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|\n      assert_equal(foreign_key, klass.foreign_key(false))\n    end\n  end\n\n  def test_tableize\n    ClassNameToTableName.each do |class_name, table_name|\n      assert_equal(table_name, class_name.tableize)\n    end\n  end\n\n  def test_classify\n    ClassNameToTableName.each do |class_name, table_name|\n      assert_equal(class_name, table_name.classify)\n    end\n  end\n\n  def test_string_parameterized_normal\n    StringToParameterized.each do |normal, slugged|\n      assert_equal(normal.parameterize, slugged)\n    end\n  end\n\n  def test_string_parameterized_no_separator\n    StringToParameterizeWithNoSeparator.each do |normal, slugged|\n      assert_equal(normal.parameterize(''), slugged)\n    end\n  end\n\n  def test_string_parameterized_underscore\n    StringToParameterizeWithUnderscore.each do |normal, slugged|\n      assert_equal(normal.parameterize('_'), slugged)\n    end\n  end\n\n  def test_humanize\n    UnderscoreToHuman.each do |underscore, human|\n      assert_equal(human, underscore.humanize)\n    end\n  end\n\n  def test_ord\n    assert_equal 97, 'a'.ord\n    assert_equal 97, 'abc'.ord\n  end\n\n  if RUBY_VERSION < '1.9'\n    def test_getbyte\n      assert_equal 97, 'a'.getbyte(0)\n      assert_equal 99, 'abc'.getbyte(2)\n      assert_nil   'abc'.getbyte(3)\n    end\n  end\n\n  def test_string_to_time\n    assert_equal Time.utc(2005, 2, 27, 23, 50), \"2005-02-27 23:50\".to_time\n    assert_equal Time.local(2005, 2, 27, 23, 50), \"2005-02-27 23:50\".to_time(:local)\n    assert_equal Time.utc(2005, 2, 27, 23, 50, 19, 275038), \"2005-02-27T23:50:19.275038\".to_time\n    assert_equal Time.local(2005, 2, 27, 23, 50, 19, 275038), \"2005-02-27T23:50:19.275038\".to_time(:local)\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_time\n    assert_equal Time.local_time(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_time(:local)\n    assert_equal Time.utc(2011, 2, 27, 23, 50), \"2011-02-27 22:50 -0100\".to_time\n    assert_nil \"\".to_time\n  end\n\n  def test_string_to_datetime\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_datetime\n    assert_equal 0, \"2039-02-27 23:50\".to_datetime.offset # use UTC offset\n    assert_equal ::Date::ITALY, \"2039-02-27 23:50\".to_datetime.start # use Ruby's default start value\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50, 19 + Rational(275038, 1000000), \"-04:00\"), \"2039-02-27T23:50:19.275038-04:00\".to_datetime\n    assert_nil \"\".to_datetime\n  end\n\n  def test_string_to_date\n    assert_equal Date.new(2005, 2, 27), \"2005-02-27\".to_date\n    assert_nil \"\".to_date\n  end\n\n  def test_access\n    s = \"hello\"\n    assert_equal \"h\", s.at(0)\n\n    assert_equal \"llo\", s.from(2)\n    assert_equal \"hel\", s.to(2)\n\n    assert_equal \"h\", s.first\n    assert_equal \"he\", s.first(2)\n    assert_equal \"\", s.first(0)\n\n    assert_equal \"o\", s.last\n    assert_equal \"llo\", s.last(3)\n    assert_equal \"hello\", s.last(10)\n    assert_equal \"\", s.last(0)\n\n    assert_equal 'x', 'x'.first\n    assert_equal 'x', 'x'.first(4)\n\n    assert_equal 'x', 'x'.last\n    assert_equal 'x', 'x'.last(4)\n  end\n\n  def test_access_returns_a_real_string\n    hash = {}\n    hash[\"h\"] = true\n    hash[\"hello123\".at(0)] = true\n    assert_equal %w(h), hash.keys\n\n    hash = {}\n    hash[\"llo\"] = true\n    hash[\"hello\".from(2)] = true\n    assert_equal %w(llo), hash.keys\n\n    hash = {}\n    hash[\"hel\"] = true\n    hash[\"hello\".to(2)] = true\n    assert_equal %w(hel), hash.keys\n\n    hash = {}\n    hash[\"hello\"] = true\n    hash[\"123hello\".last(5)] = true\n    assert_equal %w(hello), hash.keys\n\n    hash = {}\n    hash[\"hello\"] = true\n    hash[\"hello123\".first(5)] = true\n    assert_equal %w(hello), hash.keys\n  end\n\n  def test_starts_ends_with_alias\n    s = \"hello\"\n    assert s.starts_with?('h')\n    assert s.starts_with?('hel')\n    assert !s.starts_with?('el')\n\n    assert s.ends_with?('o')\n    assert s.ends_with?('lo')\n    assert !s.ends_with?('el')\n  end\n\n  def test_string_squish\n    original = %{ A string with tabs(\\t\\t), newlines(\\n\\n), and\n                  many spaces(  ). }\n\n    expected = \"A string with tabs( ), newlines( ), and many spaces( ).\"\n\n    # Make sure squish returns what we expect:\n    assert_equal original.squish,  expected\n    # But doesn't modify the original string:\n    assert_not_equal original, expected\n\n    # Make sure squish! returns what we expect:\n    assert_equal original.squish!, expected\n    # And changes the original string:\n    assert_equal original, expected\n  end\n\n  def test_string_inquiry\n    assert \"production\".inquiry.production?\n    assert !\"production\".inquiry.development?\n  end\n\n  def test_truncate\n    assert_equal \"Hello World!\", \"Hello World!\".truncate(12)\n    assert_equal \"Hello Wor...\", \"Hello World!!\".truncate(12)\n  end\n\n  def test_truncate_with_omission_and_seperator\n    assert_equal \"Hello[...]\", \"Hello World!\".truncate(10, :omission => \"[...]\")\n    assert_equal \"Hello[...]\", \"Hello Big World!\".truncate(13, :omission => \"[...]\", :separator => ' ')\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(14, :omission => \"[...]\", :separator => ' ')\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(15, :omission => \"[...]\", :separator => ' ')\n  end\n\n  if RUBY_VERSION < '1.9.0'\n    def test_truncate_multibyte\n      with_kcode 'none' do\n        assert_equal \"\\354\\225\\210\\353\\205\\225\\355...\", \"\\354\\225\\210\\353\\205\\225\\355\\225\\230\\354\\204\\270\\354\\232\\224\".truncate(10)\n      end\n      with_kcode 'u' do\n        assert_equal \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 ...\",\n          \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 \\354\\225\\204\\353\\235\\274\\353\\246\\254\\354\\230\\244\".truncate(10)\n      end\n    end\n  else\n    def test_truncate_multibyte\n      assert_equal \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 ...\".force_encoding('UTF-8'),\n        \"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 \\354\\225\\204\\353\\235\\274\\353\\246\\254\\354\\230\\244\".force_encoding('UTF-8').truncate(10)\n    end\n  end\nend\n\nclass StringBehaviourTest < Test::Unit::TestCase\n  def test_acts_like_string\n    assert 'Bambi'.acts_like_string?\n  end\nend\n\nclass CoreExtStringMultibyteTest < ActiveSupport::TestCase\n  UNICODE_STRING = '\u3053\u306b\u3061\u308f'\n  ASCII_STRING = 'ohayo'\n  BYTE_STRING = \"\\270\\236\\010\\210\\245\"\n\n  def test_core_ext_adds_mb_chars\n    assert_respond_to UNICODE_STRING, :mb_chars\n  end\n\n  def test_string_should_recognize_utf8_strings\n    assert UNICODE_STRING.is_utf8?\n    assert ASCII_STRING.is_utf8?\n    assert !BYTE_STRING.is_utf8?\n  end\n\n  if RUBY_VERSION < '1.9'\n    def test_mb_chars_returns_self_when_kcode_not_set\n      with_kcode('none') do\n        assert_kind_of String, UNICODE_STRING.mb_chars\n      end\n    end\n\n    def test_mb_chars_returns_an_instance_of_the_chars_proxy_when_kcode_utf8\n      with_kcode('UTF8') do\n        assert_kind_of ActiveSupport::Multibyte.proxy_class, UNICODE_STRING.mb_chars\n      end\n    end\n  else\n    def test_mb_chars_returns_instance_of_proxy_class\n      assert_kind_of ActiveSupport::Multibyte.proxy_class, UNICODE_STRING.mb_chars\n    end\n  end\nend\n\nclass OutputSafetyTest < ActiveSupport::TestCase\n  def setup\n    @string = \"hello\"\n    @object = Class.new(Object) do\n      def to_s\n        \"other\"\n      end\n    end.new\n  end\n\n  test \"A string is unsafe by default\" do\n    assert !@string.html_safe?\n  end\n\n  test \"A string can be marked safe\" do\n    string = @string.html_safe\n    assert string.html_safe?\n  end\n\n  test \"Marking a string safe returns the string\" do\n    assert_equal @string, @string.html_safe\n  end\n\n  test \"A fixnum is safe by default\" do\n    assert 5.html_safe?\n  end\n  \n  test \"a float is safe by default\" do\n    assert 5.7.html_safe?\n  end\n\n  test \"An object is unsafe by default\" do\n    assert !@object.html_safe?\n  end\n\n  test \"Adding an object to a safe string returns a safe string\" do\n    string = @string.html_safe\n    string << @object\n\n    assert_equal \"helloother\", string\n    assert string.html_safe?\n  end\n\n  test \"Adding a safe string to another safe string returns a safe string\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n    @combination = @other_string + string\n\n    assert_equal \"otherhello\", @combination\n    assert @combination.html_safe?\n  end\n\n  test \"Adding an unsafe string to a safe string escapes it and returns a safe string\" do\n    @other_string = \"other\".html_safe\n    @combination = @other_string + \"<foo>\"\n    @other_combination = @string + \"<foo>\"\n\n    assert_equal \"other&lt;foo&gt;\", @combination\n    assert_equal \"hello<foo>\", @other_combination\n\n    assert @combination.html_safe?\n    assert !@other_combination.html_safe?\n  end\n\n  test \"Concatting safe onto unsafe yields unsafe\" do\n    @other_string = \"other\"\n\n    string = @string.html_safe\n    @other_string.concat(string)\n    assert !@other_string.html_safe?\n  end\n\n  test \"Concatting unsafe onto safe yields escaped safe\" do\n    @other_string = \"other\".html_safe\n    string = @other_string.concat(\"<foo>\")\n    assert_equal \"other&lt;foo&gt;\", string\n    assert string.html_safe?\n  end\n\n  test \"Concatting safe onto safe yields safe\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n\n    @other_string.concat(string)\n    assert @other_string.html_safe?\n  end\n\n  test \"Concatting safe onto unsafe with << yields unsafe\" do\n    @other_string = \"other\"\n    string = @string.html_safe\n\n    @other_string << string\n    assert !@other_string.html_safe?\n  end\n\n  test \"Concatting unsafe onto safe with << yields escaped safe\" do\n    @other_string = \"other\".html_safe\n    string = @other_string << \"<foo>\"\n    assert_equal \"other&lt;foo&gt;\", string\n    assert string.html_safe?\n  end\n\n  test \"Concatting safe onto safe with << yields safe\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n\n    @other_string << string\n    assert @other_string.html_safe?\n  end\n\n  test \"Concatting a fixnum to safe always yields safe\" do\n    string = @string.html_safe\n    string = string.concat(13)\n    assert_equal \"hello\".concat(13), string\n    assert string.html_safe?\n  end\n\n  test 'emits normal string yaml' do\n    assert_equal 'foo'.to_yaml, 'foo'.html_safe.to_yaml(:foo => 1)\n  end\n\n  test 'knows whether it is encoding aware' do\n    if RUBY_VERSION >= \"1.9\"\n      assert 'ruby'.encoding_aware?\n    else\n      assert !'ruby'.encoding_aware?\n    end\n  end\n\n  test \"call to_param returns a normal string\" do\n    string = @string.html_safe\n    assert string.html_safe?\n    assert !string.to_param.html_safe?\n  end\nend\n\nclass StringExcludeTest < ActiveSupport::TestCase\n  test 'inverse of #include' do\n    assert_equal false, 'foo'.exclude?('o')\n    assert_equal true, 'foo'.exclude?('p')\n  end\nend\n"], "filenames": ["activesupport/lib/active_support/core_ext/string/output_safety.rb", "activesupport/test/core_ext/string_ext_test.rb"], "buggy_code_start_loc": [23, 9], "buggy_code_end_loc": [24, 12], "fixing_code_start_loc": [23, 10], "fixing_code_end_loc": [24, 20], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in activesupport/lib/active_support/core_ext/string/output_safety.rb in Ruby on Rails 2.x before 2.3.13, 3.0.x before 3.0.10, and 3.1.x before 3.1.0.rc5 allows remote attackers to inject arbitrary web script or HTML via a malformed Unicode string, related to a \"UTF-8 escaping vulnerability.\"", "other": {"cve": {"id": "CVE-2011-2932", "sourceIdentifier": "secalert@redhat.com", "published": "2011-08-29T18:55:01.567", "lastModified": "2019-08-08T15:42:27.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in activesupport/lib/active_support/core_ext/string/output_safety.rb in Ruby on Rails 2.x before 2.3.13, 3.0.x before 3.0.10, and 3.1.x before 3.1.0.rc5 allows remote attackers to inject arbitrary web script or HTML via a malformed Unicode string, related to a \"UTF-8 escaping vulnerability.\""}, {"lang": "es", "value": "Vulnerabilidad de ejecuci\u00f3n de secuencias comandos en sitios cruzados (XSS) en activesupport/lib/active_support/core_ext/string/output_safety.rb en Ruby on Rails v2.x antes de v2.3.13, v3.0.x antes de v3.0.10, y v3.1.x antes de v3.1.0.rc5 permite a atacantes remotos ejecutar secuencias de comandos web o HTML a trav\u00e9s de cadenas Unicode malformadas, relacionado con una \"vulnerabilidad de escapado UTF-8\""}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "50EEAFDA-7782-4E1E-9058-205AD4BE9A01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "CAC748BB-BFC5-44F7-B633-CEEBB1279889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "38CF2C31-70BB-41D3-9462-0A8B9869A5F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "F8584B37-7950-4C89-83D2-04E1ACDC60BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8CB26F65-5CFB-4BF8-BCC4-679327D4A8DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "EF12EA5D-5EB5-46A8-AC60-65B327D610AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "87B4B121-94BD-4E0F-8860-6239890043B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "63CF211C-683E-4F7D-8C62-05B153AC1960"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "456A2F7E-CC66-48C4-B028-353D2976837A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "9B1CDAFA-2AC6-4C46-9E65-0BE9127E770F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F9806A84-2160-40EA-9960-AE7756CE4E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "07EC67D4-3D0F-4FF9-8197-71175DCB2723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D1467583-23E9-4E2B-982D-80A356174BB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "4DC784C0-5618-4C32-8C17-BE7041656E14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "CFB9ABB5-1F78-4CF0-BA82-7833E0F7A56E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "AF3ED96F-3EA4-4E47-A559-9DF9A7D3DDE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "3B38EAA4-E948-45A7-B6E5-7214F2B545E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "6ECC8C49-5A46-4D23-81F9-8243F5D508DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.12:*:*:*:*:*:*:*", "matchCriteriaId": "312848C5-BA35-4A48-B66D-195A5E1CD00F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3BE7DFE-BA20-434B-A1DE-AD038B255C60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta:*:*:*:*:*:*", "matchCriteriaId": "DCEE5B21-C990-4705-8239-0D7B29DAEDA1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "65EE33B1-B079-4CDE-B9C2-F1613A4610DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "5CAAA20B-824F-4448-99DC-9712FE628073"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "D2BEBDFB-0F30-454A-B74C-F820C9D2708B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:rc:*:*:*:*:*:*", "matchCriteriaId": "1D7CD8C1-95D1-477E-AD96-6582EC33BA01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B6F00D98-3D0F-40AF-AE4F-090B1E6B660C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "9476CE55-69C0-45D3-B723-6F459C90BF05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.1:pre:*:*:*:*:*:*", "matchCriteriaId": "486F5BA6-BCF7-4691-9754-19D364B4438D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "112FC73B-A8BC-4EEA-9F4B-CCE685EF2838"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.2:pre:*:*:*:*:*:*", "matchCriteriaId": "E4498383-6FCA-4E17-A1FD-B0CE7EE50F85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "D26565B1-2BA6-4A3C-9264-7FC9A1820B59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "644EF85E-6D3E-4F5C-96B0-49AD2A2D90CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "392E2D58-CB39-4832-B4D9-9C2E23B8E14C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "1F2466EA-7039-46A1-B4A3-8DACD1953A59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "0CAB4E72-0A15-4B26-9B69-074C278568D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.6:rc1:*:*:*:*:*:*", "matchCriteriaId": "A085E105-9375-440A-80CB-9B23E6D7EB4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.6:rc2:*:*:*:*:*:*", "matchCriteriaId": "25911E48-C5D7-4ED8-B4DB-7523A74CCF49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "FE6EC1E5-3A4A-4751-9F77-28EF5AF681E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "B29674E3-CC80-446B-9A43-82594AE7A058"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.7:rc2:*:*:*:*:*:*", "matchCriteriaId": "FF34D8CB-2B6D-4CB8-A206-108293BCFFE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "8E5187F6-E3AC-4E0D-B1D0-83DE76C20A4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc1:*:*:*:*:*:*", "matchCriteriaId": "272268EE-E3E8-4683-B679-55D748877A7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc2:*:*:*:*:*:*", "matchCriteriaId": "7B69FD33-61FE-4F10-BBE1-215F59035D30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc3:*:*:*:*:*:*", "matchCriteriaId": "08D7CB5D-82EF-4A24-A792-938FAB40863D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc4:*:*:*:*:*:*", "matchCriteriaId": "8A044B21-47D5-468D-AF4A-06B3B5CC0824"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "2196F3D0-532A-40F9-843A-1DFBC8B63FDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "CBEDA932-6CB5-438C-94E4-824732A91BE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "903E5524-5E45-48CE-A804-EDAEBE3A79AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "08534AF2-F94E-4FB6-A572-4FB9827276D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "29E3B4A6-1346-4358-B7BC-84D00ED3ABBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "B52D7A6B-DD93-45F0-9186-18ABEFF28DF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "A1CB1B12-99F5-430F-AE19-9A95C17FA123"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB51F3E9-4899-49A9-9E7B-0DCA92A91DD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "F884F2F4-94F3-46CB-860B-1BCC0EEF408A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "88DFBB48-1C29-4639-9369-F5B413CA2337"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D37696D7-BEE6-4587-9E33-A7FE24780409"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "E95B5D44-0C8D-47BC-A89D-48A5BDEB84F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "1DFDAF6A-76AA-436F-A4F3-DA69892DE2B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "224BD488-0D7E-4F8B-9012-DE872DEB544C"}]}]}], "references": [{"url": "http://groups.google.com/group/rubyonrails-security/msg/f1d2749773db9f21?dmode=source&output=gplain", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/065114.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/065189.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/065212.html", "source": "secalert@redhat.com"}, {"url": "http://weblog.rubyonrails.org/2011/8/16/ann-rails-3-1-0-rc6", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/17/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/19/11", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/20/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/13", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/14", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/5", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=731435", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/rails/rails/commit/bfc432574d0b141fd7fe759edfe9b6771dd306bd", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/rails/rails/commit/bfc432574d0b141fd7fe759edfe9b6771dd306bd"}}