{"buggy_code": ["require 'rails'\nrequire 'active_support/core_ext/numeric/time'\nrequire 'active_support/dependencies'\nrequire 'orm_adapter'\nrequire 'set'\nrequire 'securerandom'\nrequire 'responders'\n\nmodule Devise\n  autoload :Delegator,          'devise/delegator'\n  autoload :Encryptor,          'devise/encryptor'\n  autoload :FailureApp,         'devise/failure_app'\n  autoload :OmniAuth,           'devise/omniauth'\n  autoload :ParameterFilter,    'devise/parameter_filter'\n  autoload :BaseSanitizer,      'devise/parameter_sanitizer'\n  autoload :ParameterSanitizer, 'devise/parameter_sanitizer'\n  autoload :TestHelpers,        'devise/test_helpers'\n  autoload :TimeInflector,      'devise/time_inflector'\n  autoload :TokenGenerator,     'devise/token_generator'\n\n  module Controllers\n    autoload :Helpers, 'devise/controllers/helpers'\n    autoload :Rememberable, 'devise/controllers/rememberable'\n    autoload :ScopedViews, 'devise/controllers/scoped_views'\n    autoload :SignInOut, 'devise/controllers/sign_in_out'\n    autoload :StoreLocation, 'devise/controllers/store_location'\n    autoload :UrlHelpers, 'devise/controllers/url_helpers'\n  end\n\n  module Hooks\n    autoload :Proxy, 'devise/hooks/proxy'\n  end\n\n  module Mailers\n    autoload :Helpers, 'devise/mailers/helpers'\n  end\n\n  module Strategies\n    autoload :Base, 'devise/strategies/base'\n    autoload :Authenticatable, 'devise/strategies/authenticatable'\n  end\n\n  # Constants which holds devise configuration for extensions. Those should\n  # not be modified by the \"end user\" (this is why they are constants).\n  ALL         = []\n  CONTROLLERS = ActiveSupport::OrderedHash.new\n  ROUTES      = ActiveSupport::OrderedHash.new\n  STRATEGIES  = ActiveSupport::OrderedHash.new\n  URL_HELPERS = ActiveSupport::OrderedHash.new\n\n  # Strategies that do not require user input.\n  NO_INPUT = []\n\n  # True values used to check params\n  TRUE_VALUES = [true, 1, '1', 't', 'T', 'true', 'TRUE']\n\n  # Secret key used by the key generator\n  mattr_accessor :secret_key\n  @@secret_key = nil\n\n  # Custom domain or key for cookies. Not set by default\n  mattr_accessor :rememberable_options\n  @@rememberable_options = {}\n\n  # The number of times to encrypt password.\n  mattr_accessor :stretches\n  @@stretches = 10\n\n  # The default key used when authenticating over http auth.\n  mattr_accessor :http_authentication_key\n  @@http_authentication_key = nil\n\n  # Keys used when authenticating a user.\n  mattr_accessor :authentication_keys\n  @@authentication_keys = [:email]\n\n  # Request keys used when authenticating a user.\n  mattr_accessor :request_keys\n  @@request_keys = []\n\n  # Keys that should be case-insensitive.\n  mattr_accessor :case_insensitive_keys\n  @@case_insensitive_keys = [:email]\n\n  # Keys that should have whitespace stripped.\n  mattr_accessor :strip_whitespace_keys\n  @@strip_whitespace_keys = []\n\n  # If http authentication is enabled by default.\n  mattr_accessor :http_authenticatable\n  @@http_authenticatable = false\n\n  # If http headers should be returned for ajax requests. True by default.\n  mattr_accessor :http_authenticatable_on_xhr\n  @@http_authenticatable_on_xhr = true\n\n  # If params authenticatable is enabled by default.\n  mattr_accessor :params_authenticatable\n  @@params_authenticatable = true\n\n  # The realm used in Http Basic Authentication.\n  mattr_accessor :http_authentication_realm\n  @@http_authentication_realm = \"Application\"\n\n  # Email regex used to validate email formats. It simply asserts that\n  # an one (and only one) @ exists in the given string. This is mainly\n  # to give user feedback and not to assert the e-mail validity.\n  mattr_accessor :email_regexp\n  @@email_regexp = /\\A[^@\\s]+@([^@\\s]+\\.)+[^@\\W]+\\z/\n\n  # Range validation for password length\n  mattr_accessor :password_length\n  @@password_length = 6..128\n\n  # The time the user will be remembered without asking for credentials again.\n  mattr_accessor :remember_for\n  @@remember_for = 2.weeks\n\n  # If true, extends the user's remember period when remembered via cookie.\n  mattr_accessor :extend_remember_period\n  @@extend_remember_period = false\n\n  # If true, all the remember me tokens are going to be invalidated when the user signs out.\n  mattr_accessor :expire_all_remember_me_on_sign_out\n  @@expire_all_remember_me_on_sign_out = true\n\n  # Time interval you can access your account before confirming your account.\n  # nil - allows unconfirmed access for unlimited time\n  mattr_accessor :allow_unconfirmed_access_for\n  @@allow_unconfirmed_access_for = 0.days\n\n  # Time interval the confirmation token is valid. nil = unlimited\n  mattr_accessor :confirm_within\n  @@confirm_within = nil\n\n  # Defines which key will be used when confirming an account.\n  mattr_accessor :confirmation_keys\n  @@confirmation_keys = [:email]\n\n  # Defines if email should be reconfirmable.\n  # False by default for backwards compatibility.\n  mattr_accessor :reconfirmable\n  @@reconfirmable = false\n\n  # Time interval to timeout the user session without activity.\n  mattr_accessor :timeout_in\n  @@timeout_in = 30.minutes\n\n  # Used to encrypt password. Please generate one with rake secret.\n  mattr_accessor :pepper\n  @@pepper = nil\n\n  # Used to enable sending notification to user when their password is changed\n  mattr_accessor :send_password_change_notification\n  @@send_password_change_notification = false\n\n  # Scoped views. Since it relies on fallbacks to render default views, it's\n  # turned off by default.\n  mattr_accessor :scoped_views\n  @@scoped_views = false\n\n  # Defines which strategy can be used to lock an account.\n  # Values: :failed_attempts, :none\n  mattr_accessor :lock_strategy\n  @@lock_strategy = :failed_attempts\n\n  # Defines which key will be used when locking and unlocking an account\n  mattr_accessor :unlock_keys\n  @@unlock_keys = [:email]\n\n  # Defines which strategy can be used to unlock an account.\n  # Values: :email, :time, :both\n  mattr_accessor :unlock_strategy\n  @@unlock_strategy = :both\n\n  # Number of authentication tries before locking an account\n  mattr_accessor :maximum_attempts\n  @@maximum_attempts = 20\n\n  # Time interval to unlock the account if :time is defined as unlock_strategy.\n  mattr_accessor :unlock_in\n  @@unlock_in = 1.hour\n\n  # Defines which key will be used when recovering the password for an account\n  mattr_accessor :reset_password_keys\n  @@reset_password_keys = [:email]\n\n  # Time interval you can reset your password with a reset password key\n  mattr_accessor :reset_password_within\n  @@reset_password_within = 6.hours\n\n  # When set to false, resetting a password does not automatically sign in a user\n  mattr_accessor :sign_in_after_reset_password\n  @@sign_in_after_reset_password = true\n\n  # The default scope which is used by warden.\n  mattr_accessor :default_scope\n  @@default_scope = nil\n\n  # Address which sends Devise e-mails.\n  mattr_accessor :mailer_sender\n  @@mailer_sender = nil\n\n  # Skip session storage for the following strategies\n  mattr_accessor :skip_session_storage\n  @@skip_session_storage = []\n\n  # Which formats should be treated as navigational.\n  mattr_accessor :navigational_formats\n  @@navigational_formats = [\"*/*\", :html]\n\n  # When set to true, signing out a user signs out all other scopes.\n  mattr_accessor :sign_out_all_scopes\n  @@sign_out_all_scopes = true\n\n  # The default method used while signing out\n  mattr_accessor :sign_out_via\n  @@sign_out_via = :get\n\n  # The parent controller all Devise controllers inherits from.\n  # Defaults to ApplicationController. This should be set early\n  # in the initialization process and should be set to a string.\n  mattr_accessor :parent_controller\n  @@parent_controller = \"ApplicationController\"\n\n  # The parent mailer all Devise mailers inherit from.\n  # Defaults to ActionMailer::Base. This should be set early\n  # in the initialization process and should be set to a string.\n  mattr_accessor :parent_mailer\n  @@parent_mailer = \"ActionMailer::Base\"\n\n  # The router Devise should use to generate routes. Defaults\n  # to :main_app. Should be overridden by engines in order\n  # to provide custom routes.\n  mattr_accessor :router_name\n  @@router_name = nil\n\n  # Set the OmniAuth path prefix so it can be overridden when\n  # Devise is used in a mountable engine\n  mattr_accessor :omniauth_path_prefix\n  @@omniauth_path_prefix = nil\n\n  # Set if we should clean up the CSRF Token on authentication\n  mattr_accessor :clean_up_csrf_token_on_authentication\n  @@clean_up_csrf_token_on_authentication = true\n\n  # PRIVATE CONFIGURATION\n\n  # Store scopes mappings.\n  mattr_reader :mappings\n  @@mappings = ActiveSupport::OrderedHash.new\n\n  # OmniAuth configurations.\n  mattr_reader :omniauth_configs\n  @@omniauth_configs = ActiveSupport::OrderedHash.new\n\n  # Define a set of modules that are called when a mapping is added.\n  mattr_reader :helpers\n  @@helpers = Set.new\n  @@helpers << Devise::Controllers::Helpers\n\n  # Private methods to interface with Warden.\n  mattr_accessor :warden_config\n  @@warden_config = nil\n  @@warden_config_blocks = []\n\n  # When true, enter in paranoid mode to avoid user enumeration.\n  mattr_accessor :paranoid\n  @@paranoid = false\n\n  # When true, warn user if they just used next-to-last attempt of authentication\n  mattr_accessor :last_attempt_warning\n  @@last_attempt_warning = true\n\n  # Stores the token generator\n  mattr_accessor :token_generator\n  @@token_generator = nil\n\n  # Default way to setup Devise. Run rails generate devise_install to create\n  # a fresh initializer with all configuration values.\n  def self.setup\n    yield self\n  end\n\n  class Getter\n    def initialize name\n      @name = name\n    end\n\n    def get\n      ActiveSupport::Dependencies.constantize(@name)\n    end\n  end\n\n  def self.ref(arg)\n    if defined?(ActiveSupport::Dependencies::ClassCache)\n      ActiveSupport::Dependencies::reference(arg)\n      Getter.new(arg)\n    else\n      ActiveSupport::Dependencies.ref(arg)\n    end\n  end\n\n  def self.available_router_name\n    router_name || :main_app\n  end\n\n  def self.omniauth_providers\n    omniauth_configs.keys\n  end\n\n  # Get the mailer class from the mailer reference object.\n  def self.mailer\n    @@mailer_ref.get\n  end\n\n  # Set the mailer reference object to access the mailer.\n  def self.mailer=(class_name)\n    @@mailer_ref = ref(class_name)\n  end\n  self.mailer = \"Devise::Mailer\"\n\n  # Small method that adds a mapping to Devise.\n  def self.add_mapping(resource, options)\n    mapping = Devise::Mapping.new(resource, options)\n    @@mappings[mapping.name] = mapping\n    @@default_scope ||= mapping.name\n    @@helpers.each { |h| h.define_helpers(mapping) }\n    mapping\n  end\n\n  # Register available devise modules. For the standard modules that Devise provides, this method is\n  # called from lib/devise/modules.rb. Third-party modules need to be added explicitly using this method.\n  #\n  # Note that adding a module using this method does not cause it to be used in the authentication\n  # process. That requires that the module be listed in the arguments passed to the 'devise' method\n  # in the model class definition.\n  #\n  # == Options:\n  #\n  #   +model+      - String representing the load path to a custom *model* for this module (to autoload.)\n  #   +controller+ - Symbol representing the name of an existing or custom *controller* for this module.\n  #   +route+      - Symbol representing the named *route* helper for this module.\n  #   +strategy+   - Symbol representing if this module got a custom *strategy*.\n  #   +insert_at+  - Integer representing the order in which this module's model will be included\n  #\n  # All values, except :model, accept also a boolean and will have the same name as the given module\n  # name.\n  #\n  # == Examples:\n  #\n  #   Devise.add_module(:party_module)\n  #   Devise.add_module(:party_module, strategy: true, controller: :sessions)\n  #   Devise.add_module(:party_module, model: 'party_module/model')\n  #   Devise.add_module(:party_module, insert_at: 0)\n  #\n  def self.add_module(module_name, options = {})\n    options.assert_valid_keys(:strategy, :model, :controller, :route, :no_input, :insert_at)\n\n    ALL.insert (options[:insert_at] || -1), module_name\n\n    if strategy = options[:strategy]\n      strategy = (strategy == true ? module_name : strategy)\n      STRATEGIES[module_name] = strategy\n    end\n\n    if controller = options[:controller]\n      controller = (controller == true ? module_name : controller)\n      CONTROLLERS[module_name] = controller\n    end\n\n    NO_INPUT << strategy if options[:no_input]\n\n    if route = options[:route]\n      case route\n      when TrueClass\n        key, value = module_name, []\n      when Symbol\n        key, value = route, []\n      when Hash\n        key, value = route.keys.first, route.values.flatten\n      else\n        raise ArgumentError, \":route should be true, a Symbol or a Hash\"\n      end\n\n      URL_HELPERS[key] ||= []\n      URL_HELPERS[key].concat(value)\n      URL_HELPERS[key].uniq!\n\n      ROUTES[module_name] = key\n    end\n\n    if options[:model]\n      path = (options[:model] == true ? \"devise/models/#{module_name}\" : options[:model])\n      camelized = ActiveSupport::Inflector.camelize(module_name.to_s)\n      Devise::Models.send(:autoload, camelized.to_sym, path)\n    end\n\n    Devise::Mapping.add_module module_name\n  end\n\n  # Sets warden configuration using a block that will be invoked on warden\n  # initialization.\n  #\n  #  Devise.setup do |config|\n  #    config.allow_unconfirmed_access_for = 2.days\n  #\n  #    config.warden do |manager|\n  #      # Configure warden to use other strategies, like oauth.\n  #      manager.oauth(:twitter)\n  #    end\n  #  end\n  def self.warden(&block)\n    @@warden_config_blocks << block\n  end\n\n  # Specify an OmniAuth provider.\n  #\n  #   config.omniauth :github, APP_ID, APP_SECRET\n  #\n  def self.omniauth(provider, *args)\n    @@helpers << Devise::OmniAuth::UrlHelpers\n    config = Devise::OmniAuth::Config.new(provider, args)\n    @@omniauth_configs[config.strategy_name.to_sym] = config\n  end\n\n  # Include helpers in the given scope to AC and AV.\n  def self.include_helpers(scope)\n    ActiveSupport.on_load(:action_controller) do\n      include scope::Helpers if defined?(scope::Helpers)\n      include scope::UrlHelpers\n    end\n\n    ActiveSupport.on_load(:action_view) do\n      include scope::UrlHelpers\n    end\n  end\n\n  # Regenerates url helpers considering Devise.mapping\n  def self.regenerate_helpers!\n    Devise::Controllers::UrlHelpers.remove_helpers!\n    Devise::Controllers::UrlHelpers.generate_helpers!\n  end\n\n  # A method used internally to complete the setup of warden manager after routes are loaded.\n  # See lib/devise/rails/routes.rb - ActionDispatch::Routing::RouteSet#finalize_with_devise!\n  def self.configure_warden! #:nodoc:\n    @@warden_configured ||= begin\n      warden_config.failure_app   = Devise::Delegator.new\n      warden_config.default_scope = Devise.default_scope\n      warden_config.intercept_401 = false\n\n      Devise.mappings.each_value do |mapping|\n        warden_config.scope_defaults mapping.name, strategies: mapping.strategies\n\n        warden_config.serialize_into_session(mapping.name) do |record|\n          mapping.to.serialize_into_session(record)\n        end\n\n        warden_config.serialize_from_session(mapping.name) do |key|\n          # Previous versions contained an additional entry at the beginning of\n          # key with the record's class name.\n          args = key[-2, 2]\n          mapping.to.serialize_from_session(*args)\n        end\n      end\n\n      @@warden_config_blocks.map { |block| block.call Devise.warden_config }\n      true\n    end\n  end\n\n  # Generate a friendly string randomly to be used as token.\n  # By default, length is 20 characters.\n  def self.friendly_token(length = 20)\n    # To calculate real characters, we must perform this operation.\n    # See SecureRandom.urlsafe_base64\n    rlength = (length * 3) / 4\n    SecureRandom.urlsafe_base64(rlength).tr('lIO0', 'sxyz')\n  end\n\n  # constant-time comparison algorithm to prevent timing attacks\n  def self.secure_compare(a, b)\n    return false if a.blank? || b.blank? || a.bytesize != b.bytesize\n    l = a.unpack \"C#{a.bytesize}\"\n\n    res = 0\n    b.each_byte { |byte| res |= byte ^ l.shift }\n    res == 0\n  end\nend\n\nrequire 'warden'\nrequire 'devise/mapping'\nrequire 'devise/models'\nrequire 'devise/modules'\nrequire 'devise/rails'\n", "module Devise\n  module Controllers\n    # A module that may be optionally included in a controller in order\n    # to provide remember me behavior. Useful when signing in is done\n    # through a callback, like in OmniAuth.\n    module Rememberable\n      # Return default cookie values retrieved from session options.\n      def self.cookie_values\n        Rails.configuration.session_options.slice(:path, :domain, :secure)\n      end\n\n      # Remembers the given resource by setting up a cookie\n      def remember_me(resource)\n        return if env[\"devise.skip_storage\"]\n        scope = Devise::Mapping.find_scope!(resource)\n        resource.remember_me!(resource.extend_remember_period)\n        cookies.signed[remember_key(resource, scope)] = remember_cookie_values(resource)\n      end\n\n      # Forgets the given resource by deleting a cookie\n      def forget_me(resource)\n        scope = Devise::Mapping.find_scope!(resource)\n        resource.forget_me!\n        cookies.delete(remember_key(resource, scope), forget_cookie_values(resource))\n      end\n\n      protected\n\n      def forget_cookie_values(resource)\n        Devise::Controllers::Rememberable.cookie_values.merge!(resource.rememberable_options)\n      end\n\n      def remember_cookie_values(resource)\n        options = { httponly: true }\n        options.merge!(forget_cookie_values(resource))\n        options.merge!(\n          value: resource.class.serialize_into_cookie(resource),\n          expires: resource.remember_expires_at\n        )\n      end\n\n      def remember_key(resource, scope)\n        resource.rememberable_options.fetch(:key, \"remember_#{scope}_token\")\n      end\n    end\n  end\nend\n", "require 'devise/strategies/rememberable'\nrequire 'devise/hooks/rememberable'\nrequire 'devise/hooks/forgetable'\n\nmodule Devise\n  module Models\n    # Rememberable manages generating and clearing token for remember the user\n    # from a saved cookie. Rememberable also has utility methods for dealing\n    # with serializing the user into the cookie and back from the cookie, trying\n    # to lookup the record based on the saved information.\n    # You probably wouldn't use rememberable methods directly, they are used\n    # mostly internally for handling the remember token.\n    #\n    # == Options\n    #\n    # Rememberable adds the following options in devise_for:\n    #\n    #   * +remember_for+: the time you want the user will be remembered without\n    #     asking for credentials. After this time the user will be blocked and\n    #     will have to enter their credentials again. This configuration is also\n    #     used to calculate the expires time for the cookie created to remember\n    #     the user. By default remember_for is 2.weeks.\n    #\n    #   * +extend_remember_period+: if true, extends the user's remember period\n    #     when remembered via cookie. False by default.\n    #\n    #   * +rememberable_options+: configuration options passed to the created cookie.\n    #\n    # == Examples\n    #\n    #   User.find(1).remember_me!  # regenerating the token\n    #   User.find(1).forget_me!    # clearing the token\n    #\n    #   # generating info to put into cookies\n    #   User.serialize_into_cookie(user)\n    #\n    #   # lookup the user based on the incoming cookie information\n    #   User.serialize_from_cookie(cookie_string)\n    module Rememberable\n      extend ActiveSupport::Concern\n\n      attr_accessor :remember_me, :extend_remember_period\n\n      def self.required_fields(klass)\n        [:remember_created_at]\n      end\n\n      # Generate a new remember token and save the record without validations\n      # if remember expired (token is no longer valid) or extend_remember_period is true\n      def remember_me!(extend_period=false)\n        self.remember_token = self.class.remember_token if generate_remember_token?\n        self.remember_created_at = Time.now.utc if generate_remember_timestamp?(extend_period)\n        save(validate: false) if self.changed?\n      end\n\n      # If the record is persisted, remove the remember token (but only if\n      # it exists), and save the record without validations.\n      def forget_me!\n        return unless persisted?\n        self.remember_token = nil if respond_to?(:remember_token=)\n        self.remember_created_at = nil if self.class.expire_all_remember_me_on_sign_out\n        save(validate: false)\n      end\n\n      # Remember token should be expired if expiration time not overpass now.\n      def remember_expired?\n        remember_created_at.nil? || (remember_expires_at <= Time.now.utc)\n      end\n\n      # Remember token expires at created time + remember_for configuration\n      def remember_expires_at\n        remember_created_at + self.class.remember_for\n      end\n\n      def rememberable_value\n        if respond_to?(:remember_token)\n          remember_token\n        elsif respond_to?(:authenticatable_salt) && (salt = authenticatable_salt.presence)\n          salt\n        else\n          raise \"authenticable_salt returned nil for the #{self.class.name} model. \" \\\n            \"In order to use rememberable, you must ensure a password is always set \" \\\n            \"or have a remember_token column in your model or implement your own \" \\\n            \"rememberable_value in the model with custom logic.\"\n        end\n      end\n\n      def rememberable_options\n        self.class.rememberable_options\n      end\n\n      # A callback initiated after successfully being remembered. This can be\n      # used to insert your own logic that is only run after the user is\n      # remembered.\n      #\n      # Example:\n      #\n      #   def after_remembered\n      #     self.update_attribute(:invite_code, nil)\n      #   end\n      #\n      def after_remembered\n      end\n\n    protected\n\n      def generate_remember_token? #:nodoc:\n        respond_to?(:remember_token) && remember_expired?\n      end\n\n      # Generate a timestamp if extend_remember_period is true, if no remember_token\n      # exists, or if an existing remember token has expired.\n      def generate_remember_timestamp?(extend_period) #:nodoc:\n        extend_period || remember_expired?\n      end\n\n      module ClassMethods\n        # Create the cookie key using the record id and remember_token\n        def serialize_into_cookie(record)\n          [record.to_key, record.rememberable_value]\n        end\n\n        # Recreate the user based on the stored cookie\n        def serialize_from_cookie(id, remember_token)\n          record = to_adapter.get(id)\n          record if record && !record.remember_expired? &&\n                    Devise.secure_compare(record.rememberable_value, remember_token)\n        end\n\n        # Generate a token checking if one does not already exist in the database.\n        def remember_token #:nodoc:\n          loop do\n            token = Devise.friendly_token\n            break token unless to_adapter.find_first({ remember_token: token })\n          end\n        end\n\n        Devise::Models.config(self, :remember_for, :extend_remember_period, :rememberable_options, :expire_all_remember_me_on_sign_out)\n      end\n    end\n  end\nend\n", "require 'devise/hooks/timeoutable'\n\nmodule Devise\n  module Models\n    # Timeoutable takes care of verifying whether a user session has already\n    # expired or not. When a session expires after the configured time, the user\n    # will be asked for credentials again, it means, they will be redirected\n    # to the sign in page.\n    #\n    # == Options\n    #\n    # Timeoutable adds the following options to devise_for:\n    #\n    #   * +timeout_in+: the interval to timeout the user session without activity.\n    #\n    # == Examples\n    #\n    #   user.timedout?(30.minutes.ago)\n    #\n    module Timeoutable\n      extend ActiveSupport::Concern\n\n      def self.required_fields(klass)\n        []\n      end\n\n      # Checks whether the user session has expired based on configured time.\n      def timedout?(last_access)\n        return false if remember_exists_and_not_expired?\n        !timeout_in.nil? && last_access && last_access <= timeout_in.ago\n      end\n\n      def timeout_in\n        self.class.timeout_in\n      end\n\n      private\n\n      def remember_exists_and_not_expired?\n        return false unless respond_to?(:remember_created_at) && respond_to?(:remember_expired?)\n        remember_created_at && !remember_expired?\n      end\n\n      module ClassMethods\n        Devise::Models.config(self, :timeout_in)\n      end\n    end\n  end\nend\n", "require 'test_helper'\n\nclass RememberMeTest < ActionDispatch::IntegrationTest\n  def create_user_and_remember(add_to_token='')\n    user = create_user\n    user.remember_me!\n    raw_cookie = User.serialize_into_cookie(user).tap { |a| a.last << add_to_token }\n    cookies['remember_user_token'] = generate_signed_cookie(raw_cookie)\n    user\n  end\n\n  def generate_signed_cookie(raw_cookie)\n    request = ActionDispatch::TestRequest.new\n    request.cookie_jar.signed['raw_cookie'] = raw_cookie\n    request.cookie_jar['raw_cookie']\n  end\n\n  def signed_cookie(key)\n    controller.send(:cookies).signed[key]\n  end\n\n  def cookie_expires(key)\n    cookie  = response.headers[\"Set-Cookie\"].split(\"\\n\").grep(/^#{key}/).first\n    expires = cookie.split(\";\").map(&:strip).grep(/^expires=/).first\n    Time.parse(expires).utc\n  end\n\n  test 'do not remember the user if they have not checked remember me option' do\n    sign_in_as_user\n    assert_nil request.cookies[\"remember_user_cookie\"]\n  end\n\n  test 'handle unverified requests gets rid of caches' do\n    swap ApplicationController, allow_forgery_protection: true do\n      post exhibit_user_url(1)\n      assert_not warden.authenticated?(:user)\n\n      create_user_and_remember\n      post exhibit_user_url(1)\n      assert_equal \"User is not authenticated\", response.body\n      assert_not warden.authenticated?(:user)\n    end\n  end\n\n  test 'handle unverified requests does not create cookies on sign in' do\n    swap ApplicationController, allow_forgery_protection: true do\n      get new_user_session_path\n      assert request.session[:_csrf_token]\n\n      post user_session_path, authenticity_token: \"oops\", user:\n           { email: \"jose.valim@gmail.com\", password: \"123456\", remember_me: \"1\" }\n      assert_not warden.authenticated?(:user)\n      assert_not request.cookies['remember_user_token']\n    end\n  end\n\n  test 'generate remember token after sign in' do\n    sign_in_as_user remember_me: true\n    assert request.cookies['remember_user_token']\n  end\n\n  test 'generate remember token after sign in setting cookie options' do\n    # We test this by asserting the cookie is not sent after the redirect\n    # since we changed the domain. This is the only difference with the\n    # previous test.\n    swap Devise, rememberable_options: { domain: \"omg.somewhere.com\" } do\n      sign_in_as_user remember_me: true\n      assert_nil request.cookies[\"remember_user_token\"]\n    end\n  end\n\n  test 'generate remember token with a custom key' do\n    swap Devise, rememberable_options: { key: \"v1lat_token\" } do\n      sign_in_as_user remember_me: true\n      assert request.cookies[\"v1lat_token\"]\n    end\n  end\n\n  test 'generate remember token after sign in setting session options' do\n    begin\n      Rails.configuration.session_options[:domain] = \"omg.somewhere.com\"\n      sign_in_as_user remember_me: true\n      assert_nil request.cookies[\"remember_user_token\"]\n    ensure\n      Rails.configuration.session_options.delete(:domain)\n    end\n  end\n\n  test 'remember the user before sign in' do\n    user = create_user_and_remember\n    get users_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n    assert warden.user(:user) == user\n    assert_match /remember_user_token[^\\n]*HttpOnly/, response.headers[\"Set-Cookie\"], \"Expected Set-Cookie header in response to set HttpOnly flag on remember_user_token cookie.\"\n  end\n\n  test 'remember the user before sign up and redirect them to their home' do\n    create_user_and_remember\n    get new_user_registration_path\n    assert warden.authenticated?(:user)\n    assert_redirected_to root_path\n  end\n\n  test 'does not extend remember period through sign in' do\n    swap Devise, extend_remember_period: true, remember_for: 1.year do\n      user = create_user\n      user.remember_me!\n\n      user.remember_created_at = old = 10.days.ago\n      user.save\n\n      sign_in_as_user remember_me: true\n      user.reload\n\n      assert warden.user(:user) == user\n      assert_equal old.to_i, user.remember_created_at.to_i\n    end\n  end\n\n  test 'do not remember other scopes' do\n    create_user_and_remember\n    get root_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n    assert_not warden.authenticated?(:admin)\n  end\n\n  test 'do not remember with invalid token' do\n    create_user_and_remember('add')\n    get users_path\n    assert_not warden.authenticated?(:user)\n    assert_redirected_to new_user_session_path\n  end\n\n  test 'do not remember with expired token' do\n    create_user_and_remember\n    swap Devise, remember_for: 0 do\n      get users_path\n      assert_not warden.authenticated?(:user)\n      assert_redirected_to new_user_session_path\n    end\n  end\n\n  test 'do not remember the user anymore after forget' do\n    create_user_and_remember\n    get users_path\n    assert warden.authenticated?(:user)\n\n    get destroy_user_session_path\n    assert_not warden.authenticated?(:user)\n    assert_nil warden.cookies['remember_user_token']\n\n    get users_path\n    assert_not warden.authenticated?(:user)\n  end\n\n  test 'changing user password expires remember me token' do\n    user = create_user_and_remember\n    user.password = \"another_password\"\n    user.password_confirmation = \"another_password\"\n    user.save!\n\n    get users_path\n    assert_not warden.authenticated?(:user)\n  end\n\n  test 'valid sign in calls after_remembered callback' do\n    user = create_user_and_remember\n\n    User.expects(:serialize_from_cookie).returns user\n    user.expects :after_remembered\n\n    get new_user_registration_path\n  end\nend\n", "require 'test_helper'\n\nclass SessionTimeoutTest < ActionDispatch::IntegrationTest\n\n  def last_request_at\n    @controller.user_session['last_request_at']\n  end\n\n  test 'set last request at in user session after each request' do\n    sign_in_as_user\n    assert_not_nil last_request_at\n\n    @controller.user_session.delete('last_request_at')\n    get users_path\n    assert_not_nil last_request_at\n  end\n\n  test 'set last request at in user session after each request is skipped if tracking is disabled' do\n    sign_in_as_user\n    old_last_request = last_request_at\n    assert_not_nil last_request_at\n\n    get users_path, {}, 'devise.skip_trackable' => true\n    assert_equal old_last_request, last_request_at\n  end\n\n  test 'does not set last request at in user session after each request if timeoutable is disabled' do\n    sign_in_as_user\n    old_last_request = last_request_at\n    assert_not_nil last_request_at\n\n    new_time = 2.seconds.from_now\n    Time.stubs(:now).returns(new_time)\n\n    get users_path, {}, 'devise.skip_timeoutable' => true\n    assert_equal old_last_request, last_request_at\n  end\n\n  test 'does not time out user session before default limit time' do\n    sign_in_as_user\n    assert_response :success\n    assert warden.authenticated?(:user)\n\n    get users_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n  end\n\n  test 'time out user session after default limit time when sign_out_all_scopes is false' do\n    swap Devise, sign_out_all_scopes: false do\n      sign_in_as_admin\n\n      user = sign_in_as_user\n      get expire_user_path(user)\n      assert_not_nil last_request_at\n\n      get users_path\n      assert_redirected_to users_path\n      assert_not warden.authenticated?(:user)\n      assert warden.authenticated?(:admin)\n    end\n  end\n\n  test 'time out all sessions after default limit time when sign_out_all_scopes is true' do\n    swap Devise, sign_out_all_scopes: true do\n      sign_in_as_admin\n\n      user = sign_in_as_user\n      get expire_user_path(user)\n      assert_not_nil last_request_at\n\n      get root_path\n      assert_not warden.authenticated?(:user)\n      assert_not warden.authenticated?(:admin)\n    end\n  end\n\n  test 'time out user session after deault limit time and redirect to latest get request' do\n    user = sign_in_as_user\n    visit edit_form_user_path(user)\n\n    click_button 'Update'\n    sign_in_as_user\n\n    assert_equal edit_form_user_url(user), current_url\n  end\n\n  test 'time out is not triggered on sign out' do\n    user = sign_in_as_user\n    get expire_user_path(user)\n\n    get destroy_user_session_path\n\n    assert_response :redirect\n    assert_redirected_to root_path\n    follow_redirect!\n    assert_contain 'Signed out successfully'\n  end\n\n  test 'expired session is not extended by sign in page' do\n    user = sign_in_as_user\n    get expire_user_path(user)\n    assert warden.authenticated?(:user)\n\n    get \"/users/sign_in\"\n    assert_redirected_to \"/users/sign_in\"\n    follow_redirect!\n\n    assert_response :success\n    assert_contain 'Sign in'\n    assert_not warden.authenticated?(:user)\n  end\n\n  test 'time out is not triggered on sign in' do\n    user = sign_in_as_user\n    get expire_user_path(user)\n\n    post \"/users/sign_in\", email: user.email, password: \"123456\"\n\n    assert_response :redirect\n    follow_redirect!\n    assert_contain 'You are signed in'\n  end\n\n  test 'user configured timeout limit' do\n    swap Devise, timeout_in: 8.minutes do\n      user = sign_in_as_user\n\n      get users_path\n      assert_not_nil last_request_at\n      assert_response :success\n      assert warden.authenticated?(:user)\n\n      get expire_user_path(user)\n      get users_path\n      assert_redirected_to users_path\n      assert_not warden.authenticated?(:user)\n    end\n  end\n\n  test 'error message with i18n' do\n    store_translations :en, devise: {\n      failure: { user: { timeout: 'Session expired!' } }\n    } do\n      user = sign_in_as_user\n\n      get expire_user_path(user)\n      get root_path\n      follow_redirect!\n      assert_contain 'Session expired!'\n    end\n  end\n\n  test 'error message with i18n with double redirect' do\n    store_translations :en, devise: {\n      failure: { user: { timeout: 'Session expired!' } }\n    } do\n      user = sign_in_as_user\n\n      get expire_user_path(user)\n      get users_path\n      follow_redirect!\n      follow_redirect!\n      assert_contain 'Session expired!'\n    end\n  end\n\n  test 'time out not triggered if remembered' do\n    user = sign_in_as_user remember_me: true\n    get expire_user_path(user)\n    assert_not_nil last_request_at\n\n    get users_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n  end\n\n  test 'does not crashes when the last_request_at is a String' do\n    user = sign_in_as_user\n\n    get edit_form_user_path(user, last_request_at: Time.now.utc.to_s)\n    get users_path\n  end\nend\n", "require 'test_helper'\n\nclass RememberableTest < ActiveSupport::TestCase\n  def resource_class\n    User\n  end\n\n  def create_resource\n    create_user\n  end\n\n  test 'remember_me should not generate a new token if using salt' do\n    user = create_user\n    user.expects(:valid?).never\n    user.remember_me!\n  end\n\n  test 'forget_me should not clear remember token if using salt' do\n    user = create_user\n    user.remember_me!\n    user.expects(:valid?).never\n    user.forget_me!\n  end\n\n  test 'can generate remember token' do\n    user = create_user\n    user.singleton_class.send(:attr_accessor, :remember_token)\n    User.to_adapter.expects(:find_first).returns(nil)\n    user.remember_me!\n    assert user.remember_token\n  end\n\n  test 'serialize into cookie' do\n    user = create_user\n    user.remember_me!\n    assert_equal [user.to_key, user.authenticatable_salt], User.serialize_into_cookie(user)\n  end\n\n  test 'serialize from cookie' do\n    user = create_user\n    user.remember_me!\n    assert_equal user, User.serialize_from_cookie(user.to_key, user.authenticatable_salt)\n  end\n\n  test 'raises a RuntimeError if authenticatable_salt is nil or empty' do\n    user = User.new\n    def user.authenticable_salt; nil; end\n    assert_raise RuntimeError do\n      user.rememberable_value\n    end\n\n    user = User.new\n    def user.authenticable_salt; \"\"; end\n    assert_raise RuntimeError do\n      user.rememberable_value\n    end\n  end\n\n  test 'should respond to remember_me attribute' do\n    assert resource_class.new.respond_to?(:remember_me)\n    assert resource_class.new.respond_to?(:remember_me=)\n  end\n\n  test 'forget_me should clear remember_created_at if expire_all_remember_me_on_sign_out is true' do\n    swap Devise, expire_all_remember_me_on_sign_out: true do\n      resource = create_resource\n      resource.remember_me!\n      assert_not_nil resource.remember_created_at\n\n      resource.forget_me!\n      assert_nil resource.remember_created_at\n    end\n  end\n\n  test 'forget_me should not clear remember_created_at if expire_all_remember_me_on_sign_out is false' do\n    swap Devise, expire_all_remember_me_on_sign_out: false do\n      resource = create_resource\n      resource.remember_me!\n\n      assert_not_nil resource.remember_created_at\n\n      resource.forget_me!\n      assert_not_nil resource.remember_created_at\n    end\n  end\n\n  test 'forget_me should not try to update resource if it has been destroyed' do\n    resource = create_resource\n    resource.expects(:remember_created_at).never\n    resource.expects(:save).never\n\n    resource.destroy\n    resource.forget_me!\n  end\n\n  test 'remember is expired if not created at timestamp is set' do\n    assert create_resource.remember_expired?\n  end\n\n  test 'serialize should return nil if no resource is found' do\n    assert_nil resource_class.serialize_from_cookie([0], \"123\")\n  end\n\n  test 'remember me return nil if is a valid resource with invalid token' do\n    resource = create_resource\n    assert_nil resource_class.serialize_from_cookie([resource.id], \"123\")\n  end\n\n  test 'remember for should fallback to devise remember for default configuration' do\n    swap Devise, remember_for: 1.day do\n      resource = create_resource\n      resource.remember_me!\n      assert_not resource.remember_expired?\n    end\n  end\n\n  test 'remember expires at should sum date of creation with remember for configuration' do\n    swap Devise, remember_for: 3.days do\n      resource = create_resource\n      resource.remember_me!\n      assert_equal 3.days.from_now.to_date, resource.remember_expires_at.to_date\n\n      Devise.remember_for = 5.days\n      assert_equal 5.days.from_now.to_date, resource.remember_expires_at.to_date\n    end\n  end\n\n  test 'remember should be expired if remember_for is zero' do\n    swap Devise, remember_for: 0.days do\n      Devise.remember_for = 0.days\n      resource = create_resource\n      resource.remember_me!\n      assert resource.remember_expired?\n    end\n  end\n\n  test 'remember should be expired if it was created before limit time' do\n    swap Devise, remember_for: 1.day do\n      resource = create_resource\n      resource.remember_me!\n      resource.remember_created_at = 2.days.ago\n      resource.save\n      assert resource.remember_expired?\n    end\n  end\n\n  test 'remember should not be expired if it was created within the limit time' do\n    swap Devise, remember_for: 30.days do\n      resource = create_resource\n      resource.remember_me!\n      resource.remember_created_at = (30.days.ago + 2.minutes)\n      resource.save\n      assert_not resource.remember_expired?\n    end\n  end\n\n  test 'if extend_remember_period is false, remember_me! should generate a new timestamp if expired' do\n    swap Devise, remember_for: 5.minutes do\n      resource = create_resource\n      resource.remember_me!(false)\n      assert resource.remember_created_at\n\n      resource.remember_created_at = old = 10.minutes.ago\n      resource.save\n\n      resource.remember_me!(false)\n      assert_not_equal old.to_i, resource.remember_created_at.to_i\n    end\n  end\n\n  test 'if extend_remember_period is false, remember_me! should not generate a new timestamp' do\n    swap Devise, remember_for: 1.year do\n      resource = create_resource\n      resource.remember_me!(false)\n      assert resource.remember_created_at\n\n      resource.remember_created_at = old = 10.minutes.ago.utc\n      resource.save\n\n      resource.remember_me!(false)\n      assert_equal old.to_i, resource.remember_created_at.to_i\n    end\n  end\n\n  test 'if extend_remember_period is true, remember_me! should always generate a new timestamp' do\n    swap Devise, remember_for: 1.year do\n      resource = create_resource\n      resource.remember_me!(true)\n      assert resource.remember_created_at\n\n      resource.remember_created_at = old = 10.minutes.ago\n      resource.save\n\n      resource.remember_me!(true)\n      assert_not_equal old, resource.remember_created_at\n    end\n  end\n\n  test 'should have the required_fields array' do\n    assert_same_content Devise::Models::Rememberable.required_fields(User), [\n      :remember_created_at\n    ]\n  end\nend\n"], "fixing_code": ["require 'rails'\nrequire 'active_support/core_ext/numeric/time'\nrequire 'active_support/dependencies'\nrequire 'orm_adapter'\nrequire 'set'\nrequire 'securerandom'\nrequire 'responders'\n\nmodule Devise\n  autoload :Delegator,          'devise/delegator'\n  autoload :Encryptor,          'devise/encryptor'\n  autoload :FailureApp,         'devise/failure_app'\n  autoload :OmniAuth,           'devise/omniauth'\n  autoload :ParameterFilter,    'devise/parameter_filter'\n  autoload :BaseSanitizer,      'devise/parameter_sanitizer'\n  autoload :ParameterSanitizer, 'devise/parameter_sanitizer'\n  autoload :TestHelpers,        'devise/test_helpers'\n  autoload :TimeInflector,      'devise/time_inflector'\n  autoload :TokenGenerator,     'devise/token_generator'\n\n  module Controllers\n    autoload :Helpers, 'devise/controllers/helpers'\n    autoload :Rememberable, 'devise/controllers/rememberable'\n    autoload :ScopedViews, 'devise/controllers/scoped_views'\n    autoload :SignInOut, 'devise/controllers/sign_in_out'\n    autoload :StoreLocation, 'devise/controllers/store_location'\n    autoload :UrlHelpers, 'devise/controllers/url_helpers'\n  end\n\n  module Hooks\n    autoload :Proxy, 'devise/hooks/proxy'\n  end\n\n  module Mailers\n    autoload :Helpers, 'devise/mailers/helpers'\n  end\n\n  module Strategies\n    autoload :Base, 'devise/strategies/base'\n    autoload :Authenticatable, 'devise/strategies/authenticatable'\n  end\n\n  # Constants which holds devise configuration for extensions. Those should\n  # not be modified by the \"end user\" (this is why they are constants).\n  ALL         = []\n  CONTROLLERS = ActiveSupport::OrderedHash.new\n  ROUTES      = ActiveSupport::OrderedHash.new\n  STRATEGIES  = ActiveSupport::OrderedHash.new\n  URL_HELPERS = ActiveSupport::OrderedHash.new\n\n  # Strategies that do not require user input.\n  NO_INPUT = []\n\n  # True values used to check params\n  TRUE_VALUES = [true, 1, '1', 't', 'T', 'true', 'TRUE']\n\n  # Secret key used by the key generator\n  mattr_accessor :secret_key\n  @@secret_key = nil\n\n  # Custom domain or key for cookies. Not set by default\n  mattr_accessor :rememberable_options\n  @@rememberable_options = {}\n\n  # The number of times to encrypt password.\n  mattr_accessor :stretches\n  @@stretches = 10\n\n  # The default key used when authenticating over http auth.\n  mattr_accessor :http_authentication_key\n  @@http_authentication_key = nil\n\n  # Keys used when authenticating a user.\n  mattr_accessor :authentication_keys\n  @@authentication_keys = [:email]\n\n  # Request keys used when authenticating a user.\n  mattr_accessor :request_keys\n  @@request_keys = []\n\n  # Keys that should be case-insensitive.\n  mattr_accessor :case_insensitive_keys\n  @@case_insensitive_keys = [:email]\n\n  # Keys that should have whitespace stripped.\n  mattr_accessor :strip_whitespace_keys\n  @@strip_whitespace_keys = []\n\n  # If http authentication is enabled by default.\n  mattr_accessor :http_authenticatable\n  @@http_authenticatable = false\n\n  # If http headers should be returned for ajax requests. True by default.\n  mattr_accessor :http_authenticatable_on_xhr\n  @@http_authenticatable_on_xhr = true\n\n  # If params authenticatable is enabled by default.\n  mattr_accessor :params_authenticatable\n  @@params_authenticatable = true\n\n  # The realm used in Http Basic Authentication.\n  mattr_accessor :http_authentication_realm\n  @@http_authentication_realm = \"Application\"\n\n  # Email regex used to validate email formats. It simply asserts that\n  # an one (and only one) @ exists in the given string. This is mainly\n  # to give user feedback and not to assert the e-mail validity.\n  mattr_accessor :email_regexp\n  @@email_regexp = /\\A[^@\\s]+@([^@\\s]+\\.)+[^@\\W]+\\z/\n\n  # Range validation for password length\n  mattr_accessor :password_length\n  @@password_length = 6..128\n\n  # The time the user will be remembered without asking for credentials again.\n  mattr_accessor :remember_for\n  @@remember_for = 2.weeks\n\n  # TODO: extend_remember_period is no longer used\n  # If true, extends the user's remember period when remembered via cookie.\n  mattr_accessor :extend_remember_period\n  @@extend_remember_period = false\n\n  # If true, all the remember me tokens are going to be invalidated when the user signs out.\n  mattr_accessor :expire_all_remember_me_on_sign_out\n  @@expire_all_remember_me_on_sign_out = true\n\n  # Time interval you can access your account before confirming your account.\n  # nil - allows unconfirmed access for unlimited time\n  mattr_accessor :allow_unconfirmed_access_for\n  @@allow_unconfirmed_access_for = 0.days\n\n  # Time interval the confirmation token is valid. nil = unlimited\n  mattr_accessor :confirm_within\n  @@confirm_within = nil\n\n  # Defines which key will be used when confirming an account.\n  mattr_accessor :confirmation_keys\n  @@confirmation_keys = [:email]\n\n  # Defines if email should be reconfirmable.\n  # False by default for backwards compatibility.\n  mattr_accessor :reconfirmable\n  @@reconfirmable = false\n\n  # Time interval to timeout the user session without activity.\n  mattr_accessor :timeout_in\n  @@timeout_in = 30.minutes\n\n  # Used to encrypt password. Please generate one with rake secret.\n  mattr_accessor :pepper\n  @@pepper = nil\n\n  # Used to enable sending notification to user when their password is changed\n  mattr_accessor :send_password_change_notification\n  @@send_password_change_notification = false\n\n  # Scoped views. Since it relies on fallbacks to render default views, it's\n  # turned off by default.\n  mattr_accessor :scoped_views\n  @@scoped_views = false\n\n  # Defines which strategy can be used to lock an account.\n  # Values: :failed_attempts, :none\n  mattr_accessor :lock_strategy\n  @@lock_strategy = :failed_attempts\n\n  # Defines which key will be used when locking and unlocking an account\n  mattr_accessor :unlock_keys\n  @@unlock_keys = [:email]\n\n  # Defines which strategy can be used to unlock an account.\n  # Values: :email, :time, :both\n  mattr_accessor :unlock_strategy\n  @@unlock_strategy = :both\n\n  # Number of authentication tries before locking an account\n  mattr_accessor :maximum_attempts\n  @@maximum_attempts = 20\n\n  # Time interval to unlock the account if :time is defined as unlock_strategy.\n  mattr_accessor :unlock_in\n  @@unlock_in = 1.hour\n\n  # Defines which key will be used when recovering the password for an account\n  mattr_accessor :reset_password_keys\n  @@reset_password_keys = [:email]\n\n  # Time interval you can reset your password with a reset password key\n  mattr_accessor :reset_password_within\n  @@reset_password_within = 6.hours\n\n  # When set to false, resetting a password does not automatically sign in a user\n  mattr_accessor :sign_in_after_reset_password\n  @@sign_in_after_reset_password = true\n\n  # The default scope which is used by warden.\n  mattr_accessor :default_scope\n  @@default_scope = nil\n\n  # Address which sends Devise e-mails.\n  mattr_accessor :mailer_sender\n  @@mailer_sender = nil\n\n  # Skip session storage for the following strategies\n  mattr_accessor :skip_session_storage\n  @@skip_session_storage = []\n\n  # Which formats should be treated as navigational.\n  mattr_accessor :navigational_formats\n  @@navigational_formats = [\"*/*\", :html]\n\n  # When set to true, signing out a user signs out all other scopes.\n  mattr_accessor :sign_out_all_scopes\n  @@sign_out_all_scopes = true\n\n  # The default method used while signing out\n  mattr_accessor :sign_out_via\n  @@sign_out_via = :get\n\n  # The parent controller all Devise controllers inherits from.\n  # Defaults to ApplicationController. This should be set early\n  # in the initialization process and should be set to a string.\n  mattr_accessor :parent_controller\n  @@parent_controller = \"ApplicationController\"\n\n  # The parent mailer all Devise mailers inherit from.\n  # Defaults to ActionMailer::Base. This should be set early\n  # in the initialization process and should be set to a string.\n  mattr_accessor :parent_mailer\n  @@parent_mailer = \"ActionMailer::Base\"\n\n  # The router Devise should use to generate routes. Defaults\n  # to :main_app. Should be overridden by engines in order\n  # to provide custom routes.\n  mattr_accessor :router_name\n  @@router_name = nil\n\n  # Set the OmniAuth path prefix so it can be overridden when\n  # Devise is used in a mountable engine\n  mattr_accessor :omniauth_path_prefix\n  @@omniauth_path_prefix = nil\n\n  # Set if we should clean up the CSRF Token on authentication\n  mattr_accessor :clean_up_csrf_token_on_authentication\n  @@clean_up_csrf_token_on_authentication = true\n\n  # PRIVATE CONFIGURATION\n\n  # Store scopes mappings.\n  mattr_reader :mappings\n  @@mappings = ActiveSupport::OrderedHash.new\n\n  # OmniAuth configurations.\n  mattr_reader :omniauth_configs\n  @@omniauth_configs = ActiveSupport::OrderedHash.new\n\n  # Define a set of modules that are called when a mapping is added.\n  mattr_reader :helpers\n  @@helpers = Set.new\n  @@helpers << Devise::Controllers::Helpers\n\n  # Private methods to interface with Warden.\n  mattr_accessor :warden_config\n  @@warden_config = nil\n  @@warden_config_blocks = []\n\n  # When true, enter in paranoid mode to avoid user enumeration.\n  mattr_accessor :paranoid\n  @@paranoid = false\n\n  # When true, warn user if they just used next-to-last attempt of authentication\n  mattr_accessor :last_attempt_warning\n  @@last_attempt_warning = true\n\n  # Stores the token generator\n  mattr_accessor :token_generator\n  @@token_generator = nil\n\n  # Default way to setup Devise. Run rails generate devise_install to create\n  # a fresh initializer with all configuration values.\n  def self.setup\n    yield self\n  end\n\n  class Getter\n    def initialize name\n      @name = name\n    end\n\n    def get\n      ActiveSupport::Dependencies.constantize(@name)\n    end\n  end\n\n  def self.ref(arg)\n    if defined?(ActiveSupport::Dependencies::ClassCache)\n      ActiveSupport::Dependencies::reference(arg)\n      Getter.new(arg)\n    else\n      ActiveSupport::Dependencies.ref(arg)\n    end\n  end\n\n  def self.available_router_name\n    router_name || :main_app\n  end\n\n  def self.omniauth_providers\n    omniauth_configs.keys\n  end\n\n  # Get the mailer class from the mailer reference object.\n  def self.mailer\n    @@mailer_ref.get\n  end\n\n  # Set the mailer reference object to access the mailer.\n  def self.mailer=(class_name)\n    @@mailer_ref = ref(class_name)\n  end\n  self.mailer = \"Devise::Mailer\"\n\n  # Small method that adds a mapping to Devise.\n  def self.add_mapping(resource, options)\n    mapping = Devise::Mapping.new(resource, options)\n    @@mappings[mapping.name] = mapping\n    @@default_scope ||= mapping.name\n    @@helpers.each { |h| h.define_helpers(mapping) }\n    mapping\n  end\n\n  # Register available devise modules. For the standard modules that Devise provides, this method is\n  # called from lib/devise/modules.rb. Third-party modules need to be added explicitly using this method.\n  #\n  # Note that adding a module using this method does not cause it to be used in the authentication\n  # process. That requires that the module be listed in the arguments passed to the 'devise' method\n  # in the model class definition.\n  #\n  # == Options:\n  #\n  #   +model+      - String representing the load path to a custom *model* for this module (to autoload.)\n  #   +controller+ - Symbol representing the name of an existing or custom *controller* for this module.\n  #   +route+      - Symbol representing the named *route* helper for this module.\n  #   +strategy+   - Symbol representing if this module got a custom *strategy*.\n  #   +insert_at+  - Integer representing the order in which this module's model will be included\n  #\n  # All values, except :model, accept also a boolean and will have the same name as the given module\n  # name.\n  #\n  # == Examples:\n  #\n  #   Devise.add_module(:party_module)\n  #   Devise.add_module(:party_module, strategy: true, controller: :sessions)\n  #   Devise.add_module(:party_module, model: 'party_module/model')\n  #   Devise.add_module(:party_module, insert_at: 0)\n  #\n  def self.add_module(module_name, options = {})\n    options.assert_valid_keys(:strategy, :model, :controller, :route, :no_input, :insert_at)\n\n    ALL.insert (options[:insert_at] || -1), module_name\n\n    if strategy = options[:strategy]\n      strategy = (strategy == true ? module_name : strategy)\n      STRATEGIES[module_name] = strategy\n    end\n\n    if controller = options[:controller]\n      controller = (controller == true ? module_name : controller)\n      CONTROLLERS[module_name] = controller\n    end\n\n    NO_INPUT << strategy if options[:no_input]\n\n    if route = options[:route]\n      case route\n      when TrueClass\n        key, value = module_name, []\n      when Symbol\n        key, value = route, []\n      when Hash\n        key, value = route.keys.first, route.values.flatten\n      else\n        raise ArgumentError, \":route should be true, a Symbol or a Hash\"\n      end\n\n      URL_HELPERS[key] ||= []\n      URL_HELPERS[key].concat(value)\n      URL_HELPERS[key].uniq!\n\n      ROUTES[module_name] = key\n    end\n\n    if options[:model]\n      path = (options[:model] == true ? \"devise/models/#{module_name}\" : options[:model])\n      camelized = ActiveSupport::Inflector.camelize(module_name.to_s)\n      Devise::Models.send(:autoload, camelized.to_sym, path)\n    end\n\n    Devise::Mapping.add_module module_name\n  end\n\n  # Sets warden configuration using a block that will be invoked on warden\n  # initialization.\n  #\n  #  Devise.setup do |config|\n  #    config.allow_unconfirmed_access_for = 2.days\n  #\n  #    config.warden do |manager|\n  #      # Configure warden to use other strategies, like oauth.\n  #      manager.oauth(:twitter)\n  #    end\n  #  end\n  def self.warden(&block)\n    @@warden_config_blocks << block\n  end\n\n  # Specify an OmniAuth provider.\n  #\n  #   config.omniauth :github, APP_ID, APP_SECRET\n  #\n  def self.omniauth(provider, *args)\n    @@helpers << Devise::OmniAuth::UrlHelpers\n    config = Devise::OmniAuth::Config.new(provider, args)\n    @@omniauth_configs[config.strategy_name.to_sym] = config\n  end\n\n  # Include helpers in the given scope to AC and AV.\n  def self.include_helpers(scope)\n    ActiveSupport.on_load(:action_controller) do\n      include scope::Helpers if defined?(scope::Helpers)\n      include scope::UrlHelpers\n    end\n\n    ActiveSupport.on_load(:action_view) do\n      include scope::UrlHelpers\n    end\n  end\n\n  # Regenerates url helpers considering Devise.mapping\n  def self.regenerate_helpers!\n    Devise::Controllers::UrlHelpers.remove_helpers!\n    Devise::Controllers::UrlHelpers.generate_helpers!\n  end\n\n  # A method used internally to complete the setup of warden manager after routes are loaded.\n  # See lib/devise/rails/routes.rb - ActionDispatch::Routing::RouteSet#finalize_with_devise!\n  def self.configure_warden! #:nodoc:\n    @@warden_configured ||= begin\n      warden_config.failure_app   = Devise::Delegator.new\n      warden_config.default_scope = Devise.default_scope\n      warden_config.intercept_401 = false\n\n      Devise.mappings.each_value do |mapping|\n        warden_config.scope_defaults mapping.name, strategies: mapping.strategies\n\n        warden_config.serialize_into_session(mapping.name) do |record|\n          mapping.to.serialize_into_session(record)\n        end\n\n        warden_config.serialize_from_session(mapping.name) do |key|\n          # Previous versions contained an additional entry at the beginning of\n          # key with the record's class name.\n          args = key[-2, 2]\n          mapping.to.serialize_from_session(*args)\n        end\n      end\n\n      @@warden_config_blocks.map { |block| block.call Devise.warden_config }\n      true\n    end\n  end\n\n  # Generate a friendly string randomly to be used as token.\n  # By default, length is 20 characters.\n  def self.friendly_token(length = 20)\n    # To calculate real characters, we must perform this operation.\n    # See SecureRandom.urlsafe_base64\n    rlength = (length * 3) / 4\n    SecureRandom.urlsafe_base64(rlength).tr('lIO0', 'sxyz')\n  end\n\n  # constant-time comparison algorithm to prevent timing attacks\n  def self.secure_compare(a, b)\n    return false if a.blank? || b.blank? || a.bytesize != b.bytesize\n    l = a.unpack \"C#{a.bytesize}\"\n\n    res = 0\n    b.each_byte { |byte| res |= byte ^ l.shift }\n    res == 0\n  end\nend\n\nrequire 'warden'\nrequire 'devise/mapping'\nrequire 'devise/models'\nrequire 'devise/modules'\nrequire 'devise/rails'\n", "module Devise\n  module Controllers\n    # A module that may be optionally included in a controller in order\n    # to provide remember me behavior. Useful when signing in is done\n    # through a callback, like in OmniAuth.\n    module Rememberable\n      # Return default cookie values retrieved from session options.\n      def self.cookie_values\n        Rails.configuration.session_options.slice(:path, :domain, :secure)\n      end\n\n      # Remembers the given resource by setting up a cookie\n      def remember_me(resource)\n        return if env[\"devise.skip_storage\"]\n        scope = Devise::Mapping.find_scope!(resource)\n        resource.remember_me!\n        cookies.signed[remember_key(resource, scope)] = remember_cookie_values(resource)\n      end\n\n      # Forgets the given resource by deleting a cookie\n      def forget_me(resource)\n        scope = Devise::Mapping.find_scope!(resource)\n        resource.forget_me!\n        cookies.delete(remember_key(resource, scope), forget_cookie_values(resource))\n      end\n\n      protected\n\n      def forget_cookie_values(resource)\n        Devise::Controllers::Rememberable.cookie_values.merge!(resource.rememberable_options)\n      end\n\n      def remember_cookie_values(resource)\n        options = { httponly: true }\n        options.merge!(forget_cookie_values(resource))\n        options.merge!(\n          value: resource.class.serialize_into_cookie(resource),\n          expires: resource.remember_expires_at\n        )\n      end\n\n      def remember_key(resource, scope)\n        resource.rememberable_options.fetch(:key, \"remember_#{scope}_token\")\n      end\n    end\n  end\nend\n", "require 'devise/strategies/rememberable'\nrequire 'devise/hooks/rememberable'\nrequire 'devise/hooks/forgetable'\n\nmodule Devise\n  module Models\n    # Rememberable manages generating and clearing token for remember the user\n    # from a saved cookie. Rememberable also has utility methods for dealing\n    # with serializing the user into the cookie and back from the cookie, trying\n    # to lookup the record based on the saved information.\n    # You probably wouldn't use rememberable methods directly, they are used\n    # mostly internally for handling the remember token.\n    #\n    # == Options\n    #\n    # Rememberable adds the following options in devise_for:\n    #\n    #   * +remember_for+: the time you want the user will be remembered without\n    #     asking for credentials. After this time the user will be blocked and\n    #     will have to enter their credentials again. This configuration is also\n    #     used to calculate the expires time for the cookie created to remember\n    #     the user. By default remember_for is 2.weeks.\n    #\n    #   * +extend_remember_period+: if true, extends the user's remember period\n    #     when remembered via cookie. False by default.\n    #\n    #   * +rememberable_options+: configuration options passed to the created cookie.\n    #\n    # == Examples\n    #\n    #   User.find(1).remember_me!  # regenerating the token\n    #   User.find(1).forget_me!    # clearing the token\n    #\n    #   # generating info to put into cookies\n    #   User.serialize_into_cookie(user)\n    #\n    #   # lookup the user based on the incoming cookie information\n    #   User.serialize_from_cookie(cookie_string)\n    module Rememberable\n      extend ActiveSupport::Concern\n\n      attr_accessor :remember_me, :extend_remember_period\n\n      def self.required_fields(klass)\n        [:remember_created_at]\n      end\n\n      # TODO: We were used to receive a extend period argument but we no longer do.\n      # Remove this for Devise 4.0.\n      def remember_me!(*)\n        self.remember_token = self.class.remember_token if respond_to?(:remember_token)\n        self.remember_created_at ||= Time.now.utc\n        save(validate: false) if self.changed?\n      end\n\n      # If the record is persisted, remove the remember token (but only if\n      # it exists), and save the record without validations.\n      def forget_me!\n        return unless persisted?\n        self.remember_token = nil if respond_to?(:remember_token)\n        self.remember_created_at = nil if self.class.expire_all_remember_me_on_sign_out\n        save(validate: false)\n      end\n\n      def remember_expires_at\n        self.class.remember_for.from_now\n      end\n\n      def rememberable_value\n        if respond_to?(:remember_token)\n          remember_token\n        elsif respond_to?(:authenticatable_salt) && (salt = authenticatable_salt.presence)\n          salt\n        else\n          raise \"authenticable_salt returned nil for the #{self.class.name} model. \" \\\n            \"In order to use rememberable, you must ensure a password is always set \" \\\n            \"or have a remember_token column in your model or implement your own \" \\\n            \"rememberable_value in the model with custom logic.\"\n        end\n      end\n\n      def rememberable_options\n        self.class.rememberable_options\n      end\n\n      # A callback initiated after successfully being remembered. This can be\n      # used to insert your own logic that is only run after the user is\n      # remembered.\n      #\n      # Example:\n      #\n      #   def after_remembered\n      #     self.update_attribute(:invite_code, nil)\n      #   end\n      #\n      def after_remembered\n      end\n\n    protected\n\n      module ClassMethods\n        # Create the cookie key using the record id and remember_token\n        def serialize_into_cookie(record)\n          [record.to_key, record.rememberable_value, Time.now.utc]\n        end\n\n        # Recreate the user based on the stored cookie\n        def serialize_from_cookie(*args)\n          id, token, generated_at = args\n\n          # The token is only valid if:\n          # 1. we have a date\n          # 2. the current time does not pass the expiry period\n          # 3. there is a record with the given id\n          # 4. the record has a remember_created_at date\n          # 5. the token date is bigger than the remember_created_at\n          # 6. the token matches\n          if generated_at &&\n             (self.remember_for.ago < generated_at) &&\n             (record = to_adapter.get(id)) &&\n             (generated_at > (record.remember_created_at || Time.now).utc) &&\n             Devise.secure_compare(record.rememberable_value, token)\n            record\n          end\n        end\n\n        # Generate a token checking if one does not already exist in the database.\n        def remember_token #:nodoc:\n          loop do\n            token = Devise.friendly_token\n            break token unless to_adapter.find_first({ remember_token: token })\n          end\n        end\n\n        # TODO: extend_remember_period is no longer used\n        Devise::Models.config(self, :remember_for, :extend_remember_period, :rememberable_options, :expire_all_remember_me_on_sign_out)\n      end\n    end\n  end\nend\n", "require 'devise/hooks/timeoutable'\n\nmodule Devise\n  module Models\n    # Timeoutable takes care of verifying whether a user session has already\n    # expired or not. When a session expires after the configured time, the user\n    # will be asked for credentials again, it means, they will be redirected\n    # to the sign in page.\n    #\n    # == Options\n    #\n    # Timeoutable adds the following options to devise_for:\n    #\n    #   * +timeout_in+: the interval to timeout the user session without activity.\n    #\n    # == Examples\n    #\n    #   user.timedout?(30.minutes.ago)\n    #\n    module Timeoutable\n      extend ActiveSupport::Concern\n\n      def self.required_fields(klass)\n        []\n      end\n\n      # Checks whether the user session has expired based on configured time.\n      def timedout?(last_access)\n        !timeout_in.nil? && last_access && last_access <= timeout_in.ago\n      end\n\n      def timeout_in\n        self.class.timeout_in\n      end\n\n      private\n\n      module ClassMethods\n        Devise::Models.config(self, :timeout_in)\n      end\n    end\n  end\nend\n", "require 'test_helper'\n\nclass RememberMeTest < ActionDispatch::IntegrationTest\n  def create_user_and_remember(add_to_token='')\n    user = create_user\n    user.remember_me!\n    raw_cookie = User.serialize_into_cookie(user).tap { |a| a[1] << add_to_token }\n    cookies['remember_user_token'] = generate_signed_cookie(raw_cookie)\n    user\n  end\n\n  def generate_signed_cookie(raw_cookie)\n    request = ActionDispatch::TestRequest.new\n    request.cookie_jar.signed['raw_cookie'] = raw_cookie\n    request.cookie_jar['raw_cookie']\n  end\n\n  def signed_cookie(key)\n    controller.send(:cookies).signed[key]\n  end\n\n  def cookie_expires(key)\n    cookie  = response.headers[\"Set-Cookie\"].split(\"\\n\").grep(/^#{key}/).first\n    expires = cookie.split(\";\").map(&:strip).grep(/^expires=/).first\n    Time.parse(expires).utc\n  end\n\n  test 'do not remember the user if they have not checked remember me option' do\n    sign_in_as_user\n    assert_nil request.cookies[\"remember_user_cookie\"]\n  end\n\n  test 'handle unverified requests gets rid of caches' do\n    swap ApplicationController, allow_forgery_protection: true do\n      post exhibit_user_url(1)\n      assert_not warden.authenticated?(:user)\n\n      create_user_and_remember\n      post exhibit_user_url(1)\n      assert_equal \"User is not authenticated\", response.body\n      assert_not warden.authenticated?(:user)\n    end\n  end\n\n  test 'handle unverified requests does not create cookies on sign in' do\n    swap ApplicationController, allow_forgery_protection: true do\n      get new_user_session_path\n      assert request.session[:_csrf_token]\n\n      post user_session_path, authenticity_token: \"oops\", user:\n           { email: \"jose.valim@gmail.com\", password: \"123456\", remember_me: \"1\" }\n      assert_not warden.authenticated?(:user)\n      assert_not request.cookies['remember_user_token']\n    end\n  end\n\n  test 'generate remember token after sign in' do\n    sign_in_as_user remember_me: true\n    assert request.cookies['remember_user_token']\n  end\n\n  test 'generate remember token after sign in setting cookie options' do\n    # We test this by asserting the cookie is not sent after the redirect\n    # since we changed the domain. This is the only difference with the\n    # previous test.\n    swap Devise, rememberable_options: { domain: \"omg.somewhere.com\" } do\n      sign_in_as_user remember_me: true\n      assert_nil request.cookies[\"remember_user_token\"]\n    end\n  end\n\n  test 'generate remember token with a custom key' do\n    swap Devise, rememberable_options: { key: \"v1lat_token\" } do\n      sign_in_as_user remember_me: true\n      assert request.cookies[\"v1lat_token\"]\n    end\n  end\n\n  test 'generate remember token after sign in setting session options' do\n    begin\n      Rails.configuration.session_options[:domain] = \"omg.somewhere.com\"\n      sign_in_as_user remember_me: true\n      assert_nil request.cookies[\"remember_user_token\"]\n    ensure\n      Rails.configuration.session_options.delete(:domain)\n    end\n  end\n\n  test 'remember the user before sign in' do\n    user = create_user_and_remember\n    get users_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n    assert warden.user(:user) == user\n    assert_match /remember_user_token[^\\n]*HttpOnly/, response.headers[\"Set-Cookie\"], \"Expected Set-Cookie header in response to set HttpOnly flag on remember_user_token cookie.\"\n  end\n\n  test 'remember the user before sign up and redirect them to their home' do\n    create_user_and_remember\n    get new_user_registration_path\n    assert warden.authenticated?(:user)\n    assert_redirected_to root_path\n  end\n\n  test 'does not extend remember period through sign in' do\n    swap Devise, extend_remember_period: true, remember_for: 1.year do\n      user = create_user\n      user.remember_me!\n\n      user.remember_created_at = old = 10.days.ago\n      user.save\n\n      sign_in_as_user remember_me: true\n      user.reload\n\n      assert warden.user(:user) == user\n      assert_equal old.to_i, user.remember_created_at.to_i\n    end\n  end\n\n  test 'do not remember other scopes' do\n    create_user_and_remember\n    get root_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n    assert_not warden.authenticated?(:admin)\n  end\n\n  test 'do not remember with invalid token' do\n    create_user_and_remember('add')\n    get users_path\n    assert_not warden.authenticated?(:user)\n    assert_redirected_to new_user_session_path\n  end\n\n  test 'do not remember with expired token' do\n    create_user_and_remember\n    swap Devise, remember_for: 0.days do\n      get users_path\n      assert_not warden.authenticated?(:user)\n      assert_redirected_to new_user_session_path\n    end\n  end\n\n  test 'do not remember the user anymore after forget' do\n    create_user_and_remember\n    get users_path\n    assert warden.authenticated?(:user)\n\n    get destroy_user_session_path\n    assert_not warden.authenticated?(:user)\n    assert_nil warden.cookies['remember_user_token']\n\n    get users_path\n    assert_not warden.authenticated?(:user)\n  end\n\n  test 'changing user password expires remember me token' do\n    user = create_user_and_remember\n    user.password = \"another_password\"\n    user.password_confirmation = \"another_password\"\n    user.save!\n\n    get users_path\n    assert_not warden.authenticated?(:user)\n  end\n\n  test 'valid sign in calls after_remembered callback' do\n    user = create_user_and_remember\n\n    User.expects(:serialize_from_cookie).returns user\n    user.expects :after_remembered\n\n    get new_user_registration_path\n  end\nend\n", "require 'test_helper'\n\nclass SessionTimeoutTest < ActionDispatch::IntegrationTest\n\n  def last_request_at\n    @controller.user_session['last_request_at']\n  end\n\n  test 'set last request at in user session after each request' do\n    sign_in_as_user\n    assert_not_nil last_request_at\n\n    @controller.user_session.delete('last_request_at')\n    get users_path\n    assert_not_nil last_request_at\n  end\n\n  test 'set last request at in user session after each request is skipped if tracking is disabled' do\n    sign_in_as_user\n    old_last_request = last_request_at\n    assert_not_nil last_request_at\n\n    get users_path, {}, 'devise.skip_trackable' => true\n    assert_equal old_last_request, last_request_at\n  end\n\n  test 'does not set last request at in user session after each request if timeoutable is disabled' do\n    sign_in_as_user\n    old_last_request = last_request_at\n    assert_not_nil last_request_at\n\n    new_time = 2.seconds.from_now\n    Time.stubs(:now).returns(new_time)\n\n    get users_path, {}, 'devise.skip_timeoutable' => true\n    assert_equal old_last_request, last_request_at\n  end\n\n  test 'does not time out user session before default limit time' do\n    sign_in_as_user\n    assert_response :success\n    assert warden.authenticated?(:user)\n\n    get users_path\n    assert_response :success\n    assert warden.authenticated?(:user)\n  end\n\n  test 'time out user session after default limit time when sign_out_all_scopes is false' do\n    swap Devise, sign_out_all_scopes: false do\n      sign_in_as_admin\n\n      user = sign_in_as_user\n      get expire_user_path(user)\n      assert_not_nil last_request_at\n\n      get users_path\n      assert_redirected_to users_path\n      assert_not warden.authenticated?(:user)\n      assert warden.authenticated?(:admin)\n    end\n  end\n\n  test 'time out all sessions after default limit time when sign_out_all_scopes is true' do\n    swap Devise, sign_out_all_scopes: true do\n      sign_in_as_admin\n\n      user = sign_in_as_user\n      get expire_user_path(user)\n      assert_not_nil last_request_at\n\n      get root_path\n      assert_not warden.authenticated?(:user)\n      assert_not warden.authenticated?(:admin)\n    end\n  end\n\n  test 'time out user session after deault limit time and redirect to latest get request' do\n    user = sign_in_as_user\n    visit edit_form_user_path(user)\n\n    click_button 'Update'\n    sign_in_as_user\n\n    assert_equal edit_form_user_url(user), current_url\n  end\n\n  test 'time out is not triggered on sign out' do\n    user = sign_in_as_user\n    get expire_user_path(user)\n\n    get destroy_user_session_path\n\n    assert_response :redirect\n    assert_redirected_to root_path\n    follow_redirect!\n    assert_contain 'Signed out successfully'\n  end\n\n  test 'expired session is not extended by sign in page' do\n    user = sign_in_as_user\n    get expire_user_path(user)\n    assert warden.authenticated?(:user)\n\n    get \"/users/sign_in\"\n    assert_redirected_to \"/users/sign_in\"\n    follow_redirect!\n\n    assert_response :success\n    assert_contain 'Sign in'\n    assert_not warden.authenticated?(:user)\n  end\n\n  test 'time out is not triggered on sign in' do\n    user = sign_in_as_user\n    get expire_user_path(user)\n\n    post \"/users/sign_in\", email: user.email, password: \"123456\"\n\n    assert_response :redirect\n    follow_redirect!\n    assert_contain 'You are signed in'\n  end\n\n  test 'user configured timeout limit' do\n    swap Devise, timeout_in: 8.minutes do\n      user = sign_in_as_user\n\n      get users_path\n      assert_not_nil last_request_at\n      assert_response :success\n      assert warden.authenticated?(:user)\n\n      get expire_user_path(user)\n      get users_path\n      assert_redirected_to users_path\n      assert_not warden.authenticated?(:user)\n    end\n  end\n\n  test 'error message with i18n' do\n    store_translations :en, devise: {\n      failure: { user: { timeout: 'Session expired!' } }\n    } do\n      user = sign_in_as_user\n\n      get expire_user_path(user)\n      get root_path\n      follow_redirect!\n      assert_contain 'Session expired!'\n    end\n  end\n\n  test 'error message with i18n with double redirect' do\n    store_translations :en, devise: {\n      failure: { user: { timeout: 'Session expired!' } }\n    } do\n      user = sign_in_as_user\n\n      get expire_user_path(user)\n      get users_path\n      follow_redirect!\n      follow_redirect!\n      assert_contain 'Session expired!'\n    end\n  end\n\n  test 'does not crashes when the last_request_at is a String' do\n    user = sign_in_as_user\n\n    get edit_form_user_path(user, last_request_at: Time.now.utc.to_s)\n    get users_path\n  end\nend\n", "require 'test_helper'\n\nclass RememberableTest < ActiveSupport::TestCase\n  def resource_class\n    User\n  end\n\n  def create_resource\n    create_user\n  end\n\n  test 'remember_me should not generate a new token if using salt' do\n    user = create_user\n    user.expects(:valid?).never\n    user.remember_me!\n    assert user.remember_created_at\n  end\n\n  test 'forget_me should not clear remember token if using salt' do\n    user = create_user\n    user.remember_me!\n    user.expects(:valid?).never\n    user.forget_me!\n  end\n\n  test 'can generate remember token' do\n    user = create_user\n    user.singleton_class.send(:attr_accessor, :remember_token)\n    User.to_adapter.expects(:find_first).returns(nil)\n    user.remember_me!\n    assert user.remember_token\n  end\n\n  test 'serialize into cookie' do\n    user = create_user\n    user.remember_me!\n    id, token, date = User.serialize_into_cookie(user)\n    assert_equal id, user.to_key\n    assert_equal token, user.authenticatable_salt\n    assert date.is_a?(Time)\n  end\n\n  test 'serialize from cookie' do\n    user = create_user\n    user.remember_me!\n    assert_equal user, User.serialize_from_cookie(user.to_key, user.authenticatable_salt, Time.now.utc)\n  end\n\n  test 'serialize from cookie should return nil if no resource is found' do\n    assert_nil resource_class.serialize_from_cookie([0], \"123\", Time.now.utc)\n  end\n\n  test 'serialize from cookie should return nil if no timestamp' do\n    user = create_user\n    user.remember_me!\n    assert_nil User.serialize_from_cookie(user.to_key, user.authenticatable_salt)\n  end\n\n  test 'serialize from cookie should return nil if timestamp is earlier than token creation' do\n    user = create_user\n    user.remember_me!\n    assert_nil User.serialize_from_cookie(user.to_key, user.authenticatable_salt, 1.day.ago)\n  end\n\n  test 'serialize from cookie should return nil if timestamp is older than remember_for' do\n    user = create_user\n    user.remember_created_at = 1.month.ago\n    user.remember_me!\n    assert_nil User.serialize_from_cookie(user.to_key, user.authenticatable_salt, 3.weeks.ago)\n  end\n\n  test 'serialize from cookie me return nil if is a valid resource with invalid token' do\n    user = create_user\n    user.remember_me!\n    assert_nil User.serialize_from_cookie(user.to_key, \"123\", Time.now.utc)\n  end\n\n  test 'raises a RuntimeError if authenticatable_salt is nil or empty' do\n    user = User.new\n    def user.authenticable_salt; nil; end\n    assert_raise RuntimeError do\n      user.rememberable_value\n    end\n\n    user = User.new\n    def user.authenticable_salt; \"\"; end\n    assert_raise RuntimeError do\n      user.rememberable_value\n    end\n  end\n\n  test 'should respond to remember_me attribute' do\n    assert resource_class.new.respond_to?(:remember_me)\n    assert resource_class.new.respond_to?(:remember_me=)\n  end\n\n  test 'forget_me should clear remember_created_at if expire_all_remember_me_on_sign_out is true' do\n    swap Devise, expire_all_remember_me_on_sign_out: true do\n      resource = create_resource\n      resource.remember_me!\n      assert_not_nil resource.remember_created_at\n\n      resource.forget_me!\n      assert_nil resource.remember_created_at\n    end\n  end\n\n  test 'forget_me should not clear remember_created_at if expire_all_remember_me_on_sign_out is false' do\n    swap Devise, expire_all_remember_me_on_sign_out: false do\n      resource = create_resource\n      resource.remember_me!\n\n      assert_not_nil resource.remember_created_at\n\n      resource.forget_me!\n      assert_not_nil resource.remember_created_at\n    end\n  end\n\n  test 'forget_me should not try to update resource if it has been destroyed' do\n    resource = create_resource\n    resource.expects(:remember_created_at).never\n    resource.expects(:save).never\n\n    resource.destroy\n    resource.forget_me!\n  end\n\n  test 'remember expires at uses remember for configuration' do\n    swap Devise, remember_for: 3.days do\n      resource = create_resource\n      resource.remember_me!\n      assert_equal 3.days.from_now.to_date, resource.remember_expires_at.to_date\n\n      Devise.remember_for = 5.days\n      assert_equal 5.days.from_now.to_date, resource.remember_expires_at.to_date\n    end\n  end\n\n  test 'should have the required_fields array' do\n    assert_same_content Devise::Models::Rememberable.required_fields(User), [\n      :remember_created_at\n    ]\n  end\nend\n"], "filenames": ["lib/devise.rb", "lib/devise/controllers/rememberable.rb", "lib/devise/models/rememberable.rb", "lib/devise/models/timeoutable.rb", "test/integration/rememberable_test.rb", "test/integration/timeoutable_test.rb", "test/models/rememberable_test.rb"], "buggy_code_start_loc": [118, 16, 48, 29, 7, 168, 15], "buggy_code_end_loc": [118, 17, 137, 44, 139, 178, 199], "fixing_code_start_loc": [119, 16, 48, 28, 7, 167, 16], "fixing_code_end_loc": [120, 17, 136, 37, 139, 167, 139], "type": "CWE-312", "message": "The Devise gem before 3.5.4 for Ruby mishandles Remember Me cookies for sessions, which may allow an adversary to obtain unauthorized persistent application access.", "other": {"cve": {"id": "CVE-2015-8314", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-12T17:15:07.450", "lastModified": "2023-12-14T20:34:05.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Devise gem before 3.5.4 for Ruby mishandles Remember Me cookies for sessions, which may allow an adversary to obtain unauthorized persistent application access."}, {"lang": "es", "value": "Devise gem anterior a 3.5.4 para Ruby maneja mal las cookies Recordarme para las sesiones, lo que puede permitir que un adversario obtenga acceso persistente no autorizado a la aplicaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-312"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:heartcombo:devise:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "3.5.4", "matchCriteriaId": "693703F3-9D16-4FB7-930F-0FD309D1D3F4"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-746g-3gfp-hfhw", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/heartcombo/devise/commit/c92996646aba2d25b2c3e235fe0c4f1a84b70d24", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://rubysec.com/advisories/CVE-2015-8314/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/heartcombo/devise/commit/c92996646aba2d25b2c3e235fe0c4f1a84b70d24"}}