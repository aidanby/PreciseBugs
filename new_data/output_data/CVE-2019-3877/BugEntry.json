{"buggy_code": ["/*\n *\n *   auth_mellon_util.c: an authentication apache module\n *   Copyright \u00a9 2003-2007 UNINETT (http://www.uninett.no/)\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include <assert.h>\n\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\n#include \"auth_mellon.h\"\n\n#ifdef APLOG_USE_MODULE\nAPLOG_USE_MODULE(auth_mellon);\n#endif\n\n/* This function is used to get the url of the current request.\n *\n * Parameters:\n *  request_rec *r       The current request.\n *\n * Returns:\n *  A string containing the full url of the current request.\n *  The string is allocated from r->pool.\n */\nchar *am_reconstruct_url(request_rec *r)\n{\n    char *url;\n\n    /* This function will construct an full url for a given path relative to\n     * the root of the web site. To configure what hostname and port this\n     * function will use, see the UseCanonicalName configuration directive.\n     */\n    url = ap_construct_url(r->pool, r->unparsed_uri, r);\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"reconstruct_url: url==\\\"%s\\\", unparsed_uri==\\\"%s\\\"\", url,\n                  r->unparsed_uri);\n    return url;\n}\n\n/* Get the hostname of the current request.\n *\n * Parameters:\n *  request_rec *r       The current request.\n *\n * Returns:\n *  The hostname of the current request.\n */\nstatic const char *am_request_hostname(request_rec *r)\n{\n    const char *url;\n    apr_uri_t uri;\n    int ret;\n\n    url = am_reconstruct_url(r);\n\n    ret = apr_uri_parse(r->pool, url, &uri);\n    if (ret != APR_SUCCESS) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Failed to parse request URL: %s\", url);\n        return NULL;\n    }\n\n    if (uri.hostname == NULL) {\n        /* This shouldn't happen, since the request URL is built with a hostname,\n         * but log a message to make any debuggin around this code easier.\n         */\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No hostname in request URL: %s\", url);\n        return NULL;\n    }\n\n    return uri.hostname;\n}\n\n/* Validate the redirect URL.\n *\n * Checks that the redirect URL is to a trusted domain & scheme.\n *\n * Parameters:\n *  request_rec *r       The current request.\n *  const char *url      The redirect URL to validate.\n *\n * Returns:\n *  OK if the URL is valid, HTTP_BAD_REQUEST if not.\n */\nint am_validate_redirect_url(request_rec *r, const char *url)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n    apr_uri_t uri;\n    int ret;\n\n    ret = apr_uri_parse(r->pool, url, &uri);\n    if (ret != APR_SUCCESS) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid redirect URL: %s\", url);\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Sanity check of the scheme of the domain. We only allow http and https. */\n    if (uri.scheme) {\n        if (strcasecmp(uri.scheme, \"http\")\n            && strcasecmp(uri.scheme, \"https\")) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Only http or https scheme allowed in redirect URL: %s (%s)\",\n                          url, uri.scheme);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (!uri.hostname) {\n        return OK; /* No hostname to check. */\n    }\n\n    for (int i = 0; cfg->redirect_domains[i] != NULL; i++) {\n        const char *redirect_domain = cfg->redirect_domains[i];\n        if (!strcasecmp(redirect_domain, \"[self]\")) {\n            if (!strcasecmp(uri.hostname, am_request_hostname(r))) {\n                return OK;\n            }\n        } else if (apr_fnmatch(redirect_domain, uri.hostname,\n                               APR_FNM_PERIOD | APR_FNM_CASE_BLIND) ==\n                   APR_SUCCESS) {\n            return OK;\n        }\n    }\n    AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"Untrusted hostname (%s) in redirect URL: %s\",\n                  uri.hostname, url);\n    return HTTP_BAD_REQUEST;\n}\n\n/* This function builds an array of regexp backreferences\n *\n * Parameters:\n *  request_rec *r                 The current request.\n *  const am_cond_t *ce            The condition\n *  const char *value              Attribute value\n *  const ap_regmatch_t *regmatch  regmatch_t from ap_regexec()\n *\n * Returns:\n *  An array of collected backreference strings\n */\nconst apr_array_header_t *am_cond_backrefs(request_rec *r, \n                                           const am_cond_t *ce, \n                                           const char *value, \n                                           const ap_regmatch_t *regmatch)\n{\n    apr_array_header_t *backrefs;\n    const char **ref;\n    int nsub;\n    int i;\n\n    nsub = ce->regex->re_nsub + 1;     /* +1 for %0 */\n    backrefs = apr_array_make(r->pool, nsub, sizeof(const char *));\n    backrefs->nelts = nsub;\n\n    ref = (const char **)(backrefs->elts);\n\n    for (i = 0; i < nsub; i++) {\n        if ((regmatch[i].rm_so == -1) || (regmatch[i].rm_eo == -1)) {\n            ref[i] = \"\";\n        } else {\n            int len = regmatch[i].rm_eo - regmatch[i].rm_so;\n            int off = regmatch[i].rm_so;\n\n            ref[i] = apr_pstrndup(r->pool, value + off, len);\n        }\n    }\n\n    return (const apr_array_header_t *)backrefs;\n}\n\n/* This function clones an am_cond_t and substitute value to \n * match (both regexp and string) with backreferences from\n * a previous regex match.\n *\n * Parameters:\n *  request_rec *r                      The current request.\n *  const am_cond_t *cond               The am_cond_t to clone and substiture\n *  const apr_array_header_t *backrefs  Collected backreferences\n *\n * Returns:\n *  The cloned am_cond_t\n */\nconst am_cond_t *am_cond_substitue(request_rec *r, const am_cond_t *ce, \n                                   const apr_array_header_t *backrefs)\n{\n    am_cond_t *c;\n    const char *instr = ce->str;\n    apr_size_t inlen = strlen(instr);\n    const char *outstr = \"\";\n    size_t last;\n    size_t i;\n\n    c = (am_cond_t *)apr_pmemdup(r->pool, ce, sizeof(*ce));\n    last = 0;\n\n    for (i = strcspn(instr, \"%\"); i < inlen; i += strcspn(instr + i, \"%\")) {\n        const char *fstr;\n        const char *ns;\n        const char *name;\n        const char *value;\n        apr_size_t flen;\n        apr_size_t pad;\n        apr_size_t nslen;\n\n        /* \n         * Make sure we got a %\n         */\n\tassert(instr[i] == '%');\n\n        /*\n         * Copy the format string in fstr. It can be a single \n         * digit (e.g.: %1) , or a curly-brace enclosed text\n         * (e.g.: %{12})\n         */\n        fstr = instr + i + 1;\n        if (*fstr == '{') {          /* Curly-brace enclosed text */\n            pad = 3; /* 3 for %{} */\n            fstr++;\n            flen = strcspn(fstr, \"}\");\n\n            /* If there is no closing }, we do not substitute  */\n            if (fstr[flen] == '\\0') {\n                pad = 2; /* 2 for %{ */\n                i += flen + pad;\n                break;\n            }\n\n        } else if (*fstr == '\\0') {  /* String ending by a % */\n            break;\n\n        } else {                     /* Single digit */\n            pad = 1; /* 1 for % */\n            flen = 1;\n        }\n\n        /*\n         * Try to extract a namespace (ns) and a name, e.g: %{ENV:foo}\n         */ \n        fstr = apr_pstrndup(r->pool, fstr, flen);\n        if ((nslen = strcspn(fstr, \":\")) != flen) {\n            ns = apr_pstrndup(r->pool, fstr, nslen);\n            name = fstr + nslen + 1; /* +1 for : */\n        } else {\n            nslen = 0;\n            ns = \"\";\n            name = fstr;\n        }\n\n        value = NULL;\n        if ((*ns == '\\0') && (strspn(fstr, \"0123456789\") == flen) && (backrefs != NULL)) {\n            /*\n             * If fstr has only digits, this is a regexp backreference\n             */\n            int d = (int)apr_atoi64(fstr);\n\n            if ((d >= 0) && (d < backrefs->nelts)) \n                value = ((const char **)(backrefs->elts))[d];\n\n        } else if ((*ns == '\\0') && (strcmp(fstr, \"%\") == 0)) {\n            /*\n             * %-escape\n             */\n            value = fstr;\n\n        } else if (strcmp(ns, \"ENV\") == 0) {\n            /*\n             * ENV namespace. Get value from apache environment.\n             * This is akin to how Apache itself does it during expression evaluation.\n             */\n            value = apr_table_get(r->subprocess_env, name);\n            if (value == NULL) {\n                value = apr_table_get(r->notes, name);\n            }\n            if (value == NULL) {\n                value = getenv(name);\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"Resolving \\\"%s\\\" from ENV to \\\"%s\\\"\",\n                          name, value == NULL ? \"(nothing)\" : value);\n        }\n\n        /*\n         * If we did not find a value, substitue the\n         * format string with an empty string.\n         */\n         if (value == NULL)\n            value = \"\";\n\n        /*\n         * Concatenate the value with leading text, and * keep track \n         * of the last location we copied in source string\n         */\n        outstr = apr_pstrcat(r->pool, outstr,\n                             apr_pstrndup(r->pool, instr + last, i - last), \n                             value, NULL);\n        last = i + flen + pad;\n\n        /*\n         * Move index to the end of the format string\n         */\n        i += flen + pad;\n    }\n\n    /*\n     * Copy text remaining after the last format string.\n     */\n    outstr = apr_pstrcat(r->pool, outstr,\n                         apr_pstrndup(r->pool, instr + last, i - last), \n                         NULL);\n    c->str = outstr;\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"Directive %s, \\\"%s\\\" substituted into \\\"%s\\\"\",\n                  ce->directive, instr, outstr);\n\n    /*\n     * If this was a regexp, recompile it.\n     */\n    if (ce->flags & AM_COND_FLAG_REG) {\n        int regex_flags = AP_REG_EXTENDED|AP_REG_NOSUB;\n \n        if (ce->flags & AM_COND_FLAG_NC)\n            regex_flags |= AP_REG_ICASE;\n \n        c->regex = ap_pregcomp(r->pool, outstr, regex_flags);\n        if (c->regex == NULL) {\n             AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                           \"Invalid regular expression \\\"%s\\\"\", outstr);\n             return ce;\n        }\n    }\n\n    return (const am_cond_t *)c;\n}\n\n/* This function checks if the user has access according\n * to the MellonRequire and MellonCond directives.\n *\n * Parameters:\n *  request_rec *r              The current request.\n *  am_cache_entry_t *session   The current session.\n *\n * Returns:\n *  OK if the user has access and HTTP_FORBIDDEN if he doesn't.\n */\nint am_check_permissions(request_rec *r, am_cache_entry_t *session)\n{\n    am_dir_cfg_rec *dir_cfg;\n    int i, j;\n    int skip_or = 0;\n    const apr_array_header_t *backrefs = NULL;\n\n    dir_cfg = am_get_dir_cfg(r);\n\n    /* Iterate over all cond-directives */\n    for (i = 0; i < dir_cfg->cond->nelts; i++) {\n        const am_cond_t *ce;\n        const char *value = NULL;\n        int match = 0;\n\n        ce = &((am_cond_t *)(dir_cfg->cond->elts))[i];\n\n        am_diag_printf(r, \"%s processing condition %d of %d: %s \",\n                       __func__, i, dir_cfg->cond->nelts,\n                       am_diag_cond_str(r, ce));\n\n        /*\n         * Rule with ignore flog?\n         */\n        if (ce->flags & AM_COND_FLAG_IGN)\n            continue;\n\n        /* \n         * We matched a [OR] rule, skip the next rules\n         * until we have one without [OR]. \n         */\n        if (skip_or) {\n            if (!(ce->flags & AM_COND_FLAG_OR))\n                skip_or = 0;\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"Skip %s, [OR] rule matched previously\",\n                          ce->directive);\n\n            am_diag_printf(r, \"Skip, [OR] rule matched previously\\n\");\n            continue;\n        }\n        \n        /* \n         * look for a match on each value for this attribute, \n         * stop on first match.\n         */\n        for (j = 0; (j < session->size) && !match; j++) {\n            const char *varname = NULL;\n            am_envattr_conf_t *envattr_conf = NULL;\n\n            /*\n             * if MAP flag is set, check for remapped \n             * attribute name with mellonSetEnv\n             */\n            if (ce->flags & AM_COND_FLAG_MAP) {\n                envattr_conf =  (am_envattr_conf_t *)apr_hash_get(dir_cfg->envattr, \n                                         am_cache_entry_get_string(session,&session->env[j].varname),\n                                         APR_HASH_KEY_STRING);\n                                                    \n                if (envattr_conf != NULL)\n                    varname = envattr_conf->name;\n            }\n\n            /*\n             * Otherwise or if not found, use the attribute name\n             * sent by the IdP.\n             */\n            if (varname == NULL)\n                varname = am_cache_entry_get_string(session,\n                                                    &session->env[j].varname);\n                      \n            if (strcmp(varname, ce->varname) != 0)\n                    continue;\n\n            value = am_cache_entry_get_string(session, &session->env[j].value);\n\n            /*\n             * Substiture backrefs if available\n             */\n            if (ce->flags & AM_COND_FLAG_FSTR)\n                ce = am_cond_substitue(r, ce, backrefs);\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"Evaluate %s vs \\\"%s\\\"\", \n                          ce->directive, value);\n\n            am_diag_printf(r, \"evaluate value \\\"%s\\\" \", value);\n    \n            if (value == NULL) {\n                 match = 0;          /* can not happen */\n\n            } else if (ce->flags & (AM_COND_FLAG_REG|AM_COND_FLAG_REF)) {\n                 int nsub = ce->regex->re_nsub + 1;\n                 ap_regmatch_t *regmatch;\n\n                 regmatch = (ap_regmatch_t *)apr_palloc(r->pool, \n                            nsub * sizeof(*regmatch));\n\n                 match = !ap_regexec(ce->regex, value, nsub, regmatch, 0);\n                 if (match)\n                     backrefs = am_cond_backrefs(r, ce, value, regmatch);\n\n            } else if (ce->flags & AM_COND_FLAG_REG) {\n                 match = !ap_regexec(ce->regex, value, 0, NULL, 0);\n\n            } else if (ce->flags & (AM_COND_FLAG_SUB|AM_COND_FLAG_NC)) {\n                 match = (ap_strcasestr(ce->str, value) != NULL);\n\n            } else if (ce->flags & AM_COND_FLAG_SUB) {\n                 match = (strstr(ce->str, value) != NULL);\n\n            } else if (ce->flags & AM_COND_FLAG_NC) {\n                 match = !strcasecmp(ce->str, value);\n\n            } else {\n                 match = !strcmp(ce->str, value);\n            }\n\n        am_diag_printf(r, \"match=%s, \", match ? \"yes\" : \"no\");\n        }\n\n        if (ce->flags & AM_COND_FLAG_NOT) {\n            match = !match;\n\n            am_diag_printf(r, \"negating now match=%s \", match ? \"yes\" : \"no\");\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                      \"%s: %smatch\", ce->directive,\n                      (match == 0) ? \"no \": \"\");\n\n        /*\n         * If no match, we stop here, except if it is an [OR] condition\n         */\n        if (!match & !(ce->flags & AM_COND_FLAG_OR)) {\n            ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r,\n                          \"Client failed to match %s\",\n                          ce->directive);\n\n            am_diag_printf(r, \"failed (no OR condition)\"\n                           \" returning HTTP_FORBIDDEN\\n\");\n            return HTTP_FORBIDDEN;\n        }\n\n        /*\n         * Match on [OR] condition means we skip until a rule\n         * without [OR], \n         */\n        if (match && (ce->flags & AM_COND_FLAG_OR))\n            skip_or = 1;\n\n        am_diag_printf(r, \"\\n\");\n    }\n\n    am_diag_printf(r, \"%s succeeds\\n\", __func__);\n\n    return OK;\n}\n\n/* This function sets default Cache-Control headers.\n *\n * Parameters:\n *  request_rec *r       The request we are handling.\n *\n * Returns:\n *  Nothing.\n */\nvoid am_set_cache_control_headers(request_rec *r)\n{\n    /* Send Cache-Control header to ensure that:\n     * - no proxy in the path caches content inside this location (private),\n     * - user agent have to revalidate content on server (must-revalidate).\n     * - content is always stale as the session login status can change at any\n     *   time synchronously (Redirect logout, session cookie is removed) or\n     *   asynchronously (SOAP logout, session cookie still exists but is\n     *   invalid),\n     *\n     * But never prohibit specifically any user agent to cache or store content\n     *\n     * Setting the headers in err_headers_out ensures that they will be\n     * sent for all responses.\n     */\n    apr_table_setn(r->err_headers_out,\n                   \"Cache-Control\", \"private, max-age=0, must-revalidate\");\n}\n\n/* This function reads the post data for a request.\n *\n * The data is stored in a buffer allocated from the request pool.\n * After successful operation *data contains a pointer to the data and\n * *length contains the length of the data. \n * The data will always be null-terminated.\n *\n * Parameters:\n *  request_rec *r        The request we read the form data from.\n *  char **data           Pointer to where we will store the pointer\n *                        to the data we read.\n *  apr_size_t *length    Pointer to where we will store the length\n *                        of the data we read. Pass NULL if you don't\n *                        need to know the length of the data.\n *\n * Returns:\n *  OK if we successfully read the POST data.\n *  An error if we fail to read the data.\n */\nint am_read_post_data(request_rec *r, char **data, apr_size_t *length)\n{\n    apr_size_t bytes_read;\n    apr_size_t bytes_left;\n    apr_size_t len;\n    long read_length;\n    int rc;\n\n    /* Prepare to receive data from the client. We request that apache\n     * dechunks data if it is chunked.\n     */\n    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* This function will send a 100 Continue response if the client is\n     * waiting for that. If the client isn't going to send data, then this\n     * function will return 0.\n     */\n    if (!ap_should_client_block(r)) {\n        len = 0;\n    } else {\n        len = r->remaining;\n    }\n\n    if (len >= 1024*1024) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Too large POST data payload (%lu bytes).\",\n                      (unsigned long)len);\n        return HTTP_BAD_REQUEST;\n    }\n\n\n    if (length != NULL) {\n        *length = len;\n    }\n\n    *data = (char *)apr_palloc(r->pool, len + 1);\n    if (*data == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Failed to allocate memory for %lu bytes of POST data.\",\n                      (unsigned long)len);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* Make sure that the data is null-terminated.  */\n    (*data)[len] = '\\0';\n\n    bytes_read = 0;\n    bytes_left = len;\n\n    while (bytes_left > 0) {\n        /* Read data from the client. Returns 0 on EOF and -1 on\n         * error, the number of bytes otherwise.\n         */\n        read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                          bytes_left);\n        if (read_length == 0) {\n            /* got the EOF */\n            (*data)[bytes_read] = '\\0';\n\n            if (length != NULL) {\n                *length = bytes_read;\n            }\n            break;\n        }\n        else if (read_length < 0) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Failed to read POST data from client.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bytes_read += read_length;\n        bytes_left -= read_length;\n    }\n\n    am_diag_printf(r, \"POST data: %s\\n\", *data);\n    return OK;\n}\n\n\n/* extract_query_parameter is a function which extracts the value of\n * a given parameter in a query string. The query string can be the\n * query_string parameter of a GET request, or it can be the data\n * passed to the web server in a POST request.\n *\n * Parameters:\n *  apr_pool_t *pool           The memory pool which the memory for\n *                             the value will be allocated from.\n *  const char *query_string   Either the query_string from a GET\n *                             request, or the data from a POST\n *                             request.\n *  const char *name           The name of the parameter to extract.\n *                             Note that the search for this name is\n *                             case sensitive.\n *\n * Returns:\n *  The value of the parameter or NULL if we don't find the parameter.\n */\nchar *am_extract_query_parameter(apr_pool_t *pool,\n                                 const char *query_string,\n                                 const char *name)\n{\n    const char *ip;\n    const char *value_end;\n    apr_size_t namelen;\n\n    if (query_string == NULL) {\n        return NULL;\n    }\n\n    ip = query_string;\n    namelen = strlen(name);\n\n    /* Find parameter. Searches for /[^&]<name>[&=$]/.\n     * Moves ip to the first character after the name (either '&', '='\n     * or '\\0').\n     */\n    for (;;) {\n        /* First we find the name of the parameter. */\n        ip = strstr(ip, name);\n        if (ip == NULL) {\n            /* Parameter not found. */\n            return NULL;\n        }\n\n        /* Then we check what is before the parameter name. */\n        if (ip != query_string && ip[-1] != '&') {\n            /* Name not preceded by [^&]. */\n            ip++;\n            continue;\n        }\n\n        /* And last we check what follows the parameter name. */\n        if (ip[namelen] != '=' && ip[namelen] != '&'\n            && ip[namelen] != '\\0') {\n            /* Name not followed by [&=$]. */\n            ip++;\n            continue;\n        }\n\n\n        /* We have found the pattern. */\n        ip += namelen;\n        break;\n    }\n\n    /* Now ip points to the first character after the name. If this\n     * character is '&' or '\\0', then this field doesn't have a value.\n     * If this character is '=', then this field has a value.\n     */\n    if (ip[0] == '=') {\n        ip += 1;\n    }\n\n    /* The value is from ip to '&' or to the end of the string, whichever\n     * comes first. */\n    value_end = strchr(ip, '&');\n    if (value_end != NULL) {\n        /* '&' comes first. */\n        return apr_pstrndup(pool, ip, value_end - ip);\n    } else {\n        /* Value continues until the end of the string. */\n        return apr_pstrdup(pool, ip);\n    }\n}\n\n\n/* Convert a hexadecimal digit to an integer.\n *\n * Parameters:\n *  char c           The digit we should convert.\n *\n * Returns:\n *  The digit as an integer, or -1 if it isn't a hex digit.\n */\nstatic int am_unhex_digit(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 0xa;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 0xa;\n    } else {\n        return -1;\n    }\n}\n\n/* This function urldecodes a string in-place.\n *\n * Parameters:\n *  char *data       The string to urldecode.\n *\n * Returns:\n *  OK if successful or HTTP_BAD_REQUEST if any escape sequence decodes to a\n *  null-byte ('\\0'), or if an invalid escape sequence is found.\n */\nint am_urldecode(char *data)\n{\n    char *ip;\n    char *op;\n    int c1, c2;\n\n    if (data == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n\n    ip = data;\n    op = data;\n    while (*ip) {\n        switch (*ip) {\n        case '+':\n            *op = ' ';\n            ip++;\n            op++;\n            break;\n        case '%':\n            /* Decode the hex digits. Note that we need to check the\n             * result of the first conversion before attempting the\n             * second conversion -- otherwise we may read past the end\n             * of the string.\n             */\n            c1 = am_unhex_digit(ip[1]);\n            if (c1 < 0) {\n                return HTTP_BAD_REQUEST;\n            }\n            c2 = am_unhex_digit(ip[2]);\n            if (c2 < 0) {\n                return HTTP_BAD_REQUEST;\n            }\n\n            *op = (c1 << 4) | c2;\n            if (*op == '\\0') {\n                /* null-byte. */\n                return HTTP_BAD_REQUEST;\n            }\n            ip += 3;\n            op++;\n            break;\n        default:\n            *op = *ip;\n            ip++;\n            op++;\n        }\n    }\n    *op = '\\0';\n\n    return OK;\n}\n\n\n/* This function urlencodes a string. It will escape all characters\n * except a-z, A-Z, 0-9, '_' and '.'.\n *\n * Parameters:\n *  apr_pool_t *pool   The pool we should allocate memory from.\n *  const char *str    The string we should urlencode.\n *\n * Returns:\n *  The urlencoded string, or NULL if str == NULL.\n */\nchar *am_urlencode(apr_pool_t *pool, const char *str)\n{\n    const char *ip;\n    apr_size_t length;\n    char *ret;\n    char *op;\n    int hi, low;\n    /* Return NULL if str is NULL. */\n    if(str == NULL) {\n        return NULL;\n    }\n\n\n    /* Find the length of the output string. */\n    length = 0;\n    for(ip = str; *ip; ip++) {\n        if(*ip >= 'a' && *ip <= 'z') {\n            length++;\n        } else if(*ip >= 'A' && *ip <= 'Z') {\n            length++;\n        } else if(*ip >= '0' && *ip <= '9') {\n            length++;\n        } else if(*ip == '_' || *ip == '.') {\n            length++;\n        } else {\n            length += 3;\n        }\n    }\n\n    /* Add space for null-terminator. */\n    length++;\n\n    /* Allocate memory for string. */\n    ret = (char *)apr_palloc(pool, length);\n\n    /* Encode string. */\n    for(ip = str, op = ret; *ip; ip++, op++) {\n        if(*ip >= 'a' && *ip <= 'z') {\n            *op = *ip;\n        } else if(*ip >= 'A' && *ip <= 'Z') {\n            *op = *ip;\n        } else if(*ip >= '0' && *ip <= '9') {\n            *op = *ip;\n        } else if(*ip == '_' || *ip == '.') {\n            *op = *ip;\n        } else {\n            *op = '%';\n            op++;\n\n            hi = (*ip & 0xf0) >> 4;\n\n            if(hi < 0xa) {\n                *op = '0' + hi;\n            } else {\n                *op = 'A' + hi - 0xa;\n            }\n            op++;\n\n            low = *ip & 0x0f;\n\n            if(low < 0xa) {\n                *op = '0' + low;\n            } else {\n                *op = 'A' + low - 0xa;\n            }\n        }\n    }\n\n    /* Make output string null-terminated. */\n    *op = '\\0';\n\n    return ret;\n}\n\n/*\n * Check that a URL is safe for redirect.\n *\n * Parameters:\n *  request_rec *r       The request we are processing.\n *  const char *url      The URL we should check.\n *\n * Returns:\n *  OK on success, HTTP_BAD_REQUEST otherwise.\n */\nint am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}\n\n/* This function generates a given number of (pseudo)random bytes.\n * The current implementation uses OpenSSL's RAND_*-functions.\n *\n * Parameters:\n *  request_rec *r       The request we are generating random bytes for.\n *                       The request is used for configuration and\n *                       error/warning reporting.\n *  void *dest           The address if the buffer we should fill with data.\n *  apr_size_t count     The number of random bytes to create.\n *\n * Returns:\n *  OK on success, or HTTP_INTERNAL_SERVER on failure.\n */\nint am_generate_random_bytes(request_rec *r, void *dest, apr_size_t count)\n{\n    int rc;\n    rc = RAND_bytes((unsigned char *)dest, (int)count);\n    if(rc != 1) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error generating random data: %lu\",\n                      ERR_get_error());\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    return OK;\n}\n\n\n/* This function generates an id which is AM_ID_LENGTH characters long.\n * The id will consist of hexadecimal characters.\n *\n * Parameters:\n *  request_rec *r       The request we associate allocated memory with.\n *\n * Returns:\n *  The session id, made up of AM_ID_LENGTH hexadecimal characters,\n *  terminated by a null-byte.\n */\nchar *am_generate_id(request_rec *r)\n{\n    int rc;\n    char *ret;\n    int rand_data_len;\n    unsigned char *rand_data;\n    int i;\n    unsigned char b;\n    int hi, low;\n\n    ret = (char *)apr_palloc(r->pool, AM_ID_LENGTH + 1);\n\n    /* We need to round the length of the random data _up_, in case the\n     * length of the session id isn't even.\n     */\n    rand_data_len = (AM_ID_LENGTH + 1) / 2;\n\n    /* Fill the last rand_data_len bytes of the string with\n     * random bytes. This allows us to overwrite from the beginning of\n     * the string.\n     */\n    rand_data = (unsigned char *)&ret[AM_ID_LENGTH - rand_data_len];\n\n    /* Generate random numbers. */\n    rc = am_generate_random_bytes(r, rand_data, rand_data_len);\n    if(rc != OK) {\n        return NULL;\n    }\n\n    /* Convert the random bytes to hexadecimal. Note that we will write\n     * AM_ID_LENGTH+1 characters if we have a non-even length of the\n     * session id. This is OK - we will simply overwrite the last character\n     * with the null-terminator afterwards.\n     */\n    for(i = 0; i < AM_ID_LENGTH; i += 2) {\n        b = rand_data[i / 2];\n        hi = (b >> 4) & 0xf;\n        low = b & 0xf;\n\n        if(hi >= 0xa) {\n            ret[i] = 'a' + hi - 0xa;\n        } else {\n            ret[i] = '0' + hi;\n        }\n\n        if(low >= 0xa) {\n            ret[i+1] = 'a' + low - 0xa;\n        } else {\n            ret[i+1] = '0' + low;\n        }\n    }\n\n    /* Add null-terminator- */\n    ret[AM_ID_LENGTH] = '\\0';\n\n    return ret;\n}\n\n/* This returns the directroy part of a path, a la dirname(3)\n *\n * Parameters:\n *  apr_pool_t p         Pool to allocate memory from\n *  const char *path     Path to extract directory from\n *\n * Returns:\n *  The directory part of path\n */\nconst char *am_filepath_dirname(apr_pool_t *p, const char *path) \n{\n    char *cp;\n\n    /*\n     * Try Unix and then Windows style. Borrowed from\n     * apr_match_glob(), it seems it cannot be made more\n     * portable.\n     */\n    if (((cp = strrchr(path, (int)'/')) == NULL) &&\n        ((cp = strrchr(path, (int)'\\\\')) == NULL))\n            return \".\";\n   \n    return apr_pstrndup(p, path, cp - path);\n}\n\n/*\n * Allocate and initialize a am_file_data_t\n *\n * Parameters:\n *   apr_pool_t *pool  Allocation pool.\n *   const char *path  If non-NULL initialize file_data->path to copy of path\n *\n * Returns:\n *   Newly allocated & initialized file_data_t\n */\nam_file_data_t *am_file_data_new(apr_pool_t *pool, const char *path)\n{\n    am_file_data_t *file_data = NULL;\n\n    if ((file_data = apr_pcalloc(pool, sizeof(am_file_data_t))) == NULL) {\n        return NULL;\n    }\n\n    file_data->pool = pool;\n    file_data->rv = APR_EINIT;\n    if (path) {\n        file_data->path = apr_pstrdup(file_data->pool, path);\n    }\n\n    return file_data;\n}\n\n/*\n * Allocate a new am_file_data_t and copy\n *\n * Parameters:\n *   apr_pool_t *pool              Allocation pool.\n *   am_file_data_t *src_file_data The src being copied.\n *\n * Returns:\n *   Newly allocated & initialized from src_file_data\n */\nam_file_data_t *am_file_data_copy(apr_pool_t *pool,\n                                  am_file_data_t *src_file_data)\n{\n    am_file_data_t *dst_file_data = NULL;\n\n    if ((dst_file_data = am_file_data_new(pool, src_file_data->path)) == NULL) {\n        return NULL;\n    }\n\n    dst_file_data->path = apr_pstrdup(pool, src_file_data->path);\n    dst_file_data->stat_time = src_file_data->stat_time;\n    dst_file_data->finfo = src_file_data->finfo;\n    dst_file_data->contents = apr_pstrdup(pool, src_file_data->contents);\n    dst_file_data->read_time = src_file_data->read_time;\n    dst_file_data->rv = src_file_data->rv;\n    dst_file_data->strerror = apr_pstrdup(pool, src_file_data->strerror);\n    dst_file_data->generated = src_file_data->generated;\n\n    return dst_file_data;\n}\n\n/*\n * Peform a stat on a file to get it's properties\n *\n * A stat is performed on the file. If there was an error the\n * result value is left in file_data->rv and an error description\n * string is formatted and left in file_data->strerror and function\n * returns the rv value. If the stat was successful the stat\n * information is left in file_data->finfo and APR_SUCCESS\n * set set as file_data->rv and returned as the function result.\n * \n * The file_data->stat_time indicates if and when the stat was\n * performed, a zero time value indicates the operation has not yet\n * been performed.\n *\n * Parameters:\n *   am_file_data_t *file_data   Struct containing file information\n *\n * Returns:\n *   APR status code, same value as file_data->rv\n */\napr_status_t am_file_stat(am_file_data_t *file_data)\n{\n    char buffer[512];\n\n    if (file_data == NULL) {\n        return APR_EINVAL;\n    }\n\n    file_data->strerror = NULL;\n\n    file_data->stat_time = apr_time_now();\n    file_data->rv = apr_stat(&file_data->finfo, file_data->path,\n                             APR_FINFO_SIZE, file_data->pool);\n    if (file_data->rv != APR_SUCCESS) {\n        file_data->strerror =\n            apr_psprintf(file_data->pool,\n                         \"apr_stat: Error opening \\\"%s\\\" [%d] \\\"%s\\\"\",\n                         file_data->path, file_data->rv,\n                         apr_strerror(file_data->rv, buffer, sizeof(buffer)));\n    }\n\n    return file_data->rv;\n}\n\n/*\n * Read file into dynamically allocated buffer\n *\n * First a stat is performed on the file. If there was an error the\n * result value is left in file_data->rv and an error description\n * string is formatted and left in file_data->strerror and function\n * returns the rv value. If the stat was successful the stat\n * information is left in file_data->finfo.\n *\n * A buffer is dynamically allocated and the contents of the file is\n * read into file_data->contents. If there was an error the result\n * value is left in file_data->rv and an error description string is\n * formatted and left in file_data->strerror and the function returns\n * the rv value.\n *\n * The file_data->stat_time and file_data->read_time indicate if and\n * when those operations were performed, a zero time value indicates\n * the operation has not yet been performed.\n *\n * Parameters:\n *   am_file_data_t *file_data   Struct containing file information\n *\n * Returns:\n *   APR status code, same value as file_data->rv\n */\napr_status_t am_file_read(am_file_data_t *file_data)\n{\n    char buffer[512];\n    apr_file_t *fd;\n    apr_size_t nbytes;\n\n    if (file_data == NULL) {\n        return APR_EINVAL;\n    }\n    file_data->rv = APR_SUCCESS;\n    file_data->strerror = NULL;\n\n    am_file_stat(file_data);\n    if (file_data->rv != APR_SUCCESS) {\n        return file_data->rv;\n    }\n\n    if ((file_data->rv = apr_file_open(&fd, file_data->path,\n                                       APR_READ, 0, file_data->pool)) != 0) {\n        file_data->strerror =\n            apr_psprintf(file_data->pool,\n                         \"apr_file_open: Error opening \\\"%s\\\" [%d] \\\"%s\\\"\",\n                         file_data->path, file_data->rv,\n                         apr_strerror(file_data->rv, buffer, sizeof(buffer)));\n        return file_data->rv;\n    }\n\n    file_data->read_time = apr_time_now();\n    nbytes = file_data->finfo.size;\n    file_data->contents = (char *)apr_palloc(file_data->pool, nbytes + 1);\n\n    file_data->rv = apr_file_read_full(fd, file_data->contents, nbytes, NULL);\n    if (file_data->rv != 0) {\n        file_data->strerror =\n            apr_psprintf(file_data->pool,\n                         \"apr_file_read_full: Error reading \\\"%s\\\" [%d] \\\"%s\\\"\",\n                         file_data->path, file_data->rv,\n                         apr_strerror(file_data->rv, buffer, sizeof(buffer)));\n        (void)apr_file_close(fd);\n        return file_data->rv;\n\n    }\n    file_data->contents[nbytes] = '\\0';\n\n    (void)apr_file_close(fd);\n\n    return file_data->rv;\n}\n\n/*\n * Purge outdated saved POST requests.\n *\n * Parameters:\n *   request_rec *r     The current request\n *\n * Returns:\n *  OK on success, or HTTP_INTERNAL_SERVER on failure.\n */\nint am_postdir_cleanup(request_rec *r)\n{\n    am_mod_cfg_rec *mod_cfg;\n    apr_dir_t *postdir;\n    apr_status_t rv;\n    char error_buffer[64];\n    apr_finfo_t afi;\n    char *fname;\n    int count;\n    apr_time_t expire_before;\n\n    mod_cfg = am_get_mod_cfg(r->server);\n\n    /* The oldes file we should keep. Delete files that are older. */\n    expire_before = apr_time_now() - mod_cfg->post_ttl * APR_USEC_PER_SEC;\n\n    /*\n     * Open our POST directory or create it. \n     */\n    rv = apr_dir_open(&postdir, mod_cfg->post_dir, r->pool);\n    if (rv != 0) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to open MellonPostDirectory \\\"%s\\\": %s\",\n                      mod_cfg->post_dir,\n                      apr_strerror(rv, error_buffer, sizeof(error_buffer)));\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * Purge outdated items\n     */\n    count = 0;\n    do {\n        rv = apr_dir_read(&afi, APR_FINFO_NAME|APR_FINFO_CTIME, postdir);\n        if (rv != OK)\n            break;\n\n        /* Skip dot_files */\n        if (afi.name[0] == '.')\n             continue;\n\n        if (afi.ctime < expire_before) {\n            fname = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, afi.name);\n            (void)apr_file_remove(fname , r->pool); \n        } else {\n            count++;\n        }\n    } while (1 /* CONSTCOND */);\n\n    (void)apr_dir_close(postdir);\n\n    if (count >= mod_cfg->post_count) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Too many saved POST sessions. \"\n                      \"Increase MellonPostCount directive.\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    return OK;\n}\n\n/* \n * HTML-encode a string\n *\n * Parameters:\n *   request_rec *r     The current request\n *   const char *str    The string to encode\n *\n * Returns:\n *  The encoded string\n */\nchar *am_htmlencode(request_rec *r, const char *str)\n{\n    const char *cp;\n    char *output;\n    apr_size_t outputlen;\n    int i;\n\n    outputlen = 0;\n    for (cp = str; *cp; cp++) {\n        switch (*cp) {\n        case '&':\n            outputlen += 5;\n            break;\n        case '\"':\n            outputlen += 6;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n\n    i = 0;\n    output = apr_palloc(r->pool, outputlen + 1);\n    for (cp = str; *cp; cp++) {\n        switch (*cp) {\n        case '&':\n            (void)strcpy(&output[i], \"&amp;\");\n            i += 5;\n            break;\n        case '\"':\n            (void)strcpy(&output[i], \"&quot;\");\n            i += 6;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = '\\0';\n\n    return output;\n}\n\n/* This function produces the endpoint URL\n *\n * Parameters:\n *  request_rec *r       The request we received.\n *\n * Returns:\n *  the endpoint URL\n */\nchar *am_get_endpoint_url(request_rec *r)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n\n    return ap_construct_url(r->pool, cfg->endpoint_path, r);\n}\n\n/*\n * This function saves a POST request for later replay and updates\n * the return URL.\n *\n * Parameters:\n *  request_rec *r           The current request.\n *  const char **relay_state The returl URL\n *\n * Returns:\n *  OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise\n */\nint am_save_post(request_rec *r, const char **relay_state)\n{\n    am_mod_cfg_rec *mod_cfg;\n    const char *content_type;\n    const char *charset;\n    const char *psf_id;\n    char *psf_name;\n    char *post_data;\n    apr_size_t post_data_len;\n    apr_size_t written;\n    apr_file_t *psf;\n\n    mod_cfg = am_get_mod_cfg(r->server);\n    if (mod_cfg->post_dir == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"MellonPostReplay enabled but MellonPostDirectory not set \"\n                      \"-- cannot save post data\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (am_postdir_cleanup(r) != OK)\n        return HTTP_INTERNAL_SERVER_ERROR;\n\n    /* Check Content-Type */\n    content_type = apr_table_get(r->headers_in, \"Content-Type\");\n    if (content_type == NULL) {\n        content_type = \"urlencoded\";\n        charset = NULL; \n    } else {\n        if (am_has_header(r, content_type, \n            \"application/x-www-form-urlencoded\")) {\n            content_type = \"urlencoded\";\n\n        } else if (am_has_header(r, content_type,\n                   \"multipart/form-data\")) {\n            content_type = \"multipart\";\n\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Unknown POST Content-Type \\\"%s\\\"\", content_type);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        charset = am_get_header_attr(r, content_type, NULL, \"charset\");\n    }     \n\n    if ((psf_id = am_generate_id(r)) == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"cannot generate id\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    psf_name = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, psf_id);\n\n    if (apr_file_open(&psf, psf_name,\n                      APR_WRITE|APR_CREATE|APR_BINARY, \n                      APR_FPROT_UREAD|APR_FPROT_UWRITE,\n                      r->pool) != OK) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"cannot create POST session file\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    } \n\n    if (am_read_post_data(r, &post_data, &post_data_len) != OK) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"cannot read POST data\");\n        (void)apr_file_close(psf);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    } \n\n    if (post_data_len > mod_cfg->post_size) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"POST data size %\" APR_SIZE_T_FMT \n                      \" exceeds maximum %\" APR_SIZE_T_FMT \". \"\n                      \"Increase MellonPostSize directive.\",\n                      post_data_len, mod_cfg->post_size);\n        (void)apr_file_close(psf);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    written = post_data_len;\n    if ((apr_file_write(psf, post_data, &written) != OK) ||\n        (written != post_data_len)) { \n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"cannot write to POST session file\");\n            (void)apr_file_close(psf);\n            return HTTP_INTERNAL_SERVER_ERROR;\n    } \n    \n    if (apr_file_close(psf) != OK) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"cannot close POST session file\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (charset != NULL)\n        charset = apr_psprintf(r->pool, \"&charset=%s\", \n                               am_urlencode(r->pool, charset));\n    else \n        charset = \"\";\n\n    *relay_state = apr_psprintf(r->pool, \n                                \"%srepost?id=%s&ReturnTo=%s&enctype=%s%s\",\n                                am_get_endpoint_url(r), psf_id,\n                                am_urlencode(r->pool, *relay_state), \n                                content_type, charset);\n\n    return OK;\n}\n\n/*\n * This function replaces CRLF by LF in a string\n *\n * Parameters:\n *  request_rec *r  The current request\n *  const char *str The string\n *\n * Returns:\n *  Output string\n */\nconst char *am_strip_cr(request_rec *r, const char *str)\n{\n    char *output;\n    const char *cp;\n    apr_size_t i;\n\n    output = apr_palloc(r->pool, strlen(str) + 1);\n    i = 0;\n\n    for (cp = str; *cp; cp++) {\n        if ((*cp == '\\r') && (*(cp + 1) == '\\n'))\n            continue;\n        output[i++] = *cp;\n    }\n\n    output[i++] = '\\0';\n    \n    return (const char *)output;\n}\n\n/*\n * This function replaces LF by CRLF in a string\n *\n * Parameters:\n *  request_rec *r  The current request\n *  const char *str The string\n *\n * Returns:\n *  Output string\n */\nconst char *am_add_cr(request_rec *r, const char *str)\n{\n    char *output;\n    const char *cp;\n    apr_size_t xlen;\n    apr_size_t i;\n\n    xlen = 0;\n\n    for (cp = str; *cp; cp++)\n        if (*cp == '\\n')\n            xlen++;\n\n    output = apr_palloc(r->pool, strlen(str) + xlen + 1);\n    i = 0;\n\n    for (cp = str; *cp; cp++) {\n        if (*cp == '\\n')\n            output[i++] = '\\r';\n        output[i++] = *cp;\n    }\n\n    output[i++] = '\\0';\n    \n    return (const char *)output;\n}\n\n/*\n * This function tokenize a string, just like strtok_r, except that\n * the separator is a string instead of a character set.\n *\n * Parameters:\n *  const char *str The string to tokenize\n *  const char *sep The separator string\n *  char **last     Pointer to state (char *)\n *\n * Returns:\n *  OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise\n */\nconst char *am_xstrtok(request_rec *r, const char *str,\n                       const char *sep, char **last)\n{\n    char *s;\n    char *np;\n\n    /* Resume */\n    if (str != NULL)\n        s = apr_pstrdup(r->pool, str);\n    else\n        s = *last;\n\n    /* End of string */\n    if (*s == '\\0')\n        return NULL;\n\n    /* Next sep exists? */\n    if ((np = strstr(s, sep)) == NULL) {\n        *last = s + strlen(s);\n    } else {\n        *last = np + strlen(sep);\n        memset(np, 0, strlen(sep));\n    }\n\n    return s;\n}\n\n/* This function strips leading spaces and tabs from a string\n *\n * Parameters:\n *  const char **s       Pointer to the string\n *\n */\nvoid am_strip_blank(const char **s)\n{\n    while ((**s == ' ') || (**s == '\\t'))\n        (*s)++;\n    return;\n}\n\n/* This function extracts a MIME header from a MIME section\n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *m         The MIME section\n *  const char *h         The header to extract (case insensitive)\n *\n * Returns:\n *  The header value, or NULL on failure.\n */\nconst char *am_get_mime_header(request_rec *r, const char *m, const char *h) \n{\n    const char *line;\n    char *l1;\n    const char *value;\n    char *l2;\n\n    for (line = am_xstrtok(r, m, \"\\n\", &l1); line && *line; \n         line = am_xstrtok(r, NULL, \"\\n\", &l1)) {\n\n        am_strip_blank(&line);\n\n        if (((value = am_xstrtok(r, line, \":\", &l2)) != NULL) &&\n            (strcasecmp(value, h) == 0)) {\n            if ((value = am_xstrtok(r, NULL, \":\", &l2)) != NULL)\n                am_strip_blank(&value);\n            return value;\n        }\n   }\n   return NULL;\n}\n\n/* This function extracts an attribute from a header \n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *h         The header\n *  const char *v         Optional header value to check (case insensitive)\n *  const char *a         Optional attribute to extract (case insensitive)\n *\n * Returns:\n *   if i was provided, item value, or NULL on failure.\n *   if i is NULL, the whole header, or NULL on failure. This is\n *   useful for testing v.\n */\nconst char *am_get_header_attr(request_rec *r, const char *h,\n                               const char *v, const char *a) \n{\n    const char *value;\n    const char *attr;\n    char *l1;\n    const char *attr_value = NULL;\n\n    /* Looking for \n     * header-value; item_name=\"item_value\"\\n \n     */\n    if ((value = am_xstrtok(r, h, \";\", &l1)) == NULL)\n        return NULL;\n    am_strip_blank(&value);\n\n    /* If a header value was provided, check it */ \n    if ((v != NULL) && (strcasecmp(value, v) != 0))\n        return NULL;\n\n    /* If no attribute name is provided, return everything */\n    if (a == NULL)\n        return h;\n\n    while ((attr = am_xstrtok(r, NULL, \";\", &l1)) != NULL) {\n        const char *attr_name = NULL;\n        char *l2;\n\n        am_strip_blank(&attr);\n\n        attr_name = am_xstrtok(r, attr, \"=\", &l2); \n        if ((attr_name != NULL) && (strcasecmp(attr_name, a) == 0)) {\n            if ((attr_value = am_xstrtok(r, NULL, \"=\", &l2)) != NULL)\n                am_strip_blank(&attr_value);\n            break;\n        }\n    }\n  \n    /* Remove leading and trailing quotes */\n    if (attr_value != NULL) {\n        apr_size_t len; \n\n        len = strlen(attr_value);\n        if ((len > 1) && (attr_value[len - 1] == '\\\"'))\n            attr_value = apr_pstrndup(r->pool, attr_value, len - 1);\n        if (attr_value[0] == '\\\"')\n            attr_value++;\n    }\n    \n    return attr_value;\n}\n\n/* This function checks for a header name/value existence\n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *h         The header (case insensitive)\n *  const char *v         Optional header value to check (case insensitive)\n *\n * Returns:\n *   0 if header does not exists or does not has the value, 1 otherwise\n */\nint am_has_header(request_rec *r, const char *h, const char *v)\n{\n    return (am_get_header_attr(r, h, v, NULL) != NULL);\n}\n\n/* This function extracts the body from a MIME section\n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *mime      The MIME section\n *\n * Returns:\n *  The MIME section body, or NULL on failure.\n */\nconst char *am_get_mime_body(request_rec *r, const char *mime) \n{\n    const char lflf[] = \"\\n\\n\";\n    const char *body;\n    apr_size_t body_len;\n\n    if ((body = strstr(mime, lflf)) == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"No MIME body\");\n        return NULL;\n    }\n\n    body += strlen(lflf);\n\n    /* Strip tralling \\n */\n    if ((body_len = strlen(body)) >= 1) {\n        if (body[body_len - 1] == '\\n') \n            body = apr_pstrmemdup(r->pool, body, body_len - 1);\n    }\n\n    /* Turn back LF into CRLF */\n    return am_add_cr(r, body);\n}\n\n/* This function returns the URL for a given provider service (type + method)\n *\n * Parameters:\n *  request_rec *r        The request\n *  LassoProfile *profile Login profile\n *  char *endpoint_name   Service and method as specified in metadata\n *                        e.g.: \"SingleSignOnService HTTP-Redirect\"\n * Returns:\n *  The endpoint URL that must be freed by caller, or NULL on failure.\n */\nchar *\nam_get_service_url(request_rec *r, LassoProfile *profile, char *service_name)\n{\n    LassoProvider *provider;\n    gchar *url;\n\n    provider = lasso_server_get_provider(profile->server, \n                                         profile->remote_providerID);\n    if (LASSO_IS_PROVIDER(provider) == FALSE) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Cannot find provider service %s, no provider.\",\n                      service_name);\n\treturn NULL;\n    }\n\n    url = lasso_provider_get_metadata_one(provider, service_name);\n    if (url == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Cannot find provider service %s from metadata.\",\n                      service_name);\n\treturn NULL;\n    }\n\n    return url;\n}\n\n/*------------------------ Begin Token Parsing Code --------------------------*/\n\ntypedef enum {\n    TOKEN_WHITESPACE = 1,\n    TOKEN_SEMICOLON,\n    TOKEN_COMMA,\n    TOKEN_EQUAL,\n    TOKEN_IDENTIFIER,\n    TOKEN_DBL_QUOTE_STRING,\n} TokenType;\n\ntypedef struct {\n    TokenType type;             /* The type of this token */\n    char *str;                  /* The string value of the token */\n    apr_size_t len;             /* The number of characters in the token */\n    apr_size_t offset;          /* The offset from the beginning of\n                                   the string to the start of the token */\n} Token;\n\n\n#ifdef DEBUG\n/* Return string representation of TokenType enumeration\n *\n * Parameters:\n *  token_type  A TokenType enumeration\n * Returns:     String name of token_type\n */\nstatic const char *\ntoken_type_str(TokenType token_type)\n{\n    switch(token_type) {\n    case TOKEN_WHITESPACE:       return \"WHITESPACE\";\n    case TOKEN_SEMICOLON:        return \"SEMICOLON\";\n    case TOKEN_COMMA:            return \"COMMA\";\n    case TOKEN_EQUAL:            return \"EQUAL\";\n    case TOKEN_IDENTIFIER:       return \"IDENTIFIER\";\n    case TOKEN_DBL_QUOTE_STRING: return \"DBL_QUOTE_STRING\";\n    default:                     return \"unknown\";\n    }\n}\n\nstatic void dump_tokens(request_rec *r, apr_array_header_t *tokens)\n{\n    apr_size_t i;\n    \n    for (i = 0; i < tokens->nelts; i++) {\n        Token token = APR_ARRAY_IDX(tokens, i, Token);\n        AM_LOG_RERROR(APLOG_MARK, APLOG_DEBUG, 0, r,\n                      \"token[%2zd] %s \\\"%s\\\" offset=%lu len=%lu \", i,\n                      token_type_str(token.type), token.str,\n                      token.offset, token.len);\n    }\n}\n#endif\n\n\n/* Initialize token and add to list of tokens\n *\n * Utility to assist tokenize function.\n *\n * A token object is created and added to the end of the list of\n * tokens. It is initialized with the type of token, a copy of the\n * string, it's length, and it's offset from the beginning of the\n * string where it was found.\n *\n * Tokens with special processing needs are also handled here.\n *\n * A double quoted string will:\n *\n * * Have it's delimiting quotes removed.\n * * Will unescape escaped characters.\n *\n * Parameters:\n *  tokens  Array of Token objects.\n *  type    The type of the token (e.g. TokenType).\n *  str     The string the token was parsed from, used to compute\n *          the position of the token in the original string.\n *  start   The first character in the token.\n *  end     the last character in the token.\n */\nstatic inline void\npush_token(apr_array_header_t *tokens, TokenType type, const char *str,\n           const char *start, const char *end)\n{\n    apr_size_t offset = start - str;\n    Token *token = apr_array_push(tokens);\n\n    if (type == TOKEN_DBL_QUOTE_STRING) {\n        /* do not include quotes in token value */\n        start++; end--;\n    }\n\n    token->type = type;\n    token->len = end - start;\n    token->offset = offset;\n    token->str = apr_pstrmemdup(tokens->pool, start, token->len);\n\n    if (type == TOKEN_DBL_QUOTE_STRING) {\n        /*\n         * The original HTTP 1.1 spec was ambiguous with respect to\n         * backslash quoting inside double quoted strings. This has since\n         * been resolved in this errata:\n         *\n         * http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p1-messaging-16.html#rfc.section.3.2.3\n         *\n         * Which states:\n         *\n         * Recipients that process the value of the quoted-string MUST\n         * handle a quoted-pair as if it were replaced by the octet\n         * following the backslash.\n         *\n         * Senders SHOULD NOT escape octets in quoted-strings that do not\n         * require escaping (i.e., other than DQUOTE and the backslash\n         * octet).\n         */\n        char *p, *t;\n\n        for (p = token->str; *p; p++) {\n            if (p[0] == '\\\\' && p[1]) {\n                /*\n                 * Found backslash with following character.\n                 * Move rest of string down 1 character.\n                 */\n                for (t = p; *t; t++) {\n                    t[0] = t[1];\n                }\n                token->len--;\n            }\n        }\n    }\n}\n\n/* Break a string into a series of tokens\n *\n * Given a string return an array of tokens. If the string cannot be\n * successfully parsed an error string is returned at the location\n * specified by the error parameter, if error is NULL then the parsing\n * was successful. If an error occured the returned array of tokens\n * will include all tokens parsed up until where the unrecognized\n * input occurred. The input str is never modified.\n *\n * Parameters:\n *  pool              memory allocation pool\n *  str               input string to be parsed.\n *  ignore_whitespace if True whitespace tokens are not returned\n *  error             location where error string is returned\n *                    if NULL no error occurred\n * Returns:           array of Token objects\n */\nstatic apr_array_header_t *\ntokenize(apr_pool_t *pool, const char *str, bool ignore_whitespace,\n             char **error)\n{\n    apr_array_header_t *tokens = apr_array_make(pool, 10, sizeof(Token));\n    const char *p, *start;\n\n    *error = NULL;\n    p = start = str;\n    while(*p) {\n        if (apr_isspace(*p)) {  /* whitespace */\n            p++;\n            while(*p && apr_isspace(*p)) p++;\n            if (!ignore_whitespace) {\n                push_token(tokens, TOKEN_WHITESPACE, str, start, p);\n            }\n            start = p;\n        }\n        else if (apr_isalpha(*p)) { /* identifier: must begin with\n                                       alpha then any alphanumeric or\n                                       underscore */\n            p++;\n            while(*p && (apr_isalnum(*p) || *p == '_')) p++;\n            push_token(tokens, TOKEN_IDENTIFIER, str, start, p);\n            start = p;\n        }\n        else if (*p == '\"') {   /* double quoted string */\n            p++;                /* step over double quote */\n            while(*p) {\n                if (*p == '\\\\') { /* backslash escape */\n                    p++;          /* step over backslash */\n                    if (*p) {\n                        p++;      /* step over escaped character */\n                    } else {\n                        break;    /* backslash at end of string, stop */\n                    }\n                }\n                if (*p == '\\\"') break; /* terminating quote delimiter */\n                p++;                   /* keep scanning */\n            }\n            if (*p != '\\\"') {\n                *error = apr_psprintf(pool,\n                                      \"unterminated string beginning at \"\n                                      \"position %\" APR_SIZE_T_FMT \" in \\\"%s\\\"\",\n                                      start-str, str);\n                break;\n            }\n            p++;\n            push_token(tokens, TOKEN_DBL_QUOTE_STRING, str, start, p);\n            start = p;\n        }\n        else if (*p == '=') {   /* equals */\n            p++;\n            push_token(tokens, TOKEN_EQUAL, str, start, p);\n            start = p;\n        }\n        else if (*p == ',') {   /* comma */\n            p++;\n            push_token(tokens, TOKEN_COMMA, str, start, p);\n            start = p;\n        }\n        else if (*p == ';') {   /* semicolon */\n            p++;\n            push_token(tokens, TOKEN_SEMICOLON, str, start, p);\n            start = p;\n        }\n        else {                  /* unrecognized token */\n            *error = apr_psprintf(pool,\n                                  \"unknown token at \"\n                                  \"position %\" APR_SIZE_T_FMT \" in string \\\"%s\\\"\",\n                                  p-str, str);\n            break;\n        }\n    }\n\n    return tokens;\n}\n\n/* Test if the token is what we're looking for\n *\n * Given an index into the tokens array determine if the token type\n * matches. If the value parameter is non-NULL then the token's value\n * must also match. If the array index is beyond the last array item\n * false is returned.\n *\n * Parameters:\n *  tokens  Array of Token objects\n *  index   Index used to select the Token object from the Tokens array.\n *          If the index is beyond the last array item False is returned.\n *  type    The token type which must match\n *  value   If non-NULL then the token string value must be equal to this.\n * Returns: True if the token matches, False otherwise.\n */\n\nstatic bool\nis_token(apr_array_header_t *tokens, apr_size_t index, TokenType type, const char *value)\n{\n    if (index >= tokens->nelts) {\n        return false;\n    }\n\n    Token token = APR_ARRAY_IDX(tokens, index, Token);\n\n    if (token.type != type) {\n        return false;\n    }\n\n    if (value) {\n        if (!g_str_equal(token.str, value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/*------------------------- End Token Parsing Code ---------------------------*/\n\n/* Return message describing position an error when parsing.\n *\n * When parsing we expect tokens to appear in a certain sequence.  We\n * report the contents of the unexpected token and it's position in\n * the string. However if the parsing error is due to the fact we've\n * exhausted all tokens but are still expecting another token then our\n * error message indicates we reached the end of the string.\n *\n * Parameters:\n *  tokens  Array of Token objects.\n *  index   Index in tokens array where bad token was found\n */\nstatic inline const char *\nparse_error_msg(apr_array_header_t *tokens, apr_size_t index)\n{\n    if (index >= tokens->nelts) {\n        return \"end of string\";\n    }\n\n    return apr_psprintf(tokens->pool, \"\\\"%s\\\" at position %\" APR_SIZE_T_FMT,\n                        APR_ARRAY_IDX(tokens, index, Token).str,\n                        APR_ARRAY_IDX(tokens, index, Token).offset);\n}\n\n/* This function checks if an HTTP PAOS header is valid and\n * returns any service options which may have been specified.\n *\n * A PAOS header is composed of a mandatory PAOS version and service\n * values. A semicolon separates the version from the service values.\n *\n * Service values are delimited by semicolons, and options are\n * comma-delimited from the service value and each other.\n *\n * The PAOS version must be in the form ver=\"xxx\" (note the version\n * string must be in double quotes).\n *\n * The ECP service must be specified, it MAY be followed by optional\n * comma seperated options, all values must be in double quotes.\n *\n * ECP Service\n *   \"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\"\n *\n * Recognized Options:\n *\n * Support for channel bindings\n *  urn:oasis:names:tc:SAML:protocol:ext:channel-binding\n *\n * Support for Holder-of-Key subject confirmation\n *   urn:oasis:names:tc:SAML:2.0:cm:holder-of-key\n *\n * Request for signed SAML request\n *   urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:2.0:WantAuthnRequestsSigned\n *\n * Request to delegate credentials to the service provider\n *   urn:oasis:names:tc:SAML:2.0:conditions:delegation\n *\n *\n * Example PAOS HTTP header::\n *\n *   PAOS: ver=\"urn:liberty:paos:2003-08\";\n *     \"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\",\n *     \"urn:oasis:names:tc:SAML:protocol:ext:channel-binding\",\n *     \"urn:oasis:names:tc:SAML:2.0:cm:holder-of-key\"\n *\n * Parameters:\n *  request_rec *r              The request\n *  const char *header          The PAOS header value\n *  ECPServiceOptions *options_return\n *                              Pointer to location to receive options,\n *                              may be NULL. Bitmask of option flags.\n *\n * Returns:\n *   true if the PAOS header is valid, false otherwise. If options is non-NULL\n *   then the set of option flags is returned there.\n *\n */\nbool am_parse_paos_header(request_rec *r, const char *header,\n                             ECPServiceOptions *options_return)\n{\n    bool result = false;\n    ECPServiceOptions options = 0;\n    apr_array_header_t *tokens;\n    apr_size_t i;\n    char *error;\n\n    AM_LOG_RERROR(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"PAOS header: \\\"%s\\\"\", header);\n\n    tokens = tokenize(r->pool, header, true, &error);\n\n#ifdef DEBUG\n    dump_tokens(r, tokens);\n#endif\n\n    if (error) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"%s\", error);\n        goto cleanup;\n    }\n\n    /* Header must begin with \"ver=xxx\" where xxx is paos version */\n    if (!is_token(tokens, 0, TOKEN_IDENTIFIER, \"ver\") ||\n        !is_token(tokens, 1, TOKEN_EQUAL, NULL) ||\n        !is_token(tokens, 2, TOKEN_DBL_QUOTE_STRING, LASSO_PAOS_HREF)) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"invalid PAOS header, \"\n                      \"expected header to begin with ver=\\\"%s\\\", \"\n                      \"actual header=\\\"%s\\\"\",\n                      LASSO_PAOS_HREF, header);\n        goto cleanup;\n    }\n\n    /* Next is the service value, separated from the version by a semicolon */\n    if (!is_token(tokens, 3, TOKEN_SEMICOLON, NULL)) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                     \"invalid PAOS header, \"\n                     \"expected semicolon after PAOS version \"\n                     \"but found %s in header=\\\"%s\\\"\",\n                      parse_error_msg(tokens, 3),\n                      header);\n        goto cleanup;\n    }\n\n    if (!is_token(tokens, 4, TOKEN_DBL_QUOTE_STRING, LASSO_ECP_HREF)) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"invalid PAOS header, \"\n                      \"expected service token to be \\\"%s\\\", \"\n                      \"but found %s in header=\\\"%s\\\"\",\n                      LASSO_ECP_HREF,\n                      parse_error_msg(tokens, 4),\n                      header);\n        goto cleanup;\n    }\n\n    /* After the service value there may be optional flags separated by commas */\n\n    if (tokens->nelts == 5) {    /* no options */\n        result = true;\n        goto cleanup;\n    }\n\n    /* More tokens after the service value, must be options, iterate over them */\n    for (i = 5; i < tokens->nelts; i++) {\n        if (!is_token(tokens, i, TOKEN_COMMA, NULL)) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"invalid PAOS header, \"\n                          \"expected comma after PAOS service \"\n                          \"but found %s in header=\\\"%s\\\"\",\n                          parse_error_msg(tokens, i),\n                          header);\n            goto cleanup;\n        }\n\n        if (++i > tokens->nelts) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"invalid PAOS header, \"\n                          \"expected option after comma \"\n                          \"in header=\\\"%s\\\"\",\n                          header);\n            goto cleanup;\n        }\n\n        Token token = APR_ARRAY_IDX(tokens, i, Token);\n\n        if (token.type != TOKEN_DBL_QUOTE_STRING) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"invalid PAOS header, \"\n                          \"expected quoted string after comma \"\n                          \"but found %s in header=\\\"%s\\\"\",\n                          parse_error_msg(tokens, i),\n                          header);\n            goto cleanup;\n        }\n\n        /* Have an option string, convert it to a bit flag */\n        const char *value = token.str;\n\n        if (g_str_equal(value, LASSO_SAML_EXT_CHANNEL_BINDING)) {\n            options |= ECP_SERVICE_OPTION_CHANNEL_BINDING;\n        } else if (g_str_equal(value, LASSO_SAML2_CONFIRMATION_METHOD_HOLDER_OF_KEY)) {\n            options |= ECP_SERVICE_OPTION_HOLDER_OF_KEY;\n        } else if (g_str_equal(value, LASSO_SAML2_ECP_PROFILE_WANT_AUTHN_SIGNED)) {\n            options |= ECP_SERVICE_OPTION_WANT_AUTHN_SIGNED;\n        } else if (g_str_equal(value, LASSO_SAML2_CONDITIONS_DELEGATION)) {\n            options |= ECP_SERVICE_OPTION_DELEGATION;\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                          \"Unknown PAOS service option = \\\"%s\\\"\",\n                          value);\n            goto cleanup;\n        }\n    }\n\n    result = true;\n\n cleanup:\n    if (options_return) {\n        *options_return = options;\n    }\n    return result;\n\n}\n\n/* This function checks if Accept header has a media type\n *\n * Given an Accept header value like this:\n *\n * \"text/html,application/xhtml+xml,application/xml;q=0.9\"\n *\n * Parse the string and find name of each media type, ignore any parameters\n * bound to the name. Test to see if the name matches the input media_type.\n *\n * Parameters:\n *  request_rec *r         The request\n *  const char *header     The header value\n *  const char *media_type media type header value to check (case insensitive)\n *\n * Returns:\n *   true if media type is in header, false otherwise\n */\nbool am_header_has_media_type(request_rec *r, const char *header, const char *media_type)\n{\n    bool result = false;\n    char **comma_tokens = NULL;\n    char **media_ranges = NULL;\n    char *media_range = NULL;\n\n    if (header == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                     \"invalid Accept header, NULL\");\n        goto cleanup;\n    }\n\n    /*\n     * Split the header into a list of media_range tokens separated by\n     * a comma and iterate over the list.\n     */\n    comma_tokens = g_strsplit(header, \",\", 0);\n    for (media_ranges = comma_tokens, media_range = *media_ranges;\n         media_range;\n         media_range = *(++media_ranges)) {\n        char **semicolon_tokens = NULL;\n        char *name = NULL;\n\n        /*\n         * Split the media_range into a name and parameters, each\n         * separated by a semicolon. The first element in the list is\n         * the media_type name, subsequent params are optional and ignored.\n         */\n        media_range = g_strstrip(media_range);\n        semicolon_tokens = g_strsplit(media_range, \";\", 0);\n\n        /*\n         * Does the media_type match our required media_type?\n         * If so clean up and return success.\n         */\n        name = g_strstrip(semicolon_tokens[0]);\n        if (name && g_str_equal(name, media_type)) {\n            result = true;\n            g_strfreev(semicolon_tokens);\n            goto cleanup;\n        }\n        g_strfreev(semicolon_tokens);\n    }\n\n cleanup:\n    g_strfreev(comma_tokens);\n    return result;\n}\n\n/*\n * Lookup a config string in a specific language.  If lang is NULL and\n * the config string had been defined without a language qualifier\n * return the unqualified value.  If not found NULL is returned.\n */\nconst char *am_get_config_langstring(apr_hash_t *h, const char *lang)\n{\n    char *string;\n\n    if (lang == NULL) {\n        lang = \"\";\n    }\n\n    string = (char *)apr_hash_get(h, lang, APR_HASH_KEY_STRING);\n\n    return string;\n}\n\n/*\n * Get the value of boolean query parameter.\n *\n * Parameters:\n *  request_rec *r         The request\n *  const char *name       The name of the query parameter\n *  int *return_value      The address of the variable to receive\n *                         the boolean value\n *  int default_value      The value returned if parameter is absent or\n *                          in event of an error\n *\n * Returns:\n *   OK on success, HTTP error otherwise\n *\n * Looks for the named parameter in the query parameters, if found\n * parses the value which must be one of:\n *\n *   * true\n *   * false\n *\n * If value cannot be parsed HTTP_BAD_REQUEST is returned.\n *\n * If not found, or if there is an error, the returned value is set to\n * default_value.\n */\n\nint am_get_boolean_query_parameter(request_rec *r, const char *name,\n                                   int *return_value, int default_value)\n{\n    char *value_str;\n    int ret = OK;\n\n    *return_value = default_value;\n\n    value_str = am_extract_query_parameter(r->pool, r->args, name);\n    if (value_str != NULL) {\n        ret = am_urldecode(value_str);\n        if (ret != OK) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Error urldecoding \\\"%s\\\" boolean query parameter, \"\n                          \"value=\\\"%s\\\"\", name, value_str);\n            return ret;\n        }\n        if(!strcmp(value_str, \"true\")) {\n            *return_value = TRUE;\n        } else if(!strcmp(value_str, \"false\")) {\n            *return_value = FALSE;\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Invalid value for \\\"%s\\\" boolean query parameter, \"\n                          \"value=\\\"%s\\\"\", name, value_str);\n            ret = HTTP_BAD_REQUEST;\n        }\n    }\n\n    return ret;\n}\n\n/*\n * Get the URL of the AssertionConsumerServer having specific protocol\n * binding.\n *\n * Parameters:\n *  LassoProvider *provider The provider whose endpoints will be scanned.\n *  const char *binding     The required binding short name.\n *\n * Returns:\n *   The endpoint URL or NULL if not found. Must be freed with g_free().\n *\n * Lasso does not provide a public API to select a provider endpoint\n * by binding. The best we can do is iterate over a list of endpoint\n * descriptors and select a matching descriptor.\n *\n * Lasso does not document the format of these descriptor names but\n * essentially a descriptor is a space separated concatenation of the\n * endpoint properties. For SAML2 one can assume it is the endpoint\n * type, optionally followed by the protocol binding name, optionally\n * followd by the index (if the endpoint type is indexed). If the\n * endpoint is a response location then \"ResponseLocation\" will be\n * appended as the final token. For example here is a list of\n * descriptors returned for a service provider (note they are\n * unordered).\n *\n *    \"AssertionConsumerService HTTP-POST 0\"\n *    \"AuthnRequestsSigned\"\n *    \"AssertionConsumerService PAOS 2\"\n *    \"SingleLogoutService HTTP-Redirect\"\n *    \"SingleLogoutService SOAP\"\n *    \"AssertionConsumerService HTTP-Artifact 1\"\n *    \"NameIDFormat\"\n *    \"SingleLogoutService HTTP-POST ResponseLocation\"\n *\n * The possible binding names are:\n *\n *    \"SOAP\"\n *    \"HTTP-Redirect\"\n *    \"HTTP-POST\"\n *    \"HTTP-Artifact\"\n *    \"PAOS\"\n *    \"URI\"\n *\n * We know the AssertionConsumerService is indexed. If there is more\n * than one endpoint with the required binding we select the one with\n * the lowest index assuming it is preferred.\n */\n\nchar *am_get_assertion_consumer_service_by_binding(LassoProvider *provider, const char *binding)\n{\n    GList *descriptors;\n    char *url;\n    char *selected_descriptor;\n    char *descriptor;\n    char **tokens;\n    guint n_tokens;\n    GList *i;\n    char *endptr;\n    long descriptor_index, min_index;\n\n    url = NULL;\n    selected_descriptor = NULL;\n    min_index = LONG_MAX;\n\n    /* The descriptor list is unordered */\n    descriptors = lasso_provider_get_metadata_keys_for_role(provider,\n                                                            LASSO_PROVIDER_ROLE_SP);\n\n    for (i = g_list_first(descriptors), tokens=NULL;\n         i;\n         i = g_list_next(i), g_strfreev(tokens)) {\n\n        descriptor = i->data;\n        descriptor_index = LONG_MAX;\n\n        /*\n         * Split the descriptor into tokens, only consider descriptors\n         * which have at least 3 tokens and whose first token is\n         * AssertionConsumerService\n         */\n\n        tokens = g_strsplit(descriptor, \" \", 0);\n        n_tokens = g_strv_length(tokens);\n\n        if (n_tokens < 3) continue;\n\n        if (!g_str_equal(tokens[0], \"AssertionConsumerService\")) continue;\n        if (!g_str_equal(tokens[1], binding)) continue;\n\n        descriptor_index = strtol(tokens[2], &endptr, 10);\n        if (tokens[2] == endptr) continue; /* could not parse int */\n\n        if (descriptor_index < min_index) {\n            selected_descriptor = descriptor;\n            min_index = descriptor_index;\n        }\n    }\n\n    if (selected_descriptor) {\n        url = lasso_provider_get_metadata_one_for_role(provider,\n                                                       LASSO_PROVIDER_ROLE_SP,\n                                                       selected_descriptor);\n    }\n\n    lasso_release_list_of_strings(descriptors);\n\n    return url;\n}\n\n\n#ifdef HAVE_ECP\n\n/* String representation of ECPServiceOptions bitmask\n *\n * ECPServiceOptions is a bitmask of flags. Return a comma separated string\n * of all the flags. If any bit in the bitmask is unaccounted for an\n * extra string will be appended of the form \"(unknown bits = x)\".\n *\n * Parameters:\n *  pool    memory allocation pool\n *  options bitmask of PAOS options\n */\nchar *am_ecp_service_options_str(apr_pool_t *pool, ECPServiceOptions options)\n{\n    apr_array_header_t *names = apr_array_make(pool, 4, sizeof(const char *));\n\n    if (options & ECP_SERVICE_OPTION_CHANNEL_BINDING) {\n        APR_ARRAY_PUSH(names, const char *) = \"channel-binding\";\n        options &= ~ECP_SERVICE_OPTION_CHANNEL_BINDING;\n    }\n\n    if (options & ECP_SERVICE_OPTION_HOLDER_OF_KEY) {\n        APR_ARRAY_PUSH(names, const char *) = \"holder-of-key\";\n        options &= ~ECP_SERVICE_OPTION_HOLDER_OF_KEY;\n    }\n\n    if (options & ECP_SERVICE_OPTION_WANT_AUTHN_SIGNED) {\n        APR_ARRAY_PUSH(names, const char *) = \"want-authn-signed\";\n        options &= ~ECP_SERVICE_OPTION_WANT_AUTHN_SIGNED;\n    }\n\n    if (options & ECP_SERVICE_OPTION_DELEGATION) {\n        APR_ARRAY_PUSH(names, const char *) = \"delegation\";\n        options &= ~ECP_SERVICE_OPTION_DELEGATION;\n    }\n\n    if (options) {\n        APR_ARRAY_PUSH(names, const char *) =\n            apr_psprintf(pool, \"(unknown bits = %#x)\", options);\n    }\n\n    return apr_array_pstrcat(pool, names, ',');\n}\n\n/* Determine if request is compatible with PAOS, decode headers\n *\n * To indicate support for the ECP profile, and the PAOS binding, the\n * request MUST include the following HTTP header fields:\n *\n * 1. An Accept header indicating acceptance of the MIME type\n *    \"application/vnd.paos+xml\"\n *\n * 2. A PAOS header specifying the PAOS version with a value, at minimum, of\n *    \"urn:liberty:paos:2003-08\" and a supported service value of\n *    \"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\". The service value MAY\n *    contain option values.\n *\n * This function validates the Accept header the the PAOS header, if\n * all condidtions are met it returns true, false otherwise. If the\n * validation succeeds any ECP options specified along with the\n * ECP service are parsed and stored in req_cfg->ecp_service_options\n *\n * Any error discovered during processing are returned in the\n * error_code parameter, zero indicates success. This function never\n * returns true if an error occurred.\n *\n * Parameters:\n *  request_rec *r     The current request.\n *  int * error_code   Return error code here\n *\n */\nbool am_is_paos_request(request_rec *r, int *error_code)\n{\n    const char *accept_header = NULL;\n    const char *paos_header = NULL;\n    bool have_paos_media_type = false;\n    bool valid_paos_header = false;\n    bool is_paos = false;\n    ECPServiceOptions ecp_service_options = 0;\n\n    *error_code = 0;\n    accept_header = apr_table_get(r->headers_in, \"Accept\");\n    paos_header = apr_table_get(r->headers_in, \"PAOS\");\n    if (accept_header) {\n        if (am_header_has_media_type(r, accept_header, MEDIA_TYPE_PAOS)) {\n            have_paos_media_type = true;\n        }\n    }\n    if (paos_header) {\n        if (am_parse_paos_header(r, paos_header, &ecp_service_options)) {\n            valid_paos_header = true;\n        } else {\n            if (*error_code == 0)\n                *error_code = AM_ERROR_INVALID_PAOS_HEADER;\n        }\n    }\n    if (have_paos_media_type) {\n        if (valid_paos_header) {\n            is_paos = true;\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"request supplied PAOS media type in Accept header \"\n                          \"but omitted valid PAOS header\");\n            if (*error_code == 0)\n                *error_code = AM_ERROR_MISSING_PAOS_HEADER;\n        }\n    } else {\n        if (valid_paos_header) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"request supplied valid PAOS header \"\n                          \"but omitted PAOS media type in Accept header\");\n            if (*error_code == 0)\n                *error_code = AM_ERROR_MISSING_PAOS_MEDIA_TYPE;\n        }\n    }\n    AM_LOG_RERROR(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"have_paos_media_type=%s valid_paos_header=%s is_paos=%s \"\n                  \"error_code=%d ecp options=[%s]\",\n                  have_paos_media_type ? \"True\" : \"False\",\n                  valid_paos_header ? \"True\" : \"False\",\n                  is_paos ? \"True\" : \"False\",\n                  *error_code,\n                  am_ecp_service_options_str(r->pool, ecp_service_options));\n\n    if (is_paos) {\n        am_req_cfg_rec *req_cfg;\n\n        req_cfg = am_get_req_cfg(r);\n        req_cfg->ecp_service_options = ecp_service_options;\n    }\n\n    return is_paos;\n}\n#endif /* HAVE_ECP */\n\nchar *\nam_saml_response_status_str(request_rec *r, LassoNode *node)\n{\n    LassoSamlp2StatusResponse *response = (LassoSamlp2StatusResponse*)node;\n    LassoSamlp2Status *status = NULL;\n    const char *status_code1 = NULL;\n    const char *status_code2 = NULL;\n\n    if (!LASSO_IS_SAMLP2_STATUS_RESPONSE(response)) {\n        return apr_psprintf(r->pool,\n                            \"error, expected LassoSamlp2StatusResponse \"\n                            \"but got %s\",\n                            lasso_node_get_name((LassoNode*)response));\n    }\n\n    status = response->Status;\n    if (status == NULL                  ||\n        !LASSO_IS_SAMLP2_STATUS(status) ||\n        status->StatusCode == NULL      ||\n        status->StatusCode->Value == NULL) {\n        return apr_psprintf(r->pool, \"Status missing\");\n\n    }\n\n    status_code1 = status->StatusCode->Value;\n    if (status->StatusCode->StatusCode) {\n        status_code2 = status->StatusCode->StatusCode->Value;\n    }\n\n    return apr_psprintf(r->pool,\n                        \"StatusCode1=\\\"%s\\\", StatusCode2=\\\"%s\\\", \"\n                        \"StatusMessage=\\\"%s\\\"\",\n                        status_code1, status_code2, status->StatusMessage);\n}\n"], "fixing_code": ["/*\n *\n *   auth_mellon_util.c: an authentication apache module\n *   Copyright \u00a9 2003-2007 UNINETT (http://www.uninett.no/)\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include <assert.h>\n\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\n#include \"auth_mellon.h\"\n\n#ifdef APLOG_USE_MODULE\nAPLOG_USE_MODULE(auth_mellon);\n#endif\n\n/* This function is used to get the url of the current request.\n *\n * Parameters:\n *  request_rec *r       The current request.\n *\n * Returns:\n *  A string containing the full url of the current request.\n *  The string is allocated from r->pool.\n */\nchar *am_reconstruct_url(request_rec *r)\n{\n    char *url;\n\n    /* This function will construct an full url for a given path relative to\n     * the root of the web site. To configure what hostname and port this\n     * function will use, see the UseCanonicalName configuration directive.\n     */\n    url = ap_construct_url(r->pool, r->unparsed_uri, r);\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"reconstruct_url: url==\\\"%s\\\", unparsed_uri==\\\"%s\\\"\", url,\n                  r->unparsed_uri);\n    return url;\n}\n\n/* Get the hostname of the current request.\n *\n * Parameters:\n *  request_rec *r       The current request.\n *\n * Returns:\n *  The hostname of the current request.\n */\nstatic const char *am_request_hostname(request_rec *r)\n{\n    const char *url;\n    apr_uri_t uri;\n    int ret;\n\n    url = am_reconstruct_url(r);\n\n    ret = apr_uri_parse(r->pool, url, &uri);\n    if (ret != APR_SUCCESS) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Failed to parse request URL: %s\", url);\n        return NULL;\n    }\n\n    if (uri.hostname == NULL) {\n        /* This shouldn't happen, since the request URL is built with a hostname,\n         * but log a message to make any debuggin around this code easier.\n         */\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No hostname in request URL: %s\", url);\n        return NULL;\n    }\n\n    return uri.hostname;\n}\n\n/* Validate the redirect URL.\n *\n * Checks that the redirect URL is to a trusted domain & scheme.\n *\n * Parameters:\n *  request_rec *r       The current request.\n *  const char *url      The redirect URL to validate.\n *\n * Returns:\n *  OK if the URL is valid, HTTP_BAD_REQUEST if not.\n */\nint am_validate_redirect_url(request_rec *r, const char *url)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n    apr_uri_t uri;\n    int ret;\n\n    ret = apr_uri_parse(r->pool, url, &uri);\n    if (ret != APR_SUCCESS) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid redirect URL: %s\", url);\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Sanity check of the scheme of the domain. We only allow http and https. */\n    if (uri.scheme) {\n        if (strcasecmp(uri.scheme, \"http\")\n            && strcasecmp(uri.scheme, \"https\")) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Only http or https scheme allowed in redirect URL: %s (%s)\",\n                          url, uri.scheme);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (!uri.hostname) {\n        return OK; /* No hostname to check. */\n    }\n\n    for (int i = 0; cfg->redirect_domains[i] != NULL; i++) {\n        const char *redirect_domain = cfg->redirect_domains[i];\n        if (!strcasecmp(redirect_domain, \"[self]\")) {\n            if (!strcasecmp(uri.hostname, am_request_hostname(r))) {\n                return OK;\n            }\n        } else if (apr_fnmatch(redirect_domain, uri.hostname,\n                               APR_FNM_PERIOD | APR_FNM_CASE_BLIND) ==\n                   APR_SUCCESS) {\n            return OK;\n        }\n    }\n    AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                  \"Untrusted hostname (%s) in redirect URL: %s\",\n                  uri.hostname, url);\n    return HTTP_BAD_REQUEST;\n}\n\n/* This function builds an array of regexp backreferences\n *\n * Parameters:\n *  request_rec *r                 The current request.\n *  const am_cond_t *ce            The condition\n *  const char *value              Attribute value\n *  const ap_regmatch_t *regmatch  regmatch_t from ap_regexec()\n *\n * Returns:\n *  An array of collected backreference strings\n */\nconst apr_array_header_t *am_cond_backrefs(request_rec *r, \n                                           const am_cond_t *ce, \n                                           const char *value, \n                                           const ap_regmatch_t *regmatch)\n{\n    apr_array_header_t *backrefs;\n    const char **ref;\n    int nsub;\n    int i;\n\n    nsub = ce->regex->re_nsub + 1;     /* +1 for %0 */\n    backrefs = apr_array_make(r->pool, nsub, sizeof(const char *));\n    backrefs->nelts = nsub;\n\n    ref = (const char **)(backrefs->elts);\n\n    for (i = 0; i < nsub; i++) {\n        if ((regmatch[i].rm_so == -1) || (regmatch[i].rm_eo == -1)) {\n            ref[i] = \"\";\n        } else {\n            int len = regmatch[i].rm_eo - regmatch[i].rm_so;\n            int off = regmatch[i].rm_so;\n\n            ref[i] = apr_pstrndup(r->pool, value + off, len);\n        }\n    }\n\n    return (const apr_array_header_t *)backrefs;\n}\n\n/* This function clones an am_cond_t and substitute value to \n * match (both regexp and string) with backreferences from\n * a previous regex match.\n *\n * Parameters:\n *  request_rec *r                      The current request.\n *  const am_cond_t *cond               The am_cond_t to clone and substiture\n *  const apr_array_header_t *backrefs  Collected backreferences\n *\n * Returns:\n *  The cloned am_cond_t\n */\nconst am_cond_t *am_cond_substitue(request_rec *r, const am_cond_t *ce, \n                                   const apr_array_header_t *backrefs)\n{\n    am_cond_t *c;\n    const char *instr = ce->str;\n    apr_size_t inlen = strlen(instr);\n    const char *outstr = \"\";\n    size_t last;\n    size_t i;\n\n    c = (am_cond_t *)apr_pmemdup(r->pool, ce, sizeof(*ce));\n    last = 0;\n\n    for (i = strcspn(instr, \"%\"); i < inlen; i += strcspn(instr + i, \"%\")) {\n        const char *fstr;\n        const char *ns;\n        const char *name;\n        const char *value;\n        apr_size_t flen;\n        apr_size_t pad;\n        apr_size_t nslen;\n\n        /* \n         * Make sure we got a %\n         */\n\tassert(instr[i] == '%');\n\n        /*\n         * Copy the format string in fstr. It can be a single \n         * digit (e.g.: %1) , or a curly-brace enclosed text\n         * (e.g.: %{12})\n         */\n        fstr = instr + i + 1;\n        if (*fstr == '{') {          /* Curly-brace enclosed text */\n            pad = 3; /* 3 for %{} */\n            fstr++;\n            flen = strcspn(fstr, \"}\");\n\n            /* If there is no closing }, we do not substitute  */\n            if (fstr[flen] == '\\0') {\n                pad = 2; /* 2 for %{ */\n                i += flen + pad;\n                break;\n            }\n\n        } else if (*fstr == '\\0') {  /* String ending by a % */\n            break;\n\n        } else {                     /* Single digit */\n            pad = 1; /* 1 for % */\n            flen = 1;\n        }\n\n        /*\n         * Try to extract a namespace (ns) and a name, e.g: %{ENV:foo}\n         */ \n        fstr = apr_pstrndup(r->pool, fstr, flen);\n        if ((nslen = strcspn(fstr, \":\")) != flen) {\n            ns = apr_pstrndup(r->pool, fstr, nslen);\n            name = fstr + nslen + 1; /* +1 for : */\n        } else {\n            nslen = 0;\n            ns = \"\";\n            name = fstr;\n        }\n\n        value = NULL;\n        if ((*ns == '\\0') && (strspn(fstr, \"0123456789\") == flen) && (backrefs != NULL)) {\n            /*\n             * If fstr has only digits, this is a regexp backreference\n             */\n            int d = (int)apr_atoi64(fstr);\n\n            if ((d >= 0) && (d < backrefs->nelts)) \n                value = ((const char **)(backrefs->elts))[d];\n\n        } else if ((*ns == '\\0') && (strcmp(fstr, \"%\") == 0)) {\n            /*\n             * %-escape\n             */\n            value = fstr;\n\n        } else if (strcmp(ns, \"ENV\") == 0) {\n            /*\n             * ENV namespace. Get value from apache environment.\n             * This is akin to how Apache itself does it during expression evaluation.\n             */\n            value = apr_table_get(r->subprocess_env, name);\n            if (value == NULL) {\n                value = apr_table_get(r->notes, name);\n            }\n            if (value == NULL) {\n                value = getenv(name);\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"Resolving \\\"%s\\\" from ENV to \\\"%s\\\"\",\n                          name, value == NULL ? \"(nothing)\" : value);\n        }\n\n        /*\n         * If we did not find a value, substitue the\n         * format string with an empty string.\n         */\n         if (value == NULL)\n            value = \"\";\n\n        /*\n         * Concatenate the value with leading text, and * keep track \n         * of the last location we copied in source string\n         */\n        outstr = apr_pstrcat(r->pool, outstr,\n                             apr_pstrndup(r->pool, instr + last, i - last), \n                             value, NULL);\n        last = i + flen + pad;\n\n        /*\n         * Move index to the end of the format string\n         */\n        i += flen + pad;\n    }\n\n    /*\n     * Copy text remaining after the last format string.\n     */\n    outstr = apr_pstrcat(r->pool, outstr,\n                         apr_pstrndup(r->pool, instr + last, i - last), \n                         NULL);\n    c->str = outstr;\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"Directive %s, \\\"%s\\\" substituted into \\\"%s\\\"\",\n                  ce->directive, instr, outstr);\n\n    /*\n     * If this was a regexp, recompile it.\n     */\n    if (ce->flags & AM_COND_FLAG_REG) {\n        int regex_flags = AP_REG_EXTENDED|AP_REG_NOSUB;\n \n        if (ce->flags & AM_COND_FLAG_NC)\n            regex_flags |= AP_REG_ICASE;\n \n        c->regex = ap_pregcomp(r->pool, outstr, regex_flags);\n        if (c->regex == NULL) {\n             AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                           \"Invalid regular expression \\\"%s\\\"\", outstr);\n             return ce;\n        }\n    }\n\n    return (const am_cond_t *)c;\n}\n\n/* This function checks if the user has access according\n * to the MellonRequire and MellonCond directives.\n *\n * Parameters:\n *  request_rec *r              The current request.\n *  am_cache_entry_t *session   The current session.\n *\n * Returns:\n *  OK if the user has access and HTTP_FORBIDDEN if he doesn't.\n */\nint am_check_permissions(request_rec *r, am_cache_entry_t *session)\n{\n    am_dir_cfg_rec *dir_cfg;\n    int i, j;\n    int skip_or = 0;\n    const apr_array_header_t *backrefs = NULL;\n\n    dir_cfg = am_get_dir_cfg(r);\n\n    /* Iterate over all cond-directives */\n    for (i = 0; i < dir_cfg->cond->nelts; i++) {\n        const am_cond_t *ce;\n        const char *value = NULL;\n        int match = 0;\n\n        ce = &((am_cond_t *)(dir_cfg->cond->elts))[i];\n\n        am_diag_printf(r, \"%s processing condition %d of %d: %s \",\n                       __func__, i, dir_cfg->cond->nelts,\n                       am_diag_cond_str(r, ce));\n\n        /*\n         * Rule with ignore flog?\n         */\n        if (ce->flags & AM_COND_FLAG_IGN)\n            continue;\n\n        /* \n         * We matched a [OR] rule, skip the next rules\n         * until we have one without [OR]. \n         */\n        if (skip_or) {\n            if (!(ce->flags & AM_COND_FLAG_OR))\n                skip_or = 0;\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"Skip %s, [OR] rule matched previously\",\n                          ce->directive);\n\n            am_diag_printf(r, \"Skip, [OR] rule matched previously\\n\");\n            continue;\n        }\n        \n        /* \n         * look for a match on each value for this attribute, \n         * stop on first match.\n         */\n        for (j = 0; (j < session->size) && !match; j++) {\n            const char *varname = NULL;\n            am_envattr_conf_t *envattr_conf = NULL;\n\n            /*\n             * if MAP flag is set, check for remapped \n             * attribute name with mellonSetEnv\n             */\n            if (ce->flags & AM_COND_FLAG_MAP) {\n                envattr_conf =  (am_envattr_conf_t *)apr_hash_get(dir_cfg->envattr, \n                                         am_cache_entry_get_string(session,&session->env[j].varname),\n                                         APR_HASH_KEY_STRING);\n                                                    \n                if (envattr_conf != NULL)\n                    varname = envattr_conf->name;\n            }\n\n            /*\n             * Otherwise or if not found, use the attribute name\n             * sent by the IdP.\n             */\n            if (varname == NULL)\n                varname = am_cache_entry_get_string(session,\n                                                    &session->env[j].varname);\n                      \n            if (strcmp(varname, ce->varname) != 0)\n                    continue;\n\n            value = am_cache_entry_get_string(session, &session->env[j].value);\n\n            /*\n             * Substiture backrefs if available\n             */\n            if (ce->flags & AM_COND_FLAG_FSTR)\n                ce = am_cond_substitue(r, ce, backrefs);\n\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                          \"Evaluate %s vs \\\"%s\\\"\", \n                          ce->directive, value);\n\n            am_diag_printf(r, \"evaluate value \\\"%s\\\" \", value);\n    \n            if (value == NULL) {\n                 match = 0;          /* can not happen */\n\n            } else if (ce->flags & (AM_COND_FLAG_REG|AM_COND_FLAG_REF)) {\n                 int nsub = ce->regex->re_nsub + 1;\n                 ap_regmatch_t *regmatch;\n\n                 regmatch = (ap_regmatch_t *)apr_palloc(r->pool, \n                            nsub * sizeof(*regmatch));\n\n                 match = !ap_regexec(ce->regex, value, nsub, regmatch, 0);\n                 if (match)\n                     backrefs = am_cond_backrefs(r, ce, value, regmatch);\n\n            } else if (ce->flags & AM_COND_FLAG_REG) {\n                 match = !ap_regexec(ce->regex, value, 0, NULL, 0);\n\n            } else if (ce->flags & (AM_COND_FLAG_SUB|AM_COND_FLAG_NC)) {\n                 match = (ap_strcasestr(ce->str, value) != NULL);\n\n            } else if (ce->flags & AM_COND_FLAG_SUB) {\n                 match = (strstr(ce->str, value) != NULL);\n\n            } else if (ce->flags & AM_COND_FLAG_NC) {\n                 match = !strcasecmp(ce->str, value);\n\n            } else {\n                 match = !strcmp(ce->str, value);\n            }\n\n        am_diag_printf(r, \"match=%s, \", match ? \"yes\" : \"no\");\n        }\n\n        if (ce->flags & AM_COND_FLAG_NOT) {\n            match = !match;\n\n            am_diag_printf(r, \"negating now match=%s \", match ? \"yes\" : \"no\");\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                      \"%s: %smatch\", ce->directive,\n                      (match == 0) ? \"no \": \"\");\n\n        /*\n         * If no match, we stop here, except if it is an [OR] condition\n         */\n        if (!match & !(ce->flags & AM_COND_FLAG_OR)) {\n            ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r,\n                          \"Client failed to match %s\",\n                          ce->directive);\n\n            am_diag_printf(r, \"failed (no OR condition)\"\n                           \" returning HTTP_FORBIDDEN\\n\");\n            return HTTP_FORBIDDEN;\n        }\n\n        /*\n         * Match on [OR] condition means we skip until a rule\n         * without [OR], \n         */\n        if (match && (ce->flags & AM_COND_FLAG_OR))\n            skip_or = 1;\n\n        am_diag_printf(r, \"\\n\");\n    }\n\n    am_diag_printf(r, \"%s succeeds\\n\", __func__);\n\n    return OK;\n}\n\n/* This function sets default Cache-Control headers.\n *\n * Parameters:\n *  request_rec *r       The request we are handling.\n *\n * Returns:\n *  Nothing.\n */\nvoid am_set_cache_control_headers(request_rec *r)\n{\n    /* Send Cache-Control header to ensure that:\n     * - no proxy in the path caches content inside this location (private),\n     * - user agent have to revalidate content on server (must-revalidate).\n     * - content is always stale as the session login status can change at any\n     *   time synchronously (Redirect logout, session cookie is removed) or\n     *   asynchronously (SOAP logout, session cookie still exists but is\n     *   invalid),\n     *\n     * But never prohibit specifically any user agent to cache or store content\n     *\n     * Setting the headers in err_headers_out ensures that they will be\n     * sent for all responses.\n     */\n    apr_table_setn(r->err_headers_out,\n                   \"Cache-Control\", \"private, max-age=0, must-revalidate\");\n}\n\n/* This function reads the post data for a request.\n *\n * The data is stored in a buffer allocated from the request pool.\n * After successful operation *data contains a pointer to the data and\n * *length contains the length of the data. \n * The data will always be null-terminated.\n *\n * Parameters:\n *  request_rec *r        The request we read the form data from.\n *  char **data           Pointer to where we will store the pointer\n *                        to the data we read.\n *  apr_size_t *length    Pointer to where we will store the length\n *                        of the data we read. Pass NULL if you don't\n *                        need to know the length of the data.\n *\n * Returns:\n *  OK if we successfully read the POST data.\n *  An error if we fail to read the data.\n */\nint am_read_post_data(request_rec *r, char **data, apr_size_t *length)\n{\n    apr_size_t bytes_read;\n    apr_size_t bytes_left;\n    apr_size_t len;\n    long read_length;\n    int rc;\n\n    /* Prepare to receive data from the client. We request that apache\n     * dechunks data if it is chunked.\n     */\n    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* This function will send a 100 Continue response if the client is\n     * waiting for that. If the client isn't going to send data, then this\n     * function will return 0.\n     */\n    if (!ap_should_client_block(r)) {\n        len = 0;\n    } else {\n        len = r->remaining;\n    }\n\n    if (len >= 1024*1024) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Too large POST data payload (%lu bytes).\",\n                      (unsigned long)len);\n        return HTTP_BAD_REQUEST;\n    }\n\n\n    if (length != NULL) {\n        *length = len;\n    }\n\n    *data = (char *)apr_palloc(r->pool, len + 1);\n    if (*data == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Failed to allocate memory for %lu bytes of POST data.\",\n                      (unsigned long)len);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* Make sure that the data is null-terminated.  */\n    (*data)[len] = '\\0';\n\n    bytes_read = 0;\n    bytes_left = len;\n\n    while (bytes_left > 0) {\n        /* Read data from the client. Returns 0 on EOF and -1 on\n         * error, the number of bytes otherwise.\n         */\n        read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                          bytes_left);\n        if (read_length == 0) {\n            /* got the EOF */\n            (*data)[bytes_read] = '\\0';\n\n            if (length != NULL) {\n                *length = bytes_read;\n            }\n            break;\n        }\n        else if (read_length < 0) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Failed to read POST data from client.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bytes_read += read_length;\n        bytes_left -= read_length;\n    }\n\n    am_diag_printf(r, \"POST data: %s\\n\", *data);\n    return OK;\n}\n\n\n/* extract_query_parameter is a function which extracts the value of\n * a given parameter in a query string. The query string can be the\n * query_string parameter of a GET request, or it can be the data\n * passed to the web server in a POST request.\n *\n * Parameters:\n *  apr_pool_t *pool           The memory pool which the memory for\n *                             the value will be allocated from.\n *  const char *query_string   Either the query_string from a GET\n *                             request, or the data from a POST\n *                             request.\n *  const char *name           The name of the parameter to extract.\n *                             Note that the search for this name is\n *                             case sensitive.\n *\n * Returns:\n *  The value of the parameter or NULL if we don't find the parameter.\n */\nchar *am_extract_query_parameter(apr_pool_t *pool,\n                                 const char *query_string,\n                                 const char *name)\n{\n    const char *ip;\n    const char *value_end;\n    apr_size_t namelen;\n\n    if (query_string == NULL) {\n        return NULL;\n    }\n\n    ip = query_string;\n    namelen = strlen(name);\n\n    /* Find parameter. Searches for /[^&]<name>[&=$]/.\n     * Moves ip to the first character after the name (either '&', '='\n     * or '\\0').\n     */\n    for (;;) {\n        /* First we find the name of the parameter. */\n        ip = strstr(ip, name);\n        if (ip == NULL) {\n            /* Parameter not found. */\n            return NULL;\n        }\n\n        /* Then we check what is before the parameter name. */\n        if (ip != query_string && ip[-1] != '&') {\n            /* Name not preceded by [^&]. */\n            ip++;\n            continue;\n        }\n\n        /* And last we check what follows the parameter name. */\n        if (ip[namelen] != '=' && ip[namelen] != '&'\n            && ip[namelen] != '\\0') {\n            /* Name not followed by [&=$]. */\n            ip++;\n            continue;\n        }\n\n\n        /* We have found the pattern. */\n        ip += namelen;\n        break;\n    }\n\n    /* Now ip points to the first character after the name. If this\n     * character is '&' or '\\0', then this field doesn't have a value.\n     * If this character is '=', then this field has a value.\n     */\n    if (ip[0] == '=') {\n        ip += 1;\n    }\n\n    /* The value is from ip to '&' or to the end of the string, whichever\n     * comes first. */\n    value_end = strchr(ip, '&');\n    if (value_end != NULL) {\n        /* '&' comes first. */\n        return apr_pstrndup(pool, ip, value_end - ip);\n    } else {\n        /* Value continues until the end of the string. */\n        return apr_pstrdup(pool, ip);\n    }\n}\n\n\n/* Convert a hexadecimal digit to an integer.\n *\n * Parameters:\n *  char c           The digit we should convert.\n *\n * Returns:\n *  The digit as an integer, or -1 if it isn't a hex digit.\n */\nstatic int am_unhex_digit(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 0xa;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 0xa;\n    } else {\n        return -1;\n    }\n}\n\n/* This function urldecodes a string in-place.\n *\n * Parameters:\n *  char *data       The string to urldecode.\n *\n * Returns:\n *  OK if successful or HTTP_BAD_REQUEST if any escape sequence decodes to a\n *  null-byte ('\\0'), or if an invalid escape sequence is found.\n */\nint am_urldecode(char *data)\n{\n    char *ip;\n    char *op;\n    int c1, c2;\n\n    if (data == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n\n    ip = data;\n    op = data;\n    while (*ip) {\n        switch (*ip) {\n        case '+':\n            *op = ' ';\n            ip++;\n            op++;\n            break;\n        case '%':\n            /* Decode the hex digits. Note that we need to check the\n             * result of the first conversion before attempting the\n             * second conversion -- otherwise we may read past the end\n             * of the string.\n             */\n            c1 = am_unhex_digit(ip[1]);\n            if (c1 < 0) {\n                return HTTP_BAD_REQUEST;\n            }\n            c2 = am_unhex_digit(ip[2]);\n            if (c2 < 0) {\n                return HTTP_BAD_REQUEST;\n            }\n\n            *op = (c1 << 4) | c2;\n            if (*op == '\\0') {\n                /* null-byte. */\n                return HTTP_BAD_REQUEST;\n            }\n            ip += 3;\n            op++;\n            break;\n        default:\n            *op = *ip;\n            ip++;\n            op++;\n        }\n    }\n    *op = '\\0';\n\n    return OK;\n}\n\n\n/* This function urlencodes a string. It will escape all characters\n * except a-z, A-Z, 0-9, '_' and '.'.\n *\n * Parameters:\n *  apr_pool_t *pool   The pool we should allocate memory from.\n *  const char *str    The string we should urlencode.\n *\n * Returns:\n *  The urlencoded string, or NULL if str == NULL.\n */\nchar *am_urlencode(apr_pool_t *pool, const char *str)\n{\n    const char *ip;\n    apr_size_t length;\n    char *ret;\n    char *op;\n    int hi, low;\n    /* Return NULL if str is NULL. */\n    if(str == NULL) {\n        return NULL;\n    }\n\n\n    /* Find the length of the output string. */\n    length = 0;\n    for(ip = str; *ip; ip++) {\n        if(*ip >= 'a' && *ip <= 'z') {\n            length++;\n        } else if(*ip >= 'A' && *ip <= 'Z') {\n            length++;\n        } else if(*ip >= '0' && *ip <= '9') {\n            length++;\n        } else if(*ip == '_' || *ip == '.') {\n            length++;\n        } else {\n            length += 3;\n        }\n    }\n\n    /* Add space for null-terminator. */\n    length++;\n\n    /* Allocate memory for string. */\n    ret = (char *)apr_palloc(pool, length);\n\n    /* Encode string. */\n    for(ip = str, op = ret; *ip; ip++, op++) {\n        if(*ip >= 'a' && *ip <= 'z') {\n            *op = *ip;\n        } else if(*ip >= 'A' && *ip <= 'Z') {\n            *op = *ip;\n        } else if(*ip >= '0' && *ip <= '9') {\n            *op = *ip;\n        } else if(*ip == '_' || *ip == '.') {\n            *op = *ip;\n        } else {\n            *op = '%';\n            op++;\n\n            hi = (*ip & 0xf0) >> 4;\n\n            if(hi < 0xa) {\n                *op = '0' + hi;\n            } else {\n                *op = 'A' + hi - 0xa;\n            }\n            op++;\n\n            low = *ip & 0x0f;\n\n            if(low < 0xa) {\n                *op = '0' + low;\n            } else {\n                *op = 'A' + low - 0xa;\n            }\n        }\n    }\n\n    /* Make output string null-terminated. */\n    *op = '\\0';\n\n    return ret;\n}\n\n/*\n * Check that a URL is safe for redirect.\n *\n * Parameters:\n *  request_rec *r       The request we are processing.\n *  const char *url      The URL we should check.\n *\n * Returns:\n *  OK on success, HTTP_BAD_REQUEST otherwise.\n */\nint am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            /* Reject backslash character, as it can be used to bypass\n             * redirect URL validation. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}\n\n/* This function generates a given number of (pseudo)random bytes.\n * The current implementation uses OpenSSL's RAND_*-functions.\n *\n * Parameters:\n *  request_rec *r       The request we are generating random bytes for.\n *                       The request is used for configuration and\n *                       error/warning reporting.\n *  void *dest           The address if the buffer we should fill with data.\n *  apr_size_t count     The number of random bytes to create.\n *\n * Returns:\n *  OK on success, or HTTP_INTERNAL_SERVER on failure.\n */\nint am_generate_random_bytes(request_rec *r, void *dest, apr_size_t count)\n{\n    int rc;\n    rc = RAND_bytes((unsigned char *)dest, (int)count);\n    if(rc != 1) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error generating random data: %lu\",\n                      ERR_get_error());\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    return OK;\n}\n\n\n/* This function generates an id which is AM_ID_LENGTH characters long.\n * The id will consist of hexadecimal characters.\n *\n * Parameters:\n *  request_rec *r       The request we associate allocated memory with.\n *\n * Returns:\n *  The session id, made up of AM_ID_LENGTH hexadecimal characters,\n *  terminated by a null-byte.\n */\nchar *am_generate_id(request_rec *r)\n{\n    int rc;\n    char *ret;\n    int rand_data_len;\n    unsigned char *rand_data;\n    int i;\n    unsigned char b;\n    int hi, low;\n\n    ret = (char *)apr_palloc(r->pool, AM_ID_LENGTH + 1);\n\n    /* We need to round the length of the random data _up_, in case the\n     * length of the session id isn't even.\n     */\n    rand_data_len = (AM_ID_LENGTH + 1) / 2;\n\n    /* Fill the last rand_data_len bytes of the string with\n     * random bytes. This allows us to overwrite from the beginning of\n     * the string.\n     */\n    rand_data = (unsigned char *)&ret[AM_ID_LENGTH - rand_data_len];\n\n    /* Generate random numbers. */\n    rc = am_generate_random_bytes(r, rand_data, rand_data_len);\n    if(rc != OK) {\n        return NULL;\n    }\n\n    /* Convert the random bytes to hexadecimal. Note that we will write\n     * AM_ID_LENGTH+1 characters if we have a non-even length of the\n     * session id. This is OK - we will simply overwrite the last character\n     * with the null-terminator afterwards.\n     */\n    for(i = 0; i < AM_ID_LENGTH; i += 2) {\n        b = rand_data[i / 2];\n        hi = (b >> 4) & 0xf;\n        low = b & 0xf;\n\n        if(hi >= 0xa) {\n            ret[i] = 'a' + hi - 0xa;\n        } else {\n            ret[i] = '0' + hi;\n        }\n\n        if(low >= 0xa) {\n            ret[i+1] = 'a' + low - 0xa;\n        } else {\n            ret[i+1] = '0' + low;\n        }\n    }\n\n    /* Add null-terminator- */\n    ret[AM_ID_LENGTH] = '\\0';\n\n    return ret;\n}\n\n/* This returns the directroy part of a path, a la dirname(3)\n *\n * Parameters:\n *  apr_pool_t p         Pool to allocate memory from\n *  const char *path     Path to extract directory from\n *\n * Returns:\n *  The directory part of path\n */\nconst char *am_filepath_dirname(apr_pool_t *p, const char *path) \n{\n    char *cp;\n\n    /*\n     * Try Unix and then Windows style. Borrowed from\n     * apr_match_glob(), it seems it cannot be made more\n     * portable.\n     */\n    if (((cp = strrchr(path, (int)'/')) == NULL) &&\n        ((cp = strrchr(path, (int)'\\\\')) == NULL))\n            return \".\";\n   \n    return apr_pstrndup(p, path, cp - path);\n}\n\n/*\n * Allocate and initialize a am_file_data_t\n *\n * Parameters:\n *   apr_pool_t *pool  Allocation pool.\n *   const char *path  If non-NULL initialize file_data->path to copy of path\n *\n * Returns:\n *   Newly allocated & initialized file_data_t\n */\nam_file_data_t *am_file_data_new(apr_pool_t *pool, const char *path)\n{\n    am_file_data_t *file_data = NULL;\n\n    if ((file_data = apr_pcalloc(pool, sizeof(am_file_data_t))) == NULL) {\n        return NULL;\n    }\n\n    file_data->pool = pool;\n    file_data->rv = APR_EINIT;\n    if (path) {\n        file_data->path = apr_pstrdup(file_data->pool, path);\n    }\n\n    return file_data;\n}\n\n/*\n * Allocate a new am_file_data_t and copy\n *\n * Parameters:\n *   apr_pool_t *pool              Allocation pool.\n *   am_file_data_t *src_file_data The src being copied.\n *\n * Returns:\n *   Newly allocated & initialized from src_file_data\n */\nam_file_data_t *am_file_data_copy(apr_pool_t *pool,\n                                  am_file_data_t *src_file_data)\n{\n    am_file_data_t *dst_file_data = NULL;\n\n    if ((dst_file_data = am_file_data_new(pool, src_file_data->path)) == NULL) {\n        return NULL;\n    }\n\n    dst_file_data->path = apr_pstrdup(pool, src_file_data->path);\n    dst_file_data->stat_time = src_file_data->stat_time;\n    dst_file_data->finfo = src_file_data->finfo;\n    dst_file_data->contents = apr_pstrdup(pool, src_file_data->contents);\n    dst_file_data->read_time = src_file_data->read_time;\n    dst_file_data->rv = src_file_data->rv;\n    dst_file_data->strerror = apr_pstrdup(pool, src_file_data->strerror);\n    dst_file_data->generated = src_file_data->generated;\n\n    return dst_file_data;\n}\n\n/*\n * Peform a stat on a file to get it's properties\n *\n * A stat is performed on the file. If there was an error the\n * result value is left in file_data->rv and an error description\n * string is formatted and left in file_data->strerror and function\n * returns the rv value. If the stat was successful the stat\n * information is left in file_data->finfo and APR_SUCCESS\n * set set as file_data->rv and returned as the function result.\n * \n * The file_data->stat_time indicates if and when the stat was\n * performed, a zero time value indicates the operation has not yet\n * been performed.\n *\n * Parameters:\n *   am_file_data_t *file_data   Struct containing file information\n *\n * Returns:\n *   APR status code, same value as file_data->rv\n */\napr_status_t am_file_stat(am_file_data_t *file_data)\n{\n    char buffer[512];\n\n    if (file_data == NULL) {\n        return APR_EINVAL;\n    }\n\n    file_data->strerror = NULL;\n\n    file_data->stat_time = apr_time_now();\n    file_data->rv = apr_stat(&file_data->finfo, file_data->path,\n                             APR_FINFO_SIZE, file_data->pool);\n    if (file_data->rv != APR_SUCCESS) {\n        file_data->strerror =\n            apr_psprintf(file_data->pool,\n                         \"apr_stat: Error opening \\\"%s\\\" [%d] \\\"%s\\\"\",\n                         file_data->path, file_data->rv,\n                         apr_strerror(file_data->rv, buffer, sizeof(buffer)));\n    }\n\n    return file_data->rv;\n}\n\n/*\n * Read file into dynamically allocated buffer\n *\n * First a stat is performed on the file. If there was an error the\n * result value is left in file_data->rv and an error description\n * string is formatted and left in file_data->strerror and function\n * returns the rv value. If the stat was successful the stat\n * information is left in file_data->finfo.\n *\n * A buffer is dynamically allocated and the contents of the file is\n * read into file_data->contents. If there was an error the result\n * value is left in file_data->rv and an error description string is\n * formatted and left in file_data->strerror and the function returns\n * the rv value.\n *\n * The file_data->stat_time and file_data->read_time indicate if and\n * when those operations were performed, a zero time value indicates\n * the operation has not yet been performed.\n *\n * Parameters:\n *   am_file_data_t *file_data   Struct containing file information\n *\n * Returns:\n *   APR status code, same value as file_data->rv\n */\napr_status_t am_file_read(am_file_data_t *file_data)\n{\n    char buffer[512];\n    apr_file_t *fd;\n    apr_size_t nbytes;\n\n    if (file_data == NULL) {\n        return APR_EINVAL;\n    }\n    file_data->rv = APR_SUCCESS;\n    file_data->strerror = NULL;\n\n    am_file_stat(file_data);\n    if (file_data->rv != APR_SUCCESS) {\n        return file_data->rv;\n    }\n\n    if ((file_data->rv = apr_file_open(&fd, file_data->path,\n                                       APR_READ, 0, file_data->pool)) != 0) {\n        file_data->strerror =\n            apr_psprintf(file_data->pool,\n                         \"apr_file_open: Error opening \\\"%s\\\" [%d] \\\"%s\\\"\",\n                         file_data->path, file_data->rv,\n                         apr_strerror(file_data->rv, buffer, sizeof(buffer)));\n        return file_data->rv;\n    }\n\n    file_data->read_time = apr_time_now();\n    nbytes = file_data->finfo.size;\n    file_data->contents = (char *)apr_palloc(file_data->pool, nbytes + 1);\n\n    file_data->rv = apr_file_read_full(fd, file_data->contents, nbytes, NULL);\n    if (file_data->rv != 0) {\n        file_data->strerror =\n            apr_psprintf(file_data->pool,\n                         \"apr_file_read_full: Error reading \\\"%s\\\" [%d] \\\"%s\\\"\",\n                         file_data->path, file_data->rv,\n                         apr_strerror(file_data->rv, buffer, sizeof(buffer)));\n        (void)apr_file_close(fd);\n        return file_data->rv;\n\n    }\n    file_data->contents[nbytes] = '\\0';\n\n    (void)apr_file_close(fd);\n\n    return file_data->rv;\n}\n\n/*\n * Purge outdated saved POST requests.\n *\n * Parameters:\n *   request_rec *r     The current request\n *\n * Returns:\n *  OK on success, or HTTP_INTERNAL_SERVER on failure.\n */\nint am_postdir_cleanup(request_rec *r)\n{\n    am_mod_cfg_rec *mod_cfg;\n    apr_dir_t *postdir;\n    apr_status_t rv;\n    char error_buffer[64];\n    apr_finfo_t afi;\n    char *fname;\n    int count;\n    apr_time_t expire_before;\n\n    mod_cfg = am_get_mod_cfg(r->server);\n\n    /* The oldes file we should keep. Delete files that are older. */\n    expire_before = apr_time_now() - mod_cfg->post_ttl * APR_USEC_PER_SEC;\n\n    /*\n     * Open our POST directory or create it. \n     */\n    rv = apr_dir_open(&postdir, mod_cfg->post_dir, r->pool);\n    if (rv != 0) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to open MellonPostDirectory \\\"%s\\\": %s\",\n                      mod_cfg->post_dir,\n                      apr_strerror(rv, error_buffer, sizeof(error_buffer)));\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * Purge outdated items\n     */\n    count = 0;\n    do {\n        rv = apr_dir_read(&afi, APR_FINFO_NAME|APR_FINFO_CTIME, postdir);\n        if (rv != OK)\n            break;\n\n        /* Skip dot_files */\n        if (afi.name[0] == '.')\n             continue;\n\n        if (afi.ctime < expire_before) {\n            fname = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, afi.name);\n            (void)apr_file_remove(fname , r->pool); \n        } else {\n            count++;\n        }\n    } while (1 /* CONSTCOND */);\n\n    (void)apr_dir_close(postdir);\n\n    if (count >= mod_cfg->post_count) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Too many saved POST sessions. \"\n                      \"Increase MellonPostCount directive.\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    return OK;\n}\n\n/* \n * HTML-encode a string\n *\n * Parameters:\n *   request_rec *r     The current request\n *   const char *str    The string to encode\n *\n * Returns:\n *  The encoded string\n */\nchar *am_htmlencode(request_rec *r, const char *str)\n{\n    const char *cp;\n    char *output;\n    apr_size_t outputlen;\n    int i;\n\n    outputlen = 0;\n    for (cp = str; *cp; cp++) {\n        switch (*cp) {\n        case '&':\n            outputlen += 5;\n            break;\n        case '\"':\n            outputlen += 6;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n\n    i = 0;\n    output = apr_palloc(r->pool, outputlen + 1);\n    for (cp = str; *cp; cp++) {\n        switch (*cp) {\n        case '&':\n            (void)strcpy(&output[i], \"&amp;\");\n            i += 5;\n            break;\n        case '\"':\n            (void)strcpy(&output[i], \"&quot;\");\n            i += 6;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = '\\0';\n\n    return output;\n}\n\n/* This function produces the endpoint URL\n *\n * Parameters:\n *  request_rec *r       The request we received.\n *\n * Returns:\n *  the endpoint URL\n */\nchar *am_get_endpoint_url(request_rec *r)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n\n    return ap_construct_url(r->pool, cfg->endpoint_path, r);\n}\n\n/*\n * This function saves a POST request for later replay and updates\n * the return URL.\n *\n * Parameters:\n *  request_rec *r           The current request.\n *  const char **relay_state The returl URL\n *\n * Returns:\n *  OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise\n */\nint am_save_post(request_rec *r, const char **relay_state)\n{\n    am_mod_cfg_rec *mod_cfg;\n    const char *content_type;\n    const char *charset;\n    const char *psf_id;\n    char *psf_name;\n    char *post_data;\n    apr_size_t post_data_len;\n    apr_size_t written;\n    apr_file_t *psf;\n\n    mod_cfg = am_get_mod_cfg(r->server);\n    if (mod_cfg->post_dir == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"MellonPostReplay enabled but MellonPostDirectory not set \"\n                      \"-- cannot save post data\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (am_postdir_cleanup(r) != OK)\n        return HTTP_INTERNAL_SERVER_ERROR;\n\n    /* Check Content-Type */\n    content_type = apr_table_get(r->headers_in, \"Content-Type\");\n    if (content_type == NULL) {\n        content_type = \"urlencoded\";\n        charset = NULL; \n    } else {\n        if (am_has_header(r, content_type, \n            \"application/x-www-form-urlencoded\")) {\n            content_type = \"urlencoded\";\n\n        } else if (am_has_header(r, content_type,\n                   \"multipart/form-data\")) {\n            content_type = \"multipart\";\n\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Unknown POST Content-Type \\\"%s\\\"\", content_type);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        charset = am_get_header_attr(r, content_type, NULL, \"charset\");\n    }     \n\n    if ((psf_id = am_generate_id(r)) == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"cannot generate id\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    psf_name = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, psf_id);\n\n    if (apr_file_open(&psf, psf_name,\n                      APR_WRITE|APR_CREATE|APR_BINARY, \n                      APR_FPROT_UREAD|APR_FPROT_UWRITE,\n                      r->pool) != OK) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"cannot create POST session file\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    } \n\n    if (am_read_post_data(r, &post_data, &post_data_len) != OK) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"cannot read POST data\");\n        (void)apr_file_close(psf);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    } \n\n    if (post_data_len > mod_cfg->post_size) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"POST data size %\" APR_SIZE_T_FMT \n                      \" exceeds maximum %\" APR_SIZE_T_FMT \". \"\n                      \"Increase MellonPostSize directive.\",\n                      post_data_len, mod_cfg->post_size);\n        (void)apr_file_close(psf);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    written = post_data_len;\n    if ((apr_file_write(psf, post_data, &written) != OK) ||\n        (written != post_data_len)) { \n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"cannot write to POST session file\");\n            (void)apr_file_close(psf);\n            return HTTP_INTERNAL_SERVER_ERROR;\n    } \n    \n    if (apr_file_close(psf) != OK) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"cannot close POST session file\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (charset != NULL)\n        charset = apr_psprintf(r->pool, \"&charset=%s\", \n                               am_urlencode(r->pool, charset));\n    else \n        charset = \"\";\n\n    *relay_state = apr_psprintf(r->pool, \n                                \"%srepost?id=%s&ReturnTo=%s&enctype=%s%s\",\n                                am_get_endpoint_url(r), psf_id,\n                                am_urlencode(r->pool, *relay_state), \n                                content_type, charset);\n\n    return OK;\n}\n\n/*\n * This function replaces CRLF by LF in a string\n *\n * Parameters:\n *  request_rec *r  The current request\n *  const char *str The string\n *\n * Returns:\n *  Output string\n */\nconst char *am_strip_cr(request_rec *r, const char *str)\n{\n    char *output;\n    const char *cp;\n    apr_size_t i;\n\n    output = apr_palloc(r->pool, strlen(str) + 1);\n    i = 0;\n\n    for (cp = str; *cp; cp++) {\n        if ((*cp == '\\r') && (*(cp + 1) == '\\n'))\n            continue;\n        output[i++] = *cp;\n    }\n\n    output[i++] = '\\0';\n    \n    return (const char *)output;\n}\n\n/*\n * This function replaces LF by CRLF in a string\n *\n * Parameters:\n *  request_rec *r  The current request\n *  const char *str The string\n *\n * Returns:\n *  Output string\n */\nconst char *am_add_cr(request_rec *r, const char *str)\n{\n    char *output;\n    const char *cp;\n    apr_size_t xlen;\n    apr_size_t i;\n\n    xlen = 0;\n\n    for (cp = str; *cp; cp++)\n        if (*cp == '\\n')\n            xlen++;\n\n    output = apr_palloc(r->pool, strlen(str) + xlen + 1);\n    i = 0;\n\n    for (cp = str; *cp; cp++) {\n        if (*cp == '\\n')\n            output[i++] = '\\r';\n        output[i++] = *cp;\n    }\n\n    output[i++] = '\\0';\n    \n    return (const char *)output;\n}\n\n/*\n * This function tokenize a string, just like strtok_r, except that\n * the separator is a string instead of a character set.\n *\n * Parameters:\n *  const char *str The string to tokenize\n *  const char *sep The separator string\n *  char **last     Pointer to state (char *)\n *\n * Returns:\n *  OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise\n */\nconst char *am_xstrtok(request_rec *r, const char *str,\n                       const char *sep, char **last)\n{\n    char *s;\n    char *np;\n\n    /* Resume */\n    if (str != NULL)\n        s = apr_pstrdup(r->pool, str);\n    else\n        s = *last;\n\n    /* End of string */\n    if (*s == '\\0')\n        return NULL;\n\n    /* Next sep exists? */\n    if ((np = strstr(s, sep)) == NULL) {\n        *last = s + strlen(s);\n    } else {\n        *last = np + strlen(sep);\n        memset(np, 0, strlen(sep));\n    }\n\n    return s;\n}\n\n/* This function strips leading spaces and tabs from a string\n *\n * Parameters:\n *  const char **s       Pointer to the string\n *\n */\nvoid am_strip_blank(const char **s)\n{\n    while ((**s == ' ') || (**s == '\\t'))\n        (*s)++;\n    return;\n}\n\n/* This function extracts a MIME header from a MIME section\n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *m         The MIME section\n *  const char *h         The header to extract (case insensitive)\n *\n * Returns:\n *  The header value, or NULL on failure.\n */\nconst char *am_get_mime_header(request_rec *r, const char *m, const char *h) \n{\n    const char *line;\n    char *l1;\n    const char *value;\n    char *l2;\n\n    for (line = am_xstrtok(r, m, \"\\n\", &l1); line && *line; \n         line = am_xstrtok(r, NULL, \"\\n\", &l1)) {\n\n        am_strip_blank(&line);\n\n        if (((value = am_xstrtok(r, line, \":\", &l2)) != NULL) &&\n            (strcasecmp(value, h) == 0)) {\n            if ((value = am_xstrtok(r, NULL, \":\", &l2)) != NULL)\n                am_strip_blank(&value);\n            return value;\n        }\n   }\n   return NULL;\n}\n\n/* This function extracts an attribute from a header \n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *h         The header\n *  const char *v         Optional header value to check (case insensitive)\n *  const char *a         Optional attribute to extract (case insensitive)\n *\n * Returns:\n *   if i was provided, item value, or NULL on failure.\n *   if i is NULL, the whole header, or NULL on failure. This is\n *   useful for testing v.\n */\nconst char *am_get_header_attr(request_rec *r, const char *h,\n                               const char *v, const char *a) \n{\n    const char *value;\n    const char *attr;\n    char *l1;\n    const char *attr_value = NULL;\n\n    /* Looking for \n     * header-value; item_name=\"item_value\"\\n \n     */\n    if ((value = am_xstrtok(r, h, \";\", &l1)) == NULL)\n        return NULL;\n    am_strip_blank(&value);\n\n    /* If a header value was provided, check it */ \n    if ((v != NULL) && (strcasecmp(value, v) != 0))\n        return NULL;\n\n    /* If no attribute name is provided, return everything */\n    if (a == NULL)\n        return h;\n\n    while ((attr = am_xstrtok(r, NULL, \";\", &l1)) != NULL) {\n        const char *attr_name = NULL;\n        char *l2;\n\n        am_strip_blank(&attr);\n\n        attr_name = am_xstrtok(r, attr, \"=\", &l2); \n        if ((attr_name != NULL) && (strcasecmp(attr_name, a) == 0)) {\n            if ((attr_value = am_xstrtok(r, NULL, \"=\", &l2)) != NULL)\n                am_strip_blank(&attr_value);\n            break;\n        }\n    }\n  \n    /* Remove leading and trailing quotes */\n    if (attr_value != NULL) {\n        apr_size_t len; \n\n        len = strlen(attr_value);\n        if ((len > 1) && (attr_value[len - 1] == '\\\"'))\n            attr_value = apr_pstrndup(r->pool, attr_value, len - 1);\n        if (attr_value[0] == '\\\"')\n            attr_value++;\n    }\n    \n    return attr_value;\n}\n\n/* This function checks for a header name/value existence\n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *h         The header (case insensitive)\n *  const char *v         Optional header value to check (case insensitive)\n *\n * Returns:\n *   0 if header does not exists or does not has the value, 1 otherwise\n */\nint am_has_header(request_rec *r, const char *h, const char *v)\n{\n    return (am_get_header_attr(r, h, v, NULL) != NULL);\n}\n\n/* This function extracts the body from a MIME section\n *\n * Parameters:\n *  request_rec *r        The request\n *  const char *mime      The MIME section\n *\n * Returns:\n *  The MIME section body, or NULL on failure.\n */\nconst char *am_get_mime_body(request_rec *r, const char *mime) \n{\n    const char lflf[] = \"\\n\\n\";\n    const char *body;\n    apr_size_t body_len;\n\n    if ((body = strstr(mime, lflf)) == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"No MIME body\");\n        return NULL;\n    }\n\n    body += strlen(lflf);\n\n    /* Strip tralling \\n */\n    if ((body_len = strlen(body)) >= 1) {\n        if (body[body_len - 1] == '\\n') \n            body = apr_pstrmemdup(r->pool, body, body_len - 1);\n    }\n\n    /* Turn back LF into CRLF */\n    return am_add_cr(r, body);\n}\n\n/* This function returns the URL for a given provider service (type + method)\n *\n * Parameters:\n *  request_rec *r        The request\n *  LassoProfile *profile Login profile\n *  char *endpoint_name   Service and method as specified in metadata\n *                        e.g.: \"SingleSignOnService HTTP-Redirect\"\n * Returns:\n *  The endpoint URL that must be freed by caller, or NULL on failure.\n */\nchar *\nam_get_service_url(request_rec *r, LassoProfile *profile, char *service_name)\n{\n    LassoProvider *provider;\n    gchar *url;\n\n    provider = lasso_server_get_provider(profile->server, \n                                         profile->remote_providerID);\n    if (LASSO_IS_PROVIDER(provider) == FALSE) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Cannot find provider service %s, no provider.\",\n                      service_name);\n\treturn NULL;\n    }\n\n    url = lasso_provider_get_metadata_one(provider, service_name);\n    if (url == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Cannot find provider service %s from metadata.\",\n                      service_name);\n\treturn NULL;\n    }\n\n    return url;\n}\n\n/*------------------------ Begin Token Parsing Code --------------------------*/\n\ntypedef enum {\n    TOKEN_WHITESPACE = 1,\n    TOKEN_SEMICOLON,\n    TOKEN_COMMA,\n    TOKEN_EQUAL,\n    TOKEN_IDENTIFIER,\n    TOKEN_DBL_QUOTE_STRING,\n} TokenType;\n\ntypedef struct {\n    TokenType type;             /* The type of this token */\n    char *str;                  /* The string value of the token */\n    apr_size_t len;             /* The number of characters in the token */\n    apr_size_t offset;          /* The offset from the beginning of\n                                   the string to the start of the token */\n} Token;\n\n\n#ifdef DEBUG\n/* Return string representation of TokenType enumeration\n *\n * Parameters:\n *  token_type  A TokenType enumeration\n * Returns:     String name of token_type\n */\nstatic const char *\ntoken_type_str(TokenType token_type)\n{\n    switch(token_type) {\n    case TOKEN_WHITESPACE:       return \"WHITESPACE\";\n    case TOKEN_SEMICOLON:        return \"SEMICOLON\";\n    case TOKEN_COMMA:            return \"COMMA\";\n    case TOKEN_EQUAL:            return \"EQUAL\";\n    case TOKEN_IDENTIFIER:       return \"IDENTIFIER\";\n    case TOKEN_DBL_QUOTE_STRING: return \"DBL_QUOTE_STRING\";\n    default:                     return \"unknown\";\n    }\n}\n\nstatic void dump_tokens(request_rec *r, apr_array_header_t *tokens)\n{\n    apr_size_t i;\n    \n    for (i = 0; i < tokens->nelts; i++) {\n        Token token = APR_ARRAY_IDX(tokens, i, Token);\n        AM_LOG_RERROR(APLOG_MARK, APLOG_DEBUG, 0, r,\n                      \"token[%2zd] %s \\\"%s\\\" offset=%lu len=%lu \", i,\n                      token_type_str(token.type), token.str,\n                      token.offset, token.len);\n    }\n}\n#endif\n\n\n/* Initialize token and add to list of tokens\n *\n * Utility to assist tokenize function.\n *\n * A token object is created and added to the end of the list of\n * tokens. It is initialized with the type of token, a copy of the\n * string, it's length, and it's offset from the beginning of the\n * string where it was found.\n *\n * Tokens with special processing needs are also handled here.\n *\n * A double quoted string will:\n *\n * * Have it's delimiting quotes removed.\n * * Will unescape escaped characters.\n *\n * Parameters:\n *  tokens  Array of Token objects.\n *  type    The type of the token (e.g. TokenType).\n *  str     The string the token was parsed from, used to compute\n *          the position of the token in the original string.\n *  start   The first character in the token.\n *  end     the last character in the token.\n */\nstatic inline void\npush_token(apr_array_header_t *tokens, TokenType type, const char *str,\n           const char *start, const char *end)\n{\n    apr_size_t offset = start - str;\n    Token *token = apr_array_push(tokens);\n\n    if (type == TOKEN_DBL_QUOTE_STRING) {\n        /* do not include quotes in token value */\n        start++; end--;\n    }\n\n    token->type = type;\n    token->len = end - start;\n    token->offset = offset;\n    token->str = apr_pstrmemdup(tokens->pool, start, token->len);\n\n    if (type == TOKEN_DBL_QUOTE_STRING) {\n        /*\n         * The original HTTP 1.1 spec was ambiguous with respect to\n         * backslash quoting inside double quoted strings. This has since\n         * been resolved in this errata:\n         *\n         * http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p1-messaging-16.html#rfc.section.3.2.3\n         *\n         * Which states:\n         *\n         * Recipients that process the value of the quoted-string MUST\n         * handle a quoted-pair as if it were replaced by the octet\n         * following the backslash.\n         *\n         * Senders SHOULD NOT escape octets in quoted-strings that do not\n         * require escaping (i.e., other than DQUOTE and the backslash\n         * octet).\n         */\n        char *p, *t;\n\n        for (p = token->str; *p; p++) {\n            if (p[0] == '\\\\' && p[1]) {\n                /*\n                 * Found backslash with following character.\n                 * Move rest of string down 1 character.\n                 */\n                for (t = p; *t; t++) {\n                    t[0] = t[1];\n                }\n                token->len--;\n            }\n        }\n    }\n}\n\n/* Break a string into a series of tokens\n *\n * Given a string return an array of tokens. If the string cannot be\n * successfully parsed an error string is returned at the location\n * specified by the error parameter, if error is NULL then the parsing\n * was successful. If an error occured the returned array of tokens\n * will include all tokens parsed up until where the unrecognized\n * input occurred. The input str is never modified.\n *\n * Parameters:\n *  pool              memory allocation pool\n *  str               input string to be parsed.\n *  ignore_whitespace if True whitespace tokens are not returned\n *  error             location where error string is returned\n *                    if NULL no error occurred\n * Returns:           array of Token objects\n */\nstatic apr_array_header_t *\ntokenize(apr_pool_t *pool, const char *str, bool ignore_whitespace,\n             char **error)\n{\n    apr_array_header_t *tokens = apr_array_make(pool, 10, sizeof(Token));\n    const char *p, *start;\n\n    *error = NULL;\n    p = start = str;\n    while(*p) {\n        if (apr_isspace(*p)) {  /* whitespace */\n            p++;\n            while(*p && apr_isspace(*p)) p++;\n            if (!ignore_whitespace) {\n                push_token(tokens, TOKEN_WHITESPACE, str, start, p);\n            }\n            start = p;\n        }\n        else if (apr_isalpha(*p)) { /* identifier: must begin with\n                                       alpha then any alphanumeric or\n                                       underscore */\n            p++;\n            while(*p && (apr_isalnum(*p) || *p == '_')) p++;\n            push_token(tokens, TOKEN_IDENTIFIER, str, start, p);\n            start = p;\n        }\n        else if (*p == '\"') {   /* double quoted string */\n            p++;                /* step over double quote */\n            while(*p) {\n                if (*p == '\\\\') { /* backslash escape */\n                    p++;          /* step over backslash */\n                    if (*p) {\n                        p++;      /* step over escaped character */\n                    } else {\n                        break;    /* backslash at end of string, stop */\n                    }\n                }\n                if (*p == '\\\"') break; /* terminating quote delimiter */\n                p++;                   /* keep scanning */\n            }\n            if (*p != '\\\"') {\n                *error = apr_psprintf(pool,\n                                      \"unterminated string beginning at \"\n                                      \"position %\" APR_SIZE_T_FMT \" in \\\"%s\\\"\",\n                                      start-str, str);\n                break;\n            }\n            p++;\n            push_token(tokens, TOKEN_DBL_QUOTE_STRING, str, start, p);\n            start = p;\n        }\n        else if (*p == '=') {   /* equals */\n            p++;\n            push_token(tokens, TOKEN_EQUAL, str, start, p);\n            start = p;\n        }\n        else if (*p == ',') {   /* comma */\n            p++;\n            push_token(tokens, TOKEN_COMMA, str, start, p);\n            start = p;\n        }\n        else if (*p == ';') {   /* semicolon */\n            p++;\n            push_token(tokens, TOKEN_SEMICOLON, str, start, p);\n            start = p;\n        }\n        else {                  /* unrecognized token */\n            *error = apr_psprintf(pool,\n                                  \"unknown token at \"\n                                  \"position %\" APR_SIZE_T_FMT \" in string \\\"%s\\\"\",\n                                  p-str, str);\n            break;\n        }\n    }\n\n    return tokens;\n}\n\n/* Test if the token is what we're looking for\n *\n * Given an index into the tokens array determine if the token type\n * matches. If the value parameter is non-NULL then the token's value\n * must also match. If the array index is beyond the last array item\n * false is returned.\n *\n * Parameters:\n *  tokens  Array of Token objects\n *  index   Index used to select the Token object from the Tokens array.\n *          If the index is beyond the last array item False is returned.\n *  type    The token type which must match\n *  value   If non-NULL then the token string value must be equal to this.\n * Returns: True if the token matches, False otherwise.\n */\n\nstatic bool\nis_token(apr_array_header_t *tokens, apr_size_t index, TokenType type, const char *value)\n{\n    if (index >= tokens->nelts) {\n        return false;\n    }\n\n    Token token = APR_ARRAY_IDX(tokens, index, Token);\n\n    if (token.type != type) {\n        return false;\n    }\n\n    if (value) {\n        if (!g_str_equal(token.str, value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/*------------------------- End Token Parsing Code ---------------------------*/\n\n/* Return message describing position an error when parsing.\n *\n * When parsing we expect tokens to appear in a certain sequence.  We\n * report the contents of the unexpected token and it's position in\n * the string. However if the parsing error is due to the fact we've\n * exhausted all tokens but are still expecting another token then our\n * error message indicates we reached the end of the string.\n *\n * Parameters:\n *  tokens  Array of Token objects.\n *  index   Index in tokens array where bad token was found\n */\nstatic inline const char *\nparse_error_msg(apr_array_header_t *tokens, apr_size_t index)\n{\n    if (index >= tokens->nelts) {\n        return \"end of string\";\n    }\n\n    return apr_psprintf(tokens->pool, \"\\\"%s\\\" at position %\" APR_SIZE_T_FMT,\n                        APR_ARRAY_IDX(tokens, index, Token).str,\n                        APR_ARRAY_IDX(tokens, index, Token).offset);\n}\n\n/* This function checks if an HTTP PAOS header is valid and\n * returns any service options which may have been specified.\n *\n * A PAOS header is composed of a mandatory PAOS version and service\n * values. A semicolon separates the version from the service values.\n *\n * Service values are delimited by semicolons, and options are\n * comma-delimited from the service value and each other.\n *\n * The PAOS version must be in the form ver=\"xxx\" (note the version\n * string must be in double quotes).\n *\n * The ECP service must be specified, it MAY be followed by optional\n * comma seperated options, all values must be in double quotes.\n *\n * ECP Service\n *   \"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\"\n *\n * Recognized Options:\n *\n * Support for channel bindings\n *  urn:oasis:names:tc:SAML:protocol:ext:channel-binding\n *\n * Support for Holder-of-Key subject confirmation\n *   urn:oasis:names:tc:SAML:2.0:cm:holder-of-key\n *\n * Request for signed SAML request\n *   urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:2.0:WantAuthnRequestsSigned\n *\n * Request to delegate credentials to the service provider\n *   urn:oasis:names:tc:SAML:2.0:conditions:delegation\n *\n *\n * Example PAOS HTTP header::\n *\n *   PAOS: ver=\"urn:liberty:paos:2003-08\";\n *     \"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\",\n *     \"urn:oasis:names:tc:SAML:protocol:ext:channel-binding\",\n *     \"urn:oasis:names:tc:SAML:2.0:cm:holder-of-key\"\n *\n * Parameters:\n *  request_rec *r              The request\n *  const char *header          The PAOS header value\n *  ECPServiceOptions *options_return\n *                              Pointer to location to receive options,\n *                              may be NULL. Bitmask of option flags.\n *\n * Returns:\n *   true if the PAOS header is valid, false otherwise. If options is non-NULL\n *   then the set of option flags is returned there.\n *\n */\nbool am_parse_paos_header(request_rec *r, const char *header,\n                             ECPServiceOptions *options_return)\n{\n    bool result = false;\n    ECPServiceOptions options = 0;\n    apr_array_header_t *tokens;\n    apr_size_t i;\n    char *error;\n\n    AM_LOG_RERROR(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"PAOS header: \\\"%s\\\"\", header);\n\n    tokens = tokenize(r->pool, header, true, &error);\n\n#ifdef DEBUG\n    dump_tokens(r, tokens);\n#endif\n\n    if (error) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r, \"%s\", error);\n        goto cleanup;\n    }\n\n    /* Header must begin with \"ver=xxx\" where xxx is paos version */\n    if (!is_token(tokens, 0, TOKEN_IDENTIFIER, \"ver\") ||\n        !is_token(tokens, 1, TOKEN_EQUAL, NULL) ||\n        !is_token(tokens, 2, TOKEN_DBL_QUOTE_STRING, LASSO_PAOS_HREF)) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"invalid PAOS header, \"\n                      \"expected header to begin with ver=\\\"%s\\\", \"\n                      \"actual header=\\\"%s\\\"\",\n                      LASSO_PAOS_HREF, header);\n        goto cleanup;\n    }\n\n    /* Next is the service value, separated from the version by a semicolon */\n    if (!is_token(tokens, 3, TOKEN_SEMICOLON, NULL)) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                     \"invalid PAOS header, \"\n                     \"expected semicolon after PAOS version \"\n                     \"but found %s in header=\\\"%s\\\"\",\n                      parse_error_msg(tokens, 3),\n                      header);\n        goto cleanup;\n    }\n\n    if (!is_token(tokens, 4, TOKEN_DBL_QUOTE_STRING, LASSO_ECP_HREF)) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"invalid PAOS header, \"\n                      \"expected service token to be \\\"%s\\\", \"\n                      \"but found %s in header=\\\"%s\\\"\",\n                      LASSO_ECP_HREF,\n                      parse_error_msg(tokens, 4),\n                      header);\n        goto cleanup;\n    }\n\n    /* After the service value there may be optional flags separated by commas */\n\n    if (tokens->nelts == 5) {    /* no options */\n        result = true;\n        goto cleanup;\n    }\n\n    /* More tokens after the service value, must be options, iterate over them */\n    for (i = 5; i < tokens->nelts; i++) {\n        if (!is_token(tokens, i, TOKEN_COMMA, NULL)) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"invalid PAOS header, \"\n                          \"expected comma after PAOS service \"\n                          \"but found %s in header=\\\"%s\\\"\",\n                          parse_error_msg(tokens, i),\n                          header);\n            goto cleanup;\n        }\n\n        if (++i > tokens->nelts) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"invalid PAOS header, \"\n                          \"expected option after comma \"\n                          \"in header=\\\"%s\\\"\",\n                          header);\n            goto cleanup;\n        }\n\n        Token token = APR_ARRAY_IDX(tokens, i, Token);\n\n        if (token.type != TOKEN_DBL_QUOTE_STRING) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"invalid PAOS header, \"\n                          \"expected quoted string after comma \"\n                          \"but found %s in header=\\\"%s\\\"\",\n                          parse_error_msg(tokens, i),\n                          header);\n            goto cleanup;\n        }\n\n        /* Have an option string, convert it to a bit flag */\n        const char *value = token.str;\n\n        if (g_str_equal(value, LASSO_SAML_EXT_CHANNEL_BINDING)) {\n            options |= ECP_SERVICE_OPTION_CHANNEL_BINDING;\n        } else if (g_str_equal(value, LASSO_SAML2_CONFIRMATION_METHOD_HOLDER_OF_KEY)) {\n            options |= ECP_SERVICE_OPTION_HOLDER_OF_KEY;\n        } else if (g_str_equal(value, LASSO_SAML2_ECP_PROFILE_WANT_AUTHN_SIGNED)) {\n            options |= ECP_SERVICE_OPTION_WANT_AUTHN_SIGNED;\n        } else if (g_str_equal(value, LASSO_SAML2_CONDITIONS_DELEGATION)) {\n            options |= ECP_SERVICE_OPTION_DELEGATION;\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_WARNING, 0, r,\n                          \"Unknown PAOS service option = \\\"%s\\\"\",\n                          value);\n            goto cleanup;\n        }\n    }\n\n    result = true;\n\n cleanup:\n    if (options_return) {\n        *options_return = options;\n    }\n    return result;\n\n}\n\n/* This function checks if Accept header has a media type\n *\n * Given an Accept header value like this:\n *\n * \"text/html,application/xhtml+xml,application/xml;q=0.9\"\n *\n * Parse the string and find name of each media type, ignore any parameters\n * bound to the name. Test to see if the name matches the input media_type.\n *\n * Parameters:\n *  request_rec *r         The request\n *  const char *header     The header value\n *  const char *media_type media type header value to check (case insensitive)\n *\n * Returns:\n *   true if media type is in header, false otherwise\n */\nbool am_header_has_media_type(request_rec *r, const char *header, const char *media_type)\n{\n    bool result = false;\n    char **comma_tokens = NULL;\n    char **media_ranges = NULL;\n    char *media_range = NULL;\n\n    if (header == NULL) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                     \"invalid Accept header, NULL\");\n        goto cleanup;\n    }\n\n    /*\n     * Split the header into a list of media_range tokens separated by\n     * a comma and iterate over the list.\n     */\n    comma_tokens = g_strsplit(header, \",\", 0);\n    for (media_ranges = comma_tokens, media_range = *media_ranges;\n         media_range;\n         media_range = *(++media_ranges)) {\n        char **semicolon_tokens = NULL;\n        char *name = NULL;\n\n        /*\n         * Split the media_range into a name and parameters, each\n         * separated by a semicolon. The first element in the list is\n         * the media_type name, subsequent params are optional and ignored.\n         */\n        media_range = g_strstrip(media_range);\n        semicolon_tokens = g_strsplit(media_range, \";\", 0);\n\n        /*\n         * Does the media_type match our required media_type?\n         * If so clean up and return success.\n         */\n        name = g_strstrip(semicolon_tokens[0]);\n        if (name && g_str_equal(name, media_type)) {\n            result = true;\n            g_strfreev(semicolon_tokens);\n            goto cleanup;\n        }\n        g_strfreev(semicolon_tokens);\n    }\n\n cleanup:\n    g_strfreev(comma_tokens);\n    return result;\n}\n\n/*\n * Lookup a config string in a specific language.  If lang is NULL and\n * the config string had been defined without a language qualifier\n * return the unqualified value.  If not found NULL is returned.\n */\nconst char *am_get_config_langstring(apr_hash_t *h, const char *lang)\n{\n    char *string;\n\n    if (lang == NULL) {\n        lang = \"\";\n    }\n\n    string = (char *)apr_hash_get(h, lang, APR_HASH_KEY_STRING);\n\n    return string;\n}\n\n/*\n * Get the value of boolean query parameter.\n *\n * Parameters:\n *  request_rec *r         The request\n *  const char *name       The name of the query parameter\n *  int *return_value      The address of the variable to receive\n *                         the boolean value\n *  int default_value      The value returned if parameter is absent or\n *                          in event of an error\n *\n * Returns:\n *   OK on success, HTTP error otherwise\n *\n * Looks for the named parameter in the query parameters, if found\n * parses the value which must be one of:\n *\n *   * true\n *   * false\n *\n * If value cannot be parsed HTTP_BAD_REQUEST is returned.\n *\n * If not found, or if there is an error, the returned value is set to\n * default_value.\n */\n\nint am_get_boolean_query_parameter(request_rec *r, const char *name,\n                                   int *return_value, int default_value)\n{\n    char *value_str;\n    int ret = OK;\n\n    *return_value = default_value;\n\n    value_str = am_extract_query_parameter(r->pool, r->args, name);\n    if (value_str != NULL) {\n        ret = am_urldecode(value_str);\n        if (ret != OK) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Error urldecoding \\\"%s\\\" boolean query parameter, \"\n                          \"value=\\\"%s\\\"\", name, value_str);\n            return ret;\n        }\n        if(!strcmp(value_str, \"true\")) {\n            *return_value = TRUE;\n        } else if(!strcmp(value_str, \"false\")) {\n            *return_value = FALSE;\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Invalid value for \\\"%s\\\" boolean query parameter, \"\n                          \"value=\\\"%s\\\"\", name, value_str);\n            ret = HTTP_BAD_REQUEST;\n        }\n    }\n\n    return ret;\n}\n\n/*\n * Get the URL of the AssertionConsumerServer having specific protocol\n * binding.\n *\n * Parameters:\n *  LassoProvider *provider The provider whose endpoints will be scanned.\n *  const char *binding     The required binding short name.\n *\n * Returns:\n *   The endpoint URL or NULL if not found. Must be freed with g_free().\n *\n * Lasso does not provide a public API to select a provider endpoint\n * by binding. The best we can do is iterate over a list of endpoint\n * descriptors and select a matching descriptor.\n *\n * Lasso does not document the format of these descriptor names but\n * essentially a descriptor is a space separated concatenation of the\n * endpoint properties. For SAML2 one can assume it is the endpoint\n * type, optionally followed by the protocol binding name, optionally\n * followd by the index (if the endpoint type is indexed). If the\n * endpoint is a response location then \"ResponseLocation\" will be\n * appended as the final token. For example here is a list of\n * descriptors returned for a service provider (note they are\n * unordered).\n *\n *    \"AssertionConsumerService HTTP-POST 0\"\n *    \"AuthnRequestsSigned\"\n *    \"AssertionConsumerService PAOS 2\"\n *    \"SingleLogoutService HTTP-Redirect\"\n *    \"SingleLogoutService SOAP\"\n *    \"AssertionConsumerService HTTP-Artifact 1\"\n *    \"NameIDFormat\"\n *    \"SingleLogoutService HTTP-POST ResponseLocation\"\n *\n * The possible binding names are:\n *\n *    \"SOAP\"\n *    \"HTTP-Redirect\"\n *    \"HTTP-POST\"\n *    \"HTTP-Artifact\"\n *    \"PAOS\"\n *    \"URI\"\n *\n * We know the AssertionConsumerService is indexed. If there is more\n * than one endpoint with the required binding we select the one with\n * the lowest index assuming it is preferred.\n */\n\nchar *am_get_assertion_consumer_service_by_binding(LassoProvider *provider, const char *binding)\n{\n    GList *descriptors;\n    char *url;\n    char *selected_descriptor;\n    char *descriptor;\n    char **tokens;\n    guint n_tokens;\n    GList *i;\n    char *endptr;\n    long descriptor_index, min_index;\n\n    url = NULL;\n    selected_descriptor = NULL;\n    min_index = LONG_MAX;\n\n    /* The descriptor list is unordered */\n    descriptors = lasso_provider_get_metadata_keys_for_role(provider,\n                                                            LASSO_PROVIDER_ROLE_SP);\n\n    for (i = g_list_first(descriptors), tokens=NULL;\n         i;\n         i = g_list_next(i), g_strfreev(tokens)) {\n\n        descriptor = i->data;\n        descriptor_index = LONG_MAX;\n\n        /*\n         * Split the descriptor into tokens, only consider descriptors\n         * which have at least 3 tokens and whose first token is\n         * AssertionConsumerService\n         */\n\n        tokens = g_strsplit(descriptor, \" \", 0);\n        n_tokens = g_strv_length(tokens);\n\n        if (n_tokens < 3) continue;\n\n        if (!g_str_equal(tokens[0], \"AssertionConsumerService\")) continue;\n        if (!g_str_equal(tokens[1], binding)) continue;\n\n        descriptor_index = strtol(tokens[2], &endptr, 10);\n        if (tokens[2] == endptr) continue; /* could not parse int */\n\n        if (descriptor_index < min_index) {\n            selected_descriptor = descriptor;\n            min_index = descriptor_index;\n        }\n    }\n\n    if (selected_descriptor) {\n        url = lasso_provider_get_metadata_one_for_role(provider,\n                                                       LASSO_PROVIDER_ROLE_SP,\n                                                       selected_descriptor);\n    }\n\n    lasso_release_list_of_strings(descriptors);\n\n    return url;\n}\n\n\n#ifdef HAVE_ECP\n\n/* String representation of ECPServiceOptions bitmask\n *\n * ECPServiceOptions is a bitmask of flags. Return a comma separated string\n * of all the flags. If any bit in the bitmask is unaccounted for an\n * extra string will be appended of the form \"(unknown bits = x)\".\n *\n * Parameters:\n *  pool    memory allocation pool\n *  options bitmask of PAOS options\n */\nchar *am_ecp_service_options_str(apr_pool_t *pool, ECPServiceOptions options)\n{\n    apr_array_header_t *names = apr_array_make(pool, 4, sizeof(const char *));\n\n    if (options & ECP_SERVICE_OPTION_CHANNEL_BINDING) {\n        APR_ARRAY_PUSH(names, const char *) = \"channel-binding\";\n        options &= ~ECP_SERVICE_OPTION_CHANNEL_BINDING;\n    }\n\n    if (options & ECP_SERVICE_OPTION_HOLDER_OF_KEY) {\n        APR_ARRAY_PUSH(names, const char *) = \"holder-of-key\";\n        options &= ~ECP_SERVICE_OPTION_HOLDER_OF_KEY;\n    }\n\n    if (options & ECP_SERVICE_OPTION_WANT_AUTHN_SIGNED) {\n        APR_ARRAY_PUSH(names, const char *) = \"want-authn-signed\";\n        options &= ~ECP_SERVICE_OPTION_WANT_AUTHN_SIGNED;\n    }\n\n    if (options & ECP_SERVICE_OPTION_DELEGATION) {\n        APR_ARRAY_PUSH(names, const char *) = \"delegation\";\n        options &= ~ECP_SERVICE_OPTION_DELEGATION;\n    }\n\n    if (options) {\n        APR_ARRAY_PUSH(names, const char *) =\n            apr_psprintf(pool, \"(unknown bits = %#x)\", options);\n    }\n\n    return apr_array_pstrcat(pool, names, ',');\n}\n\n/* Determine if request is compatible with PAOS, decode headers\n *\n * To indicate support for the ECP profile, and the PAOS binding, the\n * request MUST include the following HTTP header fields:\n *\n * 1. An Accept header indicating acceptance of the MIME type\n *    \"application/vnd.paos+xml\"\n *\n * 2. A PAOS header specifying the PAOS version with a value, at minimum, of\n *    \"urn:liberty:paos:2003-08\" and a supported service value of\n *    \"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\". The service value MAY\n *    contain option values.\n *\n * This function validates the Accept header the the PAOS header, if\n * all condidtions are met it returns true, false otherwise. If the\n * validation succeeds any ECP options specified along with the\n * ECP service are parsed and stored in req_cfg->ecp_service_options\n *\n * Any error discovered during processing are returned in the\n * error_code parameter, zero indicates success. This function never\n * returns true if an error occurred.\n *\n * Parameters:\n *  request_rec *r     The current request.\n *  int * error_code   Return error code here\n *\n */\nbool am_is_paos_request(request_rec *r, int *error_code)\n{\n    const char *accept_header = NULL;\n    const char *paos_header = NULL;\n    bool have_paos_media_type = false;\n    bool valid_paos_header = false;\n    bool is_paos = false;\n    ECPServiceOptions ecp_service_options = 0;\n\n    *error_code = 0;\n    accept_header = apr_table_get(r->headers_in, \"Accept\");\n    paos_header = apr_table_get(r->headers_in, \"PAOS\");\n    if (accept_header) {\n        if (am_header_has_media_type(r, accept_header, MEDIA_TYPE_PAOS)) {\n            have_paos_media_type = true;\n        }\n    }\n    if (paos_header) {\n        if (am_parse_paos_header(r, paos_header, &ecp_service_options)) {\n            valid_paos_header = true;\n        } else {\n            if (*error_code == 0)\n                *error_code = AM_ERROR_INVALID_PAOS_HEADER;\n        }\n    }\n    if (have_paos_media_type) {\n        if (valid_paos_header) {\n            is_paos = true;\n        } else {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"request supplied PAOS media type in Accept header \"\n                          \"but omitted valid PAOS header\");\n            if (*error_code == 0)\n                *error_code = AM_ERROR_MISSING_PAOS_HEADER;\n        }\n    } else {\n        if (valid_paos_header) {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"request supplied valid PAOS header \"\n                          \"but omitted PAOS media type in Accept header\");\n            if (*error_code == 0)\n                *error_code = AM_ERROR_MISSING_PAOS_MEDIA_TYPE;\n        }\n    }\n    AM_LOG_RERROR(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"have_paos_media_type=%s valid_paos_header=%s is_paos=%s \"\n                  \"error_code=%d ecp options=[%s]\",\n                  have_paos_media_type ? \"True\" : \"False\",\n                  valid_paos_header ? \"True\" : \"False\",\n                  is_paos ? \"True\" : \"False\",\n                  *error_code,\n                  am_ecp_service_options_str(r->pool, ecp_service_options));\n\n    if (is_paos) {\n        am_req_cfg_rec *req_cfg;\n\n        req_cfg = am_get_req_cfg(r);\n        req_cfg->ecp_service_options = ecp_service_options;\n    }\n\n    return is_paos;\n}\n#endif /* HAVE_ECP */\n\nchar *\nam_saml_response_status_str(request_rec *r, LassoNode *node)\n{\n    LassoSamlp2StatusResponse *response = (LassoSamlp2StatusResponse*)node;\n    LassoSamlp2Status *status = NULL;\n    const char *status_code1 = NULL;\n    const char *status_code2 = NULL;\n\n    if (!LASSO_IS_SAMLP2_STATUS_RESPONSE(response)) {\n        return apr_psprintf(r->pool,\n                            \"error, expected LassoSamlp2StatusResponse \"\n                            \"but got %s\",\n                            lasso_node_get_name((LassoNode*)response));\n    }\n\n    status = response->Status;\n    if (status == NULL                  ||\n        !LASSO_IS_SAMLP2_STATUS(status) ||\n        status->StatusCode == NULL      ||\n        status->StatusCode->Value == NULL) {\n        return apr_psprintf(r->pool, \"Status missing\");\n\n    }\n\n    status_code1 = status->StatusCode->Value;\n    if (status->StatusCode->StatusCode) {\n        status_code2 = status->StatusCode->StatusCode->Value;\n    }\n\n    return apr_psprintf(r->pool,\n                        \"StatusCode1=\\\"%s\\\", StatusCode2=\\\"%s\\\", \"\n                        \"StatusMessage=\\\"%s\\\"\",\n                        status_code1, status_code2, status->StatusMessage);\n}\n"], "filenames": ["auth_mellon_util.c"], "buggy_code_start_loc": [927], "buggy_code_end_loc": [927], "fixing_code_start_loc": [928], "fixing_code_end_loc": [935], "type": "CWE-601", "message": "A vulnerability was found in mod_auth_mellon before v0.14.2. An open redirect in the logout URL allows requests with backslashes to pass through by assuming that it is a relative URL, while the browsers silently convert backslash characters into forward slashes treating them as an absolute URL. This mismatch allows an attacker to bypass the redirect URL validation logic in apr_uri_parse function.", "other": {"cve": {"id": "CVE-2019-3877", "sourceIdentifier": "secalert@redhat.com", "published": "2019-03-27T13:29:01.820", "lastModified": "2019-04-16T18:29:06.780", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in mod_auth_mellon before v0.14.2. An open redirect in the logout URL allows requests with backslashes to pass through by assuming that it is a relative URL, while the browsers silently convert backslash characters into forward slashes treating them as an absolute URL. This mismatch allows an attacker to bypass the redirect URL validation logic in apr_uri_parse function."}, {"lang": "es", "value": "Se ha detectado una vulnerabilidad en mod_auth_mellon, en anteriores a la v0.14.2. Una redirecci\u00f3n abierta en la URL de cierre de sesi\u00f3n permite que las peticiones con barras invertidas pasen asumiendo que es una URL relativa, mientras que los navegadores convierten silenciosamente los caracteres de barra invertida en barras, trat\u00e1ndolos como una URL absoluta. Este error de emparejamiento permite que un atacante omita la l\u00f3gica de validaci\u00f3n de URL de redirecci\u00f3n en la funci\u00f3n apr_uri_parse."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mod_auth_mellon_project:mod_auth_mellon:*:*:*:*:*:apache:*:*", "versionEndExcluding": "0.14.2", "matchCriteriaId": "8FF38978-846A-409A-BEC7-81EADDF30F04"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:0766", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3421", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-3877", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Uninett/mod_auth_mellon/commit/62041428a32de402e0be6ba45fe12df6a83bedb8", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Uninett/mod_auth_mellon/issues/35", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CNW5YMC5TLWVWNJEY6AIWNSNPRAMWPQJ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X7NLAU7KROWNTHAYSA2S67X347F42L2I/", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3924-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Uninett/mod_auth_mellon/commit/62041428a32de402e0be6ba45fe12df6a83bedb8"}}