{"buggy_code": ["import { createPopper } from \"@popperjs/core\";\nimport { withPluginApi } from \"discourse/lib/plugin-api\";\nimport { iconHTML } from \"discourse-common/lib/icon-library\";\n\nlet inlineFootnotePopper;\n\nfunction applyInlineFootnotes(elem) {\n  const footnoteRefs = elem.querySelectorAll(\"sup.footnote-ref\");\n\n  footnoteRefs.forEach((footnoteRef) => {\n    const expandableFootnote = document.createElement(\"a\");\n    expandableFootnote.classList.add(\"expand-footnote\");\n    expandableFootnote.innerHTML = iconHTML(\"ellipsis-h\");\n    expandableFootnote.href = \"\";\n    expandableFootnote.role = \"button\";\n    expandableFootnote.dataset.footnoteId = footnoteRef\n      .querySelector(\"a\")\n      .id.replace(\"footnote-ref-\", \"\");\n\n    footnoteRef.after(expandableFootnote);\n  });\n\n  if (footnoteRefs.length) {\n    elem.classList.add(\"inline-footnotes\");\n  }\n}\n\nfunction buildTooltip() {\n  let html = `\n    <div id=\"footnote-tooltip\" role=\"tooltip\">\n      <div class=\"footnote-tooltip-content\"></div>\n      <div id=\"arrow\" data-popper-arrow></div>\n    </div>\n  `;\n\n  let template = document.createElement(\"template\");\n  html = html.trim();\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nfunction footNoteEventHandler(event) {\n  inlineFootnotePopper?.destroy();\n\n  const tooltip = document.getElementById(\"footnote-tooltip\");\n\n  // reset state by hidding tooltip, it handles \"click outside\"\n  // allowing to hide the tooltip when you click anywhere else\n  tooltip?.removeAttribute(\"data-show\");\n\n  // if we didn't actually click a footnote button, exit early\n  if (!event.target.classList.contains(\"expand-footnote\")) {\n    return;\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n\n  // append footnote to tooltip body\n  const expandableFootnote = event.target;\n  const cooked = expandableFootnote.closest(\".cooked\");\n  const footnoteId = expandableFootnote.dataset.footnoteId;\n  const footnoteContent = tooltip.querySelector(\".footnote-tooltip-content\");\n  const newContent = cooked.querySelector(`#footnote-${footnoteId}`);\n  footnoteContent.innerHTML = newContent.innerHTML;\n\n  // remove backref from tooltip\n  const backRef = footnoteContent.querySelector(\".footnote-backref\");\n  backRef.parentNode.removeChild(backRef);\n\n  // display tooltip\n  tooltip.dataset.show = \"\";\n\n  // setup popper\n  inlineFootnotePopper?.destroy();\n  inlineFootnotePopper = createPopper(expandableFootnote, tooltip, {\n    modifiers: [\n      {\n        name: \"arrow\",\n        options: { element: tooltip.querySelector(\"#arrow\") },\n      },\n      {\n        name: \"preventOverflow\",\n        options: {\n          altAxis: true,\n          padding: 5,\n        },\n      },\n      {\n        name: \"offset\",\n        options: {\n          offset: [0, 12],\n        },\n      },\n    ],\n  });\n}\n\nexport default {\n  name: \"inline-footnotes\",\n\n  initialize(container) {\n    if (!container.lookup(\"site-settings:main\").display_footnotes_inline) {\n      return;\n    }\n\n    document.documentElement.append(buildTooltip());\n\n    window.addEventListener(\"click\", footNoteEventHandler);\n\n    withPluginApi(\"0.8.9\", (api) => {\n      api.decorateCookedElement((elem) => applyInlineFootnotes(elem), {\n        onlyStream: true,\n        id: \"inline-footnotes\",\n      });\n    });\n  },\n\n  teardown() {\n    inlineFootnotePopper?.destroy();\n    window.removeEventListener(\"click\", footNoteEventHandler);\n    document.getElementById(\"footnote-tooltip\")?.remove();\n  },\n};\n", "/* eslint-disable */\n\n/*! markdown-it-footnote 3.0.3 https://github.com//markdown-it/markdown-it-footnote @license MIT */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.markdownitFootnote = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n// Process footnotes\n//\n'use strict';\n\n////////////////////////////////////////////////////////////////////////////////\n// Renderer partials\n\nfunction render_footnote_anchor_name(tokens, idx, options, env/*, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n  var prefix = '';\n\n  if (typeof env.docId === 'string') {\n    prefix = '-' + env.docId + '-';\n  }\n\n  return prefix + n;\n}\n\nfunction render_footnote_caption(tokens, idx/*, options, env, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n\n  if (tokens[idx].meta.subId > 0) {\n    n += ':' + tokens[idx].meta.subId;\n  }\n\n  return '[' + n + ']';\n}\n\nfunction render_footnote_ref(tokens, idx, options, env, slf) {\n  var id      = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n  var caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);\n  var refid   = id;\n\n  if (tokens[idx].meta.subId > 0) {\n    refid += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + id + '\" id=\"fnref' + refid + '\">' + caption + '</a></sup>';\n}\n\nfunction render_footnote_block_open(tokens, idx, options) {\n  return (options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n') +\n         '<section class=\"footnotes\">\\n' +\n         '<ol class=\"footnotes-list\">\\n';\n}\n\nfunction render_footnote_block_close() {\n  return '</ol>\\n</section>\\n';\n}\n\nfunction render_footnote_open(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<li id=\"fn' + id + '\" class=\"footnote-item\">';\n}\n\nfunction render_footnote_close() {\n  return '</li>\\n';\n}\n\nfunction render_footnote_anchor(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  /* \u21a9 with escape code to prevent display as Apple Emoji on iOS */\n  return ' <a href=\"#fnref' + id + '\" class=\"footnote-backref\">\\u21a9\\uFE0E</a>';\n}\n\n\nmodule.exports = function footnote_plugin(md) {\n  var parseLinkLabel = md.helpers.parseLinkLabel,\n      isSpace = md.utils.isSpace;\n\n  md.renderer.rules.footnote_ref          = render_footnote_ref;\n  md.renderer.rules.footnote_block_open   = render_footnote_block_open;\n  md.renderer.rules.footnote_block_close  = render_footnote_block_close;\n  md.renderer.rules.footnote_open         = render_footnote_open;\n  md.renderer.rules.footnote_close        = render_footnote_close;\n  md.renderer.rules.footnote_anchor       = render_footnote_anchor;\n\n  // helpers (only used in other rules, no tokens are attached to those)\n  md.renderer.rules.footnote_caption      = render_footnote_caption;\n  md.renderer.rules.footnote_anchor_name  = render_footnote_anchor_name;\n\n  // Process footnote block definition\n  function footnote_def(state, startLine, endLine, silent) {\n    var oldBMark, oldTShift, oldSCount, oldParentType, pos, label, token,\n        initial, offset, ch, posAfterColon,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // line should be at least 5 chars - \"[^x]:\"\n    if (start + 4 > max) { return false; }\n\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n    if (silent) { return true; }\n    pos++;\n\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n    label = state.src.slice(start + 2, pos - 2);\n    state.env.footnotes.refs[':' + label] = -1;\n\n    token       = new state.Token('footnote_reference_open', '', 1);\n    token.meta  = { label: label };\n    token.level = state.level++;\n    state.tokens.push(token);\n\n    oldBMark = state.bMarks[startLine];\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n    oldParentType = state.parentType;\n\n    posAfterColon = pos;\n    initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    state.tShift[startLine] = pos - posAfterColon;\n    state.sCount[startLine] = offset - initial;\n\n    state.bMarks[startLine] = posAfterColon;\n    state.blkIndent += 4;\n    state.parentType = 'footnote';\n\n    if (state.sCount[startLine] < state.blkIndent) {\n      state.sCount[startLine] += state.blkIndent;\n    }\n\n    state.md.block.tokenize(state, startLine, endLine, true);\n\n    state.parentType = oldParentType;\n    state.blkIndent -= 4;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.bMarks[startLine] = oldBMark;\n\n    token       = new state.Token('footnote_reference_close', '', -1);\n    token.level = --state.level;\n    state.tokens.push(token);\n\n    return true;\n  }\n\n  // Process inline footnotes (^[...])\n  function footnote_inline(state, silent) {\n    var labelStart,\n        labelEnd,\n        footnoteId,\n        token,\n        tokens,\n        max = state.posMax,\n        start = state.pos;\n\n    if (start + 2 >= max) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n\n    labelStart = start + 2;\n    labelEnd = parseLinkLabel(state, start + 1);\n\n    // parser failed to find ']', so it's not a valid note\n    if (labelEnd < 0) { return false; }\n\n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    //\n    if (!silent) {\n      if (!state.env.footnotes) { state.env.footnotes = {}; }\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n      footnoteId = state.env.footnotes.list.length;\n\n      state.md.inline.parse(\n        state.src.slice(labelStart, labelEnd),\n        state.md,\n        state.env,\n        tokens = []\n      );\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId };\n\n      state.env.footnotes.list[footnoteId] = {\n        content: state.src.slice(labelStart, labelEnd),\n        tokens: tokens\n      };\n    }\n\n    state.pos = labelEnd + 1;\n    state.posMax = max;\n    return true;\n  }\n\n  // Process footnote references ([^...])\n  function footnote_ref(state, silent) {\n    var label,\n        pos,\n        footnoteId,\n        footnoteSubId,\n        token,\n        max = state.posMax,\n        start = state.pos;\n\n    // should be at least 4 chars - \"[^x]\"\n    if (start + 3 > max) { return false; }\n\n    if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos >= max) { return false; }\n    pos++;\n\n    label = state.src.slice(start + 2, pos - 1);\n    if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n    if (!silent) {\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n      if (state.env.footnotes.refs[':' + label] < 0) {\n        footnoteId = state.env.footnotes.list.length;\n        state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n        state.env.footnotes.refs[':' + label] = footnoteId;\n      } else {\n        footnoteId = state.env.footnotes.refs[':' + label];\n      }\n\n      footnoteSubId = state.env.footnotes.list[footnoteId].count;\n      state.env.footnotes.list[footnoteId].count++;\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId, subId: footnoteSubId, label: label };\n    }\n\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  }\n\n  // Glue footnote tokens to end of token stream\n  function footnote_tail(state) {\n    var i, l, j, t, lastParagraph, list, token, tokens, current, currentLabel,\n        insideRef = false,\n        refTokens = {};\n\n    if (!state.env.footnotes) { return; }\n\n    state.tokens = state.tokens.filter(function (tok) {\n      if (tok.type === 'footnote_reference_open') {\n        insideRef = true;\n        current = [];\n        currentLabel = tok.meta.label;\n        return false;\n      }\n      if (tok.type === 'footnote_reference_close') {\n        insideRef = false;\n        // prepend ':' to avoid conflict with Object.prototype members\n        refTokens[':' + currentLabel] = current;\n        return false;\n      }\n      if (insideRef) { current.push(tok); }\n      return !insideRef;\n    });\n\n    if (!state.env.footnotes.list) { return; }\n    list = state.env.footnotes.list;\n\n    token = new state.Token('footnote_block_open', '', 1);\n    state.tokens.push(token);\n\n    for (i = 0, l = list.length; i < l; i++) {\n      token      = new state.Token('footnote_open', '', 1);\n      token.meta = { id: i, label: list[i].label };\n      state.tokens.push(token);\n\n      if (list[i].tokens) {\n        tokens = [];\n\n        token          = new state.Token('paragraph_open', 'p', 1);\n        token.block    = true;\n        tokens.push(token);\n\n        token          = new state.Token('inline', '', 0);\n        token.children = list[i].tokens;\n        token.content  = list[i].content;\n        tokens.push(token);\n\n        token          = new state.Token('paragraph_close', 'p', -1);\n        token.block    = true;\n        tokens.push(token);\n\n      } else if (list[i].label) {\n        tokens = refTokens[':' + list[i].label];\n      }\n\n      if (tokens) state.tokens = state.tokens.concat(tokens);\n      if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n        lastParagraph = state.tokens.pop();\n      } else {\n        lastParagraph = null;\n      }\n\n      t = list[i].count > 0 ? list[i].count : 1;\n      for (j = 0; j < t; j++) {\n        token      = new state.Token('footnote_anchor', '', 0);\n        token.meta = { id: i, subId: j, label: list[i].label };\n        state.tokens.push(token);\n      }\n\n      if (lastParagraph) {\n        state.tokens.push(lastParagraph);\n      }\n\n      token = new state.Token('footnote_close', '', -1);\n      state.tokens.push(token);\n    }\n\n    token = new state.Token('footnote_block_close', '', -1);\n    state.tokens.push(token);\n  }\n\n  md.block.ruler.before('reference', 'footnote_def', footnote_def, { alt: [ 'paragraph', 'reference' ] });\n  md.inline.ruler.after('image', 'footnote_inline', footnote_inline);\n  md.inline.ruler.after('footnote_inline', 'footnote_ref', footnote_ref);\n  md.core.ruler.after('inline', 'footnote_tail', footnote_tail);\n};\n\n},{}]},{},[1])(1)\n});\n", "# frozen_string_literal: true\n# transpile_js: true\n# name: discourse-footnote\n# about: Adds markdown.it footnote support to Discourse\n# version: 0.1\n# authors: Sam Saffron, Vitaly Puzrin\n# url: https://github.com/discourse/discourse-footnote\n\nenabled_site_setting :enable_markdown_footnotes\n\nregister_asset \"vendor/javascripts/markdown-it-footnote.js\", :vendored_pretty_text\n\nregister_asset \"stylesheets/footnotes.scss\"\n\nregister_svg_icon \"ellipsis-h\" if respond_to?(:register_svg_icon)\n\nDiscourseEvent.on(:before_post_process_cooked) do |doc, post|\n  doc.css('a.footnote-backref').each do |backref|\n    href = backref[\"href\"] || \"\"\n    id = href[6..-1].to_i\n    backref[\"href\"] = \"#footnote-ref-#{post.id}-#{id}\"\n  end\n\n  doc.css('sup.footnote-ref a').each do |ref|\n    href = ref[\"href\"] || \"\"\n    id = href[3..-1].to_i\n    ref[\"href\"] = \"#footnote-#{post.id}-#{id}\"\n\n    id = ref[\"id\"] || \"\"\n    id = id[5..-1].to_i\n    ref[\"id\"] = \"footnote-ref-#{post.id}-#{id}\"\n  end\n\n  doc.css('li.footnote-item').each do |li|\n    id = li[\"id\"] || \"\"\n    id = id[2..-1].to_i\n\n    li[\"id\"] = \"footnote-#{post.id}-#{id}\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe PrettyText do\n  before do\n    SiteSetting.queue_jobs = false\n  end\n\n  it \"can be disabled\" do\n    SiteSetting.enable_markdown_footnotes = false\n\n    markdown = <<~MD\n      Here is a footnote, [^1]\n\n      [^1]: I am one\n    MD\n\n    html = <<~HTML\n      <p>Here is a footnote, [^1]</p>\\n<p>[^1]: I am one</p>\n    HTML\n\n    cooked = PrettyText.cook markdown.strip\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports normal footnotes\" do\n    markdown = <<~MD\n      Here is a footnote, [^1] and another. [^test]\n\n      [^1]: I am one\n\n      [^test]: I am one\n\n       test multiline\n    MD\n\n    html = <<~HTML\n      <p>Here is a footnote, <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> and another. <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n      <p>test multiline</p>\n      <hr class=\"footnotes-sep\">\n\n      <ol class=\"footnotes-list\">\n      <li id=\"fn1\" class=\"footnote-item\">\n      <p>I am one <a href=\"#fnref1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      <li id=\"fn2\" class=\"footnote-item\">\n      <p>I am one <a href=\"#fnref2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      </ol>\n    HTML\n\n    cooked = PrettyText.cook markdown.strip\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"applies unique ids to elements after cooking a post\" do\n    raw = <<~MD\n      Here is a footnote, [^1] and another. [^test]\n\n      [^1]: I am one\n\n      [^test]: I am one\n\n       test multiline\n    MD\n\n    post = create_post(raw: raw)\n    post.reload\n\n    html = <<~HTML\n      <p>Here is a footnote, <sup class=\"footnote-ref\"><a href=\"#footnote-#{post.id}-1\" id=\"footnote-ref-#{post.id}-1\">[1]</a></sup> and another. <sup class=\"footnote-ref\"><a href=\"#footnote-#{post.id}-2\" id=\"footnote-ref-#{post.id}-2\">[2]</a></sup></p>\n      <p>test multiline</p>\n      <hr class=\"footnotes-sep\">\n\n      <ol class=\"footnotes-list\">\n      <li id=\"footnote-#{post.id}-1\" class=\"footnote-item\">\n      <p>I am one <a href=\"#footnote-ref-#{post.id}-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      <li id=\"footnote-#{post.id}-2\" class=\"footnote-item\">\n      <p>I am one <a href=\"#footnote-ref-#{post.id}-2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      </ol>\n    HTML\n\n    expect(post.cooked.strip).to eq(html.strip)\n\n  end\n\nend\n"], "fixing_code": ["import { createPopper } from \"@popperjs/core\";\nimport { withPluginApi } from \"discourse/lib/plugin-api\";\nimport { iconHTML } from \"discourse-common/lib/icon-library\";\n\nlet inlineFootnotePopper;\n\nfunction applyInlineFootnotes(elem) {\n  const footnoteRefs = elem.querySelectorAll(\"sup.footnote-ref\");\n\n  footnoteRefs.forEach((footnoteRef) => {\n    const refLink = footnoteRef.querySelector(\"a\");\n    if (!refLink) {\n      return;\n    }\n\n    const expandableFootnote = document.createElement(\"a\");\n    expandableFootnote.classList.add(\"expand-footnote\");\n    expandableFootnote.innerHTML = iconHTML(\"ellipsis-h\");\n    expandableFootnote.href = \"\";\n    expandableFootnote.role = \"button\";\n    expandableFootnote.dataset.footnoteId = refLink.id.replace(\n      \"footnote-ref-\",\n      \"\"\n    );\n\n    footnoteRef.after(expandableFootnote);\n  });\n\n  if (footnoteRefs.length) {\n    elem.classList.add(\"inline-footnotes\");\n  }\n}\n\nfunction buildTooltip() {\n  let html = `\n    <div id=\"footnote-tooltip\" role=\"tooltip\">\n      <div class=\"footnote-tooltip-content\"></div>\n      <div id=\"arrow\" data-popper-arrow></div>\n    </div>\n  `;\n\n  let template = document.createElement(\"template\");\n  html = html.trim();\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nfunction footNoteEventHandler(event) {\n  inlineFootnotePopper?.destroy();\n\n  const tooltip = document.getElementById(\"footnote-tooltip\");\n\n  // reset state by hidding tooltip, it handles \"click outside\"\n  // allowing to hide the tooltip when you click anywhere else\n  tooltip?.removeAttribute(\"data-show\");\n\n  // if we didn't actually click a footnote button, exit early\n  if (!event.target.classList.contains(\"expand-footnote\")) {\n    return;\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n\n  // append footnote to tooltip body\n  const expandableFootnote = event.target;\n  const cooked = expandableFootnote.closest(\".cooked\");\n  const footnoteId = expandableFootnote.dataset.footnoteId;\n  const footnoteContent = tooltip.querySelector(\".footnote-tooltip-content\");\n  const newContent = cooked.querySelector(`#footnote-${footnoteId}`);\n  footnoteContent.innerHTML = newContent.innerHTML;\n\n  // remove backref from tooltip\n  const backRef = footnoteContent.querySelector(\".footnote-backref\");\n  backRef.parentNode.removeChild(backRef);\n\n  // display tooltip\n  tooltip.dataset.show = \"\";\n\n  // setup popper\n  inlineFootnotePopper?.destroy();\n  inlineFootnotePopper = createPopper(expandableFootnote, tooltip, {\n    modifiers: [\n      {\n        name: \"arrow\",\n        options: { element: tooltip.querySelector(\"#arrow\") },\n      },\n      {\n        name: \"preventOverflow\",\n        options: {\n          altAxis: true,\n          padding: 5,\n        },\n      },\n      {\n        name: \"offset\",\n        options: {\n          offset: [0, 12],\n        },\n      },\n    ],\n  });\n}\n\nexport default {\n  name: \"inline-footnotes\",\n\n  initialize(container) {\n    if (!container.lookup(\"site-settings:main\").display_footnotes_inline) {\n      return;\n    }\n\n    document.documentElement.append(buildTooltip());\n\n    window.addEventListener(\"click\", footNoteEventHandler);\n\n    withPluginApi(\"0.8.9\", (api) => {\n      api.decorateCookedElement((elem) => applyInlineFootnotes(elem), {\n        onlyStream: true,\n        id: \"inline-footnotes\",\n      });\n    });\n  },\n\n  teardown() {\n    inlineFootnotePopper?.destroy();\n    window.removeEventListener(\"click\", footNoteEventHandler);\n    document.getElementById(\"footnote-tooltip\")?.remove();\n  },\n};\n", "/* eslint-disable */\n\n/*! markdown-it-footnote 3.0.3 https://github.com//markdown-it/markdown-it-footnote @license MIT */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.markdownitFootnote = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n// Process footnotes\n//\n'use strict';\n\n////////////////////////////////////////////////////////////////////////////////\n// Renderer partials\n\nfunction render_footnote_anchor_name(tokens, idx, options, env/*, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n  var prefix = '';\n\n  if (typeof env.docId === 'string') {\n    prefix = '-' + env.docId + '-';\n  }\n\n  return prefix + n;\n}\n\nfunction render_footnote_caption(tokens, idx/*, options, env, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n\n  if (tokens[idx].meta.subId > 0) {\n    n += ':' + tokens[idx].meta.subId;\n  }\n\n  return '[' + n + ']';\n}\n\nfunction render_footnote_ref(tokens, idx, options, env, slf) {\n  var id      = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n  var caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);\n  var refid   = id;\n\n  if (tokens[idx].meta.subId > 0) {\n    refid += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + id + '\" id=\"fnref' + refid + '\">' + caption + '</a></sup>';\n}\n\nfunction render_footnote_block_open(tokens, idx, options) {\n  return (options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n') +\n         '<section class=\"footnotes\">\\n' +\n         '<ol class=\"footnotes-list\">\\n';\n}\n\nfunction render_footnote_block_close() {\n  return '</ol>\\n</section>\\n';\n}\n\nfunction render_footnote_open(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<li id=\"fn' + id + '\" class=\"footnote-item\">';\n}\n\nfunction render_footnote_close() {\n  return '</li>\\n';\n}\n\nfunction render_footnote_anchor(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  /* \u21a9 with escape code to prevent display as Apple Emoji on iOS */\n  return ' <a href=\"#fnref' + id + '\" class=\"footnote-backref\">\\u21a9\\uFE0E</a>';\n}\n\n\nmodule.exports = function footnote_plugin(md) {\n  var parseLinkLabel = md.helpers.parseLinkLabel,\n      isSpace = md.utils.isSpace;\n\n  md.renderer.rules.footnote_ref          = render_footnote_ref;\n  md.renderer.rules.footnote_block_open   = render_footnote_block_open;\n  md.renderer.rules.footnote_block_close  = render_footnote_block_close;\n  md.renderer.rules.footnote_open         = render_footnote_open;\n  md.renderer.rules.footnote_close        = render_footnote_close;\n  md.renderer.rules.footnote_anchor       = render_footnote_anchor;\n\n  // helpers (only used in other rules, no tokens are attached to those)\n  md.renderer.rules.footnote_caption      = render_footnote_caption;\n  md.renderer.rules.footnote_anchor_name  = render_footnote_anchor_name;\n\n  // Process footnote block definition\n  function footnote_def(state, startLine, endLine, silent) {\n    var oldBMark, oldTShift, oldSCount, oldParentType, pos, label, token,\n        initial, offset, ch, posAfterColon,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // line should be at least 5 chars - \"[^x]:\"\n    if (start + 4 > max) { return false; }\n\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n    if (silent) { return true; }\n    pos++;\n\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n    label = state.src.slice(start + 2, pos - 2);\n    state.env.footnotes.refs[':' + label] = -1;\n\n    token       = new state.Token('footnote_reference_open', '', 1);\n    token.meta  = { label: label };\n    token.level = state.level++;\n    state.tokens.push(token);\n\n    oldBMark = state.bMarks[startLine];\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n    oldParentType = state.parentType;\n\n    posAfterColon = pos;\n    initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    state.tShift[startLine] = pos - posAfterColon;\n    state.sCount[startLine] = offset - initial;\n\n    state.bMarks[startLine] = posAfterColon;\n    state.blkIndent += 4;\n    state.parentType = 'footnote';\n\n    if (state.sCount[startLine] < state.blkIndent) {\n      state.sCount[startLine] += state.blkIndent;\n    }\n\n    state.md.block.tokenize(state, startLine, endLine, true);\n\n    state.parentType = oldParentType;\n    state.blkIndent -= 4;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.bMarks[startLine] = oldBMark;\n\n    token       = new state.Token('footnote_reference_close', '', -1);\n    token.level = --state.level;\n    state.tokens.push(token);\n\n    return true;\n  }\n\n  // Process inline footnotes (^[...])\n  function footnote_inline(state, silent) {\n    var labelStart,\n        labelEnd,\n        footnoteId,\n        token,\n        tokens,\n        max = state.posMax,\n        start = state.pos;\n\n    if (start + 2 >= max) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n\n    labelStart = start + 2;\n    labelEnd = parseLinkLabel(state, start + 1);\n\n    // parser failed to find ']', so it's not a valid note\n    if (labelEnd < 0) { return false; }\n\n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    //\n    if (!silent) {\n      if (!state.env.footnotes) { state.env.footnotes = {}; }\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n      footnoteId = state.env.footnotes.list.length;\n\n      state.md.inline.parse(\n        state.src.slice(labelStart, labelEnd),\n        state.md,\n        state.env,\n        tokens = []\n      );\n\n      // Having a rendered footnote inside a link creates a nested link, which\n      // is not valid HTML, so close the parent tag first before proceeding.\n      const previousToken = state.tokens[state.tokens.length - 1];\n      if (previousToken?.content.includes(\"<a\")) {\n        const linkCloseToken = state.push(\"html_inline\", \"\", 0);\n        linkCloseToken.content = \"</a>\";\n        linkCloseToken.block = false;\n      }\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId };\n\n      state.env.footnotes.list[footnoteId] = {\n        content: state.src.slice(labelStart, labelEnd),\n        tokens: tokens\n      };\n    }\n\n    state.pos = labelEnd + 1;\n    state.posMax = max;\n    return true;\n  }\n\n  // Process footnote references ([^...])\n  function footnote_ref(state, silent) {\n    var label,\n        pos,\n        footnoteId,\n        footnoteSubId,\n        token,\n        max = state.posMax,\n        start = state.pos;\n\n    // should be at least 4 chars - \"[^x]\"\n    if (start + 3 > max) { return false; }\n\n    if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos >= max) { return false; }\n    pos++;\n\n    label = state.src.slice(start + 2, pos - 1);\n    if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n    if (!silent) {\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n      if (state.env.footnotes.refs[':' + label] < 0) {\n        footnoteId = state.env.footnotes.list.length;\n        state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n        state.env.footnotes.refs[':' + label] = footnoteId;\n      } else {\n        footnoteId = state.env.footnotes.refs[':' + label];\n      }\n\n      footnoteSubId = state.env.footnotes.list[footnoteId].count;\n      state.env.footnotes.list[footnoteId].count++;\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId, subId: footnoteSubId, label: label };\n    }\n\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  }\n\n  // Glue footnote tokens to end of token stream\n  function footnote_tail(state) {\n    var i, l, j, t, lastParagraph, list, token, tokens, current, currentLabel,\n        insideRef = false,\n        refTokens = {};\n\n    if (!state.env.footnotes) { return; }\n\n    state.tokens = state.tokens.filter(function (tok) {\n      if (tok.type === 'footnote_reference_open') {\n        insideRef = true;\n        current = [];\n        currentLabel = tok.meta.label;\n        return false;\n      }\n      if (tok.type === 'footnote_reference_close') {\n        insideRef = false;\n        // prepend ':' to avoid conflict with Object.prototype members\n        refTokens[':' + currentLabel] = current;\n        return false;\n      }\n      if (insideRef) { current.push(tok); }\n      return !insideRef;\n    });\n\n    if (!state.env.footnotes.list) { return; }\n    list = state.env.footnotes.list;\n\n    token = new state.Token('footnote_block_open', '', 1);\n    state.tokens.push(token);\n\n    for (i = 0, l = list.length; i < l; i++) {\n      token      = new state.Token('footnote_open', '', 1);\n      token.meta = { id: i, label: list[i].label };\n      state.tokens.push(token);\n\n      if (list[i].tokens) {\n        tokens = [];\n\n        token          = new state.Token('paragraph_open', 'p', 1);\n        token.block    = true;\n        tokens.push(token);\n\n        token          = new state.Token('inline', '', 0);\n        token.children = list[i].tokens;\n        token.content  = list[i].content;\n        tokens.push(token);\n\n        token          = new state.Token('paragraph_close', 'p', -1);\n        token.block    = true;\n        tokens.push(token);\n\n      } else if (list[i].label) {\n        tokens = refTokens[':' + list[i].label];\n      }\n\n      if (tokens) state.tokens = state.tokens.concat(tokens);\n      if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n        lastParagraph = state.tokens.pop();\n      } else {\n        lastParagraph = null;\n      }\n\n      t = list[i].count > 0 ? list[i].count : 1;\n      for (j = 0; j < t; j++) {\n        token      = new state.Token('footnote_anchor', '', 0);\n        token.meta = { id: i, subId: j, label: list[i].label };\n        state.tokens.push(token);\n      }\n\n      if (lastParagraph) {\n        state.tokens.push(lastParagraph);\n      }\n\n      token = new state.Token('footnote_close', '', -1);\n      state.tokens.push(token);\n    }\n\n    token = new state.Token('footnote_block_close', '', -1);\n    state.tokens.push(token);\n  }\n\n  md.block.ruler.before('reference', 'footnote_def', footnote_def, { alt: [ 'paragraph', 'reference' ] });\n  md.inline.ruler.after('image', 'footnote_inline', footnote_inline);\n  md.inline.ruler.after('footnote_inline', 'footnote_ref', footnote_ref);\n  md.core.ruler.after('inline', 'footnote_tail', footnote_tail);\n};\n\n},{}]},{},[1])(1)\n});\n", "# frozen_string_literal: true\n# transpile_js: true\n# name: discourse-footnote\n# about: Adds markdown.it footnote support to Discourse\n# version: 0.2\n# authors: Sam Saffron, Vitaly Puzrin\n# url: https://github.com/discourse/discourse-footnote\n\nenabled_site_setting :enable_markdown_footnotes\n\nregister_asset \"vendor/javascripts/markdown-it-footnote.js\", :vendored_pretty_text\n\nregister_asset \"stylesheets/footnotes.scss\"\n\nregister_svg_icon \"ellipsis-h\" if respond_to?(:register_svg_icon)\n\nDiscourseEvent.on(:before_post_process_cooked) do |doc, post|\n  doc.css('a.footnote-backref').each do |backref|\n    href = backref[\"href\"] || \"\"\n    id = href[6..-1].to_i\n    backref[\"href\"] = \"#footnote-ref-#{post.id}-#{id}\"\n  end\n\n  doc.css('sup.footnote-ref a').each do |ref|\n    href = ref[\"href\"] || \"\"\n    id = href[3..-1].to_i\n    ref[\"href\"] = \"#footnote-#{post.id}-#{id}\"\n\n    id = ref[\"id\"] || \"\"\n    id = id[5..-1].to_i\n    ref[\"id\"] = \"footnote-ref-#{post.id}-#{id}\"\n  end\n\n  doc.css('li.footnote-item').each do |li|\n    id = li[\"id\"] || \"\"\n    id = id[2..-1].to_i\n\n    li[\"id\"] = \"footnote-#{post.id}-#{id}\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe PrettyText do\n  before do\n    SiteSetting.queue_jobs = false\n  end\n\n  it \"can be disabled\" do\n    SiteSetting.enable_markdown_footnotes = false\n\n    markdown = <<~MD\n      Here is a footnote, [^1]\n\n      [^1]: I am one\n    MD\n\n    html = <<~HTML\n      <p>Here is a footnote, [^1]</p>\\n<p>[^1]: I am one</p>\n    HTML\n\n    cooked = PrettyText.cook markdown.strip\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports normal footnotes\" do\n    markdown = <<~MD\n      Here is a footnote, [^1] and another. [^test]\n\n      [^1]: I am one\n\n      [^test]: I am one\n\n       test multiline\n    MD\n\n    html = <<~HTML\n      <p>Here is a footnote, <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> and another. <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n      <p>test multiline</p>\n      <hr class=\"footnotes-sep\">\n\n      <ol class=\"footnotes-list\">\n      <li id=\"fn1\" class=\"footnote-item\">\n      <p>I am one <a href=\"#fnref1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      <li id=\"fn2\" class=\"footnote-item\">\n      <p>I am one <a href=\"#fnref2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      </ol>\n    HTML\n\n    cooked = PrettyText.cook markdown.strip\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"applies unique ids to elements after cooking a post\" do\n    raw = <<~MD\n      Here is a footnote, [^1] and another. [^test]\n\n      [^1]: I am one\n\n      [^test]: I am one\n\n       test multiline\n    MD\n\n    post = create_post(raw: raw)\n    post.reload\n\n    html = <<~HTML\n      <p>Here is a footnote, <sup class=\"footnote-ref\"><a href=\"#footnote-#{post.id}-1\" id=\"footnote-ref-#{post.id}-1\">[1]</a></sup> and another. <sup class=\"footnote-ref\"><a href=\"#footnote-#{post.id}-2\" id=\"footnote-ref-#{post.id}-2\">[2]</a></sup></p>\n      <p>test multiline</p>\n      <hr class=\"footnotes-sep\">\n\n      <ol class=\"footnotes-list\">\n      <li id=\"footnote-#{post.id}-1\" class=\"footnote-item\">\n      <p>I am one <a href=\"#footnote-ref-#{post.id}-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      <li id=\"footnote-#{post.id}-2\" class=\"footnote-item\">\n      <p>I am one <a href=\"#footnote-ref-#{post.id}-2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      </ol>\n    HTML\n\n    expect(post.cooked.strip).to eq(html.strip)\n\n  end\n\n  it \"supports inline footnotes wrapped in <a> elements by ending the elements early\" do\n    raw = <<~MD\n      I have a point, see footnote. <a>^[the point]</a>\n\n      <a>^[footnote]</a>\n    MD\n\n    post = create_post(raw: raw)\n    post.reload\n\n    html = <<~HTML\n      <p>I have a point, see footnote. <a></a><sup class=\"footnote-ref\"><a href=\"#footnote-#{post.id}-1\" id=\"footnote-ref-#{post.id}-1\">[1]</a></sup></p>\n      <p><a></a><sup class=\"footnote-ref\"><a href=\"#footnote-#{post.id}-2\" id=\"footnote-ref-#{post.id}-2\">[2]</a></sup></p>\n      <hr class=\"footnotes-sep\">\n\n      <ol class=\"footnotes-list\">\n      <li id=\"footnote-#{post.id}-1\" class=\"footnote-item\">\n      <p>the point <a href=\"#footnote-ref-#{post.id}-1\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      <li id=\"footnote-#{post.id}-2\" class=\"footnote-item\">\n      <p>footnote <a href=\"#footnote-ref-#{post.id}-2\" class=\"footnote-backref\">\u21a9\ufe0e</a></p>\n      </li>\n      </ol>\n    HTML\n\n    expect(post.cooked.strip).to eq(html.strip)\n  end\nend\n"], "filenames": ["assets/javascripts/initializers/inline-footnotes.js", "assets/vendor/javascripts/markdown-it-footnote.js", "plugin.rb", "spec/pretty_text_spec.rb"], "buggy_code_start_loc": [10, 214, 5, 89], "buggy_code_end_loc": [19, 214, 6, 89], "fixing_code_start_loc": [11, 215, 5, 90], "fixing_code_end_loc": [25, 224, 6, 117], "type": "CWE-755", "message": "discourse-footnote is a library providing footnotes for posts in Discourse. ### Impact When posting an inline footnote wrapped in `<a>` tags (e.g. `<a>^[footnote]</a>`, the resulting rendered HTML would include a nested `<a>`, which is stripped by Nokogiri because it is not valid. This then caused a javascript error on topic pages because we were looking for an `<a>` element inside the footnote reference span and getting its ID, and because it did not exist we got a null reference error in javascript. Users are advised to update to version 0.2. As a workaround editing offending posts from the rails console or the database console for self-hosters, or disabling the plugin in the admin panel can mitigate this issue.", "other": {"cve": {"id": "CVE-2021-43827", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-14T23:15:08.020", "lastModified": "2021-12-29T20:31:48.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "discourse-footnote is a library providing footnotes for posts in Discourse. ### Impact When posting an inline footnote wrapped in `<a>` tags (e.g. `<a>^[footnote]</a>`, the resulting rendered HTML would include a nested `<a>`, which is stripped by Nokogiri because it is not valid. This then caused a javascript error on topic pages because we were looking for an `<a>` element inside the footnote reference span and getting its ID, and because it did not exist we got a null reference error in javascript. Users are advised to update to version 0.2. As a workaround editing offending posts from the rails console or the database console for self-hosters, or disabling the plugin in the admin panel can mitigate this issue."}, {"lang": "es", "value": "discourse-footnote es una biblioteca que proporciona notas a pie de p\u00e1gina para los mensajes en Discourse. ### Impacto Cuando es publicada una nota al pie de p\u00e1gina en l\u00ednea envuelta en etiquetas \"(a)\" (por ejemplo, \"(a)^[footnote](/a)\", el HTML resultante incluye un \"(a)\" anidado, que es eliminado por Nokogiri porque no es v\u00e1lido. Esto causaba un error de javascript en las p\u00e1ginas de los temas porque busc\u00e1bamos un elemento \"(a)\" dentro del span de referencia de la nota al pie y obten\u00edamos su ID, y como no se presentaba obten\u00edamos un error de referencia null en javascript. Es recomendado a usuarios que actualicen a la versi\u00f3n 0.2. Como soluci\u00f3n a este problema, pueden editarse las entradas en cuesti\u00f3n desde la consola de rails o la consola de la base de datos en el caso de los auto alojados, o deshabilitar el plugin en el panel de administraci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse_footnote:*:*:*:*:*:discourse:*:*", "versionEndExcluding": "0.2", "matchCriteriaId": "08855F99-016D-4D36-A462-6D60CB5C970F"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-footnote/commit/796617e0131277011207541313522cd1946661ab", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse-footnote/security/advisories/GHSA-58vr-c56v-qr57", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-footnote/commit/796617e0131277011207541313522cd1946661ab"}}