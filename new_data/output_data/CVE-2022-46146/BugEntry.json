{"buggy_code": ["// Copyright 2020 The Prometheus Authors\n// This code is partly borrowed from Caddy:\n//    Copyright 2015 Matthew Holt and The Caddy Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/go-kit/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// extraHTTPHeaders is a map of HTTP headers that can be added to HTTP\n// responses.\n// This is private on purpose to ensure consistency in the Prometheus ecosystem.\nvar extraHTTPHeaders = map[string][]string{\n\t\"Strict-Transport-Security\": nil,\n\t\"X-Content-Type-Options\":    {\"nosniff\"},\n\t\"X-Frame-Options\":           {\"deny\", \"sameorigin\"},\n\t\"X-XSS-Protection\":          nil,\n\t\"Content-Security-Policy\":   nil,\n}\n\nfunc validateUsers(configPath string) error {\n\tc, err := getConfig(configPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, p := range c.Users {\n\t\t_, err = bcrypt.Cost([]byte(p))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateHeaderConfig checks that the provided header configuration is correct.\n// It does not check the validity of all the values, only the ones which are\n// well-defined enumerations.\nfunc validateHeaderConfig(headers map[string]string) error {\nHeadersLoop:\n\tfor k, v := range headers {\n\t\tvalues, ok := extraHTTPHeaders[k]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"HTTP header %q can not be configured\", k)\n\t\t}\n\t\tfor _, allowedValue := range values {\n\t\t\tif v == allowedValue {\n\t\t\t\tcontinue HeadersLoop\n\t\t\t}\n\t\t}\n\t\tif len(values) > 0 {\n\t\t\treturn fmt.Errorf(\"invalid value for %s. Expected one of: %q, but got: %q\", k, values, v)\n\t\t}\n\t}\n\treturn nil\n}\n\ntype webHandler struct {\n\ttlsConfigPath string\n\thandler       http.Handler\n\tlogger        log.Logger\n\tcache         *cache\n\t// bcryptMtx is there to ensure that bcrypt.CompareHashAndPassword is run\n\t// only once in parallel as this is CPU intensive.\n\tbcryptMtx sync.Mutex\n}\n\nfunc (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tc, err := getConfig(u.tlsConfigPath)\n\tif err != nil {\n\t\tu.logger.Log(\"msg\", \"Unable to parse configuration\", \"err\", err)\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Configure http headers.\n\tfor k, v := range c.HTTPConfig.Header {\n\t\tw.Header().Set(k, v)\n\t}\n\n\tif len(c.Users) == 0 {\n\t\tu.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\tuser, pass, auth := r.BasicAuth()\n\tif auth {\n\t\thashedPassword, validUser := c.Users[user]\n\n\t\tif !validUser {\n\t\t\t// The user is not found. Use a fixed password hash to\n\t\t\t// prevent user enumeration by timing requests.\n\t\t\t// This is a bcrypt-hashed version of \"fakepassword\".\n\t\t\thashedPassword = \"$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi\"\n\t\t}\n\n\t\tcacheKey := hex.EncodeToString(append(append([]byte(user), []byte(hashedPassword)...), []byte(pass)...))\n\t\tauthOk, ok := u.cache.get(cacheKey)\n\n\t\tif !ok {\n\t\t\t// This user, hashedPassword, password is not cached.\n\t\t\tu.bcryptMtx.Lock()\n\t\t\terr := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))\n\t\t\tu.bcryptMtx.Unlock()\n\n\t\t\tauthOk = err == nil\n\t\t\tu.cache.set(cacheKey, authOk)\n\t\t}\n\n\t\tif authOk && validUser {\n\t\t\tu.handler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n}\n", "// Copyright 2021 The Prometheus Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"sync\"\n\t\"testing\"\n)\n\n// TestBasicAuthCache validates that the cache is working by calling a password\n// protected endpoint multiple times.\nfunc TestBasicAuthCache(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_users_noTLS.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tlogin := func(username, password string, code int) {\n\t\tclient := &http.Client{}\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq.SetBasicAuth(username, password)\n\t\tr, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif r.StatusCode != code {\n\t\t\tt.Fatalf(\"bad return code, expected %d, got %d\", code, r.StatusCode)\n\t\t}\n\t}\n\n\t// Initial logins, checking that it just works.\n\tlogin(\"alice\", \"alice123\", 200)\n\tlogin(\"alice\", \"alice1234\", 401)\n\n\tvar (\n\t\tstart = make(chan struct{})\n\t\twg    sync.WaitGroup\n\t)\n\twg.Add(300)\n\tfor i := 0; i < 150; i++ {\n\t\tgo func() {\n\t\t\t<-start\n\t\t\tlogin(\"alice\", \"alice123\", 200)\n\t\t\twg.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\t<-start\n\t\t\tlogin(\"alice\", \"alice1234\", 401)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\tclose(start)\n\twg.Wait()\n}\n\n// TestBasicAuthWithFakePassword validates that we can't login the \"fakepassword\" used in\n// to prevent user enumeration.\nfunc TestBasicAuthWithFakepassword(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_users_noTLS.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tlogin := func() {\n\t\tclient := &http.Client{}\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq.SetBasicAuth(\"fakeuser\", \"fakepassword\")\n\t\tr, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif r.StatusCode != 401 {\n\t\t\tt.Fatalf(\"bad return code, expected %d, got %d\", 401, r.StatusCode)\n\t\t}\n\t}\n\n\t// Login with a cold cache.\n\tlogin()\n\t// Login with the response cached.\n\tlogin()\n}\n\n// TestHTTPHeaders validates that HTTP headers are added correctly.\nfunc TestHTTPHeaders(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_headers.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor k, v := range map[string]string{\n\t\t\"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains\",\n\t\t\"X-Frame-Options\":           \"deny\",\n\t\t\"X-Content-Type-Options\":    \"nosniff\",\n\t\t\"X-XSS-Protection\":          \"1\",\n\t} {\n\t\tif got := r.Header.Get(k); got != v {\n\t\t\tt.Fatalf(\"unexpected %s header value, expected %q, got %q\", k, v, got)\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright 2020 The Prometheus Authors\n// This code is partly borrowed from Caddy:\n//    Copyright 2015 Matthew Holt and The Caddy Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/go-kit/log\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// extraHTTPHeaders is a map of HTTP headers that can be added to HTTP\n// responses.\n// This is private on purpose to ensure consistency in the Prometheus ecosystem.\nvar extraHTTPHeaders = map[string][]string{\n\t\"Strict-Transport-Security\": nil,\n\t\"X-Content-Type-Options\":    {\"nosniff\"},\n\t\"X-Frame-Options\":           {\"deny\", \"sameorigin\"},\n\t\"X-XSS-Protection\":          nil,\n\t\"Content-Security-Policy\":   nil,\n}\n\nfunc validateUsers(configPath string) error {\n\tc, err := getConfig(configPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, p := range c.Users {\n\t\t_, err = bcrypt.Cost([]byte(p))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateHeaderConfig checks that the provided header configuration is correct.\n// It does not check the validity of all the values, only the ones which are\n// well-defined enumerations.\nfunc validateHeaderConfig(headers map[string]string) error {\nHeadersLoop:\n\tfor k, v := range headers {\n\t\tvalues, ok := extraHTTPHeaders[k]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"HTTP header %q can not be configured\", k)\n\t\t}\n\t\tfor _, allowedValue := range values {\n\t\t\tif v == allowedValue {\n\t\t\t\tcontinue HeadersLoop\n\t\t\t}\n\t\t}\n\t\tif len(values) > 0 {\n\t\t\treturn fmt.Errorf(\"invalid value for %s. Expected one of: %q, but got: %q\", k, values, v)\n\t\t}\n\t}\n\treturn nil\n}\n\ntype webHandler struct {\n\ttlsConfigPath string\n\thandler       http.Handler\n\tlogger        log.Logger\n\tcache         *cache\n\t// bcryptMtx is there to ensure that bcrypt.CompareHashAndPassword is run\n\t// only once in parallel as this is CPU intensive.\n\tbcryptMtx sync.Mutex\n}\n\nfunc (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tc, err := getConfig(u.tlsConfigPath)\n\tif err != nil {\n\t\tu.logger.Log(\"msg\", \"Unable to parse configuration\", \"err\", err)\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Configure http headers.\n\tfor k, v := range c.HTTPConfig.Header {\n\t\tw.Header().Set(k, v)\n\t}\n\n\tif len(c.Users) == 0 {\n\t\tu.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\tuser, pass, auth := r.BasicAuth()\n\tif auth {\n\t\thashedPassword, validUser := c.Users[user]\n\n\t\tif !validUser {\n\t\t\t// The user is not found. Use a fixed password hash to\n\t\t\t// prevent user enumeration by timing requests.\n\t\t\t// This is a bcrypt-hashed version of \"fakepassword\".\n\t\t\thashedPassword = \"$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi\"\n\t\t}\n\n\t\tcacheKey := strings.Join(\n\t\t\t[]string{\n\t\t\t\thex.EncodeToString([]byte(user)),\n\t\t\t\thex.EncodeToString([]byte(hashedPassword)),\n\t\t\t\thex.EncodeToString([]byte(pass)),\n\t\t\t}, \":\")\n\t\tauthOk, ok := u.cache.get(cacheKey)\n\n\t\tif !ok {\n\t\t\t// This user, hashedPassword, password is not cached.\n\t\t\tu.bcryptMtx.Lock()\n\t\t\terr := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))\n\t\t\tu.bcryptMtx.Unlock()\n\n\t\t\tauthOk = validUser && err == nil\n\t\t\tu.cache.set(cacheKey, authOk)\n\t\t}\n\n\t\tif authOk && validUser {\n\t\t\tu.handler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n}\n", "// Copyright 2021 The Prometheus Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"sync\"\n\t\"testing\"\n)\n\n// TestBasicAuthCache validates that the cache is working by calling a password\n// protected endpoint multiple times.\nfunc TestBasicAuthCache(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_users_noTLS.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tlogin := func(username, password string, code int) {\n\t\tclient := &http.Client{}\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq.SetBasicAuth(username, password)\n\t\tr, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif r.StatusCode != code {\n\t\t\tt.Fatalf(\"bad return code, expected %d, got %d\", code, r.StatusCode)\n\t\t}\n\t}\n\n\t// Initial logins, checking that it just works.\n\tlogin(\"alice\", \"alice123\", 200)\n\tlogin(\"alice\", \"alice1234\", 401)\n\n\tvar (\n\t\tstart = make(chan struct{})\n\t\twg    sync.WaitGroup\n\t)\n\twg.Add(300)\n\tfor i := 0; i < 150; i++ {\n\t\tgo func() {\n\t\t\t<-start\n\t\t\tlogin(\"alice\", \"alice123\", 200)\n\t\t\twg.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\t<-start\n\t\t\tlogin(\"alice\", \"alice1234\", 401)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\tclose(start)\n\twg.Wait()\n}\n\n// TestBasicAuthWithFakePassword validates that we can't login the \"fakepassword\" used in\n// to prevent user enumeration.\nfunc TestBasicAuthWithFakepassword(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_users_noTLS.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tlogin := func() {\n\t\tclient := &http.Client{}\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq.SetBasicAuth(\"fakeuser\", \"fakepassword\")\n\t\tr, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif r.StatusCode != 401 {\n\t\t\tt.Fatalf(\"bad return code, expected %d, got %d\", 401, r.StatusCode)\n\t\t}\n\t}\n\n\t// Login with a cold cache.\n\tlogin()\n\t// Login with the response cached.\n\tlogin()\n}\n\n// TestByPassBasicAuthVuln tests for CVE-2022-46146.\nfunc TestByPassBasicAuthVuln(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_users_noTLS.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tlogin := func(username, password string) {\n\t\tclient := &http.Client{}\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq.SetBasicAuth(username, password)\n\t\tr, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif r.StatusCode != 401 {\n\t\t\tt.Fatalf(\"bad return code, expected %d, got %d\", 401, r.StatusCode)\n\t\t}\n\t}\n\n\t// Poison the cache.\n\tlogin(\"alice$2y$12$1DpfPeqF9HzHJt.EWswy1exHluGfbhnn3yXhR7Xes6m3WJqFg0Wby\", \"fakepassword\")\n\t// Login with a wrong password.\n\tlogin(\"alice\", \"$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSifakepassword\")\n}\n\n// TestHTTPHeaders validates that HTTP headers are added correctly.\nfunc TestHTTPHeaders(t *testing.T) {\n\tserver := &http.Server{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"Hello World!\"))\n\t\t}),\n\t}\n\n\tdone := make(chan struct{})\n\tt.Cleanup(func() {\n\t\tif err := server.Shutdown(context.Background()); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t<-done\n\t})\n\n\tgo func() {\n\t\tflags := FlagConfig{\n\t\t\tWebListenAddresses: &([]string{port}),\n\t\t\tWebSystemdSocket:   OfBool(false),\n\t\t\tWebConfigFile:      OfString(\"testdata/web_config_headers.good.yml\"),\n\t\t}\n\t\tListenAndServe(server, &flags, testlogger)\n\t\tclose(done)\n\t}()\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", \"http://localhost\"+port, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor k, v := range map[string]string{\n\t\t\"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains\",\n\t\t\"X-Frame-Options\":           \"deny\",\n\t\t\"X-Content-Type-Options\":    \"nosniff\",\n\t\t\"X-XSS-Protection\":          \"1\",\n\t} {\n\t\tif got := r.Header.Get(k); got != v {\n\t\t\tt.Fatalf(\"unexpected %s header value, expected %q, got %q\", k, v, got)\n\t\t}\n\t}\n}\n"], "filenames": ["web/handler.go", "web/handler_test.go"], "buggy_code_start_loc": [21, 139], "buggy_code_end_loc": [126, 139], "fixing_code_start_loc": [22, 140], "fixing_code_end_loc": [132, 188], "type": "CWE-287", "message": "Prometheus Exporter Toolkit is a utility package to build exporters. Prior to versions 0.7.2 and 0.8.2, if someone has access to a Prometheus web.yml file and users' bcrypted passwords, they can bypass security by poisoning the built-in authentication cache. Versions 0.7.2 and 0.8.2 contain a fix for the issue. There is no workaround, but attacker must have access to the hashed password to use this functionality.", "other": {"cve": {"id": "CVE-2022-46146", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-29T14:15:13.283", "lastModified": "2023-02-01T15:39:15.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prometheus Exporter Toolkit is a utility package to build exporters. Prior to versions 0.7.2 and 0.8.2, if someone has access to a Prometheus web.yml file and users' bcrypted passwords, they can bypass security by poisoning the built-in authentication cache. Versions 0.7.2 and 0.8.2 contain a fix for the issue. There is no workaround, but attacker must have access to the hashed password to use this functionality."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-303"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:prometheus:exporter_toolkit:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7.2", "matchCriteriaId": "715C0429-EE84-443F-B5F2-D2D3F6CE74AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:prometheus:exporter_toolkit:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.8.0", "versionEndExcluding": "0.8.2", "matchCriteriaId": "A2B307E0-6990-48D5-8AE1-7F4E95EBF8A0"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/11/29/1", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/11/29/2", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/11/29/4", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/prometheus/exporter-toolkit/commit/5b1eab34484ddd353986bce736cd119d863e4ff5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/prometheus/exporter-toolkit/security/advisories/GHSA-7rg2-cxvp-9p7p", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/prometheus/exporter-toolkit/commit/5b1eab34484ddd353986bce736cd119d863e4ff5"}}