{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n *\tlinux/mm/mincore.c\n *\n * Copyright (C) 1994-2006  Linus Torvalds\n */\n\n/*\n * The mincore() system call.\n */\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n\n#include <linux/uaccess.h>\n#include <asm/pgtable.h>\n\nstatic int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tunsigned char present;\n\tunsigned char *vec = walk->private;\n\n\t/*\n\t * Hugepages under user process are always in RAM and never\n\t * swapped out, but theoretically it needs to be checked.\n\t */\n\tpresent = pte && !huge_pte_none(huge_ptep_get(pte));\n\tfor (; addr != end; vec++, addr += PAGE_SIZE)\n\t\t*vec = present;\n\twalk->private = vec;\n#else\n\tBUG();\n#endif\n\treturn 0;\n}\n\n/*\n * Later we can get more picky about what \"in core\" means precisely.\n * For now, simply check to see if the page is in the page cache,\n * and is up to date; i.e. that no page-in operation would be required\n * at this time if an application were to map and access this page.\n */\nstatic unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}\n\nstatic int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}\n\nstatic int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}\n\nstatic int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { /* pte is a swap entry */\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t/*\n\t\t\t\t * migration or hwpoison entries are always\n\t\t\t\t * uptodate\n\t\t\t\t */\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}\n\n/*\n * Do a chunk of \"sys_mincore()\". We've already checked\n * all the arguments, we hold the mmap semaphore: we should\n * just return the amount of info we're asked for.\n */\nstatic long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint err;\n\tstruct mm_walk mincore_walk = {\n\t\t.pmd_entry = mincore_pte_range,\n\t\t.pte_hole = mincore_unmapped_range,\n\t\t.hugetlb_entry = mincore_hugetlb,\n\t\t.private = vec,\n\t};\n\n\tvma = find_vma(current->mm, addr);\n\tif (!vma || addr < vma->vm_start)\n\t\treturn -ENOMEM;\n\tmincore_walk.mm = vma->vm_mm;\n\tend = min(vma->vm_end, addr + (pages << PAGE_SHIFT));\n\terr = walk_page_range(addr, end, &mincore_walk);\n\tif (err < 0)\n\t\treturn err;\n\treturn (end - addr) >> PAGE_SHIFT;\n}\n\n/*\n * The mincore(2) system call.\n *\n * mincore() returns the memory residency status of the pages in the\n * current process's address space specified by [addr, addr + len).\n * The status is returned in a vector of bytes.  The least significant\n * bit of each byte is 1 if the referenced page is in memory, otherwise\n * it is zero.\n *\n * Because the status of a page can change after mincore() checks it\n * but before it returns to the application, the returned vector may\n * contain stale information.  Only locked pages are guaranteed to\n * remain in memory.\n *\n * return values:\n *  zero    - success\n *  -EFAULT - vec points to an illegal address\n *  -EINVAL - addr is not a multiple of PAGE_SIZE\n *  -ENOMEM - Addresses in the range [addr, addr + len] are\n *\t\tinvalid for the address space of this process, or\n *\t\tspecify one or more pages which are not currently\n *\t\tmapped\n *  -EAGAIN - A kernel resource was temporarily unavailable.\n */\nSYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,\n\t\tunsigned char __user *, vec)\n{\n\tlong retval;\n\tunsigned long pages;\n\tunsigned char *tmp;\n\n\t/* Check the start address: needs to be page-aligned.. */\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\t/* ..and we need to be passed a valid user-space range */\n\tif (!access_ok((void __user *) start, len))\n\t\treturn -ENOMEM;\n\n\t/* This also avoids any overflows on PAGE_ALIGN */\n\tpages = len >> PAGE_SHIFT;\n\tpages += (offset_in_page(len)) != 0;\n\n\tif (!access_ok(vec, pages))\n\t\treturn -EFAULT;\n\n\ttmp = (void *) __get_free_page(GFP_USER);\n\tif (!tmp)\n\t\treturn -EAGAIN;\n\n\tretval = 0;\n\twhile (pages) {\n\t\t/*\n\t\t * Do at most PAGE_SIZE entries per iteration, due to\n\t\t * the temporary buffer size.\n\t\t */\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tretval = do_mincore(start, min(pages, PAGE_SIZE), tmp);\n\t\tup_read(&current->mm->mmap_sem);\n\n\t\tif (retval <= 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(vec, tmp, retval)) {\n\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tpages -= retval;\n\t\tvec += retval;\n\t\tstart += retval << PAGE_SHIFT;\n\t\tretval = 0;\n\t}\n\tfree_page((unsigned long) tmp);\n\treturn retval;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n *\tlinux/mm/mincore.c\n *\n * Copyright (C) 1994-2006  Linus Torvalds\n */\n\n/*\n * The mincore() system call.\n */\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n\n#include <linux/uaccess.h>\n#include <asm/pgtable.h>\n\nstatic int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tunsigned char present;\n\tunsigned char *vec = walk->private;\n\n\t/*\n\t * Hugepages under user process are always in RAM and never\n\t * swapped out, but theoretically it needs to be checked.\n\t */\n\tpresent = pte && !huge_pte_none(huge_ptep_get(pte));\n\tfor (; addr != end; vec++, addr += PAGE_SIZE)\n\t\t*vec = present;\n\twalk->private = vec;\n#else\n\tBUG();\n#endif\n\treturn 0;\n}\n\nstatic int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\tunsigned char *vec = walk->private;\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\n\tmemset(vec, 0, nr);\n\twalk->private += nr;\n\treturn 0;\n}\n\nstatic int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\t/* We'll consider a THP page under construction to be there */\n\tif (pmd_trans_unstable(pmd)) {\n\t\tmemset(vec, 1, nr);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t*vec = 0;\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { /* pte is a swap entry */\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\t/*\n\t\t\t * migration or hwpoison entries are always\n\t\t\t * uptodate\n\t\t\t */\n\t\t\t*vec = !!non_swap_entry(entry);\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}\n\n/*\n * Do a chunk of \"sys_mincore()\". We've already checked\n * all the arguments, we hold the mmap semaphore: we should\n * just return the amount of info we're asked for.\n */\nstatic long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint err;\n\tstruct mm_walk mincore_walk = {\n\t\t.pmd_entry = mincore_pte_range,\n\t\t.pte_hole = mincore_unmapped_range,\n\t\t.hugetlb_entry = mincore_hugetlb,\n\t\t.private = vec,\n\t};\n\n\tvma = find_vma(current->mm, addr);\n\tif (!vma || addr < vma->vm_start)\n\t\treturn -ENOMEM;\n\tmincore_walk.mm = vma->vm_mm;\n\tend = min(vma->vm_end, addr + (pages << PAGE_SHIFT));\n\terr = walk_page_range(addr, end, &mincore_walk);\n\tif (err < 0)\n\t\treturn err;\n\treturn (end - addr) >> PAGE_SHIFT;\n}\n\n/*\n * The mincore(2) system call.\n *\n * mincore() returns the memory residency status of the pages in the\n * current process's address space specified by [addr, addr + len).\n * The status is returned in a vector of bytes.  The least significant\n * bit of each byte is 1 if the referenced page is in memory, otherwise\n * it is zero.\n *\n * Because the status of a page can change after mincore() checks it\n * but before it returns to the application, the returned vector may\n * contain stale information.  Only locked pages are guaranteed to\n * remain in memory.\n *\n * return values:\n *  zero    - success\n *  -EFAULT - vec points to an illegal address\n *  -EINVAL - addr is not a multiple of PAGE_SIZE\n *  -ENOMEM - Addresses in the range [addr, addr + len] are\n *\t\tinvalid for the address space of this process, or\n *\t\tspecify one or more pages which are not currently\n *\t\tmapped\n *  -EAGAIN - A kernel resource was temporarily unavailable.\n */\nSYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,\n\t\tunsigned char __user *, vec)\n{\n\tlong retval;\n\tunsigned long pages;\n\tunsigned char *tmp;\n\n\t/* Check the start address: needs to be page-aligned.. */\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\t/* ..and we need to be passed a valid user-space range */\n\tif (!access_ok((void __user *) start, len))\n\t\treturn -ENOMEM;\n\n\t/* This also avoids any overflows on PAGE_ALIGN */\n\tpages = len >> PAGE_SHIFT;\n\tpages += (offset_in_page(len)) != 0;\n\n\tif (!access_ok(vec, pages))\n\t\treturn -EFAULT;\n\n\ttmp = (void *) __get_free_page(GFP_USER);\n\tif (!tmp)\n\t\treturn -EAGAIN;\n\n\tretval = 0;\n\twhile (pages) {\n\t\t/*\n\t\t * Do at most PAGE_SIZE entries per iteration, due to\n\t\t * the temporary buffer size.\n\t\t */\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tretval = do_mincore(start, min(pages, PAGE_SIZE), tmp);\n\t\tup_read(&current->mm->mmap_sem);\n\n\t\tif (retval <= 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(vec, tmp, retval)) {\n\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tpages -= retval;\n\t\tvec += retval;\n\t\tstart += retval << PAGE_SHIFT;\n\t\tretval = 0;\n\t}\n\tfree_page((unsigned long) tmp);\n\treturn retval;\n}\n"], "filenames": ["mm/mincore.c"], "buggy_code_start_loc": [45], "buggy_code_end_loc": [162], "fixing_code_start_loc": [44], "fixing_code_end_loc": [94], "type": "CWE-319", "message": "The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server.", "other": {"cve": {"id": "CVE-2019-5489", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-07T17:29:00.470", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server."}, {"lang": "es", "value": "La implementaci\u00f3n mincore() en mm/mincore.c en el kernel de Linux hasta la versi\u00f3n 4.19.13 permit\u00eda a los atacantes observar patrones de acceso a las p\u00e1ginas de cach\u00e9 de otros procesos en el mismo sistema, permitiendo el esnifado de informaci\u00f3n secreta. (Su arreglo afecta a la salida del programa fincore.)  Puede ser posible una explotaci\u00f3n remota limitada, tal y como queda demostrado con las diferencias en latencia a la hora de acceder a archivos p\u00fablicos desde un servidor Apache HHTP."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-319"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.19.13", "matchCriteriaId": "FE279FFB-2E93-4DB8-B46B-C16E88F9941D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_performance_analytics_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "83077160-BB98-408B-81F0-8EF9E566BF28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "E902EEC6-9A41-4FBC-8D81-891DF846A5CB"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=574823bfab82d9d8fa47f422778043fbb4b4f50e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00071.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00039.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00048.html", "source": "cve@mitre.org"}, {"url": "http://www.huawei.com/en/psirt/security-advisories/huawei-sa-20200115-01-pagecache-en", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/106478", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2473", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2808", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2809", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2837", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3309", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3517", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3967", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4056", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4057", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4058", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4159", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4164", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4255", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0204", "source": "cve@mitre.org"}, {"url": "https://arxiv.org/abs/1901.01161", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1120843", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/06/msg00010.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Jun/26", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20190307-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4465", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org"}, {"url": "https://www.theregister.co.uk/2019/01/05/boffins_beat_page_cache/", "source": "cve@mitre.org", "tags": ["Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e"}}