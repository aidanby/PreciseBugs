{"buggy_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n * Copyright (c) 2002      Nokia Corp.\n *\n * This is part of the SCTP Linux Kernel Implementation.\n *\n * These are the state functions for the state machine.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, write to\n * the Free Software Foundation, 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <lksctp-developers@lists.sourceforge.net>\n *\n * Or submit a bug report through the following website:\n *    http://www.sf.net/projects/lksctp\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Mathew Kotowsky       <kotowsky@sctp.org>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Hui Huang \t    <hui.huang@nokia.com>\n *    Dajiang Zhang \t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Kevin Gao\t\t    <kevin.gao@intel.com>\n *\n * Any bugs reported given to us we will try to fix... any fixes shared will\n * be incorporated into the next SCTP release.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport);\n\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen);\n\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\n\n/* Small helper function that checks if the chunk length\n * is of the appropriate length.  The 'required_length' argument\n * is set to be the size of a specific chunk we are testing.\n * Return Values:  1 = Valid length\n * \t\t   0 = Invalid length\n *\n */\nstatic inline int\nsctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**********************************************************\n * These are the state functions for handling chunk events.\n **********************************************************/\n\n/*\n * Process the final SHUTDOWN COMPLETE.\n *\n * Section: 4 (C) (diagram), 9.2\n * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify\n * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be\n * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint\n * should stop the T2-shutdown timer and remove all knowledge of the\n * association (and thus the association enters the CLOSED state).\n *\n * Verification Tag: 8.5.1(C), sctpimpguide 2.41.\n * C) Rules for packet carrying SHUTDOWN COMPLETE:\n * ...\n * - The receiver of a SHUTDOWN COMPLETE shall accept the packet\n *   if the Verification Tag field of the packet matches its own tag and\n *   the T bit is not set\n *   OR\n *   it is set to its peer's tag and the T bit is set in the Chunk\n *   Flags.\n *   Otherwise, the receiver MUST silently discard the packet\n *   and take no further action.  An endpoint MUST ignore the\n *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_4_C(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t  void *arg,\n\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * Respond to a normal INIT chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, B\n * B) \"Z\" shall respond immediately with an INIT ACK chunk.  The\n *    destination IP address of the INIT ACK MUST be set to the source\n *    IP address of the INIT to which this INIT ACK is responding.  In\n *    the response, besides filling in other parameters, \"Z\" must set the\n *    Verification Tag field to Tag_A, and also provide its own\n *    Verification Tag (Tag_Z) in the Initiate Tag field.\n *\n * Verification Tag: Must be 0.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * Normally, this would cause an ABORT with a Protocol Violation\n\t * error, but since we don't have an association, we'll\n\t * just discard the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the INIT is coming toward a closing socket, we'll send back\n\t * and ABORT.  Essentially, this catches the race of INIT being\n\t * backloged to the socket at the same time as the user isses close().\n\t * Since the socket and all its associations are going away, we\n\t * can treat this OOTB\n\t */\n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t/* The call, sctp_process_init(), can fail on memory allocation.  */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note:  After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources, nor keep any states for the\n\t * new association.  Otherwise, \"Z\" will be vulnerable to resource\n\t * attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal INIT ACK chunk.\n * We are the side that is initiating the association.\n *\n * Section: 5.1 Normal Establishment of an Association, C\n * C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-init\n *    timer and leave COOKIE-WAIT state. \"A\" shall then send the State\n *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start\n *    the T1-cookie timer, and enter the COOKIE-ECHOED state.\n *\n *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound\n *    DATA chunks, but it MUST be the first chunk in the packet and\n *    until the COOKIE ACK is returned the sender MUST NOT send any\n *    other packets to the peer.\n *\n * Verification Tag: 3.3.3\n *   If the value of the Initiate Tag in a received INIT ACK chunk is\n *   found to be 0, the receiver MUST treat it as an error and close the\n *   association by transmitting an ABORT.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_init_chunk_t *initchunk;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT-ACK chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tsctp_error_t error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes.  If there are no causes,\n\t\t * then there wasn't enough memory.  Just terminate\n\t\t * the association.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t/* SCTP-AUTH, Section 6.3:\n\t\t *    It should be noted that if the receiver wants to tear\n\t\t *    down an association in an authenticated way only, the\n\t\t *    handling of malformed packets should not result in\n\t\t *    tearing down the association.\n\t\t *\n\t\t * This means that if we only want to abort associations\n\t\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t\t * can't destroy this association just because the packet\n\t\t * was malformed.\n\t\t */\n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t/* Tag the variable length parameters.  Note that we never\n\t * convert the parameters in an INIT chunk.\n\t */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tinitchunk = (sctp_init_chunk_t *) chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t/* Reset init error count upon receipt of INIT-ACK.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall stop the T1-init timer and leave\n\t * COOKIE-WAIT state.  \"A\" shall then ... start the T1-cookie\n\t * timer, and enter the COOKIE-ECHOED state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t/* SCTP-AUTH: genereate the assocition shared keys so that\n\t * we can potentially signe the COOKIE-ECHO.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall then send the State Cookie received in the\n\t * INIT ACK chunk in a COOKIE ECHO chunk, ...\n\t */\n\t/* If there is any errors to report, send the ERROR chunk generated\n\t * for unknown parameters as well.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Respond to a normal COOKIE ECHO chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, D\n * D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply\n *    with a COOKIE ACK chunk after building a TCB and moving to\n *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with\n *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK\n *    chunk MUST be the first chunk in the packet.\n *\n *   IMPLEMENTATION NOTE: An implementation may choose to send the\n *   Communication Up notification to the SCTP user upon reception\n *   of a valid COOKIE ECHO chunk.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * D) Rules for packet carrying a COOKIE ECHO\n *\n * - When sending a COOKIE ECHO, the endpoint MUST use the value of the\n *   Initial Tag received in the INIT ACK.\n *\n * - The receiver of a COOKIE ECHO follows the procedures in Section 5.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal COOKIE ACK chunk.\n * We are the side that is being asked for an association.\n *\n * RFC 2960 5.1 Normal Establishment of an Association\n *\n * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie\n *    timer. It may also notify its ULP about the successful\n *    establishment of the association with a Communication Up\n *    notification (see Section 10).\n *\n * Verification Tag:\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Verify that the chunk length for the COOKIE-ACK is OK.\n\t * If we don't do this, any bundled chunks may be junked.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Reset init error count upon receipt of COOKIE-ACK,\n\t * to avoid problems with the managemement of this\n\t * counter in stale cookie situations when a transition back\n\t * from the COOKIE-ECHOED state to the COOKIE-WAIT\n\t * state is performed.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move\n\t * from the COOKIE-ECHOED state to the ESTABLISHED state,\n\t * stopping the T1-cookie timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* It may also notify its ULP about the successful\n\t * establishment of the association with a Communication Up\n\t * notification (see Section 10).\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Generate and sendout a heartbeat packet.  */\nstatic sctp_disposition_t sctp_sf_heartbeat(const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Send a heartbeat to our peer.  */\n\treply = sctp_make_heartbeat(asoc, transport);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Set rto_pending indicating that an RTT measurement\n\t * is started with this heartbeat chunk.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Generate a HEARTBEAT packet on the given transport.  */\nsctp_disposition_t sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t/* Section 3.3.5.\n\t * The Sender-specific Heartbeat Info field should normally include\n\t * information about the sender's current time when this HEARTBEAT\n\t * chunk is sent and the destination transport address to which this\n\t * HEARTBEAT is sent (see Section 8.3).\n\t */\n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Set transport error counter and association error counter\n\t\t * when sending heartbeat.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an heartbeat request.\n *\n * Section: 8.3 Path Heartbeat\n * The receiver of the HEARTBEAT should immediately respond with a\n * HEARTBEAT ACK that contains the Heartbeat Information field copied\n * from the received HEARTBEAT chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * When receiving an SCTP packet, the endpoint MUST ensure that the\n * value in the Verification Tag field of the received SCTP packet\n * matches its own Tag. If the received Verification Tag value does not\n * match the receiver's own tag value, the receiver shall silently\n * discard the packet and shall not process it any further except for\n * those cases listed in Section 8.5.1 below.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tsctp_paramhdr_t *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_heartbeat_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* 8.3 The receiver of the HEARTBEAT should immediately\n\t * respond with a HEARTBEAT ACK that contains the Heartbeat\n\t * Information field copied from the received HEARTBEAT chunk.\n\t */\n\tchunk->subh.hb_hdr = (sctp_heartbeathdr_t *) chunk->skb->data;\n\tparam_hdr = (sctp_paramhdr_t *) chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the returning HEARTBEAT ACK.\n *\n * Section: 8.3 Path Heartbeat\n * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n * should clear the error counter of the destination transport\n * address to which the HEARTBEAT was sent, and mark the destination\n * transport address as active if it is not so marked. The endpoint may\n * optionally report to the upper layer when an inactive destination\n * address is marked as active due to the reception of the latest\n * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also\n * clear the association overall error count as well (as defined\n * in section 8.1).\n *\n * The receiver of the HEARTBEAT ACK should also perform an RTT\n * measurement for that destination transport address using the time\n * value carried in the HEARTBEAT ACK chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunion sctp_addr from_addr;\n\tstruct sctp_transport *link;\n\tsctp_sender_hb_info_t *hbinfo;\n\tunsigned long max_interval;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t) +\n\t\t\t\t\t    sizeof(sctp_sender_hb_info_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\n\t/* Make sure that the length of the parameter is what we expect */\n\tif (ntohs(hbinfo->param_hdr.length) !=\n\t\t\t\t    sizeof(sctp_sender_hb_info_t)) {\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t/* This should never happen, but lets log it if so.  */\n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Validate the 64-bit random nonce. */\n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t/* Check if the timestamp looks valid.  */\n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tSCTP_DEBUG_PRINTK(\"%s: HEARTBEAT ACK with invalid timestamp \"\n\t\t\t\t  \"received for transport: %p\\n\",\n\t\t\t\t   __func__, link);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of\n\t * the HEARTBEAT should clear the error counter of the\n\t * destination transport address to which the HEARTBEAT was\n\t * sent and mark the destination transport address as active if\n\t * it is not so marked.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Helper function to send out an abort for the restart\n * condition.\n */\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\n\t/* Build the error on the stack.   We are way to malloc crazy\n\t * throughout the code today.\n\t */\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\n\t/* Copy into a parm format. */\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t/* Assign to the control socket. */\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t/* Association is NULL since this may be a restart attack and we\n\t * want to send back the attacker's vtag.\n\t */\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* Discard the rest of the inbound packet. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t/* Even if there is no memory, treat as a failure so\n\t * the packet will get dropped.\n\t */\n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n/* A restart is occurring, check to make sure no new addresses\n * are being added as we may be under a takeover attack.\n */\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct net *net = sock_net(new_asoc->base.sk);\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t/* Implementor's Guide - Section 5.2.2\n\t * ...\n\t * Before responding the endpoint MUST check to see if the\n\t * unexpected INIT adds new addresses to the association. If new\n\t * addresses are added to the association, the endpoint MUST respond\n\t * with an ABORT..\n\t */\n\n\t/* Search through all current addresses and make sure\n\t * we aren't adding any new ones.\n\t */\n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Return success if all addresses were found. */\n\treturn ret;\n}\n\n/* Populate the verification/tie tags based on overlapping INIT\n * scenario.\n *\n * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.\n */\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n/*\n * Compare vtag/tietag values to determine unexpected COOKIE-ECHO\n * handling action.\n *\n * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.\n *\n * Returns value representing action to be taken.   These action values\n * correspond to Action/Description values in RFC 2960, Table 2.\n */\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t/* In this case, the peer may have restarted.  */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t/* Collision case B. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t/* Collision case D. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t/* Collision case C. */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t/* No match to any of the special cases; discard this packet. */\n\treturn 'E';\n}\n\n/* Common helper routine for both duplicate and simulataneous INIT\n * chunk handling.\n */\nstatic sctp_disposition_t sctp_sf_do_unexpected_init(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * In this case, we generate a protocol violation since we have\n\t * an association established.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/*\n\t * Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t * FIXME:  We are copying parameters from the endpoint not the\n\t * association.\n\t */\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t/* In the outbound INIT ACK the endpoint MUST copy its current\n\t * Verification Tag and Peers Verification tag into a reserved\n\t * place (local tie-tag and per tie-tag) within the state cookie.\n\t */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.   Do not do this check for COOKIE-WAIT state,\n\t * since there are no peer addresses to check against.\n\t * Upon return an ABORT will have been sent if needed.\n\t */\n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note: After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources for this new association.\n\t * Otherwise, \"Z\" will be vulnerable to resource attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n/*\n * Handle simultaneous INIT.\n * This means we started an INIT and then we got an INIT request from\n * our peer.\n *\n * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n * This usually indicates an initialization collision, i.e., each\n * endpoint is attempting, at about the same time, to establish an\n * association with the other endpoint.\n *\n * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n * endpoint MUST respond with an INIT ACK using the same parameters it\n * sent in its original INIT chunk (including its Verification Tag,\n * unchanged). These original parameters are combined with those from the\n * newly received INIT chunk. The endpoint shall also generate a State\n * Cookie with the INIT ACK. The endpoint uses the parameters sent in its\n * INIT to calculate the State Cookie.\n *\n * After that, the endpoint MUST NOT change its state, the T1-init\n * timer shall be left running and the corresponding TCB MUST NOT be\n * destroyed. The normal procedures for handling State Cookies when\n * a TCB exists will resolve the duplicate INITs to a single association.\n *\n * For an endpoint that is in the COOKIE-ECHOED state it MUST populate\n * its Tie-Tags with the Tag information of itself and its peer (see\n * section 5.2.2 for a description of the Tie-Tags).\n *\n * Verification Tag: Not explicit, but an INIT can not have a valid\n * verification tag, so we skip the check.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle duplicated INIT messages.  These are usually delayed\n * restransmissions.\n *\n * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,\n * COOKIE-ECHOED and COOKIE-WAIT\n *\n * Unless otherwise stated, upon reception of an unexpected INIT for\n * this association, the endpoint shall generate an INIT ACK with a\n * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n * current Verification Tag and peer's Verification Tag into a reserved\n * place within the state cookie.  We shall refer to these locations as\n * the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n * containing this INIT ACK MUST carry a Verification Tag value equal to\n * the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n * MUST contain a new Initiation Tag (randomly generated see Section\n * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the\n * existing parameters of the association (e.g. number of outbound\n * streams) into the INIT ACK and cookie.\n *\n * After sending out the INIT ACK, the endpoint shall take no further\n * actions, i.e., the existing association, including its current state,\n * and the corresponding TCB MUST NOT be changed.\n *\n * Note: Only when a TCB exists and the association is not in a COOKIE-\n * WAIT state are the Tie-Tags populated.  For a normal association INIT\n * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n * set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n * State Cookie are populated as specified in section 5.2.1.\n *\n * Verification Tag: Not specified, but an INIT has no way of knowing\n * what the verification tag could be, so we ignore it.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_2_dupinit(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n/*\n * Unexpected INIT-ACK handler.\n *\n * Section 5.2.3\n * If an INIT ACK received by an endpoint in any state other than the\n * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.\n * An unexpected INIT ACK usually indicates the processing of an old or\n * duplicated INIT chunk.\n*/\nsctp_disposition_t sctp_sf_do_5_2_3_initack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg, sctp_cmd_seq_t *commands)\n{\n\t/* Per the above section, we'll discard the chunk if we have an\n\t * endpoint.  If this is an OOTB INIT-ACK, treat it as such.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\n/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action 'A')\n *\n * Section 5.2.4\n *  A)  In this case, the peer may have restarted.\n */\nstatic sctp_disposition_t sctp_sf_do_dupcook_a(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\tsctp_disposition_t disposition;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.  Though this is a pretty complicated attack\n\t * since you'd have to get inside the cookie.\n\t */\n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands)) {\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes\n\t * the peer has restarted (Action A), it MUST NOT setup a new\n\t * association but instead resend the SHUTDOWN ACK and send an ERROR\n\t * chunk with a \"Cookie Received while Shutting Down\" error cause to\n\t * its peer.\n\t*/\n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\tSCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\tchunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked\n\t * data. Consider the optional choice of resending of this data.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue\n\t * and ASCONF-ACK cache.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Report association restart to upper layer. */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Update the content of current association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'B')\n *\n * Section 5.2.4\n *   B) In this case, both sides may be attempting to start an association\n *      at about the same time but the peer endpoint started its INIT\n *      after responding to the local endpoint's INIT\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Update the content of current association.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'C')\n *\n * Section 5.2.4\n *  C) In this case, the local endpoint's cookie has arrived late.\n *     Before it arrived, the local endpoint sent an INIT and received an\n *     INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n *     but a new tag of its own.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_c(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t/* The cookie should be silently discarded.\n\t * The endpoint SHOULD NOT change states and should leave\n\t * any timers running.\n\t */\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action 'D')\n *\n * Section 5.2.4\n *\n * D) When both local and remote tags match the endpoint should always\n *    enter the ESTABLISHED state, if it has not already done so.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_d(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t/* Clarification from Implementor's Guide:\n\t * D) When both local and remote tags match the endpoint should\n\t * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.\n\t * It should stop any cookie timer that may be running and send\n\t * a COOKIE ACK.\n\t */\n\n\t/* Don't accidentally move back into established state. */\n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t\t *\n\t\t * D) IMPLEMENTATION NOTE: An implementation may choose\n\t\t * to send the Communication Up notification to the\n\t\t * SCTP user upon reception of a valid COOKIE\n\t\t * ECHO chunk.\n\t\t */\n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t/* Sockets API Draft Section 5.3.1.6\n\t\t * When a peer sends a Adaptation Layer Indication parameter,\n\t\t * SCTP delivers this notification to inform the application\n\t\t * that of the peers requested adaptation layer.\n\t\t */\n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying\n * chunk was retransmitted and then delayed in the network.\n *\n * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists\n *\n * Verification Tag: None.  Do cookie validation.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tint error = 0;\n\tchar action;\n\tstruct sctp_chunk *err_chk_p;\n\n\t/* Make sure that the chunk has a valid length from the protocol\n\t * perspective.  In this case check to make sure we have at least\n\t * enough for the chunk header.  Cookie length verification is\n\t * done later.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie\n\t * of a duplicate COOKIE ECHO match the Verification Tags of the\n\t * current association, consider the State Cookie valid even if\n\t * the lifespan is exceeded.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t/* Compare the tie_tag in cookie with the verification tag of\n\t * current association.\n\t */\n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A': /* Association restart. */\n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B': /* Collision case B. */\n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C': /* Collision case C. */\n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D': /* Collision case D. */\n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault: /* Discard packet for all others. */\n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t/* Delete the tempory new association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t/* Restore association pointer to provide SCTP command interpeter\n\t * with a valid context in case it needs to manipulate\n\t * the queues */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-PENDING state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_pending_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_sent_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Stop the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-ACK-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an Error received in COOKIE_ECHOED state.\n *\n * Only handle the error type of stale COOKIE Error, the other errors will\n * be ignored.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_cookie_echoed_err(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle a Stale COOKIE Error\n *\n * Section: 5.2.6 Handle Stale COOKIE Error\n * If the association is in the COOKIE-ECHOED state, the endpoint may elect\n * one of the following three alternatives.\n * ...\n * 3) Send a new INIT chunk to the endpoint, adding a Cookie\n *    Preservative parameter requesting an extension to the lifetime of\n *    the State Cookie. When calculating the time extension, an\n *    implementation SHOULD use the RTT information measured based on the\n *    previous COOKIE ECHO / ERROR exchange, and should add no more\n *    than 1 second beyond the measured RTT, due to long State Cookie\n *    lifetimes making the endpoint more subject to a replay attack.\n *\n * Verification Tag:  Not explicit, but safe to ignore.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\ttime_t stale;\n\tsctp_cookie_preserve_param_t bht;\n\tsctp_errhdr_t *err;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (sctp_errhdr_t *)(chunk->skb->data);\n\n\t/* When calculating the time extension, an implementation\n\t * SHOULD use the RTT information measured based on the\n\t * previous COOKIE ECHO / ERROR exchange, and should add no\n\t * more than 1 second beyond the measured RTT, due to long\n\t * State Cookie lifetimes making the endpoint more subject to\n\t * a replay attack.\n\t * Measure of Staleness's unit is usec. (1/1000000 sec)\n\t * Suggested Cookie Life-span Increment's unit is msec.\n\t * (1/1000 sec)\n\t * In general, if you use the suggested cookie life, the value\n\t * found in the field of measure of staleness should be doubled\n\t * to give ample time to retransmit the new cookie and thus\n\t * yield a higher probability of success on the reattempt.\n\t */\n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(sctp_errhdr_t)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t/* Build that new INIT chunk.  */\n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t/* Clear peer's init_tag cached in assoc as we are sending a new INIT */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t/* Stop pending T3-rtx and heartbeat timers */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t/* Delete non-primary peer ip addresses since we are transitioning\n\t * back to the COOKIE-WAIT state\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t/* If we've sent any data bundled with COOKIE-ECHO we will need to\n\t * resend\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.\n *\n * Section: 9.1\n * After checking the Verification Tag, the receiving endpoint shall\n * remove the association from its record, and shall report the\n * termination to its upper layer.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * B) Rules for packet carrying ABORT:\n *\n *  - The endpoint shall always fill in the Verification Tag field of the\n *    outbound packet with the destination endpoint's tag value if it\n *    is known.\n *\n *  - If the ABORT is sent in response to an OOTB packet, the endpoint\n *    MUST follow the procedure described in Section 8.4.\n *\n *  - The receiver MUST accept the packet if the Verification Tag\n *    matches either its own tag, OR the tag of its peer. Otherwise, the\n *    receiver MUST silently discard the packet and take no further\n *    action.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr)) {\n\n\t\tsctp_errhdr_t *err;\n\t\tsctp_walk_errors(err, chunk->chunk_hdr);\n\t\tif ((void *)err != (void *)chunk->chunk_end)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t/* ASSOC_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * Process an ABORT.  (COOKIE-WAIT state)\n *\n * See sctp_sf_do_9_1_abort() above.\n */\nsctp_disposition_t sctp_sf_cookie_wait_abort(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n/*\n * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)\n */\nsctp_disposition_t sctp_sf_cookie_wait_icmp_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n/*\n * Process an ABORT.  (COOKIE-ECHOED state)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_abort(struct net *net,\n\t\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t\t       void *arg,\n\t\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Stop T1 timer and abort association with \"INIT failed\".\n *\n * This is common code called by several sctp_sf_*_abort() functions above.\n */\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport)\n{\n\tSCTP_DEBUG_PRINTK(\"ABORT received (INIT).\\n\");\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_do_9_2_shut\n *\n * Section: 9.2\n * Upon the reception of the SHUTDOWN, the peer endpoint shall\n *  - enter the SHUTDOWN-RECEIVED state,\n *\n *  - stop accepting new data from its SCTP user\n *\n *  - verify, by checking the Cumulative TSN Ack field of the chunk,\n *    that all its outstanding DATA chunks have been received by the\n *    SHUTDOWN sender.\n *\n * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT\n * send a SHUTDOWN in response to a ULP request. And should discard\n * subsequent SHUTDOWN chunks.\n *\n * If there are still outstanding DATA chunks left, the SHUTDOWN\n * receiver shall continue to follow normal data transmission\n * procedures defined in Section 6 until all outstanding DATA chunks\n * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept\n * new data from its SCTP user.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\tsctp_disposition_t disposition;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Convert the elaborate header.  */\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_shutdownhdr_t));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT\n\t * When a peer sends a SHUTDOWN, SCTP delivers this notification to\n\t * inform the application that it should cease sending data.\n\t */\n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the reception of the SHUTDOWN, the peer endpoint shall\n\t *  - enter the SHUTDOWN-RECEIVED state,\n\t *  - stop accepting new data from its SCTP user\n\t *\n\t * [This is implicit in the new state.]\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t/*  - verify, by checking the Cumulative TSN Ack field of the\n\t *    chunk, that all its outstanding DATA chunks have been\n\t *    received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n/*\n * sctp_sf_do_9_2_shut_ctsn\n *\n * Once an endpoint has reached the SHUTDOWN-RECEIVED state,\n * it MUST NOT send a SHUTDOWN in response to a ULP request.\n * The Cumulative TSN Ack of the received SHUTDOWN chunk\n * MUST be processed.\n */\nsctp_disposition_t sctp_sf_do_9_2_shut_ctsn(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* verify, by checking the Cumulative TSN Ack field of the\n\t * chunk, that all its outstanding DATA chunks have been\n\t * received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC 2960 9.2\n * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk\n * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination\n * transport addresses (either in the IP addresses or in the INIT chunk)\n * that belong to this association, it should discard the INIT chunk and\n * retransmit the SHUTDOWN ACK chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_reshutack(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Make sure that the chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Since we are not going to really process this INIT, there\n\t * is no point in verifying chunk boundries.  Just generate\n\t * the SHUTDOWN ACK.\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-SHUTDOWN timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and restart the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * sctp_sf_do_ecn_cwr\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * CWR:\n *\n * RFC 2481 details a specific bit for a sender to send in the header of\n * its next outbound TCP segment to indicate to its peer that it has\n * reduced its congestion window.  This is termed the CWR bit.  For\n * SCTP the same indication is made by including the CWR chunk.\n * This chunk contains one data element, i.e. the TSN number that\n * was sent in the ECNE chunk.  This element represents the lowest\n * TSN number in the datagram that was originally marked with the\n * CE bit.\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tsctp_cwrhdr_t *cwr;\n\tstruct sctp_chunk *chunk = arg;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (sctp_cwrhdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_do_ecne\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * ECN-Echo\n *\n * RFC 2481 details a specific bit for a receiver to send back in its\n * TCP acknowledgements to notify the sender of the Congestion\n * Experienced (CE) bit having arrived from the network.  For SCTP this\n * same indication is made by including the ECNE chunk.  This chunk\n * contains one data element, i.e. the lowest TSN associated with the IP\n * datagram marked with the CE bit.....\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecne(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t   void *arg,\n\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tsctp_ecnehdr_t *ecne;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (sctp_ecnehdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_ecnehdr_t));\n\n\t/* If this is a newer ECNE than the last CWR packet we sent out */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The SCTP endpoint MUST always acknowledge the reception of each valid\n * DATA chunk.\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated within\n * 200 ms of the arrival of any unacknowledged DATA chunk. In some\n * situations it may be beneficial for an SCTP transmitter to be more\n * conservative than the algorithms detailed in this document allow.\n * However, an SCTP transmitter MUST NOT be more aggressive than the\n * following algorithms allow.\n *\n * A SCTP receiver MUST NOT generate more than one SACK for every\n * incoming packet, other than to update the offered window as the\n * receiving application consumes new data.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_arg_t force = SCTP_NOFORCE();\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands );\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->autoclose) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* If this is the last chunk in a packet, we need to count it\n\t * toward sack generation.  Note that we need to SACK every\n\t * OTHER packet containing data chunks, EVEN IF WE DISCARD\n\t * THEM.  We elect to NOT generate SACK's if the chunk fails\n\t * the verification tag test.\n\t *\n\t * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * The SCTP endpoint MUST always acknowledge the reception of\n\t * each valid DATA chunk.\n\t *\n\t * The guidelines on delayed acknowledgement algorithm\n\t * specified in  Section 4.2 of [RFC2581] SHOULD be followed.\n\t * Specifically, an acknowledgement SHOULD be generated for at\n\t * least every second packet (not every second DATA chunk)\n\t * received, and SHOULD be generated within 200 ms of the\n\t * arrival of any unacknowledged DATA chunk.  In some\n\t * situations it may be beneficial for an SCTP transmitter to\n\t * be more conservative than the algorithms detailed in this\n\t * document allow. However, an SCTP transmitter MUST NOT be\n\t * more aggressive than the following algorithms allow.\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * When a packet arrives with duplicate DATA chunk(s) and with\n\t * no new DATA chunk(s), the endpoint MUST immediately send a\n\t * SACK with no delay.  If a packet arrives with duplicate\n\t * DATA chunk(s) bundled with new DATA chunks, the endpoint\n\t * MAY immediately send a SACK.  Normally receipt of duplicate\n\t * DATA chunks will occur when the original SACK chunk was lost\n\t * and the peer's RTO has expired.  The duplicate TSN number(s)\n\t * SHOULD be reported in the SACK as duplicate.\n\t */\n\t/* In our case, we split the MAY SACK advice up whether or not\n\t * the last chunk is a duplicate.'\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n\n}\n\n/*\n * sctp_sf_eat_data_fast_4_4\n *\n * Section: 4 (4)\n * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received\n *    DATA chunks without delay.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_fast_4_4(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands );\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Go a head and force a SACK, since we are shutting down. */\n\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tif (chunk->end_of_packet) {\n\t\t/* We must delay the chunk creation since the cumulative\n\t\t * TSN has not been updated yet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Processing a Received SACK\n * D) Any time a SACK arrives, the endpoint performs the following:\n *\n *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,\n *     then drop the SACK.   Since Cumulative TSN Ack is monotonically\n *     increasing, a SACK whose Cumulative TSN Ack is less than the\n *     Cumulative TSN Ack Point indicates an out-of-order SACK.\n *\n *     ii) Set rwnd equal to the newly received a_rwnd minus the number\n *     of bytes still outstanding after processing the Cumulative TSN Ack\n *     and the Gap Ack Blocks.\n *\n *     iii) If the SACK is missing a TSN that was previously\n *     acknowledged via a Gap Ack Block (e.g., the data receiver\n *     reneged on the data), then mark the corresponding DATA chunk\n *     as available for retransmit:  Mark it as missing for fast\n *     retransmit as described in Section 7.2.4 and if no retransmit\n *     timer is running for the destination address to which the DATA\n *     chunk was originally transmitted, then T3-rtx is started for\n *     that destination address.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_sackhdr_t *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_sack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Pull the SACK chunk from the data buffer */\n\tsackh = sctp_sm_pull_sack(chunk);\n\t/* Was this a bogus SACK? */\n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t/* i) If Cumulative TSN Ack is less than the Cumulative TSN\n\t *     Ack Point, then drop the SACK.  Since Cumulative TSN\n\t *     Ack is monotonically increasing, a SACK whose\n\t *     Cumulative TSN Ack is less than the Cumulative TSN Ack\n\t *     Point indicates an out-of-order SACK.\n\t */\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* Return this SACK for further processing.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t/* Note: We do the rest of the work on the PROCESS_SACK\n\t * sideeffect.\n\t */\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate an ABORT in response to a packet.\n *\n * Section: 8.4 Handle \"Out of the blue\" Packets, sctpimpguide 2.41\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n *\n * Verification Tag:\n *\n * The return value is the disposition of the chunk.\n*/\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT. The T bit will be set if the asoc\n\t\t * is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, 0);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR\n * event as ULP notification for each cause included in the chunk.\n *\n * API 5.3.1.3 - SCTP_REMOTE_ERROR\n *\n * The return value is the disposition of the chunk.\n*/\nsctp_disposition_t sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an inbound SHUTDOWN ACK.\n *\n * From Section 9.2:\n * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its\n * peer, and remove all record of the association.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* 10.2 H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t/* ...send a SHUTDOWN COMPLETE chunk to its peer, */\n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t/* Do all the commands now (after allocation), so that we\n\t * have consistent state if memory allocation failes\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n\t * stop the T2-shutdown timer,\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t/* ...and remove all record of the association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n */\nsctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an \"Out of the blue\" SHUTDOWN ACK.\n *\n * Section: 8.4 5, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * Inputs\n * (endpoint, asoc, type, arg, commands)\n *\n * Outputs\n * (sctp_disposition_t)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an SHUTDOWN_COMPLETE.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\t\tif (!shut) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(shut))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tshut->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, shut);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\t/* If the chunk length is invalid, we don't want to process\n\t\t * the reset of the packet.\n\t\t */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* We need to discard the rest of the packet to prevent\n\t\t * potential bomming attacks from additional bundled chunks.\n\t\t * This is documented in SCTP Threats ID.\n\t\t */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.\n *\n * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK\n *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the\n *   procedures in section 8.4 SHOULD be followed, in other words it\n *   should be treated as an Out Of The Blue packet.\n *   [This means that we do NOT check the Verification Tag on these\n *   chunks. --piggy ]\n *\n */\nsctp_disposition_t sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Although we do have an association in this case, it corresponds\n\t * to a restarted association. So the packet is treated as an OOTB\n\t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n\t * called with a NULL association.\n\t */\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */\nsctp_disposition_t sctp_sf_do_asconf(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\t__u32\t\t\tserial;\n\tint\t\t\tlength;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\taddr_param = (union sctp_addr_param *)hdr->params;\n\tlength = ntohs(addr_param->p.length);\n\tif (length < sizeof(sctp_paramhdr_t))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)addr_param, commands);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n\t\t\t    (void *)chunk->chunk_end,\n\t\t\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t/* Reset the transport so that we select the correct one\n\t\t * this time around.  This is to make sure that we don't\n\t\t * accidentally use a stale transport that's been removed.\n\t\t */\n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created until we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t        sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport,\n                    commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.3 General rules for address manipulation\n * When building TLV parameters for the ASCONF Chunk that will add or\n * delete IP addresses the D0 to D13 rules should be applied:\n */\nsctp_disposition_t sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t    (sctp_paramhdr_t *)addip_hdr->params,\n\t    (void *)asconf_ack->chunk_end,\n\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack)) {\n\t\t\t/* Successfully processed ASCONF_ACK.  We can\n\t\t\t * release the next asconf if we have one.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_NEXT_ASCONF,\n\t\t\t\t\tSCTP_NULL());\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t}\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP\n *\n * When a FORWARD TSN chunk arrives, the data receiver MUST first update\n * its cumulative TSN point to the value carried in the FORWARD TSN\n * chunk, and then MUST further advance its cumulative TSN point locally\n * if possible.\n * After the above processing, the data receiver MUST stop reporting any\n * missing TSNs earlier than or equal to the new cumulative TSN point.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto discard_noforce;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->autoclose) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nsctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto gen_shutdown;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * SCTP-AUTH Section 6.3 Receiving authenticated chukns\n *\n *    The receiver MUST use the HMAC algorithm indicated in the HMAC\n *    Identifier field.  If this algorithm was not specified by the\n *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk\n *    during association setup, the AUTH chunk and all chunks after it MUST\n *    be discarded and an ERROR chunk SHOULD be sent with the error cause\n *    defined in Section 4.1.\n *\n *    If an endpoint with no shared key receives a Shared Key Identifier\n *    other than 0, it MUST silently discard all authenticated chunks.  If\n *    the endpoint has at least one endpoint pair shared key for the peer,\n *    it MUST use the key specified by the Shared Key Identifier if a\n *    key has been configured for that Shared Key Identifier.  If no\n *    endpoint pair shared key has been configured for that Shared Key\n *    Identifier, all authenticated chunks MUST be silently discarded.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\t__u8 *save_digest;\n\t__u8 *digest;\n\n\t/* Pull in the auth header, so we can do some more verification */\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(struct sctp_authhdr));\n\n\t/* Make sure that we support the HMAC algorithm from the auth\n\t * chunk.\n\t */\n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t/* Make sure that the provided shared key identifier has been\n\t * configured\n\t */\n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id && !sctp_auth_get_shkey(asoc, key_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\n\n\t/* Make sure that the length of the signature matches what\n\t * we expect.\n\t */\n\tsig_len = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_auth_chunk_t);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Now that we've done validation checks, we can compute and\n\t * verify the hmac.  The steps involved are:\n\t *  1. Save the digest from the chunk.\n\t *  2. Zero out the digest in the chunk.\n\t *  3. Compute the new digest\n\t *  4. Compare saved and new digests.\n\t */\n\tdigest = auth_hdr->hmac;\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t(struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\tGFP_ATOMIC);\n\n\t/* Discard the packet if the digests do not match */\n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nsctp_disposition_t sctp_sf_eat_auth(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_ierror_t error;\n\n\t/* Make sure that the peer has AUTH capable */\n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the AUTH chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(net, ep, asoc, type, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t/* Generate the ERROR chunk and discard the rest\n\t\t * of the packet\n\t\t */\n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Fall Through */\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t/* Prevent gcc warnings */\n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEWKEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn -ENOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an unknown chunk.\n *\n * Section: 3.2. Also, 2.1 in the implementor's guide.\n *\n * Chunk Types are encoded such that the highest-order two bits specify\n * the action that must be taken if the processing endpoint does not\n * recognize the Chunk Type.\n *\n * 00 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it.\n *\n * 01 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it, and report the unrecognized\n *      chunk in an 'Unrecognized Chunk Type'.\n *\n * 10 - Skip this chunk and continue processing.\n *\n * 11 - Skip this chunk and continue processing, but report in an ERROR\n *      Chunk using the 'Unrecognized Chunk Type' cause of error.\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_chunkhdr_t *hdr;\n\n\tSCTP_DEBUG_PRINTK(\"Processing the unknown chunk id %d.\\n\", type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t/* Discard the packet.  */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t/* Discard the packet.  */\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\tbreak;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t\tbreak;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the chunk.\n *\n * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2\n * [Too numerous to mention...]\n * Verification Tag: No verification needed.\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tSCTP_DEBUG_PRINTK(\"Chunk %d is discarded\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the whole packet.\n *\n * Section: 8.4 2)\n *\n * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n *    silently discard the OOTB packet and take no further action.\n *\n * Verification Tag: No verification necessary\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_pdiscard(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n/*\n * The other end is violating protocol.\n *\n * Section: Not specified\n * Verification Tag: Not specified\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * We simply tag the chunk as a violation.  The state machine will log\n * the violation and continue.\n */\nsctp_disposition_t sctp_sf_violation(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n/*\n * Common function to handle a protocol violation.\n */\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t\t\t     sizeof(sctp_initack_chunk_t)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a protocol violation when the chunk length is invalid.\n * \"Invalid\" length is identified as smaller than the minimal length a\n * given chunk can be.  For example, a SACK chunk has invalid length\n * if its length is set to be smaller than the size of sctp_sack_chunk_t.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n *\n * Section: Not specified\n * Verification Tag:  Nothing to do\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (reply_msg, msg_up, counters)\n *\n * Generate an  ABORT chunk and terminate the association.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/*\n * Handle a protocol violation when the parameter length is invalid.\n * If the length is smaller than the minimum length of a given parameter,\n * or accumulated length in multi parameters exceeds the end of the chunk,\n * the length is considered as invalid.\n */\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle a protocol violation when the peer trying to advance the\n * cumulative tsn ack to a point beyond the max tsn currently sent.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n */\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/* Handle protocol violation of an invalid chunk bundling.  For example,\n * when we have an association and we receive bundled INIT-ACK, or\n * SHUDOWN-COMPLETE, our peer is clearly violationg the \"MUST NOT bundle\"\n * statement from the specs.  Additionally, there might be an attacker\n * on the path and we may not want to continue this communication.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n/***************************************************************************\n * These are the state functions for handling primitive (Section 10) events.\n ***************************************************************************/\n/*\n * sctp_sf_do_prm_asoc\n *\n * Section: 10.1 ULP-to-SCTP\n * B) Associate\n *\n * Format: ASSOCIATE(local SCTP instance name, destination transport addr,\n * outbound stream count)\n * -> association id [,destination transport addr list] [,outbound stream\n * count]\n *\n * This primitive allows the upper layer to initiate an association to a\n * specific peer endpoint.\n *\n * The peer endpoint shall be specified by one of the transport addresses\n * which defines the endpoint (see Section 1.4).  If the local SCTP\n * instance has not been initialized, the ASSOCIATE is considered an\n * error.\n * [This is not relevant for the kernel implementation since we do all\n * initialization at boot time.  It we hadn't initialized we wouldn't\n * get anywhere near this code.]\n *\n * An association id, which is a local handle to the SCTP association,\n * will be returned on successful establishment of the association. If\n * SCTP is not able to open an SCTP association with the peer endpoint,\n * an error is returned.\n * [In the kernel implementation, the struct sctp_association needs to\n * be created BEFORE causing this primitive to run.]\n *\n * Other association parameters may be returned, including the\n * complete destination transport addresses of the peer as well as the\n * outbound stream count of the local endpoint. One of the transport\n * address from the returned destination addresses will be selected by\n * the local endpoint as default primary path for sending SCTP packets\n * to this peer.  The returned \"destination transport addr list\" can\n * be used by the ULP to change the default primary path or to force\n * sending a packet to a specific transport address.  [All of this\n * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING\n * function.]\n *\n * Mandatory attributes:\n *\n * o local SCTP instance name - obtained from the INITIALIZE operation.\n *   [This is the argument asoc.]\n * o destination transport addr - specified as one of the transport\n * addresses of the peer endpoint with which the association is to be\n * established.\n *  [This is asoc->peer.active_path.]\n * o outbound stream count - the number of outbound streams the ULP\n * would like to open towards this peer endpoint.\n * [BUG: This is not currently implemented.]\n * Optional attributes:\n *\n * None.\n *\n * The return value is a disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association* my_asoc;\n\n\t/* The comment below says that we enter COOKIE-WAIT AFTER\n\t * sending the INIT, but that doesn't actually work in our\n\t * implementation...\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\"\n\t * must provide its Verification Tag (Tag_A) in the Initiate\n\t * Tag field.  Tag_A SHOULD be a random number in the range of\n\t * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...\n\t */\n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t/* Choose transport for INIT. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t/* After sending the INIT, \"A\" starts the T1-init timer and\n\t * enters the COOKIE-WAIT state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the SEND primitive.\n *\n * Section: 10.1 ULP-to-SCTP\n * E) Send\n *\n * Format: SEND(association id, buffer address, byte count [,context]\n *         [,stream id] [,life time] [,destination transport address]\n *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n * -> result\n *\n * This is the main method to send user data via SCTP.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n *  o buffer address - the location where the user message to be\n *    transmitted is stored;\n *\n *  o byte count - The size of the user data in number of bytes;\n *\n * Optional attributes:\n *\n *  o context - an optional 32 bit integer that will be carried in the\n *    sending failure notification to the ULP if the transportation of\n *    this User Message fails.\n *\n *  o stream id - to indicate which stream to send the data on. If not\n *    specified, stream 0 will be used.\n *\n *  o life time - specifies the life time of the user data. The user data\n *    will not be sent by SCTP after the life time expires. This\n *    parameter can be used to avoid efforts to transmit stale\n *    user messages. SCTP notifies the ULP if the data cannot be\n *    initiated to transport (i.e. sent to the destination via SCTP's\n *    send primitive) within the life time variable. However, the\n *    user data will be transmitted if SCTP has attempted to transmit a\n *    chunk before the life time expired.\n *\n *  o destination transport address - specified as one of the destination\n *    transport addresses of the peer endpoint to which this packet\n *    should be sent. Whenever possible, SCTP should use this destination\n *    transport address for sending the packets, instead of the current\n *    primary path.\n *\n *  o unorder flag - this flag, if present, indicates that the user\n *    would like the data delivered in an unordered fashion to the peer\n *    (i.e., the U flag is set to 1 on all DATA chunks carrying this\n *    message).\n *\n *  o no-bundle flag - instructs SCTP not to bundle this user data with\n *    other outbound DATA chunks. SCTP MAY still bundle even when\n *    this flag is present, when faced with network congestion.\n *\n *  o payload protocol-id - A 32 bit unsigned integer that is to be\n *    passed to the peer indicating the type of payload protocol data\n *    being transmitted. This value is passed as opaque data by SCTP.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process the SHUTDOWN primitive.\n *\n * Section: 10.1:\n * C) Shutdown\n *\n * Format: SHUTDOWN(association id)\n * -> result\n *\n * Gracefully closes an association. Any locally queued user data\n * will be delivered to the peer. The association will be terminated only\n * after the peer acknowledges all the SCTP packets sent.  A success code\n * will be returned on successful termination of the association. If\n * attempting to terminate the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*\n * Process the ABORT primitive.\n *\n * Section: 10.1:\n * C) Abort\n *\n * Format: Abort(association id [, cause code])\n * -> result\n *\n * Ungracefully closes an association. Any locally queued user data\n * will be discarded and an ABORT chunk is sent to the peer.  A success code\n * will be returned on successful abortion of the association. If\n * attempting to abort the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n *  o cause code - reason of the abort to be passed to the peer\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_1_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn retval;\n}\n\n/* We tried an illegal operation on an association which is closed.  */\nsctp_disposition_t sctp_sf_error_closed(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* We tried an illegal operation on an association which is shutting\n * down.\n */\nsctp_disposition_t sctp_sf_error_shutdown(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_cookie_wait_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * sctp_cookie_echoed_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_wait_prm_abort\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\t/* Stop T1-init timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn retval;\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Section: 4 Note: 3\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_pending_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-PENDING state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_pending_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_sent_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-SENT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process the REQUESTHEARTBEAT primitive\n *\n * 10.1 ULP-to-SCTP\n * J) Request Heartbeat\n *\n * Format: REQUESTHEARTBEAT(association id, destination transport address)\n *\n * -> result\n *\n * Instructs the local endpoint to perform a HeartBeat on the specified\n * destination transport address of the given association. The returned\n * result should indicate whether the transmission of the HEARTBEAT\n * chunk to the destination address is successful.\n *\n * Mandatory attributes:\n *\n * o association id - local handle to the SCTP association\n *\n * o destination transport address - the transport address of the\n *   association on which a heartbeat should be issued.\n */\nsctp_disposition_t sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/*\n\t * RFC 2960 (bis), section 8.3\n\t *\n\t *    D) Request an on-demand HEARTBEAT on a specific destination\n\t *    transport address of a given association.\n\t *\n\t *    The endpoint should increment the respective error  counter of\n\t *    the destination transport address each time a HEARTBEAT is sent\n\t *    to that address and not acknowledged within one RTO.\n\t *\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * When an endpoint has an ASCONF signaled change to be sent to the\n * remote endpoint it should do A1 to A9\n */\nsctp_disposition_t sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Ignore the primitive event\n *\n * The return value is the disposition of the primitive.\n */\nsctp_disposition_t sctp_sf_ignore_primitive(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tSCTP_DEBUG_PRINTK(\"Primitive type %d is ignored.\\n\", type.primitive);\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/***************************************************************************\n * These are the state functions for the OTHER events.\n ***************************************************************************/\n\n/*\n * When the SCTP stack has no more user data to send or retransmit, this\n * notification is given to the user. Also, at the time when a user app\n * subscribes to this event, if there is no data to be sent or\n * retransmit, the stack will immediately send up this notification.\n */\nsctp_disposition_t sctp_sf_do_no_pending_tsn(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Start the shutdown negotiation.\n *\n * From Section 9.2:\n * Once all its outstanding data has been acknowledged, the endpoint\n * shall send a SHUTDOWN chunk to its peer including in the Cumulative\n * TSN Ack field the last sequential TSN it has received from the peer.\n * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n * state. If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_start_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t/* Once all its outstanding data has been acknowledged, the\n\t * endpoint shall send a SHUTDOWN chunk to its peer including\n\t * in the Cumulative TSN Ack field the last sequential TSN it\n\t * has received from the peer.\n\t */\n\treply = sctp_make_shutdown(asoc, NULL);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN chunk and the timeout for the\n\t * T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* It shall then start the T2-shutdown timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* RFC 4960 Section 9.2\n\t * The sender of the SHUTDOWN MAY also start an overall guard timer\n\t * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* and enter the SHUTDOWN-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Generate a SHUTDOWN ACK now that everything is SACK'd.\n *\n * From Section 9.2:\n *\n * If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the\n * endpoint must re-send the SHUTDOWN ACK.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t\t  commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Ignore the event defined as other\n *\n * The return value is the disposition of the event.\n */\nsctp_disposition_t sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tSCTP_DEBUG_PRINTK(\"The event other type %d is ignored\\n\", type.other);\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/************************************************************\n * These are the state functions for handling timeout events.\n ************************************************************/\n\n/*\n * RTX Timeout\n *\n * Section: 6.3.3 Handle T3-rtx Expiration\n *\n * Whenever the retransmission timer T3-rtx expires for a destination\n * address, do the following:\n * [See below]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate delayed SACK on timeout\n *\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated\n * within 200 ms of the arrival of any unacknowledged DATA chunk.  In\n * some situations it may be beneficial for an SCTP transmitter to be\n * more conservative than the algorithms detailed in this document\n * allow. However, an SCTP transmitter MUST NOT be more aggressive than\n * the following algorithms allow.\n */\nsctp_disposition_t sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_init_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT\n *     and re-start the T1-init timer without changing state.  This MUST\n *     be repeated up to 'Max.Init.Retransmits' times.  After that, the\n *     endpoint MUST abort the initialization process and report the\n *     error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_init_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T1 expired (INIT).\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Choose transport for INIT. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tSCTP_DEBUG_PRINTK(\"Giving up on INIT, attempts: %d\"\n\t\t\t\t  \" max_init_attempts: %d\\n\",\n\t\t\t\t  attempts, asoc->max_init_attempts);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_cookie_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  3) If the T1-cookie timer expires, the endpoint MUST retransmit\n *     COOKIE ECHO and re-start the T1-cookie timer without changing\n *     state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n *     After that, the endpoint MUST abort the initialization process and\n *     report the error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_cookie_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T1 expired (COOKIE-ECHO).\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * An endpoint should limit the number of retransmissions of the\n * SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n * If this threshold is exceeded the endpoint should destroy the TCB and\n * MUST report the peer endpoint unreachable to the upper layer (and\n * thus the association enters the CLOSED state).  The reception of any\n * packet from its peer (i.e. as the peer sends all of its queued DATA\n * chunks) should clear the endpoint's retransmission count and restart\n * the T2-Shutdown timer,  giving its peer ample opportunity to transmit\n * all of its queued DATA chunks that have not yet been sent.\n */\nsctp_disposition_t sctp_sf_t2_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T2 expired.\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Do some failure management (Section 8.2).\n\t * If we remove the transport an SHUTDOWN was last sent to, don't\n\t * do failure management.\n\t */\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* Restart the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF CHunk Procedures\n * If the T4 RTO timer expires the endpoint should do B1 to B5\n */\nsctp_disposition_t sctp_sf_t4_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t/* ADDIP 4.1 B1) Increment the error counters and perform path failure\n\t * detection on the appropriate destination address as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t */\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t/* Reconfig T4 timer and transport. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t/* ADDIP 4.1 B2) Increment the association error counters and perform\n\t * endpoint failure detection on the association as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t * association error counter is incremented in SCTP_CMD_STRIKE.\n\t */\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t/* ADDIP 4.1 B3) Back-off the destination address RTO value to which\n\t * the ASCONF chunk was sent by doubling the RTO timer value.\n\t * This is done in SCTP_CMD_STRIKE.\n\t */\n\n\t/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible\n\t * choose an alternate destination address (please refer to RFC2960\n\t * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this\n\t * chunk, it MUST be the same (including its serial number) as the last\n\t * ASCONF sent.\n\t */\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different\n\t * destination is selected, then the RTO used will be that of the new\n\t * destination address.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* sctpimpguide-05 Section 2.12.2\n * The sender of the SHUTDOWN MAY also start an overall guard timer\n * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n * At the expiration of this timer the sender SHOULD abort the association\n * by sending an ABORT chunk.\n */\nsctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T5 expired.\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,\n * the association is automatically closed by starting the shutdown process.\n * The work that needs to be done is same as when SHUTDOWN is initiated by\n * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().\n */\nsctp_disposition_t sctp_sf_autoclose_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*****************************************************************************\n * These are sa state functions which could apply to all types of events.\n ****************************************************************************/\n\n/*\n * This table entry is not implemented.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_not_impl(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n/*\n * This table entry represents a bug.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_bug(struct net *net,\n\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t       const struct sctp_association *asoc,\n\t\t\t       const sctp_subtype_t type,\n\t\t\t       void *arg,\n\t\t\t       sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n/*\n * This table entry represents the firing of a timer in the wrong state.\n * Since timer deletion cannot be guaranteed a timer 'may' end up firing\n * when the association is in the wrong state.   This event should\n * be ignored, so as to prevent any rearming of the timer.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tSCTP_DEBUG_PRINTK(\"Timer %d ignored.\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Pull the SACK chunk based on the SACK header. */\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\tunsigned int len;\n\t__u16 num_blocks;\n\t__u16 num_dup_tsns;\n\n\t/* Protect ourselves from reading too far into\n\t * the skb from a bogus sender.\n\t */\n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n/* Create an ABORT packet to be sent as a response, with the specified\n * error causes.\n */\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Add specified error causes, i.e., payload, to the\n\t\t * end of the chunk.\n\t\t */\n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n/* Allocate a packet for responding in the OOTB conditions.  */\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_transport *transport;\n\t__u16 sport;\n\t__u16 dport;\n\t__u32 vtag;\n\n\t/* Get the source and destination port from the inbound packet.  */\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t/* The V-tag is going to be the same as the inbound packet if no\n\t * association exists, otherwise, use the peer's vtag.\n\t */\n\tif (asoc) {\n\t\t/* Special case the INIT-ACK as there is no peer's vtag\n\t\t * yet.\n\t\t */\n\t\tswitch(chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Special case the INIT and stale COOKIE_ECHO as there is no\n\t\t * vtag yet.\n\t\t */\n\t\tswitch(chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tsctp_init_chunk_t *init;\n\n\t\t\tinit = (sctp_init_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make a transport for the bucket, Eliza... */\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\t/* Cache a route for the transport with the chunk's destination as\n\t * the source address.\n\t */\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = sctp_packet_init(&transport->packet, transport, sport, dport);\n\tpacket = sctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n/* Free the packet allocated earlier for responding in the OOTB condition.  */\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t/* Override the OOTB vtag from the cookie. */\n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t/* Set the skb to the belonging sock for accounting. */\n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n/* Process a data chunk */\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tSCTP_DEBUG_PRINTK(\"eat_data: TSN 0x%x.\\n\", tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (!chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\taf = sctp_get_af_specific(\n\t\t\tipver2af(ip_hdr(chunk->skb)->version));\n\n\t\tif (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tSCTP_DEBUG_PRINTK(\"Reneging for tsn:%u\\n\", tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tSCTP_DEBUG_PRINTK(\"Discard tsn: %u len: %Zd, \"\n\t\t\t\t\t  \"rwnd: %d\\n\", tsn, datalen,\n\t\t\t\t\t  asoc->rwnd);\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t           (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tSCTP_DEBUG_PRINTK(\"Under Pressure! Reneging for tsn:%u\\n\", tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n"], "fixing_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n * Copyright (c) 2002      Nokia Corp.\n *\n * This is part of the SCTP Linux Kernel Implementation.\n *\n * These are the state functions for the state machine.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, write to\n * the Free Software Foundation, 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <lksctp-developers@lists.sourceforge.net>\n *\n * Or submit a bug report through the following website:\n *    http://www.sf.net/projects/lksctp\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Mathew Kotowsky       <kotowsky@sctp.org>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Hui Huang \t    <hui.huang@nokia.com>\n *    Dajiang Zhang \t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Kevin Gao\t\t    <kevin.gao@intel.com>\n *\n * Any bugs reported given to us we will try to fix... any fixes shared will\n * be incorporated into the next SCTP release.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport);\n\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen);\n\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\n\n/* Small helper function that checks if the chunk length\n * is of the appropriate length.  The 'required_length' argument\n * is set to be the size of a specific chunk we are testing.\n * Return Values:  1 = Valid length\n * \t\t   0 = Invalid length\n *\n */\nstatic inline int\nsctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**********************************************************\n * These are the state functions for handling chunk events.\n **********************************************************/\n\n/*\n * Process the final SHUTDOWN COMPLETE.\n *\n * Section: 4 (C) (diagram), 9.2\n * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify\n * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be\n * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint\n * should stop the T2-shutdown timer and remove all knowledge of the\n * association (and thus the association enters the CLOSED state).\n *\n * Verification Tag: 8.5.1(C), sctpimpguide 2.41.\n * C) Rules for packet carrying SHUTDOWN COMPLETE:\n * ...\n * - The receiver of a SHUTDOWN COMPLETE shall accept the packet\n *   if the Verification Tag field of the packet matches its own tag and\n *   the T bit is not set\n *   OR\n *   it is set to its peer's tag and the T bit is set in the Chunk\n *   Flags.\n *   Otherwise, the receiver MUST silently discard the packet\n *   and take no further action.  An endpoint MUST ignore the\n *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_4_C(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t  void *arg,\n\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * Respond to a normal INIT chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, B\n * B) \"Z\" shall respond immediately with an INIT ACK chunk.  The\n *    destination IP address of the INIT ACK MUST be set to the source\n *    IP address of the INIT to which this INIT ACK is responding.  In\n *    the response, besides filling in other parameters, \"Z\" must set the\n *    Verification Tag field to Tag_A, and also provide its own\n *    Verification Tag (Tag_Z) in the Initiate Tag field.\n *\n * Verification Tag: Must be 0.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * Normally, this would cause an ABORT with a Protocol Violation\n\t * error, but since we don't have an association, we'll\n\t * just discard the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the INIT is coming toward a closing socket, we'll send back\n\t * and ABORT.  Essentially, this catches the race of INIT being\n\t * backloged to the socket at the same time as the user isses close().\n\t * Since the socket and all its associations are going away, we\n\t * can treat this OOTB\n\t */\n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t/* The call, sctp_process_init(), can fail on memory allocation.  */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note:  After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources, nor keep any states for the\n\t * new association.  Otherwise, \"Z\" will be vulnerable to resource\n\t * attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal INIT ACK chunk.\n * We are the side that is initiating the association.\n *\n * Section: 5.1 Normal Establishment of an Association, C\n * C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-init\n *    timer and leave COOKIE-WAIT state. \"A\" shall then send the State\n *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start\n *    the T1-cookie timer, and enter the COOKIE-ECHOED state.\n *\n *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound\n *    DATA chunks, but it MUST be the first chunk in the packet and\n *    until the COOKIE ACK is returned the sender MUST NOT send any\n *    other packets to the peer.\n *\n * Verification Tag: 3.3.3\n *   If the value of the Initiate Tag in a received INIT ACK chunk is\n *   found to be 0, the receiver MUST treat it as an error and close the\n *   association by transmitting an ABORT.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_init_chunk_t *initchunk;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT-ACK chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tsctp_error_t error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes.  If there are no causes,\n\t\t * then there wasn't enough memory.  Just terminate\n\t\t * the association.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t/* SCTP-AUTH, Section 6.3:\n\t\t *    It should be noted that if the receiver wants to tear\n\t\t *    down an association in an authenticated way only, the\n\t\t *    handling of malformed packets should not result in\n\t\t *    tearing down the association.\n\t\t *\n\t\t * This means that if we only want to abort associations\n\t\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t\t * can't destroy this association just because the packet\n\t\t * was malformed.\n\t\t */\n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t/* Tag the variable length parameters.  Note that we never\n\t * convert the parameters in an INIT chunk.\n\t */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tinitchunk = (sctp_init_chunk_t *) chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t/* Reset init error count upon receipt of INIT-ACK.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall stop the T1-init timer and leave\n\t * COOKIE-WAIT state.  \"A\" shall then ... start the T1-cookie\n\t * timer, and enter the COOKIE-ECHOED state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t/* SCTP-AUTH: genereate the assocition shared keys so that\n\t * we can potentially signe the COOKIE-ECHO.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall then send the State Cookie received in the\n\t * INIT ACK chunk in a COOKIE ECHO chunk, ...\n\t */\n\t/* If there is any errors to report, send the ERROR chunk generated\n\t * for unknown parameters as well.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Respond to a normal COOKIE ECHO chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, D\n * D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply\n *    with a COOKIE ACK chunk after building a TCB and moving to\n *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with\n *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK\n *    chunk MUST be the first chunk in the packet.\n *\n *   IMPLEMENTATION NOTE: An implementation may choose to send the\n *   Communication Up notification to the SCTP user upon reception\n *   of a valid COOKIE ECHO chunk.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * D) Rules for packet carrying a COOKIE ECHO\n *\n * - When sending a COOKIE ECHO, the endpoint MUST use the value of the\n *   Initial Tag received in the INIT ACK.\n *\n * - The receiver of a COOKIE ECHO follows the procedures in Section 5.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal COOKIE ACK chunk.\n * We are the side that is being asked for an association.\n *\n * RFC 2960 5.1 Normal Establishment of an Association\n *\n * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie\n *    timer. It may also notify its ULP about the successful\n *    establishment of the association with a Communication Up\n *    notification (see Section 10).\n *\n * Verification Tag:\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Verify that the chunk length for the COOKIE-ACK is OK.\n\t * If we don't do this, any bundled chunks may be junked.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Reset init error count upon receipt of COOKIE-ACK,\n\t * to avoid problems with the managemement of this\n\t * counter in stale cookie situations when a transition back\n\t * from the COOKIE-ECHOED state to the COOKIE-WAIT\n\t * state is performed.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move\n\t * from the COOKIE-ECHOED state to the ESTABLISHED state,\n\t * stopping the T1-cookie timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* It may also notify its ULP about the successful\n\t * establishment of the association with a Communication Up\n\t * notification (see Section 10).\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Generate and sendout a heartbeat packet.  */\nstatic sctp_disposition_t sctp_sf_heartbeat(const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Send a heartbeat to our peer.  */\n\treply = sctp_make_heartbeat(asoc, transport);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Set rto_pending indicating that an RTT measurement\n\t * is started with this heartbeat chunk.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Generate a HEARTBEAT packet on the given transport.  */\nsctp_disposition_t sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t/* Section 3.3.5.\n\t * The Sender-specific Heartbeat Info field should normally include\n\t * information about the sender's current time when this HEARTBEAT\n\t * chunk is sent and the destination transport address to which this\n\t * HEARTBEAT is sent (see Section 8.3).\n\t */\n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Set transport error counter and association error counter\n\t\t * when sending heartbeat.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an heartbeat request.\n *\n * Section: 8.3 Path Heartbeat\n * The receiver of the HEARTBEAT should immediately respond with a\n * HEARTBEAT ACK that contains the Heartbeat Information field copied\n * from the received HEARTBEAT chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * When receiving an SCTP packet, the endpoint MUST ensure that the\n * value in the Verification Tag field of the received SCTP packet\n * matches its own Tag. If the received Verification Tag value does not\n * match the receiver's own tag value, the receiver shall silently\n * discard the packet and shall not process it any further except for\n * those cases listed in Section 8.5.1 below.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tsctp_paramhdr_t *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_heartbeat_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* 8.3 The receiver of the HEARTBEAT should immediately\n\t * respond with a HEARTBEAT ACK that contains the Heartbeat\n\t * Information field copied from the received HEARTBEAT chunk.\n\t */\n\tchunk->subh.hb_hdr = (sctp_heartbeathdr_t *) chunk->skb->data;\n\tparam_hdr = (sctp_paramhdr_t *) chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the returning HEARTBEAT ACK.\n *\n * Section: 8.3 Path Heartbeat\n * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n * should clear the error counter of the destination transport\n * address to which the HEARTBEAT was sent, and mark the destination\n * transport address as active if it is not so marked. The endpoint may\n * optionally report to the upper layer when an inactive destination\n * address is marked as active due to the reception of the latest\n * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also\n * clear the association overall error count as well (as defined\n * in section 8.1).\n *\n * The receiver of the HEARTBEAT ACK should also perform an RTT\n * measurement for that destination transport address using the time\n * value carried in the HEARTBEAT ACK chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunion sctp_addr from_addr;\n\tstruct sctp_transport *link;\n\tsctp_sender_hb_info_t *hbinfo;\n\tunsigned long max_interval;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t) +\n\t\t\t\t\t    sizeof(sctp_sender_hb_info_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\n\t/* Make sure that the length of the parameter is what we expect */\n\tif (ntohs(hbinfo->param_hdr.length) !=\n\t\t\t\t    sizeof(sctp_sender_hb_info_t)) {\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t/* This should never happen, but lets log it if so.  */\n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Validate the 64-bit random nonce. */\n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t/* Check if the timestamp looks valid.  */\n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tSCTP_DEBUG_PRINTK(\"%s: HEARTBEAT ACK with invalid timestamp \"\n\t\t\t\t  \"received for transport: %p\\n\",\n\t\t\t\t   __func__, link);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of\n\t * the HEARTBEAT should clear the error counter of the\n\t * destination transport address to which the HEARTBEAT was\n\t * sent and mark the destination transport address as active if\n\t * it is not so marked.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Helper function to send out an abort for the restart\n * condition.\n */\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\n\t/* Build the error on the stack.   We are way to malloc crazy\n\t * throughout the code today.\n\t */\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\n\t/* Copy into a parm format. */\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t/* Assign to the control socket. */\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t/* Association is NULL since this may be a restart attack and we\n\t * want to send back the attacker's vtag.\n\t */\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* Discard the rest of the inbound packet. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t/* Even if there is no memory, treat as a failure so\n\t * the packet will get dropped.\n\t */\n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n/* A restart is occurring, check to make sure no new addresses\n * are being added as we may be under a takeover attack.\n */\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct net *net = sock_net(new_asoc->base.sk);\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t/* Implementor's Guide - Section 5.2.2\n\t * ...\n\t * Before responding the endpoint MUST check to see if the\n\t * unexpected INIT adds new addresses to the association. If new\n\t * addresses are added to the association, the endpoint MUST respond\n\t * with an ABORT..\n\t */\n\n\t/* Search through all current addresses and make sure\n\t * we aren't adding any new ones.\n\t */\n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Return success if all addresses were found. */\n\treturn ret;\n}\n\n/* Populate the verification/tie tags based on overlapping INIT\n * scenario.\n *\n * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.\n */\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n/*\n * Compare vtag/tietag values to determine unexpected COOKIE-ECHO\n * handling action.\n *\n * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.\n *\n * Returns value representing action to be taken.   These action values\n * correspond to Action/Description values in RFC 2960, Table 2.\n */\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t/* In this case, the peer may have restarted.  */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t/* Collision case B. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t/* Collision case D. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t/* Collision case C. */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t/* No match to any of the special cases; discard this packet. */\n\treturn 'E';\n}\n\n/* Common helper routine for both duplicate and simulataneous INIT\n * chunk handling.\n */\nstatic sctp_disposition_t sctp_sf_do_unexpected_init(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * In this case, we generate a protocol violation since we have\n\t * an association established.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/*\n\t * Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t * FIXME:  We are copying parameters from the endpoint not the\n\t * association.\n\t */\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t/* In the outbound INIT ACK the endpoint MUST copy its current\n\t * Verification Tag and Peers Verification tag into a reserved\n\t * place (local tie-tag and per tie-tag) within the state cookie.\n\t */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.   Do not do this check for COOKIE-WAIT state,\n\t * since there are no peer addresses to check against.\n\t * Upon return an ABORT will have been sent if needed.\n\t */\n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note: After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources for this new association.\n\t * Otherwise, \"Z\" will be vulnerable to resource attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n/*\n * Handle simultaneous INIT.\n * This means we started an INIT and then we got an INIT request from\n * our peer.\n *\n * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n * This usually indicates an initialization collision, i.e., each\n * endpoint is attempting, at about the same time, to establish an\n * association with the other endpoint.\n *\n * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n * endpoint MUST respond with an INIT ACK using the same parameters it\n * sent in its original INIT chunk (including its Verification Tag,\n * unchanged). These original parameters are combined with those from the\n * newly received INIT chunk. The endpoint shall also generate a State\n * Cookie with the INIT ACK. The endpoint uses the parameters sent in its\n * INIT to calculate the State Cookie.\n *\n * After that, the endpoint MUST NOT change its state, the T1-init\n * timer shall be left running and the corresponding TCB MUST NOT be\n * destroyed. The normal procedures for handling State Cookies when\n * a TCB exists will resolve the duplicate INITs to a single association.\n *\n * For an endpoint that is in the COOKIE-ECHOED state it MUST populate\n * its Tie-Tags with the Tag information of itself and its peer (see\n * section 5.2.2 for a description of the Tie-Tags).\n *\n * Verification Tag: Not explicit, but an INIT can not have a valid\n * verification tag, so we skip the check.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle duplicated INIT messages.  These are usually delayed\n * restransmissions.\n *\n * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,\n * COOKIE-ECHOED and COOKIE-WAIT\n *\n * Unless otherwise stated, upon reception of an unexpected INIT for\n * this association, the endpoint shall generate an INIT ACK with a\n * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n * current Verification Tag and peer's Verification Tag into a reserved\n * place within the state cookie.  We shall refer to these locations as\n * the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n * containing this INIT ACK MUST carry a Verification Tag value equal to\n * the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n * MUST contain a new Initiation Tag (randomly generated see Section\n * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the\n * existing parameters of the association (e.g. number of outbound\n * streams) into the INIT ACK and cookie.\n *\n * After sending out the INIT ACK, the endpoint shall take no further\n * actions, i.e., the existing association, including its current state,\n * and the corresponding TCB MUST NOT be changed.\n *\n * Note: Only when a TCB exists and the association is not in a COOKIE-\n * WAIT state are the Tie-Tags populated.  For a normal association INIT\n * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n * set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n * State Cookie are populated as specified in section 5.2.1.\n *\n * Verification Tag: Not specified, but an INIT has no way of knowing\n * what the verification tag could be, so we ignore it.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_2_dupinit(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n/*\n * Unexpected INIT-ACK handler.\n *\n * Section 5.2.3\n * If an INIT ACK received by an endpoint in any state other than the\n * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.\n * An unexpected INIT ACK usually indicates the processing of an old or\n * duplicated INIT chunk.\n*/\nsctp_disposition_t sctp_sf_do_5_2_3_initack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg, sctp_cmd_seq_t *commands)\n{\n\t/* Per the above section, we'll discard the chunk if we have an\n\t * endpoint.  If this is an OOTB INIT-ACK, treat it as such.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\n/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action 'A')\n *\n * Section 5.2.4\n *  A)  In this case, the peer may have restarted.\n */\nstatic sctp_disposition_t sctp_sf_do_dupcook_a(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\tsctp_disposition_t disposition;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.  Though this is a pretty complicated attack\n\t * since you'd have to get inside the cookie.\n\t */\n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands)) {\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes\n\t * the peer has restarted (Action A), it MUST NOT setup a new\n\t * association but instead resend the SHUTDOWN ACK and send an ERROR\n\t * chunk with a \"Cookie Received while Shutting Down\" error cause to\n\t * its peer.\n\t*/\n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\tSCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\tchunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked\n\t * data. Consider the optional choice of resending of this data.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue\n\t * and ASCONF-ACK cache.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Report association restart to upper layer. */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Update the content of current association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'B')\n *\n * Section 5.2.4\n *   B) In this case, both sides may be attempting to start an association\n *      at about the same time but the peer endpoint started its INIT\n *      after responding to the local endpoint's INIT\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Update the content of current association.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'C')\n *\n * Section 5.2.4\n *  C) In this case, the local endpoint's cookie has arrived late.\n *     Before it arrived, the local endpoint sent an INIT and received an\n *     INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n *     but a new tag of its own.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_c(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t/* The cookie should be silently discarded.\n\t * The endpoint SHOULD NOT change states and should leave\n\t * any timers running.\n\t */\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action 'D')\n *\n * Section 5.2.4\n *\n * D) When both local and remote tags match the endpoint should always\n *    enter the ESTABLISHED state, if it has not already done so.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_d(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t/* Clarification from Implementor's Guide:\n\t * D) When both local and remote tags match the endpoint should\n\t * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.\n\t * It should stop any cookie timer that may be running and send\n\t * a COOKIE ACK.\n\t */\n\n\t/* Don't accidentally move back into established state. */\n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t\t *\n\t\t * D) IMPLEMENTATION NOTE: An implementation may choose\n\t\t * to send the Communication Up notification to the\n\t\t * SCTP user upon reception of a valid COOKIE\n\t\t * ECHO chunk.\n\t\t */\n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t/* Sockets API Draft Section 5.3.1.6\n\t\t * When a peer sends a Adaptation Layer Indication parameter,\n\t\t * SCTP delivers this notification to inform the application\n\t\t * that of the peers requested adaptation layer.\n\t\t */\n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying\n * chunk was retransmitted and then delayed in the network.\n *\n * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists\n *\n * Verification Tag: None.  Do cookie validation.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tint error = 0;\n\tchar action;\n\tstruct sctp_chunk *err_chk_p;\n\n\t/* Make sure that the chunk has a valid length from the protocol\n\t * perspective.  In this case check to make sure we have at least\n\t * enough for the chunk header.  Cookie length verification is\n\t * done later.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie\n\t * of a duplicate COOKIE ECHO match the Verification Tags of the\n\t * current association, consider the State Cookie valid even if\n\t * the lifespan is exceeded.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t/* Compare the tie_tag in cookie with the verification tag of\n\t * current association.\n\t */\n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A': /* Association restart. */\n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B': /* Collision case B. */\n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C': /* Collision case C. */\n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D': /* Collision case D. */\n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault: /* Discard packet for all others. */\n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t/* Delete the tempory new association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t/* Restore association pointer to provide SCTP command interpeter\n\t * with a valid context in case it needs to manipulate\n\t * the queues */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-PENDING state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_pending_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_sent_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Stop the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-ACK-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an Error received in COOKIE_ECHOED state.\n *\n * Only handle the error type of stale COOKIE Error, the other errors will\n * be ignored.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_cookie_echoed_err(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle a Stale COOKIE Error\n *\n * Section: 5.2.6 Handle Stale COOKIE Error\n * If the association is in the COOKIE-ECHOED state, the endpoint may elect\n * one of the following three alternatives.\n * ...\n * 3) Send a new INIT chunk to the endpoint, adding a Cookie\n *    Preservative parameter requesting an extension to the lifetime of\n *    the State Cookie. When calculating the time extension, an\n *    implementation SHOULD use the RTT information measured based on the\n *    previous COOKIE ECHO / ERROR exchange, and should add no more\n *    than 1 second beyond the measured RTT, due to long State Cookie\n *    lifetimes making the endpoint more subject to a replay attack.\n *\n * Verification Tag:  Not explicit, but safe to ignore.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\ttime_t stale;\n\tsctp_cookie_preserve_param_t bht;\n\tsctp_errhdr_t *err;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (sctp_errhdr_t *)(chunk->skb->data);\n\n\t/* When calculating the time extension, an implementation\n\t * SHOULD use the RTT information measured based on the\n\t * previous COOKIE ECHO / ERROR exchange, and should add no\n\t * more than 1 second beyond the measured RTT, due to long\n\t * State Cookie lifetimes making the endpoint more subject to\n\t * a replay attack.\n\t * Measure of Staleness's unit is usec. (1/1000000 sec)\n\t * Suggested Cookie Life-span Increment's unit is msec.\n\t * (1/1000 sec)\n\t * In general, if you use the suggested cookie life, the value\n\t * found in the field of measure of staleness should be doubled\n\t * to give ample time to retransmit the new cookie and thus\n\t * yield a higher probability of success on the reattempt.\n\t */\n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(sctp_errhdr_t)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t/* Build that new INIT chunk.  */\n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t/* Clear peer's init_tag cached in assoc as we are sending a new INIT */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t/* Stop pending T3-rtx and heartbeat timers */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t/* Delete non-primary peer ip addresses since we are transitioning\n\t * back to the COOKIE-WAIT state\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t/* If we've sent any data bundled with COOKIE-ECHO we will need to\n\t * resend\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.\n *\n * Section: 9.1\n * After checking the Verification Tag, the receiving endpoint shall\n * remove the association from its record, and shall report the\n * termination to its upper layer.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * B) Rules for packet carrying ABORT:\n *\n *  - The endpoint shall always fill in the Verification Tag field of the\n *    outbound packet with the destination endpoint's tag value if it\n *    is known.\n *\n *  - If the ABORT is sent in response to an OOTB packet, the endpoint\n *    MUST follow the procedure described in Section 8.4.\n *\n *  - The receiver MUST accept the packet if the Verification Tag\n *    matches either its own tag, OR the tag of its peer. Otherwise, the\n *    receiver MUST silently discard the packet and take no further\n *    action.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr)) {\n\n\t\tsctp_errhdr_t *err;\n\t\tsctp_walk_errors(err, chunk->chunk_hdr);\n\t\tif ((void *)err != (void *)chunk->chunk_end)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t/* ASSOC_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * Process an ABORT.  (COOKIE-WAIT state)\n *\n * See sctp_sf_do_9_1_abort() above.\n */\nsctp_disposition_t sctp_sf_cookie_wait_abort(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n/*\n * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)\n */\nsctp_disposition_t sctp_sf_cookie_wait_icmp_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n/*\n * Process an ABORT.  (COOKIE-ECHOED state)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_abort(struct net *net,\n\t\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t\t       void *arg,\n\t\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Stop T1 timer and abort association with \"INIT failed\".\n *\n * This is common code called by several sctp_sf_*_abort() functions above.\n */\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport)\n{\n\tSCTP_DEBUG_PRINTK(\"ABORT received (INIT).\\n\");\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_do_9_2_shut\n *\n * Section: 9.2\n * Upon the reception of the SHUTDOWN, the peer endpoint shall\n *  - enter the SHUTDOWN-RECEIVED state,\n *\n *  - stop accepting new data from its SCTP user\n *\n *  - verify, by checking the Cumulative TSN Ack field of the chunk,\n *    that all its outstanding DATA chunks have been received by the\n *    SHUTDOWN sender.\n *\n * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT\n * send a SHUTDOWN in response to a ULP request. And should discard\n * subsequent SHUTDOWN chunks.\n *\n * If there are still outstanding DATA chunks left, the SHUTDOWN\n * receiver shall continue to follow normal data transmission\n * procedures defined in Section 6 until all outstanding DATA chunks\n * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept\n * new data from its SCTP user.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\tsctp_disposition_t disposition;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Convert the elaborate header.  */\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_shutdownhdr_t));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT\n\t * When a peer sends a SHUTDOWN, SCTP delivers this notification to\n\t * inform the application that it should cease sending data.\n\t */\n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the reception of the SHUTDOWN, the peer endpoint shall\n\t *  - enter the SHUTDOWN-RECEIVED state,\n\t *  - stop accepting new data from its SCTP user\n\t *\n\t * [This is implicit in the new state.]\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t/*  - verify, by checking the Cumulative TSN Ack field of the\n\t *    chunk, that all its outstanding DATA chunks have been\n\t *    received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n/*\n * sctp_sf_do_9_2_shut_ctsn\n *\n * Once an endpoint has reached the SHUTDOWN-RECEIVED state,\n * it MUST NOT send a SHUTDOWN in response to a ULP request.\n * The Cumulative TSN Ack of the received SHUTDOWN chunk\n * MUST be processed.\n */\nsctp_disposition_t sctp_sf_do_9_2_shut_ctsn(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* verify, by checking the Cumulative TSN Ack field of the\n\t * chunk, that all its outstanding DATA chunks have been\n\t * received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC 2960 9.2\n * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk\n * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination\n * transport addresses (either in the IP addresses or in the INIT chunk)\n * that belong to this association, it should discard the INIT chunk and\n * retransmit the SHUTDOWN ACK chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_reshutack(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Make sure that the chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Since we are not going to really process this INIT, there\n\t * is no point in verifying chunk boundries.  Just generate\n\t * the SHUTDOWN ACK.\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-SHUTDOWN timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and restart the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * sctp_sf_do_ecn_cwr\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * CWR:\n *\n * RFC 2481 details a specific bit for a sender to send in the header of\n * its next outbound TCP segment to indicate to its peer that it has\n * reduced its congestion window.  This is termed the CWR bit.  For\n * SCTP the same indication is made by including the CWR chunk.\n * This chunk contains one data element, i.e. the TSN number that\n * was sent in the ECNE chunk.  This element represents the lowest\n * TSN number in the datagram that was originally marked with the\n * CE bit.\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tsctp_cwrhdr_t *cwr;\n\tstruct sctp_chunk *chunk = arg;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (sctp_cwrhdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_do_ecne\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * ECN-Echo\n *\n * RFC 2481 details a specific bit for a receiver to send back in its\n * TCP acknowledgements to notify the sender of the Congestion\n * Experienced (CE) bit having arrived from the network.  For SCTP this\n * same indication is made by including the ECNE chunk.  This chunk\n * contains one data element, i.e. the lowest TSN associated with the IP\n * datagram marked with the CE bit.....\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecne(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t   void *arg,\n\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tsctp_ecnehdr_t *ecne;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (sctp_ecnehdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_ecnehdr_t));\n\n\t/* If this is a newer ECNE than the last CWR packet we sent out */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The SCTP endpoint MUST always acknowledge the reception of each valid\n * DATA chunk.\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated within\n * 200 ms of the arrival of any unacknowledged DATA chunk. In some\n * situations it may be beneficial for an SCTP transmitter to be more\n * conservative than the algorithms detailed in this document allow.\n * However, an SCTP transmitter MUST NOT be more aggressive than the\n * following algorithms allow.\n *\n * A SCTP receiver MUST NOT generate more than one SACK for every\n * incoming packet, other than to update the offered window as the\n * receiving application consumes new data.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_arg_t force = SCTP_NOFORCE();\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands );\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->autoclose) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* If this is the last chunk in a packet, we need to count it\n\t * toward sack generation.  Note that we need to SACK every\n\t * OTHER packet containing data chunks, EVEN IF WE DISCARD\n\t * THEM.  We elect to NOT generate SACK's if the chunk fails\n\t * the verification tag test.\n\t *\n\t * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * The SCTP endpoint MUST always acknowledge the reception of\n\t * each valid DATA chunk.\n\t *\n\t * The guidelines on delayed acknowledgement algorithm\n\t * specified in  Section 4.2 of [RFC2581] SHOULD be followed.\n\t * Specifically, an acknowledgement SHOULD be generated for at\n\t * least every second packet (not every second DATA chunk)\n\t * received, and SHOULD be generated within 200 ms of the\n\t * arrival of any unacknowledged DATA chunk.  In some\n\t * situations it may be beneficial for an SCTP transmitter to\n\t * be more conservative than the algorithms detailed in this\n\t * document allow. However, an SCTP transmitter MUST NOT be\n\t * more aggressive than the following algorithms allow.\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * When a packet arrives with duplicate DATA chunk(s) and with\n\t * no new DATA chunk(s), the endpoint MUST immediately send a\n\t * SACK with no delay.  If a packet arrives with duplicate\n\t * DATA chunk(s) bundled with new DATA chunks, the endpoint\n\t * MAY immediately send a SACK.  Normally receipt of duplicate\n\t * DATA chunks will occur when the original SACK chunk was lost\n\t * and the peer's RTO has expired.  The duplicate TSN number(s)\n\t * SHOULD be reported in the SACK as duplicate.\n\t */\n\t/* In our case, we split the MAY SACK advice up whether or not\n\t * the last chunk is a duplicate.'\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n\n}\n\n/*\n * sctp_sf_eat_data_fast_4_4\n *\n * Section: 4 (4)\n * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received\n *    DATA chunks without delay.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_fast_4_4(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands );\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Go a head and force a SACK, since we are shutting down. */\n\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tif (chunk->end_of_packet) {\n\t\t/* We must delay the chunk creation since the cumulative\n\t\t * TSN has not been updated yet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Processing a Received SACK\n * D) Any time a SACK arrives, the endpoint performs the following:\n *\n *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,\n *     then drop the SACK.   Since Cumulative TSN Ack is monotonically\n *     increasing, a SACK whose Cumulative TSN Ack is less than the\n *     Cumulative TSN Ack Point indicates an out-of-order SACK.\n *\n *     ii) Set rwnd equal to the newly received a_rwnd minus the number\n *     of bytes still outstanding after processing the Cumulative TSN Ack\n *     and the Gap Ack Blocks.\n *\n *     iii) If the SACK is missing a TSN that was previously\n *     acknowledged via a Gap Ack Block (e.g., the data receiver\n *     reneged on the data), then mark the corresponding DATA chunk\n *     as available for retransmit:  Mark it as missing for fast\n *     retransmit as described in Section 7.2.4 and if no retransmit\n *     timer is running for the destination address to which the DATA\n *     chunk was originally transmitted, then T3-rtx is started for\n *     that destination address.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_sackhdr_t *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_sack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Pull the SACK chunk from the data buffer */\n\tsackh = sctp_sm_pull_sack(chunk);\n\t/* Was this a bogus SACK? */\n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t/* i) If Cumulative TSN Ack is less than the Cumulative TSN\n\t *     Ack Point, then drop the SACK.  Since Cumulative TSN\n\t *     Ack is monotonically increasing, a SACK whose\n\t *     Cumulative TSN Ack is less than the Cumulative TSN Ack\n\t *     Point indicates an out-of-order SACK.\n\t */\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* Return this SACK for further processing.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t/* Note: We do the rest of the work on the PROCESS_SACK\n\t * sideeffect.\n\t */\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate an ABORT in response to a packet.\n *\n * Section: 8.4 Handle \"Out of the blue\" Packets, sctpimpguide 2.41\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n *\n * Verification Tag:\n *\n * The return value is the disposition of the chunk.\n*/\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT. The T bit will be set if the asoc\n\t\t * is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, 0);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR\n * event as ULP notification for each cause included in the chunk.\n *\n * API 5.3.1.3 - SCTP_REMOTE_ERROR\n *\n * The return value is the disposition of the chunk.\n*/\nsctp_disposition_t sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an inbound SHUTDOWN ACK.\n *\n * From Section 9.2:\n * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its\n * peer, and remove all record of the association.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* 10.2 H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t/* ...send a SHUTDOWN COMPLETE chunk to its peer, */\n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t/* Do all the commands now (after allocation), so that we\n\t * have consistent state if memory allocation failes\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n\t * stop the T2-shutdown timer,\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t/* ...and remove all record of the association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n */\nsctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an \"Out of the blue\" SHUTDOWN ACK.\n *\n * Section: 8.4 5, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * Inputs\n * (endpoint, asoc, type, arg, commands)\n *\n * Outputs\n * (sctp_disposition_t)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an SHUTDOWN_COMPLETE.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\t\tif (!shut) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(shut))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tshut->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, shut);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\t/* If the chunk length is invalid, we don't want to process\n\t\t * the reset of the packet.\n\t\t */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* We need to discard the rest of the packet to prevent\n\t\t * potential bomming attacks from additional bundled chunks.\n\t\t * This is documented in SCTP Threats ID.\n\t\t */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.\n *\n * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK\n *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the\n *   procedures in section 8.4 SHOULD be followed, in other words it\n *   should be treated as an Out Of The Blue packet.\n *   [This means that we do NOT check the Verification Tag on these\n *   chunks. --piggy ]\n *\n */\nsctp_disposition_t sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Although we do have an association in this case, it corresponds\n\t * to a restarted association. So the packet is treated as an OOTB\n\t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n\t * called with a NULL association.\n\t */\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */\nsctp_disposition_t sctp_sf_do_asconf(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\t__u32\t\t\tserial;\n\tint\t\t\tlength;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\taddr_param = (union sctp_addr_param *)hdr->params;\n\tlength = ntohs(addr_param->p.length);\n\tif (length < sizeof(sctp_paramhdr_t))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)addr_param, commands);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n\t\t\t    (void *)chunk->chunk_end,\n\t\t\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t/* Reset the transport so that we select the correct one\n\t\t * this time around.  This is to make sure that we don't\n\t\t * accidentally use a stale transport that's been removed.\n\t\t */\n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created until we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t        sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport,\n                    commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.3 General rules for address manipulation\n * When building TLV parameters for the ASCONF Chunk that will add or\n * delete IP addresses the D0 to D13 rules should be applied:\n */\nsctp_disposition_t sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t    (sctp_paramhdr_t *)addip_hdr->params,\n\t    (void *)asconf_ack->chunk_end,\n\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack)) {\n\t\t\t/* Successfully processed ASCONF_ACK.  We can\n\t\t\t * release the next asconf if we have one.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_NEXT_ASCONF,\n\t\t\t\t\tSCTP_NULL());\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t}\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP\n *\n * When a FORWARD TSN chunk arrives, the data receiver MUST first update\n * its cumulative TSN point to the value carried in the FORWARD TSN\n * chunk, and then MUST further advance its cumulative TSN point locally\n * if possible.\n * After the above processing, the data receiver MUST stop reporting any\n * missing TSNs earlier than or equal to the new cumulative TSN point.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto discard_noforce;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->autoclose) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nsctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto gen_shutdown;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * SCTP-AUTH Section 6.3 Receiving authenticated chukns\n *\n *    The receiver MUST use the HMAC algorithm indicated in the HMAC\n *    Identifier field.  If this algorithm was not specified by the\n *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk\n *    during association setup, the AUTH chunk and all chunks after it MUST\n *    be discarded and an ERROR chunk SHOULD be sent with the error cause\n *    defined in Section 4.1.\n *\n *    If an endpoint with no shared key receives a Shared Key Identifier\n *    other than 0, it MUST silently discard all authenticated chunks.  If\n *    the endpoint has at least one endpoint pair shared key for the peer,\n *    it MUST use the key specified by the Shared Key Identifier if a\n *    key has been configured for that Shared Key Identifier.  If no\n *    endpoint pair shared key has been configured for that Shared Key\n *    Identifier, all authenticated chunks MUST be silently discarded.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\t__u8 *save_digest;\n\t__u8 *digest;\n\n\t/* Pull in the auth header, so we can do some more verification */\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(struct sctp_authhdr));\n\n\t/* Make sure that we support the HMAC algorithm from the auth\n\t * chunk.\n\t */\n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t/* Make sure that the provided shared key identifier has been\n\t * configured\n\t */\n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id && !sctp_auth_get_shkey(asoc, key_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\n\n\t/* Make sure that the length of the signature matches what\n\t * we expect.\n\t */\n\tsig_len = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_auth_chunk_t);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Now that we've done validation checks, we can compute and\n\t * verify the hmac.  The steps involved are:\n\t *  1. Save the digest from the chunk.\n\t *  2. Zero out the digest in the chunk.\n\t *  3. Compute the new digest\n\t *  4. Compare saved and new digests.\n\t */\n\tdigest = auth_hdr->hmac;\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t(struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\tGFP_ATOMIC);\n\n\t/* Discard the packet if the digests do not match */\n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nsctp_disposition_t sctp_sf_eat_auth(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_ierror_t error;\n\n\t/* Make sure that the peer has AUTH capable */\n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the AUTH chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(net, ep, asoc, type, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t/* Generate the ERROR chunk and discard the rest\n\t\t * of the packet\n\t\t */\n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Fall Through */\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t/* Prevent gcc warnings */\n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEWKEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn -ENOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an unknown chunk.\n *\n * Section: 3.2. Also, 2.1 in the implementor's guide.\n *\n * Chunk Types are encoded such that the highest-order two bits specify\n * the action that must be taken if the processing endpoint does not\n * recognize the Chunk Type.\n *\n * 00 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it.\n *\n * 01 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it, and report the unrecognized\n *      chunk in an 'Unrecognized Chunk Type'.\n *\n * 10 - Skip this chunk and continue processing.\n *\n * 11 - Skip this chunk and continue processing, but report in an ERROR\n *      Chunk using the 'Unrecognized Chunk Type' cause of error.\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_chunkhdr_t *hdr;\n\n\tSCTP_DEBUG_PRINTK(\"Processing the unknown chunk id %d.\\n\", type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t/* Discard the packet.  */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t/* Discard the packet.  */\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\tbreak;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t\tbreak;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the chunk.\n *\n * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2\n * [Too numerous to mention...]\n * Verification Tag: No verification needed.\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tSCTP_DEBUG_PRINTK(\"Chunk %d is discarded\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the whole packet.\n *\n * Section: 8.4 2)\n *\n * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n *    silently discard the OOTB packet and take no further action.\n *\n * Verification Tag: No verification necessary\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_pdiscard(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n/*\n * The other end is violating protocol.\n *\n * Section: Not specified\n * Verification Tag: Not specified\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * We simply tag the chunk as a violation.  The state machine will log\n * the violation and continue.\n */\nsctp_disposition_t sctp_sf_violation(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n/*\n * Common function to handle a protocol violation.\n */\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t\t\t     sizeof(sctp_initack_chunk_t)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a protocol violation when the chunk length is invalid.\n * \"Invalid\" length is identified as smaller than the minimal length a\n * given chunk can be.  For example, a SACK chunk has invalid length\n * if its length is set to be smaller than the size of sctp_sack_chunk_t.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n *\n * Section: Not specified\n * Verification Tag:  Nothing to do\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (reply_msg, msg_up, counters)\n *\n * Generate an  ABORT chunk and terminate the association.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/*\n * Handle a protocol violation when the parameter length is invalid.\n * If the length is smaller than the minimum length of a given parameter,\n * or accumulated length in multi parameters exceeds the end of the chunk,\n * the length is considered as invalid.\n */\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle a protocol violation when the peer trying to advance the\n * cumulative tsn ack to a point beyond the max tsn currently sent.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n */\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/* Handle protocol violation of an invalid chunk bundling.  For example,\n * when we have an association and we receive bundled INIT-ACK, or\n * SHUDOWN-COMPLETE, our peer is clearly violationg the \"MUST NOT bundle\"\n * statement from the specs.  Additionally, there might be an attacker\n * on the path and we may not want to continue this communication.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n/***************************************************************************\n * These are the state functions for handling primitive (Section 10) events.\n ***************************************************************************/\n/*\n * sctp_sf_do_prm_asoc\n *\n * Section: 10.1 ULP-to-SCTP\n * B) Associate\n *\n * Format: ASSOCIATE(local SCTP instance name, destination transport addr,\n * outbound stream count)\n * -> association id [,destination transport addr list] [,outbound stream\n * count]\n *\n * This primitive allows the upper layer to initiate an association to a\n * specific peer endpoint.\n *\n * The peer endpoint shall be specified by one of the transport addresses\n * which defines the endpoint (see Section 1.4).  If the local SCTP\n * instance has not been initialized, the ASSOCIATE is considered an\n * error.\n * [This is not relevant for the kernel implementation since we do all\n * initialization at boot time.  It we hadn't initialized we wouldn't\n * get anywhere near this code.]\n *\n * An association id, which is a local handle to the SCTP association,\n * will be returned on successful establishment of the association. If\n * SCTP is not able to open an SCTP association with the peer endpoint,\n * an error is returned.\n * [In the kernel implementation, the struct sctp_association needs to\n * be created BEFORE causing this primitive to run.]\n *\n * Other association parameters may be returned, including the\n * complete destination transport addresses of the peer as well as the\n * outbound stream count of the local endpoint. One of the transport\n * address from the returned destination addresses will be selected by\n * the local endpoint as default primary path for sending SCTP packets\n * to this peer.  The returned \"destination transport addr list\" can\n * be used by the ULP to change the default primary path or to force\n * sending a packet to a specific transport address.  [All of this\n * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING\n * function.]\n *\n * Mandatory attributes:\n *\n * o local SCTP instance name - obtained from the INITIALIZE operation.\n *   [This is the argument asoc.]\n * o destination transport addr - specified as one of the transport\n * addresses of the peer endpoint with which the association is to be\n * established.\n *  [This is asoc->peer.active_path.]\n * o outbound stream count - the number of outbound streams the ULP\n * would like to open towards this peer endpoint.\n * [BUG: This is not currently implemented.]\n * Optional attributes:\n *\n * None.\n *\n * The return value is a disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association* my_asoc;\n\n\t/* The comment below says that we enter COOKIE-WAIT AFTER\n\t * sending the INIT, but that doesn't actually work in our\n\t * implementation...\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\"\n\t * must provide its Verification Tag (Tag_A) in the Initiate\n\t * Tag field.  Tag_A SHOULD be a random number in the range of\n\t * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...\n\t */\n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t/* Choose transport for INIT. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t/* After sending the INIT, \"A\" starts the T1-init timer and\n\t * enters the COOKIE-WAIT state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the SEND primitive.\n *\n * Section: 10.1 ULP-to-SCTP\n * E) Send\n *\n * Format: SEND(association id, buffer address, byte count [,context]\n *         [,stream id] [,life time] [,destination transport address]\n *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n * -> result\n *\n * This is the main method to send user data via SCTP.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n *  o buffer address - the location where the user message to be\n *    transmitted is stored;\n *\n *  o byte count - The size of the user data in number of bytes;\n *\n * Optional attributes:\n *\n *  o context - an optional 32 bit integer that will be carried in the\n *    sending failure notification to the ULP if the transportation of\n *    this User Message fails.\n *\n *  o stream id - to indicate which stream to send the data on. If not\n *    specified, stream 0 will be used.\n *\n *  o life time - specifies the life time of the user data. The user data\n *    will not be sent by SCTP after the life time expires. This\n *    parameter can be used to avoid efforts to transmit stale\n *    user messages. SCTP notifies the ULP if the data cannot be\n *    initiated to transport (i.e. sent to the destination via SCTP's\n *    send primitive) within the life time variable. However, the\n *    user data will be transmitted if SCTP has attempted to transmit a\n *    chunk before the life time expired.\n *\n *  o destination transport address - specified as one of the destination\n *    transport addresses of the peer endpoint to which this packet\n *    should be sent. Whenever possible, SCTP should use this destination\n *    transport address for sending the packets, instead of the current\n *    primary path.\n *\n *  o unorder flag - this flag, if present, indicates that the user\n *    would like the data delivered in an unordered fashion to the peer\n *    (i.e., the U flag is set to 1 on all DATA chunks carrying this\n *    message).\n *\n *  o no-bundle flag - instructs SCTP not to bundle this user data with\n *    other outbound DATA chunks. SCTP MAY still bundle even when\n *    this flag is present, when faced with network congestion.\n *\n *  o payload protocol-id - A 32 bit unsigned integer that is to be\n *    passed to the peer indicating the type of payload protocol data\n *    being transmitted. This value is passed as opaque data by SCTP.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process the SHUTDOWN primitive.\n *\n * Section: 10.1:\n * C) Shutdown\n *\n * Format: SHUTDOWN(association id)\n * -> result\n *\n * Gracefully closes an association. Any locally queued user data\n * will be delivered to the peer. The association will be terminated only\n * after the peer acknowledges all the SCTP packets sent.  A success code\n * will be returned on successful termination of the association. If\n * attempting to terminate the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*\n * Process the ABORT primitive.\n *\n * Section: 10.1:\n * C) Abort\n *\n * Format: Abort(association id [, cause code])\n * -> result\n *\n * Ungracefully closes an association. Any locally queued user data\n * will be discarded and an ABORT chunk is sent to the peer.  A success code\n * will be returned on successful abortion of the association. If\n * attempting to abort the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n *  o cause code - reason of the abort to be passed to the peer\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_1_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn retval;\n}\n\n/* We tried an illegal operation on an association which is closed.  */\nsctp_disposition_t sctp_sf_error_closed(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* We tried an illegal operation on an association which is shutting\n * down.\n */\nsctp_disposition_t sctp_sf_error_shutdown(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_cookie_wait_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * sctp_cookie_echoed_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_wait_prm_abort\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\t/* Stop T1-init timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn retval;\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Section: 4 Note: 3\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_pending_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-PENDING state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_pending_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_sent_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-SENT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process the REQUESTHEARTBEAT primitive\n *\n * 10.1 ULP-to-SCTP\n * J) Request Heartbeat\n *\n * Format: REQUESTHEARTBEAT(association id, destination transport address)\n *\n * -> result\n *\n * Instructs the local endpoint to perform a HeartBeat on the specified\n * destination transport address of the given association. The returned\n * result should indicate whether the transmission of the HEARTBEAT\n * chunk to the destination address is successful.\n *\n * Mandatory attributes:\n *\n * o association id - local handle to the SCTP association\n *\n * o destination transport address - the transport address of the\n *   association on which a heartbeat should be issued.\n */\nsctp_disposition_t sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/*\n\t * RFC 2960 (bis), section 8.3\n\t *\n\t *    D) Request an on-demand HEARTBEAT on a specific destination\n\t *    transport address of a given association.\n\t *\n\t *    The endpoint should increment the respective error  counter of\n\t *    the destination transport address each time a HEARTBEAT is sent\n\t *    to that address and not acknowledged within one RTO.\n\t *\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * When an endpoint has an ASCONF signaled change to be sent to the\n * remote endpoint it should do A1 to A9\n */\nsctp_disposition_t sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Ignore the primitive event\n *\n * The return value is the disposition of the primitive.\n */\nsctp_disposition_t sctp_sf_ignore_primitive(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tSCTP_DEBUG_PRINTK(\"Primitive type %d is ignored.\\n\", type.primitive);\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/***************************************************************************\n * These are the state functions for the OTHER events.\n ***************************************************************************/\n\n/*\n * When the SCTP stack has no more user data to send or retransmit, this\n * notification is given to the user. Also, at the time when a user app\n * subscribes to this event, if there is no data to be sent or\n * retransmit, the stack will immediately send up this notification.\n */\nsctp_disposition_t sctp_sf_do_no_pending_tsn(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Start the shutdown negotiation.\n *\n * From Section 9.2:\n * Once all its outstanding data has been acknowledged, the endpoint\n * shall send a SHUTDOWN chunk to its peer including in the Cumulative\n * TSN Ack field the last sequential TSN it has received from the peer.\n * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n * state. If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_start_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t/* Once all its outstanding data has been acknowledged, the\n\t * endpoint shall send a SHUTDOWN chunk to its peer including\n\t * in the Cumulative TSN Ack field the last sequential TSN it\n\t * has received from the peer.\n\t */\n\treply = sctp_make_shutdown(asoc, NULL);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN chunk and the timeout for the\n\t * T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* It shall then start the T2-shutdown timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* RFC 4960 Section 9.2\n\t * The sender of the SHUTDOWN MAY also start an overall guard timer\n\t * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* and enter the SHUTDOWN-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Generate a SHUTDOWN ACK now that everything is SACK'd.\n *\n * From Section 9.2:\n *\n * If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the\n * endpoint must re-send the SHUTDOWN ACK.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t\t  commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->autoclose)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Ignore the event defined as other\n *\n * The return value is the disposition of the event.\n */\nsctp_disposition_t sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tSCTP_DEBUG_PRINTK(\"The event other type %d is ignored\\n\", type.other);\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/************************************************************\n * These are the state functions for handling timeout events.\n ************************************************************/\n\n/*\n * RTX Timeout\n *\n * Section: 6.3.3 Handle T3-rtx Expiration\n *\n * Whenever the retransmission timer T3-rtx expires for a destination\n * address, do the following:\n * [See below]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate delayed SACK on timeout\n *\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated\n * within 200 ms of the arrival of any unacknowledged DATA chunk.  In\n * some situations it may be beneficial for an SCTP transmitter to be\n * more conservative than the algorithms detailed in this document\n * allow. However, an SCTP transmitter MUST NOT be more aggressive than\n * the following algorithms allow.\n */\nsctp_disposition_t sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_init_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT\n *     and re-start the T1-init timer without changing state.  This MUST\n *     be repeated up to 'Max.Init.Retransmits' times.  After that, the\n *     endpoint MUST abort the initialization process and report the\n *     error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_init_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T1 expired (INIT).\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Choose transport for INIT. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tSCTP_DEBUG_PRINTK(\"Giving up on INIT, attempts: %d\"\n\t\t\t\t  \" max_init_attempts: %d\\n\",\n\t\t\t\t  attempts, asoc->max_init_attempts);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_cookie_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  3) If the T1-cookie timer expires, the endpoint MUST retransmit\n *     COOKIE ECHO and re-start the T1-cookie timer without changing\n *     state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n *     After that, the endpoint MUST abort the initialization process and\n *     report the error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_cookie_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T1 expired (COOKIE-ECHO).\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * An endpoint should limit the number of retransmissions of the\n * SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n * If this threshold is exceeded the endpoint should destroy the TCB and\n * MUST report the peer endpoint unreachable to the upper layer (and\n * thus the association enters the CLOSED state).  The reception of any\n * packet from its peer (i.e. as the peer sends all of its queued DATA\n * chunks) should clear the endpoint's retransmission count and restart\n * the T2-Shutdown timer,  giving its peer ample opportunity to transmit\n * all of its queued DATA chunks that have not yet been sent.\n */\nsctp_disposition_t sctp_sf_t2_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T2 expired.\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Do some failure management (Section 8.2).\n\t * If we remove the transport an SHUTDOWN was last sent to, don't\n\t * do failure management.\n\t */\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* Restart the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF CHunk Procedures\n * If the T4 RTO timer expires the endpoint should do B1 to B5\n */\nsctp_disposition_t sctp_sf_t4_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t/* ADDIP 4.1 B1) Increment the error counters and perform path failure\n\t * detection on the appropriate destination address as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t */\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t/* Reconfig T4 timer and transport. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t/* ADDIP 4.1 B2) Increment the association error counters and perform\n\t * endpoint failure detection on the association as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t * association error counter is incremented in SCTP_CMD_STRIKE.\n\t */\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t/* ADDIP 4.1 B3) Back-off the destination address RTO value to which\n\t * the ASCONF chunk was sent by doubling the RTO timer value.\n\t * This is done in SCTP_CMD_STRIKE.\n\t */\n\n\t/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible\n\t * choose an alternate destination address (please refer to RFC2960\n\t * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this\n\t * chunk, it MUST be the same (including its serial number) as the last\n\t * ASCONF sent.\n\t */\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different\n\t * destination is selected, then the RTO used will be that of the new\n\t * destination address.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* sctpimpguide-05 Section 2.12.2\n * The sender of the SHUTDOWN MAY also start an overall guard timer\n * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n * At the expiration of this timer the sender SHOULD abort the association\n * by sending an ABORT chunk.\n */\nsctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tSCTP_DEBUG_PRINTK(\"Timer T5 expired.\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,\n * the association is automatically closed by starting the shutdown process.\n * The work that needs to be done is same as when SHUTDOWN is initiated by\n * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().\n */\nsctp_disposition_t sctp_sf_autoclose_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*****************************************************************************\n * These are sa state functions which could apply to all types of events.\n ****************************************************************************/\n\n/*\n * This table entry is not implemented.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_not_impl(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n/*\n * This table entry represents a bug.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_bug(struct net *net,\n\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t       const struct sctp_association *asoc,\n\t\t\t       const sctp_subtype_t type,\n\t\t\t       void *arg,\n\t\t\t       sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n/*\n * This table entry represents the firing of a timer in the wrong state.\n * Since timer deletion cannot be guaranteed a timer 'may' end up firing\n * when the association is in the wrong state.   This event should\n * be ignored, so as to prevent any rearming of the timer.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tSCTP_DEBUG_PRINTK(\"Timer %d ignored.\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Pull the SACK chunk based on the SACK header. */\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\tunsigned int len;\n\t__u16 num_blocks;\n\t__u16 num_dup_tsns;\n\n\t/* Protect ourselves from reading too far into\n\t * the skb from a bogus sender.\n\t */\n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n/* Create an ABORT packet to be sent as a response, with the specified\n * error causes.\n */\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Add specified error causes, i.e., payload, to the\n\t\t * end of the chunk.\n\t\t */\n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n/* Allocate a packet for responding in the OOTB conditions.  */\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_transport *transport;\n\t__u16 sport;\n\t__u16 dport;\n\t__u32 vtag;\n\n\t/* Get the source and destination port from the inbound packet.  */\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t/* The V-tag is going to be the same as the inbound packet if no\n\t * association exists, otherwise, use the peer's vtag.\n\t */\n\tif (asoc) {\n\t\t/* Special case the INIT-ACK as there is no peer's vtag\n\t\t * yet.\n\t\t */\n\t\tswitch(chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Special case the INIT and stale COOKIE_ECHO as there is no\n\t\t * vtag yet.\n\t\t */\n\t\tswitch(chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tsctp_init_chunk_t *init;\n\n\t\t\tinit = (sctp_init_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make a transport for the bucket, Eliza... */\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\t/* Cache a route for the transport with the chunk's destination as\n\t * the source address.\n\t */\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = sctp_packet_init(&transport->packet, transport, sport, dport);\n\tpacket = sctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n/* Free the packet allocated earlier for responding in the OOTB condition.  */\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t/* Override the OOTB vtag from the cookie. */\n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t/* Set the skb to the belonging sock for accounting. */\n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n/* Process a data chunk */\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tSCTP_DEBUG_PRINTK(\"eat_data: TSN 0x%x.\\n\", tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (!chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\taf = sctp_get_af_specific(\n\t\t\tipver2af(ip_hdr(chunk->skb)->version));\n\n\t\tif (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tSCTP_DEBUG_PRINTK(\"Reneging for tsn:%u\\n\", tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tSCTP_DEBUG_PRINTK(\"Discard tsn: %u len: %Zd, \"\n\t\t\t\t\t  \"rwnd: %d\\n\", tsn, datalen,\n\t\t\t\t\t  asoc->rwnd);\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t           (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tSCTP_DEBUG_PRINTK(\"Under Pressure! Reneging for tsn:%u\\n\", tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n"], "filenames": ["net/sctp/sm_statefuns.c"], "buggy_code_start_loc": [2085], "buggy_code_end_loc": [2086], "fixing_code_start_loc": [2085], "fixing_code_end_loc": [2086], "type": "NVD-CWE-Other", "message": "The sctp_sf_do_5_2_4_dupcook function in net/sctp/sm_statefuns.c in the SCTP implementation in the Linux kernel before 3.8.5 does not properly handle associations during the processing of a duplicate COOKIE ECHO chunk, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via crafted SCTP traffic.", "other": {"cve": {"id": "CVE-2013-2206", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-04T21:55:01.027", "lastModified": "2023-02-13T00:28:30.560", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/476.html\r\n\r\n'CWE-476: NULL Pointer Dereference'", "descriptions": [{"lang": "en", "value": "The sctp_sf_do_5_2_4_dupcook function in net/sctp/sm_statefuns.c in the SCTP implementation in the Linux kernel before 3.8.5 does not properly handle associations during the processing of a duplicate COOKIE ECHO chunk, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via crafted SCTP traffic."}, {"lang": "es", "value": "La funci\u00f3n sctp_sf_do_5_2_4_dupcook en net/sctp/sm_statefuns.c en la implementaci\u00f3n SCTP en el kernel de Linux anterior a v3.8.5 no maneja correctamente asociaciones durante el proceso de duplicaci\u00f3n de COOKIE ECHO chunk, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicios (puntero NULL y ca\u00edda del sistema) o posiblemente tenga otro impacto sin especificar a trav\u00e9s de tr\u00e1fico SCTP."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 5.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.4", "matchCriteriaId": "0D272EF6-C70C-4FC5-98C4-3240045414FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=f2815633504b442ca0b0605c16bf3d88a3a0fcea", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-11/msg00020.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-11/msg00021.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-11/msg00023.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-11/msg00024.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00129.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1166.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1173.html", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2013/dsa-2766", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.5", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/06/21/1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1939-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=976562", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/f2815633504b442ca0b0605c16bf3d88a3a0fcea", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f2815633504b442ca0b0605c16bf3d88a3a0fcea"}}