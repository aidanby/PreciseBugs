{"buggy_code": ["/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * file.h - definitions for file(1) program\n * @(#)$File: file.h,v 1.154 2014/09/10 18:41:51 christos Exp $\n */\n\n#ifndef __file_h__\n#define __file_h__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef WIN32\n  #ifdef _WIN64\n    #define SIZE_T_FORMAT \"I64\"\n  #else\n    #define SIZE_T_FORMAT \"\"\n  #endif\n  #define INT64_T_FORMAT \"I64\"\n#else\n  #define SIZE_T_FORMAT \"z\"\n  #define INT64_T_FORMAT \"ll\"\n#endif\n\n#include <stdio.h>\t/* Include that here, to make sure __P gets defined */\n#include <errno.h>\n#include <fcntl.h>\t/* For open and flags */\n#ifdef HAVE_STDINT_H\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#include <regex.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/param.h>\n/* Do this here and now, because struct stat gets re-defined on solaris */\n#include <sys/stat.h>\n#include <stdarg.h>\n\n#define ENABLE_CONDITIONALS\n\n#ifndef MAGIC\n#define MAGIC \"/etc/magic\"\n#endif\n\n#if defined(__EMX__) || defined (WIN32)\n#define PATHSEP\t';'\n#else\n#define PATHSEP\t':'\n#endif\n\n#define private static\n\n#if HAVE_VISIBILITY && !defined(WIN32)\n#define public  __attribute__ ((__visibility__(\"default\")))\n#ifndef protected\n#define protected __attribute__ ((__visibility__(\"hidden\")))\n#endif\n#else\n#define public\n#ifndef protected\n#define protected\n#endif\n#endif\n\n#ifndef __arraycount\n#define __arraycount(a) (sizeof(a) / sizeof(a[0]))\n#endif\n\n#ifndef __GNUC_PREREQ__\n#ifdef __GNUC__\n#define\t__GNUC_PREREQ__(x, y)\t\t\t\t\t\t\\\n\t((__GNUC__ == (x) && __GNUC_MINOR__ >= (y)) ||\t\t\t\\\n\t (__GNUC__ > (x)))\n#else\n#define\t__GNUC_PREREQ__(x, y)\t0\n#endif\n#endif\n\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(a)\n#endif\n#endif\n\n#ifndef MIN\n#define\tMIN(a,b)\t(((a) < (b)) ? (a) : (b))\n#endif\n\n#ifndef MAX\n#define\tMAX(a,b)\t(((a) > (b)) ? (a) : (b))\n#endif\n\n#ifndef HOWMANY\n# define HOWMANY (256 * 1024)\t/* how much of the file to look at */\n#endif\n#define MAXMAGIS 8192\t\t/* max entries in any one magic file\n\t\t\t\t   or directory */\n#define MAXDESC\t64\t\t/* max len of text description/MIME type */\n#define MAXMIME\t80\t\t/* max len of text MIME type */\n#define MAXstring 64\t\t/* max len of \"string\" types */\n\n#define MAGICNO\t\t0xF11E041C\n#define VERSIONNO\t12\n#define FILE_MAGICSIZE\t248\n\n#define\tFILE_LOAD\t0\n#define FILE_CHECK\t1\n#define FILE_COMPILE\t2\n#define FILE_LIST\t3\n\nunion VALUETYPE {\n\tuint8_t b;\n\tuint16_t h;\n\tuint32_t l;\n\tuint64_t q;\n\tuint8_t hs[2];\t/* 2 bytes of a fixed-endian \"short\" */\n\tuint8_t hl[4];\t/* 4 bytes of a fixed-endian \"long\" */\n\tuint8_t hq[8];\t/* 8 bytes of a fixed-endian \"quad\" */\n\tchar s[MAXstring];\t/* the search string or regex pattern */\n\tunsigned char us[MAXstring];\n\tfloat f;\n\tdouble d;\n};\n\nstruct magic {\n\t/* Word 1 */\n\tuint16_t cont_level;\t/* level of \">\" */\n\tuint8_t flag;\n#define INDIR\t\t0x01\t/* if '(...)' appears */\n#define OFFADD\t\t0x02\t/* if '>&' or '>...(&' appears */\n#define INDIROFFADD\t0x04\t/* if '>&(' appears */\n#define UNSIGNED\t0x08\t/* comparison is unsigned */\n#define NOSPACE\t\t0x10\t/* suppress space character before output */\n#define BINTEST\t\t0x20\t/* test is for a binary type (set only\n\t\t\t\t   for top-level tests) */\n#define TEXTTEST\t0x40\t/* for passing to file_softmagic */\n\n\tuint8_t factor;\n\n\t/* Word 2 */\n\tuint8_t reln;\t\t/* relation (0=eq, '>'=gt, etc) */\n\tuint8_t vallen;\t\t/* length of string value, if any */\n\tuint8_t type;\t\t/* comparison type (FILE_*) */\n\tuint8_t in_type;\t/* type of indirection */\n#define \t\t\tFILE_INVALID\t0\n#define \t\t\tFILE_BYTE\t1\n#define\t\t\t\tFILE_SHORT\t2\n#define\t\t\t\tFILE_DEFAULT\t3\n#define\t\t\t\tFILE_LONG\t4\n#define\t\t\t\tFILE_STRING\t5\n#define\t\t\t\tFILE_DATE\t6\n#define\t\t\t\tFILE_BESHORT\t7\n#define\t\t\t\tFILE_BELONG\t8\n#define\t\t\t\tFILE_BEDATE\t9\n#define\t\t\t\tFILE_LESHORT\t10\n#define\t\t\t\tFILE_LELONG\t11\n#define\t\t\t\tFILE_LEDATE\t12\n#define\t\t\t\tFILE_PSTRING\t13\n#define\t\t\t\tFILE_LDATE\t14\n#define\t\t\t\tFILE_BELDATE\t15\n#define\t\t\t\tFILE_LELDATE\t16\n#define\t\t\t\tFILE_REGEX\t17\n#define\t\t\t\tFILE_BESTRING16\t18\n#define\t\t\t\tFILE_LESTRING16\t19\n#define\t\t\t\tFILE_SEARCH\t20\n#define\t\t\t\tFILE_MEDATE\t21\n#define\t\t\t\tFILE_MELDATE\t22\n#define\t\t\t\tFILE_MELONG\t23\n#define\t\t\t\tFILE_QUAD\t24\n#define\t\t\t\tFILE_LEQUAD\t25\n#define\t\t\t\tFILE_BEQUAD\t26\n#define\t\t\t\tFILE_QDATE\t27\n#define\t\t\t\tFILE_LEQDATE\t28\n#define\t\t\t\tFILE_BEQDATE\t29\n#define\t\t\t\tFILE_QLDATE\t30\n#define\t\t\t\tFILE_LEQLDATE\t31\n#define\t\t\t\tFILE_BEQLDATE\t32\n#define\t\t\t\tFILE_FLOAT\t33\n#define\t\t\t\tFILE_BEFLOAT\t34\n#define\t\t\t\tFILE_LEFLOAT\t35\n#define\t\t\t\tFILE_DOUBLE\t36\n#define\t\t\t\tFILE_BEDOUBLE\t37\n#define\t\t\t\tFILE_LEDOUBLE\t38\n#define\t\t\t\tFILE_BEID3\t39\n#define\t\t\t\tFILE_LEID3\t40\n#define\t\t\t\tFILE_INDIRECT\t41\n#define\t\t\t\tFILE_QWDATE\t42\n#define\t\t\t\tFILE_LEQWDATE\t43\n#define\t\t\t\tFILE_BEQWDATE\t44\n#define\t\t\t\tFILE_NAME\t45\n#define\t\t\t\tFILE_USE\t46\n#define\t\t\t\tFILE_CLEAR\t47\n#define\t\t\t\tFILE_NAMES_SIZE\t48 /* size of array to contain all names */\n\n#define IS_STRING(t) \\\n\t((t) == FILE_STRING || \\\n\t (t) == FILE_PSTRING || \\\n\t (t) == FILE_BESTRING16 || \\\n\t (t) == FILE_LESTRING16 || \\\n\t (t) == FILE_REGEX || \\\n\t (t) == FILE_SEARCH || \\\n\t (t) == FILE_NAME || \\\n\t (t) == FILE_USE)\n\n#define FILE_FMT_NONE 0\n#define FILE_FMT_NUM  1 /* \"cduxXi\" */\n#define FILE_FMT_STR  2 /* \"s\" */\n#define FILE_FMT_QUAD 3 /* \"ll\" */\n#define FILE_FMT_FLOAT 4 /* \"eEfFgG\" */\n#define FILE_FMT_DOUBLE 5 /* \"eEfFgG\" */\n\n\t/* Word 3 */\n\tuint8_t in_op;\t\t/* operator for indirection */\n\tuint8_t mask_op;\t/* operator for mask */\n#ifdef ENABLE_CONDITIONALS\n\tuint8_t cond;\t\t/* conditional type */\n#else\n\tuint8_t dummy;\n#endif\n\tuint8_t factor_op;\n#define\t\tFILE_FACTOR_OP_PLUS\t'+'\n#define\t\tFILE_FACTOR_OP_MINUS\t'-'\n#define\t\tFILE_FACTOR_OP_TIMES\t'*'\n#define\t\tFILE_FACTOR_OP_DIV\t'/'\n#define\t\tFILE_FACTOR_OP_NONE\t'\\0'\n\n#define\t\t\t\tFILE_OPS\t\"&|^+-*/%\"\n#define\t\t\t\tFILE_OPAND\t0\n#define\t\t\t\tFILE_OPOR\t1\n#define\t\t\t\tFILE_OPXOR\t2\n#define\t\t\t\tFILE_OPADD\t3\n#define\t\t\t\tFILE_OPMINUS\t4\n#define\t\t\t\tFILE_OPMULTIPLY\t5\n#define\t\t\t\tFILE_OPDIVIDE\t6\n#define\t\t\t\tFILE_OPMODULO\t7\n#define\t\t\t\tFILE_OPS_MASK\t0x07 /* mask for above ops */\n#define\t\t\t\tFILE_UNUSED_1\t0x08\n#define\t\t\t\tFILE_UNUSED_2\t0x10\n#define\t\t\t\tFILE_UNUSED_3\t0x20\n#define\t\t\t\tFILE_OPINVERSE\t0x40\n#define\t\t\t\tFILE_OPINDIRECT\t0x80\n\n#ifdef ENABLE_CONDITIONALS\n#define\t\t\t\tCOND_NONE\t0\n#define\t\t\t\tCOND_IF\t\t1\n#define\t\t\t\tCOND_ELIF\t2\n#define\t\t\t\tCOND_ELSE\t3\n#endif /* ENABLE_CONDITIONALS */\n\n\t/* Word 4 */\n\tuint32_t offset;\t/* offset to magic number */\n\t/* Word 5 */\n\tint32_t in_offset;\t/* offset from indirection */\n\t/* Word 6 */\n\tuint32_t lineno;\t/* line number in magic file */\n\t/* Word 7,8 */\n\tunion {\n\t\tuint64_t _mask;\t/* for use with numeric and date types */\n\t\tstruct {\n\t\t\tuint32_t _count;\t/* repeat/line count */\n\t\t\tuint32_t _flags;\t/* modifier flags */\n\t\t} _s;\t\t/* for use with string types */\n\t} _u;\n#define num_mask _u._mask\n#define str_range _u._s._count\n#define str_flags _u._s._flags\n\t/* Words 9-16 */\n\tunion VALUETYPE value;\t/* either number or string */\n\t/* Words 17-32 */\n\tchar desc[MAXDESC];\t/* description */\n\t/* Words 33-52 */\n\tchar mimetype[MAXMIME]; /* MIME type */\n\t/* Words 53-54 */\n\tchar apple[8];\n};\n\n#define BIT(A)   (1 << (A))\n#define STRING_COMPACT_WHITESPACE\t\tBIT(0)\n#define STRING_COMPACT_OPTIONAL_WHITESPACE\tBIT(1)\n#define STRING_IGNORE_LOWERCASE\t\t\tBIT(2)\n#define STRING_IGNORE_UPPERCASE\t\t\tBIT(3)\n#define REGEX_OFFSET_START\t\t\tBIT(4)\n#define STRING_TEXTTEST\t\t\t\tBIT(5)\n#define STRING_BINTEST\t\t\t\tBIT(6)\n#define PSTRING_1_BE\t\t\t\tBIT(7)\n#define PSTRING_1_LE\t\t\t\tBIT(7)\n#define PSTRING_2_BE\t\t\t\tBIT(8)\n#define PSTRING_2_LE\t\t\t\tBIT(9)\n#define PSTRING_4_BE\t\t\t\tBIT(10)\n#define PSTRING_4_LE\t\t\t\tBIT(11)\n#define REGEX_LINE_COUNT\t\t\tBIT(11)\n#define PSTRING_LEN\t\\\n    (PSTRING_1_BE|PSTRING_2_LE|PSTRING_2_BE|PSTRING_4_LE|PSTRING_4_BE)\n#define PSTRING_LENGTH_INCLUDES_ITSELF\t\tBIT(12)\n#define\tSTRING_TRIM\t\t\t\tBIT(13)\n#define CHAR_COMPACT_WHITESPACE\t\t\t'W'\n#define CHAR_COMPACT_OPTIONAL_WHITESPACE\t'w'\n#define CHAR_IGNORE_LOWERCASE\t\t\t'c'\n#define CHAR_IGNORE_UPPERCASE\t\t\t'C'\n#define CHAR_REGEX_OFFSET_START\t\t\t's'\n#define CHAR_TEXTTEST\t\t\t\t't'\n#define\tCHAR_TRIM\t\t\t\t'T'\n#define CHAR_BINTEST\t\t\t\t'b'\n#define CHAR_PSTRING_1_BE\t\t\t'B'\n#define CHAR_PSTRING_1_LE\t\t\t'B'\n#define CHAR_PSTRING_2_BE\t\t\t'H'\n#define CHAR_PSTRING_2_LE\t\t\t'h'\n#define CHAR_PSTRING_4_BE\t\t\t'L'\n#define CHAR_PSTRING_4_LE\t\t\t'l'\n#define CHAR_PSTRING_LENGTH_INCLUDES_ITSELF     'J'\n#define STRING_IGNORE_CASE\t\t(STRING_IGNORE_LOWERCASE|STRING_IGNORE_UPPERCASE)\n#define STRING_DEFAULT_RANGE\t\t100\n\n\n/* list of magic entries */\nstruct mlist {\n\tstruct magic *magic;\t\t/* array of magic entries */\n\tuint32_t nmagic;\t\t/* number of entries in array */\n\tvoid *map;\t\t\t/* internal resources used by entry */\n\tstruct mlist *next, *prev;\n};\n\n#ifdef __cplusplus\n#define CAST(T, b)\tstatic_cast<T>(b)\n#define RCAST(T, b)\treinterpret_cast<T>(b)\n#else\n#define CAST(T, b)\t(T)(b)\n#define RCAST(T, b)\t(T)(b)\n#endif\n\nstruct level_info {\n\tint32_t off;\n\tint got_match;\n#ifdef ENABLE_CONDITIONALS\n\tint last_match;\n\tint last_cond;\t/* used for error checking by parse() */\n#endif\n};\n\n#define MAGIC_SETS\t2\n\nstruct magic_set {\n\tstruct mlist *mlist[MAGIC_SETS];\t/* list of regular entries */\n\tstruct cont {\n\t\tsize_t len;\n\t\tstruct level_info *li;\n\t} c;\n\tstruct out {\n\t\tchar *buf;\t\t/* Accumulation buffer */\n\t\tchar *pbuf;\t\t/* Printable buffer */\n\t} o;\n\tuint32_t offset;\n\tint error;\n\tint flags;\t\t\t/* Control magic tests. */\n\tint event_flags;\t\t/* Note things that happened. */\n#define \t\tEVENT_HAD_ERR\t\t0x01\n\tconst char *file;\n\tsize_t line;\t\t\t/* current magic line number */\n\n\t/* data for searches */\n\tstruct {\n\t\tconst char *s;\t\t/* start of search in original source */\n\t\tsize_t s_len;\t\t/* length of search region */\n\t\tsize_t offset;\t\t/* starting offset in source: XXX - should this be off_t? */\n\t\tsize_t rm_len;\t\t/* match length */\n\t} search;\n\n\t/* FIXME: Make the string dynamically allocated so that e.g.\n\t   strings matched in files can be longer than MAXstring */\n\tunion VALUETYPE ms_value;\t/* either number or string */\n};\n\n/* Type for Unicode characters */\ntypedef unsigned long unichar;\n\nstruct stat;\n#define FILE_T_LOCAL\t1\n#define FILE_T_WINDOWS\t2\nprotected const char *file_fmttime(uint64_t, int, char *);\nprotected struct magic_set *file_ms_alloc(int);\nprotected void file_ms_free(struct magic_set *);\nprotected int file_buffer(struct magic_set *, int, const char *, const void *,\n    size_t);\nprotected int file_fsmagic(struct magic_set *, const char *, struct stat *);\nprotected int file_pipe2file(struct magic_set *, int, const void *, size_t);\nprotected int file_vprintf(struct magic_set *, const char *, va_list)\n    __attribute__((__format__(__printf__, 2, 0)));\nprotected size_t file_printedlen(const struct magic_set *);\nprotected int file_replace(struct magic_set *, const char *, const char *);\nprotected int file_printf(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected int file_reset(struct magic_set *);\nprotected int file_tryelf(struct magic_set *, int, const unsigned char *,\n    size_t);\nprotected int file_trycdf(struct magic_set *, int, const unsigned char *,\n    size_t);\n#if HAVE_FORK\nprotected int file_zmagic(struct magic_set *, int, const char *,\n    const unsigned char *, size_t);\n#endif\nprotected int file_ascmagic(struct magic_set *, const unsigned char *, size_t,\n    int);\nprotected int file_ascmagic_with_encoding(struct magic_set *,\n    const unsigned char *, size_t, unichar *, size_t, const char *,\n    const char *, int);\nprotected int file_encoding(struct magic_set *, const unsigned char *, size_t,\n    unichar **, size_t *, const char **, const char **, const char **);\nprotected int file_is_tar(struct magic_set *, const unsigned char *, size_t);\nprotected int file_softmagic(struct magic_set *, const unsigned char *, size_t,\n    size_t, int, int);\nprotected int file_apprentice(struct magic_set *, const char *, int);\nprotected int buffer_apprentice(struct magic_set *, struct magic **,\n    size_t *, size_t);\nprotected int file_magicfind(struct magic_set *, const char *, struct mlist *);\nprotected uint64_t file_signextend(struct magic_set *, struct magic *,\n    uint64_t);\nprotected void file_badread(struct magic_set *);\nprotected void file_badseek(struct magic_set *);\nprotected void file_oomem(struct magic_set *, size_t);\nprotected void file_error(struct magic_set *, int, const char *, ...)\n    __attribute__((__format__(__printf__, 3, 4)));\nprotected void file_magerror(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_magwarn(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_mdump(struct magic *);\nprotected void file_showstr(FILE *, const char *, size_t);\nprotected size_t file_mbswidth(const char *);\nprotected const char *file_getbuffer(struct magic_set *);\nprotected ssize_t sread(int, void *, size_t, int);\nprotected int file_check_mem(struct magic_set *, unsigned int);\nprotected int file_looks_utf8(const unsigned char *, size_t, unichar *,\n    size_t *);\nprotected size_t file_pstring_length_size(const struct magic *);\nprotected size_t file_pstring_get_length(const struct magic *, const char *);\n#ifdef __EMX__\nprotected int file_os2_apptype(struct magic_set *, const char *, const void *,\n    size_t);\n#endif /* __EMX__ */\n\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n#if defined(HAVE_XLOCALE_H)\n#include <xlocale.h>\n#endif\n\ntypedef struct {\n\tconst char *pat;\n#if defined(HAVE_NEWLOCALE) && defined(HAVE_USELOCALE) && defined(HAVE_FREELOCALE)\n#define USE_C_LOCALE\n\tlocale_t old_lc_ctype;\n\tlocale_t c_lc_ctype;\n#endif\n\tint rc;\n\tregex_t rx;\n} file_regex_t;\n\nprotected int file_regcomp(file_regex_t *, const char *, int);\nprotected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,\n    int);\nprotected void file_regfree(file_regex_t *);\nprotected void file_regerror(file_regex_t *, int, struct magic_set *);\n\n#ifndef COMPILE_ONLY\nextern const char *file_names[];\nextern const size_t file_nnames;\n#endif\n\n#ifndef HAVE_STRERROR\nextern int sys_nerr;\nextern char *sys_errlist[];\n#define strerror(e) \\\n\t(((e) >= 0 && (e) < sys_nerr) ? sys_errlist[(e)] : \"Unknown error\")\n#endif\n\n#ifndef HAVE_STRTOUL\n#define strtoul(a, b, c)\tstrtol(a, b, c)\n#endif\n\n#ifndef HAVE_PREAD\nssize_t pread(int, void *, size_t, off_t);\n#endif\n#ifndef HAVE_VASPRINTF\nint vasprintf(char **, const char *, va_list);\n#endif\n#ifndef HAVE_ASPRINTF\nint asprintf(char **, const char *, ...);\n#endif\n\n#ifndef HAVE_STRLCPY\nsize_t strlcpy(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRLCAT\nsize_t strlcat(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRCASESTR\nchar *strcasestr(const char *, const char *);\n#endif\n#ifndef HAVE_GETLINE\nssize_t getline(char **, size_t *, FILE *);\nssize_t getdelim(char **, size_t *, int, FILE *);\n#endif\n#ifndef HAVE_CTIME_R\nchar   *ctime_r(const time_t *, char *);\n#endif\n#ifndef HAVE_ASCTIME_R\nchar   *asctime_r(const struct tm *, char *);\n#endif\n#ifndef HAVE_FMTCHECK\nconst char *fmtcheck(const char *, const char *) \n     __attribute__((__format_arg__(2)));\n#endif\n\n#if defined(HAVE_MMAP) && defined(HAVE_SYS_MMAN_H) && !defined(QUICK)\n#define QUICK\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\n#ifndef __cplusplus\n#if defined(__GNUC__) && (__GNUC__ >= 3)\n#define FILE_RCSID(id) \\\nstatic const char rcsid[] __attribute__((__used__)) = id;\n#else\n#define FILE_RCSID(id) \\\nstatic const char *rcsid(const char *p) { \\\n\treturn rcsid(p = id); \\\n}\n#endif\n#else\n#define FILE_RCSID(id)\n#endif\n\n#endif /* __file_h__ */\n", "/*\n * Copyright (c) Christos Zoulas 2003.\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: funcs.c,v 1.72 2014/05/14 23:15:42 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#if defined(HAVE_WCHAR_H)\n#include <wchar.h>\n#endif\n#if defined(HAVE_WCTYPE_H)\n#include <wctype.h>\n#endif\n#if defined(HAVE_LIMITS_H)\n#include <limits.h>\n#endif\n\n#ifndef SIZE_MAX\n#define SIZE_MAX\t((size_t)~0)\n#endif\n\n/*\n * Like printf, only we append to a buffer.\n */\nprotected int\nfile_vprintf(struct magic_set *ms, const char *fmt, va_list ap)\n{\n\tint len;\n\tchar *buf, *newstr;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn 0;\n\tlen = vasprintf(&buf, fmt, ap);\n\tif (len < 0)\n\t\tgoto out;\n\n\tif (ms->o.buf != NULL) {\n\t\tlen = asprintf(&newstr, \"%s%s\", ms->o.buf, buf);\n\t\tfree(buf);\n\t\tif (len < 0)\n\t\t\tgoto out;\n\t\tfree(ms->o.buf);\n\t\tbuf = newstr;\n\t}\n\tms->o.buf = buf;\n\treturn 0;\nout:\n\tfile_error(ms, errno, \"vasprintf failed\");\n\treturn -1;\n}\n\nprotected int\nfile_printf(struct magic_set *ms, const char *fmt, ...)\n{\n\tint rv;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\trv = file_vprintf(ms, fmt, ap);\n\tva_end(ap);\n\treturn rv;\n}\n\n/*\n * error - print best error message possible\n */\n/*VARARGS*/\n__attribute__((__format__(__printf__, 3, 0)))\nprivate void\nfile_error_core(struct magic_set *ms, int error, const char *f, va_list va,\n    size_t lineno)\n{\n\t/* Only the first error is ok */\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn;\n\tif (lineno != 0) {\n\t\tfree(ms->o.buf);\n\t\tms->o.buf = NULL;\n\t\tfile_printf(ms, \"line %\" SIZE_T_FORMAT \"u: \", lineno);\n\t}\n\tfile_vprintf(ms, f, va);\n\tif (error > 0)\n\t\tfile_printf(ms, \" (%s)\", strerror(error));\n\tms->event_flags |= EVENT_HAD_ERR;\n\tms->error = error;\n}\n\n/*VARARGS*/\nprotected void\nfile_error(struct magic_set *ms, int error, const char *f, ...)\n{\n\tva_list va;\n\tva_start(va, f);\n\tfile_error_core(ms, error, f, va, 0);\n\tva_end(va);\n}\n\n/*\n * Print an error with magic line number.\n */\n/*VARARGS*/\nprotected void\nfile_magerror(struct magic_set *ms, const char *f, ...)\n{\n\tva_list va;\n\tva_start(va, f);\n\tfile_error_core(ms, 0, f, va, ms->line);\n\tva_end(va);\n}\n\nprotected void\nfile_oomem(struct magic_set *ms, size_t len)\n{\n\tfile_error(ms, errno, \"cannot allocate %\" SIZE_T_FORMAT \"u bytes\",\n\t    len);\n}\n\nprotected void\nfile_badseek(struct magic_set *ms)\n{\n\tfile_error(ms, errno, \"error seeking\");\n}\n\nprotected void\nfile_badread(struct magic_set *ms)\n{\n\tfile_error(ms, errno, \"error reading\");\n}\n\n#ifndef COMPILE_ONLY\nprotected int\nfile_buffer(struct magic_set *ms, int fd, const char *inname __attribute__ ((unused)),\n    const void *buf, size_t nb)\n{\n\tint m = 0, rv = 0, looks_text = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tconst unsigned char *ubuf = CAST(const unsigned char *, buf);\n\tunichar *u8buf = NULL;\n\tsize_t ulen;\n\tconst char *code = NULL;\n\tconst char *code_mime = \"binary\";\n\tconst char *type = \"application/octet-stream\";\n\tconst char *def = \"data\";\n\tconst char *ftype = NULL;\n\n\tif (nb == 0) {\n\t\tdef = \"empty\";\n\t\ttype = \"application/x-empty\";\n\t\tgoto simple;\n\t} else if (nb == 1) {\n\t\tdef = \"very short file (no magic)\";\n\t\tgoto simple;\n\t}\n\n\tif ((ms->flags & MAGIC_NO_CHECK_ENCODING) == 0) {\n\t\tlooks_text = file_encoding(ms, ubuf, nb, &u8buf, &ulen,\n\t\t    &code, &code_mime, &ftype);\n\t}\n\n#ifdef __EMX__\n\tif ((ms->flags & MAGIC_NO_CHECK_APPTYPE) == 0 && inname) {\n\t\tswitch (file_os2_apptype(ms, inname, buf, nb)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n#if HAVE_FORK\n\t/* try compression stuff */\n\tif ((ms->flags & MAGIC_NO_CHECK_COMPRESS) == 0)\n\t\tif ((m = file_zmagic(ms, fd, inname, ubuf, nb)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"zmagic %d\\n\", m);\n\t\t\tgoto done_encoding;\n\t\t}\n#endif\n\t/* Check if we have a tar file */\n\tif ((ms->flags & MAGIC_NO_CHECK_TAR) == 0)\n\t\tif ((m = file_is_tar(ms, ubuf, nb)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"tar %d\\n\", m);\n\t\t\tgoto done;\n\t\t}\n\n\t/* Check if we have a CDF file */\n\tif ((ms->flags & MAGIC_NO_CHECK_CDF) == 0)\n\t\tif ((m = file_trycdf(ms, fd, ubuf, nb)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"cdf %d\\n\", m);\n\t\t\tgoto done;\n\t\t}\n\n\t/* try soft magic tests */\n\tif ((ms->flags & MAGIC_NO_CHECK_SOFT) == 0)\n\t\tif ((m = file_softmagic(ms, ubuf, nb, 0, BINTEST,\n\t\t    looks_text)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"softmagic %d\\n\", m);\n#ifdef BUILTIN_ELF\n\t\t\tif ((ms->flags & MAGIC_NO_CHECK_ELF) == 0 && m == 1 &&\n\t\t\t    nb > 5 && fd != -1) {\n\t\t\t\t/*\n\t\t\t\t * We matched something in the file, so this\n\t\t\t\t * *might* be an ELF file, and the file is at\n\t\t\t\t * least 5 bytes long, so if it's an ELF file\n\t\t\t\t * it has at least one byte past the ELF magic\n\t\t\t\t * number - try extracting information from the\n\t\t\t\t * ELF headers that cannot easily * be\n\t\t\t\t * extracted with rules in the magic file.\n\t\t\t\t */\n\t\t\t\tif ((m = file_tryelf(ms, fd, ubuf, nb)) != 0)\n\t\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\t\t(void)fprintf(stderr,\n\t\t\t\t\t\t    \"elf %d\\n\", m);\n\t\t\t}\n#endif\n\t\t\tgoto done;\n\t\t}\n\n\t/* try text properties */\n\tif ((ms->flags & MAGIC_NO_CHECK_TEXT) == 0) {\n\n\t\tif ((m = file_ascmagic(ms, ubuf, nb, looks_text)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"ascmagic %d\\n\", m);\n\t\t\tgoto done;\n\t\t}\n\t}\n\nsimple:\n\t/* give up */\n\tm = 1;\n\tif ((!mime || (mime & MAGIC_MIME_TYPE)) &&\n\t    file_printf(ms, \"%s\", mime ? type : def) == -1) {\n\t    rv = -1;\n\t}\n done:\n\tif ((ms->flags & MAGIC_MIME_ENCODING) != 0) {\n\t\tif (ms->flags & MAGIC_MIME_TYPE)\n\t\t\tif (file_printf(ms, \"; charset=\") == -1)\n\t\t\t\trv = -1;\n\t\tif (file_printf(ms, \"%s\", code_mime) == -1)\n\t\t\trv = -1;\n\t}\n#if HAVE_FORK\n done_encoding:\n#endif\n\tfree(u8buf);\n\tif (rv)\n\t\treturn rv;\n\n\treturn m;\n}\n#endif\n\nprotected int\nfile_reset(struct magic_set *ms)\n{\n\tif (ms->mlist[0] == NULL) {\n\t\tfile_error(ms, 0, \"no magic files loaded\");\n\t\treturn -1;\n\t}\n\tif (ms->o.buf) {\n\t\tfree(ms->o.buf);\n\t\tms->o.buf = NULL;\n\t}\n\tif (ms->o.pbuf) {\n\t\tfree(ms->o.pbuf);\n\t\tms->o.pbuf = NULL;\n\t}\n\tms->event_flags &= ~EVENT_HAD_ERR;\n\tms->error = -1;\n\treturn 0;\n}\n\n#define OCTALIFY(n, o)\t\\\n\t/*LINTED*/ \\\n\t(void)(*(n)++ = '\\\\', \\\n\t*(n)++ = (((uint32_t)*(o) >> 6) & 3) + '0', \\\n\t*(n)++ = (((uint32_t)*(o) >> 3) & 7) + '0', \\\n\t*(n)++ = (((uint32_t)*(o) >> 0) & 7) + '0', \\\n\t(o)++)\n\nprotected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    (size_t)(eop - op), &state);\n\t\t\tif (bytesconsumed == (size_t)(-1) ||\n\t\t\t    bytesconsumed == (size_t)(-2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint((unsigned char)*op)) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n\nprotected int\nfile_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif /* ENABLE_CONDITIONALS */\n\treturn 0;\n}\n\nprotected size_t\nfile_printedlen(const struct magic_set *ms)\n{\n\treturn ms->o.buf == NULL ? 0 : strlen(ms->o.buf);\n}\n\nprotected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(&rx, pat, REG_EXTENDED);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(&rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\nprotected int\nfile_regcomp(file_regex_t *rx, const char *pat, int flags)\n{\n#ifdef USE_C_LOCALE\n\trx->c_lc_ctype = newlocale(LC_CTYPE_MASK, \"C\", 0);\n\tassert(rx->c_lc_ctype != NULL);\n\trx->old_lc_ctype = uselocale(rx->c_lc_ctype);\n\tassert(rx->old_lc_ctype != NULL);\n#endif\n\trx->pat = pat;\n\n\treturn rx->rc = regcomp(&rx->rx, pat, flags);\n}\n\nprotected int\nfile_regexec(file_regex_t *rx, const char *str, size_t nmatch,\n    regmatch_t* pmatch, int eflags)\n{\n\tassert(rx->rc == 0);\n\treturn regexec(&rx->rx, str, nmatch, pmatch, eflags);\n}\n\nprotected void\nfile_regfree(file_regex_t *rx)\n{\n\tif (rx->rc == 0)\n\t\tregfree(&rx->rx);\n#ifdef USE_C_LOCALE\n\t(void)uselocale(rx->old_lc_ctype);\n\tfreelocale(rx->c_lc_ctype);\n#endif\n}\n\nprotected void\nfile_regerror(file_regex_t *rx, int rc, struct magic_set *ms)\n{\n\tchar errmsg[512];\n\n\t(void)regerror(rc, &rx->rx, errmsg, sizeof(errmsg));\n\tfile_magerror(ms, \"regex error %d for `%s', (%s)\", rc, rx->pat,\n\t    errmsg);\n}\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: softmagic.c,v 1.196 2014/11/07 15:24:14 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, struct magic *);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n#define FILE_FMTDEBUG\n#ifdef FILE_FMTDEBUG\n#define F(a, b, c) file_fmtcheck((a), (b), (c), __FILE__, __LINE__)\n\nprivate const char * __attribute__((__format_arg__(3)))\nfile_fmtcheck(struct magic_set *ms, const struct magic *m, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(m->desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %\" SIZE_T_FORMAT \"u: format `%s' does not match\"\n\t\t    \" with `%s'\", file, line, m->desc, def);\n\treturn ptr;\n}\n#else\n#define F(a, b, c) fmtcheck((b)->desc, (c))\n#endif\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n\t\tif (*m->desc) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\tif (print_sep(ms, firstline) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\n\t\tif (print && mprint(ms, m) == -1)\n\t\t\treturn -1;\n\n\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t/* and any continuations that match */\n\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\treturn -1;\n\n\t\twhile (magindex + 1 < nmagic &&\n\t\t    magic[magindex + 1].cont_level != 0) {\n\t\t\tm = &magic[++magindex];\n\t\t\tms->line = m->lineno; /* for messages */\n\n\t\t\tif (cont_level < m->cont_level)\n\t\t\t\tcontinue;\n\t\t\tif (cont_level > m->cont_level) {\n\t\t\t\t/*\n\t\t\t\t * We're at the end of the level\n\t\t\t\t * \"cont_level\" continuations.\n\t\t\t\t */\n\t\t\t\tcont_level = m->cont_level;\n\t\t\t}\n\t\t\tms->offset = m->offset;\n\t\t\tif (m->flag & OFFADD) {\n\t\t\t\tms->offset +=\n\t\t\t\t    ms->c.li[cont_level - 1].off;\n\t\t\t}\n\n#ifdef ENABLE_CONDITIONALS\n\t\t\tif (m->cond == COND_ELSE ||\n\t\t\t    m->cond == COND_ELIF) {\n\t\t\t\tif (ms->c.li[cont_level].last_match == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n\t\t\t    text, flip, recursion_level + 1, printed_something,\n\t\t\t    need_separator, returnval)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tif (m->reln != '!')\n\t\t\t\t\tcontinue;\n\t\t\t\tflush = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t\t*returnval = 1;\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (flush ? 1 : magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 0;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 1;\n#endif\n\t\t\t\tif (m->type == FILE_CLEAR)\n\t\t\t\t\tms->c.li[cont_level].got_match = 0;\n\t\t\t\telse if (ms->c.li[cont_level].got_match) {\n\t\t\t\t\tif (m->type == FILE_DEFAULT)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tms->c.li[cont_level].got_match = 1;\n\t\t\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t\t\t*need_separator = 1;\n\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t*returnval = 1;\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If we are going to print something,\n\t\t\t\t * make sure that we have a separator first.\n\t\t\t\t */\n\t\t\t\tif (*m->desc) {\n\t\t\t\t\tif (!*printed_something) {\n\t\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t\tif (print_sep(ms, firstline)\n\t\t\t\t\t\t    == -1)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * This continuation matched.  Print\n\t\t\t\t * its message, with a blank before it\n\t\t\t\t * if the previous item printed and\n\t\t\t\t * this item isn't empty.\n\t\t\t\t */\n\t\t\t\t/* space if previous printed */\n\t\t\t\tif (*need_separator\n\t\t\t\t    && ((m->flag & NOSPACE) == 0)\n\t\t\t\t    && *m->desc) {\n\t\t\t\t\tif (print &&\n\t\t\t\t\t    file_printf(ms, \" \") == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t*need_separator = 0;\n\t\t\t\t}\n\t\t\t\tif (print && mprint(ms, m) == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t\t\tif (*m->desc)\n\t\t\t\t\t*need_separator = 1;\n\n\t\t\t\t/*\n\t\t\t\t * If we see any continuations\n\t\t\t\t * at a higher level,\n\t\t\t\t * process them.\n\t\t\t\t */\n\t\t\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*printed_something) {\n\t\t\tfirstline = 0;\n\t\t\tif (print)\n\t\t\t\t*returnval = 1;\n\t\t}\n\t\tif ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n\t\t\treturn *returnval; /* don't keep searching */\n\t\t}\n\t}\n\treturn *returnval;  /* This is hit if -k is set or there is no match */\n}\n\nprivate int\ncheck_fmt(struct magic_set *ms, struct magic *m)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\tif (strchr(m->desc, '%') == NULL)\n\t\treturn 0;\n\n\trc = file_regcomp(&rx, \"%[-0-9\\\\.]*s\", REG_EXTENDED|REG_NOSUB);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\trc = file_regexec(&rx, m->desc, 0, 0, 0);\n\t\trv = !rc;\n\t}\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *, size_t);\n\nchar *\nstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *copy;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\tcontinue;\n\tif ((copy = malloc(len + 1)) == NULL)\n\t\treturn NULL;\n\t(void)memcpy(copy, str, len);\n\tcopy[len] = '\\0';\n\treturn copy;\n}\n#endif /* HAVE_STRNDUP */\n\nstatic char *\nprintable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n\nprivate int32_t\nmprint(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t v;\n\tfloat vf;\n\tdouble vd;\n\tint64_t t = 0;\n \tchar buf[128], tbuf[26];\n\tunion VALUETYPE *p = &ms->ms_value;\n\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\tv = file_signextend(ms, m, (uint64_t)p->b);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%d\",\n\t\t\t    (unsigned char)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%d\"),\n\t\t\t    (unsigned char) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(char);\n\t\tbreak;\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\tv = file_signextend(ms, m, (uint64_t)p->h);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\",\n\t\t\t    (unsigned short)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"),\n\t\t\t    (unsigned short) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(short);\n\t\tbreak;\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\tv = file_signextend(ms, m, (uint64_t)p->l);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\", (uint32_t) v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"), (uint32_t) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int32_t);\n  \t\tbreak;\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\tv = file_signextend(ms, m, p->q);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%\" INT64_T_FORMAT \"u\",\n\t\t\t    (unsigned long long)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%\" INT64_T_FORMAT \"u\"),\n\t\t\t    (unsigned long long) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int64_t);\n  \t\tbreak;\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!') {\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\t\treturn -1;\n\t\t\tt = ms->offset + m->vallen;\n\t\t}\n\t\telse {\n\t\t\tchar sbuf[512];\n\t\t\tchar *str = p->s;\n\n\t\t\t/* compute t before we mangle the string? */\n\t\t\tt = ms->offset + strlen(str);\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tstr[strcspn(str, \"\\n\")] = '\\0';\n\n\t\t\tif (m->str_flags & STRING_TRIM) {\n\t\t\t\tchar *last;\n\t\t\t\twhile (isspace((unsigned char)*str))\n\t\t\t\t\tstr++;\n\t\t\t\tlast = str;\n\t\t\t\twhile (*last)\n\t\t\t\t\tlast++;\n\t\t\t\t--last;\n\t\t\t\twhile (isspace((unsigned char)*last))\n\t\t\t\t\tlast--;\n\t\t\t\t*++last = '\\0';\n\t\t\t}\n\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t\t    printable(sbuf, sizeof(sbuf), str)) == -1)\n\t\t\t\treturn -1;\n\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += file_pstring_length_size(m);\n\t\t}\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\tvf = p->f;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vf);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(float);\n  \t\tbreak;\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\tvd = p->d;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vd);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vd) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(double);\n  \t\tbreak;\n\n\tcase FILE_REGEX: {\n\t\tchar *cp;\n\t\tint rval;\n\n\t\tcp = strndup((const char *)ms->search.s, ms->search.rm_len);\n\t\tif (cp == NULL) {\n\t\t\tfile_oomem(ms, ms->search.rm_len);\n\t\t\treturn -1;\n\t\t}\n\t\trval = file_printf(ms, F(ms, m, \"%s\"), cp);\n\t\tfree(cp);\n\n\t\tif (rval == -1)\n\t\t\treturn -1;\n\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + ms->search.rm_len;\n\t\tbreak;\n\t}\n\n\tcase FILE_SEARCH:\n\t  \tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\treturn -1;\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + m->vallen;\n\t\tbreak;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t  \tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"invalid m->type (%d) in mprint()\", m->type);\n\t\treturn -1;\n\t}\n\treturn (int32_t)t;\n}\n\nprivate int32_t\nmoffset(struct magic_set *ms, struct magic *m)\n{\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(char)));\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(short)));\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int32_t)));\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int64_t)));\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!')\n\t\t\treturn ms->offset + m->vallen;\n\t\telse {\n\t\t\tunion VALUETYPE *p = &ms->ms_value;\n\t\t\tuint32_t t;\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tp->s[strcspn(p->s, \"\\n\")] = '\\0';\n\t\t\tt = CAST(uint32_t, (ms->offset + strlen(p->s)));\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += (uint32_t)file_pstring_length_size(m);\n\t\t\treturn t;\n\t\t}\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(float)));\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(double)));\n\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset +\n\t\t\t    ms->search.rm_len));\n\n\tcase FILE_SEARCH:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset + m->vallen));\n\n\tcase FILE_CLEAR:\n\tcase FILE_DEFAULT:\n\tcase FILE_INDIRECT:\n\t\treturn ms->offset;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nprivate int\ncvt_flip(int type, int flip)\n{\n\tif (flip == 0)\n\t\treturn type;\n\tswitch (type) {\n\tcase FILE_BESHORT:\n\t\treturn FILE_LESHORT;\n\tcase FILE_BELONG:\n\t\treturn FILE_LELONG;\n\tcase FILE_BEDATE:\n\t\treturn FILE_LEDATE;\n\tcase FILE_BELDATE:\n\t\treturn FILE_LELDATE;\n\tcase FILE_BEQUAD:\n\t\treturn FILE_LEQUAD;\n\tcase FILE_BEQDATE:\n\t\treturn FILE_LEQDATE;\n\tcase FILE_BEQLDATE:\n\t\treturn FILE_LEQLDATE;\n\tcase FILE_BEQWDATE:\n\t\treturn FILE_LEQWDATE;\n\tcase FILE_LESHORT:\n\t\treturn FILE_BESHORT;\n\tcase FILE_LELONG:\n\t\treturn FILE_BELONG;\n\tcase FILE_LEDATE:\n\t\treturn FILE_BEDATE;\n\tcase FILE_LELDATE:\n\t\treturn FILE_BELDATE;\n\tcase FILE_LEQUAD:\n\t\treturn FILE_BEQUAD;\n\tcase FILE_LEQDATE:\n\t\treturn FILE_BEQDATE;\n\tcase FILE_LEQLDATE:\n\t\treturn FILE_BEQLDATE;\n\tcase FILE_LEQWDATE:\n\t\treturn FILE_BEQWDATE;\n\tcase FILE_BEFLOAT:\n\t\treturn FILE_LEFLOAT;\n\tcase FILE_LEFLOAT:\n\t\treturn FILE_BEFLOAT;\n\tcase FILE_BEDOUBLE:\n\t\treturn FILE_LEDOUBLE;\n\tcase FILE_LEDOUBLE:\n\t\treturn FILE_BEDOUBLE;\n\tdefault:\n\t\treturn type;\n\t}\n}\n#define DO_CVT(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPAND: \\\n\t\t\tp->fld &= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPOR: \\\n\t\t\tp->fld |= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPXOR: \\\n\t\t\tp->fld ^= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMODULO: \\\n\t\t\tp->fld %= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\tif (m->mask_op & FILE_OPINVERSE) \\\n\t\tp->fld = ~p->fld \\\n\nprivate void\ncvt_8(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(b, (uint8_t));\n}\n\nprivate void\ncvt_16(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(h, (uint16_t));\n}\n\nprivate void\ncvt_32(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(l, (uint32_t));\n}\n\nprivate void\ncvt_64(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(q, (uint64_t));\n}\n\n#define DO_CVT2(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\nprivate void\ncvt_float(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(f, (float));\n}\n\nprivate void\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));\n}\n\n/*\n * Convert the byte order of the data we are looking at\n * While we're here, let's apply the mask operation\n * (unless you have a better idea)\n */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tsz = sizeof(p->s) - sz; /* maximum length of string */\n\t\tif (len >= sz) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t * Because we can use one of the bytes of the length\n\t\t\t * after we shifted as NUL termination.\n\t\t\t */ \n\t\t\tlen = sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n\n\nprivate void\nmdebug(uint32_t offset, const char *str, size_t len)\n{\n\t(void) fprintf(stderr, \"mget/%\" SIZE_T_FORMAT \"u @%d: \", len, offset);\n\tfile_showstr(stderr, str, len);\n\t(void) fputc('\\n', stderr);\n\t(void) fputc('\\n', stderr);\n}\n\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (m->str_flags & REGEX_LINE_COUNT) {\n\t\t\t\tlinecnt = m->str_range;\n\t\t\t\tbytecnt = linecnt * 80;\n\t\t\t} else {\n\t\t\t\tlinecnt = 0;\n\t\t\t\tbytecnt = m->str_range;\n\t\t\t}\n\n\t\t\tif (bytecnt == 0)\n\t\t\t\tbytecnt = 8192;\n\t\t\tif (bytecnt > nbytes)\n\t\t\t\tbytecnt = nbytes;\n\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes)\n\t\t\t\tbreak;\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}\n\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\t    SIZE_T_FORMAT \"u, \" \"nbytes=%\" SIZE_T_FORMAT \"u)\\n\",\n\t\t    m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}\n\nprivate uint64_t\nfile_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)\n{\n\t/*\n\t * Convert the source args to unsigned here so that (1) the\n\t * compare will be unsigned as it is in strncmp() and (2) so\n\t * the ctype functions will work correctly without extra\n\t * casting.\n\t */\n\tconst unsigned char *a = (const unsigned char *)s1;\n\tconst unsigned char *b = (const unsigned char *)s2;\n\tuint64_t v;\n\n\t/*\n\t * What we want here is v = strncmp(s1, s2, len),\n\t * but ignoring any nulls.\n\t */\n\tv = 0;\n\tif (0L == flags) { /* normal string: do it fast */\n\t\twhile (len-- > 0)\n\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\tbreak;\n\t}\n\telse { /* combine the others */\n\t\twhile (len-- > 0) {\n\t\t\tif ((flags & STRING_IGNORE_LOWERCASE) &&\n\t\t\t    islower(*a)) {\n\t\t\t\tif ((v = tolower(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_IGNORE_UPPERCASE) &&\n\t\t\t    isupper(*a)) {\n\t\t\t\tif ((v = toupper(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\tif (isspace(*b++)) {\n\t\t\t\t\tif (!isspace(*a))\n\t\t\t\t\t\twhile (isspace(*b))\n\t\t\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\twhile (isspace(*b))\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\t/*\n\t * XXX - The 16-bit string compare probably needs to be done\n\t * differently, especially if the flags are to be supported.\n\t * At the moment, I am unsure.\n\t */\n\tflags = 0;\n\treturn file_strncmp(a, b, len, flags);\n}\n\nprivate int\nmagiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n\t\t\tif (slen + idx > ms->search.s_len)\n\t\t\t\tbreak;\n\n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen,\n\t\t\t    m->str_flags);\n\t\t\tif (v == 0) {\t/* found match */\n\t\t\t\tms->search.offset += idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\t\tconst char *search;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tchar *copy;\n\t\t\tif (slen != 0) {\n\t\t\t    copy = malloc(slen);\n\t\t\t    if (copy == NULL)  {\n\t\t\t\tfile_error(ms, errno,\n\t\t\t\t    \"can't allocate %\" SIZE_T_FORMAT \"u bytes\",\n\t\t\t\t    slen);\n\t\t\t\treturn -1;\n\t\t\t    }\n\t\t\t    memcpy(copy, ms->search.s, slen);\n\t\t\t    copy[--slen] = '\\0';\n\t\t\t    search = copy;\n\t\t\t} else {\n\t\t\t    search = ms->search.s;\n\t\t\t    copy = NULL;\n\t\t\t}\n#else\n\t\t\tsearch = ms->search.s;\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)search,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\tfree(copy);\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n\nprivate int\nhandle_annotation(struct magic_set *ms, struct magic *m)\n{\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"%.8s\", m->apple) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {\n\t\tif (file_printf(ms, \"%s\", m->mimetype) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (ms->flags & MAGIC_MIME)\n\t\treturn 0;\n\tif (firstline)\n\t\treturn 0;\n\t/*\n\t * we found another match\n\t * put a newline and '-' to do some simple formatting\n\t */\n\treturn file_printf(ms, \"\\n- \");\n}\n"], "fixing_code": ["/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * file.h - definitions for file(1) program\n * @(#)$File: file.h,v 1.155 2014/10/11 15:03:16 christos Exp $\n */\n\n#ifndef __file_h__\n#define __file_h__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef WIN32\n  #ifdef _WIN64\n    #define SIZE_T_FORMAT \"I64\"\n  #else\n    #define SIZE_T_FORMAT \"\"\n  #endif\n  #define INT64_T_FORMAT \"I64\"\n#else\n  #define SIZE_T_FORMAT \"z\"\n  #define INT64_T_FORMAT \"ll\"\n#endif\n\n#include <stdio.h>\t/* Include that here, to make sure __P gets defined */\n#include <errno.h>\n#include <fcntl.h>\t/* For open and flags */\n#ifdef HAVE_STDINT_H\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#include <regex.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/param.h>\n/* Do this here and now, because struct stat gets re-defined on solaris */\n#include <sys/stat.h>\n#include <stdarg.h>\n\n#define ENABLE_CONDITIONALS\n\n#ifndef MAGIC\n#define MAGIC \"/etc/magic\"\n#endif\n\n#if defined(__EMX__) || defined (WIN32)\n#define PATHSEP\t';'\n#else\n#define PATHSEP\t':'\n#endif\n\n#define private static\n\n#if HAVE_VISIBILITY && !defined(WIN32)\n#define public  __attribute__ ((__visibility__(\"default\")))\n#ifndef protected\n#define protected __attribute__ ((__visibility__(\"hidden\")))\n#endif\n#else\n#define public\n#ifndef protected\n#define protected\n#endif\n#endif\n\n#ifndef __arraycount\n#define __arraycount(a) (sizeof(a) / sizeof(a[0]))\n#endif\n\n#ifndef __GNUC_PREREQ__\n#ifdef __GNUC__\n#define\t__GNUC_PREREQ__(x, y)\t\t\t\t\t\t\\\n\t((__GNUC__ == (x) && __GNUC_MINOR__ >= (y)) ||\t\t\t\\\n\t (__GNUC__ > (x)))\n#else\n#define\t__GNUC_PREREQ__(x, y)\t0\n#endif\n#endif\n\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(a)\n#endif\n#endif\n\n#ifndef MIN\n#define\tMIN(a,b)\t(((a) < (b)) ? (a) : (b))\n#endif\n\n#ifndef MAX\n#define\tMAX(a,b)\t(((a) > (b)) ? (a) : (b))\n#endif\n\n#ifndef HOWMANY\n# define HOWMANY (256 * 1024)\t/* how much of the file to look at */\n#endif\n#define MAXMAGIS 8192\t\t/* max entries in any one magic file\n\t\t\t\t   or directory */\n#define MAXDESC\t64\t\t/* max len of text description/MIME type */\n#define MAXMIME\t80\t\t/* max len of text MIME type */\n#define MAXstring 64\t\t/* max len of \"string\" types */\n\n#define MAGICNO\t\t0xF11E041C\n#define VERSIONNO\t12\n#define FILE_MAGICSIZE\t248\n\n#define\tFILE_LOAD\t0\n#define FILE_CHECK\t1\n#define FILE_COMPILE\t2\n#define FILE_LIST\t3\n\nunion VALUETYPE {\n\tuint8_t b;\n\tuint16_t h;\n\tuint32_t l;\n\tuint64_t q;\n\tuint8_t hs[2];\t/* 2 bytes of a fixed-endian \"short\" */\n\tuint8_t hl[4];\t/* 4 bytes of a fixed-endian \"long\" */\n\tuint8_t hq[8];\t/* 8 bytes of a fixed-endian \"quad\" */\n\tchar s[MAXstring];\t/* the search string or regex pattern */\n\tunsigned char us[MAXstring];\n\tfloat f;\n\tdouble d;\n};\n\nstruct magic {\n\t/* Word 1 */\n\tuint16_t cont_level;\t/* level of \">\" */\n\tuint8_t flag;\n#define INDIR\t\t0x01\t/* if '(...)' appears */\n#define OFFADD\t\t0x02\t/* if '>&' or '>...(&' appears */\n#define INDIROFFADD\t0x04\t/* if '>&(' appears */\n#define UNSIGNED\t0x08\t/* comparison is unsigned */\n#define NOSPACE\t\t0x10\t/* suppress space character before output */\n#define BINTEST\t\t0x20\t/* test is for a binary type (set only\n\t\t\t\t   for top-level tests) */\n#define TEXTTEST\t0x40\t/* for passing to file_softmagic */\n\n\tuint8_t factor;\n\n\t/* Word 2 */\n\tuint8_t reln;\t\t/* relation (0=eq, '>'=gt, etc) */\n\tuint8_t vallen;\t\t/* length of string value, if any */\n\tuint8_t type;\t\t/* comparison type (FILE_*) */\n\tuint8_t in_type;\t/* type of indirection */\n#define \t\t\tFILE_INVALID\t0\n#define \t\t\tFILE_BYTE\t1\n#define\t\t\t\tFILE_SHORT\t2\n#define\t\t\t\tFILE_DEFAULT\t3\n#define\t\t\t\tFILE_LONG\t4\n#define\t\t\t\tFILE_STRING\t5\n#define\t\t\t\tFILE_DATE\t6\n#define\t\t\t\tFILE_BESHORT\t7\n#define\t\t\t\tFILE_BELONG\t8\n#define\t\t\t\tFILE_BEDATE\t9\n#define\t\t\t\tFILE_LESHORT\t10\n#define\t\t\t\tFILE_LELONG\t11\n#define\t\t\t\tFILE_LEDATE\t12\n#define\t\t\t\tFILE_PSTRING\t13\n#define\t\t\t\tFILE_LDATE\t14\n#define\t\t\t\tFILE_BELDATE\t15\n#define\t\t\t\tFILE_LELDATE\t16\n#define\t\t\t\tFILE_REGEX\t17\n#define\t\t\t\tFILE_BESTRING16\t18\n#define\t\t\t\tFILE_LESTRING16\t19\n#define\t\t\t\tFILE_SEARCH\t20\n#define\t\t\t\tFILE_MEDATE\t21\n#define\t\t\t\tFILE_MELDATE\t22\n#define\t\t\t\tFILE_MELONG\t23\n#define\t\t\t\tFILE_QUAD\t24\n#define\t\t\t\tFILE_LEQUAD\t25\n#define\t\t\t\tFILE_BEQUAD\t26\n#define\t\t\t\tFILE_QDATE\t27\n#define\t\t\t\tFILE_LEQDATE\t28\n#define\t\t\t\tFILE_BEQDATE\t29\n#define\t\t\t\tFILE_QLDATE\t30\n#define\t\t\t\tFILE_LEQLDATE\t31\n#define\t\t\t\tFILE_BEQLDATE\t32\n#define\t\t\t\tFILE_FLOAT\t33\n#define\t\t\t\tFILE_BEFLOAT\t34\n#define\t\t\t\tFILE_LEFLOAT\t35\n#define\t\t\t\tFILE_DOUBLE\t36\n#define\t\t\t\tFILE_BEDOUBLE\t37\n#define\t\t\t\tFILE_LEDOUBLE\t38\n#define\t\t\t\tFILE_BEID3\t39\n#define\t\t\t\tFILE_LEID3\t40\n#define\t\t\t\tFILE_INDIRECT\t41\n#define\t\t\t\tFILE_QWDATE\t42\n#define\t\t\t\tFILE_LEQWDATE\t43\n#define\t\t\t\tFILE_BEQWDATE\t44\n#define\t\t\t\tFILE_NAME\t45\n#define\t\t\t\tFILE_USE\t46\n#define\t\t\t\tFILE_CLEAR\t47\n#define\t\t\t\tFILE_NAMES_SIZE\t48 /* size of array to contain all names */\n\n#define IS_STRING(t) \\\n\t((t) == FILE_STRING || \\\n\t (t) == FILE_PSTRING || \\\n\t (t) == FILE_BESTRING16 || \\\n\t (t) == FILE_LESTRING16 || \\\n\t (t) == FILE_REGEX || \\\n\t (t) == FILE_SEARCH || \\\n\t (t) == FILE_NAME || \\\n\t (t) == FILE_USE)\n\n#define FILE_FMT_NONE 0\n#define FILE_FMT_NUM  1 /* \"cduxXi\" */\n#define FILE_FMT_STR  2 /* \"s\" */\n#define FILE_FMT_QUAD 3 /* \"ll\" */\n#define FILE_FMT_FLOAT 4 /* \"eEfFgG\" */\n#define FILE_FMT_DOUBLE 5 /* \"eEfFgG\" */\n\n\t/* Word 3 */\n\tuint8_t in_op;\t\t/* operator for indirection */\n\tuint8_t mask_op;\t/* operator for mask */\n#ifdef ENABLE_CONDITIONALS\n\tuint8_t cond;\t\t/* conditional type */\n#else\n\tuint8_t dummy;\n#endif\n\tuint8_t factor_op;\n#define\t\tFILE_FACTOR_OP_PLUS\t'+'\n#define\t\tFILE_FACTOR_OP_MINUS\t'-'\n#define\t\tFILE_FACTOR_OP_TIMES\t'*'\n#define\t\tFILE_FACTOR_OP_DIV\t'/'\n#define\t\tFILE_FACTOR_OP_NONE\t'\\0'\n\n#define\t\t\t\tFILE_OPS\t\"&|^+-*/%\"\n#define\t\t\t\tFILE_OPAND\t0\n#define\t\t\t\tFILE_OPOR\t1\n#define\t\t\t\tFILE_OPXOR\t2\n#define\t\t\t\tFILE_OPADD\t3\n#define\t\t\t\tFILE_OPMINUS\t4\n#define\t\t\t\tFILE_OPMULTIPLY\t5\n#define\t\t\t\tFILE_OPDIVIDE\t6\n#define\t\t\t\tFILE_OPMODULO\t7\n#define\t\t\t\tFILE_OPS_MASK\t0x07 /* mask for above ops */\n#define\t\t\t\tFILE_UNUSED_1\t0x08\n#define\t\t\t\tFILE_UNUSED_2\t0x10\n#define\t\t\t\tFILE_UNUSED_3\t0x20\n#define\t\t\t\tFILE_OPINVERSE\t0x40\n#define\t\t\t\tFILE_OPINDIRECT\t0x80\n\n#ifdef ENABLE_CONDITIONALS\n#define\t\t\t\tCOND_NONE\t0\n#define\t\t\t\tCOND_IF\t\t1\n#define\t\t\t\tCOND_ELIF\t2\n#define\t\t\t\tCOND_ELSE\t3\n#endif /* ENABLE_CONDITIONALS */\n\n\t/* Word 4 */\n\tuint32_t offset;\t/* offset to magic number */\n\t/* Word 5 */\n\tint32_t in_offset;\t/* offset from indirection */\n\t/* Word 6 */\n\tuint32_t lineno;\t/* line number in magic file */\n\t/* Word 7,8 */\n\tunion {\n\t\tuint64_t _mask;\t/* for use with numeric and date types */\n\t\tstruct {\n\t\t\tuint32_t _count;\t/* repeat/line count */\n\t\t\tuint32_t _flags;\t/* modifier flags */\n\t\t} _s;\t\t/* for use with string types */\n\t} _u;\n#define num_mask _u._mask\n#define str_range _u._s._count\n#define str_flags _u._s._flags\n\t/* Words 9-16 */\n\tunion VALUETYPE value;\t/* either number or string */\n\t/* Words 17-32 */\n\tchar desc[MAXDESC];\t/* description */\n\t/* Words 33-52 */\n\tchar mimetype[MAXMIME]; /* MIME type */\n\t/* Words 53-54 */\n\tchar apple[8];\n};\n\n#define BIT(A)   (1 << (A))\n#define STRING_COMPACT_WHITESPACE\t\tBIT(0)\n#define STRING_COMPACT_OPTIONAL_WHITESPACE\tBIT(1)\n#define STRING_IGNORE_LOWERCASE\t\t\tBIT(2)\n#define STRING_IGNORE_UPPERCASE\t\t\tBIT(3)\n#define REGEX_OFFSET_START\t\t\tBIT(4)\n#define STRING_TEXTTEST\t\t\t\tBIT(5)\n#define STRING_BINTEST\t\t\t\tBIT(6)\n#define PSTRING_1_BE\t\t\t\tBIT(7)\n#define PSTRING_1_LE\t\t\t\tBIT(7)\n#define PSTRING_2_BE\t\t\t\tBIT(8)\n#define PSTRING_2_LE\t\t\t\tBIT(9)\n#define PSTRING_4_BE\t\t\t\tBIT(10)\n#define PSTRING_4_LE\t\t\t\tBIT(11)\n#define REGEX_LINE_COUNT\t\t\tBIT(11)\n#define PSTRING_LEN\t\\\n    (PSTRING_1_BE|PSTRING_2_LE|PSTRING_2_BE|PSTRING_4_LE|PSTRING_4_BE)\n#define PSTRING_LENGTH_INCLUDES_ITSELF\t\tBIT(12)\n#define\tSTRING_TRIM\t\t\t\tBIT(13)\n#define CHAR_COMPACT_WHITESPACE\t\t\t'W'\n#define CHAR_COMPACT_OPTIONAL_WHITESPACE\t'w'\n#define CHAR_IGNORE_LOWERCASE\t\t\t'c'\n#define CHAR_IGNORE_UPPERCASE\t\t\t'C'\n#define CHAR_REGEX_OFFSET_START\t\t\t's'\n#define CHAR_TEXTTEST\t\t\t\t't'\n#define\tCHAR_TRIM\t\t\t\t'T'\n#define CHAR_BINTEST\t\t\t\t'b'\n#define CHAR_PSTRING_1_BE\t\t\t'B'\n#define CHAR_PSTRING_1_LE\t\t\t'B'\n#define CHAR_PSTRING_2_BE\t\t\t'H'\n#define CHAR_PSTRING_2_LE\t\t\t'h'\n#define CHAR_PSTRING_4_BE\t\t\t'L'\n#define CHAR_PSTRING_4_LE\t\t\t'l'\n#define CHAR_PSTRING_LENGTH_INCLUDES_ITSELF     'J'\n#define STRING_IGNORE_CASE\t\t(STRING_IGNORE_LOWERCASE|STRING_IGNORE_UPPERCASE)\n#define STRING_DEFAULT_RANGE\t\t100\n\n\n/* list of magic entries */\nstruct mlist {\n\tstruct magic *magic;\t\t/* array of magic entries */\n\tuint32_t nmagic;\t\t/* number of entries in array */\n\tvoid *map;\t\t\t/* internal resources used by entry */\n\tstruct mlist *next, *prev;\n};\n\n#ifdef __cplusplus\n#define CAST(T, b)\tstatic_cast<T>(b)\n#define RCAST(T, b)\treinterpret_cast<T>(b)\n#else\n#define CAST(T, b)\t(T)(b)\n#define RCAST(T, b)\t(T)(b)\n#endif\n\nstruct level_info {\n\tint32_t off;\n\tint got_match;\n#ifdef ENABLE_CONDITIONALS\n\tint last_match;\n\tint last_cond;\t/* used for error checking by parse() */\n#endif\n};\n\n#define MAGIC_SETS\t2\n\nstruct magic_set {\n\tstruct mlist *mlist[MAGIC_SETS];\t/* list of regular entries */\n\tstruct cont {\n\t\tsize_t len;\n\t\tstruct level_info *li;\n\t} c;\n\tstruct out {\n\t\tchar *buf;\t\t/* Accumulation buffer */\n\t\tchar *pbuf;\t\t/* Printable buffer */\n\t} o;\n\tuint32_t offset;\n\tint error;\n\tint flags;\t\t\t/* Control magic tests. */\n\tint event_flags;\t\t/* Note things that happened. */\n#define \t\tEVENT_HAD_ERR\t\t0x01\n\tconst char *file;\n\tsize_t line;\t\t\t/* current magic line number */\n\n\t/* data for searches */\n\tstruct {\n\t\tconst char *s;\t\t/* start of search in original source */\n\t\tsize_t s_len;\t\t/* length of search region */\n\t\tsize_t offset;\t\t/* starting offset in source: XXX - should this be off_t? */\n\t\tsize_t rm_len;\t\t/* match length */\n\t} search;\n\n\t/* FIXME: Make the string dynamically allocated so that e.g.\n\t   strings matched in files can be longer than MAXstring */\n\tunion VALUETYPE ms_value;\t/* either number or string */\n};\n\n/* Type for Unicode characters */\ntypedef unsigned long unichar;\n\nstruct stat;\n#define FILE_T_LOCAL\t1\n#define FILE_T_WINDOWS\t2\nprotected const char *file_fmttime(uint64_t, int, char *);\nprotected struct magic_set *file_ms_alloc(int);\nprotected void file_ms_free(struct magic_set *);\nprotected int file_buffer(struct magic_set *, int, const char *, const void *,\n    size_t);\nprotected int file_fsmagic(struct magic_set *, const char *, struct stat *);\nprotected int file_pipe2file(struct magic_set *, int, const void *, size_t);\nprotected int file_vprintf(struct magic_set *, const char *, va_list)\n    __attribute__((__format__(__printf__, 2, 0)));\nprotected size_t file_printedlen(const struct magic_set *);\nprotected int file_replace(struct magic_set *, const char *, const char *);\nprotected int file_printf(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected int file_reset(struct magic_set *);\nprotected int file_tryelf(struct magic_set *, int, const unsigned char *,\n    size_t);\nprotected int file_trycdf(struct magic_set *, int, const unsigned char *,\n    size_t);\n#if HAVE_FORK\nprotected int file_zmagic(struct magic_set *, int, const char *,\n    const unsigned char *, size_t);\n#endif\nprotected int file_ascmagic(struct magic_set *, const unsigned char *, size_t,\n    int);\nprotected int file_ascmagic_with_encoding(struct magic_set *,\n    const unsigned char *, size_t, unichar *, size_t, const char *,\n    const char *, int);\nprotected int file_encoding(struct magic_set *, const unsigned char *, size_t,\n    unichar **, size_t *, const char **, const char **, const char **);\nprotected int file_is_tar(struct magic_set *, const unsigned char *, size_t);\nprotected int file_softmagic(struct magic_set *, const unsigned char *, size_t,\n    size_t, int, int);\nprotected int file_apprentice(struct magic_set *, const char *, int);\nprotected int buffer_apprentice(struct magic_set *, struct magic **,\n    size_t *, size_t);\nprotected int file_magicfind(struct magic_set *, const char *, struct mlist *);\nprotected uint64_t file_signextend(struct magic_set *, struct magic *,\n    uint64_t);\nprotected void file_badread(struct magic_set *);\nprotected void file_badseek(struct magic_set *);\nprotected void file_oomem(struct magic_set *, size_t);\nprotected void file_error(struct magic_set *, int, const char *, ...)\n    __attribute__((__format__(__printf__, 3, 4)));\nprotected void file_magerror(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_magwarn(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_mdump(struct magic *);\nprotected void file_showstr(FILE *, const char *, size_t);\nprotected size_t file_mbswidth(const char *);\nprotected const char *file_getbuffer(struct magic_set *);\nprotected ssize_t sread(int, void *, size_t, int);\nprotected int file_check_mem(struct magic_set *, unsigned int);\nprotected int file_looks_utf8(const unsigned char *, size_t, unichar *,\n    size_t *);\nprotected size_t file_pstring_length_size(const struct magic *);\nprotected size_t file_pstring_get_length(const struct magic *, const char *);\n#ifdef __EMX__\nprotected int file_os2_apptype(struct magic_set *, const char *, const void *,\n    size_t);\n#endif /* __EMX__ */\n\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n#if defined(HAVE_XLOCALE_H)\n#include <xlocale.h>\n#endif\n\ntypedef struct {\n\tconst char *pat;\n#if defined(HAVE_NEWLOCALE) && defined(HAVE_USELOCALE) && defined(HAVE_FREELOCALE)\n#define USE_C_LOCALE\n\tlocale_t old_lc_ctype;\n\tlocale_t c_lc_ctype;\n#endif\n\tint rc;\n\tregex_t rx;\n} file_regex_t;\n\nprotected int file_regcomp(file_regex_t *, const char *, int);\nprotected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,\n    int);\nprotected void file_regfree(file_regex_t *);\nprotected void file_regerror(file_regex_t *, int, struct magic_set *);\n\ntypedef struct {\n\tchar *buf;\n\tuint32_t offset;\n} file_pushbuf_t;\n\nprotected file_pushbuf_t *file_push_buffer(struct magic_set *);\nprotected char  *file_pop_buffer(struct magic_set *, file_pushbuf_t *);\n\n#ifndef COMPILE_ONLY\nextern const char *file_names[];\nextern const size_t file_nnames;\n#endif\n\n#ifndef HAVE_STRERROR\nextern int sys_nerr;\nextern char *sys_errlist[];\n#define strerror(e) \\\n\t(((e) >= 0 && (e) < sys_nerr) ? sys_errlist[(e)] : \"Unknown error\")\n#endif\n\n#ifndef HAVE_STRTOUL\n#define strtoul(a, b, c)\tstrtol(a, b, c)\n#endif\n\n#ifndef HAVE_PREAD\nssize_t pread(int, void *, size_t, off_t);\n#endif\n#ifndef HAVE_VASPRINTF\nint vasprintf(char **, const char *, va_list);\n#endif\n#ifndef HAVE_ASPRINTF\nint asprintf(char **, const char *, ...);\n#endif\n\n#ifndef HAVE_STRLCPY\nsize_t strlcpy(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRLCAT\nsize_t strlcat(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRCASESTR\nchar *strcasestr(const char *, const char *);\n#endif\n#ifndef HAVE_GETLINE\nssize_t getline(char **, size_t *, FILE *);\nssize_t getdelim(char **, size_t *, int, FILE *);\n#endif\n#ifndef HAVE_CTIME_R\nchar   *ctime_r(const time_t *, char *);\n#endif\n#ifndef HAVE_ASCTIME_R\nchar   *asctime_r(const struct tm *, char *);\n#endif\n#ifndef HAVE_FMTCHECK\nconst char *fmtcheck(const char *, const char *) \n     __attribute__((__format_arg__(2)));\n#endif\n\n#if defined(HAVE_MMAP) && defined(HAVE_SYS_MMAN_H) && !defined(QUICK)\n#define QUICK\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\n#ifndef __cplusplus\n#if defined(__GNUC__) && (__GNUC__ >= 3)\n#define FILE_RCSID(id) \\\nstatic const char rcsid[] __attribute__((__used__)) = id;\n#else\n#define FILE_RCSID(id) \\\nstatic const char *rcsid(const char *p) { \\\n\treturn rcsid(p = id); \\\n}\n#endif\n#else\n#define FILE_RCSID(id)\n#endif\n\n#endif /* __file_h__ */\n", "/*\n * Copyright (c) Christos Zoulas 2003.\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: funcs.c,v 1.73 2014/09/10 18:41:51 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#if defined(HAVE_WCHAR_H)\n#include <wchar.h>\n#endif\n#if defined(HAVE_WCTYPE_H)\n#include <wctype.h>\n#endif\n#if defined(HAVE_LIMITS_H)\n#include <limits.h>\n#endif\n\n#ifndef SIZE_MAX\n#define SIZE_MAX\t((size_t)~0)\n#endif\n\n/*\n * Like printf, only we append to a buffer.\n */\nprotected int\nfile_vprintf(struct magic_set *ms, const char *fmt, va_list ap)\n{\n\tint len;\n\tchar *buf, *newstr;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn 0;\n\tlen = vasprintf(&buf, fmt, ap);\n\tif (len < 0)\n\t\tgoto out;\n\n\tif (ms->o.buf != NULL) {\n\t\tlen = asprintf(&newstr, \"%s%s\", ms->o.buf, buf);\n\t\tfree(buf);\n\t\tif (len < 0)\n\t\t\tgoto out;\n\t\tfree(ms->o.buf);\n\t\tbuf = newstr;\n\t}\n\tms->o.buf = buf;\n\treturn 0;\nout:\n\tfile_error(ms, errno, \"vasprintf failed\");\n\treturn -1;\n}\n\nprotected int\nfile_printf(struct magic_set *ms, const char *fmt, ...)\n{\n\tint rv;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\trv = file_vprintf(ms, fmt, ap);\n\tva_end(ap);\n\treturn rv;\n}\n\n/*\n * error - print best error message possible\n */\n/*VARARGS*/\n__attribute__((__format__(__printf__, 3, 0)))\nprivate void\nfile_error_core(struct magic_set *ms, int error, const char *f, va_list va,\n    size_t lineno)\n{\n\t/* Only the first error is ok */\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn;\n\tif (lineno != 0) {\n\t\tfree(ms->o.buf);\n\t\tms->o.buf = NULL;\n\t\tfile_printf(ms, \"line %\" SIZE_T_FORMAT \"u: \", lineno);\n\t}\n\tfile_vprintf(ms, f, va);\n\tif (error > 0)\n\t\tfile_printf(ms, \" (%s)\", strerror(error));\n\tms->event_flags |= EVENT_HAD_ERR;\n\tms->error = error;\n}\n\n/*VARARGS*/\nprotected void\nfile_error(struct magic_set *ms, int error, const char *f, ...)\n{\n\tva_list va;\n\tva_start(va, f);\n\tfile_error_core(ms, error, f, va, 0);\n\tva_end(va);\n}\n\n/*\n * Print an error with magic line number.\n */\n/*VARARGS*/\nprotected void\nfile_magerror(struct magic_set *ms, const char *f, ...)\n{\n\tva_list va;\n\tva_start(va, f);\n\tfile_error_core(ms, 0, f, va, ms->line);\n\tva_end(va);\n}\n\nprotected void\nfile_oomem(struct magic_set *ms, size_t len)\n{\n\tfile_error(ms, errno, \"cannot allocate %\" SIZE_T_FORMAT \"u bytes\",\n\t    len);\n}\n\nprotected void\nfile_badseek(struct magic_set *ms)\n{\n\tfile_error(ms, errno, \"error seeking\");\n}\n\nprotected void\nfile_badread(struct magic_set *ms)\n{\n\tfile_error(ms, errno, \"error reading\");\n}\n\n#ifndef COMPILE_ONLY\nprotected int\nfile_buffer(struct magic_set *ms, int fd, const char *inname __attribute__ ((unused)),\n    const void *buf, size_t nb)\n{\n\tint m = 0, rv = 0, looks_text = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tconst unsigned char *ubuf = CAST(const unsigned char *, buf);\n\tunichar *u8buf = NULL;\n\tsize_t ulen;\n\tconst char *code = NULL;\n\tconst char *code_mime = \"binary\";\n\tconst char *type = \"application/octet-stream\";\n\tconst char *def = \"data\";\n\tconst char *ftype = NULL;\n\n\tif (nb == 0) {\n\t\tdef = \"empty\";\n\t\ttype = \"application/x-empty\";\n\t\tgoto simple;\n\t} else if (nb == 1) {\n\t\tdef = \"very short file (no magic)\";\n\t\tgoto simple;\n\t}\n\n\tif ((ms->flags & MAGIC_NO_CHECK_ENCODING) == 0) {\n\t\tlooks_text = file_encoding(ms, ubuf, nb, &u8buf, &ulen,\n\t\t    &code, &code_mime, &ftype);\n\t}\n\n#ifdef __EMX__\n\tif ((ms->flags & MAGIC_NO_CHECK_APPTYPE) == 0 && inname) {\n\t\tswitch (file_os2_apptype(ms, inname, buf, nb)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n#if HAVE_FORK\n\t/* try compression stuff */\n\tif ((ms->flags & MAGIC_NO_CHECK_COMPRESS) == 0)\n\t\tif ((m = file_zmagic(ms, fd, inname, ubuf, nb)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"zmagic %d\\n\", m);\n\t\t\tgoto done_encoding;\n\t\t}\n#endif\n\t/* Check if we have a tar file */\n\tif ((ms->flags & MAGIC_NO_CHECK_TAR) == 0)\n\t\tif ((m = file_is_tar(ms, ubuf, nb)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"tar %d\\n\", m);\n\t\t\tgoto done;\n\t\t}\n\n\t/* Check if we have a CDF file */\n\tif ((ms->flags & MAGIC_NO_CHECK_CDF) == 0)\n\t\tif ((m = file_trycdf(ms, fd, ubuf, nb)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"cdf %d\\n\", m);\n\t\t\tgoto done;\n\t\t}\n\n\t/* try soft magic tests */\n\tif ((ms->flags & MAGIC_NO_CHECK_SOFT) == 0)\n\t\tif ((m = file_softmagic(ms, ubuf, nb, 0, BINTEST,\n\t\t    looks_text)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"softmagic %d\\n\", m);\n#ifdef BUILTIN_ELF\n\t\t\tif ((ms->flags & MAGIC_NO_CHECK_ELF) == 0 && m == 1 &&\n\t\t\t    nb > 5 && fd != -1) {\n\t\t\t\t/*\n\t\t\t\t * We matched something in the file, so this\n\t\t\t\t * *might* be an ELF file, and the file is at\n\t\t\t\t * least 5 bytes long, so if it's an ELF file\n\t\t\t\t * it has at least one byte past the ELF magic\n\t\t\t\t * number - try extracting information from the\n\t\t\t\t * ELF headers that cannot easily * be\n\t\t\t\t * extracted with rules in the magic file.\n\t\t\t\t */\n\t\t\t\tif ((m = file_tryelf(ms, fd, ubuf, nb)) != 0)\n\t\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\t\t(void)fprintf(stderr,\n\t\t\t\t\t\t    \"elf %d\\n\", m);\n\t\t\t}\n#endif\n\t\t\tgoto done;\n\t\t}\n\n\t/* try text properties */\n\tif ((ms->flags & MAGIC_NO_CHECK_TEXT) == 0) {\n\n\t\tif ((m = file_ascmagic(ms, ubuf, nb, looks_text)) != 0) {\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void)fprintf(stderr, \"ascmagic %d\\n\", m);\n\t\t\tgoto done;\n\t\t}\n\t}\n\nsimple:\n\t/* give up */\n\tm = 1;\n\tif ((!mime || (mime & MAGIC_MIME_TYPE)) &&\n\t    file_printf(ms, \"%s\", mime ? type : def) == -1) {\n\t    rv = -1;\n\t}\n done:\n\tif ((ms->flags & MAGIC_MIME_ENCODING) != 0) {\n\t\tif (ms->flags & MAGIC_MIME_TYPE)\n\t\t\tif (file_printf(ms, \"; charset=\") == -1)\n\t\t\t\trv = -1;\n\t\tif (file_printf(ms, \"%s\", code_mime) == -1)\n\t\t\trv = -1;\n\t}\n#if HAVE_FORK\n done_encoding:\n#endif\n\tfree(u8buf);\n\tif (rv)\n\t\treturn rv;\n\n\treturn m;\n}\n#endif\n\nprotected int\nfile_reset(struct magic_set *ms)\n{\n\tif (ms->mlist[0] == NULL) {\n\t\tfile_error(ms, 0, \"no magic files loaded\");\n\t\treturn -1;\n\t}\n\tif (ms->o.buf) {\n\t\tfree(ms->o.buf);\n\t\tms->o.buf = NULL;\n\t}\n\tif (ms->o.pbuf) {\n\t\tfree(ms->o.pbuf);\n\t\tms->o.pbuf = NULL;\n\t}\n\tms->event_flags &= ~EVENT_HAD_ERR;\n\tms->error = -1;\n\treturn 0;\n}\n\n#define OCTALIFY(n, o)\t\\\n\t/*LINTED*/ \\\n\t(void)(*(n)++ = '\\\\', \\\n\t*(n)++ = (((uint32_t)*(o) >> 6) & 3) + '0', \\\n\t*(n)++ = (((uint32_t)*(o) >> 3) & 7) + '0', \\\n\t*(n)++ = (((uint32_t)*(o) >> 0) & 7) + '0', \\\n\t(o)++)\n\nprotected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    (size_t)(eop - op), &state);\n\t\t\tif (bytesconsumed == (size_t)(-1) ||\n\t\t\t    bytesconsumed == (size_t)(-2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint((unsigned char)*op)) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n\nprotected int\nfile_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif /* ENABLE_CONDITIONALS */\n\treturn 0;\n}\n\nprotected size_t\nfile_printedlen(const struct magic_set *ms)\n{\n\treturn ms->o.buf == NULL ? 0 : strlen(ms->o.buf);\n}\n\nprotected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(&rx, pat, REG_EXTENDED);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(&rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\nprotected int\nfile_regcomp(file_regex_t *rx, const char *pat, int flags)\n{\n#ifdef USE_C_LOCALE\n\trx->c_lc_ctype = newlocale(LC_CTYPE_MASK, \"C\", 0);\n\tassert(rx->c_lc_ctype != NULL);\n\trx->old_lc_ctype = uselocale(rx->c_lc_ctype);\n\tassert(rx->old_lc_ctype != NULL);\n#endif\n\trx->pat = pat;\n\n\treturn rx->rc = regcomp(&rx->rx, pat, flags);\n}\n\nprotected int\nfile_regexec(file_regex_t *rx, const char *str, size_t nmatch,\n    regmatch_t* pmatch, int eflags)\n{\n\tassert(rx->rc == 0);\n\treturn regexec(&rx->rx, str, nmatch, pmatch, eflags);\n}\n\nprotected void\nfile_regfree(file_regex_t *rx)\n{\n\tif (rx->rc == 0)\n\t\tregfree(&rx->rx);\n#ifdef USE_C_LOCALE\n\t(void)uselocale(rx->old_lc_ctype);\n\tfreelocale(rx->c_lc_ctype);\n#endif\n}\n\nprotected void\nfile_regerror(file_regex_t *rx, int rc, struct magic_set *ms)\n{\n\tchar errmsg[512];\n\n\t(void)regerror(rc, &rx->rx, errmsg, sizeof(errmsg));\n\tfile_magerror(ms, \"regex error %d for `%s', (%s)\", rc, rx->pat,\n\t    errmsg);\n}\n\nprotected file_pushbuf_t *\nfile_push_buffer(struct magic_set *ms)\n{\n\tfile_pushbuf_t *pb;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)\n\t\treturn NULL;\n\n\tpb->buf = ms->o.buf;\n\tpb->offset = ms->offset;\n\n\tms->o.buf = NULL;\n\tms->offset = 0;\n\n\treturn pb;\n}\n\nprotected char *\nfile_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)\n{\n\tchar *rbuf;\n\n\tif (ms->event_flags & EVENT_HAD_ERR) {\n\t\tfree(pb->buf);\n\t\tfree(pb);\n\t\treturn NULL;\n\t}\n\n\trbuf = ms->o.buf;\n\n\tms->o.buf = pb->buf;\n\tms->offset = pb->offset;\n\n\tfree(pb);\n\treturn rbuf;\n}\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: softmagic.c,v 1.197 2014/11/11 17:48:23 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, struct magic *);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n\n#define MAX_RECURSION_LEVEL\t10\n\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n#define FILE_FMTDEBUG\n#ifdef FILE_FMTDEBUG\n#define F(a, b, c) file_fmtcheck((a), (b), (c), __FILE__, __LINE__)\n\nprivate const char * __attribute__((__format_arg__(3)))\nfile_fmtcheck(struct magic_set *ms, const struct magic *m, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(m->desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %\" SIZE_T_FORMAT \"u: format `%s' does not match\"\n\t\t    \" with `%s'\", file, line, m->desc, def);\n\treturn ptr;\n}\n#else\n#define F(a, b, c) fmtcheck((b)->desc, (c))\n#endif\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n\t\tif (*m->desc) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\tif (print_sep(ms, firstline) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\n\t\tif (print && mprint(ms, m) == -1)\n\t\t\treturn -1;\n\n\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t/* and any continuations that match */\n\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\treturn -1;\n\n\t\twhile (magindex + 1 < nmagic &&\n\t\t    magic[magindex + 1].cont_level != 0) {\n\t\t\tm = &magic[++magindex];\n\t\t\tms->line = m->lineno; /* for messages */\n\n\t\t\tif (cont_level < m->cont_level)\n\t\t\t\tcontinue;\n\t\t\tif (cont_level > m->cont_level) {\n\t\t\t\t/*\n\t\t\t\t * We're at the end of the level\n\t\t\t\t * \"cont_level\" continuations.\n\t\t\t\t */\n\t\t\t\tcont_level = m->cont_level;\n\t\t\t}\n\t\t\tms->offset = m->offset;\n\t\t\tif (m->flag & OFFADD) {\n\t\t\t\tms->offset +=\n\t\t\t\t    ms->c.li[cont_level - 1].off;\n\t\t\t}\n\n#ifdef ENABLE_CONDITIONALS\n\t\t\tif (m->cond == COND_ELSE ||\n\t\t\t    m->cond == COND_ELIF) {\n\t\t\t\tif (ms->c.li[cont_level].last_match == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n\t\t\t    text, flip, recursion_level + 1, printed_something,\n\t\t\t    need_separator, returnval)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tif (m->reln != '!')\n\t\t\t\t\tcontinue;\n\t\t\t\tflush = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t\t*returnval = 1;\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (flush ? 1 : magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 0;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 1;\n#endif\n\t\t\t\tif (m->type == FILE_CLEAR)\n\t\t\t\t\tms->c.li[cont_level].got_match = 0;\n\t\t\t\telse if (ms->c.li[cont_level].got_match) {\n\t\t\t\t\tif (m->type == FILE_DEFAULT)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tms->c.li[cont_level].got_match = 1;\n\t\t\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t\t\t*need_separator = 1;\n\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t*returnval = 1;\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If we are going to print something,\n\t\t\t\t * make sure that we have a separator first.\n\t\t\t\t */\n\t\t\t\tif (*m->desc) {\n\t\t\t\t\tif (!*printed_something) {\n\t\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t\tif (print_sep(ms, firstline)\n\t\t\t\t\t\t    == -1)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * This continuation matched.  Print\n\t\t\t\t * its message, with a blank before it\n\t\t\t\t * if the previous item printed and\n\t\t\t\t * this item isn't empty.\n\t\t\t\t */\n\t\t\t\t/* space if previous printed */\n\t\t\t\tif (*need_separator\n\t\t\t\t    && ((m->flag & NOSPACE) == 0)\n\t\t\t\t    && *m->desc) {\n\t\t\t\t\tif (print &&\n\t\t\t\t\t    file_printf(ms, \" \") == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t*need_separator = 0;\n\t\t\t\t}\n\t\t\t\tif (print && mprint(ms, m) == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t\t\tif (*m->desc)\n\t\t\t\t\t*need_separator = 1;\n\n\t\t\t\t/*\n\t\t\t\t * If we see any continuations\n\t\t\t\t * at a higher level,\n\t\t\t\t * process them.\n\t\t\t\t */\n\t\t\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*printed_something) {\n\t\t\tfirstline = 0;\n\t\t\tif (print)\n\t\t\t\t*returnval = 1;\n\t\t}\n\t\tif ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n\t\t\treturn *returnval; /* don't keep searching */\n\t\t}\n\t}\n\treturn *returnval;  /* This is hit if -k is set or there is no match */\n}\n\nprivate int\ncheck_fmt(struct magic_set *ms, struct magic *m)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\tif (strchr(m->desc, '%') == NULL)\n\t\treturn 0;\n\n\trc = file_regcomp(&rx, \"%[-0-9\\\\.]*s\", REG_EXTENDED|REG_NOSUB);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\trc = file_regexec(&rx, m->desc, 0, 0, 0);\n\t\trv = !rc;\n\t}\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *, size_t);\n\nchar *\nstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *copy;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\tcontinue;\n\tif ((copy = malloc(len + 1)) == NULL)\n\t\treturn NULL;\n\t(void)memcpy(copy, str, len);\n\tcopy[len] = '\\0';\n\treturn copy;\n}\n#endif /* HAVE_STRNDUP */\n\nstatic char *\nprintable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n\nprivate int32_t\nmprint(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t v;\n\tfloat vf;\n\tdouble vd;\n\tint64_t t = 0;\n \tchar buf[128], tbuf[26];\n\tunion VALUETYPE *p = &ms->ms_value;\n\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\tv = file_signextend(ms, m, (uint64_t)p->b);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%d\",\n\t\t\t    (unsigned char)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%d\"),\n\t\t\t    (unsigned char) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(char);\n\t\tbreak;\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\tv = file_signextend(ms, m, (uint64_t)p->h);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\",\n\t\t\t    (unsigned short)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"),\n\t\t\t    (unsigned short) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(short);\n\t\tbreak;\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\tv = file_signextend(ms, m, (uint64_t)p->l);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\", (uint32_t) v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"), (uint32_t) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int32_t);\n  \t\tbreak;\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\tv = file_signextend(ms, m, p->q);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%\" INT64_T_FORMAT \"u\",\n\t\t\t    (unsigned long long)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%\" INT64_T_FORMAT \"u\"),\n\t\t\t    (unsigned long long) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int64_t);\n  \t\tbreak;\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!') {\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\t\treturn -1;\n\t\t\tt = ms->offset + m->vallen;\n\t\t}\n\t\telse {\n\t\t\tchar sbuf[512];\n\t\t\tchar *str = p->s;\n\n\t\t\t/* compute t before we mangle the string? */\n\t\t\tt = ms->offset + strlen(str);\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tstr[strcspn(str, \"\\n\")] = '\\0';\n\n\t\t\tif (m->str_flags & STRING_TRIM) {\n\t\t\t\tchar *last;\n\t\t\t\twhile (isspace((unsigned char)*str))\n\t\t\t\t\tstr++;\n\t\t\t\tlast = str;\n\t\t\t\twhile (*last)\n\t\t\t\t\tlast++;\n\t\t\t\t--last;\n\t\t\t\twhile (isspace((unsigned char)*last))\n\t\t\t\t\tlast--;\n\t\t\t\t*++last = '\\0';\n\t\t\t}\n\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t\t    printable(sbuf, sizeof(sbuf), str)) == -1)\n\t\t\t\treturn -1;\n\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += file_pstring_length_size(m);\n\t\t}\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\tvf = p->f;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vf);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(float);\n  \t\tbreak;\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\tvd = p->d;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vd);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vd) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(double);\n  \t\tbreak;\n\n\tcase FILE_REGEX: {\n\t\tchar *cp;\n\t\tint rval;\n\n\t\tcp = strndup((const char *)ms->search.s, ms->search.rm_len);\n\t\tif (cp == NULL) {\n\t\t\tfile_oomem(ms, ms->search.rm_len);\n\t\t\treturn -1;\n\t\t}\n\t\trval = file_printf(ms, F(ms, m, \"%s\"), cp);\n\t\tfree(cp);\n\n\t\tif (rval == -1)\n\t\t\treturn -1;\n\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + ms->search.rm_len;\n\t\tbreak;\n\t}\n\n\tcase FILE_SEARCH:\n\t  \tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\treturn -1;\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + m->vallen;\n\t\tbreak;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t  \tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"invalid m->type (%d) in mprint()\", m->type);\n\t\treturn -1;\n\t}\n\treturn (int32_t)t;\n}\n\nprivate int32_t\nmoffset(struct magic_set *ms, struct magic *m)\n{\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(char)));\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(short)));\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int32_t)));\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int64_t)));\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!')\n\t\t\treturn ms->offset + m->vallen;\n\t\telse {\n\t\t\tunion VALUETYPE *p = &ms->ms_value;\n\t\t\tuint32_t t;\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tp->s[strcspn(p->s, \"\\n\")] = '\\0';\n\t\t\tt = CAST(uint32_t, (ms->offset + strlen(p->s)));\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += (uint32_t)file_pstring_length_size(m);\n\t\t\treturn t;\n\t\t}\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(float)));\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(double)));\n\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset +\n\t\t\t    ms->search.rm_len));\n\n\tcase FILE_SEARCH:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset + m->vallen));\n\n\tcase FILE_CLEAR:\n\tcase FILE_DEFAULT:\n\tcase FILE_INDIRECT:\n\t\treturn ms->offset;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nprivate int\ncvt_flip(int type, int flip)\n{\n\tif (flip == 0)\n\t\treturn type;\n\tswitch (type) {\n\tcase FILE_BESHORT:\n\t\treturn FILE_LESHORT;\n\tcase FILE_BELONG:\n\t\treturn FILE_LELONG;\n\tcase FILE_BEDATE:\n\t\treturn FILE_LEDATE;\n\tcase FILE_BELDATE:\n\t\treturn FILE_LELDATE;\n\tcase FILE_BEQUAD:\n\t\treturn FILE_LEQUAD;\n\tcase FILE_BEQDATE:\n\t\treturn FILE_LEQDATE;\n\tcase FILE_BEQLDATE:\n\t\treturn FILE_LEQLDATE;\n\tcase FILE_BEQWDATE:\n\t\treturn FILE_LEQWDATE;\n\tcase FILE_LESHORT:\n\t\treturn FILE_BESHORT;\n\tcase FILE_LELONG:\n\t\treturn FILE_BELONG;\n\tcase FILE_LEDATE:\n\t\treturn FILE_BEDATE;\n\tcase FILE_LELDATE:\n\t\treturn FILE_BELDATE;\n\tcase FILE_LEQUAD:\n\t\treturn FILE_BEQUAD;\n\tcase FILE_LEQDATE:\n\t\treturn FILE_BEQDATE;\n\tcase FILE_LEQLDATE:\n\t\treturn FILE_BEQLDATE;\n\tcase FILE_LEQWDATE:\n\t\treturn FILE_BEQWDATE;\n\tcase FILE_BEFLOAT:\n\t\treturn FILE_LEFLOAT;\n\tcase FILE_LEFLOAT:\n\t\treturn FILE_BEFLOAT;\n\tcase FILE_BEDOUBLE:\n\t\treturn FILE_LEDOUBLE;\n\tcase FILE_LEDOUBLE:\n\t\treturn FILE_BEDOUBLE;\n\tdefault:\n\t\treturn type;\n\t}\n}\n#define DO_CVT(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPAND: \\\n\t\t\tp->fld &= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPOR: \\\n\t\t\tp->fld |= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPXOR: \\\n\t\t\tp->fld ^= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMODULO: \\\n\t\t\tp->fld %= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\tif (m->mask_op & FILE_OPINVERSE) \\\n\t\tp->fld = ~p->fld \\\n\nprivate void\ncvt_8(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(b, (uint8_t));\n}\n\nprivate void\ncvt_16(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(h, (uint16_t));\n}\n\nprivate void\ncvt_32(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(l, (uint32_t));\n}\n\nprivate void\ncvt_64(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(q, (uint64_t));\n}\n\n#define DO_CVT2(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\nprivate void\ncvt_float(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(f, (float));\n}\n\nprivate void\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));\n}\n\n/*\n * Convert the byte order of the data we are looking at\n * While we're here, let's apply the mask operation\n * (unless you have a better idea)\n */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tsz = sizeof(p->s) - sz; /* maximum length of string */\n\t\tif (len >= sz) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t * Because we can use one of the bytes of the length\n\t\t\t * after we shifted as NUL termination.\n\t\t\t */ \n\t\t\tlen = sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n\n\nprivate void\nmdebug(uint32_t offset, const char *str, size_t len)\n{\n\t(void) fprintf(stderr, \"mget/%\" SIZE_T_FORMAT \"u @%d: \", len, offset);\n\tfile_showstr(stderr, str, len);\n\t(void) fputc('\\n', stderr);\n\t(void) fputc('\\n', stderr);\n}\n\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (m->str_flags & REGEX_LINE_COUNT) {\n\t\t\t\tlinecnt = m->str_range;\n\t\t\t\tbytecnt = linecnt * 80;\n\t\t\t} else {\n\t\t\t\tlinecnt = 0;\n\t\t\t\tbytecnt = m->str_range;\n\t\t\t}\n\n\t\t\tif (bytecnt == 0)\n\t\t\t\tbytecnt = 8192;\n\t\t\tif (bytecnt > nbytes)\n\t\t\t\tbytecnt = nbytes;\n\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes)\n\t\t\t\tbreak;\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}\n\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t offset = ms->offset;\n\tuint32_t lhs;\n\tfile_pushbuf_t *pb;\n\tint rv, oneed_separator, in_type;\n\tchar *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= MAX_RECURSION_LEVEL) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\t    SIZE_T_FORMAT \"u, \" \"nbytes=%\" SIZE_T_FORMAT \"u)\\n\",\n\t\t    m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\n\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\treturn -1;\n\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\n\t\trbuf = file_pop_buffer(ms, pb);\n\t\tif (rbuf == NULL)\n\t\t\treturn -1;\n\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\trbuf = m->value.s;\n\t\tif (*rbuf == '^') {\n\t\t\trbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, rbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", rbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}\n\nprivate uint64_t\nfile_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)\n{\n\t/*\n\t * Convert the source args to unsigned here so that (1) the\n\t * compare will be unsigned as it is in strncmp() and (2) so\n\t * the ctype functions will work correctly without extra\n\t * casting.\n\t */\n\tconst unsigned char *a = (const unsigned char *)s1;\n\tconst unsigned char *b = (const unsigned char *)s2;\n\tuint64_t v;\n\n\t/*\n\t * What we want here is v = strncmp(s1, s2, len),\n\t * but ignoring any nulls.\n\t */\n\tv = 0;\n\tif (0L == flags) { /* normal string: do it fast */\n\t\twhile (len-- > 0)\n\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\tbreak;\n\t}\n\telse { /* combine the others */\n\t\twhile (len-- > 0) {\n\t\t\tif ((flags & STRING_IGNORE_LOWERCASE) &&\n\t\t\t    islower(*a)) {\n\t\t\t\tif ((v = tolower(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_IGNORE_UPPERCASE) &&\n\t\t\t    isupper(*a)) {\n\t\t\t\tif ((v = toupper(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\tif (isspace(*b++)) {\n\t\t\t\t\tif (!isspace(*a))\n\t\t\t\t\t\twhile (isspace(*b))\n\t\t\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\twhile (isspace(*b))\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\t/*\n\t * XXX - The 16-bit string compare probably needs to be done\n\t * differently, especially if the flags are to be supported.\n\t * At the moment, I am unsure.\n\t */\n\tflags = 0;\n\treturn file_strncmp(a, b, len, flags);\n}\n\nprivate int\nmagiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n\t\t\tif (slen + idx > ms->search.s_len)\n\t\t\t\tbreak;\n\n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen,\n\t\t\t    m->str_flags);\n\t\t\tif (v == 0) {\t/* found match */\n\t\t\t\tms->search.offset += idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\t\tconst char *search;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tchar *copy;\n\t\t\tif (slen != 0) {\n\t\t\t    copy = malloc(slen);\n\t\t\t    if (copy == NULL)  {\n\t\t\t\tfile_error(ms, errno,\n\t\t\t\t    \"can't allocate %\" SIZE_T_FORMAT \"u bytes\",\n\t\t\t\t    slen);\n\t\t\t\treturn -1;\n\t\t\t    }\n\t\t\t    memcpy(copy, ms->search.s, slen);\n\t\t\t    copy[--slen] = '\\0';\n\t\t\t    search = copy;\n\t\t\t} else {\n\t\t\t    search = ms->search.s;\n\t\t\t    copy = NULL;\n\t\t\t}\n#else\n\t\t\tsearch = ms->search.s;\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)search,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\tfree(copy);\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n\nprivate int\nhandle_annotation(struct magic_set *ms, struct magic *m)\n{\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"%.8s\", m->apple) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {\n\t\tif (file_printf(ms, \"%s\", m->mimetype) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (ms->flags & MAGIC_MIME)\n\t\treturn 0;\n\tif (firstline)\n\t\treturn 0;\n\t/*\n\t * we found another match\n\t * put a newline and '-' to do some simple formatting\n\t */\n\treturn file_printf(ms, \"\\n- \");\n}\n"], "filenames": ["src/file.h", "src/funcs.c", "src/softmagic.c"], "buggy_code_start_loc": [30, 30, 35], "buggy_code_end_loc": [497, 493, 1709], "fixing_code_start_loc": [30, 30, 35], "fixing_code_end_loc": [506, 534, 1717], "type": "CWE-399", "message": "softmagic.c in file before 5.21 does not properly limit recursion, which allows remote attackers to cause a denial of service (CPU consumption or crash) via unspecified vectors.", "other": {"cve": {"id": "CVE-2014-8117", "sourceIdentifier": "secalert@redhat.com", "published": "2014-12-17T19:59:05.353", "lastModified": "2018-01-05T02:29:54.103", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "softmagic.c in file before 5.21 does not properly limit recursion, which allows remote attackers to cause a denial of service (CPU consumption or crash) via unspecified vectors."}, {"lang": "es", "value": "softmagic.c en archivo anterior a 5.21 no limita adecuadamente el l\u00edmite de recursividad, esto permite a atacantes remotos, provocar una denegaci\u00f3n de servicio (consumo de CPU o rotura) mediante vectores no especificados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:file_project:file:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.20", "matchCriteriaId": "3E2E14D1-CD34-4C5F-AE83-A6C639BD5BC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:freebsd:freebsd:*:*:*:*:*:*:*:*", "matchCriteriaId": "D9EC02F3-3905-460D-8949-3B26394215CA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:mageia:mageia:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "F805A106-9A6F-48E7-8582-D3C5A26DFC11"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:lts:*:*:*", "matchCriteriaId": "5D37DF0F-F863-45AC-853A-3E04F9FEC7CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2015-0040.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0760.html", "source": "secalert@redhat.com"}, {"url": "http://seclists.org/oss-sec/2014/q4/1056", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://secunia.com/advisories/61944", "source": "secalert@redhat.com"}, {"url": "http://secunia.com/advisories/62081", "source": "secalert@redhat.com"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "secalert@redhat.com"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2015-2719645.html", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/71692", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1031344", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2494-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2535-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/file/file/blob/00cef282a902a4a6709bbbbb933ee397768caa38/ChangeLog", "source": "secalert@redhat.com", "tags": ["Patch", "Issue Tracking"]}, {"url": "https://github.com/file/file/commit/6f737ddfadb596d7d4a993f7ed2141ffd664a81c", "source": "secalert@redhat.com", "tags": ["Patch", "Issue Tracking"]}, {"url": "https://www.freebsd.org/security/advisories/FreeBSD-SA-14:28.file.asc", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/file/file/commit/6f737ddfadb596d7d4a993f7ed2141ffd664a81c"}}