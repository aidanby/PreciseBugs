{"buggy_code": ["import vyper\n\n\ndef test_basic_init_function(get_contract):\n    code = \"\"\"\nval: public(uint256)\n\n@external\ndef __init__(a: uint256):\n    self.val = a\n    \"\"\"\n\n    c = get_contract(code, *[123])\n\n    assert c.val() == 123\n\n    # Make sure the init code does not access calldata\n    opcodes = vyper.compile_code(code, [\"opcodes\"])[\"opcodes\"].split(\" \")\n    ir_return_idx = opcodes.index(\"JUMP\")\n\n    assert \"CALLDATALOAD\" in opcodes\n    assert \"CALLDATACOPY\" not in opcodes[:ir_return_idx]\n    assert \"CALLDATALOAD\" not in opcodes[:ir_return_idx]\n\n\ndef test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):\n    code = \"\"\"\nfoo: public(uint8)\n@internal\ndef bar(x: uint256) -> uint8:\n    return convert(x, uint8) * 7\n@external\ndef __init__(a: uint256):\n    self.foo = self.bar(a)\n\n@external\ndef baz() -> uint8:\n    return self.bar(convert(self.foo, uint256))\n    \"\"\"\n    n = 5\n    c = get_contract(code, n)\n    assert c.foo() == n * 7\n    assert c.baz() == 245  # 5*7*7\n\n    n = 6\n    c = get_contract(code, n)\n    assert c.foo() == n * 7\n    assert_tx_failed(lambda: c.baz())\n\n    n = 255\n    assert_compile_failed(lambda: get_contract(code, n))\n\n    n = 256\n    assert_compile_failed(lambda: get_contract(code, n))\n", "from typing import Any, List\n\nimport vyper.utils as util\nfrom vyper.address_space import CALLDATA, DATA, MEMORY\nfrom vyper.ast.signatures.function_signature import FunctionSignature\nfrom vyper.codegen.abi_encoder import abi_encoding_matches_vyper\nfrom vyper.codegen.context import Context, VariableRecord\nfrom vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp\nfrom vyper.codegen.expr import Expr\nfrom vyper.codegen.function_definitions.utils import get_nonreentrant_lock\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.codegen.stmt import parse_body\nfrom vyper.semantics.types import TupleT\n\n\n# register function args with the local calling context.\n# also allocate the ones that live in memory (i.e. kwargs)\ndef _register_function_args(context: Context, sig: FunctionSignature) -> List[IRnode]:\n    ret = []\n\n    # the type of the calldata\n    base_args_t = TupleT(tuple(arg.typ for arg in sig.base_args))\n\n    # tuple with the abi_encoded args\n    if sig.is_init_func:\n        base_args_ofst = IRnode(0, location=DATA, typ=base_args_t, encoding=Encoding.ABI)\n    else:\n        base_args_ofst = IRnode(4, location=CALLDATA, typ=base_args_t, encoding=Encoding.ABI)\n\n    for i, arg in enumerate(sig.base_args):\n\n        arg_ir = get_element_ptr(base_args_ofst, i)\n\n        if needs_clamp(arg.typ, Encoding.ABI):\n            # allocate a memory slot for it and copy\n            p = context.new_variable(arg.name, arg.typ, is_mutable=False)\n            dst = IRnode(p, typ=arg.typ, location=MEMORY)\n\n            copy_arg = make_setter(dst, arg_ir)\n            copy_arg.source_pos = getpos(arg.ast_source)\n            ret.append(copy_arg)\n        else:\n            assert abi_encoding_matches_vyper(arg.typ)\n            # leave it in place\n            context.vars[arg.name] = VariableRecord(\n                name=arg.name,\n                pos=arg_ir,\n                typ=arg.typ,\n                mutable=False,\n                location=arg_ir.location,\n                encoding=Encoding.ABI,\n            )\n\n    return ret\n\n\ndef _annotated_method_id(abi_sig):\n    method_id = util.method_id_int(abi_sig)\n    annotation = f\"{hex(method_id)}: {abi_sig}\"\n    return IRnode(method_id, annotation=annotation)\n\n\ndef _generate_kwarg_handlers(context: Context, sig: FunctionSignature) -> List[Any]:\n    # generate kwarg handlers.\n    # since they might come in thru calldata or be default,\n    # allocate them in memory and then fill it in based on calldata or default,\n    # depending on the signature\n    # a kwarg handler looks like\n    # (if (eq _method_id <method_id>)\n    #    copy calldata args to memory\n    #    write default args to memory\n    #    goto external_function_common_ir\n\n    def handler_for(calldata_kwargs, default_kwargs):\n        calldata_args = sig.base_args + calldata_kwargs\n        # create a fake type so that get_element_ptr works\n        calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))\n\n        abi_sig = sig.abi_signature_for_kwargs(calldata_kwargs)\n        method_id = _annotated_method_id(abi_sig)\n\n        calldata_kwargs_ofst = IRnode(\n            4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI\n        )\n\n        # a sequence of statements to strictify kwargs into memory\n        ret = [\"seq\"]\n\n        # ensure calldata is at least of minimum length\n        args_abi_t = calldata_args_t.abi_type\n        calldata_min_size = args_abi_t.min_size() + 4\n        ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])\n\n        # TODO optimize make_setter by using\n        # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))\n        # (must ensure memory area is contiguous)\n\n        n_base_args = len(sig.base_args)\n\n        for i, arg_meta in enumerate(calldata_kwargs):\n            k = n_base_args + i\n\n            dst = context.lookup_var(arg_meta.name).pos\n\n            lhs = IRnode(dst, location=MEMORY, typ=arg_meta.typ)\n\n            rhs = get_element_ptr(calldata_kwargs_ofst, k, array_bounds_check=False)\n\n            copy_arg = make_setter(lhs, rhs)\n            copy_arg.source_pos = getpos(arg_meta.ast_source)\n            ret.append(copy_arg)\n\n        for x in default_kwargs:\n            dst = context.lookup_var(x.name).pos\n            lhs = IRnode(dst, location=MEMORY, typ=x.typ)\n            lhs.source_pos = getpos(x.ast_source)\n            kw_ast_val = sig.default_values[x.name]  # e.g. `3` in x: int = 3\n            rhs = Expr(kw_ast_val, context).ir_node\n\n            copy_arg = make_setter(lhs, rhs)\n            copy_arg.source_pos = getpos(x.ast_source)\n            ret.append(copy_arg)\n\n        ret.append([\"goto\", sig.external_function_base_entry_label])\n\n        ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]\n        return ret\n\n    ret = [\"seq\"]\n\n    keyword_args = sig.default_args\n\n    # allocate variable slots in memory\n    for arg in keyword_args:\n        context.new_variable(arg.name, arg.typ, is_mutable=False)\n\n    for i, _ in enumerate(keyword_args):\n        calldata_kwargs = keyword_args[:i]\n        default_kwargs = keyword_args[i:]\n\n        ret.append(handler_for(calldata_kwargs, default_kwargs))\n\n    ret.append(handler_for(keyword_args, []))\n\n    return ret\n\n\n# TODO it would be nice if this returned a data structure which were\n# amenable to generating a jump table instead of the linear search for\n# method_id we have now.\ndef generate_ir_for_external_function(code, sig, context, skip_nonpayable_check):\n    # TODO type hints:\n    # def generate_ir_for_external_function(\n    #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,\n    # ) -> IRnode:\n    \"\"\"Return the IR for an external function. Includes code to inspect the method_id,\n    enter the function (nonpayable and reentrancy checks), handle kwargs and exit\n    the function (clean up reentrancy storage variables)\n    \"\"\"\n    func_type = code._metadata[\"type\"]\n\n    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)\n\n    # generate handlers for base args and register the variable records\n    handle_base_args = _register_function_args(context, sig)\n\n    # generate handlers for kwargs and register the variable records\n    kwarg_handlers = _generate_kwarg_handlers(context, sig)\n\n    body = [\"seq\"]\n    # once optional args have been handled,\n    # generate the main body of the function\n    body += handle_base_args\n\n    if sig.mutability != \"payable\" and not skip_nonpayable_check:\n        # if the contract contains payable functions, but this is not one of them\n        # add an assertion that the value of the call is zero\n        body += [[\"assert\", [\"iszero\", \"callvalue\"]]]\n\n    body += nonreentrant_pre\n\n    body += [parse_body(code.body, context, ensure_terminated=True)]\n\n    # wrap the body in labeled block\n    body = [\"label\", sig.external_function_base_entry_label, [\"var_list\"], body]\n\n    exit_sequence = [\"seq\"] + nonreentrant_post\n    if sig.is_init_func:\n        pass  # init func has special exit sequence generated by module.py\n    elif context.return_type is None:\n        exit_sequence += [[\"stop\"]]\n    else:\n        exit_sequence += [[\"return\", \"ret_ofst\", \"ret_len\"]]\n\n    exit_sequence_args = [\"var_list\"]\n    if context.return_type is not None:\n        exit_sequence_args += [\"ret_ofst\", \"ret_len\"]\n    # wrap the exit in a labeled block\n    exit = [\"label\", sig.exit_sequence_label, exit_sequence_args, exit_sequence]\n\n    # the ir which comprises the main body of the function,\n    # besides any kwarg handling\n    func_common_ir = [\"seq\", body, exit]\n\n    if sig.is_default_func or sig.is_init_func:\n        ret = [\"seq\"]\n        # add a goto to make the function entry look like other functions\n        # (for zksync interpreter)\n        ret.append([\"goto\", sig.external_function_base_entry_label])\n        ret.append(func_common_ir)\n    else:\n        ret = kwarg_handlers\n        # sneak the base code into the kwarg handler\n        # TODO rethink this / make it clearer\n        ret[-1][-1].append(func_common_ir)\n\n    return IRnode.from_list(ret, source_pos=getpos(sig.func_ast_code))\n", "# a contract.vy -- all functions and constructor\n\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom vyper import ast as vy_ast\nfrom vyper.ast.signatures.function_signature import FunctionSignature, FunctionSignatures\nfrom vyper.codegen.core import shr\nfrom vyper.codegen.function_definitions import generate_ir_for_function\nfrom vyper.codegen.global_context import GlobalContext\nfrom vyper.codegen.ir_node import IRnode\nfrom vyper.exceptions import CompilerPanic\nfrom vyper.semantics.types.function import StateMutability\n\n\ndef _topsort_helper(functions, lookup):\n    #  single pass to get a global topological sort of functions (so that each\n    # function comes after each of its callees). may have duplicates, which get\n    # filtered out in _topsort()\n\n    ret = []\n    for f in functions:\n        # called_functions is a list of ContractFunctions, need to map\n        # back to FunctionDefs.\n        callees = [lookup[t.name] for t in f._metadata[\"type\"].called_functions]\n        ret.extend(_topsort_helper(callees, lookup))\n        ret.append(f)\n\n    return ret\n\n\ndef _topsort(functions):\n    lookup = {f.name: f for f in functions}\n    # strip duplicates\n    return list(dict.fromkeys(_topsort_helper(functions, lookup)))\n\n\ndef _is_init_func(func_ast):\n    return func_ast._metadata[\"signature\"].is_init_func\n\n\ndef _is_default_func(func_ast):\n    return func_ast._metadata[\"signature\"].is_default_func\n\n\ndef _is_internal(func_ast):\n    return func_ast._metadata[\"type\"].is_internal\n\n\ndef _is_payable(func_ast):\n    return func_ast._metadata[\"type\"].mutability == StateMutability.PAYABLE\n\n\n# codegen for all runtime functions + callvalue/calldata checks + method selector routines\ndef _runtime_ir(runtime_functions, all_sigs, global_ctx):\n    # categorize the runtime functions because we will organize the runtime\n    # code into the following sections:\n    # payable functions, nonpayable functions, fallback function, internal_functions\n    internal_functions = [f for f in runtime_functions if _is_internal(f)]\n\n    external_functions = [f for f in runtime_functions if not _is_internal(f)]\n    default_function = next((f for f in external_functions if _is_default_func(f)), None)\n\n    # functions that need to go exposed in the selector section\n    regular_functions = [f for f in external_functions if not _is_default_func(f)]\n    payables = [f for f in regular_functions if _is_payable(f)]\n    nonpayables = [f for f in regular_functions if not _is_payable(f)]\n\n    # create a map of the IR functions since they might live in both\n    # runtime and deploy code (if init function calls them)\n    internal_functions_map: Dict[str, IRnode] = {}\n\n    for func_ast in internal_functions:\n        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)\n        internal_functions_map[func_ast.name] = func_ir\n\n    # for some reason, somebody may want to deploy a contract with no\n    # external functions, or more likely, a \"pure data\" contract which\n    # contains immutables\n    if len(external_functions) == 0:\n        # TODO: prune internal functions in this case?\n        runtime = [\"seq\"] + list(internal_functions_map.values())\n        return runtime, internal_functions_map\n\n    # note: if the user does not provide one, the default fallback function\n    # reverts anyway. so it does not hurt to batch the payable check.\n    default_is_nonpayable = default_function is None or not _is_payable(default_function)\n\n    # when a contract has a nonpayable default function,\n    # we can do a single check for all nonpayable functions\n    batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable\n    skip_nonpayable_check = batch_payable_check\n\n    selector_section = [\"seq\"]\n\n    for func_ast in payables:\n        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)\n        selector_section.append(func_ir)\n\n    if batch_payable_check:\n        selector_section.append([\"assert\", [\"iszero\", \"callvalue\"]])\n\n    for func_ast in nonpayables:\n        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, skip_nonpayable_check)\n        selector_section.append(func_ir)\n\n    if default_function:\n        fallback_ir = generate_ir_for_function(\n            default_function, all_sigs, global_ctx, skip_nonpayable_check\n        )\n    else:\n        fallback_ir = IRnode.from_list(\n            [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"\n        )\n\n    # ensure the external jumptable section gets closed out\n    # (for basic block hygiene and also for zksync interpreter)\n    # NOTE: this jump gets optimized out in assembly since the\n    # fallback label is the immediate next instruction,\n    close_selector_section = [\"goto\", \"fallback\"]\n\n    runtime = [\n        \"seq\",\n        # check that calldatasize is at least 4, otherwise\n        # calldataload will load zeros (cf. yellow paper).\n        [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],\n        [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],\n        close_selector_section,\n        [\"label\", \"fallback\", [\"var_list\"], fallback_ir],\n    ]\n\n    # TODO: prune unreachable functions?\n    runtime.extend(internal_functions_map.values())\n\n    return runtime, internal_functions_map\n\n\n# take a GlobalContext, which is basically\n# and generate the runtime and deploy IR, also return the dict of all signatures\ndef generate_ir_for_module(global_ctx: GlobalContext) -> Tuple[IRnode, IRnode, FunctionSignatures]:\n    # order functions so that each function comes after all of its callees\n    function_defs = _topsort(global_ctx.functions)\n\n    # FunctionSignatures for all interfaces defined in this module\n    all_sigs: Dict[str, FunctionSignatures] = {}\n\n    init_function: Optional[vy_ast.FunctionDef] = None\n    local_sigs: FunctionSignatures = {}  # internal/local functions\n\n    # generate all signatures\n    # TODO really this should live in GlobalContext\n    for f in function_defs:\n        sig = FunctionSignature.from_definition(f, global_ctx)\n        # add it to the global namespace.\n        local_sigs[sig.name] = sig\n        # a little hacky, eventually FunctionSignature should be\n        # merged with ContractFunction and we can remove this.\n        f._metadata[\"signature\"] = sig\n\n    assert \"self\" not in all_sigs\n    all_sigs[\"self\"] = local_sigs\n\n    runtime_functions = [f for f in function_defs if not _is_init_func(f)]\n    init_function = next((f for f in function_defs if _is_init_func(f)), None)\n\n    runtime, internal_functions = _runtime_ir(runtime_functions, all_sigs, global_ctx)\n\n    deploy_code: List[Any] = [\"seq\"]\n    immutables_len = global_ctx.immutable_section_bytes\n    if init_function:\n        init_func_ir = generate_ir_for_function(init_function, all_sigs, global_ctx, False)\n        deploy_code.append(init_func_ir)\n\n        # pass the amount of memory allocated for the init function\n        # so that deployment does not clobber while preparing immutables\n        # note: (deploy mem_ofst, code, extra_padding)\n        init_mem_used = init_function._metadata[\"signature\"].frame_info.mem_used\n        deploy_code.append([\"deploy\", init_mem_used, runtime, immutables_len])\n\n        # internal functions come after everything else\n        for f in init_function._metadata[\"type\"].called_functions:\n            deploy_code.append(internal_functions[f.name])\n\n    else:\n        if immutables_len != 0:\n            raise CompilerPanic(\"unreachable\")\n        deploy_code.append([\"deploy\", 0, runtime, 0])\n\n    return IRnode.from_list(deploy_code), IRnode.from_list(runtime), local_sigs\n"], "fixing_code": ["import vyper\n\n\ndef test_basic_init_function(get_contract):\n    code = \"\"\"\nval: public(uint256)\n\n@external\ndef __init__(a: uint256):\n    self.val = a\n    \"\"\"\n\n    c = get_contract(code, *[123])\n\n    assert c.val() == 123\n\n    # Make sure the init code does not access calldata\n    assembly = vyper.compile_code(code, [\"asm\"])[\"asm\"].split(\" \")\n    ir_return_idx_start = assembly.index(\"{\")\n    ir_return_idx_end = assembly.index(\"}\")\n\n    assert \"CALLDATALOAD\" in assembly\n    assert \"CALLDATACOPY\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]\n    assert \"CALLDATALOAD\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]\n\n\ndef test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):\n    code = \"\"\"\nfoo: public(uint8)\n@internal\ndef bar(x: uint256) -> uint8:\n    return convert(x, uint8) * 7\n@external\ndef __init__(a: uint256):\n    self.foo = self.bar(a)\n\n@external\ndef baz() -> uint8:\n    return self.bar(convert(self.foo, uint256))\n    \"\"\"\n    n = 5\n    c = get_contract(code, n)\n    assert c.foo() == n * 7\n    assert c.baz() == 245  # 5*7*7\n\n    n = 6\n    c = get_contract(code, n)\n    assert c.foo() == n * 7\n    assert_tx_failed(lambda: c.baz())\n\n    n = 255\n    assert_compile_failed(lambda: get_contract(code, n))\n\n    n = 256\n    assert_compile_failed(lambda: get_contract(code, n))\n", "from typing import Any, List\n\nimport vyper.utils as util\nfrom vyper.address_space import CALLDATA, DATA, MEMORY\nfrom vyper.ast.signatures.function_signature import FunctionSignature\nfrom vyper.codegen.abi_encoder import abi_encoding_matches_vyper\nfrom vyper.codegen.context import Context, VariableRecord\nfrom vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp\nfrom vyper.codegen.expr import Expr\nfrom vyper.codegen.function_definitions.utils import get_nonreentrant_lock\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.codegen.stmt import parse_body\nfrom vyper.semantics.types import TupleT\n\n\n# register function args with the local calling context.\n# also allocate the ones that live in memory (i.e. kwargs)\ndef _register_function_args(context: Context, sig: FunctionSignature) -> List[IRnode]:\n    ret = []\n\n    # the type of the calldata\n    base_args_t = TupleT(tuple(arg.typ for arg in sig.base_args))\n\n    # tuple with the abi_encoded args\n    if sig.is_init_func:\n        base_args_ofst = IRnode(0, location=DATA, typ=base_args_t, encoding=Encoding.ABI)\n    else:\n        base_args_ofst = IRnode(4, location=CALLDATA, typ=base_args_t, encoding=Encoding.ABI)\n\n    for i, arg in enumerate(sig.base_args):\n\n        arg_ir = get_element_ptr(base_args_ofst, i)\n\n        if needs_clamp(arg.typ, Encoding.ABI):\n            # allocate a memory slot for it and copy\n            p = context.new_variable(arg.name, arg.typ, is_mutable=False)\n            dst = IRnode(p, typ=arg.typ, location=MEMORY)\n\n            copy_arg = make_setter(dst, arg_ir)\n            copy_arg.source_pos = getpos(arg.ast_source)\n            ret.append(copy_arg)\n        else:\n            assert abi_encoding_matches_vyper(arg.typ)\n            # leave it in place\n            context.vars[arg.name] = VariableRecord(\n                name=arg.name,\n                pos=arg_ir,\n                typ=arg.typ,\n                mutable=False,\n                location=arg_ir.location,\n                encoding=Encoding.ABI,\n            )\n\n    return ret\n\n\ndef _annotated_method_id(abi_sig):\n    method_id = util.method_id_int(abi_sig)\n    annotation = f\"{hex(method_id)}: {abi_sig}\"\n    return IRnode(method_id, annotation=annotation)\n\n\ndef _generate_kwarg_handlers(context: Context, sig: FunctionSignature) -> List[Any]:\n    # generate kwarg handlers.\n    # since they might come in thru calldata or be default,\n    # allocate them in memory and then fill it in based on calldata or default,\n    # depending on the signature\n    # a kwarg handler looks like\n    # (if (eq _method_id <method_id>)\n    #    copy calldata args to memory\n    #    write default args to memory\n    #    goto external_function_common_ir\n\n    def handler_for(calldata_kwargs, default_kwargs):\n        calldata_args = sig.base_args + calldata_kwargs\n        # create a fake type so that get_element_ptr works\n        calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))\n\n        abi_sig = sig.abi_signature_for_kwargs(calldata_kwargs)\n        method_id = _annotated_method_id(abi_sig)\n\n        calldata_kwargs_ofst = IRnode(\n            4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI\n        )\n\n        # a sequence of statements to strictify kwargs into memory\n        ret = [\"seq\"]\n\n        # ensure calldata is at least of minimum length\n        args_abi_t = calldata_args_t.abi_type\n        calldata_min_size = args_abi_t.min_size() + 4\n        ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])\n\n        # TODO optimize make_setter by using\n        # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))\n        # (must ensure memory area is contiguous)\n\n        n_base_args = len(sig.base_args)\n\n        for i, arg_meta in enumerate(calldata_kwargs):\n            k = n_base_args + i\n\n            dst = context.lookup_var(arg_meta.name).pos\n\n            lhs = IRnode(dst, location=MEMORY, typ=arg_meta.typ)\n\n            rhs = get_element_ptr(calldata_kwargs_ofst, k, array_bounds_check=False)\n\n            copy_arg = make_setter(lhs, rhs)\n            copy_arg.source_pos = getpos(arg_meta.ast_source)\n            ret.append(copy_arg)\n\n        for x in default_kwargs:\n            dst = context.lookup_var(x.name).pos\n            lhs = IRnode(dst, location=MEMORY, typ=x.typ)\n            lhs.source_pos = getpos(x.ast_source)\n            kw_ast_val = sig.default_values[x.name]  # e.g. `3` in x: int = 3\n            rhs = Expr(kw_ast_val, context).ir_node\n\n            copy_arg = make_setter(lhs, rhs)\n            copy_arg.source_pos = getpos(x.ast_source)\n            ret.append(copy_arg)\n\n        ret.append([\"goto\", sig.external_function_base_entry_label])\n\n        method_id_check = [\"eq\", \"_calldata_method_id\", method_id]\n\n        # if there is a function whose selector is 0, it won't be distinguished\n        # from the case where nil calldata is supplied, b/c calldataload loads\n        # 0s past the end of physical calldata (cf. yellow paper).\n        # since supplying 0 calldata is expected to trigger the fallback fn,\n        # we check that calldatasize > 0, which distinguishes the 0 selector\n        # from the fallback function \"selector\"\n        # (equiv. to \"all selectors not in the selector table\").\n\n        # note: cases where not enough calldata is supplied (besides\n        # calldatasize==0) are not addressed here b/c a calldatasize\n        # well-formedness check is already present in the function body\n        # as part of abi validation\n        if method_id.value == 0:\n            method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]\n\n        ret = [\"if\", method_id_check, ret]\n        return ret\n\n    ret = [\"seq\"]\n\n    keyword_args = sig.default_args\n\n    # allocate variable slots in memory\n    for arg in keyword_args:\n        context.new_variable(arg.name, arg.typ, is_mutable=False)\n\n    for i, _ in enumerate(keyword_args):\n        calldata_kwargs = keyword_args[:i]\n        default_kwargs = keyword_args[i:]\n\n        ret.append(handler_for(calldata_kwargs, default_kwargs))\n\n    ret.append(handler_for(keyword_args, []))\n\n    return ret\n\n\n# TODO it would be nice if this returned a data structure which were\n# amenable to generating a jump table instead of the linear search for\n# method_id we have now.\ndef generate_ir_for_external_function(code, sig, context, skip_nonpayable_check):\n    # TODO type hints:\n    # def generate_ir_for_external_function(\n    #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,\n    # ) -> IRnode:\n    \"\"\"Return the IR for an external function. Includes code to inspect the method_id,\n    enter the function (nonpayable and reentrancy checks), handle kwargs and exit\n    the function (clean up reentrancy storage variables)\n    \"\"\"\n    func_type = code._metadata[\"type\"]\n\n    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)\n\n    # generate handlers for base args and register the variable records\n    handle_base_args = _register_function_args(context, sig)\n\n    # generate handlers for kwargs and register the variable records\n    kwarg_handlers = _generate_kwarg_handlers(context, sig)\n\n    body = [\"seq\"]\n    # once optional args have been handled,\n    # generate the main body of the function\n    body += handle_base_args\n\n    if sig.mutability != \"payable\" and not skip_nonpayable_check:\n        # if the contract contains payable functions, but this is not one of them\n        # add an assertion that the value of the call is zero\n        body += [[\"assert\", [\"iszero\", \"callvalue\"]]]\n\n    body += nonreentrant_pre\n\n    body += [parse_body(code.body, context, ensure_terminated=True)]\n\n    # wrap the body in labeled block\n    body = [\"label\", sig.external_function_base_entry_label, [\"var_list\"], body]\n\n    exit_sequence = [\"seq\"] + nonreentrant_post\n    if sig.is_init_func:\n        pass  # init func has special exit sequence generated by module.py\n    elif context.return_type is None:\n        exit_sequence += [[\"stop\"]]\n    else:\n        exit_sequence += [[\"return\", \"ret_ofst\", \"ret_len\"]]\n\n    exit_sequence_args = [\"var_list\"]\n    if context.return_type is not None:\n        exit_sequence_args += [\"ret_ofst\", \"ret_len\"]\n    # wrap the exit in a labeled block\n    exit = [\"label\", sig.exit_sequence_label, exit_sequence_args, exit_sequence]\n\n    # the ir which comprises the main body of the function,\n    # besides any kwarg handling\n    func_common_ir = [\"seq\", body, exit]\n\n    if sig.is_default_func or sig.is_init_func:\n        ret = [\"seq\"]\n        # add a goto to make the function entry look like other functions\n        # (for zksync interpreter)\n        ret.append([\"goto\", sig.external_function_base_entry_label])\n        ret.append(func_common_ir)\n    else:\n        ret = kwarg_handlers\n        # sneak the base code into the kwarg handler\n        # TODO rethink this / make it clearer\n        ret[-1][-1].append(func_common_ir)\n\n    return IRnode.from_list(ret, source_pos=getpos(sig.func_ast_code))\n", "# a contract.vy -- all functions and constructor\n\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom vyper import ast as vy_ast\nfrom vyper.ast.signatures.function_signature import FunctionSignature, FunctionSignatures\nfrom vyper.codegen.core import shr\nfrom vyper.codegen.function_definitions import generate_ir_for_function\nfrom vyper.codegen.global_context import GlobalContext\nfrom vyper.codegen.ir_node import IRnode\nfrom vyper.exceptions import CompilerPanic\nfrom vyper.semantics.types.function import StateMutability\n\n\ndef _topsort_helper(functions, lookup):\n    #  single pass to get a global topological sort of functions (so that each\n    # function comes after each of its callees). may have duplicates, which get\n    # filtered out in _topsort()\n\n    ret = []\n    for f in functions:\n        # called_functions is a list of ContractFunctions, need to map\n        # back to FunctionDefs.\n        callees = [lookup[t.name] for t in f._metadata[\"type\"].called_functions]\n        ret.extend(_topsort_helper(callees, lookup))\n        ret.append(f)\n\n    return ret\n\n\ndef _topsort(functions):\n    lookup = {f.name: f for f in functions}\n    # strip duplicates\n    return list(dict.fromkeys(_topsort_helper(functions, lookup)))\n\n\ndef _is_init_func(func_ast):\n    return func_ast._metadata[\"signature\"].is_init_func\n\n\ndef _is_default_func(func_ast):\n    return func_ast._metadata[\"signature\"].is_default_func\n\n\ndef _is_internal(func_ast):\n    return func_ast._metadata[\"type\"].is_internal\n\n\ndef _is_payable(func_ast):\n    return func_ast._metadata[\"type\"].mutability == StateMutability.PAYABLE\n\n\n# codegen for all runtime functions + callvalue/calldata checks + method selector routines\ndef _runtime_ir(runtime_functions, all_sigs, global_ctx):\n    # categorize the runtime functions because we will organize the runtime\n    # code into the following sections:\n    # payable functions, nonpayable functions, fallback function, internal_functions\n    internal_functions = [f for f in runtime_functions if _is_internal(f)]\n\n    external_functions = [f for f in runtime_functions if not _is_internal(f)]\n    default_function = next((f for f in external_functions if _is_default_func(f)), None)\n\n    # functions that need to go exposed in the selector section\n    regular_functions = [f for f in external_functions if not _is_default_func(f)]\n    payables = [f for f in regular_functions if _is_payable(f)]\n    nonpayables = [f for f in regular_functions if not _is_payable(f)]\n\n    # create a map of the IR functions since they might live in both\n    # runtime and deploy code (if init function calls them)\n    internal_functions_map: Dict[str, IRnode] = {}\n\n    for func_ast in internal_functions:\n        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)\n        internal_functions_map[func_ast.name] = func_ir\n\n    # for some reason, somebody may want to deploy a contract with no\n    # external functions, or more likely, a \"pure data\" contract which\n    # contains immutables\n    if len(external_functions) == 0:\n        # TODO: prune internal functions in this case?\n        runtime = [\"seq\"] + list(internal_functions_map.values())\n        return runtime, internal_functions_map\n\n    # note: if the user does not provide one, the default fallback function\n    # reverts anyway. so it does not hurt to batch the payable check.\n    default_is_nonpayable = default_function is None or not _is_payable(default_function)\n\n    # when a contract has a nonpayable default function,\n    # we can do a single check for all nonpayable functions\n    batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable\n    skip_nonpayable_check = batch_payable_check\n\n    selector_section = [\"seq\"]\n\n    for func_ast in payables:\n        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)\n        selector_section.append(func_ir)\n\n    if batch_payable_check:\n        selector_section.append([\"assert\", [\"iszero\", \"callvalue\"]])\n\n    for func_ast in nonpayables:\n        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, skip_nonpayable_check)\n        selector_section.append(func_ir)\n\n    if default_function:\n        fallback_ir = generate_ir_for_function(\n            default_function, all_sigs, global_ctx, skip_nonpayable_check\n        )\n    else:\n        fallback_ir = IRnode.from_list(\n            [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"\n        )\n\n    # ensure the external jumptable section gets closed out\n    # (for basic block hygiene and also for zksync interpreter)\n    # NOTE: this jump gets optimized out in assembly since the\n    # fallback label is the immediate next instruction,\n    close_selector_section = [\"goto\", \"fallback\"]\n\n    runtime = [\n        \"seq\",\n        [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],\n        close_selector_section,\n        [\"label\", \"fallback\", [\"var_list\"], fallback_ir],\n    ]\n\n    # TODO: prune unreachable functions?\n    runtime.extend(internal_functions_map.values())\n\n    return runtime, internal_functions_map\n\n\n# take a GlobalContext, which is basically\n# and generate the runtime and deploy IR, also return the dict of all signatures\ndef generate_ir_for_module(global_ctx: GlobalContext) -> Tuple[IRnode, IRnode, FunctionSignatures]:\n    # order functions so that each function comes after all of its callees\n    function_defs = _topsort(global_ctx.functions)\n\n    # FunctionSignatures for all interfaces defined in this module\n    all_sigs: Dict[str, FunctionSignatures] = {}\n\n    init_function: Optional[vy_ast.FunctionDef] = None\n    local_sigs: FunctionSignatures = {}  # internal/local functions\n\n    # generate all signatures\n    # TODO really this should live in GlobalContext\n    for f in function_defs:\n        sig = FunctionSignature.from_definition(f, global_ctx)\n        # add it to the global namespace.\n        local_sigs[sig.name] = sig\n        # a little hacky, eventually FunctionSignature should be\n        # merged with ContractFunction and we can remove this.\n        f._metadata[\"signature\"] = sig\n\n    assert \"self\" not in all_sigs\n    all_sigs[\"self\"] = local_sigs\n\n    runtime_functions = [f for f in function_defs if not _is_init_func(f)]\n    init_function = next((f for f in function_defs if _is_init_func(f)), None)\n\n    runtime, internal_functions = _runtime_ir(runtime_functions, all_sigs, global_ctx)\n\n    deploy_code: List[Any] = [\"seq\"]\n    immutables_len = global_ctx.immutable_section_bytes\n    if init_function:\n        init_func_ir = generate_ir_for_function(init_function, all_sigs, global_ctx, False)\n        deploy_code.append(init_func_ir)\n\n        # pass the amount of memory allocated for the init function\n        # so that deployment does not clobber while preparing immutables\n        # note: (deploy mem_ofst, code, extra_padding)\n        init_mem_used = init_function._metadata[\"signature\"].frame_info.mem_used\n        deploy_code.append([\"deploy\", init_mem_used, runtime, immutables_len])\n\n        # internal functions come after everything else\n        for f in init_function._metadata[\"type\"].called_functions:\n            deploy_code.append(internal_functions[f.name])\n\n    else:\n        if immutables_len != 0:\n            raise CompilerPanic(\"unreachable\")\n        deploy_code.append([\"deploy\", 0, runtime, 0])\n\n    return IRnode.from_list(deploy_code), IRnode.from_list(runtime), local_sigs\n"], "filenames": ["tests/parser/features/test_init.py", "vyper/codegen/function_definitions/external_function.py", "vyper/codegen/module.py"], "buggy_code_start_loc": [18, 126, 123], "buggy_code_end_loc": [24, 127, 126], "fixing_code_start_loc": [18, 126, 122], "fixing_code_end_loc": [25, 144, 122], "type": "CWE-670", "message": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In contracts with more than one regular nonpayable function, it is possible to send funds to the default function, even if the default function is marked `nonpayable`. This applies to contracts compiled with vyper versions prior to 0.3.8. This issue was fixed by the removal of the global `calldatasize` check in commit `02339dfda`. Users are advised to upgrade to version 0.3.8. Users unable to upgrade should avoid use of nonpayable default functions.", "other": {"cve": {"id": "CVE-2023-32675", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-19T20:15:09.230", "lastModified": "2023-05-26T17:34:06.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In contracts with more than one regular nonpayable function, it is possible to send funds to the default function, even if the default function is marked `nonpayable`. This applies to contracts compiled with vyper versions prior to 0.3.8. This issue was fixed by the removal of the global `calldatasize` check in commit `02339dfda`. Users are advised to upgrade to version 0.3.8. Users unable to upgrade should avoid use of nonpayable default functions."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vyper_project:vyper:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.8", "matchCriteriaId": "BD6E3906-C87B-4245-9871-27CD85C32EEF"}]}]}], "references": [{"url": "https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.", "source": "security-advisories@github.com", "tags": ["Broken Link", "Patch"]}, {"url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-vxmm-cwh2-q762", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520."}}