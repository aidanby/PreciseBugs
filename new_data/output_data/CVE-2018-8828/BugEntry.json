{"buggy_code": ["/*\n * Copyright (C) 2014 Daniel-Constantin Mierla (asipto.com)\n *\n * This file is part of kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n/*! \\file\n * \\brief TMX :: Pretran\n *\n * \\ingroup tm\n * - Module: \\ref tm\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"../../core/dprint.h\"\n#include \"../../core/mem/shm_mem.h\"\n#include \"../../core/locking.h\"\n#include \"../../core/hashes.h\"\n#include \"../../core/config.h\"\n#include \"../../core/parser/parse_via.h\"\n#include \"../../core/parser/parse_from.h\"\n#include \"../../core/route.h\"\n#include \"../../core/trim.h\"\n#include \"../../core/pt.h\"\n\n#include \"tmx_pretran.h\"\n\ntypedef struct _pretran {\n\tunsigned int hid;\n\tunsigned int linked;\n\tstr callid;\n\tstr ftag;\n\tstr cseqnum;\n\tstr cseqmet;\n\tunsigned int cseqmetid;\n\tstr vbranch;\n\tstr dbuf;\n\tint pid;\n\tstruct _pretran *next;\n\tstruct _pretran *prev;\n} pretran_t;\n\ntypedef struct pretran_slot {\n\tpretran_t *plist;\n\tgen_lock_t lock;\n} pretran_slot_t;\n\nstatic pretran_t *_tmx_proc_ptran = NULL;\nstatic pretran_slot_t *_tmx_ptran_table = NULL;\nstatic int _tmx_ptran_size = 0;\n\n/**\n *\n */\nint tmx_init_pretran_table(void)\n{\n\tint n;\n\tint pn;\n\n\tpn = get_max_procs();\n\n\tif(pn<=0)\n\t\treturn -1;\n\tif(_tmx_ptran_table!=NULL)\n\t\treturn -1;\n\t/* get the highest power of two less than number of processes */\n\tn = -1;\n\twhile (pn >> ++n > 0);\n\tn--;\n\tif(n<=1) n = 2;\n\tif(n>8) n = 8;\n\t_tmx_ptran_size = 1<<n;\n\n\t_tmx_ptran_table = (pretran_slot_t*)shm_malloc(_tmx_ptran_size*sizeof(pretran_slot_t));\n\tif(_tmx_ptran_table == NULL) {\n\t\tLM_ERR(\"not enough shared memory\\n\");\n\t\treturn -1;\n\t}\n\tmemset(_tmx_ptran_table, 0, _tmx_ptran_size*sizeof(pretran_slot_t));\n\tfor(n=0; n<_tmx_ptran_size; n++) {\n\t\tif(lock_init(&_tmx_ptran_table[n].lock)==NULL)\n\t\t{\n\t\t\tLM_ERR(\"cannot init the lock %d\\n\", n);\n\t\t\tn--;\n\t\t\twhile(n>=0) {\n\t\t\t\tlock_destroy(&_tmx_ptran_table[n].lock);\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tshm_free(_tmx_ptran_table);\n\t\t\t_tmx_ptran_table = 0;\n\t\t\t_tmx_ptran_size = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n *\n */\nvoid tmx_pretran_link_safe(int slotid)\n{\n\tif(_tmx_proc_ptran==NULL)\n\t\treturn;\n\n\tif(_tmx_ptran_table[slotid].plist==NULL) {\n\t\t_tmx_ptran_table[slotid].plist = _tmx_proc_ptran;\n\t\t_tmx_proc_ptran->linked = 1;\n\t\treturn;\n\t}\n\t_tmx_proc_ptran->next = _tmx_ptran_table[slotid].plist;\n\t_tmx_ptran_table[slotid].plist->prev = _tmx_proc_ptran;\n\t_tmx_ptran_table[slotid].plist = _tmx_proc_ptran;\n\t_tmx_proc_ptran->linked = 1;\n\treturn;\n}\n\n/**\n *\n */\nvoid tmx_pretran_unlink_safe(int slotid)\n{\n\tif(_tmx_proc_ptran==NULL)\n\t\treturn;\n\tif(_tmx_proc_ptran->linked == 0)\n\t\treturn;\n\tif(_tmx_ptran_table[slotid].plist==NULL) {\n\t\t_tmx_proc_ptran->prev = _tmx_proc_ptran->next = NULL;\n\t\t_tmx_proc_ptran->linked = 0;\n\t\treturn;\n\t}\n\tif(_tmx_proc_ptran->prev==NULL) {\n\t\t_tmx_ptran_table[slotid].plist = _tmx_proc_ptran->next;\n\t\tif(_tmx_ptran_table[slotid].plist!=NULL)\n\t\t\t_tmx_ptran_table[slotid].plist->prev = NULL;\n\t} else {\n\t\t_tmx_proc_ptran->prev->next = _tmx_proc_ptran->next;\n\t\tif(_tmx_proc_ptran->next)\n\t\t\t_tmx_proc_ptran->next->prev = _tmx_proc_ptran->prev;\n\t}\n\t_tmx_proc_ptran->prev = _tmx_proc_ptran->next = NULL;\n\t_tmx_proc_ptran->linked = 0;\n\treturn;\n}\n\n/**\n *\n */\nvoid tmx_pretran_unlink(void)\n{\n\tint slotid;\n\n\tif(_tmx_proc_ptran==NULL)\n\t\treturn;\n\n\tslotid = _tmx_proc_ptran->hid & (_tmx_ptran_size-1);\n\tlock_get(&_tmx_ptran_table[slotid].lock);\n\ttmx_pretran_unlink_safe(slotid);\n\tlock_release(&_tmx_ptran_table[slotid].lock);\n}\n\n/**\n * return:\n *   - -1: error\n *   -  0: not found\n *   -  1: found\n */\nint tmx_check_pretran(sip_msg_t *msg)\n{\n\tunsigned int chid;\n\tunsigned int slotid;\n\tint dsize;\n\tstruct via_param *vbr;\n\tstr scallid;\n\tstr scseqmet;\n\tstr scseqnum;\n\tstr sftag;\n\tstr svbranch = {NULL, 0};\n\tpretran_t *it;\n\n\tif(_tmx_ptran_table==NULL) {\n\t\tLM_ERR(\"pretran hash table not initialized yet\\n\");\n\t\treturn -1;\n\t}\n\tif(get_route_type()!=REQUEST_ROUTE) {\n\t\tLM_ERR(\"invalid usage - not in request route\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->first_line.type!=SIP_REQUEST) {\n\t\tLM_ERR(\"invalid usage - not a sip request\\n\");\n\t\treturn -1;\n\t}\n\tif(parse_headers(msg, HDR_FROM_F|HDR_VIA1_F|HDR_CALLID_F|HDR_CSEQ_F, 0)<0) {\n\t\tLM_ERR(\"failed to parse required headers\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->cseq==NULL || msg->cseq->parsed==NULL) {\n\t\tLM_ERR(\"failed to parse cseq headers\\n\");\n\t\treturn -1;\n\t}\n\tif(get_cseq(msg)->method_id==METHOD_ACK\n\t\t\t|| get_cseq(msg)->method_id==METHOD_CANCEL) {\n\t\tLM_DBG(\"no pre-transaction management for ACK or CANCEL\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->via1==0) {\n\t\tLM_ERR(\"failed to get Via header\\n\");\n\t\treturn -1;\n\t}\n\tif (parse_from_header(msg)<0 || get_from(msg)->tag_value.len==0) {\n\t\tLM_ERR(\"failed to get From header\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->callid==NULL || msg->callid->body.s==NULL) {\n\t\tLM_ERR(\"failed to parse callid headers\\n\");\n\t\treturn -1;\n\t}\n\n\tvbr = msg->via1->branch;\n\n\tscallid = msg->callid->body;\n\ttrim(&scallid);\n\tscseqmet = get_cseq(msg)->method;\n\ttrim(&scseqmet);\n\tscseqnum = get_cseq(msg)->number;\n\ttrim(&scseqnum);\n\tsftag = get_from(msg)->tag_value;\n\ttrim(&sftag);\n\n\tchid = get_hash1_raw(msg->callid->body.s, msg->callid->body.len);\n\tslotid = chid & (_tmx_ptran_size-1);\n\n\tif(unlikely(_tmx_proc_ptran == NULL)) {\n\t\t_tmx_proc_ptran = (pretran_t*)shm_malloc(sizeof(pretran_t));\n\t\tif(_tmx_proc_ptran == NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran structure\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(_tmx_proc_ptran, 0, sizeof(pretran_t));\n\t\t_tmx_proc_ptran->pid = my_pid();\n\t}\n\tdsize = scallid.len + scseqnum.len + scseqmet.len\n\t\t+ sftag.len + 4;\n\tif(likely(vbr!=NULL)) {\n\t\tsvbranch = vbr->value;\n\t\ttrim(&svbranch);\n\t\tdsize += svbranch.len;\n\t}\n\tif(dsize<256) dsize = 256;\n\n\ttmx_pretran_unlink();\n\n\tif(dsize > _tmx_proc_ptran->dbuf.len) {\n\t\tif(_tmx_proc_ptran->dbuf.s) shm_free(_tmx_proc_ptran->dbuf.s);\n\t\t_tmx_proc_ptran->dbuf.s = (char*)shm_malloc(dsize);\n\t\tif(_tmx_proc_ptran->dbuf.s==NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran data\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t_tmx_proc_ptran->dbuf.len = dsize;\n\t}\n\t_tmx_proc_ptran->hid = chid;\n\t_tmx_proc_ptran->cseqmetid = (get_cseq(msg))->method_id;\n\n\t_tmx_proc_ptran->callid.s = _tmx_proc_ptran->dbuf.s;\n\tmemcpy(_tmx_proc_ptran->callid.s, scallid.s, scallid.len);\n\t_tmx_proc_ptran->callid.len = scallid.len;\n\t_tmx_proc_ptran->callid.s[_tmx_proc_ptran->callid.len] = '\\0';\n\n\t_tmx_proc_ptran->ftag.s = _tmx_proc_ptran->callid.s\n\t\t+ _tmx_proc_ptran->callid.len + 1;\n\tmemcpy(_tmx_proc_ptran->ftag.s, sftag.s, sftag.len);\n\t_tmx_proc_ptran->ftag.len = sftag.len;\n\t_tmx_proc_ptran->ftag.s[_tmx_proc_ptran->ftag.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqnum.s = _tmx_proc_ptran->ftag.s\n\t\t+ _tmx_proc_ptran->ftag.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqnum.s, scseqnum.s, scseqnum.len);\n\t_tmx_proc_ptran->cseqnum.len = scseqnum.len;\n\t_tmx_proc_ptran->cseqnum.s[_tmx_proc_ptran->cseqnum.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqmet.s = _tmx_proc_ptran->cseqnum.s\n\t\t+ _tmx_proc_ptran->cseqnum.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqmet.s, scseqmet.s, scseqmet.len);\n\t_tmx_proc_ptran->cseqmet.len = scseqmet.len;\n\t_tmx_proc_ptran->cseqmet.s[_tmx_proc_ptran->cseqmet.len] = '\\0';\n\n\tif(likely(vbr!=NULL)) {\n\t\t_tmx_proc_ptran->vbranch.s = _tmx_proc_ptran->cseqmet.s\n\t\t\t+ _tmx_proc_ptran->cseqmet.len + 1;\n\t\tmemcpy(_tmx_proc_ptran->vbranch.s, svbranch.s, svbranch.len);\n\t\t_tmx_proc_ptran->vbranch.len = svbranch.len;\n\t\t_tmx_proc_ptran->vbranch.s[_tmx_proc_ptran->vbranch.len] = '\\0';\n\t} else {\n\t\t_tmx_proc_ptran->vbranch.s = NULL;\n\t\t_tmx_proc_ptran->vbranch.len = 0;\n\t}\n\n\tlock_get(&_tmx_ptran_table[slotid].lock);\n\tit = _tmx_ptran_table[slotid].plist;\n\ttmx_pretran_link_safe(slotid);\n\tfor(; it!=NULL; it=it->next) {\n\t\tif(_tmx_proc_ptran->hid != it->hid\n\t\t\t\t|| _tmx_proc_ptran->cseqmetid != it->cseqmetid\n\t\t\t\t|| _tmx_proc_ptran->callid.len != it->callid.len\n\t\t\t\t|| _tmx_proc_ptran->ftag.len != it->ftag.len\n\t\t\t\t|| _tmx_proc_ptran->cseqmet.len != it->cseqmet.len\n\t\t\t\t|| _tmx_proc_ptran->cseqnum.len != it->cseqnum.len)\n\t\t\tcontinue;\n\t\tif(_tmx_proc_ptran->vbranch.s != NULL && it->vbranch.s != NULL) {\n\t\t\tif(_tmx_proc_ptran->vbranch.len != it->vbranch.len)\n\t\t\t\tcontinue;\n\t\t\t/* shortcut - check last char in Via branch\n\t\t\t * - kamailio/ser adds there branch index => in case of paralel\n\t\t\t *   forking by previous hop, catch it here quickly */\n\t\t\tif(_tmx_proc_ptran->vbranch.s[it->vbranch.len-1]\n\t\t\t\t\t!= it->vbranch.s[it->vbranch.len-1])\n\t\t\t\tcontinue;\n\t\t\tif(memcmp(_tmx_proc_ptran->vbranch.s,\n\t\t\t\t\t\tit->vbranch.s, it->vbranch.len)!=0)\n\t\t\t\tcontinue;\n\t\t\t/* shall stop by matching magic cookie?\n\t\t\t *  if (vbr && vbr->value.s && vbr->value.len > MCOOKIE_LEN\n\t\t\t *  && memcmp(vbr->value.s, MCOOKIE, MCOOKIE_LEN)==0) {\n\t\t\t *  LM_DBG(\"rfc3261 cookie found in Via branch\\n\");\n\t\t\t *  }\n\t\t\t */\n\t\t}\n\t\tif(memcmp(_tmx_proc_ptran->callid.s,\n\t\t\t\t\tit->callid.s, it->callid.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->ftag.s,\n\t\t\t\t\tit->ftag.s, it->ftag.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->cseqnum.s,\n\t\t\t\t\tit->cseqnum.s, it->cseqnum.len)!=0)\n\t\t\tcontinue;\n\t\tif((it->cseqmetid==METHOD_OTHER || it->cseqmetid==METHOD_UNDEF)\n\t\t\t\t&& memcmp(_tmx_proc_ptran->cseqmet.s,\n\t\t\t\t\tit->cseqmet.s, it->cseqmet.len)!=0)\n\t\t\tcontinue;\n\t\tLM_DBG(\"matched another pre-transaction by pid %d for [%.*s]\\n\",\n\t\t\t\tit->pid, it->callid.len, it->callid.s);\n\t\tlock_release(&_tmx_ptran_table[slotid].lock);\n\t\treturn 1;\n\t}\n\tlock_release(&_tmx_ptran_table[slotid].lock);\n\treturn 0;\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 2014 Daniel-Constantin Mierla (asipto.com)\n *\n * This file is part of kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n/*! \\file\n * \\brief TMX :: Pretran\n *\n * \\ingroup tm\n * - Module: \\ref tm\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"../../core/dprint.h\"\n#include \"../../core/mem/shm_mem.h\"\n#include \"../../core/locking.h\"\n#include \"../../core/hashes.h\"\n#include \"../../core/config.h\"\n#include \"../../core/parser/parse_via.h\"\n#include \"../../core/parser/parse_from.h\"\n#include \"../../core/route.h\"\n#include \"../../core/trim.h\"\n#include \"../../core/pt.h\"\n\n#include \"tmx_pretran.h\"\n\ntypedef struct _pretran {\n\tunsigned int hid;\n\tunsigned int linked;\n\tstr callid;\n\tstr ftag;\n\tstr cseqnum;\n\tstr cseqmet;\n\tunsigned int cseqmetid;\n\tstr vbranch;\n\tstr dbuf;\n\tint pid;\n\tstruct _pretran *next;\n\tstruct _pretran *prev;\n} pretran_t;\n\ntypedef struct pretran_slot {\n\tpretran_t *plist;\n\tgen_lock_t lock;\n} pretran_slot_t;\n\nstatic pretran_t *_tmx_proc_ptran = NULL;\nstatic pretran_slot_t *_tmx_ptran_table = NULL;\nstatic int _tmx_ptran_size = 0;\n\n/**\n *\n */\nint tmx_init_pretran_table(void)\n{\n\tint n;\n\tint pn;\n\n\tpn = get_max_procs();\n\n\tif(pn<=0)\n\t\treturn -1;\n\tif(_tmx_ptran_table!=NULL)\n\t\treturn -1;\n\t/* get the highest power of two less than number of processes */\n\tn = -1;\n\twhile (pn >> ++n > 0);\n\tn--;\n\tif(n<=1) n = 2;\n\tif(n>8) n = 8;\n\t_tmx_ptran_size = 1<<n;\n\n\t_tmx_ptran_table = (pretran_slot_t*)shm_malloc(_tmx_ptran_size*sizeof(pretran_slot_t));\n\tif(_tmx_ptran_table == NULL) {\n\t\tLM_ERR(\"not enough shared memory\\n\");\n\t\treturn -1;\n\t}\n\tmemset(_tmx_ptran_table, 0, _tmx_ptran_size*sizeof(pretran_slot_t));\n\tfor(n=0; n<_tmx_ptran_size; n++) {\n\t\tif(lock_init(&_tmx_ptran_table[n].lock)==NULL)\n\t\t{\n\t\t\tLM_ERR(\"cannot init the lock %d\\n\", n);\n\t\t\tn--;\n\t\t\twhile(n>=0) {\n\t\t\t\tlock_destroy(&_tmx_ptran_table[n].lock);\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tshm_free(_tmx_ptran_table);\n\t\t\t_tmx_ptran_table = 0;\n\t\t\t_tmx_ptran_size = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n *\n */\nvoid tmx_pretran_link_safe(int slotid)\n{\n\tif(_tmx_proc_ptran==NULL)\n\t\treturn;\n\n\tif(_tmx_ptran_table[slotid].plist==NULL) {\n\t\t_tmx_ptran_table[slotid].plist = _tmx_proc_ptran;\n\t\t_tmx_proc_ptran->linked = 1;\n\t\treturn;\n\t}\n\t_tmx_proc_ptran->next = _tmx_ptran_table[slotid].plist;\n\t_tmx_ptran_table[slotid].plist->prev = _tmx_proc_ptran;\n\t_tmx_ptran_table[slotid].plist = _tmx_proc_ptran;\n\t_tmx_proc_ptran->linked = 1;\n\treturn;\n}\n\n/**\n *\n */\nvoid tmx_pretran_unlink_safe(int slotid)\n{\n\tif(_tmx_proc_ptran==NULL)\n\t\treturn;\n\tif(_tmx_proc_ptran->linked == 0)\n\t\treturn;\n\tif(_tmx_ptran_table[slotid].plist==NULL) {\n\t\t_tmx_proc_ptran->prev = _tmx_proc_ptran->next = NULL;\n\t\t_tmx_proc_ptran->linked = 0;\n\t\treturn;\n\t}\n\tif(_tmx_proc_ptran->prev==NULL) {\n\t\t_tmx_ptran_table[slotid].plist = _tmx_proc_ptran->next;\n\t\tif(_tmx_ptran_table[slotid].plist!=NULL)\n\t\t\t_tmx_ptran_table[slotid].plist->prev = NULL;\n\t} else {\n\t\t_tmx_proc_ptran->prev->next = _tmx_proc_ptran->next;\n\t\tif(_tmx_proc_ptran->next)\n\t\t\t_tmx_proc_ptran->next->prev = _tmx_proc_ptran->prev;\n\t}\n\t_tmx_proc_ptran->prev = _tmx_proc_ptran->next = NULL;\n\t_tmx_proc_ptran->linked = 0;\n\treturn;\n}\n\n/**\n *\n */\nvoid tmx_pretran_unlink(void)\n{\n\tint slotid;\n\n\tif(_tmx_proc_ptran==NULL)\n\t\treturn;\n\n\tslotid = _tmx_proc_ptran->hid & (_tmx_ptran_size-1);\n\tlock_get(&_tmx_ptran_table[slotid].lock);\n\ttmx_pretran_unlink_safe(slotid);\n\tlock_release(&_tmx_ptran_table[slotid].lock);\n}\n\n/**\n * return:\n *   - -1: error\n *   -  0: not found\n *   -  1: found\n */\nint tmx_check_pretran(sip_msg_t *msg)\n{\n\tunsigned int chid;\n\tunsigned int slotid;\n\tint dsize;\n\tstruct via_param *vbr;\n\tstr scallid;\n\tstr scseqmet;\n\tstr scseqnum;\n\tstr sftag;\n\tstr svbranch = {NULL, 0};\n\tpretran_t *it;\n\n\tif(_tmx_ptran_table==NULL) {\n\t\tLM_ERR(\"pretran hash table not initialized yet\\n\");\n\t\treturn -1;\n\t}\n\tif(get_route_type()!=REQUEST_ROUTE) {\n\t\tLM_ERR(\"invalid usage - not in request route\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->first_line.type!=SIP_REQUEST) {\n\t\tLM_ERR(\"invalid usage - not a sip request\\n\");\n\t\treturn -1;\n\t}\n\tif(parse_headers(msg, HDR_FROM_F|HDR_VIA1_F|HDR_CALLID_F|HDR_CSEQ_F, 0)<0) {\n\t\tLM_ERR(\"failed to parse required headers\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->cseq==NULL || msg->cseq->parsed==NULL) {\n\t\tLM_ERR(\"failed to parse cseq headers\\n\");\n\t\treturn -1;\n\t}\n\tif(get_cseq(msg)->method_id==METHOD_ACK\n\t\t\t|| get_cseq(msg)->method_id==METHOD_CANCEL) {\n\t\tLM_DBG(\"no pre-transaction management for ACK or CANCEL\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->via1==0) {\n\t\tLM_ERR(\"failed to get Via header\\n\");\n\t\treturn -1;\n\t}\n\tif (parse_from_header(msg)<0 || get_from(msg)->tag_value.len==0) {\n\t\tLM_ERR(\"failed to get From header\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->callid==NULL || msg->callid->body.s==NULL) {\n\t\tLM_ERR(\"failed to parse callid headers\\n\");\n\t\treturn -1;\n\t}\n\n\tvbr = msg->via1->branch;\n\n\tscallid = msg->callid->body;\n\ttrim(&scallid);\n\tscseqmet = get_cseq(msg)->method;\n\ttrim(&scseqmet);\n\tscseqnum = get_cseq(msg)->number;\n\ttrim(&scseqnum);\n\tsftag = get_from(msg)->tag_value;\n\ttrim(&sftag);\n\n\tchid = get_hash1_raw(msg->callid->body.s, msg->callid->body.len);\n\tslotid = chid & (_tmx_ptran_size-1);\n\n\tif(unlikely(_tmx_proc_ptran == NULL)) {\n\t\t_tmx_proc_ptran = (pretran_t*)shm_malloc(sizeof(pretran_t));\n\t\tif(_tmx_proc_ptran == NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran structure\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(_tmx_proc_ptran, 0, sizeof(pretran_t));\n\t\t_tmx_proc_ptran->pid = my_pid();\n\t}\n\tdsize = scallid.len + scseqnum.len + scseqmet.len\n\t\t+ sftag.len + 4;\n\tif(likely(vbr!=NULL)) {\n\t\tsvbranch = vbr->value;\n\t\ttrim(&svbranch);\n\t\tdsize += svbranch.len + 1;\n\t}\n\tif(dsize<256) dsize = 256;\n\n\ttmx_pretran_unlink();\n\n\tif(dsize > _tmx_proc_ptran->dbuf.len) {\n\t\tif(_tmx_proc_ptran->dbuf.s) shm_free(_tmx_proc_ptran->dbuf.s);\n\t\t_tmx_proc_ptran->dbuf.s = (char*)shm_malloc(dsize);\n\t\tif(_tmx_proc_ptran->dbuf.s==NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran data\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t_tmx_proc_ptran->dbuf.len = dsize;\n\t}\n\t_tmx_proc_ptran->hid = chid;\n\t_tmx_proc_ptran->cseqmetid = (get_cseq(msg))->method_id;\n\n\t_tmx_proc_ptran->callid.s = _tmx_proc_ptran->dbuf.s;\n\tmemcpy(_tmx_proc_ptran->callid.s, scallid.s, scallid.len);\n\t_tmx_proc_ptran->callid.len = scallid.len;\n\t_tmx_proc_ptran->callid.s[_tmx_proc_ptran->callid.len] = '\\0';\n\n\t_tmx_proc_ptran->ftag.s = _tmx_proc_ptran->callid.s\n\t\t+ _tmx_proc_ptran->callid.len + 1;\n\tmemcpy(_tmx_proc_ptran->ftag.s, sftag.s, sftag.len);\n\t_tmx_proc_ptran->ftag.len = sftag.len;\n\t_tmx_proc_ptran->ftag.s[_tmx_proc_ptran->ftag.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqnum.s = _tmx_proc_ptran->ftag.s\n\t\t+ _tmx_proc_ptran->ftag.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqnum.s, scseqnum.s, scseqnum.len);\n\t_tmx_proc_ptran->cseqnum.len = scseqnum.len;\n\t_tmx_proc_ptran->cseqnum.s[_tmx_proc_ptran->cseqnum.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqmet.s = _tmx_proc_ptran->cseqnum.s\n\t\t+ _tmx_proc_ptran->cseqnum.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqmet.s, scseqmet.s, scseqmet.len);\n\t_tmx_proc_ptran->cseqmet.len = scseqmet.len;\n\t_tmx_proc_ptran->cseqmet.s[_tmx_proc_ptran->cseqmet.len] = '\\0';\n\n\tif(likely(vbr!=NULL)) {\n\t\t_tmx_proc_ptran->vbranch.s = _tmx_proc_ptran->cseqmet.s\n\t\t\t+ _tmx_proc_ptran->cseqmet.len + 1;\n\t\tmemcpy(_tmx_proc_ptran->vbranch.s, svbranch.s, svbranch.len);\n\t\t_tmx_proc_ptran->vbranch.len = svbranch.len;\n\t\t_tmx_proc_ptran->vbranch.s[_tmx_proc_ptran->vbranch.len] = '\\0';\n\t} else {\n\t\t_tmx_proc_ptran->vbranch.s = NULL;\n\t\t_tmx_proc_ptran->vbranch.len = 0;\n\t}\n\n\tlock_get(&_tmx_ptran_table[slotid].lock);\n\tit = _tmx_ptran_table[slotid].plist;\n\ttmx_pretran_link_safe(slotid);\n\tfor(; it!=NULL; it=it->next) {\n\t\tif(_tmx_proc_ptran->hid != it->hid\n\t\t\t\t|| _tmx_proc_ptran->cseqmetid != it->cseqmetid\n\t\t\t\t|| _tmx_proc_ptran->callid.len != it->callid.len\n\t\t\t\t|| _tmx_proc_ptran->ftag.len != it->ftag.len\n\t\t\t\t|| _tmx_proc_ptran->cseqmet.len != it->cseqmet.len\n\t\t\t\t|| _tmx_proc_ptran->cseqnum.len != it->cseqnum.len)\n\t\t\tcontinue;\n\t\tif(_tmx_proc_ptran->vbranch.s != NULL && it->vbranch.s != NULL) {\n\t\t\tif(_tmx_proc_ptran->vbranch.len != it->vbranch.len)\n\t\t\t\tcontinue;\n\t\t\t/* shortcut - check last char in Via branch\n\t\t\t * - kamailio/ser adds there branch index => in case of paralel\n\t\t\t *   forking by previous hop, catch it here quickly */\n\t\t\tif(_tmx_proc_ptran->vbranch.s[it->vbranch.len-1]\n\t\t\t\t\t!= it->vbranch.s[it->vbranch.len-1])\n\t\t\t\tcontinue;\n\t\t\tif(memcmp(_tmx_proc_ptran->vbranch.s,\n\t\t\t\t\t\tit->vbranch.s, it->vbranch.len)!=0)\n\t\t\t\tcontinue;\n\t\t\t/* shall stop by matching magic cookie?\n\t\t\t *  if (vbr && vbr->value.s && vbr->value.len > MCOOKIE_LEN\n\t\t\t *  && memcmp(vbr->value.s, MCOOKIE, MCOOKIE_LEN)==0) {\n\t\t\t *  LM_DBG(\"rfc3261 cookie found in Via branch\\n\");\n\t\t\t *  }\n\t\t\t */\n\t\t}\n\t\tif(memcmp(_tmx_proc_ptran->callid.s,\n\t\t\t\t\tit->callid.s, it->callid.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->ftag.s,\n\t\t\t\t\tit->ftag.s, it->ftag.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->cseqnum.s,\n\t\t\t\t\tit->cseqnum.s, it->cseqnum.len)!=0)\n\t\t\tcontinue;\n\t\tif((it->cseqmetid==METHOD_OTHER || it->cseqmetid==METHOD_UNDEF)\n\t\t\t\t&& memcmp(_tmx_proc_ptran->cseqmet.s,\n\t\t\t\t\tit->cseqmet.s, it->cseqmet.len)!=0)\n\t\t\tcontinue;\n\t\tLM_DBG(\"matched another pre-transaction by pid %d for [%.*s]\\n\",\n\t\t\t\tit->pid, it->callid.len, it->callid.s);\n\t\tlock_release(&_tmx_ptran_table[slotid].lock);\n\t\treturn 1;\n\t}\n\tlock_release(&_tmx_ptran_table[slotid].lock);\n\treturn 0;\n}\n\n"], "filenames": ["src/modules/tmx/tmx_pretran.c"], "buggy_code_start_loc": [263], "buggy_code_end_loc": [264], "fixing_code_start_loc": [263], "fixing_code_end_loc": [264], "type": "CWE-193", "message": "A Buffer Overflow issue was discovered in Kamailio before 4.4.7, 5.0.x before 5.0.6, and 5.1.x before 5.1.2. A specially crafted REGISTER message with a malformed branch or From tag triggers an off-by-one heap-based buffer overflow in the tmx_check_pretran function in modules/tmx/tmx_pretran.c.", "other": {"cve": {"id": "CVE-2018-8828", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-20T20:29:00.350", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A Buffer Overflow issue was discovered in Kamailio before 4.4.7, 5.0.x before 5.0.6, and 5.1.x before 5.1.2. A specially crafted REGISTER message with a malformed branch or From tag triggers an off-by-one heap-based buffer overflow in the tmx_check_pretran function in modules/tmx/tmx_pretran.c."}, {"lang": "es", "value": "Se ha descubierto un problema de desbordamiento de b\u00fafer en Kamailio, en versiones anteriores a la 4.4.7, versiones 5.0.x anteriores a la 5.0.6 y versiones 5.1.x anteriores a la 5.1.2. Un mensaje REGISTER especialmente manipulado con una rama o una etiqueta From mal formadas desencadena un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) por error por un paso en la funci\u00f3n tmx_check_pretran en modules/tmx/tmx_pretran.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kamailio:kamailio:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.7", "matchCriteriaId": "6C6AD2E6-C4B0-4F27-9710-808047AC87F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:kamailio:kamailio:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.6", "matchCriteriaId": "B123B107-A24D-4484-B02A-F9EC02B616F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:kamailio:kamailio:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.1.0", "versionEndExcluding": "5.1.2", "matchCriteriaId": "2A6505A9-5F54-400F-A645-74C59286D1F7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/EnableSecurity/advisories/tree/master/ES2018-05-kamailio-heap-overflow", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/kamailio/kamailio/commit/e1d8008a09d9390ebaf698abe8909e10dfec4097", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4240-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4148", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kamailio/kamailio/commit/e1d8008a09d9390ebaf698abe8909e10dfec4097"}}