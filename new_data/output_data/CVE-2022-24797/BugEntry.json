{"buggy_code": ["package config\n\nimport (\n\t\"crypto/tls\"\n\n\t\"github.com/pomerium/pomerium/internal/hashutil\"\n)\n\n// Config holds pomerium configuration options.\ntype Config struct {\n\tOptions          *Options\n\tAutoCertificates []tls.Certificate\n\tEnvoyVersion     string\n\n\t// GRPCPort is the port the gRPC server is running on.\n\tGRPCPort string\n\t// HTTPPort is the port the HTTP server is running on.\n\tHTTPPort string\n\t// OutboundPort is the port the outbound gRPC listener is running on.\n\tOutboundPort string\n}\n\n// Clone creates a clone of the config.\nfunc (cfg *Config) Clone() *Config {\n\tnewOptions := new(Options)\n\t*newOptions = *cfg.Options\n\treturn &Config{\n\t\tOptions:          newOptions,\n\t\tAutoCertificates: cfg.AutoCertificates,\n\t\tEnvoyVersion:     cfg.EnvoyVersion,\n\n\t\tGRPCPort:     cfg.GRPCPort,\n\t\tHTTPPort:     cfg.HTTPPort,\n\t\tOutboundPort: cfg.OutboundPort,\n\t}\n}\n\n// AllCertificates returns all the certificates in the config.\nfunc (cfg *Config) AllCertificates() ([]tls.Certificate, error) {\n\toptionCertificates, err := cfg.Options.GetCertificates()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar certs []tls.Certificate\n\tcerts = append(certs, optionCertificates...)\n\tcerts = append(certs, cfg.AutoCertificates...)\n\treturn certs, nil\n}\n\n// Checksum returns the config checksum.\nfunc (cfg *Config) Checksum() uint64 {\n\treturn hashutil.MustHash(cfg)\n}\n", "package config\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/google/uuid\"\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/pomerium/pomerium/internal/fileutil\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/netutil\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/metrics\"\n)\n\n// A ChangeListener is called when configuration changes.\ntype ChangeListener = func(context.Context, *Config)\n\n// A ChangeDispatcher manages listeners on config changes.\ntype ChangeDispatcher struct {\n\tsync.Mutex\n\tonConfigChangeListeners []ChangeListener\n}\n\n// Trigger triggers a change.\nfunc (dispatcher *ChangeDispatcher) Trigger(ctx context.Context, cfg *Config) {\n\tdispatcher.Lock()\n\tdefer dispatcher.Unlock()\n\n\tfor _, li := range dispatcher.onConfigChangeListeners {\n\t\tli(ctx, cfg)\n\t}\n}\n\n// OnConfigChange adds a listener.\nfunc (dispatcher *ChangeDispatcher) OnConfigChange(ctx context.Context, li ChangeListener) {\n\tdispatcher.Lock()\n\tdefer dispatcher.Unlock()\n\tdispatcher.onConfigChangeListeners = append(dispatcher.onConfigChangeListeners, li)\n}\n\n// A Source gets configuration.\ntype Source interface {\n\tGetConfig() *Config\n\tOnConfigChange(context.Context, ChangeListener)\n}\n\n// A StaticSource always returns the same config. Useful for testing.\ntype StaticSource struct {\n\tmu  sync.Mutex\n\tcfg *Config\n\tlis []ChangeListener\n}\n\n// NewStaticSource creates a new StaticSource.\nfunc NewStaticSource(cfg *Config) *StaticSource {\n\treturn &StaticSource{cfg: cfg}\n}\n\n// GetConfig gets the config.\nfunc (src *StaticSource) GetConfig() *Config {\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\treturn src.cfg\n}\n\n// SetConfig sets the config.\nfunc (src *StaticSource) SetConfig(ctx context.Context, cfg *Config) {\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\tsrc.cfg = cfg\n\tfor _, li := range src.lis {\n\t\tli(ctx, cfg)\n\t}\n}\n\n// OnConfigChange is ignored for the StaticSource.\nfunc (src *StaticSource) OnConfigChange(ctx context.Context, li ChangeListener) {\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\tsrc.lis = append(src.lis, li)\n}\n\n// A FileOrEnvironmentSource retrieves config options from a file or the environment.\ntype FileOrEnvironmentSource struct {\n\tconfigFile string\n\n\tmu     sync.RWMutex\n\tconfig *Config\n\n\tChangeDispatcher\n}\n\n// NewFileOrEnvironmentSource creates a new FileOrEnvironmentSource.\nfunc NewFileOrEnvironmentSource(\n\tconfigFile, envoyVersion string,\n) (*FileOrEnvironmentSource, error) {\n\tctx := log.WithContext(context.TODO(), func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"config_file_source\", configFile)\n\t})\n\n\toptions, err := newOptionsFromConfig(configFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tports, err := netutil.AllocatePorts(3)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgrpcPort := ports[0]\n\thttpPort := ports[1]\n\toutboundPort := ports[2]\n\n\tcfg := &Config{\n\t\tOptions:      options,\n\t\tEnvoyVersion: envoyVersion,\n\n\t\tGRPCPort:     grpcPort,\n\t\tHTTPPort:     httpPort,\n\t\tOutboundPort: outboundPort,\n\t}\n\tmetrics.SetConfigInfo(ctx, cfg.Options.Services, \"local\", cfg.Checksum(), true)\n\n\tsrc := &FileOrEnvironmentSource{\n\t\tconfigFile: configFile,\n\t\tconfig:     cfg,\n\t}\n\toptions.viper.OnConfigChange(src.onConfigChange(ctx))\n\tgo options.viper.WatchConfig()\n\n\treturn src, nil\n}\n\nfunc (src *FileOrEnvironmentSource) onConfigChange(ctx context.Context) func(fsnotify.Event) {\n\treturn func(evt fsnotify.Event) {\n\t\tctx := log.WithContext(ctx, func(c zerolog.Context) zerolog.Context {\n\t\t\treturn c.Str(\"config_change_id\", uuid.New().String())\n\t\t})\n\t\tlog.Info(ctx).Msg(\"config: file updated, reconfiguring...\")\n\t\tsrc.mu.Lock()\n\t\tcfg := src.config\n\t\toptions, err := newOptionsFromConfig(src.configFile)\n\t\tif err == nil {\n\t\t\tcfg = cfg.Clone()\n\t\t\tcfg.Options = options\n\t\t\tmetrics.SetConfigInfo(ctx, cfg.Options.Services, \"local\", cfg.Checksum(), true)\n\t\t} else {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"config: error updating config\")\n\t\t\tmetrics.SetConfigInfo(ctx, cfg.Options.Services, \"local\", cfg.Checksum(), false)\n\t\t}\n\t\tsrc.mu.Unlock()\n\n\t\tsrc.Trigger(ctx, cfg)\n\t}\n}\n\n// GetConfig gets the config.\nfunc (src *FileOrEnvironmentSource) GetConfig() *Config {\n\tsrc.mu.RLock()\n\tdefer src.mu.RUnlock()\n\n\treturn src.config\n}\n\n// FileWatcherSource is a config source which triggers a change any time a file in the options changes.\ntype FileWatcherSource struct {\n\tunderlying Source\n\twatcher    *fileutil.Watcher\n\n\tmu             sync.RWMutex\n\tcomputedConfig *Config\n\n\tChangeDispatcher\n}\n\n// NewFileWatcherSource creates a new FileWatcherSource\nfunc NewFileWatcherSource(underlying Source) *FileWatcherSource {\n\tsrc := &FileWatcherSource{\n\t\tunderlying: underlying,\n\t\twatcher:    fileutil.NewWatcher(),\n\t}\n\n\tch := src.watcher.Bind()\n\tgo func() {\n\t\tfor range ch {\n\t\t\tsrc.check(context.TODO(), underlying.GetConfig())\n\t\t}\n\t}()\n\tunderlying.OnConfigChange(context.TODO(), func(ctx context.Context, cfg *Config) {\n\t\tsrc.check(ctx, cfg)\n\t})\n\tsrc.check(context.TODO(), underlying.GetConfig())\n\n\treturn src\n}\n\n// GetConfig gets the underlying config.\nfunc (src *FileWatcherSource) GetConfig() *Config {\n\tsrc.mu.RLock()\n\tdefer src.mu.RUnlock()\n\treturn src.computedConfig\n}\n\nfunc (src *FileWatcherSource) check(ctx context.Context, cfg *Config) {\n\tif cfg == nil || cfg.Options == nil {\n\t\treturn\n\t}\n\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\tsrc.watcher.Clear()\n\n\th := sha256.New()\n\tfs := []string{\n\t\tcfg.Options.CAFile,\n\t\tcfg.Options.CertFile,\n\t\tcfg.Options.ClientCAFile,\n\t\tcfg.Options.ClientCRLFile,\n\t\tcfg.Options.DataBrokerStorageCAFile,\n\t\tcfg.Options.DataBrokerStorageCertFile,\n\t\tcfg.Options.DataBrokerStorageCertKeyFile,\n\t\tcfg.Options.KeyFile,\n\t\tcfg.Options.PolicyFile,\n\t\tcfg.Options.MetricsClientCAFile,\n\t\tcfg.Options.MetricsCertificateFile,\n\t\tcfg.Options.MetricsCertificateKeyFile,\n\t}\n\n\tfor _, pair := range cfg.Options.CertificateFiles {\n\t\tfs = append(fs, pair.CertFile, pair.KeyFile)\n\t}\n\n\tfor _, policy := range cfg.Options.Policies {\n\t\tfs = append(fs,\n\t\t\tpolicy.KubernetesServiceAccountTokenFile,\n\t\t\tpolicy.TLSClientCertFile,\n\t\t\tpolicy.TLSClientKeyFile,\n\t\t\tpolicy.TLSCustomCAFile,\n\t\t\tpolicy.TLSDownstreamClientCAFile,\n\t\t)\n\t}\n\n\tfor _, f := range fs {\n\t\t_, _ = h.Write([]byte{0})\n\t\tbs, err := os.ReadFile(f)\n\t\tif err == nil {\n\t\t\tsrc.watcher.Add(f)\n\t\t\t_, _ = h.Write(bs)\n\t\t}\n\t}\n\n\t// update the computed config\n\tsrc.computedConfig = cfg.Clone()\n\n\t// trigger a change\n\tsrc.Trigger(ctx, src.computedConfig)\n}\n", "package envoyconfig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n)\n\nfunc TestBuilder_BuildBootstrapAdmin(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\tadminCfg, err := b.BuildBootstrapAdmin(&config.Config{\n\t\t\tOptions: &config.Options{\n\t\t\t\tEnvoyAdminAddress: \"localhost:9901\",\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"address\": {\n\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\"portValue\": 9901\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`, adminCfg)\n\t})\n\tt.Run(\"bad address\", func(t *testing.T) {\n\t\t_, err := b.BuildBootstrapAdmin(&config.Config{\n\t\t\tOptions: &config.Options{\n\t\t\t\tEnvoyAdminAddress: \"xyz1234:zyx4321\",\n\t\t\t},\n\t\t})\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestBuilder_BuildBootstrapLayeredRuntime(t *testing.T) {\n\tb := New(\"localhost:1111\", \"localhost:2222\", filemgr.NewManager(), nil)\n\tstaticCfg, err := b.BuildBootstrapLayeredRuntime()\n\tassert.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t{ \"layers\": [{\n\t\t\t\"name\": \"static_layer_0\",\n\t\t\t\"staticLayer\": {\n\t\t\t\t\"overload\": {\n\t\t\t\t\t\"global_downstream_max_connections\": 50000\n\t\t\t\t}\n\t\t\t}\n\t\t}] }\n\t`, staticCfg)\n}\n\nfunc TestBuilder_BuildBootstrapStaticResources(t *testing.T) {\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\tb := New(\"localhost:1111\", \"localhost:2222\", filemgr.NewManager(), nil)\n\t\tstaticCfg, err := b.BuildBootstrapStaticResources()\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"clusters\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"pomerium-control-plane-grpc\",\n\t\t\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\t\t\"connectTimeout\": \"5s\",\n\t\t\t\t\t\t\"http2ProtocolOptions\": {},\n\t\t\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\t\t\"clusterName\": \"pomerium-control-plane-grpc\",\n\t\t\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\t\t\"socketAddress\":{\n\t\t\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"portValue\": 1111\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t`, staticCfg)\n\t})\n\tt.Run(\"bad gRPC address\", func(t *testing.T) {\n\t\tb := New(\"xyz:zyx\", \"localhost:2222\", filemgr.NewManager(), nil)\n\t\t_, err := b.BuildBootstrapStaticResources()\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestBuilder_BuildBootstrapStatsConfig(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\tstatsCfg, err := b.BuildBootstrapStatsConfig(&config.Config{\n\t\t\tOptions: &config.Options{\n\t\t\t\tServices: \"all\",\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"statsTags\": [{\n\t\t\t\t\t\"tagName\": \"service\",\n\t\t\t\t\t\"fixedValue\": \"pomerium\"\n\t\t\t\t}]\n\t\t\t}\n\t\t`, statsCfg)\n\t})\n}\n", "package envoyconfig\n\nimport (\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/httputil/reproxy\"\n)\n\n// A Builder builds envoy config from pomerium config.\ntype Builder struct {\n\tlocalGRPCAddress string\n\tlocalHTTPAddress string\n\tfilemgr          *filemgr.Manager\n\treproxy          *reproxy.Handler\n}\n\n// New creates a new Builder.\nfunc New(\n\tlocalGRPCAddress string,\n\tlocalHTTPAddress string,\n\tfileManager *filemgr.Manager,\n\treproxyHandler *reproxy.Handler,\n) *Builder {\n\treturn &Builder{\n\t\tlocalGRPCAddress: localGRPCAddress,\n\t\tlocalHTTPAddress: localHTTPAddress,\n\t\tfilemgr:          fileManager,\n\t\treproxy:          reproxyHandler,\n\t}\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\tenvoy_config_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tenvoy_config_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_config_endpoint_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3\"\n\tenvoy_extensions_transport_sockets_tls_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/anypb\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n)\n\n// BuildClusters builds envoy clusters from the given config.\nfunc (b *Builder) BuildClusters(ctx context.Context, cfg *config.Config) ([]*envoy_config_cluster_v3.Cluster, error) {\n\tgrpcURL := &url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   b.localGRPCAddress,\n\t}\n\thttpURL := &url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   b.localHTTPAddress,\n\t}\n\tauthorizeURLs, err := cfg.Options.GetInternalAuthorizeURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdatabrokerURLs, err := cfg.Options.GetDataBrokerURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontrolGRPC, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-control-plane-grpc\", []*url.URL{grpcURL}, upstreamProtocolHTTP2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontrolHTTP, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-control-plane-http\", []*url.URL{httpURL}, upstreamProtocolAuto)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tauthorizeCluster, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-authorize\", authorizeURLs, upstreamProtocolHTTP2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(authorizeURLs) > 1 {\n\t\tauthorizeCluster.HealthChecks = grpcHealthChecks(\"pomerium-authorize\")\n\t\tauthorizeCluster.OutlierDetection = grpcAuthorizeOutlierDetection()\n\t}\n\n\tdatabrokerCluster, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-databroker\", databrokerURLs, upstreamProtocolHTTP2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(databrokerURLs) > 1 {\n\t\tauthorizeCluster.HealthChecks = grpcHealthChecks(\"pomerium-databroker\")\n\t\tauthorizeCluster.OutlierDetection = grpcAuthorizeOutlierDetection()\n\t}\n\n\tclusters := []*envoy_config_cluster_v3.Cluster{\n\t\tcontrolGRPC,\n\t\tcontrolHTTP,\n\t\tauthorizeCluster,\n\t\tdatabrokerCluster,\n\t}\n\n\ttracingCluster, err := buildTracingCluster(cfg.Options)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if tracingCluster != nil {\n\t\tclusters = append(clusters, tracingCluster)\n\t}\n\n\tif config.IsProxy(cfg.Options.Services) {\n\t\tfor i, p := range cfg.Options.GetAllPolicies() {\n\t\t\tpolicy := p\n\t\t\tif policy.EnvoyOpts == nil {\n\t\t\t\tpolicy.EnvoyOpts = newDefaultEnvoyClusterConfig()\n\t\t\t}\n\t\t\tif len(policy.To) > 0 {\n\t\t\t\tcluster, err := b.buildPolicyCluster(ctx, cfg.Options, &policy)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"policy #%d: %w\", i, err)\n\t\t\t\t}\n\t\t\t\tclusters = append(clusters, cluster)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = validateClusters(clusters); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn clusters, nil\n}\n\nfunc (b *Builder) buildInternalCluster(\n\tctx context.Context,\n\toptions *config.Options,\n\tname string,\n\tdsts []*url.URL,\n\tupstreamProtocol upstreamProtocolConfig,\n) (*envoy_config_cluster_v3.Cluster, error) {\n\tcluster := newDefaultEnvoyClusterConfig()\n\tcluster.DnsLookupFamily = config.GetEnvoyDNSLookupFamily(options.DNSLookupFamily)\n\tvar endpoints []Endpoint\n\tfor _, dst := range dsts {\n\t\tts, err := b.buildInternalTransportSocket(ctx, options, dst)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tendpoints = append(endpoints, NewEndpoint(dst, ts, 1))\n\t}\n\tif err := b.buildCluster(cluster, name, endpoints, upstreamProtocol); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cluster, nil\n}\n\nfunc (b *Builder) buildPolicyCluster(ctx context.Context, options *config.Options, policy *config.Policy) (*envoy_config_cluster_v3.Cluster, error) {\n\tcluster := new(envoy_config_cluster_v3.Cluster)\n\tproto.Merge(cluster, policy.EnvoyOpts)\n\n\tif options.EnvoyBindConfigFreebind.IsSet() || options.EnvoyBindConfigSourceAddress != \"\" {\n\t\tcluster.UpstreamBindConfig = new(envoy_config_core_v3.BindConfig)\n\t\tif options.EnvoyBindConfigFreebind.IsSet() {\n\t\t\tcluster.UpstreamBindConfig.Freebind = wrapperspb.Bool(options.EnvoyBindConfigFreebind.Bool)\n\t\t}\n\t\tif options.EnvoyBindConfigSourceAddress != \"\" {\n\t\t\tcluster.UpstreamBindConfig.SourceAddress = &envoy_config_core_v3.SocketAddress{\n\t\t\t\tAddress: options.EnvoyBindConfigSourceAddress,\n\t\t\t\tPortSpecifier: &envoy_config_core_v3.SocketAddress_PortValue{\n\t\t\t\t\tPortValue: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tcluster.UpstreamBindConfig.SourceAddress = &envoy_config_core_v3.SocketAddress{\n\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\tPortSpecifier: &envoy_config_core_v3.SocketAddress_PortValue{\n\t\t\t\t\tPortValue: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tcluster.AltStatName = getClusterStatsName(policy)\n\tupstreamProtocol := getUpstreamProtocolForPolicy(ctx, policy)\n\n\tname := getClusterID(policy)\n\tendpoints, err := b.buildPolicyEndpoints(ctx, options, policy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cluster.DnsLookupFamily == envoy_config_cluster_v3.Cluster_AUTO {\n\t\tcluster.DnsLookupFamily = config.GetEnvoyDNSLookupFamily(options.DNSLookupFamily)\n\t}\n\n\tif policy.EnableGoogleCloudServerlessAuthentication {\n\t\tcluster.DnsLookupFamily = envoy_config_cluster_v3.Cluster_V4_ONLY\n\t}\n\n\tif err := b.buildCluster(cluster, name, endpoints, upstreamProtocol); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cluster, nil\n}\n\nfunc (b *Builder) buildPolicyEndpoints(\n\tctx context.Context,\n\toptions *config.Options,\n\tpolicy *config.Policy,\n) ([]Endpoint, error) {\n\tvar endpoints []Endpoint\n\tfor _, dst := range policy.To {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, options, policy, dst.URL)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tendpoints = append(endpoints, NewEndpoint(&dst.URL, ts, dst.LbWeight))\n\t}\n\treturn endpoints, nil\n}\n\nfunc (b *Builder) buildInternalTransportSocket(\n\tctx context.Context,\n\toptions *config.Options,\n\tendpoint *url.URL,\n) (*envoy_config_core_v3.TransportSocket, error) {\n\tif endpoint.Scheme != \"https\" {\n\t\treturn nil, nil\n\t}\n\n\tvalidationContext := &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\tMatchTypedSubjectAltNames: []*envoy_extensions_transport_sockets_tls_v3.SubjectAltNameMatcher{\n\t\t\tb.buildSubjectAltNameMatcher(endpoint, options.OverrideCertificateName),\n\t\t},\n\t}\n\tbs, err := getCombinedCertificateAuthority(options.CA, options.CAFile)\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"unable to enable certificate verification because no root CAs were found\")\n\t} else {\n\t\tvalidationContext.TrustedCa = b.filemgr.BytesDataSource(\"ca.pem\", bs)\n\t}\n\ttlsContext := &envoy_extensions_transport_sockets_tls_v3.UpstreamTlsContext{\n\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\tAlpnProtocols: []string{\"h2\", \"http/1.1\"},\n\t\t\tValidationContextType: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: validationContext,\n\t\t\t},\n\t\t},\n\t\tSni: b.buildSubjectNameIndication(endpoint, options.OverrideCertificateName),\n\t}\n\ttlsConfig := marshalAny(tlsContext)\n\treturn &envoy_config_core_v3.TransportSocket{\n\t\tName: \"tls\",\n\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\tTypedConfig: tlsConfig,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildPolicyTransportSocket(\n\tctx context.Context,\n\toptions *config.Options,\n\tpolicy *config.Policy,\n\tdst url.URL,\n) (*envoy_config_core_v3.TransportSocket, error) {\n\tif dst.Scheme != \"https\" {\n\t\treturn nil, nil\n\t}\n\n\tupstreamProtocol := getUpstreamProtocolForPolicy(ctx, policy)\n\n\tvc, err := b.buildPolicyValidationContext(ctx, options, policy, dst)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsni := dst.Hostname()\n\tif policy.TLSServerName != \"\" {\n\t\tsni = policy.TLSServerName\n\t}\n\ttlsContext := &envoy_extensions_transport_sockets_tls_v3.UpstreamTlsContext{\n\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\tTlsParams: &envoy_extensions_transport_sockets_tls_v3.TlsParameters{\n\t\t\t\tCipherSuites: []string{\n\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\"AES256-SHA\",\n\t\t\t\t},\n\t\t\t\tEcdhCurves: []string{\n\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\"P-521\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAlpnProtocols: buildUpstreamALPN(upstreamProtocol),\n\t\t\tValidationContextType: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: vc,\n\t\t\t},\n\t\t},\n\t\tSni: sni,\n\t}\n\tif policy.ClientCertificate != nil {\n\t\ttlsContext.CommonTlsContext.TlsCertificates = append(tlsContext.CommonTlsContext.TlsCertificates,\n\t\t\tb.envoyTLSCertificateFromGoTLSCertificate(ctx, policy.ClientCertificate))\n\t}\n\n\ttlsConfig := marshalAny(tlsContext)\n\treturn &envoy_config_core_v3.TransportSocket{\n\t\tName: \"tls\",\n\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\tTypedConfig: tlsConfig,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildPolicyValidationContext(\n\tctx context.Context,\n\toptions *config.Options,\n\tpolicy *config.Policy,\n\tdst url.URL,\n) (*envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext, error) {\n\tvalidationContext := &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\tMatchTypedSubjectAltNames: []*envoy_extensions_transport_sockets_tls_v3.SubjectAltNameMatcher{\n\t\t\tb.buildSubjectAltNameMatcher(&dst, policy.TLSServerName),\n\t\t},\n\t}\n\tif policy.TLSCustomCAFile != \"\" {\n\t\tvalidationContext.TrustedCa = b.filemgr.FileDataSource(policy.TLSCustomCAFile)\n\t} else if policy.TLSCustomCA != \"\" {\n\t\tbs, err := base64.StdEncoding.DecodeString(policy.TLSCustomCA)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"invalid custom CA certificate\")\n\t\t}\n\t\tvalidationContext.TrustedCa = b.filemgr.BytesDataSource(\"custom-ca.pem\", bs)\n\t} else {\n\t\tbs, err := getCombinedCertificateAuthority(options.CA, options.CAFile)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"unable to enable certificate verification because no root CAs were found\")\n\t\t} else {\n\t\t\tvalidationContext.TrustedCa = b.filemgr.BytesDataSource(\"ca.pem\", bs)\n\t\t}\n\t}\n\n\tif policy.TLSSkipVerify {\n\t\tvalidationContext.TrustChainVerification = envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_ACCEPT_UNTRUSTED\n\t}\n\n\treturn validationContext, nil\n}\n\nfunc (b *Builder) buildCluster(\n\tcluster *envoy_config_cluster_v3.Cluster,\n\tname string,\n\tendpoints []Endpoint,\n\tupstreamProtocol upstreamProtocolConfig,\n) error {\n\tif len(endpoints) == 0 {\n\t\treturn errNoEndpoints\n\t}\n\n\tif cluster.ConnectTimeout == nil {\n\t\tcluster.ConnectTimeout = defaultConnectionTimeout\n\t}\n\tcluster.RespectDnsTtl = true\n\tlbEndpoints, err := b.buildLbEndpoints(endpoints)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcluster.Name = name\n\tcluster.LoadAssignment = &envoy_config_endpoint_v3.ClusterLoadAssignment{\n\t\tClusterName: name,\n\t\tEndpoints: []*envoy_config_endpoint_v3.LocalityLbEndpoints{{\n\t\t\tLbEndpoints: lbEndpoints,\n\t\t}},\n\t}\n\tcluster.TransportSocketMatches, err = b.buildTransportSocketMatches(endpoints)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set the default transport socket to the first socket match. This is necessary so that ALPN\n\t// auto configuration works.\n\tif len(cluster.TransportSocketMatches) > 0 {\n\t\tcluster.TransportSocket = cluster.TransportSocketMatches[0].TransportSocket\n\t}\n\n\tcluster.TypedExtensionProtocolOptions = map[string]*anypb.Any{\n\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": marshalAny(buildUpstreamProtocolOptions(endpoints, upstreamProtocol)),\n\t}\n\n\tcluster.ClusterDiscoveryType = getClusterDiscoveryType(lbEndpoints)\n\n\treturn cluster.Validate()\n}\n\n// grpcAuthorizeOutlierDetection defines slightly more aggressive malfunction detection for authorize endpoints\nfunc grpcAuthorizeOutlierDetection() *envoy_config_cluster_v3.OutlierDetection {\n\treturn &envoy_config_cluster_v3.OutlierDetection{\n\t\tConsecutive_5Xx:                       wrapperspb.UInt32(5),\n\t\tInterval:                              durationpb.New(time.Second * 10),\n\t\tBaseEjectionTime:                      durationpb.New(time.Second * 30),\n\t\tMaxEjectionPercent:                    wrapperspb.UInt32(100),\n\t\tEnforcingConsecutive_5Xx:              wrapperspb.UInt32(100),\n\t\tEnforcingSuccessRate:                  wrapperspb.UInt32(100),\n\t\tSuccessRateMinimumHosts:               wrapperspb.UInt32(2),\n\t\tSuccessRateRequestVolume:              wrapperspb.UInt32(10),\n\t\tSuccessRateStdevFactor:                wrapperspb.UInt32(1900),\n\t\tConsecutiveGatewayFailure:             wrapperspb.UInt32(5),\n\t\tEnforcingConsecutiveGatewayFailure:    wrapperspb.UInt32(0),\n\t\tSplitExternalLocalOriginErrors:        false,\n\t\tFailurePercentageThreshold:            wrapperspb.UInt32(85),\n\t\tEnforcingFailurePercentage:            wrapperspb.UInt32(100),\n\t\tEnforcingFailurePercentageLocalOrigin: wrapperspb.UInt32(100),\n\t\tFailurePercentageMinimumHosts:         wrapperspb.UInt32(2),\n\t\tFailurePercentageRequestVolume:        wrapperspb.UInt32(10),\n\t\tMaxEjectionTime:                       durationpb.New(time.Minute * 5),\n\t}\n}\n\nfunc grpcHealthChecks(name string) []*envoy_config_core_v3.HealthCheck {\n\treturn []*envoy_config_core_v3.HealthCheck{{\n\t\tTimeout:               durationpb.New(time.Second * 10),\n\t\tInterval:              durationpb.New(time.Second * 10),\n\t\tInitialJitter:         durationpb.New(time.Millisecond * 100),\n\t\tIntervalJitter:        durationpb.New(time.Millisecond * 100),\n\t\tIntervalJitterPercent: 10,\n\t\tUnhealthyThreshold:    wrapperspb.UInt32(1),\n\t\tHealthyThreshold:      wrapperspb.UInt32(1),\n\t\tReuseConnection:       wrapperspb.Bool(true),\n\t\tNoTrafficInterval:     durationpb.New(time.Minute),\n\t\tHealthChecker: &envoy_config_core_v3.HealthCheck_GrpcHealthCheck_{\n\t\t\tGrpcHealthCheck: &envoy_config_core_v3.HealthCheck_GrpcHealthCheck{\n\t\t\t\tServiceName: name,\n\t\t\t},\n\t\t},\n\t}}\n}\n\nfunc (b *Builder) buildLbEndpoints(endpoints []Endpoint) ([]*envoy_config_endpoint_v3.LbEndpoint, error) {\n\tvar lbes []*envoy_config_endpoint_v3.LbEndpoint\n\tfor _, e := range endpoints {\n\t\tdefaultPort := 80\n\t\tif e.transportSocket != nil && e.transportSocket.Name == \"tls\" {\n\t\t\tdefaultPort = 443\n\t\t}\n\n\t\tu := e.url\n\t\tif e.url.Hostname() == \"localhost\" {\n\t\t\tu.Host = strings.Replace(e.url.Host, \"localhost\", \"127.0.0.1\", -1)\n\t\t}\n\n\t\tlbe := &envoy_config_endpoint_v3.LbEndpoint{\n\t\t\tHostIdentifier: &envoy_config_endpoint_v3.LbEndpoint_Endpoint{\n\t\t\t\tEndpoint: &envoy_config_endpoint_v3.Endpoint{\n\t\t\t\t\tAddress: buildAddress(u.Host, defaultPort),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLoadBalancingWeight: e.loadBalancerWeight,\n\t\t}\n\n\t\tif e.transportSocket != nil {\n\t\t\tlbe.Metadata = &envoy_config_core_v3.Metadata{\n\t\t\t\tFilterMetadata: map[string]*structpb.Struct{\n\t\t\t\t\t\"envoy.transport_socket_match\": {\n\t\t\t\t\t\tFields: map[string]*structpb.Value{\n\t\t\t\t\t\t\te.TransportSocketName(): structpb.NewBoolValue(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tlbes = append(lbes, lbe)\n\t}\n\treturn lbes, nil\n}\n\nfunc (b *Builder) buildTransportSocketMatches(endpoints []Endpoint) ([]*envoy_config_cluster_v3.Cluster_TransportSocketMatch, error) {\n\tvar tsms []*envoy_config_cluster_v3.Cluster_TransportSocketMatch\n\tseen := map[string]struct{}{}\n\tfor _, e := range endpoints {\n\t\tif e.transportSocket == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// only add unique transport sockets\n\t\tnm := e.TransportSocketName()\n\t\tif _, ok := seen[nm]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tseen[nm] = struct{}{}\n\n\t\ttsms = append(tsms, &envoy_config_cluster_v3.Cluster_TransportSocketMatch{\n\t\t\tName: nm,\n\t\t\tMatch: &structpb.Struct{\n\t\t\t\tFields: map[string]*structpb.Value{\n\t\t\t\t\tnm: structpb.NewBoolValue(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTransportSocket: e.transportSocket,\n\t\t})\n\t}\n\treturn tsms, nil\n}\n\n// validateClusters contains certain rules that must match\nfunc validateClusters(clusters []*envoy_config_cluster_v3.Cluster) error {\n\treturn validateClusterNamesUnique(clusters)\n}\n\n// validateClusterNamesUnique checks cluster names are unique, as they're effectively IDs\nfunc validateClusterNamesUnique(clusters []*envoy_config_cluster_v3.Cluster) error {\n\tnames := make(map[string]bool, len(clusters))\n\n\tfor _, c := range clusters {\n\t\tif _, there := names[c.Name]; there {\n\t\t\treturn fmt.Errorf(\"route %s is not unique\", c.Name)\n\t\t}\n\t\tnames[c.Name] = true\n\t}\n\n\treturn nil\n}\n\nfunc getClusterDiscoveryType(lbEndpoints []*envoy_config_endpoint_v3.LbEndpoint) *envoy_config_cluster_v3.Cluster_Type {\n\t// for IPs we use a static discovery type, otherwise we use DNS\n\tallIP := true\n\tfor _, lbe := range lbEndpoints {\n\t\tif net.ParseIP(urlutil.StripPort(lbe.GetEndpoint().GetAddress().GetSocketAddress().GetAddress())) == nil {\n\t\t\tallIP = false\n\t\t}\n\t}\n\tif allIP {\n\t\treturn &envoy_config_cluster_v3.Cluster_Type{Type: envoy_config_cluster_v3.Cluster_STATIC}\n\t}\n\treturn &envoy_config_cluster_v3.Cluster_Type{Type: envoy_config_cluster_v3.Cluster_STRICT_DNS}\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\tenvoy_config_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/volatiletech/null/v9\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n\t\"github.com/pomerium/pomerium/pkg/cryptutil\"\n)\n\nfunc Test_buildPolicyTransportSocket(t *testing.T) {\n\tctx := context.Background()\n\tcacheDir, _ := os.UserCacheDir()\n\tcustomCA := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"custom-ca-32484c314b584447463735303142374c31414145374650305a525539554938594d524855353757313942494d473847535231.pem\")\n\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\trootCABytes, _ := getCombinedCertificateAuthority(\"\", \"\")\n\trootCA := b.filemgr.BytesDataSource(\"ca.pem\", rootCABytes).GetFilename()\n\n\to1 := config.NewDefaultOptions()\n\to2 := config.NewDefaultOptions()\n\to2.CA = base64.StdEncoding.EncodeToString([]byte{0, 0, 0, 0})\n\n\tcombinedCABytes, _ := getCombinedCertificateAuthority(o2.CA, \"\")\n\tcombinedCA := b.filemgr.BytesDataSource(\"ca.pem\", combinedCABytes).GetFilename()\n\n\tt.Run(\"insecure\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://example.com\"),\n\t\t}, *mustParseURL(t, \"http://example.com\"))\n\t\trequire.NoError(t, err)\n\t\tassert.Nil(t, ts)\n\t})\n\tt.Run(\"host as sni\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"tls_server_name as sni\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:            mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tTLSServerName: \"use-this-name.example.com\",\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"use-this-name.example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"use-this-name.example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"tls_skip_verify\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:            mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tTLSSkipVerify: true,\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"trustChainVerification\": \"ACCEPT_UNTRUSTED\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"custom ca\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:          mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tTLSCustomCA: base64.StdEncoding.EncodeToString([]byte{0, 0, 0, 0}),\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+customCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"options custom ca\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o2, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+combinedCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"client certificate\", func(t *testing.T) {\n\t\tclientCert, _ := cryptutil.CertificateFromBase64(aExampleComCert, aExampleComKey)\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:                mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tClientCertificate: clientCert,\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"tlsCertificates\": [{\n\t\t\t\t\t\t\t\"certificateChain\":{\n\t\t\t\t\t\t\t\t\"filename\": \"`+filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-crt-354e49305a5a39414a545530374e58454e48334148524c4e324258463837364355564c4e4532464b54355139495547514a38.pem\")+`\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-key-3350415a38414e4e4a4655424e55393430474147324651433949384e485341334b5157364f424b4c5856365a545937383735.pem\")+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n}\n\nfunc Test_buildCluster(t *testing.T) {\n\tctx := context.Background()\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\trootCABytes, _ := getCombinedCertificateAuthority(\"\", \"\")\n\trootCA := b.filemgr.BytesDataSource(\"ca.pem\", rootCABytes).GetFilename()\n\to1 := config.NewDefaultOptions()\n\tt.Run(\"insecure\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://example.com\", \"http://1.2.3.4\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\tcluster.DnsLookupFamily = envoy_config_cluster_v3.Cluster_V4_ONLY\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STRICT_DNS\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"dnsLookupFamily\": \"V4_ONLY\",\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"1.2.3.4\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"secure\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t,\n\t\t\t\t\"https://example.com\",\n\t\t\t\t\"https://example.com\",\n\t\t\t),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STRICT_DNS\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"transportSocketMatches\": [{\n\t\t\t\t\t\"name\": \"`+endpoints[0].TransportSocketName()+`\",\n\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\"`+endpoints[0].TransportSocketName()+`\": true\n\t\t\t\t\t},\n\t\t\t\t\t\"transportSocket\": {\n\t\t\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}],\n\t\t\t\t\"transportSocket\": {\n\t\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 443\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\t\t\"envoy.transport_socket_match\": {\n\t\t\t\t\t\t\t\t\t\t\"`+endpoints[0].TransportSocketName()+`\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 443\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\t\t\"envoy.transport_socket_match\": {\n\t\t\t\t\t\t\t\t\t\t\"`+endpoints[0].TransportSocketName()+`\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"ip addresses\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://127.0.0.1\", \"http://127.0.0.2\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.2\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"weights\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://127.0.0.1:8080,1\", \"http://127.0.0.2,2\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 8080\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"loadBalancingWeight\": 1\n\t\t\t\t\t\t},{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.2\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"loadBalancingWeight\": 2\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"localhost\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://localhost\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"outlier\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://example.com\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\tcluster.DnsLookupFamily = envoy_config_cluster_v3.Cluster_V4_ONLY\n\t\tcluster.OutlierDetection = &envoy_config_cluster_v3.OutlierDetection{\n\t\t\tEnforcingConsecutive_5Xx:       wrapperspb.UInt32(17),\n\t\t\tSplitExternalLocalOriginErrors: true,\n\t\t}\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STRICT_DNS\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"dnsLookupFamily\": \"V4_ONLY\",\n\t\t\t\t\"outlierDetection\": {\n\t\t\t\t\t\"enforcingConsecutive5xx\": 17,\n\t\t\t\t\t\"splitExternalLocalOriginErrors\": true\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n}\n\nfunc Test_validateClusters(t *testing.T) {\n\ttype c []*envoy_config_cluster_v3.Cluster\n\ttestCases := []struct {\n\t\tclusters    c\n\t\texpectError bool\n\t}{\n\t\t{c{{Name: \"one\"}, {Name: \"one\"}}, true},\n\t\t{c{{Name: \"one\"}, {Name: \"two\"}}, false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\terr := validateClusters(tc.clusters)\n\t\tif tc.expectError {\n\t\t\tassert.Error(t, err, \"%#v\", tc.clusters)\n\t\t} else {\n\t\t\tassert.NoError(t, err, \"%#v\", tc.clusters)\n\t\t}\n\t}\n}\n\nfunc Test_bindConfig(t *testing.T) {\n\tctx, clearTimeout := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer clearTimeout()\n\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\tt.Run(\"no bind config\", func(t *testing.T) {\n\t\tcluster, err := b.buildPolicyCluster(ctx, &config.Options{}, &config.Policy{\n\t\t\tFrom: \"https://from.example.com\",\n\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, cluster.UpstreamBindConfig)\n\t})\n\tt.Run(\"freebind\", func(t *testing.T) {\n\t\tcluster, err := b.buildPolicyCluster(ctx, &config.Options{\n\t\t\tEnvoyBindConfigFreebind: null.BoolFrom(true),\n\t\t}, &config.Policy{\n\t\t\tFrom: \"https://from.example.com\",\n\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"freebind\": true,\n\t\t\t\t\"sourceAddress\": {\n\t\t\t\t\t\"address\": \"0.0.0.0\",\n\t\t\t\t\t\"portValue\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster.UpstreamBindConfig)\n\t})\n\tt.Run(\"source address\", func(t *testing.T) {\n\t\tcluster, err := b.buildPolicyCluster(ctx, &config.Options{\n\t\t\tEnvoyBindConfigSourceAddress: \"192.168.0.1\",\n\t\t}, &config.Policy{\n\t\t\tFrom: \"https://from.example.com\",\n\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"sourceAddress\": {\n\t\t\t\t\t\"address\": \"192.168.0.1\",\n\t\t\t\t\t\"portValue\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster.UpstreamBindConfig)\n\t})\n}\n\nfunc mustParseWeightedURLs(t *testing.T, urls ...string) []config.WeightedURL {\n\twu, err := config.ParseWeightedUrls(urls...)\n\trequire.NoError(t, err)\n\treturn wu\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"sort\"\n\t\"time\"\n\n\tenvoy_config_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_config_listener_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_extensions_filters_http_ext_authz_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ext_authz/v3\"\n\tenvoy_extensions_filters_http_lua_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/lua/v3\"\n\tenvoy_extensions_filters_listener_proxy_protocol_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/proxy_protocol/v3\"\n\tenvoy_http_connection_manager \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3\"\n\tenvoy_extensions_transport_sockets_tls_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3\"\n\tenvoy_type_v3 \"github.com/envoyproxy/go-control-plane/envoy/type/v3\"\n\t\"github.com/golang/protobuf/ptypes/any\"\n\t\"github.com/golang/protobuf/ptypes/wrappers\"\n\t\"github.com/scylladb/go-set\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/hashutil\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n\t\"github.com/pomerium/pomerium/pkg/cryptutil\"\n)\n\nconst listenerBufferLimit uint32 = 32 * 1024\n\nvar (\n\tdisableExtAuthz *any.Any\n\ttlsParams       = &envoy_extensions_transport_sockets_tls_v3.TlsParameters{\n\t\tCipherSuites: []string{\n\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t},\n\t\tTlsMinimumProtocolVersion: envoy_extensions_transport_sockets_tls_v3.TlsParameters_TLSv1_2,\n\t}\n)\n\nfunc init() {\n\tdisableExtAuthz = marshalAny(&envoy_extensions_filters_http_ext_authz_v3.ExtAuthzPerRoute{\n\t\tOverride: &envoy_extensions_filters_http_ext_authz_v3.ExtAuthzPerRoute_Disabled{\n\t\t\tDisabled: true,\n\t\t},\n\t})\n}\n\n// BuildListeners builds envoy listeners from the given config.\nfunc (b *Builder) BuildListeners(ctx context.Context, cfg *config.Config) ([]*envoy_config_listener_v3.Listener, error) {\n\tvar listeners []*envoy_config_listener_v3.Listener\n\n\tif config.IsAuthenticate(cfg.Options.Services) || config.IsProxy(cfg.Options.Services) {\n\t\tli, err := b.buildMainListener(ctx, cfg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, li)\n\t}\n\n\tif config.IsAuthorize(cfg.Options.Services) || config.IsDataBroker(cfg.Options.Services) {\n\t\tli, err := b.buildGRPCListener(ctx, cfg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, li)\n\t}\n\n\tif cfg.Options.MetricsAddr != \"\" {\n\t\tli, err := b.buildMetricsListener(cfg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, li)\n\t}\n\n\tli, err := b.buildOutboundListener(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlisteners = append(listeners, li)\n\n\treturn listeners, nil\n}\n\nfunc (b *Builder) buildMainListener(ctx context.Context, cfg *config.Config) (*envoy_config_listener_v3.Listener, error) {\n\tlistenerFilters := []*envoy_config_listener_v3.ListenerFilter{}\n\tif cfg.Options.UseProxyProtocol {\n\t\tproxyCfg := marshalAny(&envoy_extensions_filters_listener_proxy_protocol_v3.ProxyProtocol{})\n\t\tlistenerFilters = append(listenerFilters, &envoy_config_listener_v3.ListenerFilter{\n\t\t\tName: \"envoy.filters.listener.proxy_protocol\",\n\t\t\tConfigType: &envoy_config_listener_v3.ListenerFilter_TypedConfig{\n\t\t\t\tTypedConfig: proxyCfg,\n\t\t\t},\n\t\t})\n\t}\n\n\tif cfg.Options.InsecureServer {\n\t\tallDomains, err := getAllRouteableDomains(cfg.Options, cfg.Options.Addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfilter, err := b.buildMainHTTPConnectionManagerFilter(cfg.Options, allDomains, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tli := newEnvoyListener(\"http-ingress\")\n\t\tli.Address = buildAddress(cfg.Options.Addr, 80)\n\t\tli.ListenerFilters = listenerFilters\n\t\tli.FilterChains = []*envoy_config_listener_v3.FilterChain{{\n\t\t\tFilters: []*envoy_config_listener_v3.Filter{\n\t\t\t\tfilter,\n\t\t\t},\n\t\t}}\n\t\treturn li, nil\n\t}\n\n\ttlsInspectorCfg := marshalAny(new(emptypb.Empty))\n\tlistenerFilters = append(listenerFilters, &envoy_config_listener_v3.ListenerFilter{\n\t\tName: \"envoy.filters.listener.tls_inspector\",\n\t\tConfigType: &envoy_config_listener_v3.ListenerFilter_TypedConfig{\n\t\t\tTypedConfig: tlsInspectorCfg,\n\t\t},\n\t})\n\n\tchains, err := b.buildFilterChains(cfg.Options, cfg.Options.Addr,\n\t\tfunc(tlsDomain string, httpDomains []string) (*envoy_config_listener_v3.FilterChain, error) {\n\t\t\tfilter, err := b.buildMainHTTPConnectionManagerFilter(cfg.Options, httpDomains, tlsDomain)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfilterChain := &envoy_config_listener_v3.FilterChain{\n\t\t\t\tFilters: []*envoy_config_listener_v3.Filter{filter},\n\t\t\t}\n\t\t\tif tlsDomain != \"*\" {\n\t\t\t\tfilterChain.FilterChainMatch = &envoy_config_listener_v3.FilterChainMatch{\n\t\t\t\t\tServerNames: []string{tlsDomain},\n\t\t\t\t}\n\t\t\t}\n\t\t\ttlsContext := b.buildDownstreamTLSContext(ctx, cfg, tlsDomain)\n\t\t\tif tlsContext != nil {\n\t\t\t\ttlsConfig := marshalAny(tlsContext)\n\t\t\t\tfilterChain.TransportSocket = &envoy_config_core_v3.TransportSocket{\n\t\t\t\t\tName: \"tls\",\n\t\t\t\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\t\t\t\tTypedConfig: tlsConfig,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filterChain, nil\n\t\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tli := newEnvoyListener(\"https-ingress\")\n\tli.Address = buildAddress(cfg.Options.Addr, 443)\n\tli.ListenerFilters = listenerFilters\n\tli.FilterChains = chains\n\treturn li, nil\n}\n\nfunc (b *Builder) buildMetricsListener(cfg *config.Config) (*envoy_config_listener_v3.Listener, error) {\n\tfilter, err := b.buildMetricsHTTPConnectionManagerFilter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilterChain := &envoy_config_listener_v3.FilterChain{\n\t\tFilters: []*envoy_config_listener_v3.Filter{\n\t\t\tfilter,\n\t\t},\n\t}\n\n\tcert, err := cfg.Options.GetMetricsCertificate()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif cert != nil {\n\t\tdtc := &envoy_extensions_transport_sockets_tls_v3.DownstreamTlsContext{\n\t\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\t\tTlsParams: tlsParams,\n\t\t\t\tTlsCertificates: []*envoy_extensions_transport_sockets_tls_v3.TlsCertificate{\n\t\t\t\t\tb.envoyTLSCertificateFromGoTLSCertificate(context.TODO(), cert),\n\t\t\t\t},\n\t\t\t\tAlpnProtocols: []string{\"h2\", \"http/1.1\"},\n\t\t\t},\n\t\t}\n\n\t\tif cfg.Options.MetricsClientCA != \"\" {\n\t\t\tbs, err := base64.StdEncoding.DecodeString(cfg.Options.MetricsClientCA)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"xds: invalid metrics_client_ca: %w\", err)\n\t\t\t}\n\n\t\t\tdtc.RequireClientCertificate = wrapperspb.Bool(true)\n\t\t\tdtc.CommonTlsContext.ValidationContextType = &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\t\t\t\tTrustChainVerification: envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_VERIFY_TRUST_CHAIN,\n\t\t\t\t\tTrustedCa:              b.filemgr.BytesDataSource(\"metrics_client_ca.pem\", bs),\n\t\t\t\t},\n\t\t\t}\n\t\t} else if cfg.Options.MetricsClientCAFile != \"\" {\n\t\t\tdtc.RequireClientCertificate = wrapperspb.Bool(true)\n\t\t\tdtc.CommonTlsContext.ValidationContextType = &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\t\t\t\tTrustChainVerification: envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_VERIFY_TRUST_CHAIN,\n\t\t\t\t\tTrustedCa:              b.filemgr.FileDataSource(cfg.Options.MetricsClientCAFile),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\ttc := marshalAny(dtc)\n\t\tfilterChain.TransportSocket = &envoy_config_core_v3.TransportSocket{\n\t\t\tName: \"tls\",\n\t\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\t\tTypedConfig: tc,\n\t\t\t},\n\t\t}\n\t}\n\n\t// we ignore the host part of the address, only binding to\n\thost, port, err := net.SplitHostPort(cfg.Options.MetricsAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"metrics_addr %s: %w\", cfg.Options.MetricsAddr, err)\n\t}\n\tif port == \"\" {\n\t\treturn nil, fmt.Errorf(\"metrics_addr %s: port is required\", cfg.Options.MetricsAddr)\n\t}\n\t// unless an explicit IP address was provided, and bind to all interfaces if hostname was provided\n\tif net.ParseIP(host) == nil {\n\t\thost = \"\"\n\t}\n\n\taddr := buildAddress(fmt.Sprintf(\"%s:%s\", host, port), 9902)\n\tli := newEnvoyListener(fmt.Sprintf(\"metrics-ingress-%d\", hashutil.MustHash(addr)))\n\tli.Address = addr\n\tli.FilterChains = []*envoy_config_listener_v3.FilterChain{filterChain}\n\treturn li, nil\n}\n\nfunc (b *Builder) buildFilterChains(\n\toptions *config.Options, addr string,\n\tcallback func(tlsDomain string, httpDomains []string) (*envoy_config_listener_v3.FilterChain, error),\n) ([]*envoy_config_listener_v3.FilterChain, error) {\n\tallDomains, err := getAllRouteableDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsDomains, err := getAllTLSDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar chains []*envoy_config_listener_v3.FilterChain\n\tfor _, domain := range tlsDomains {\n\t\trouteableDomains, err := getRouteableDomainsForTLSDomain(options, addr, domain)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// first we match on SNI\n\t\tchain, err := callback(domain, routeableDomains)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tchains = append(chains, chain)\n\t}\n\n\t// if there are no SNI matches we match on HTTP host\n\tchain, err := callback(\"*\", allDomains)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchains = append(chains, chain)\n\treturn chains, nil\n}\n\nfunc (b *Builder) buildMainHTTPConnectionManagerFilter(\n\toptions *config.Options,\n\tdomains []string,\n\ttlsDomain string,\n) (*envoy_config_listener_v3.Filter, error) {\n\tauthorizeURLs, err := options.GetInternalAuthorizeURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdataBrokerURLs, err := options.GetInternalDataBrokerURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar virtualHosts []*envoy_config_route_v3.VirtualHost\n\tfor _, domain := range domains {\n\t\tvh, err := b.buildVirtualHost(options, domain, domain)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif options.Addr == options.GetGRPCAddr() {\n\t\t\t// if this is a gRPC service domain and we're supposed to handle that, add those routes\n\t\t\tif (config.IsAuthorize(options.Services) && hostsMatchDomain(authorizeURLs, domain)) ||\n\t\t\t\t(config.IsDataBroker(options.Services) && hostsMatchDomain(dataBrokerURLs, domain)) {\n\t\t\t\trs, err := b.buildGRPCRoutes()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tvh.Routes = append(vh.Routes, rs...)\n\t\t\t}\n\t\t}\n\n\t\t// if we're the proxy, add all the policy routes\n\t\tif config.IsProxy(options.Services) {\n\t\t\trs, err := b.buildPolicyRoutes(options, domain)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvh.Routes = append(vh.Routes, rs...)\n\t\t}\n\n\t\tif len(vh.Routes) > 0 {\n\t\t\tvirtualHosts = append(virtualHosts, vh)\n\t\t}\n\t}\n\n\tvh, err := b.buildVirtualHost(options, \"catch-all\", \"*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvirtualHosts = append(virtualHosts, vh)\n\n\tvar grpcClientTimeout *durationpb.Duration\n\tif options.GRPCClientTimeout != 0 {\n\t\tgrpcClientTimeout = durationpb.New(options.GRPCClientTimeout)\n\t} else {\n\t\tgrpcClientTimeout = durationpb.New(30 * time.Second)\n\t}\n\n\textAuthZ := marshalAny(&envoy_extensions_filters_http_ext_authz_v3.ExtAuthz{\n\t\tStatusOnError: &envoy_type_v3.HttpStatus{\n\t\t\tCode: envoy_type_v3.StatusCode_InternalServerError,\n\t\t},\n\t\tServices: &envoy_extensions_filters_http_ext_authz_v3.ExtAuthz_GrpcService{\n\t\t\tGrpcService: &envoy_config_core_v3.GrpcService{\n\t\t\t\tTimeout: grpcClientTimeout,\n\t\t\t\tTargetSpecifier: &envoy_config_core_v3.GrpcService_EnvoyGrpc_{\n\t\t\t\t\tEnvoyGrpc: &envoy_config_core_v3.GrpcService_EnvoyGrpc{\n\t\t\t\t\t\tClusterName: \"pomerium-authorize\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tIncludePeerCertificate: true,\n\t\tTransportApiVersion:    envoy_config_core_v3.ApiVersion_V3,\n\t})\n\n\textAuthzSetCookieLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.ExtAuthzSetCookie,\n\t})\n\tcleanUpstreamLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.CleanUpstream,\n\t})\n\tremoveImpersonateHeadersLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.RemoveImpersonateHeaders,\n\t})\n\trewriteHeadersLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.RewriteHeaders,\n\t})\n\n\tfilters := []*envoy_http_connection_manager.HttpFilter{\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: removeImpersonateHeadersLua,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.ext_authz\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: extAuthZ,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: extAuthzSetCookieLua,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: cleanUpstreamLua,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: rewriteHeadersLua,\n\t\t\t},\n\t\t},\n\t}\n\tif tlsDomain != \"\" && tlsDomain != \"*\" {\n\t\tfixMisdirectedLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\t\tInlineCode: fmt.Sprintf(luascripts.FixMisdirected, tlsDomain),\n\t\t})\n\t\tfilters = append(filters, &envoy_http_connection_manager.HttpFilter{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: fixMisdirectedLua,\n\t\t\t},\n\t\t})\n\t}\n\tfilters = append(filters, &envoy_http_connection_manager.HttpFilter{\n\t\tName: \"envoy.filters.http.router\",\n\t})\n\n\tvar maxStreamDuration *durationpb.Duration\n\tif options.WriteTimeout > 0 {\n\t\tmaxStreamDuration = durationpb.New(options.WriteTimeout)\n\t}\n\n\trc, err := b.buildRouteConfiguration(\"main\", virtualHosts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttracingProvider, err := buildTracingHTTP(options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttc := marshalAny(&envoy_http_connection_manager.HttpConnectionManager{\n\t\tCodecType:  options.GetCodecType().ToEnvoy(),\n\t\tStatPrefix: \"ingress\",\n\t\tRouteSpecifier: &envoy_http_connection_manager.HttpConnectionManager_RouteConfig{\n\t\t\tRouteConfig: rc,\n\t\t},\n\t\tHttpFilters: filters,\n\t\tAccessLog:   buildAccessLogs(options),\n\t\tCommonHttpProtocolOptions: &envoy_config_core_v3.HttpProtocolOptions{\n\t\t\tIdleTimeout:       durationpb.New(options.IdleTimeout),\n\t\t\tMaxStreamDuration: maxStreamDuration,\n\t\t},\n\t\tRequestTimeout: durationpb.New(options.ReadTimeout),\n\t\tTracing: &envoy_http_connection_manager.HttpConnectionManager_Tracing{\n\t\t\tRandomSampling: &envoy_type_v3.Percent{Value: options.TracingSampleRate * 100},\n\t\t\tProvider:       tracingProvider,\n\t\t},\n\t\t// See https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#x-forwarded-for\n\t\tUseRemoteAddress:  &wrappers.BoolValue{Value: true},\n\t\tSkipXffAppend:     options.SkipXffAppend,\n\t\tXffNumTrustedHops: options.XffNumTrustedHops,\n\t\tLocalReplyConfig:  b.buildLocalReplyConfig(options),\n\t})\n\n\treturn &envoy_config_listener_v3.Filter{\n\t\tName: \"envoy.filters.network.http_connection_manager\",\n\t\tConfigType: &envoy_config_listener_v3.Filter_TypedConfig{\n\t\t\tTypedConfig: tc,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildMetricsHTTPConnectionManagerFilter() (*envoy_config_listener_v3.Filter, error) {\n\trc, err := b.buildRouteConfiguration(\"metrics\", []*envoy_config_route_v3.VirtualHost{{\n\t\tName:    \"metrics\",\n\t\tDomains: []string{\"*\"},\n\t\tRoutes: []*envoy_config_route_v3.Route{{\n\t\t\tName: \"metrics\",\n\t\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: \"/\"},\n\t\t\t},\n\t\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\t\tCluster: \"pomerium-control-plane-http\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttc := marshalAny(&envoy_http_connection_manager.HttpConnectionManager{\n\t\tCodecType:  envoy_http_connection_manager.HttpConnectionManager_AUTO,\n\t\tStatPrefix: \"metrics\",\n\t\tRouteSpecifier: &envoy_http_connection_manager.HttpConnectionManager_RouteConfig{\n\t\t\tRouteConfig: rc,\n\t\t},\n\t\tHttpFilters: []*envoy_http_connection_manager.HttpFilter{{\n\t\t\tName: \"envoy.filters.http.router\",\n\t\t}},\n\t})\n\n\treturn &envoy_config_listener_v3.Filter{\n\t\tName: \"envoy.filters.network.http_connection_manager\",\n\t\tConfigType: &envoy_config_listener_v3.Filter_TypedConfig{\n\t\t\tTypedConfig: tc,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildGRPCListener(ctx context.Context, cfg *config.Config) (*envoy_config_listener_v3.Listener, error) {\n\tfilter, err := b.buildGRPCHTTPConnectionManagerFilter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Options.GetGRPCInsecure() {\n\t\tli := newEnvoyListener(\"grpc-ingress\")\n\t\tli.Address = buildAddress(cfg.Options.GetGRPCAddr(), 80)\n\t\tli.FilterChains = []*envoy_config_listener_v3.FilterChain{{\n\t\t\tFilters: []*envoy_config_listener_v3.Filter{\n\t\t\t\tfilter,\n\t\t\t},\n\t\t}}\n\t\treturn li, nil\n\t}\n\n\tchains, err := b.buildFilterChains(cfg.Options, cfg.Options.GRPCAddr,\n\t\tfunc(tlsDomain string, httpDomains []string) (*envoy_config_listener_v3.FilterChain, error) {\n\t\t\tfilterChain := &envoy_config_listener_v3.FilterChain{\n\t\t\t\tFilters: []*envoy_config_listener_v3.Filter{filter},\n\t\t\t}\n\t\t\tif tlsDomain != \"*\" {\n\t\t\t\tfilterChain.FilterChainMatch = &envoy_config_listener_v3.FilterChainMatch{\n\t\t\t\t\tServerNames: []string{tlsDomain},\n\t\t\t\t}\n\t\t\t}\n\t\t\ttlsContext := b.buildDownstreamTLSContext(ctx, cfg, tlsDomain)\n\t\t\tif tlsContext != nil {\n\t\t\t\ttlsConfig := marshalAny(tlsContext)\n\t\t\t\tfilterChain.TransportSocket = &envoy_config_core_v3.TransportSocket{\n\t\t\t\t\tName: \"tls\",\n\t\t\t\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\t\t\t\tTypedConfig: tlsConfig,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filterChain, nil\n\t\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsInspectorCfg := marshalAny(new(emptypb.Empty))\n\tli := newEnvoyListener(\"grpc-ingress\")\n\tli.Address = buildAddress(cfg.Options.GetGRPCAddr(), 443)\n\tli.ListenerFilters = []*envoy_config_listener_v3.ListenerFilter{{\n\t\tName: \"envoy.filters.listener.tls_inspector\",\n\t\tConfigType: &envoy_config_listener_v3.ListenerFilter_TypedConfig{\n\t\t\tTypedConfig: tlsInspectorCfg,\n\t\t},\n\t}}\n\tli.FilterChains = chains\n\treturn li, nil\n}\n\nfunc (b *Builder) buildGRPCHTTPConnectionManagerFilter() (*envoy_config_listener_v3.Filter, error) {\n\trc, err := b.buildRouteConfiguration(\"grpc\", []*envoy_config_route_v3.VirtualHost{{\n\t\tName:    \"grpc\",\n\t\tDomains: []string{\"*\"},\n\t\tRoutes: []*envoy_config_route_v3.Route{{\n\t\t\tName: \"grpc\",\n\t\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: \"/\"},\n\t\t\t\tGrpc:          &envoy_config_route_v3.RouteMatch_GrpcRouteMatchOptions{},\n\t\t\t},\n\t\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\t\tCluster: \"pomerium-control-plane-grpc\",\n\t\t\t\t\t},\n\t\t\t\t\t// disable the timeout to support grpc streaming\n\t\t\t\t\tTimeout: &durationpb.Duration{\n\t\t\t\t\t\tSeconds: 0,\n\t\t\t\t\t},\n\t\t\t\t\tIdleTimeout: &durationpb.Duration{\n\t\t\t\t\t\tSeconds: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttc := marshalAny(&envoy_http_connection_manager.HttpConnectionManager{\n\t\tCodecType:  envoy_http_connection_manager.HttpConnectionManager_AUTO,\n\t\tStatPrefix: \"grpc_ingress\",\n\t\t// limit request first byte to last byte time\n\t\tRequestTimeout: &durationpb.Duration{\n\t\t\tSeconds: 15,\n\t\t},\n\t\tRouteSpecifier: &envoy_http_connection_manager.HttpConnectionManager_RouteConfig{\n\t\t\tRouteConfig: rc,\n\t\t},\n\t\tHttpFilters: []*envoy_http_connection_manager.HttpFilter{{\n\t\t\tName: \"envoy.filters.http.router\",\n\t\t}},\n\t})\n\treturn &envoy_config_listener_v3.Filter{\n\t\tName: \"envoy.filters.network.http_connection_manager\",\n\t\tConfigType: &envoy_config_listener_v3.Filter_TypedConfig{\n\t\t\tTypedConfig: tc,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildRouteConfiguration(name string, virtualHosts []*envoy_config_route_v3.VirtualHost) (*envoy_config_route_v3.RouteConfiguration, error) {\n\treturn &envoy_config_route_v3.RouteConfiguration{\n\t\tName:         name,\n\t\tVirtualHosts: virtualHosts,\n\t\t// disable cluster validation since the order of LDS/CDS updates isn't guaranteed\n\t\tValidateClusters: &wrappers.BoolValue{Value: false},\n\t}, nil\n}\n\nfunc (b *Builder) buildDownstreamTLSContext(ctx context.Context,\n\tcfg *config.Config,\n\tdomain string,\n) *envoy_extensions_transport_sockets_tls_v3.DownstreamTlsContext {\n\tcerts, err := cfg.AllCertificates()\n\tif err != nil {\n\t\tlog.Warn(ctx).Str(\"domain\", domain).Err(err).Msg(\"failed to get all certificates from config\")\n\t\treturn nil\n\t}\n\n\tcert, err := cryptutil.GetCertificateForDomain(certs, domain)\n\tif err != nil {\n\t\tlog.Warn(ctx).Str(\"domain\", domain).Err(err).Msg(\"failed to get certificate for domain\")\n\t\treturn nil\n\t}\n\n\terr = validateCertificate(cert)\n\tif err != nil {\n\t\tlog.Warn(ctx).Str(\"domain\", domain).Err(err).Msg(\"invalid certificate for domain\")\n\t\treturn nil\n\t}\n\n\tvar alpnProtocols []string\n\tswitch cfg.Options.GetCodecType() {\n\tcase config.CodecTypeHTTP1:\n\t\talpnProtocols = []string{\"http/1.1\"}\n\tcase config.CodecTypeHTTP2:\n\t\talpnProtocols = []string{\"h2\"}\n\tdefault:\n\t\talpnProtocols = []string{\"h2\", \"http/1.1\"}\n\t}\n\n\tenvoyCert := b.envoyTLSCertificateFromGoTLSCertificate(ctx, cert)\n\treturn &envoy_extensions_transport_sockets_tls_v3.DownstreamTlsContext{\n\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\tTlsParams:             tlsParams,\n\t\t\tTlsCertificates:       []*envoy_extensions_transport_sockets_tls_v3.TlsCertificate{envoyCert},\n\t\t\tAlpnProtocols:         alpnProtocols,\n\t\t\tValidationContextType: b.buildDownstreamValidationContext(ctx, cfg, domain),\n\t\t},\n\t}\n}\n\nfunc (b *Builder) buildDownstreamValidationContext(ctx context.Context,\n\tcfg *config.Config,\n\tdomain string,\n) *envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext {\n\tneedsClientCert := false\n\n\tif ca, _ := cfg.Options.GetClientCA(); len(ca) > 0 {\n\t\tneedsClientCert = true\n\t}\n\tif !needsClientCert {\n\t\tfor _, p := range getPoliciesForDomain(cfg.Options, domain) {\n\t\t\tif p.TLSDownstreamClientCA != \"\" {\n\t\t\t\tneedsClientCert = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !needsClientCert {\n\t\treturn nil\n\t}\n\n\t// trusted_ca is left blank because we verify the client certificate in the authorize service\n\tvc := &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\tValidationContext: &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\t\tTrustChainVerification: envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_ACCEPT_UNTRUSTED,\n\t\t},\n\t}\n\n\tif cfg.Options.ClientCRL != \"\" {\n\t\tbs, err := base64.StdEncoding.DecodeString(cfg.Options.ClientCRL)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"invalid client CRL\")\n\t\t} else {\n\t\t\tvc.ValidationContext.Crl = b.filemgr.BytesDataSource(\"client-crl.pem\", bs)\n\t\t}\n\t} else if cfg.Options.ClientCRLFile != \"\" {\n\t\tvc.ValidationContext.Crl = b.filemgr.FileDataSource(cfg.Options.ClientCRLFile)\n\t}\n\n\treturn vc\n}\n\nfunc getRouteableDomainsForTLSDomain(options *config.Options, addr string, tlsDomain string) ([]string, error) {\n\tallDomains, err := getAllRouteableDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar filtered []string\n\tfor _, domain := range allDomains {\n\t\tif urlutil.StripPort(domain) == tlsDomain {\n\t\t\tfiltered = append(filtered, domain)\n\t\t}\n\t}\n\treturn filtered, nil\n}\n\nfunc getAllRouteableDomains(options *config.Options, addr string) ([]string, error) {\n\tallDomains := set.NewStringSet()\n\n\tif addr == options.Addr {\n\t\tdomains, err := options.GetAllRouteableHTTPDomains()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tallDomains.Add(domains...)\n\t}\n\n\tif addr == options.GetGRPCAddr() {\n\t\tdomains, err := options.GetAllRouteableGRPCDomains()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tallDomains.Add(domains...)\n\t}\n\n\tdomains := allDomains.List()\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\nfunc getAllTLSDomains(options *config.Options, addr string) ([]string, error) {\n\tallDomains, err := getAllRouteableDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlookup := map[string]struct{}{}\n\tfor _, hp := range allDomains {\n\t\tif d, _, err := net.SplitHostPort(hp); err == nil {\n\t\t\tlookup[d] = struct{}{}\n\t\t} else {\n\t\t\tlookup[hp] = struct{}{}\n\t\t}\n\t}\n\n\tdomains := make([]string, 0, len(lookup))\n\tfor domain := range lookup {\n\t\tdomains = append(domains, domain)\n\t}\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\nfunc hostsMatchDomain(urls []*url.URL, host string) bool {\n\tfor _, u := range urls {\n\t\tif hostMatchesDomain(u, host) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc hostMatchesDomain(u *url.URL, host string) bool {\n\tif u == nil {\n\t\treturn false\n\t}\n\n\tvar defaultPort string\n\tif u.Scheme == \"http\" {\n\t\tdefaultPort = \"80\"\n\t} else {\n\t\tdefaultPort = \"443\"\n\t}\n\n\th1, p1, err := net.SplitHostPort(u.Host)\n\tif err != nil {\n\t\th1 = u.Host\n\t\tp1 = defaultPort\n\t}\n\n\th2, p2, err := net.SplitHostPort(host)\n\tif err != nil {\n\t\th2 = host\n\t\tp2 = defaultPort\n\t}\n\n\treturn h1 == h2 && p1 == p2\n}\n\nfunc getPoliciesForDomain(options *config.Options, domain string) []config.Policy {\n\tvar policies []config.Policy\n\tfor _, p := range options.GetAllPolicies() {\n\t\tif p.Source != nil && p.Source.URL.Hostname() == domain {\n\t\t\tpolicies = append(policies, p)\n\t\t}\n\t}\n\treturn policies\n}\n\n// newEnvoyListener creates envoy listener with certain default values\nfunc newEnvoyListener(name string) *envoy_config_listener_v3.Listener {\n\treturn &envoy_config_listener_v3.Listener{\n\t\tName:                          name,\n\t\tPerConnectionBufferLimitBytes: wrapperspb.UInt32(listenerBufferLimit),\n\t}\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n)\n\nconst (\n\taExampleComCert = `LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVQVENDQXFXZ0F3SUJBZ0lSQUlWMDhHSVFYTWRVT0NXV3FocXlGR3N3RFFZSktvWklodmNOQVFFTEJRQXcKY3pFZU1Cd0dBMVVFQ2hNVmJXdGpaWEowSUdSbGRtVnNiM0J0Wlc1MElFTkJNU1F3SWdZRFZRUUxEQnRqWVd4bApZa0J3YjNBdGIzTWdLRU5oYkdWaUlFUnZlSE5sZVNreEt6QXBCZ05WQkFNTUltMXJZMlZ5ZENCallXeGxZa0J3CmIzQXRiM01nS0VOaGJHVmlJRVJ2ZUhObGVTa3dIaGNOTVRrd05qQXhNREF3TURBd1doY05NekF3TlRJeU1qRXoKT0RRMFdqQlBNU2N3SlFZRFZRUUtFeDV0YTJObGNuUWdaR1YyWld4dmNHMWxiblFnWTJWeWRHbG1hV05oZEdVeApKREFpQmdOVkJBc01HMk5oYkdWaVFIQnZjQzF2Y3lBb1EyRnNaV0lnUkc5NGMyVjVLVENDQVNJd0RRWUpLb1pJCmh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTm1HMWFKaXc0L29SMHFqUDMxUjRXeTZkOUVqZHc5K1kyelQKcjBDbGNYTDYxRk11R0YrKzJRclV6Y0VUZlZ2dGM1OXNQa0xkRHNtZ0Y2VlZCOTkyQ3ArWDlicWczWmQwSXZtbApVbjJvdTM5eUNEYnV2Q0E2d1gwbGNHL2JkRDE3TkRrS0poL3g5SDMzU3h4SG5UamlKdFBhbmt1MUI3ajdtRmM5Ck5jNXRyamFvUHBGaFJqMTJ1L0dWajRhWWs3SStpWHRpZHBjZXp2eWNDT0NtQlIwNHkzeWx5Q2sxSWNMTUhWOEEKNXphUFpVck15ZUtnTE1PTGlDSDBPeHhhUzh0Nk5vTjZudDdmOUp1TUxTN2V5SkxkQW05bGg0c092YXBPVklXZgpJQitaYnk5bkQ1dWl4N3V0a3llWTFOeE05SFZhUmZTQzcrejM4TDBWN3lJZlpCNkFLcWNDQXdFQUFhTndNRzR3CkRnWURWUjBQQVFIL0JBUURBZ1dnTUJNR0ExVWRKUVFNTUFvR0NDc0dBUVVGQndNQk1Bd0dBMVVkRXdFQi93UUMKTUFBd0h3WURWUjBqQkJnd0ZvQVVTaG9mWE5rY1hoMnE0d25uV1oyYmNvMjRYRVF3R0FZRFZSMFJCQkV3RDRJTgpZUzVsZUdGdGNHeGxMbU52YlRBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVlFQVA3aHVraThGeG54azRoVnJYUk93Ck51Uy9OUFhmQ3VaVDZWemJYUVUxbWNrZmhweVNDajVRZkFDQzdodVp6Qkp0NEtsUHViWHdRQ25YMFRMSmg1L0cKUzZBWEFXQ3VTSW5jTTZxNGs4MFAzVllWK3hXOS9rdERnTk1FTlNxSjdKR3lqdzBWWHlhOUZwdWd6Q3ZnN290RQo5STcrZTN0cmJnUDBHY3plSml6WTJBMVBWU082MVdKQ1lNQjNDLzcwVE9KMkZTNy82bURPTG9DSVJCY215cW5KClY2Vk5sRDl3Y2xmUWIrZUp0YlY0Vlg2RUY5UEYybUtncUNKT0FKLzBoMHAydTBhZGgzMkJDS2dIMDRSYUtuSS8KUzY1N0MrN1YzVEgzQ1VIVHgrdDRRRll4UEhRL0loQ3pYdUpVeFQzYWtYNEQ1czJkTHp2RnBJMFIzTVBwUE9VQQpUelpSdDI2T3FVNHlUdUFnb0kvZnZMdk55VTNZekF3ZUQ2Mndxc1hiVHAranNFcWpoODUvakpXWnA4RExKK0w3CmhXQW0rSVNKTzhrNWgwR0lIMFllb01heXBJbjRubWVsbHNSM1dvYzZRVTZ4cFFTd3V1NXE0ckJzOUxDWS9kZkwKNkEzMEhlYXVVK2sydGFUVlBMY2FCZm11NDJPaHMyYzQ0bzNPYnlvVkNDNi8KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=`\n\taExampleComKey  = `LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2Z0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktnd2dnU2tBZ0VBQW9JQkFRRFpodFdpWXNPUDZFZEsKb3o5OVVlRnN1bmZSSTNjUGZtTnMwNjlBcFhGeSt0UlRMaGhmdnRrSzFNM0JFMzFiN1hPZmJENUMzUTdKb0JlbApWUWZmZGdxZmwvVzZvTjJYZENMNXBWSjlxTHQvY2dnMjdyd2dPc0Y5SlhCdjIzUTllelE1Q2lZZjhmUjk5MHNjClI1MDQ0aWJUMnA1THRRZTQrNWhYUFRYT2JhNDJxRDZSWVVZOWRydnhsWStHbUpPeVBvbDdZbmFYSHM3OG5BamcKcGdVZE9NdDhwY2dwTlNIQ3pCMWZBT2MyajJWS3pNbmlvQ3pEaTRnaDlEc2NXa3ZMZWphRGVwN2UzL1NiakMwdQozc2lTM1FKdlpZZUxEcjJxVGxTRm55QWZtVzh2WncrYm9zZTdyWk1ubU5UY1RQUjFXa1gwZ3UvczkvQzlGZThpCkgyUWVnQ3FuQWdNQkFBRUNnZ0VCQUsrclFrLzNyck5EQkgvMFFrdTBtbll5U0p6dkpUR3dBaDlhL01jYVZQcGsKTXFCU000RHZJVnlyNnRZb0pTN2VIbWY3QkhUL0RQZ3JmNjBYZEZvMGUvUFN4ckhIUSswUjcwVHBEQ3RLM3REWAppR2JFZWMwVlpqam95VnFzUWIxOUIvbWdocFY1MHRiL3BQcmJvczdUWkVQbTQ3dUVJUTUwc055VEpDYm5VSy8xCnhla2ZmZ3hMbmZlRUxoaXhDNE1XYjMzWG9GNU5VdWduQ2pUakthUFNNUmpISm9YSFlGWjdZdEdlSEd1aDR2UGwKOU5TM0YxT2l0MWNnQzNCSm1BM28yZmhYbTRGR1FhQzNjYUdXTzE5eHAwRWE1eXQ0RHZOTWp5WlgvSkx1Qko0NQpsZU5jUSs3c3U0dW0vY0hqcFFVenlvZmoydFBIU085QXczWGY0L2lmN0hFQ2dZRUE1SWMzMzVKUUhJVlQwc003CnhkY3haYmppbUE5alBWMDFXSXh0di8zbzFJWm5TUGFocEFuYXVwZGZqRkhKZmJTYlZXaUJTaUZpb2RTR3pIdDgKTlZNTGFyVzVreDl5N1luYXdnZjJuQjc2VG03aFl6L3h5T3AxNXFRbmswVW9DdnQ2MHp6dDl5UE5KQ1pWalFwNgp4cUw4T1c4emNlUGpxZzJBTHRtcVhpNitZRXNDZ1lFQTg2ME5zSHMzNktFZE91Q1o1TXF6NVRLSmVYSzQ5ZkdBCjdxcjM5Sm9RcWYzbEhSSWozUlFlNERkWmQ5NUFXcFRKUEJXdnp6NVROOWdwNHVnb3VGc0tCaG82YWtsUEZTUFIKRkZwWCtGZE56eHJGTlAwZHhydmN0bXU2OW91MFR0QU1jd1hYWFJuR1BuK0xDTnVUUHZndHZTTnRwSEZMb0dzUQorVDFpTjhpWS9aVUNnWUJpMVJQVjdkb1ZxNWVuNCtWYTE0azJlL0lMWDBSRkNxV0NpU0VCMGxhNmF2SUtQUmVFCjhQb1dqbGExUWIzSlRxMkxEMm95M0NOaTU1M3dtMHNKYU1QY1A0RmxYa2wrNzRxYk5ZUnkybmJZS3QzdzVYdTAKcjZtVHVOU2d2VnptK3dHUWo1NCtyczRPWDBIS2dJaStsVWhOc29qbUxXK05ZTTlaODZyWmxvK2c1d0tCZ0VMQQplRXlOSko2c2JCWng2cFo3Vk5hSGhwTm5jdldreDc0WnhiMFM2MWUxL3FwOUNxZ0lXQUR5Q0tkR2tmaCtZN1g2Cjl1TmQzbXdnNGpDUGlvQWVLRnZObVl6K01oVEhjQUlVVVo3dFE1cGxhZnAvRUVZZHRuT2VoV1ArbDFFenV3VlQKWjFEUXU3YnBONHdnb25DUWllOFRJbmoydEZIb29vaTBZUkNJK2lnVkFvR0JBSUxaOXd4WDlnMmVNYU9xUFk1dgo5RGxxNFVEZlpaYkprNFZPbmhjR0pWQUNXbmlpNTU0Y1RCSEkxUTdBT0ZQOHRqK3d3YWJBOWRMaUpDdzJzd0E2ClQrdnhiK1NySGxEUnFON3NNRUQ1Z091REo0eHJxRVdLZ3ZkSEsvME9EMC9ZMUFvSCt2aDlJMHVaV0RRNnNLcXcKeFcrbDk0UTZXSW1xYnpDODZsa3JXa0lCCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K`\n)\n\nfunc Test_buildMetricsHTTPConnectionManagerFilter(t *testing.T) {\n\tcacheDir, _ := os.UserCacheDir()\n\tcertFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-crt-354e49305a5a39414a545530374e58454e48334148524c4e324258463837364355564c4e4532464b54355139495547514a38.pem\")\n\tkeyFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-key-3350415a38414e4e4a4655424e55393430474147324651433949384e485341334b5157364f424b4c5856365a545937383735.pem\")\n\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\tli, err := b.buildMetricsListener(&config.Config{\n\t\tOptions: &config.Options{\n\t\t\tMetricsAddr:           \"127.0.0.1:9902\",\n\t\t\tMetricsCertificate:    aExampleComCert,\n\t\t\tMetricsCertificateKey: aExampleComKey,\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n{\n\t\"name\": \"metrics-ingress-1566242852377945326\",\n\t\"perConnectionBufferLimitBytes\": 32768,\n\t\"address\": {\n\t\t\"socketAddress\": {\n\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\"ipv4Compat\": true,\n\t\t\t\"portValue\": 9902\n\t\t}\n\t},\n\t\"filterChains\": [{\n\t\t\"filters\": [{\n\t\t\t\"name\": \"envoy.filters.network.http_connection_manager\",\n\t\t\t\"typedConfig\": {\n\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\n\t\t\t\t\"httpFilters\": [{\n\t\t\t\t\t\"name\": \"envoy.filters.http.router\"\n\t\t\t\t}],\n\t\t\t\t\"routeConfig\": {\n\t\t\t\t\t\"name\": \"metrics\",\n\t\t\t\t\t\"validateClusters\": false,\n\t\t\t\t\t\"virtualHosts\": [{\n\t\t\t\t\t\t\"name\": \"metrics\",\n\t\t\t\t\t\t\"domains\": [\"*\"],\n\t\t\t\t\t\t\"routes\": [{\n\t\t\t\t\t\t\t\"name\": \"metrics\",\n\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t},\n\t\t\t\t\"statPrefix\": \"metrics\"\n\t\t\t}\n\t\t}],\n\t\t\"transportSocket\": {\n\t\t\t\"name\": \"tls\",\n\t\t\t\"typedConfig\": {\n\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\",\n\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t\t},\n\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]\n}`, li)\n}\n\nfunc Test_buildMainHTTPConnectionManagerFilter(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", nil, nil)\n\n\toptions := config.NewDefaultOptions()\n\toptions.SkipXffAppend = true\n\toptions.XffNumTrustedHops = 1\n\tfilter, err := b.buildMainHTTPConnectionManagerFilter(options, []string{\"example.com\"}, \"*\")\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\"name\": \"envoy.filters.network.http_connection_manager\",\n\t\t\"typedConfig\": {\n\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\n\t\t\t\"accessLog\": [{\n\t\t\t\t\"name\": \"envoy.access_loggers.http_grpc\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig\",\n\t\t\t\t\t\"commonConfig\": {\n\t\t\t\t\t\t\"grpcService\": {\n\t\t\t\t\t\t\t\"envoyGrpc\": {\n\t\t\t\t\t\t\t\t\"clusterName\": \"pomerium-control-plane-grpc\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"logName\": \"ingress-http\",\n\t\t\t\t\t\t\"transportApiVersion\": \"V3\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"codecType\": \"HTTP1\",\n\t\t\t\"commonHttpProtocolOptions\": {\n\t\t\t\t\"idleTimeout\": \"300s\"\n\t\t\t},\n\t\t\t\"httpFilters\": [\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"local function starts_with(str, start)\\n    return str:sub(1, #start) == start\\nend\\n\\nfunction envoy_on_request(request_handle)\\n    local headers = request_handle:headers()\\n    local metadata = request_handle:metadata()\\n\\n    local remove_impersonate_headers = metadata:get(\\\"remove_impersonate_headers\\\")\\n    if remove_impersonate_headers then\\n        local to_remove = {}\\n        for k, v in pairs(headers) do\\n            if starts_with(k, \\\"impersonate-extra-\\\") or k == \\\"impersonate-group\\\" or k == \\\"impersonate-user\\\" then\\n                table.insert(to_remove, k)\\n            end\\n        end\\n\\n        for k, v in pairs(to_remove) do\\n            headers:remove(v)\\n        end\\n    end\\nend\\n\\nfunction envoy_on_response(response_handle)\\nend\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.ext_authz\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\",\n\t\t\t\t\t\t\"grpcService\": {\n\t\t\t\t\t\t\t\"envoyGrpc\": {\n\t\t\t\t\t\t\t\t\"clusterName\": \"pomerium-authorize\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"timeout\": \"10s\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"includePeerCertificate\": true,\n\t\t\t\t\t\t\"statusOnError\": {\n\t\t\t\t\t\t\t\"code\": \"InternalServerError\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"transportApiVersion\": \"V3\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"function envoy_on_request(request_handle)\\n    local headers = request_handle:headers()\\n    local dynamic_meta = request_handle:streamInfo():dynamicMetadata()\\n    if headers:get(\\\"x-pomerium-set-cookie\\\") ~= nil then\\n        dynamic_meta:set(\\\"envoy.filters.http.lua\\\", \\\"pomerium_set_cookie\\\",\\n                         headers:get(\\\"x-pomerium-set-cookie\\\"))\\n        headers:remove(\\\"x-pomerium-set-cookie\\\")\\n    end\\nend\\n\\nfunction envoy_on_response(response_handle)\\n    local headers = response_handle:headers()\\n    local dynamic_meta = response_handle:streamInfo():dynamicMetadata()\\n    local tbl = dynamic_meta:get(\\\"envoy.filters.http.lua\\\")\\n    if tbl ~= nil and tbl[\\\"pomerium_set_cookie\\\"] ~= nil then\\n        headers:add(\\\"set-cookie\\\", tbl[\\\"pomerium_set_cookie\\\"])\\n    end\\nend\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"function remove_pomerium_cookie(cookie_name, cookie)\\n    -- lua doesn't support optional capture groups\\n    -- so we replace twice to handle pomerium=xyz at the end of the string\\n    cookie = cookie:gsub(cookie_name .. \\\"=[^;]+; \\\", \\\"\\\")\\n    cookie = cookie:gsub(cookie_name .. \\\"=[^;]+\\\", \\\"\\\")\\n    return cookie\\nend\\n\\nfunction has_prefix(str, prefix)\\n    return str ~= nil and str:sub(1, #prefix) == prefix\\nend\\n\\nfunction envoy_on_request(request_handle)\\n    local headers = request_handle:headers()\\n    local metadata = request_handle:metadata()\\n\\n    local remove_cookie_name = metadata:get(\\\"remove_pomerium_cookie\\\")\\n    if remove_cookie_name then\\n        local cookie = headers:get(\\\"cookie\\\")\\n        if cookie ~= nil then\\n            newcookie = remove_pomerium_cookie(remove_cookie_name, cookie)\\n            headers:replace(\\\"cookie\\\", newcookie)\\n        end\\n    end\\n\\n    local remove_authorization = metadata:get(\\\"remove_pomerium_authorization\\\")\\n    if remove_authorization then\\n        local authorization = headers:get(\\\"authorization\\\")\\n        local authorization_prefix = \\\"Pomerium \\\"\\n        if has_prefix(authorization, authorization_prefix) then\\n            headers:remove(\\\"authorization\\\")\\n        end\\n\\n        headers:remove('x-pomerium-authorization')\\n    end\\nend\\n\\nfunction envoy_on_response(response_handle) end\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"function replace_prefix(str, prefix, value)\\n    return str:gsub(\\\"^\\\"..prefix, value)\\nend\\n\\nfunction envoy_on_request(request_handle)\\nend\\n\\nfunction envoy_on_response(response_handle)\\n    local headers = response_handle:headers()\\n    local metadata = response_handle:metadata()\\n\\n    -- should be in the form:\\n    -- [{\\n    --   \\\"header\\\":\\\"Location\\\",\\n    --   \\\"prefix\\\":\\\"http://localhost:8000/two/\\\",\\n    --   \\\"value\\\":\\\"http://frontend/one/\\\"\\n    -- }]\\n    local rewrite_response_headers = metadata:get(\\\"rewrite_response_headers\\\")\\n    if rewrite_response_headers then\\n        for _, obj in pairs(rewrite_response_headers) do\\n            local hdr = headers:get(obj.header)\\n            if hdr ~= nil then\\n                local newhdr = replace_prefix(hdr, obj.prefix, obj.value)\\n                headers:replace(obj.header, newhdr)\\n            end\\n        end\\n    end\\nend\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.router\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"requestTimeout\": \"30s\",\n\t\t\t\"routeConfig\": {\n\t\t\t\t\"name\": \"main\",\n\t\t\t\t\"virtualHosts\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"example.com\",\n\t\t\t\t\t\t\"domains\": [\"example.com\"],\n\t\t\t\t\t\t\"responseHeadersToAdd\": [{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"Strict-Transport-Security\",\n\t\t\t\t\t\t\t\t\"value\": \"max-age=31536000; includeSubDomains; preload\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-Frame-Options\",\n\t\t\t\t\t\t\t\t\"value\": \"SAMEORIGIN\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-XSS-Protection\",\n\t\t\t\t\t\t\t\t\"value\": \"1; mode=block\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t\"routes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium/jwt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium/jwt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/ping\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/ping\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/healthz\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/healthz\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.well-known/pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.well-known/pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.well-known/pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.well-known/pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/robots.txt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/robots.txt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"catch-all\",\n\t\t\t\t\t\t\"domains\": [\"*\"],\n\t\t\t\t\t\t\"responseHeadersToAdd\": [{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"Strict-Transport-Security\",\n\t\t\t\t\t\t\t\t\"value\": \"max-age=31536000; includeSubDomains; preload\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-Frame-Options\",\n\t\t\t\t\t\t\t\t\"value\": \"SAMEORIGIN\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-XSS-Protection\",\n\t\t\t\t\t\t\t\t\"value\": \"1; mode=block\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t\"routes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium/jwt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium/jwt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/ping\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/ping\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/healthz\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/healthz\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.well-known/pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.well-known/pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.well-known/pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.well-known/pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/robots.txt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/robots.txt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"validateClusters\": false\n\t\t\t},\n\t\t\t\"statPrefix\": \"ingress\",\n\t\t\t\"tracing\": {\n\t\t\t\t\"randomSampling\": {\n\t\t\t\t\t\"value\": 0.01\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"useRemoteAddress\": true,\n\t\t\t\"skipXffAppend\": true,\n\t\t\t\"xffNumTrustedHops\": 1,\n\t\t\t\"localReplyConfig\":{\n\t\t\t\t\"mappers\":[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"filter\":{\n\t\t\t\t\t\t\t\"responseFlagFilter\":{}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"headersToAdd\":[\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"append\":false,\n\t\t\t\t\t\t\t\t\"header\":{\n\t\t\t\t\t\t\t\t\t\"key\":\"Strict-Transport-Security\",\n\t\t\t\t\t\t\t\t\t\"value\":\"max-age=31536000; includeSubDomains; preload\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"append\":false,\n\t\t\t\t\t\t\t\t\"header\":{\n\t\t\t\t\t\t\t\t\t\"key\":\"X-Frame-Options\",\n\t\t\t\t\t\t\t\t\t\"value\":\"SAMEORIGIN\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"append\":false,\n\t\t\t\t\t\t\t\t\"header\":{\n\t\t\t\t\t\t\t\t\t\"key\":\"X-XSS-Protection\",\n\t\t\t\t\t\t\t\t\t\"value\":\"1; mode=block\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t}`, filter)\n}\n\nfunc Test_buildDownstreamTLSContext(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", filemgr.NewManager(), nil)\n\n\tcacheDir, _ := os.UserCacheDir()\n\tcertFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-crt-354e49305a5a39414a545530374e58454e48334148524c4e324258463837364355564c4e4532464b54355139495547514a38.pem\")\n\tkeyFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-key-3350415a38414e4e4a4655424e55393430474147324651433949384e485341334b5157364f424b4c5856365a545937383735.pem\")\n\n\tt.Run(\"no-validation\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert: aExampleComCert,\n\t\t\tKey:  aExampleComKey,\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"client-ca\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert:     aExampleComCert,\n\t\t\tKey:      aExampleComKey,\n\t\t\tClientCA: \"TEST\",\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\"trustChainVerification\": \"ACCEPT_UNTRUSTED\"\n\t\t\t\t}\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"policy-client-ca\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert: aExampleComCert,\n\t\t\tKey:  aExampleComKey,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:                &config.StringURL{URL: mustParseURL(t, \"https://a.example.com:1234\")},\n\t\t\t\t\tTLSDownstreamClientCA: \"TEST\",\n\t\t\t\t},\n\t\t\t},\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\"trustChainVerification\": \"ACCEPT_UNTRUSTED\"\n\t\t\t\t}\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"http1\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert:      aExampleComCert,\n\t\t\tKey:       aExampleComKey,\n\t\t\tCodecType: config.CodecTypeHTTP1,\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"http2\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert:      aExampleComCert,\n\t\t\tKey:       aExampleComKey,\n\t\t\tCodecType: config.CodecTypeHTTP2,\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n}\n\nfunc Test_getAllDomains(t *testing.T) {\n\toptions := &config.Options{\n\t\tAddr:                  \"127.0.0.1:9000\",\n\t\tGRPCAddr:              \"127.0.0.1:9001\",\n\t\tServices:              \"all\",\n\t\tAuthenticateURLString: \"https://authenticate.example.com\",\n\t\tAuthorizeURLString:    \"https://authorize.example.com:9001\",\n\t\tDataBrokerURLString:   \"https://cache.example.com:9001\",\n\t\tPolicies: []config.Policy{\n\t\t\t{Source: &config.StringURL{URL: mustParseURL(t, \"http://a.example.com\")}},\n\t\t\t{Source: &config.StringURL{URL: mustParseURL(t, \"https://b.example.com\")}},\n\t\t\t{Source: &config.StringURL{URL: mustParseURL(t, \"https://c.example.com\")}},\n\t\t},\n\t}\n\tt.Run(\"routable\", func(t *testing.T) {\n\t\tt.Run(\"http\", func(t *testing.T) {\n\t\t\tactual, err := getAllRouteableDomains(options, \"127.0.0.1:9000\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"a.example.com\",\n\t\t\t\t\"a.example.com:80\",\n\t\t\t\t\"authenticate.example.com\",\n\t\t\t\t\"authenticate.example.com:443\",\n\t\t\t\t\"b.example.com\",\n\t\t\t\t\"b.example.com:443\",\n\t\t\t\t\"c.example.com\",\n\t\t\t\t\"c.example.com:443\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t\tt.Run(\"grpc\", func(t *testing.T) {\n\t\t\tactual, err := getAllRouteableDomains(options, \"127.0.0.1:9001\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"authorize.example.com:9001\",\n\t\t\t\t\"cache.example.com:9001\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t\tt.Run(\"both\", func(t *testing.T) {\n\t\t\tnewOptions := *options\n\t\t\tnewOptions.GRPCAddr = newOptions.Addr\n\t\t\tactual, err := getAllRouteableDomains(&newOptions, \"127.0.0.1:9000\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"a.example.com\",\n\t\t\t\t\"a.example.com:80\",\n\t\t\t\t\"authenticate.example.com\",\n\t\t\t\t\"authenticate.example.com:443\",\n\t\t\t\t\"authorize.example.com:9001\",\n\t\t\t\t\"b.example.com\",\n\t\t\t\t\"b.example.com:443\",\n\t\t\t\t\"c.example.com\",\n\t\t\t\t\"c.example.com:443\",\n\t\t\t\t\"cache.example.com:9001\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t})\n\tt.Run(\"tls\", func(t *testing.T) {\n\t\tt.Run(\"http\", func(t *testing.T) {\n\t\t\tactual, err := getAllTLSDomains(options, \"127.0.0.1:9000\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"a.example.com\",\n\t\t\t\t\"authenticate.example.com\",\n\t\t\t\t\"b.example.com\",\n\t\t\t\t\"c.example.com\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t\tt.Run(\"grpc\", func(t *testing.T) {\n\t\t\tactual, err := getAllTLSDomains(options, \"127.0.0.1:9001\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"authorize.example.com\",\n\t\t\t\t\"cache.example.com\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t})\n}\n\nfunc Test_hostMatchesDomain(t *testing.T) {\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"http://example.com\"), \"example.com\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"http://example.com\"), \"example.com:80\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"https://example.com\"), \"example.com:443\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"https://example.com:443\"), \"example.com:443\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"https://example.com:443\"), \"example.com\"))\n\tassert.False(t, hostMatchesDomain(mustParseURL(t, \"http://example.com:81\"), \"example.com\"))\n\tassert.False(t, hostMatchesDomain(mustParseURL(t, \"http://example.com:81\"), \"example.com:80\"))\n}\n\nfunc Test_buildRouteConfiguration(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", nil, nil)\n\tvirtualHosts := make([]*envoy_config_route_v3.VirtualHost, 10)\n\trouteConfig, err := b.buildRouteConfiguration(\"test-route-configuration\", virtualHosts)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"test-route-configuration\", routeConfig.GetName())\n\tassert.Equal(t, virtualHosts, routeConfig.GetVirtualHosts())\n\tassert.False(t, routeConfig.GetValidateClusters().GetValue())\n}\n\nfunc Test_requireProxyProtocol(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", nil, nil)\n\tt.Run(\"required\", func(t *testing.T) {\n\t\tli, err := b.buildMainListener(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tUseProxyProtocol: true,\n\t\t\tInsecureServer:   true,\n\t\t}})\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t{\n\t\t\t\t\"name\": \"envoy.filters.listener.proxy_protocol\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol\"\n\t\t\t\t}\n\t\t\t}\n\t\t]`, li.GetListenerFilters())\n\t})\n\tt.Run(\"not required\", func(t *testing.T) {\n\t\tli, err := b.buildMainListener(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tUseProxyProtocol: false,\n\t\t\tInsecureServer:   true,\n\t\t}})\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, li.GetListenerFilters(), 0)\n\t})\n}\n", "package envoyconfig\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"sort\"\n\n\tenvoy_config_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_type_matcher_v3 \"github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3\"\n\t\"github.com/golang/protobuf/ptypes/any\"\n\t\"github.com/golang/protobuf/ptypes/wrappers\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/httputil\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n)\n\nconst (\n\thttpCluster = \"pomerium-control-plane-http\"\n)\n\nfunc (b *Builder) buildGRPCRoutes() ([]*envoy_config_route_v3.Route, error) {\n\taction := &envoy_config_route_v3.Route_Route{\n\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\tCluster: \"pomerium-control-plane-grpc\",\n\t\t\t},\n\t\t},\n\t}\n\treturn []*envoy_config_route_v3.Route{{\n\t\tName: \"pomerium-grpc\",\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{\n\t\t\t\tPrefix: \"/\",\n\t\t\t},\n\t\t\tGrpc: &envoy_config_route_v3.RouteMatch_GrpcRouteMatchOptions{},\n\t\t},\n\t\tAction: action,\n\t\tTypedPerFilterConfig: map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t},\n\t}}, nil\n}\n\nfunc (b *Builder) buildPomeriumHTTPRoutes(options *config.Options, domain string) ([]*envoy_config_route_v3.Route, error) {\n\tvar routes []*envoy_config_route_v3.Route\n\n\t// if this is the pomerium proxy in front of the the authenticate service, don't add\n\t// these routes since they will be handled by authenticate\n\tisFrontingAuthenticate, err := isProxyFrontingAuthenticate(options, domain)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isFrontingAuthenticate {\n\t\t// enable ext_authz\n\t\tr, err := b.buildControlPlanePathRoute(\"/.pomerium/jwt\", true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\n\t\t// disable ext_authz and passthrough to proxy handlers\n\t\tr, err = b.buildControlPlanePathRoute(\"/ping\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathRoute(\"/healthz\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathRoute(\"/.pomerium\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePrefixRoute(\"/.pomerium/\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathRoute(\"/.well-known/pomerium\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePrefixRoute(\"/.well-known/pomerium/\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\t// per #837, only add robots.txt if there are no unauthenticated routes\n\t\tif !hasPublicPolicyMatchingURL(options, url.URL{Scheme: \"https\", Host: domain, Path: \"/robots.txt\"}) {\n\t\t\tr, err := b.buildControlPlanePathRoute(\"/robots.txt\", false)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\troutes = append(routes, r)\n\t\t}\n\t}\n\t// if we're handling authentication, add the oauth2 callback url\n\tauthenticateURL, err := options.GetInternalAuthenticateURL()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif config.IsAuthenticate(options.Services) && hostMatchesDomain(authenticateURL, domain) {\n\t\tr, err := b.buildControlPlanePrefixRoute(\"/\", false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t}\n\t// if we're the proxy and this is the forward-auth url\n\tforwardAuthURL, err := options.GetForwardAuthURL()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif config.IsProxy(options.Services) && hostMatchesDomain(forwardAuthURL, domain) {\n\t\t// disable ext_authz and pass request to proxy handlers that enable authN flow\n\t\tr, err := b.buildControlPlanePathAndQueryRoute(\"/verify\", []string{urlutil.QueryForwardAuthURI, urlutil.QuerySessionEncrypted, urlutil.QueryRedirectURI})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathAndQueryRoute(\"/\", []string{urlutil.QueryForwardAuthURI, urlutil.QuerySessionEncrypted, urlutil.QueryRedirectURI})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathAndQueryRoute(\"/\", []string{urlutil.QueryForwardAuthURI})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\n\t\t// otherwise, enforce ext_authz; pass all other requests through to an upstream\n\t\t// handler that will simply respond with http status 200 / OK indicating that\n\t\t// the fronting forward-auth proxy can continue.\n\t\tr, err = b.buildControlPlaneProtectedPrefixRoute(\"/\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t}\n\treturn routes, nil\n}\n\nfunc (b *Builder) buildControlPlaneProtectedPrefixRoute(prefix string) (*envoy_config_route_v3.Route, error) {\n\treturn &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-protected-prefix-\" + prefix,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: prefix},\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildControlPlanePathAndQueryRoute(path string, queryparams []string) (*envoy_config_route_v3.Route, error) {\n\tvar queryParameterMatchers []*envoy_config_route_v3.QueryParameterMatcher\n\tfor _, q := range queryparams {\n\t\tqueryParameterMatchers = append(queryParameterMatchers,\n\t\t\t&envoy_config_route_v3.QueryParameterMatcher{\n\t\t\t\tName:                         q,\n\t\t\t\tQueryParameterMatchSpecifier: &envoy_config_route_v3.QueryParameterMatcher_PresentMatch{PresentMatch: true},\n\t\t\t})\n\t}\n\n\treturn &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-path-and-query\" + path,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier:   &envoy_config_route_v3.RouteMatch_Path{Path: path},\n\t\t\tQueryParameters: queryParameterMatchers,\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTypedPerFilterConfig: map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildControlPlanePathRoute(path string, protected bool) (*envoy_config_route_v3.Route, error) {\n\tr := &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-path-\" + path,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Path{Path: path},\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif !protected {\n\t\tr.TypedPerFilterConfig = map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t}\n\t}\n\treturn r, nil\n}\n\nfunc (b *Builder) buildControlPlanePrefixRoute(prefix string, protected bool) (*envoy_config_route_v3.Route, error) {\n\tr := &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-prefix-\" + prefix,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: prefix},\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif !protected {\n\t\tr.TypedPerFilterConfig = map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t}\n\t}\n\treturn r, nil\n}\n\n// getClusterID returns a cluster ID\nvar getClusterID = func(policy *config.Policy) string {\n\tprefix := getClusterStatsName(policy)\n\tif prefix == \"\" {\n\t\tprefix = \"route\"\n\t}\n\n\tid, _ := policy.RouteID()\n\treturn fmt.Sprintf(\"%s-%x\", prefix, id)\n}\n\n// getClusterStatsName returns human readable name that would be used by envoy to emit statistics, available as envoy_cluster_name label\nfunc getClusterStatsName(policy *config.Policy) string {\n\tif policy.EnvoyOpts != nil && policy.EnvoyOpts.Name != \"\" {\n\t\treturn policy.EnvoyOpts.Name\n\t}\n\treturn \"\"\n}\n\nfunc (b *Builder) buildPolicyRoutes(options *config.Options, domain string) ([]*envoy_config_route_v3.Route, error) {\n\tvar routes []*envoy_config_route_v3.Route\n\n\tfor i, p := range options.GetAllPolicies() {\n\t\tpolicy := p\n\t\tif !hostMatchesDomain(policy.Source.URL, domain) {\n\t\t\tcontinue\n\t\t}\n\n\t\tmatch := mkRouteMatch(&policy)\n\t\tenvoyRoute := &envoy_config_route_v3.Route{\n\t\t\tName:                   fmt.Sprintf(\"policy-%d\", i),\n\t\t\tMatch:                  match,\n\t\t\tMetadata:               &envoy_config_core_v3.Metadata{},\n\t\t\tRequestHeadersToAdd:    toEnvoyHeaders(policy.SetRequestHeaders),\n\t\t\tRequestHeadersToRemove: getRequestHeadersToRemove(options, &policy),\n\t\t\tResponseHeadersToAdd:   toEnvoyHeaders(policy.SetResponseHeaders),\n\t\t}\n\t\tif policy.Redirect != nil {\n\t\t\taction, err := b.buildPolicyRouteRedirectAction(policy.Redirect)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tenvoyRoute.Action = &envoy_config_route_v3.Route_Redirect{Redirect: action}\n\t\t} else {\n\t\t\taction, err := b.buildPolicyRouteRouteAction(options, &policy)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tenvoyRoute.Action = &envoy_config_route_v3.Route_Route{Route: action}\n\t\t}\n\n\t\tluaMetadata := map[string]*structpb.Value{\n\t\t\t\"rewrite_response_headers\": getRewriteHeadersMetadata(policy.RewriteResponseHeaders),\n\t\t}\n\n\t\t// disable authentication entirely when the proxy is fronting authenticate\n\t\tisFrontingAuthenticate, err := isProxyFrontingAuthenticate(options, domain)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif isFrontingAuthenticate {\n\t\t\tenvoyRoute.TypedPerFilterConfig = map[string]*any.Any{\n\t\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t\t}\n\t\t} else {\n\t\t\tluaMetadata[\"remove_pomerium_cookie\"] = &structpb.Value{\n\t\t\t\tKind: &structpb.Value_StringValue{\n\t\t\t\t\tStringValue: options.CookieName,\n\t\t\t\t},\n\t\t\t}\n\t\t\tluaMetadata[\"remove_pomerium_authorization\"] = &structpb.Value{\n\t\t\t\tKind: &structpb.Value_BoolValue{\n\t\t\t\t\tBoolValue: true,\n\t\t\t\t},\n\t\t\t}\n\t\t\tluaMetadata[\"remove_impersonate_headers\"] = &structpb.Value{\n\t\t\t\tKind: &structpb.Value_BoolValue{\n\t\t\t\t\tBoolValue: policy.IsForKubernetes(),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif policy.IsForKubernetes() {\n\t\t\tpolicyID, _ := policy.RouteID()\n\t\t\tfor _, hdr := range b.reproxy.GetPolicyIDHeaders(policyID) {\n\t\t\t\tenvoyRoute.RequestHeadersToAdd = append(envoyRoute.RequestHeadersToAdd,\n\t\t\t\t\t&envoy_config_core_v3.HeaderValueOption{\n\t\t\t\t\t\tHeader: &envoy_config_core_v3.HeaderValue{\n\t\t\t\t\t\t\tKey:   hdr[0],\n\t\t\t\t\t\t\tValue: hdr[1],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tAppend: wrapperspb.Bool(false),\n\t\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tenvoyRoute.Metadata.FilterMetadata = map[string]*structpb.Struct{\n\t\t\t\"envoy.filters.http.lua\": {Fields: luaMetadata},\n\t\t}\n\n\t\troutes = append(routes, envoyRoute)\n\t}\n\treturn routes, nil\n}\n\nfunc (b *Builder) buildPolicyRouteRedirectAction(r *config.PolicyRedirect) (*envoy_config_route_v3.RedirectAction, error) {\n\taction := &envoy_config_route_v3.RedirectAction{}\n\tswitch {\n\tcase r.HTTPSRedirect != nil:\n\t\taction.SchemeRewriteSpecifier = &envoy_config_route_v3.RedirectAction_HttpsRedirect{\n\t\t\tHttpsRedirect: *r.HTTPSRedirect,\n\t\t}\n\tcase r.SchemeRedirect != nil:\n\t\taction.SchemeRewriteSpecifier = &envoy_config_route_v3.RedirectAction_SchemeRedirect{\n\t\t\tSchemeRedirect: *r.SchemeRedirect,\n\t\t}\n\t}\n\tif r.HostRedirect != nil {\n\t\taction.HostRedirect = *r.HostRedirect\n\t}\n\tif r.PortRedirect != nil {\n\t\taction.PortRedirect = *r.PortRedirect\n\t}\n\tswitch {\n\tcase r.PathRedirect != nil:\n\t\taction.PathRewriteSpecifier = &envoy_config_route_v3.RedirectAction_PathRedirect{\n\t\t\tPathRedirect: *r.PathRedirect,\n\t\t}\n\tcase r.PrefixRewrite != nil:\n\t\taction.PathRewriteSpecifier = &envoy_config_route_v3.RedirectAction_PrefixRewrite{\n\t\t\tPrefixRewrite: *r.PrefixRewrite,\n\t\t}\n\t}\n\tif r.ResponseCode != nil {\n\t\taction.ResponseCode = envoy_config_route_v3.RedirectAction_RedirectResponseCode(*r.ResponseCode)\n\t}\n\tif r.StripQuery != nil {\n\t\taction.StripQuery = *r.StripQuery\n\t}\n\treturn action, nil\n}\n\nfunc (b *Builder) buildPolicyRouteRouteAction(options *config.Options, policy *config.Policy) (*envoy_config_route_v3.RouteAction, error) {\n\tclusterName := getClusterID(policy)\n\t// kubernetes requests are sent to the http control plane to be reproxied\n\tif policy.IsForKubernetes() {\n\t\tclusterName = httpCluster\n\t}\n\trouteTimeout := getRouteTimeout(options, policy)\n\tidleTimeout := getRouteIdleTimeout(policy)\n\tprefixRewrite, regexRewrite := getRewriteOptions(policy)\n\tupgradeConfigs := []*envoy_config_route_v3.RouteAction_UpgradeConfig{\n\t\t{\n\t\t\tUpgradeType: \"websocket\",\n\t\t\tEnabled:     &wrappers.BoolValue{Value: policy.AllowWebsockets},\n\t\t},\n\t\t{\n\t\t\tUpgradeType: \"spdy/3.1\",\n\t\t\tEnabled:     &wrappers.BoolValue{Value: policy.AllowSPDY},\n\t\t},\n\t}\n\tif urlutil.IsTCP(policy.Source.URL) {\n\t\tupgradeConfigs = append(upgradeConfigs, &envoy_config_route_v3.RouteAction_UpgradeConfig{\n\t\t\tUpgradeType:   \"CONNECT\",\n\t\t\tEnabled:       &wrappers.BoolValue{Value: true},\n\t\t\tConnectConfig: &envoy_config_route_v3.RouteAction_UpgradeConfig_ConnectConfig{},\n\t\t})\n\t}\n\taction := &envoy_config_route_v3.RouteAction{\n\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\tCluster: clusterName,\n\t\t},\n\t\tUpgradeConfigs: upgradeConfigs,\n\t\tHostRewriteSpecifier: &envoy_config_route_v3.RouteAction_AutoHostRewrite{\n\t\t\tAutoHostRewrite: &wrappers.BoolValue{Value: !policy.PreserveHostHeader},\n\t\t},\n\t\tTimeout:       routeTimeout,\n\t\tIdleTimeout:   idleTimeout,\n\t\tPrefixRewrite: prefixRewrite,\n\t\tRegexRewrite:  regexRewrite,\n\t\tHashPolicy: []*envoy_config_route_v3.RouteAction_HashPolicy{\n\t\t\t// hash by the routing key, which is added by authorize.\n\t\t\t{\n\t\t\t\tPolicySpecifier: &envoy_config_route_v3.RouteAction_HashPolicy_Header_{\n\t\t\t\t\tHeader: &envoy_config_route_v3.RouteAction_HashPolicy_Header{\n\t\t\t\t\t\tHeaderName: httputil.HeaderPomeriumRoutingKey,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTerminal: true,\n\t\t\t},\n\t\t\t// if the routing key is missing, hash by the ip.\n\t\t\t{\n\t\t\t\tPolicySpecifier: &envoy_config_route_v3.RouteAction_HashPolicy_ConnectionProperties_{\n\t\t\t\t\tConnectionProperties: &envoy_config_route_v3.RouteAction_HashPolicy_ConnectionProperties{\n\t\t\t\t\t\tSourceIp: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTerminal: true,\n\t\t\t},\n\t\t},\n\t}\n\tsetHostRewriteOptions(policy, action)\n\n\treturn action, nil\n}\n\nfunc mkEnvoyHeader(k, v string) *envoy_config_core_v3.HeaderValueOption {\n\treturn &envoy_config_core_v3.HeaderValueOption{\n\t\tHeader: &envoy_config_core_v3.HeaderValue{\n\t\t\tKey:   k,\n\t\t\tValue: v,\n\t\t},\n\t\tAppend: &wrappers.BoolValue{Value: false},\n\t}\n}\n\nfunc toEnvoyHeaders(headers map[string]string) []*envoy_config_core_v3.HeaderValueOption {\n\tvar ks []string\n\tfor k := range headers {\n\t\tks = append(ks, k)\n\t}\n\tsort.Strings(ks)\n\n\tenvoyHeaders := make([]*envoy_config_core_v3.HeaderValueOption, 0, len(headers))\n\tfor _, k := range ks {\n\t\tenvoyHeaders = append(envoyHeaders, mkEnvoyHeader(k, headers[k]))\n\t}\n\treturn envoyHeaders\n}\n\nfunc mkRouteMatch(policy *config.Policy) *envoy_config_route_v3.RouteMatch {\n\tmatch := &envoy_config_route_v3.RouteMatch{}\n\tswitch {\n\tcase urlutil.IsTCP(policy.Source.URL):\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_ConnectMatcher_{\n\t\t\tConnectMatcher: &envoy_config_route_v3.RouteMatch_ConnectMatcher{},\n\t\t}\n\tcase policy.Regex != \"\":\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_SafeRegex{\n\t\t\tSafeRegex: &envoy_type_matcher_v3.RegexMatcher{\n\t\t\t\tEngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{\n\t\t\t\t\tGoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},\n\t\t\t\t},\n\t\t\t\tRegex: policy.Regex,\n\t\t\t},\n\t\t}\n\tcase policy.Path != \"\":\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_Path{Path: policy.Path}\n\tcase policy.Prefix != \"\":\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_Prefix{Prefix: policy.Prefix}\n\tdefault:\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_Prefix{Prefix: \"/\"}\n\t}\n\treturn match\n}\n\nfunc getRequestHeadersToRemove(options *config.Options, policy *config.Policy) []string {\n\trequestHeadersToRemove := policy.RemoveRequestHeaders\n\tif !policy.PassIdentityHeaders {\n\t\trequestHeadersToRemove = append(requestHeadersToRemove,\n\t\t\thttputil.HeaderPomeriumJWTAssertion,\n\t\t\thttputil.HeaderPomeriumJWTAssertionFor)\n\t\tfor headerName := range options.JWTClaimsHeaders {\n\t\t\trequestHeadersToRemove = append(requestHeadersToRemove, headerName)\n\t\t}\n\t}\n\t// remove these headers to prevent a user from re-proxying requests through the control plane\n\trequestHeadersToRemove = append(requestHeadersToRemove,\n\t\thttputil.HeaderPomeriumReproxyPolicy,\n\t\thttputil.HeaderPomeriumReproxyPolicyHMAC,\n\t)\n\treturn requestHeadersToRemove\n}\n\nfunc getRouteTimeout(options *config.Options, policy *config.Policy) *durationpb.Duration {\n\tvar routeTimeout *durationpb.Duration\n\tif policy.UpstreamTimeout != nil {\n\t\trouteTimeout = durationpb.New(*policy.UpstreamTimeout)\n\t} else if shouldDisableStreamIdleTimeout(policy) {\n\t\t// a non-zero value would conflict with idleTimeout and/or websocket / tcp calls\n\t\trouteTimeout = durationpb.New(0)\n\t} else {\n\t\trouteTimeout = durationpb.New(options.DefaultUpstreamTimeout)\n\t}\n\treturn routeTimeout\n}\n\nfunc getRouteIdleTimeout(policy *config.Policy) *durationpb.Duration {\n\tvar idleTimeout *durationpb.Duration\n\tif policy.IdleTimeout != nil {\n\t\tidleTimeout = durationpb.New(*policy.IdleTimeout)\n\t} else if shouldDisableStreamIdleTimeout(policy) {\n\t\tidleTimeout = durationpb.New(0)\n\t}\n\treturn idleTimeout\n}\n\nfunc shouldDisableStreamIdleTimeout(policy *config.Policy) bool {\n\treturn policy.AllowWebsockets ||\n\t\turlutil.IsTCP(policy.Source.URL) ||\n\t\tpolicy.IsForKubernetes() // disable for kubernetes so that tailing logs works (#2182)\n}\n\nfunc getRewriteOptions(policy *config.Policy) (prefixRewrite string, regexRewrite *envoy_type_matcher_v3.RegexMatchAndSubstitute) {\n\tif policy.PrefixRewrite != \"\" {\n\t\tprefixRewrite = policy.PrefixRewrite\n\t} else if policy.RegexRewritePattern != \"\" {\n\t\tregexRewrite = &envoy_type_matcher_v3.RegexMatchAndSubstitute{\n\t\t\tPattern: &envoy_type_matcher_v3.RegexMatcher{\n\t\t\t\tEngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{\n\t\t\t\t\tGoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},\n\t\t\t\t},\n\t\t\t\tRegex: policy.RegexRewritePattern,\n\t\t\t},\n\t\t\tSubstitution: policy.RegexRewriteSubstitution,\n\t\t}\n\t} else if len(policy.To) > 0 && policy.To[0].URL.Path != \"\" {\n\t\tprefixRewrite = policy.To[0].URL.Path\n\t}\n\n\treturn prefixRewrite, regexRewrite\n}\n\nfunc setHostRewriteOptions(policy *config.Policy, action *envoy_config_route_v3.RouteAction) {\n\tswitch {\n\tcase policy.HostRewrite != \"\":\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_HostRewriteLiteral{\n\t\t\tHostRewriteLiteral: policy.HostRewrite,\n\t\t}\n\tcase policy.HostRewriteHeader != \"\":\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_HostRewriteHeader{\n\t\t\tHostRewriteHeader: policy.HostRewriteHeader,\n\t\t}\n\tcase policy.HostPathRegexRewritePattern != \"\":\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_HostRewritePathRegex{\n\t\t\tHostRewritePathRegex: &envoy_type_matcher_v3.RegexMatchAndSubstitute{\n\t\t\t\tPattern: &envoy_type_matcher_v3.RegexMatcher{\n\t\t\t\t\tEngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{\n\t\t\t\t\t\tGoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},\n\t\t\t\t\t},\n\t\t\t\t\tRegex: policy.HostPathRegexRewritePattern,\n\t\t\t\t},\n\t\t\t\tSubstitution: policy.HostPathRegexRewriteSubstitution,\n\t\t\t},\n\t\t}\n\tcase policy.PreserveHostHeader:\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_AutoHostRewrite{\n\t\t\tAutoHostRewrite: wrapperspb.Bool(false),\n\t\t}\n\tdefault:\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_AutoHostRewrite{\n\t\t\tAutoHostRewrite: wrapperspb.Bool(true),\n\t\t}\n\t}\n}\n\nfunc hasPublicPolicyMatchingURL(options *config.Options, requestURL url.URL) bool {\n\tfor _, policy := range options.GetAllPolicies() {\n\t\tif policy.AllowPublicUnauthenticatedAccess && policy.Matches(requestURL) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isProxyFrontingAuthenticate(options *config.Options, domain string) (bool, error) {\n\tauthenticateURL, err := options.GetAuthenticateURL()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif !config.IsAuthenticate(options.Services) && hostMatchesDomain(authenticateURL, domain) {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\nfunc getRewriteHeadersMetadata(headers []config.RewriteHeader) *structpb.Value {\n\tif len(headers) == 0 {\n\t\treturn &structpb.Value{\n\t\t\tKind: &structpb.Value_ListValue{\n\t\t\t\tListValue: new(structpb.ListValue),\n\t\t\t},\n\t\t}\n\t}\n\tvar obj interface{}\n\tbs, _ := json.Marshal(headers)\n\t_ = json.Unmarshal(bs, &obj)\n\tv, _ := structpb.NewValue(obj)\n\treturn v\n}\n", "package envoyconfig\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tenvoy_config_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n)\n\nfunc policyNameFunc() func(*config.Policy) string {\n\ti := 0\n\treturn func(*config.Policy) string {\n\t\ti++\n\t\treturn fmt.Sprintf(\"policy-%d\", i)\n\t}\n}\n\nfunc Test_buildGRPCRoutes(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troutes, err := b.buildGRPCRoutes()\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"pomerium-grpc\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"grpc\": {},\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"cluster\": \"pomerium-control-plane-grpc\"\n\t\t\t\t},\n\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t`, routes)\n}\n\nfunc Test_buildPomeriumHTTPRoutes(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\trouteString := func(typ, name string, protected bool) string {\n\t\tstr := `{\n\t\t\t\t\"name\": \"pomerium-` + typ + `-` + name + `\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"` + typ + `\": \"` + name + `\"\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t}\n\t\t\t`\n\t\tif !protected {\n\t\t\tstr += `,\n\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`\n\t\t}\n\t\tstr += \"}\"\n\t\treturn str\n\t}\n\tt.Run(\"authenticate\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"all\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t\tForwardAuthURLString:     \"https://forward-auth.example.com\",\n\t\t}\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"authenticate.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t`+routeString(\"path\", \"/.pomerium/jwt\", true)+`,\n\t\t\t`+routeString(\"path\", \"/ping\", false)+`,\n\t\t\t`+routeString(\"path\", \"/healthz\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.well-known/pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.well-known/pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/robots.txt\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/\", false)+`\n\t\t]`, routes)\n\t})\n\tt.Run(\"proxy fronting authenticate\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"proxy\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t}\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"authenticate.example.com\")\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, \"null\", routes)\n\t})\n\n\tt.Run(\"with robots\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"all\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t\tForwardAuthURLString:     \"https://forward-auth.example.com\",\n\t\t\tPolicies: []config.Policy{{\n\t\t\t\tFrom: \"https://from.example.com\",\n\t\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t\t}},\n\t\t}\n\t\t_ = options.Policies[0].Validate()\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"from.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t`+routeString(\"path\", \"/.pomerium/jwt\", true)+`,\n\t\t\t`+routeString(\"path\", \"/ping\", false)+`,\n\t\t\t`+routeString(\"path\", \"/healthz\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.well-known/pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.well-known/pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/robots.txt\", false)+`\n\t\t]`, routes)\n\t})\n\n\tt.Run(\"without robots\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"all\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t\tForwardAuthURLString:     \"https://forward-auth.example.com\",\n\t\t\tPolicies: []config.Policy{{\n\t\t\t\tFrom:                             \"https://from.example.com\",\n\t\t\t\tTo:                               mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t\t\tAllowPublicUnauthenticatedAccess: true,\n\t\t\t}},\n\t\t}\n\t\t_ = options.Policies[0].Validate()\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"from.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t`+routeString(\"path\", \"/.pomerium/jwt\", true)+`,\n\t\t\t`+routeString(\"path\", \"/ping\", false)+`,\n\t\t\t`+routeString(\"path\", \"/healthz\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.well-known/pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.well-known/pomerium/\", false)+`\n\t\t]`, routes)\n\t})\n}\n\nfunc Test_buildControlPlanePathRoute(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troute, err := b.buildControlPlanePathRoute(\"/hello/world\", false)\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t{\n\t\t\t\"name\": \"pomerium-path-/hello/world\",\n\t\t\t\"match\": {\n\t\t\t\t\"path\": \"/hello/world\"\n\t\t\t},\n\t\t\t\"route\": {\n\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t},\n\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\"disabled\": true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`, route)\n}\n\nfunc Test_buildControlPlanePrefixRoute(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troute, err := b.buildControlPlanePrefixRoute(\"/hello/world/\", false)\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t{\n\t\t\t\"name\": \"pomerium-prefix-/hello/world/\",\n\t\t\t\"match\": {\n\t\t\t\t\"prefix\": \"/hello/world/\"\n\t\t\t},\n\t\t\t\"route\": {\n\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t},\n\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\"disabled\": true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`, route)\n}\n\nfunc TestTimeouts(t *testing.T) {\n\tdefer func(f func(*config.Policy) string) {\n\t\tgetClusterID = f\n\t}(getClusterID)\n\tgetClusterID = func(*config.Policy) string { return \"policy\" }\n\n\tgetDuration := func(txt string) *time.Duration {\n\t\tif txt == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\td, err := time.ParseDuration(txt)\n\t\trequire.NoError(t, err, txt)\n\t\treturn &d\n\t}\n\n\ttestCases := []struct {\n\t\tupstream, idle  string\n\t\tallowWebsockets bool\n\t\texpect          string\n\t}{\n\t\t{\"\", \"\", false, `\"timeout\": \"3s\"`},\n\t\t{\"\", \"\", true, `\"timeout\": \"0s\", \"idleTimeout\": \"0s\"`},\n\t\t{\"5s\", \"\", true, `\"timeout\": \"5s\", \"idleTimeout\": \"0s\"`},\n\t\t{\"\", \"0s\", false, `\"timeout\": \"3s\",\"idleTimeout\": \"0s\"`},\n\t\t{\"\", \"5s\", false, `\"timeout\": \"3s\",\"idleTimeout\": \"5s\"`},\n\t\t{\"5s\", \"\", false, `\"timeout\": \"5s\"`},\n\t\t{\"5s\", \"4s\", false, `\"timeout\": \"5s\",\"idleTimeout\": \"4s\"`},\n\t\t{\"0s\", \"4s\", false, `\"timeout\": \"0s\",\"idleTimeout\": \"4s\"`},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tb := &Builder{filemgr: filemgr.NewManager()}\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:          &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\t\tPath:            \"/test\",\n\t\t\t\t\tUpstreamTimeout: getDuration(tc.upstream),\n\t\t\t\t\tIdleTimeout:     getDuration(tc.idle),\n\t\t\t\t\tAllowWebsockets: tc.allowWebsockets,\n\t\t\t\t}},\n\t\t}, \"example.com\")\n\t\tif !assert.NoError(t, err, \"%v\", tc) || !assert.Len(t, routes, 1, tc) || !assert.NotNil(t, routes[0].GetRoute(), \"%v\", tc) {\n\t\t\tcontinue\n\t\t}\n\n\t\texpect := fmt.Sprintf(`{\n\t\t\t%s,\n\t\t\t\"autoHostRewrite\": true,\n\t\t\t\"cluster\": \"policy\",\n\t\t\t\"hashPolicy\": [\n\t\t\t\t{\n\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t},\n\t\t\t\t\t\"terminal\": true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t},\n\t\t\t\t\t\"terminal\": true\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"upgradeConfigs\": [\n\t\t\t\t{ \"enabled\": %v, \"upgradeType\": \"websocket\"},\n\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t]\n\t\t}`, tc.expect, tc.allowWebsockets)\n\t\ttestutil.AssertProtoJSONEqual(t, expect, routes[0].GetRoute())\n\t}\n}\n\nfunc Test_buildPolicyRoutes(t *testing.T) {\n\tdefer func(f func(*config.Policy) string) {\n\t\tgetClusterID = f\n\t}(getClusterID)\n\tgetClusterID = policyNameFunc()\n\n\toneMinute := time.Minute\n\tten := time.Second * 10\n\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\tCookieName:             \"pomerium\",\n\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\tPolicies: []config.Policy{\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://ignore.example.com\")},\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/some/path\",\n\t\t\t\tAllowWebsockets:     true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPrefix:              \"/some/prefix/\",\n\t\t\t\tSetRequestHeaders:   map[string]string{\"HEADER-KEY\": \"HEADER-VALUE\"},\n\t\t\t\tUpstreamTimeout:     &oneMinute,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tRegex:               `^/[a]+$`,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:               &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPrefix:               \"/some/prefix/\",\n\t\t\t\tRemoveRequestHeaders: []string{\"HEADER-KEY\"},\n\t\t\t\tUpstreamTimeout:      &oneMinute,\n\t\t\t\tPassIdentityHeaders:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/some/path\",\n\t\t\t\tAllowSPDY:           true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/some/path\",\n\t\t\t\tAllowSPDY:           true,\n\t\t\t\tAllowWebsockets:     true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/websocket-timeout\",\n\t\t\t\tAllowWebsockets:     true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tUpstreamTimeout:     &ten,\n\t\t\t},\n\t\t},\n\t}, \"example.com\")\n\trequire.NoError(t, err)\n\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"policy-1\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-1\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-2\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/some/path\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-2\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"0s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-3\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/some/prefix/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-3\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"60s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToAdd\": [{\n\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\"key\": \"HEADER-KEY\",\n\t\t\t\t\t\t\"value\": \"HEADER-VALUE\"\n\t\t\t\t\t}\n\t\t\t\t}],\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-4\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"safeRegex\": {\n\t\t\t\t\t\t\"googleRe2\": {},\n\t\t\t\t\t\t\"regex\": \"^/[a]+$\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-4\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-5\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/some/prefix/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-5\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"60s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"HEADER-KEY\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-6\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/some/path\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-6\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-7\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/some/path\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-7\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"0s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-8\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/websocket-timeout\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-8\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"10s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t`, routes)\n\n\tt.Run(\"fronting-authenticate\", func(t *testing.T) {\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tAuthenticateURLString:  \"https://authenticate.example.com\",\n\t\t\tServices:               \"proxy\",\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://authenticate.example.com\")},\n\t\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\t},\n\t\t\t},\n\t\t}, \"authenticate.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t\t},\n\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\t\"cluster\": \"policy-9\",\n\t\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n        \t        \"requestHeadersToRemove\": [\n        \t           \t\"x-pomerium-reproxy-policy\",\n        \t           \t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t\t],\n\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t`, routes)\n\t})\n\n\tt.Run(\"tcp\", func(t *testing.T) {\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"tcp+https://example.com:22\")},\n\t\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"tcp+https://example.com:22\")},\n\t\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\t\tUpstreamTimeout:     &ten,\n\t\t\t\t},\n\t\t\t},\n\t\t}, \"example.com:22\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"connectMatcher\": {}\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-10\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"0s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"CONNECT\", \"connectConfig\": {} }\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-1\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"connectMatcher\": {}\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-11\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"10s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"CONNECT\", \"connectConfig\": {} }\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t`, routes)\n\t})\n\n\tt.Run(\"remove-pomerium-headers\", func(t *testing.T) {\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tAuthenticateURLString:  \"https://authenticate.example.com\",\n\t\t\tServices:               \"proxy\",\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tJWTClaimsHeaders: map[string]string{\n\t\t\t\t\"x-email\": \"email\",\n\t\t\t},\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource: &config.StringURL{URL: mustParseURL(t, \"https://from.example.com\")},\n\t\t\t\t},\n\t\t\t},\n\t\t}, \"from.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t\t},\n\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\t\"cluster\": \"policy-12\",\n\t\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\t\"x-pomerium-jwt-assertion\",\n\t\t\t\t\t\t\"x-pomerium-jwt-assertion-for\",\n\t\t\t\t\t\t\"x-email\",\n\t\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t`, routes)\n\t})\n}\n\nfunc Test_buildPolicyRoutesRewrite(t *testing.T) {\n\tdefer func(f func(*config.Policy) string) {\n\t\tgetClusterID = f\n\t}(getClusterID)\n\tgetClusterID = policyNameFunc()\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\tCookieName:             \"pomerium\",\n\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\tPolicies: []config.Policy{\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tPrefixRewrite:       \"/foo\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:                   &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                       mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders:      true,\n\t\t\t\tRegexRewritePattern:      \"^/service/([^/]+)(/.*)$\",\n\t\t\t\tRegexRewriteSubstitution: \"\\\\2/instance/\\\\1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tHostRewrite:         \"literal.example.com\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tHostRewriteHeader:   \"HOST_HEADER\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:                           &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                               mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders:              true,\n\t\t\t\tHostPathRegexRewritePattern:      \"^/(.+)/.+$\",\n\t\t\t\tHostPathRegexRewriteSubstitution: \"\\\\1\",\n\t\t\t},\n\t\t},\n\t}, \"example.com\")\n\trequire.NoError(t, err)\n\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-1\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-1\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"prefixRewrite\": \"/foo\",\n\t\t\t\t\t\"cluster\": \"policy-2\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-2\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"regexRewrite\": {\n\t\t\t\t\t\t\"pattern\": {\n\t\t\t\t\t\t\t\"googleRe2\": {},\n\t\t\t\t\t\t\t\"regex\": \"^/service/([^/]+)(/.*)$\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"substitution\": \"\\\\2/instance/\\\\1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"cluster\": \"policy-3\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-3\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"hostRewriteLiteral\": \"literal.example.com\",\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-4\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-4\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"hostRewriteHeader\": \"HOST_HEADER\",\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-5\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-5\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"hostRewritePathRegex\": {\n\t\t\t\t\t\t\"pattern\": {\n\t\t\t\t\t\t\t\"googleRe2\": {},\n\t\t\t\t\t\t\t\"regex\": \"^/(.+)/.+$\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"substitution\": \"\\\\1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-6\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t`, routes)\n}\n\nfunc Test_buildPolicyRouteRedirectAction(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\tt.Run(\"HTTPSRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tHTTPSRedirect: proto.Bool(true),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tSchemeRewriteSpecifier: &envoy_config_route_v3.RedirectAction_HttpsRedirect{\n\t\t\t\tHttpsRedirect: true,\n\t\t\t},\n\t\t}, action)\n\n\t\taction, err = b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tHTTPSRedirect: proto.Bool(false),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tSchemeRewriteSpecifier: &envoy_config_route_v3.RedirectAction_HttpsRedirect{\n\t\t\t\tHttpsRedirect: false,\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"SchemeRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tSchemeRedirect: proto.String(\"https\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tSchemeRewriteSpecifier: &envoy_config_route_v3.RedirectAction_SchemeRedirect{\n\t\t\t\tSchemeRedirect: \"https\",\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"HostRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tHostRedirect: proto.String(\"HOST\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tHostRedirect: \"HOST\",\n\t\t}, action)\n\t})\n\tt.Run(\"PortRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tPortRedirect: proto.Uint32(1234),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tPortRedirect: 1234,\n\t\t}, action)\n\t})\n\tt.Run(\"PathRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tPathRedirect: proto.String(\"PATH\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tPathRewriteSpecifier: &envoy_config_route_v3.RedirectAction_PathRedirect{\n\t\t\t\tPathRedirect: \"PATH\",\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"PrefixRewrite\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tPrefixRewrite: proto.String(\"PREFIX_REWRITE\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tPathRewriteSpecifier: &envoy_config_route_v3.RedirectAction_PrefixRewrite{\n\t\t\t\tPrefixRewrite: \"PREFIX_REWRITE\",\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"ResponseCode\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tResponseCode: proto.Int32(301),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tResponseCode: 301,\n\t\t}, action)\n\t})\n\tt.Run(\"StripQuery\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tStripQuery: proto.Bool(true),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tStripQuery: true,\n\t\t}, action)\n\t})\n}\n\nfunc TestPolicyName(t *testing.T) {\n\t// policy names should form a unique ID when converted to envoy cluster names\n\t// however for metrics purposes we keep original name if present\n\tassert.NotEmpty(t, getClusterID(&config.Policy{}))\n\tassert.Empty(t, getClusterStatsName(&config.Policy{}))\n\tassert.True(t, strings.HasPrefix(getClusterID(&config.Policy{EnvoyOpts: &envoy_config_cluster_v3.Cluster{Name: \"my-pomerium-cluster\"}}), \"my-pomerium-cluster\"))\n\tassert.NotEqual(t, getClusterID(&config.Policy{EnvoyOpts: &envoy_config_cluster_v3.Cluster{Name: \"my-pomerium-cluster\"}}), \"my-pomerium-cluster\")\n\tassert.Equal(t, getClusterStatsName(&config.Policy{EnvoyOpts: &envoy_config_cluster_v3.Cluster{Name: \"my-pomerium-cluster\"}}), \"my-pomerium-cluster\")\n}\n\nfunc mustParseURL(t *testing.T, str string) *url.URL {\n\tu, err := url.Parse(str)\n\trequire.NoError(t, err, str)\n\treturn u\n}\n", "package config\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/middleware\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/metrics\"\n\n\t\"github.com/rs/zerolog\"\n)\n\n// A MetricsManager manages metrics for a given configuration.\ntype MetricsManager struct {\n\tmu             sync.RWMutex\n\tinstallationID string\n\tserviceName    string\n\taddr           string\n\tbasicAuth      string\n\thandler        http.Handler\n}\n\n// NewMetricsManager creates a new MetricsManager.\nfunc NewMetricsManager(ctx context.Context, src Source) *MetricsManager {\n\tctx = log.WithContext(ctx, func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"service\", \"metrics_manager\")\n\t})\n\tmgr := &MetricsManager{}\n\tmetrics.RegisterInfoMetrics()\n\tsrc.OnConfigChange(ctx, mgr.OnConfigChange)\n\tmgr.OnConfigChange(ctx, src.GetConfig())\n\treturn mgr\n}\n\n// Close closes any underlying http server.\nfunc (mgr *MetricsManager) Close() error {\n\treturn nil\n}\n\n// OnConfigChange updates the metrics manager when configuration is changed.\nfunc (mgr *MetricsManager) OnConfigChange(ctx context.Context, cfg *Config) {\n\tmgr.mu.Lock()\n\tdefer mgr.mu.Unlock()\n\n\tmgr.updateInfo(cfg)\n\tmgr.updateServer(cfg)\n}\n\nfunc (mgr *MetricsManager) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tmgr.mu.RLock()\n\tdefer mgr.mu.RUnlock()\n\n\tif mgr.handler == nil {\n\t\thttp.NotFound(w, r)\n\t\treturn\n\t}\n\tmgr.handler.ServeHTTP(w, r)\n}\n\nfunc (mgr *MetricsManager) updateInfo(cfg *Config) {\n\tserviceName := telemetry.ServiceName(cfg.Options.Services)\n\tif serviceName == mgr.serviceName {\n\t\treturn\n\t}\n\n\thostname, err := os.Hostname()\n\tif err != nil {\n\t\tlog.Error(context.TODO()).Err(err).Msg(\"telemetry/metrics: failed to get OS hostname\")\n\t\thostname = \"__unknown__\"\n\t}\n\n\tmetrics.SetBuildInfo(serviceName, hostname, cfg.EnvoyVersion)\n\tmgr.serviceName = serviceName\n}\n\nfunc (mgr *MetricsManager) updateServer(cfg *Config) {\n\tif cfg.Options.MetricsAddr == mgr.addr &&\n\t\tcfg.Options.MetricsBasicAuth == mgr.basicAuth &&\n\t\tcfg.Options.InstallationID == mgr.installationID {\n\t\treturn\n\t}\n\n\tmgr.addr = cfg.Options.MetricsAddr\n\tmgr.basicAuth = cfg.Options.MetricsBasicAuth\n\tmgr.installationID = cfg.Options.InstallationID\n\tmgr.handler = nil\n\n\tif mgr.addr == \"\" {\n\t\tlog.Info(context.TODO()).Msg(\"metrics: http server disabled\")\n\t\treturn\n\t}\n\n\thandler, err := metrics.PrometheusHandler(EnvoyAdminURL, mgr.installationID)\n\tif err != nil {\n\t\tlog.Error(context.TODO()).Err(err).Msg(\"metrics: failed to create prometheus handler\")\n\t\treturn\n\t}\n\n\tif username, password, ok := cfg.Options.GetMetricsBasicAuth(); ok {\n\t\thandler = middleware.RequireBasicAuth(username, password)(handler)\n\t}\n\n\tmgr.handler = handler\n}\n", "package config\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/mitchellh/mapstructure\"\n\t\"github.com/spf13/viper\"\n\t\"github.com/volatiletech/null/v9\"\n\n\t\"github.com/pomerium/pomerium/internal/directory/azure\"\n\t\"github.com/pomerium/pomerium/internal/directory/github\"\n\t\"github.com/pomerium/pomerium/internal/directory/gitlab\"\n\t\"github.com/pomerium/pomerium/internal/directory/google\"\n\t\"github.com/pomerium/pomerium/internal/directory/okta\"\n\t\"github.com/pomerium/pomerium/internal/directory/onelogin\"\n\t\"github.com/pomerium/pomerium/internal/hashutil\"\n\t\"github.com/pomerium/pomerium/internal/identity/oauth\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/metrics\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n\t\"github.com/pomerium/pomerium/pkg/cryptutil\"\n\t\"github.com/pomerium/pomerium/pkg/grpc/config\"\n)\n\n// DisableHeaderKey is the key used to check whether to disable setting header\nconst DisableHeaderKey = \"disable\"\n\nconst (\n\tidpCustomScopesDocLink = \"https://www.pomerium.io/reference/#identity-provider-scopes\"\n\tidpCustomScopesWarnMsg = \"config: using custom scopes may result in undefined behavior, see: \" + idpCustomScopesDocLink\n)\n\n// DefaultAlternativeAddr is the address used is two services are competing over\n// the same listener. Typically this is invisible to the end user (e.g. localhost)\n// gRPC server, or is used for healthchecks (authorize only service)\nconst DefaultAlternativeAddr = \":5443\"\n\n// EnvoyAdminURL indicates where the envoy control plane is listening\nvar EnvoyAdminURL = &url.URL{Host: \"127.0.0.1:9901\", Scheme: \"http\"}\n\n// The randomSharedKey is used if no shared key is supplied in all-in-one mode.\nvar randomSharedKey = cryptutil.NewBase64Key()\n\n// Options are the global environmental flags used to set up pomerium's services.\n// Use NewXXXOptions() methods for a safely initialized data structure.\ntype Options struct {\n\t// InstallationID is used to indicate a unique installation of pomerium. Useful for telemetry.\n\tInstallationID string `mapstructure:\"installation_id\" yaml:\"installation_id,omitempty\"`\n\n\t// Debug outputs human-readable logs to Stdout.\n\tDebug bool `mapstructure:\"pomerium_debug\" yaml:\"pomerium_debug,omitempty\"`\n\n\t// LogLevel sets the global override for log level. All Loggers will use at least this value.\n\t// Possible options are \"info\",\"warn\",\"debug\" and \"error\". Defaults to \"info\".\n\tLogLevel string `mapstructure:\"log_level\" yaml:\"log_level,omitempty\"`\n\n\t// ProxyLogLevel sets the log level for the proxy service.\n\t// Possible options are \"info\",\"warn\", and \"error\". Defaults to the value of `LogLevel`.\n\tProxyLogLevel string `mapstructure:\"proxy_log_level\" yaml:\"proxy_log_level,omitempty\"`\n\n\t// SharedKey is the shared secret authorization key used to mutually authenticate\n\t// requests between services.\n\tSharedKey string `mapstructure:\"shared_secret\" yaml:\"shared_secret,omitempty\"`\n\n\t// Services is a list enabled service mode. If none are selected, \"all\" is used.\n\t// Available options are : \"all\", \"authenticate\", \"proxy\".\n\tServices string `mapstructure:\"services\" yaml:\"services,omitempty\"`\n\n\t// Addr specifies the host and port on which the server should serve\n\t// HTTPS requests. If empty, \":443\" (localhost:443) is used.\n\tAddr string `mapstructure:\"address\" yaml:\"address,omitempty\"`\n\n\t// InsecureServer when enabled disables all transport security.\n\t// In this mode, Pomerium is susceptible to man-in-the-middle attacks.\n\t// This should be used only for testing.\n\tInsecureServer bool `mapstructure:\"insecure_server\" yaml:\"insecure_server,omitempty\"`\n\n\t// DNSLookupFamily is the DNS IP address resolution policy.\n\t// If this setting is not specified, the value defaults to AUTO.\n\tDNSLookupFamily string `mapstructure:\"dns_lookup_family\" yaml:\"dns_lookup_family,omitempty\"`\n\n\tCertificateFiles []certificateFilePair `mapstructure:\"certificates\" yaml:\"certificates,omitempty\"`\n\n\t// Cert and Key is the x509 certificate used to create the HTTPS server.\n\tCert string `mapstructure:\"certificate\" yaml:\"certificate,omitempty\"`\n\tKey  string `mapstructure:\"certificate_key\" yaml:\"certificate_key,omitempty\"`\n\n\t// CertFile and KeyFile is the x509 certificate used to hydrate TLSCertificate\n\tCertFile string `mapstructure:\"certificate_file\" yaml:\"certificate_file,omitempty\"`\n\tKeyFile  string `mapstructure:\"certificate_key_file\" yaml:\"certificate_key_file,omitempty\"`\n\n\t// HttpRedirectAddr, if set, specifies the host and port to run the HTTP\n\t// to HTTPS redirect server on. If empty, no redirect server is started.\n\tHTTPRedirectAddr string `mapstructure:\"http_redirect_addr\" yaml:\"http_redirect_addr,omitempty\"`\n\n\t// Timeout settings : https://github.com/pomerium/pomerium/issues/40\n\tReadTimeout  time.Duration `mapstructure:\"timeout_read\" yaml:\"timeout_read,omitempty\"`\n\tWriteTimeout time.Duration `mapstructure:\"timeout_write\" yaml:\"timeout_write,omitempty\"`\n\tIdleTimeout  time.Duration `mapstructure:\"timeout_idle\" yaml:\"timeout_idle,omitempty\"`\n\n\t// Policies define per-route configuration and access control policies.\n\tPolicies   []Policy `mapstructure:\"policy\"`\n\tPolicyFile string   `mapstructure:\"policy_file\" yaml:\"policy_file,omitempty\"`\n\tRoutes     []Policy `mapstructure:\"routes\"`\n\n\t// AdditionalPolicies are any additional policies added to the options.\n\tAdditionalPolicies []Policy `yaml:\"-\"`\n\n\t// AuthenticateURL represents the externally accessible http endpoints\n\t// used for authentication requests and callbacks\n\tAuthenticateURLString         string `mapstructure:\"authenticate_service_url\" yaml:\"authenticate_service_url,omitempty\"`\n\tAuthenticateInternalURLString string `mapstructure:\"authenticate_internal_service_url\" yaml:\"authenticate_internal_service_url,omitempty\"`\n\t// SignOutRedirectURL represents the url that  user will be redirected to after signing out.\n\tSignOutRedirectURLString string `mapstructure:\"signout_redirect_url\" yaml:\"signout_redirect_url,omitempty\"`\n\n\t// AuthenticateCallbackPath is the path to the HTTP endpoint that will\n\t// receive the response from your identity provider. The value must exactly\n\t// match one of the authorized redirect URIs for the OAuth 2.0 client.\n\t// Defaults to: `/oauth2/callback`\n\tAuthenticateCallbackPath string `mapstructure:\"authenticate_callback_path\" yaml:\"authenticate_callback_path,omitempty\"`\n\n\t// Session/Cookie management\n\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\n\tCookieName     string        `mapstructure:\"cookie_name\" yaml:\"cookie_name,omitempty\"`\n\tCookieSecret   string        `mapstructure:\"cookie_secret\" yaml:\"cookie_secret,omitempty\"`\n\tCookieDomain   string        `mapstructure:\"cookie_domain\" yaml:\"cookie_domain,omitempty\"`\n\tCookieSecure   bool          `mapstructure:\"cookie_secure\" yaml:\"cookie_secure,omitempty\"`\n\tCookieHTTPOnly bool          `mapstructure:\"cookie_http_only\" yaml:\"cookie_http_only,omitempty\"`\n\tCookieExpire   time.Duration `mapstructure:\"cookie_expire\" yaml:\"cookie_expire,omitempty\"`\n\n\t// Identity provider configuration variables as specified by RFC6749\n\t// https://openid.net/specs/openid-connect-basic-1_0.html#RFC6749\n\tClientID       string   `mapstructure:\"idp_client_id\" yaml:\"idp_client_id,omitempty\"`\n\tClientSecret   string   `mapstructure:\"idp_client_secret\" yaml:\"idp_client_secret,omitempty\"`\n\tProvider       string   `mapstructure:\"idp_provider\" yaml:\"idp_provider,omitempty\"`\n\tProviderURL    string   `mapstructure:\"idp_provider_url\" yaml:\"idp_provider_url,omitempty\"`\n\tScopes         []string `mapstructure:\"idp_scopes\" yaml:\"idp_scopes,omitempty\"`\n\tServiceAccount string   `mapstructure:\"idp_service_account\" yaml:\"idp_service_account,omitempty\"`\n\t// Identity provider refresh directory interval/timeout settings.\n\tRefreshDirectoryTimeout  time.Duration `mapstructure:\"idp_refresh_directory_timeout\" yaml:\"idp_refresh_directory_timeout,omitempty\"`\n\tRefreshDirectoryInterval time.Duration `mapstructure:\"idp_refresh_directory_interval\" yaml:\"idp_refresh_directory_interval,omitempty\"`\n\tQPS                      float64       `mapstructure:\"idp_qps\" yaml:\"idp_qps\"`\n\n\t// RequestParams are custom request params added to the signin request as\n\t// part of an Oauth2 code flow.\n\t//\n\t// https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml\n\t// https://openid.net/specs/openid-connect-basic-1_0.html#RequestParameters\n\tRequestParams map[string]string `mapstructure:\"idp_request_params\" yaml:\"idp_request_params,omitempty\"`\n\n\t// AuthorizeURLString is the routable destination of the authorize service's\n\t// gRPC endpoint. NOTE: As many load balancers do not support\n\t// externally routed gRPC so this may be an internal location.\n\tAuthorizeURLString         string   `mapstructure:\"authorize_service_url\" yaml:\"authorize_service_url,omitempty\"`\n\tAuthorizeURLStrings        []string `mapstructure:\"authorize_service_urls\" yaml:\"authorize_service_urls,omitempty\"`\n\tAuthorizeInternalURLString string   `mapstructure:\"authorize_internal_service_url\" yaml:\"authorize_internal_service_url,omitempty\"`\n\n\t// Settings to enable custom behind-the-ingress service communication\n\tOverrideCertificateName string `mapstructure:\"override_certificate_name\" yaml:\"override_certificate_name,omitempty\"`\n\tCA                      string `mapstructure:\"certificate_authority\" yaml:\"certificate_authority,omitempty\"`\n\tCAFile                  string `mapstructure:\"certificate_authority_file\" yaml:\"certificate_authority_file,omitempty\"`\n\n\t// SigningKey is the private key used to add a JWT-signature to upstream requests.\n\t// https://www.pomerium.io/docs/topics/getting-users-identity.html\n\tSigningKey string `mapstructure:\"signing_key\" yaml:\"signing_key,omitempty\"`\n\n\tHeadersEnv string `yaml:\",omitempty\"`\n\t// SetResponseHeaders to set on all proxied requests. Add a 'disable' key map to turn off.\n\tSetResponseHeaders map[string]string `yaml:\",omitempty\"`\n\n\t// List of JWT claims to insert as x-pomerium-claim-* headers on proxied requests\n\tJWTClaimsHeaders JWTClaimHeaders `mapstructure:\"jwt_claims_headers\" yaml:\"jwt_claims_headers,omitempty\"`\n\n\tDefaultUpstreamTimeout time.Duration `mapstructure:\"default_upstream_timeout\" yaml:\"default_upstream_timeout,omitempty\"`\n\n\t// Address/Port to bind to for prometheus metrics\n\tMetricsAddr string `mapstructure:\"metrics_address\" yaml:\"metrics_address,omitempty\"`\n\t// - require basic auth for prometheus metrics, base64 encoded user:pass string\n\tMetricsBasicAuth string `mapstructure:\"metrics_basic_auth\" yaml:\"metrics_basic_auth,omitempty\"`\n\t// - TLS options\n\tMetricsCertificate        string `mapstructure:\"metrics_certificate\" yaml:\"metrics_certificate,omitempty\"`\n\tMetricsCertificateKey     string `mapstructure:\"metrics_certificate_key\" yaml:\"metrics_certificate_key,omitempty\"`\n\tMetricsCertificateFile    string `mapstructure:\"metrics_certificate_file\" yaml:\"metrics_certificate_file,omitempty\"`\n\tMetricsCertificateKeyFile string `mapstructure:\"metrics_certificate_key_file\" yaml:\"metrics_certificate_key_file,omitempty\"`\n\tMetricsClientCA           string `mapstructure:\"metrics_client_ca\" yaml:\"metrics_client_ca,omitempty\"`\n\tMetricsClientCAFile       string `mapstructure:\"metrics_client_ca_file\" yaml:\"metrics_client_ca_file,omitempty\"`\n\n\t// Tracing shared settings\n\tTracingProvider   string  `mapstructure:\"tracing_provider\" yaml:\"tracing_provider,omitempty\"`\n\tTracingSampleRate float64 `mapstructure:\"tracing_sample_rate\" yaml:\"tracing_sample_rate,omitempty\"`\n\n\t// Datadog tracing address\n\tTracingDatadogAddress string `mapstructure:\"tracing_datadog_address\" yaml:\"tracing_datadog_address,omitempty\"`\n\n\t//  Jaeger\n\t//\n\t// CollectorEndpoint is the full url to the Jaeger HTTP Thrift collector.\n\t// For example, http://localhost:14268/api/traces\n\tTracingJaegerCollectorEndpoint string `mapstructure:\"tracing_jaeger_collector_endpoint\" yaml:\"tracing_jaeger_collector_endpoint,omitempty\"`\n\t// AgentEndpoint instructs exporter to send spans to jaeger-agent at this address.\n\t// For example, localhost:6831.\n\tTracingJaegerAgentEndpoint string `mapstructure:\"tracing_jaeger_agent_endpoint\" yaml:\"tracing_jaeger_agent_endpoint,omitempty\"`\n\n\t// Zipkin\n\t//\n\t// ZipkinEndpoint configures the zipkin collector URI\n\t// Example: http://zipkin:9411/api/v2/spans\n\tZipkinEndpoint string `mapstructure:\"tracing_zipkin_endpoint\" yaml:\"tracing_zipkin_endpoint\"`\n\n\t// GRPC Service Settings\n\n\t// GRPCAddr specifies the host and port on which the server should serve\n\t// gRPC requests. If running in all-in-one mode, \":5443\" (localhost:5443) is used.\n\tGRPCAddr string `mapstructure:\"grpc_address\" yaml:\"grpc_address,omitempty\"`\n\n\t// GRPCInsecure disables transport security.\n\t// If running in all-in-one mode, defaults to true.\n\tGRPCInsecure bool `mapstructure:\"grpc_insecure\" yaml:\"grpc_insecure,omitempty\"`\n\n\tGRPCClientTimeout       time.Duration `mapstructure:\"grpc_client_timeout\" yaml:\"grpc_client_timeout,omitempty\"`\n\tGRPCClientDNSRoundRobin bool          `mapstructure:\"grpc_client_dns_roundrobin\" yaml:\"grpc_client_dns_roundrobin,omitempty\"`\n\n\t// ForwardAuthEndpoint allows for a given route to be used as a forward-auth\n\t// endpoint instead of a reverse proxy. Some third-party proxies that do not\n\t// have rich access control capabilities (nginx, envoy, ambassador, traefik)\n\t// allow you to delegate and authenticate each request to your website\n\t// with an external server or service. Pomerium can be configured to accept\n\t// these requests with this switch\n\tForwardAuthURLString string `mapstructure:\"forward_auth_url\" yaml:\"forward_auth_url,omitempty\"`\n\n\t// DataBrokerURLString is the routable destination of the databroker service's gRPC endpiont.\n\tDataBrokerURLString         string   `mapstructure:\"databroker_service_url\" yaml:\"databroker_service_url,omitempty\"`\n\tDataBrokerURLStrings        []string `mapstructure:\"databroker_service_urls\" yaml:\"databroker_service_urls,omitempty\"`\n\tDataBrokerInternalURLString string   `mapstructure:\"databroker_internal_service_url\" yaml:\"databroker_internal_service_url,omitempty\"`\n\t// DataBrokerStorageType is the storage backend type that databroker will use.\n\t// Supported type: memory, redis\n\tDataBrokerStorageType string `mapstructure:\"databroker_storage_type\" yaml:\"databroker_storage_type,omitempty\"`\n\t// DataBrokerStorageConnectionString is the data source name for storage backend.\n\tDataBrokerStorageConnectionString string `mapstructure:\"databroker_storage_connection_string\" yaml:\"databroker_storage_connection_string,omitempty\"`\n\tDataBrokerStorageCertFile         string `mapstructure:\"databroker_storage_cert_file\" yaml:\"databroker_storage_cert_file,omitempty\"`\n\tDataBrokerStorageCertKeyFile      string `mapstructure:\"databroker_storage_key_file\" yaml:\"databroker_storage_key_file,omitempty\"`\n\tDataBrokerStorageCAFile           string `mapstructure:\"databroker_storage_ca_file\" yaml:\"databroker_storage_ca_file,omitempty\"`\n\tDataBrokerStorageCertSkipVerify   bool   `mapstructure:\"databroker_storage_tls_skip_verify\" yaml:\"databroker_storage_tls_skip_verify,omitempty\"`\n\n\t// ClientCA is the base64-encoded certificate authority to validate client mTLS certificates against.\n\tClientCA string `mapstructure:\"client_ca\" yaml:\"client_ca,omitempty\"`\n\t// ClientCAFile points to a file that contains the certificate authority to validate client mTLS certificates against.\n\tClientCAFile string `mapstructure:\"client_ca_file\" yaml:\"client_ca_file,omitempty\"`\n\t// ClientCRL is the base64-encoded certificate revocation list for client mTLS certificates.\n\tClientCRL string `mapstructure:\"client_crl\" yaml:\"client_crl,omitempty\"`\n\t// ClientCRLFile points to a file that contains the certificate revocation list for client mTLS certificates.\n\tClientCRLFile string `mapstructure:\"client_crl_file\" yaml:\"client_crl_file,omitempty\"`\n\n\t// GoogleCloudServerlessAuthenticationServiceAccount is the service account to use for GCP serverless authentication.\n\t// If unset, the GCP metadata server will be used to query for identity tokens.\n\tGoogleCloudServerlessAuthenticationServiceAccount string `mapstructure:\"google_cloud_serverless_authentication_service_account\" yaml:\"google_cloud_serverless_authentication_service_account,omitempty\"` //nolint\n\n\t// UseProxyProtocol configures the HTTP listener to require the HAProxy proxy protocol (either v1 or v2) on incoming requests.\n\tUseProxyProtocol bool `mapstructure:\"use_proxy_protocol\" yaml:\"use_proxy_protocol,omitempty\" json:\"use_proxy_protocol,omitempty\"`\n\n\tviper *viper.Viper\n\n\tAutocertOptions `mapstructure:\",squash\" yaml:\",inline\"`\n\n\t// SkipXffAppend instructs proxy not to append its IP address to x-forwarded-for header.\n\t// see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers.html?highlight=skip_xff_append#x-forwarded-for\n\tSkipXffAppend bool `mapstructure:\"skip_xff_append\" yaml:\"skip_xff_append,omitempty\" json:\"skip_xff_append,omitempty\"`\n\t// XffNumTrustedHops determines the trusted client address from x-forwarded-for addresses.\n\t// see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers.html?highlight=xff_num_trusted_hops#x-forwarded-for\n\tXffNumTrustedHops uint32 `mapstructure:\"xff_num_trusted_hops\" yaml:\"xff_num_trusted_hops,omitempty\" json:\"xff_num_trusted_hops,omitempty\"`\n\n\t// Envoy bootstrap options. These do not support dynamic updates.\n\tEnvoyAdminAccessLogPath      string    `mapstructure:\"envoy_admin_access_log_path\" yaml:\"envoy_admin_access_log_path\"`\n\tEnvoyAdminProfilePath        string    `mapstructure:\"envoy_admin_profile_path\" yaml:\"envoy_admin_profile_path\"`\n\tEnvoyAdminAddress            string    `mapstructure:\"envoy_admin_address\" yaml:\"envoy_admin_address\"`\n\tEnvoyBindConfigSourceAddress string    `mapstructure:\"envoy_bind_config_source_address\" yaml:\"envoy_bind_config_source_address,omitempty\"`\n\tEnvoyBindConfigFreebind      null.Bool `mapstructure:\"envoy_bind_config_freebind\" yaml:\"envoy_bind_config_freebind,omitempty\"`\n\n\t// ProgrammaticRedirectDomainWhitelist restricts the allowed redirect URLs when using programmatic login.\n\tProgrammaticRedirectDomainWhitelist []string `mapstructure:\"programmatic_redirect_domain_whitelist\" yaml:\"programmatic_redirect_domain_whitelist,omitempty\" json:\"programmatic_redirect_domain_whitelist,omitempty\"` //nolint\n\n\t// CodecType is the codec to use for downstream connections.\n\tCodecType CodecType `mapstructure:\"codec_type\" yaml:\"codec_type\"`\n\n\tAuditKey *PublicKeyEncryptionKeyOptions `mapstructure:\"audit_key\"`\n}\n\ntype certificateFilePair struct {\n\t// CertFile and KeyFile is the x509 certificate used to hydrate TLSCertificate\n\tCertFile string `mapstructure:\"cert\" yaml:\"cert,omitempty\"`\n\tKeyFile  string `mapstructure:\"key\" yaml:\"key,omitempty\"`\n}\n\n// DefaultOptions are the default configuration options for pomerium\nvar defaultOptions = Options{\n\tDebug:                  false,\n\tLogLevel:               \"info\",\n\tServices:               \"all\",\n\tCookieHTTPOnly:         true,\n\tCookieSecure:           true,\n\tCookieExpire:           14 * time.Hour,\n\tCookieName:             \"_pomerium\",\n\tDefaultUpstreamTimeout: 30 * time.Second,\n\tSetResponseHeaders: map[string]string{\n\t\t\"X-Frame-Options\":           \"SAMEORIGIN\",\n\t\t\"X-XSS-Protection\":          \"1; mode=block\",\n\t\t\"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains; preload\",\n\t},\n\tAddr:                     \":443\",\n\tReadTimeout:              30 * time.Second,\n\tWriteTimeout:             0, // support streaming by default\n\tIdleTimeout:              5 * time.Minute,\n\tGRPCAddr:                 \":443\",\n\tGRPCClientTimeout:        10 * time.Second, // Try to withstand transient service failures for a single request\n\tGRPCClientDNSRoundRobin:  true,\n\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\tTracingSampleRate:        0.0001,\n\tRefreshDirectoryInterval: 10 * time.Minute,\n\tRefreshDirectoryTimeout:  1 * time.Minute,\n\tQPS:                      1.0,\n\n\tAutocertOptions: AutocertOptions{\n\t\tFolder: dataDir(),\n\t},\n\tDataBrokerStorageType:               \"memory\",\n\tSkipXffAppend:                       false,\n\tXffNumTrustedHops:                   0,\n\tEnvoyAdminAccessLogPath:             os.DevNull,\n\tEnvoyAdminProfilePath:               os.DevNull,\n\tEnvoyAdminAddress:                   \"127.0.0.1:9901\",\n\tProgrammaticRedirectDomainWhitelist: []string{\"localhost\"},\n}\n\n// NewDefaultOptions returns a copy the default options. It's the caller's\n// responsibility to do a follow up Validate call.\nfunc NewDefaultOptions() *Options {\n\tnewOpts := defaultOptions\n\tnewOpts.viper = viper.New()\n\treturn &newOpts\n}\n\n// newOptionsFromConfig builds the main binary's configuration options by parsing\n// environmental variables and config file\nfunc newOptionsFromConfig(configFile string) (*Options, error) {\n\to, err := optionsFromViper(configFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"config: options from config file %q: %w\", configFile, err)\n\t}\n\tserviceName := telemetry.ServiceName(o.Services)\n\tmetrics.AddPolicyCountCallback(serviceName, func() int64 {\n\t\treturn int64(len(o.GetAllPolicies()))\n\t})\n\n\treturn o, nil\n}\n\nfunc optionsFromViper(configFile string) (*Options, error) {\n\t// start a copy of the default options\n\to := NewDefaultOptions()\n\tv := o.viper\n\t// Load up config\n\terr := bindEnvs(o, v)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to bind options to env vars: %w\", err)\n\t}\n\n\tif configFile != \"\" {\n\t\tv.SetConfigFile(configFile)\n\t\tif err := v.ReadInConfig(); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read config: %w\", err)\n\t\t}\n\t}\n\n\tvar metadata mapstructure.Metadata\n\tif err := v.Unmarshal(o, ViperPolicyHooks, func(c *mapstructure.DecoderConfig) { c.Metadata = &metadata }); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal config: %w\", err)\n\t}\n\tcheckUnusedConfigFields(configFile, metadata.Unused)\n\n\t// This is necessary because v.Unmarshal will overwrite .viper field.\n\to.viper = v\n\n\tif err := o.Validate(); err != nil {\n\t\treturn nil, fmt.Errorf(\"validation error %w\", err)\n\t}\n\treturn o, nil\n}\n\nfunc checkUnusedConfigFields(configFile string, unused []string) {\n\tkeys := make([]string, 0, len(unused))\n\tfor _, k := range unused {\n\t\tif !strings.HasPrefix(k, \"policy[\") { // policy's embedded protobuf structs are decoded by separate hook and are unknown to mapstructure\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\tif len(keys) == 0 {\n\t\treturn\n\t}\n\tlog.Warn(context.Background()).Str(\"config_file\", configFile).Strs(\"keys\", keys).Msg(\"config contained unknown keys that were ignored\")\n}\n\n// parsePolicy initializes policy to the options from either base64 environmental\n// variables or from a file\nfunc (o *Options) parsePolicy() error {\n\tvar policies []Policy\n\tif err := o.viper.UnmarshalKey(\"policy\", &policies, ViperPolicyHooks); err != nil {\n\t\treturn err\n\t}\n\tif len(policies) != 0 {\n\t\to.Policies = policies\n\t}\n\n\tvar routes []Policy\n\tif err := o.viper.UnmarshalKey(\"routes\", &routes, ViperPolicyHooks); err != nil {\n\t\treturn err\n\t}\n\tif len(routes) != 0 {\n\t\to.Routes = routes\n\t}\n\n\t// Finish initializing policies\n\tfor i := range o.Policies {\n\t\tp := &o.Policies[i]\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor i := range o.Routes {\n\t\tp := &o.Routes[i]\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor i := range o.AdditionalPolicies {\n\t\tp := &o.AdditionalPolicies[i]\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (o *Options) viperSet(key string, value interface{}) {\n\to.viper.Set(key, value)\n}\n\nfunc (o *Options) viperIsSet(key string) bool {\n\treturn o.viper.IsSet(key)\n}\n\n// parseHeaders handles unmarshalling any custom headers correctly from the\n// environment or viper's parsed keys\nfunc (o *Options) parseHeaders(ctx context.Context) error {\n\tvar headers map[string]string\n\tif o.HeadersEnv != \"\" {\n\t\t// Handle JSON by default via viper\n\t\tif headers = o.viper.GetStringMapString(\"HeadersEnv\"); len(headers) == 0 {\n\t\t\t// Try to parse \"Key1:Value1,Key2:Value2\" syntax\n\t\t\theaderSlice := strings.Split(o.HeadersEnv, \",\")\n\t\t\tfor n := range headerSlice {\n\t\t\t\theaderFields := strings.SplitN(headerSlice[n], \":\", 2)\n\t\t\t\tif len(headerFields) == 2 {\n\t\t\t\t\theaders[headerFields[0]] = headerFields[1]\n\t\t\t\t} else {\n\t\t\t\t\t// Something went wrong\n\t\t\t\t\treturn fmt.Errorf(\"failed to decode headers from '%s'\", o.HeadersEnv)\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\to.SetResponseHeaders = headers\n\t\treturn nil\n\t}\n\n\tif o.viperIsSet(\"set_response_headers\") {\n\t\tif err := o.viper.UnmarshalKey(\"set_response_headers\", &headers); err != nil {\n\t\t\treturn fmt.Errorf(\"header %s failed to parse: %w\", o.viper.Get(\"set_response_headers\"), err)\n\t\t}\n\t\to.SetResponseHeaders = headers\n\t}\n\treturn nil\n}\n\n// bindEnvs binds a viper instance to each env var of an Options struct based\n// on the mapstructure tag\nfunc bindEnvs(o *Options, v *viper.Viper) error {\n\ttagName := `mapstructure`\n\tt := reflect.TypeOf(*o)\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tenvName := field.Tag.Get(tagName)\n\t\terr := v.BindEnv(envName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to bind field '%s' to env var '%s': %w\", field.Name, envName, err)\n\t\t}\n\n\t}\n\n\t// Statically bind fields\n\terr := v.BindEnv(\"Policy\", \"POLICY\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to bind field 'Policy' to env var 'POLICY': %w\", err)\n\t}\n\terr = v.BindEnv(\"HeadersEnv\", \"HEADERS\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to bind field 'HeadersEnv' to env var 'HEADERS': %w\", err)\n\t}\n\t// autocert options\n\tao := reflect.TypeOf(o.AutocertOptions)\n\tfor i := 0; i < ao.NumField(); i++ {\n\t\tfield := ao.Field(i)\n\t\tenvName := field.Tag.Get(tagName)\n\t\terr := v.BindEnv(envName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to bind field '%s' to env var '%s': %w\", field.Name, envName, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Validate ensures the Options fields are valid, and hydrated.\nfunc (o *Options) Validate() error {\n\tctx := context.TODO()\n\tif !IsValidService(o.Services) {\n\t\treturn fmt.Errorf(\"config: %s is an invalid service type\", o.Services)\n\t}\n\n\tswitch o.DataBrokerStorageType {\n\tcase StorageInMemoryName:\n\tcase StorageRedisName:\n\t\tif o.DataBrokerStorageConnectionString == \"\" {\n\t\t\treturn errors.New(\"config: missing databroker storage backend dsn\")\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"config: unknown databroker storage backend type\")\n\t}\n\n\t_, err := o.GetSharedKey()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"config: invalid shared secret: %w\", err)\n\t}\n\n\tif o.AuthenticateURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthenticateURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authenticate-url %s : %w\", o.AuthenticateURLString, err)\n\t\t}\n\t}\n\tif o.AuthenticateInternalURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthenticateInternalURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authenticate-internal-url %s : %w\", o.AuthenticateInternalURLString, err)\n\t\t}\n\t}\n\n\tif o.SignOutRedirectURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.SignOutRedirectURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad signout-redirect-url %s : %w\", o.SignOutRedirectURLString, err)\n\t\t}\n\t}\n\n\tif o.AuthorizeURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthorizeURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authorize-url %s : %w\", o.AuthorizeURLString, err)\n\t\t}\n\t}\n\tif o.AuthorizeInternalURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthorizeInternalURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authorize-internal-url %s : %w\", o.AuthorizeInternalURLString, err)\n\t\t}\n\t}\n\n\tif o.DataBrokerURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.DataBrokerURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker service url %s : %w\", o.DataBrokerURLString, err)\n\t\t}\n\t}\n\tif o.DataBrokerInternalURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.DataBrokerInternalURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker internal service url %s : %w\", o.DataBrokerInternalURLString, err)\n\t\t}\n\t}\n\n\tif o.ForwardAuthURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.ForwardAuthURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad forward-auth-url %s : %w\", o.ForwardAuthURLString, err)\n\t\t}\n\t}\n\n\tif o.PolicyFile != \"\" {\n\t\treturn errors.New(\"config: policy file setting is deprecated\")\n\t}\n\tif err := o.parsePolicy(); err != nil {\n\t\treturn fmt.Errorf(\"config: failed to parse policy: %w\", err)\n\t}\n\n\tif err := o.parseHeaders(ctx); err != nil {\n\t\treturn fmt.Errorf(\"config: failed to parse headers: %w\", err)\n\t}\n\n\thasCert := false\n\n\tif o.Cert != \"\" || o.Key != \"\" {\n\t\t_, err := cryptutil.CertificateFromBase64(o.Cert, o.Key)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad cert base64 %w\", err)\n\t\t}\n\t\thasCert = true\n\t}\n\n\tfor _, c := range o.CertificateFiles {\n\t\t_, err := cryptutil.CertificateFromBase64(c.CertFile, c.KeyFile)\n\t\tif err != nil {\n\t\t\t_, err = cryptutil.CertificateFromFile(c.CertFile, c.KeyFile)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad cert entry, base64 or file reference invalid. %w\", err)\n\t\t}\n\t\thasCert = true\n\t}\n\n\tif o.CertFile != \"\" || o.KeyFile != \"\" {\n\t\t_, err := cryptutil.CertificateFromFile(o.CertFile, o.KeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad cert file %w\", err)\n\t\t}\n\t\thasCert = true\n\t}\n\n\tif o.DataBrokerStorageCertFile != \"\" || o.DataBrokerStorageCertKeyFile != \"\" {\n\t\t_, err := cryptutil.CertificateFromFile(o.DataBrokerStorageCertFile, o.DataBrokerStorageCertKeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker cert file %w\", err)\n\t\t}\n\t}\n\n\tif o.DataBrokerStorageCAFile != \"\" {\n\t\tif _, err := os.Stat(o.DataBrokerStorageCAFile); err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker ca file: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCA != \"\" {\n\t\tif _, err := base64.StdEncoding.DecodeString(o.ClientCA); err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client ca base64: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCAFile != \"\" {\n\t\t_, err := os.ReadFile(o.ClientCAFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client ca file: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCRL != \"\" {\n\t\t_, err = cryptutil.CRLFromBase64(o.ClientCRL)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client crl base64: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCRLFile != \"\" {\n\t\t_, err = cryptutil.CRLFromFile(o.ClientCRLFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client crl file: %w\", err)\n\t\t}\n\t}\n\n\t// if no service account was defined, there should not be any policies that\n\t// assert group membership (except for azure which can be derived from the client\n\t// id, secret and provider url)\n\tif o.ServiceAccount == \"\" && o.Provider != \"azure\" {\n\t\tfor _, p := range o.GetAllPolicies() {\n\t\t\tif len(p.AllowedGroups) != 0 {\n\t\t\t\treturn fmt.Errorf(\"config: `allowed_groups` requires `idp_service_account`\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// strip quotes from redirect address (#811)\n\to.HTTPRedirectAddr = strings.Trim(o.HTTPRedirectAddr, `\"'`)\n\n\tif !o.InsecureServer && !hasCert && !o.AutocertOptions.Enable {\n\t\tlog.Warn(ctx).Msg(\"neither `autocert`, \" +\n\t\t\t\"`insecure_server` or manually provided certificates were provided, server will be using a self-signed certificate\")\n\t}\n\n\tswitch o.Provider {\n\tcase azure.Name, github.Name, gitlab.Name, google.Name, okta.Name, onelogin.Name:\n\t\tif len(o.Scopes) > 0 {\n\t\t\tlog.Warn(ctx).Msg(idpCustomScopesWarnMsg)\n\t\t}\n\tdefault:\n\t}\n\n\tif err := ValidateDNSLookupFamily(o.DNSLookupFamily); err != nil {\n\t\treturn fmt.Errorf(\"config: %w\", err)\n\t}\n\n\tif o.MetricsAddr != \"\" {\n\t\tif err := ValidateMetricsAddress(o.MetricsAddr); err != nil {\n\t\t\treturn fmt.Errorf(\"config: invalid metrics_addr: %w\", err)\n\t\t}\n\t}\n\n\t// validate metrics basic auth\n\tif o.MetricsBasicAuth != \"\" {\n\t\tstr, err := base64.StdEncoding.DecodeString(o.MetricsBasicAuth)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: metrics_basic_auth must be a base64 encoded string\")\n\t\t}\n\n\t\tif !strings.Contains(string(str), \":\") {\n\t\t\treturn fmt.Errorf(\"config: metrics_basic_auth should contain a user name and password separated by a colon\")\n\t\t}\n\t}\n\n\tif o.MetricsCertificate != \"\" && o.MetricsCertificateKey != \"\" {\n\t\t_, err := cryptutil.CertificateFromBase64(o.MetricsCertificate, o.MetricsCertificateKey)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: invalid metrics_certificate or metrics_certificate_key: %w\", err)\n\t\t}\n\t}\n\n\tif o.MetricsCertificateFile != \"\" && o.MetricsCertificateKeyFile != \"\" {\n\t\t_, err := cryptutil.CertificateFromFile(o.MetricsCertificateFile, o.MetricsCertificateKeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: invalid metrics_certificate_file or metrics_certificate_key_file: %w\", err)\n\t\t}\n\t}\n\n\t// validate the Autocert options\n\terr = o.AutocertOptions.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// GetAuthenticateURL returns the AuthenticateURL in the options or 127.0.0.1.\nfunc (o *Options) GetAuthenticateURL() (*url.URL, error) {\n\trawurl := o.AuthenticateURLString\n\tif rawurl == \"\" {\n\t\trawurl = \"https://127.0.0.1\"\n\t}\n\treturn urlutil.ParseAndValidateURL(rawurl)\n}\n\n// GetInternalAuthenticateURL returns the internal AuthenticateURL in the options or the AuthenticateURL.\nfunc (o *Options) GetInternalAuthenticateURL() (*url.URL, error) {\n\trawurl := o.AuthenticateInternalURLString\n\tif rawurl == \"\" {\n\t\treturn o.GetAuthenticateURL()\n\t}\n\treturn urlutil.ParseAndValidateURL(o.AuthenticateInternalURLString)\n}\n\n// GetAuthorizeURLs returns the AuthorizeURLs in the options or 127.0.0.1:5443.\nfunc (o *Options) GetAuthorizeURLs() ([]*url.URL, error) {\n\tif IsAll(o.Services) && o.AuthorizeURLString == \"\" && len(o.AuthorizeURLStrings) == 0 {\n\t\tu, err := urlutil.ParseAndValidateURL(\"http://127.0.0.1\" + DefaultAlternativeAddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn []*url.URL{u}, nil\n\t}\n\treturn o.getURLs(append([]string{o.AuthorizeURLString}, o.AuthorizeURLStrings...)...)\n}\n\n// GetInternalAuthorizeURLs returns the internal AuthorizeURLs in the options or the AuthorizeURLs.\nfunc (o *Options) GetInternalAuthorizeURLs() ([]*url.URL, error) {\n\trawurl := o.AuthorizeInternalURLString\n\tif rawurl == \"\" {\n\t\treturn o.GetAuthorizeURLs()\n\t}\n\treturn o.getURLs(rawurl)\n}\n\n// GetDataBrokerURLs returns the DataBrokerURLs in the options or 127.0.0.1:5443.\nfunc (o *Options) GetDataBrokerURLs() ([]*url.URL, error) {\n\tif IsAll(o.Services) && o.DataBrokerURLString == \"\" && len(o.DataBrokerURLStrings) == 0 {\n\t\tu, err := urlutil.ParseAndValidateURL(\"http://127.0.0.1\" + DefaultAlternativeAddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn []*url.URL{u}, nil\n\t}\n\treturn o.getURLs(append([]string{o.DataBrokerURLString}, o.DataBrokerURLStrings...)...)\n}\n\n// GetInternalDataBrokerURLs returns the internal DataBrokerURLs in the options or the DataBrokerURLs.\nfunc (o *Options) GetInternalDataBrokerURLs() ([]*url.URL, error) {\n\trawurl := o.DataBrokerInternalURLString\n\tif rawurl == \"\" {\n\t\treturn o.GetDataBrokerURLs()\n\t}\n\treturn o.getURLs(rawurl)\n}\n\nfunc (o *Options) getURLs(strs ...string) ([]*url.URL, error) {\n\tvar urls []*url.URL\n\tif o != nil {\n\t\tfor _, str := range strs {\n\t\t\tif str == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tu, err := urlutil.ParseAndValidateURL(str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\turls = append(urls, u)\n\t\t}\n\t}\n\tif len(urls) == 0 {\n\t\tu, _ := url.Parse(\"http://127.0.0.1\" + DefaultAlternativeAddr)\n\t\turls = append(urls, u)\n\t}\n\treturn urls, nil\n}\n\n// GetForwardAuthURL returns the ForwardAuthURL.\nfunc (o *Options) GetForwardAuthURL() (*url.URL, error) {\n\trawurl := o.ForwardAuthURLString\n\tif rawurl == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn urlutil.ParseAndValidateURL(rawurl)\n}\n\n// GetGRPCAddr gets the gRPC address.\nfunc (o *Options) GetGRPCAddr() string {\n\t// to avoid port collision when running on localhost\n\tif IsAll(o.Services) && o.GRPCAddr == defaultOptions.GRPCAddr {\n\t\treturn DefaultAlternativeAddr\n\t}\n\treturn o.GRPCAddr\n}\n\n// GetGRPCInsecure gets whether or not gRPC is insecure.\nfunc (o *Options) GetGRPCInsecure() bool {\n\tif IsAll(o.Services) {\n\t\treturn true\n\t}\n\treturn o.GRPCInsecure\n}\n\n// GetSignOutRedirectURL gets the SignOutRedirectURL.\nfunc (o *Options) GetSignOutRedirectURL() (*url.URL, error) {\n\trawurl := o.SignOutRedirectURLString\n\tif rawurl == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn urlutil.ParseAndValidateURL(rawurl)\n}\n\n// GetMetricsCertificate returns the metrics certificate to use for TLS. `nil` will be\n// returned if there is no certificate.\nfunc (o *Options) GetMetricsCertificate() (*tls.Certificate, error) {\n\tif o.MetricsCertificate != \"\" && o.MetricsCertificateKey != \"\" {\n\t\treturn cryptutil.CertificateFromBase64(o.MetricsCertificate, o.MetricsCertificateKey)\n\t}\n\tif o.MetricsCertificateFile != \"\" && o.MetricsCertificateKeyFile != \"\" {\n\t\treturn cryptutil.CertificateFromFile(o.MetricsCertificateFile, o.MetricsCertificateKeyFile)\n\t}\n\treturn nil, nil\n}\n\n// GetOauthOptions gets the oauth.Options for the given config options.\nfunc (o *Options) GetOauthOptions() (oauth.Options, error) {\n\tredirectURL, err := o.GetAuthenticateURL()\n\tif err != nil {\n\t\treturn oauth.Options{}, err\n\t}\n\tredirectURL = redirectURL.ResolveReference(&url.URL{\n\t\tPath: o.AuthenticateCallbackPath,\n\t})\n\treturn oauth.Options{\n\t\tRedirectURL:    redirectURL,\n\t\tProviderName:   o.Provider,\n\t\tProviderURL:    o.ProviderURL,\n\t\tClientID:       o.ClientID,\n\t\tClientSecret:   o.ClientSecret,\n\t\tScopes:         o.Scopes,\n\t\tServiceAccount: o.ServiceAccount,\n\t}, nil\n}\n\n// GetAllPolicies gets all the policies in the options.\nfunc (o *Options) GetAllPolicies() []Policy {\n\tif o == nil {\n\t\treturn nil\n\t}\n\tpolicies := make([]Policy, 0, len(o.Policies)+len(o.Routes)+len(o.AdditionalPolicies))\n\tpolicies = append(policies, o.Policies...)\n\tpolicies = append(policies, o.Routes...)\n\tpolicies = append(policies, o.AdditionalPolicies...)\n\treturn policies\n}\n\n// GetMetricsBasicAuth gets the metrics basic auth username and password.\nfunc (o *Options) GetMetricsBasicAuth() (username, password string, ok bool) {\n\tif o.MetricsBasicAuth == \"\" {\n\t\treturn \"\", \"\", false\n\t}\n\n\tbs, err := base64.StdEncoding.DecodeString(o.MetricsBasicAuth)\n\tif err != nil {\n\t\treturn \"\", \"\", false\n\t}\n\n\tidx := bytes.Index(bs, []byte{':'})\n\tif idx == -1 {\n\t\treturn \"\", \"\", false\n\t}\n\n\treturn string(bs[:idx]), string(bs[idx+1:]), true\n}\n\n// GetClientCA returns the client certificate authority. If neither client_ca nor client_ca_file is specified nil will\n// be returned.\nfunc (o *Options) GetClientCA() ([]byte, error) {\n\tif o.ClientCA != \"\" {\n\t\treturn base64.StdEncoding.DecodeString(o.ClientCA)\n\t}\n\tif o.ClientCAFile != \"\" {\n\t\treturn os.ReadFile(o.ClientCAFile)\n\t}\n\treturn nil, nil\n}\n\n// GetDataBrokerCertificate gets the optional databroker certificate. This method will return nil if no certificate is\n// specified.\nfunc (o *Options) GetDataBrokerCertificate() (*tls.Certificate, error) {\n\tif o.DataBrokerStorageCertFile == \"\" || o.DataBrokerStorageCertKeyFile == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn cryptutil.CertificateFromFile(o.DataBrokerStorageCertFile, o.DataBrokerStorageCertKeyFile)\n}\n\n// GetCertificates gets all the certificates from the options.\nfunc (o *Options) GetCertificates() ([]tls.Certificate, error) {\n\tvar certs []tls.Certificate\n\tif o.Cert != \"\" && o.Key != \"\" {\n\t\tcert, err := cryptutil.CertificateFromBase64(o.Cert, o.Key)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config: invalid base64 certificate: %w\", err)\n\t\t}\n\t\tcerts = append(certs, *cert)\n\t}\n\tfor _, c := range o.CertificateFiles {\n\t\tcert, err := cryptutil.CertificateFromBase64(c.CertFile, c.KeyFile)\n\t\tif err != nil {\n\t\t\tcert, err = cryptutil.CertificateFromFile(c.CertFile, c.KeyFile)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config: invalid certificate entry: %w\", err)\n\t\t}\n\t\tcerts = append(certs, *cert)\n\t}\n\tif o.CertFile != \"\" && o.KeyFile != \"\" {\n\t\tcert, err := cryptutil.CertificateFromFile(o.CertFile, o.KeyFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config: bad cert file %w\", err)\n\t\t}\n\t\tcerts = append(certs, *cert)\n\t}\n\treturn certs, nil\n}\n\n// GetSharedKey gets the decoded shared key.\nfunc (o *Options) GetSharedKey() ([]byte, error) {\n\tsharedKey := o.SharedKey\n\t// mutual auth between services on the same host can be generated at runtime\n\tif IsAll(o.Services) && o.SharedKey == \"\" && o.DataBrokerStorageType == StorageInMemoryName {\n\t\tsharedKey = randomSharedKey\n\t}\n\tif sharedKey == \"\" {\n\t\treturn nil, errors.New(\"empty shared secret\")\n\t}\n\tif strings.TrimSpace(sharedKey) != sharedKey {\n\t\treturn nil, errors.New(\"shared secret contains whitespace\")\n\t}\n\treturn base64.StdEncoding.DecodeString(sharedKey)\n}\n\n// GetGoogleCloudServerlessAuthenticationServiceAccount gets the GoogleCloudServerlessAuthenticationServiceAccount.\nfunc (o *Options) GetGoogleCloudServerlessAuthenticationServiceAccount() string {\n\tif o.GoogleCloudServerlessAuthenticationServiceAccount == \"\" && o.Provider == \"google\" {\n\t\treturn o.ServiceAccount\n\t}\n\treturn o.GoogleCloudServerlessAuthenticationServiceAccount\n}\n\n// GetSetResponseHeaders gets the SetResponseHeaders.\nfunc (o *Options) GetSetResponseHeaders() map[string]string {\n\tif _, ok := o.SetResponseHeaders[DisableHeaderKey]; ok {\n\t\treturn map[string]string{}\n\t}\n\treturn o.SetResponseHeaders\n}\n\n// GetQPS gets the QPS.\nfunc (o *Options) GetQPS() float64 {\n\tif o.QPS < 1 {\n\t\treturn 1\n\t}\n\treturn o.QPS\n}\n\n// GetCodecType gets a codec type.\nfunc (o *Options) GetCodecType() CodecType {\n\tif o.CodecType == CodecTypeUnset {\n\t\tif IsAll(o.Services) {\n\t\t\treturn CodecTypeHTTP1\n\t\t}\n\t\treturn CodecTypeAuto\n\t}\n\treturn o.CodecType\n}\n\n// GetAllRouteableGRPCDomains returns all the possible gRPC domains handled by the Pomerium options.\nfunc (o *Options) GetAllRouteableGRPCDomains() ([]string, error) {\n\tlookup := map[string]struct{}{}\n\n\t// authorize urls\n\tif IsAll(o.Services) {\n\t\tauthorizeURLs, err := o.GetAuthorizeURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range authorizeURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t} else if IsAuthorize(o.Services) {\n\t\tauthorizeURLs, err := o.GetInternalAuthorizeURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range authorizeURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\t// databroker urls\n\tif IsAll(o.Services) {\n\t\tdataBrokerURLs, err := o.GetDataBrokerURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range dataBrokerURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t} else if IsDataBroker(o.Services) {\n\t\tdataBrokerURLs, err := o.GetInternalDataBrokerURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range dataBrokerURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\tdomains := make([]string, 0, len(lookup))\n\tfor domain := range lookup {\n\t\tdomains = append(domains, domain)\n\t}\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\n// GetAllRouteableHTTPDomains returns all the possible HTTP domains handled by the Pomerium options.\nfunc (o *Options) GetAllRouteableHTTPDomains() ([]string, error) {\n\tforwardAuthURL, err := o.GetForwardAuthURL()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlookup := map[string]struct{}{}\n\tif IsAuthenticate(o.Services) {\n\t\tauthenticateURL, err := o.GetInternalAuthenticateURL()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, h := range urlutil.GetDomainsForURL(*authenticateURL) {\n\t\t\tlookup[h] = struct{}{}\n\t\t}\n\t}\n\n\t// policy urls\n\tif IsProxy(o.Services) {\n\t\tfor _, policy := range o.GetAllPolicies() {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*policy.Source.URL) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tif forwardAuthURL != nil {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*forwardAuthURL) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\tdomains := make([]string, 0, len(lookup))\n\tfor domain := range lookup {\n\t\tdomains = append(domains, domain)\n\t}\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\n// Checksum returns the checksum of the current options struct\nfunc (o *Options) Checksum() uint64 {\n\treturn hashutil.MustHash(o)\n}\n\nfunc (o Options) indexCerts(ctx context.Context) certsIndex {\n\tidx := make(certsIndex)\n\n\tif o.CertFile != \"\" {\n\t\tcert, err := cryptutil.ParsePEMCertificateFromFile(o.CertFile)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Str(\"file\", o.CertFile).Msg(\"parsing local cert: skipped\")\n\t\t} else {\n\t\t\tidx.addCert(cert)\n\t\t}\n\t} else if o.Cert != \"\" {\n\t\tif data, err := base64.StdEncoding.DecodeString(o.Cert); err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"bad base64 for local cert: skipped\")\n\t\t} else if cert, err := cryptutil.ParsePEMCertificate(data); err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"parsing local cert: skipped\")\n\t\t} else {\n\t\t\tidx.addCert(cert)\n\t\t}\n\t}\n\n\tfor _, c := range o.CertificateFiles {\n\t\tcert, err := cryptutil.ParsePEMCertificateFromFile(c.CertFile)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Str(\"file\", c.CertFile).Msg(\"parsing local cert: skipped\")\n\t\t} else {\n\t\t\tidx.addCert(cert)\n\t\t}\n\t}\n\treturn idx\n}\n\nfunc (o *Options) applyExternalCerts(ctx context.Context, certs []*config.Settings_Certificate) {\n\tidx := o.indexCerts(ctx)\n\tfor _, c := range certs {\n\t\tcert, err := cryptutil.ParsePEMCertificate(c.CertBytes)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"parsing cert from databroker: skipped\")\n\t\t\tcontinue\n\t\t}\n\t\tif overlaps, name := idx.matchCert(cert); overlaps {\n\t\t\tlog.Error(ctx).Err(err).Str(\"domain\", name).Msg(\"overlaps with local certs: skipped\")\n\t\t\tcontinue\n\t\t}\n\t\tcfp := certificateFilePair{\n\t\t\tCertFile: c.CertFile,\n\t\t\tKeyFile:  c.KeyFile,\n\t\t}\n\t\tif cfp.CertFile == \"\" {\n\t\t\tcfp.CertFile = base64.StdEncoding.EncodeToString(c.CertBytes)\n\t\t}\n\t\tif cfp.KeyFile == \"\" {\n\t\t\tcfp.KeyFile = base64.StdEncoding.EncodeToString(c.KeyBytes)\n\t\t}\n\t\to.CertificateFiles = append(o.CertificateFiles, cfp)\n\t}\n}\n\n// ApplySettings modifies the config options using the given protobuf settings.\nfunc (o *Options) ApplySettings(ctx context.Context, settings *config.Settings) {\n\tif settings == nil {\n\t\treturn\n\t}\n\n\tif settings.InstallationId != nil {\n\t\to.InstallationID = settings.GetInstallationId()\n\t}\n\tif settings.Debug != nil {\n\t\to.Debug = settings.GetDebug()\n\t}\n\tif settings.LogLevel != nil {\n\t\to.LogLevel = settings.GetLogLevel()\n\t}\n\tif settings.ProxyLogLevel != nil {\n\t\to.ProxyLogLevel = settings.GetProxyLogLevel()\n\t}\n\tif settings.SharedSecret != nil {\n\t\to.SharedKey = settings.GetSharedSecret()\n\t}\n\tif settings.Services != nil {\n\t\to.Services = settings.GetServices()\n\t}\n\tif settings.Address != nil {\n\t\to.Addr = settings.GetAddress()\n\t}\n\tif settings.InsecureServer != nil {\n\t\to.InsecureServer = settings.GetInsecureServer()\n\t}\n\tif settings.DnsLookupFamily != nil {\n\t\to.DNSLookupFamily = settings.GetDnsLookupFamily()\n\t}\n\to.applyExternalCerts(ctx, settings.GetCertificates())\n\tif settings.HttpRedirectAddr != nil {\n\t\to.HTTPRedirectAddr = settings.GetHttpRedirectAddr()\n\t}\n\tif settings.TimeoutRead != nil {\n\t\to.ReadTimeout = settings.GetTimeoutRead().AsDuration()\n\t}\n\tif settings.TimeoutWrite != nil {\n\t\to.WriteTimeout = settings.GetTimeoutWrite().AsDuration()\n\t}\n\tif settings.TimeoutIdle != nil {\n\t\to.IdleTimeout = settings.GetTimeoutIdle().AsDuration()\n\t}\n\tif settings.AuthenticateServiceUrl != nil {\n\t\to.AuthenticateURLString = settings.GetAuthenticateServiceUrl()\n\t}\n\tif settings.AuthenticateInternalServiceUrl != nil {\n\t\to.AuthenticateInternalURLString = settings.GetAuthenticateInternalServiceUrl()\n\t}\n\tif settings.AuthenticateCallbackPath != nil {\n\t\to.AuthenticateCallbackPath = settings.GetAuthenticateCallbackPath()\n\t}\n\tif settings.CookieName != nil {\n\t\to.CookieName = settings.GetCookieName()\n\t}\n\tif settings.CookieSecret != nil {\n\t\to.CookieSecret = settings.GetCookieSecret()\n\t}\n\tif settings.CookieDomain != nil {\n\t\to.CookieDomain = settings.GetCookieDomain()\n\t}\n\tif settings.CookieSecure != nil {\n\t\to.CookieSecure = settings.GetCookieSecure()\n\t}\n\tif settings.CookieHttpOnly != nil {\n\t\to.CookieHTTPOnly = settings.GetCookieHttpOnly()\n\t}\n\tif settings.CookieExpire != nil {\n\t\to.CookieExpire = settings.GetCookieExpire().AsDuration()\n\t}\n\tif settings.IdpClientId != nil {\n\t\to.ClientID = settings.GetIdpClientId()\n\t}\n\tif settings.IdpClientSecret != nil {\n\t\to.ClientSecret = settings.GetIdpClientSecret()\n\t}\n\tif settings.IdpProvider != nil {\n\t\to.Provider = settings.GetIdpProvider()\n\t}\n\tif settings.IdpProviderUrl != nil {\n\t\to.ProviderURL = settings.GetIdpProviderUrl()\n\t}\n\tif len(settings.Scopes) > 0 {\n\t\to.Scopes = settings.Scopes\n\t}\n\tif settings.IdpServiceAccount != nil {\n\t\to.ServiceAccount = settings.GetIdpServiceAccount()\n\t}\n\tif settings.IdpRefreshDirectoryTimeout != nil {\n\t\to.RefreshDirectoryTimeout = settings.GetIdpRefreshDirectoryTimeout().AsDuration()\n\t}\n\tif settings.IdpRefreshDirectoryInterval != nil {\n\t\to.RefreshDirectoryInterval = settings.GetIdpRefreshDirectoryInterval().AsDuration()\n\t}\n\tif settings.RequestParams != nil && len(settings.RequestParams) > 0 {\n\t\to.RequestParams = settings.RequestParams\n\t}\n\tif len(settings.AuthorizeServiceUrls) > 0 {\n\t\to.AuthorizeURLStrings = settings.GetAuthorizeServiceUrls()\n\t}\n\tif settings.AuthorizeInternalServiceUrl != nil {\n\t\to.AuthorizeInternalURLString = settings.GetAuthorizeInternalServiceUrl()\n\t}\n\tif settings.OverrideCertificateName != nil {\n\t\to.OverrideCertificateName = settings.GetOverrideCertificateName()\n\t}\n\tif settings.CertificateAuthority != nil {\n\t\to.CA = settings.GetCertificateAuthority()\n\t}\n\tif settings.CertificateAuthorityFile != nil {\n\t\to.CAFile = settings.GetCertificateAuthorityFile()\n\t}\n\tif settings.SigningKey != nil {\n\t\to.SigningKey = settings.GetSigningKey()\n\t}\n\tif settings.SetResponseHeaders != nil && len(settings.SetResponseHeaders) > 0 {\n\t\to.SetResponseHeaders = settings.SetResponseHeaders\n\t}\n\tif len(settings.JwtClaimsHeaders) > 0 {\n\t\to.JWTClaimsHeaders = settings.GetJwtClaimsHeaders()\n\t}\n\tif settings.DefaultUpstreamTimeout != nil {\n\t\to.DefaultUpstreamTimeout = settings.GetDefaultUpstreamTimeout().AsDuration()\n\t}\n\tif settings.MetricsAddress != nil {\n\t\to.MetricsAddr = settings.GetMetricsAddress()\n\t}\n\tif settings.MetricsBasicAuth != nil {\n\t\to.MetricsBasicAuth = settings.GetMetricsBasicAuth()\n\t}\n\tif len(settings.GetMetricsCertificate().GetCertBytes()) > 0 {\n\t\to.MetricsCertificate = base64.StdEncoding.EncodeToString(settings.GetMetricsCertificate().GetCertBytes())\n\t}\n\tif len(settings.GetMetricsCertificate().GetKeyBytes()) > 0 {\n\t\to.MetricsCertificateKey = base64.StdEncoding.EncodeToString(settings.GetMetricsCertificate().GetKeyBytes())\n\t}\n\tif settings.GetMetricsCertificate().GetCertFile() != \"\" {\n\t\to.MetricsCertificateFile = settings.GetMetricsCertificate().GetCertFile()\n\t}\n\tif settings.GetMetricsCertificate().GetKeyFile() != \"\" {\n\t\to.MetricsCertificateKeyFile = settings.GetMetricsCertificate().GetKeyFile()\n\t}\n\tif settings.GetMetricsClientCa() != \"\" {\n\t\to.MetricsClientCA = settings.GetMetricsClientCa()\n\t}\n\tif settings.GetMetricsClientCaFile() != \"\" {\n\t\to.MetricsClientCAFile = settings.GetMetricsClientCaFile()\n\t}\n\tif settings.TracingProvider != nil {\n\t\to.TracingProvider = settings.GetTracingProvider()\n\t}\n\tif settings.TracingSampleRate != nil {\n\t\to.TracingSampleRate = settings.GetTracingSampleRate()\n\t}\n\tif settings.TracingJaegerCollectorEndpoint != nil {\n\t\to.TracingJaegerCollectorEndpoint = settings.GetTracingJaegerCollectorEndpoint()\n\t}\n\tif settings.TracingJaegerAgentEndpoint != nil {\n\t\to.TracingJaegerAgentEndpoint = settings.GetTracingJaegerAgentEndpoint()\n\t}\n\tif settings.TracingZipkinEndpoint != nil {\n\t\to.ZipkinEndpoint = settings.GetTracingZipkinEndpoint()\n\t}\n\tif settings.GrpcAddress != nil {\n\t\to.GRPCAddr = settings.GetGrpcAddress()\n\t}\n\tif settings.GrpcInsecure != nil {\n\t\to.GRPCInsecure = settings.GetGrpcInsecure()\n\t}\n\tif settings.ForwardAuthUrl != nil {\n\t\to.ForwardAuthURLString = settings.GetForwardAuthUrl()\n\t}\n\tif len(settings.DatabrokerServiceUrls) > 0 {\n\t\to.DataBrokerURLStrings = settings.GetDatabrokerServiceUrls()\n\t}\n\tif settings.DatabrokerInternalServiceUrl != nil {\n\t\to.DataBrokerInternalURLString = settings.GetDatabrokerInternalServiceUrl()\n\t}\n\tif settings.ClientCa != nil {\n\t\to.ClientCA = settings.GetClientCa()\n\t}\n\tif settings.ClientCaFile != nil {\n\t\to.ClientCAFile = settings.GetClientCaFile()\n\t}\n\tif settings.GoogleCloudServerlessAuthenticationServiceAccount != nil {\n\t\to.GoogleCloudServerlessAuthenticationServiceAccount = settings.GetGoogleCloudServerlessAuthenticationServiceAccount()\n\t}\n\tif settings.Autocert != nil {\n\t\to.AutocertOptions.Enable = settings.GetAutocert()\n\t}\n\tif settings.AutocertCa != nil {\n\t\to.AutocertOptions.CA = settings.GetAutocertCa()\n\t}\n\tif settings.AutocertEmail != nil {\n\t\to.AutocertOptions.Email = settings.GetAutocertEmail()\n\t}\n\tif settings.AutocertEabKeyId != nil {\n\t\to.AutocertOptions.EABKeyID = settings.GetAutocertEabKeyId()\n\t}\n\tif settings.AutocertEabMacKey != nil {\n\t\to.AutocertOptions.EABMACKey = settings.GetAutocertEabMacKey()\n\t}\n\tif settings.AutocertUseStaging != nil {\n\t\to.AutocertOptions.UseStaging = settings.GetAutocertUseStaging()\n\t}\n\tif settings.AutocertMustStaple != nil {\n\t\to.AutocertOptions.MustStaple = settings.GetAutocertMustStaple()\n\t}\n\tif settings.AutocertDir != nil {\n\t\to.AutocertOptions.Folder = settings.GetAutocertDir()\n\t}\n\tif settings.AutocertTrustedCa != nil {\n\t\to.AutocertOptions.TrustedCA = settings.GetAutocertTrustedCa()\n\t}\n\tif settings.AutocertTrustedCaFile != nil {\n\t\to.AutocertOptions.TrustedCAFile = settings.GetAutocertTrustedCaFile()\n\t}\n\tif settings.SkipXffAppend != nil {\n\t\to.SkipXffAppend = settings.GetSkipXffAppend()\n\t}\n\tif settings.XffNumTrustedHops != nil {\n\t\to.XffNumTrustedHops = settings.GetXffNumTrustedHops()\n\t}\n\tif len(settings.ProgrammaticRedirectDomainWhitelist) > 0 {\n\t\to.ProgrammaticRedirectDomainWhitelist = settings.GetProgrammaticRedirectDomainWhitelist()\n\t}\n\tif settings.AuditKey != nil {\n\t\to.AuditKey = &PublicKeyEncryptionKeyOptions{\n\t\t\tID:   settings.AuditKey.GetId(),\n\t\t\tData: base64.StdEncoding.EncodeToString(settings.AuditKey.GetData()),\n\t\t}\n\t}\n\tif settings.CodecType != nil {\n\t\to.CodecType = CodecTypeFromEnvoy(settings.GetCodecType())\n\t}\n\tif settings.ClientCrl != nil {\n\t\to.ClientCRL = settings.GetClientCrl()\n\t}\n\tif settings.ClientCrlFile != nil {\n\t\to.ClientCRLFile = settings.GetClientCrlFile()\n\t}\n}\n\nfunc dataDir() string {\n\thomeDir, _ := os.UserHomeDir()\n\tif homeDir == \"\" {\n\t\thomeDir = \".\"\n\t}\n\tbaseDir := filepath.Join(homeDir, \".local\", \"share\")\n\tif xdgData := os.Getenv(\"XDG_DATA_HOME\"); xdgData != \"\" {\n\t\tbaseDir = xdgData\n\t}\n\treturn filepath.Join(baseDir, \"pomerium\")\n}\n\nfunc compareByteSliceSlice(a, b [][]byte) int {\n\tsz := min(len(a), len(b))\n\tfor i := 0; i < sz; i++ {\n\t\tswitch bytes.Compare(a[i], b[i]) {\n\t\tcase -1:\n\t\t\treturn -1\n\t\tcase 1:\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tswitch {\n\tcase len(a) < len(b):\n\t\treturn -1\n\tcase len(b) < len(a):\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n// AtomicOptions are Options that can be access atomically.\ntype AtomicOptions struct {\n\tvalue atomic.Value\n}\n\n// NewAtomicOptions creates a new AtomicOptions.\nfunc NewAtomicOptions() *AtomicOptions {\n\tao := new(AtomicOptions)\n\tao.Store(new(Options))\n\treturn ao\n}\n\n// Load loads the options.\nfunc (a *AtomicOptions) Load() *Options {\n\treturn a.value.Load().(*Options)\n}\n\n// Store stores the options.\nfunc (a *AtomicOptions) Store(options *Options) {\n\ta.value.Store(options)\n}\n", "// Package pomerium houses the main pomerium CLI command.\n//\npackage pomerium\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\tenvoy_service_auth_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v3\"\n\t\"github.com/rs/zerolog\"\n\t\"golang.org/x/sync/errgroup\"\n\n\t\"github.com/pomerium/pomerium/authenticate\"\n\t\"github.com/pomerium/pomerium/authorize\"\n\t\"github.com/pomerium/pomerium/config\"\n\tdatabroker_service \"github.com/pomerium/pomerium/databroker\"\n\t\"github.com/pomerium/pomerium/internal/autocert\"\n\t\"github.com/pomerium/pomerium/internal/controlplane\"\n\t\"github.com/pomerium/pomerium/internal/databroker\"\n\t\"github.com/pomerium/pomerium/internal/envoy\"\n\t\"github.com/pomerium/pomerium/internal/envoy/files\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/registry\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n\t\"github.com/pomerium/pomerium/internal/version\"\n\t\"github.com/pomerium/pomerium/proxy\"\n)\n\n// Run runs the main pomerium application.\nfunc Run(ctx context.Context, configFile string) error {\n\tlog.Info(ctx).\n\t\tStr(\"envoy_version\", files.FullVersion()).\n\t\tStr(\"version\", version.FullVersion()).\n\t\tMsg(\"cmd/pomerium\")\n\n\tvar src config.Source\n\n\tsrc, err := config.NewFileOrEnvironmentSource(configFile, files.FullVersion())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsrc = databroker.NewConfigSource(ctx, src)\n\tlogMgr := config.NewLogManager(ctx, src)\n\tdefer logMgr.Close()\n\n\t// trigger changes when underlying files are changed\n\tsrc = config.NewFileWatcherSource(src)\n\n\tsrc, err = autocert.New(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// override the default http transport so we can use the custom CA in the TLS client config (#1570)\n\thttp.DefaultTransport = config.NewHTTPTransport(src)\n\n\tmetricsMgr := config.NewMetricsManager(ctx, src)\n\tdefer metricsMgr.Close()\n\ttraceMgr := config.NewTraceManager(ctx, src)\n\tdefer traceMgr.Close()\n\n\t// setup the control plane\n\tcontrolPlane, err := controlplane.NewServer(src.GetConfig(), metricsMgr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating control plane: %w\", err)\n\t}\n\tsrc.OnConfigChange(ctx,\n\t\tfunc(ctx context.Context, cfg *config.Config) {\n\t\t\tif err := controlPlane.OnConfigChange(ctx, cfg); err != nil {\n\t\t\t\tlog.Error(ctx).Err(err).Msg(\"config change\")\n\t\t\t}\n\t\t})\n\n\tif err = controlPlane.OnConfigChange(log.WithContext(ctx, func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"config_file_source\", configFile).Bool(\"bootstrap\", true)\n\t}), src.GetConfig()); err != nil {\n\t\treturn fmt.Errorf(\"applying config: %w\", err)\n\t}\n\n\tlog.Info(ctx).\n\t\tStr(\"grpc-port\", src.GetConfig().GRPCPort).\n\t\tStr(\"http-port\", src.GetConfig().HTTPPort).\n\t\tStr(\"outbound-port\", src.GetConfig().OutboundPort).\n\t\tMsg(\"server started\")\n\n\t// create envoy server\n\tenvoyServer, err := envoy.NewServer(ctx, src, controlPlane.Builder)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating envoy server: %w\", err)\n\t}\n\tdefer envoyServer.Close()\n\n\t// add services\n\tif err := setupAuthenticate(ctx, src, controlPlane); err != nil {\n\t\treturn err\n\t}\n\tvar authorizeServer *authorize.Authorize\n\tif config.IsAuthorize(src.GetConfig().Options.Services) {\n\t\tauthorizeServer, err = setupAuthorize(ctx, src, controlPlane)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tvar dataBrokerServer *databroker_service.DataBroker\n\tif config.IsDataBroker(src.GetConfig().Options.Services) {\n\t\tdataBrokerServer, err = setupDataBroker(ctx, src, controlPlane)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up databroker: %w\", err)\n\t\t}\n\t}\n\n\tif err = setupRegistryReporter(ctx, src); err != nil {\n\t\treturn fmt.Errorf(\"setting up registry reporter: %w\", err)\n\t}\n\tif err := setupProxy(ctx, src, controlPlane); err != nil {\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\tgo func(ctx context.Context) {\n\t\tch := make(chan os.Signal, 2)\n\t\tdefer signal.Stop(ch)\n\n\t\tsignal.Notify(ch, os.Interrupt)\n\t\tsignal.Notify(ch, syscall.SIGTERM)\n\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-ctx.Done():\n\t\t}\n\t\tcancel()\n\t}(ctx)\n\n\t// run everything\n\teg, ctx := errgroup.WithContext(ctx)\n\tif authorizeServer != nil {\n\t\teg.Go(func() error {\n\t\t\treturn authorizeServer.Run(ctx)\n\t\t})\n\t}\n\teg.Go(func() error {\n\t\treturn controlPlane.Run(ctx)\n\t})\n\tif dataBrokerServer != nil {\n\t\teg.Go(func() error {\n\t\t\treturn dataBrokerServer.Run(ctx)\n\t\t})\n\t}\n\treturn eg.Wait()\n}\n\nfunc setupAuthenticate(ctx context.Context, src config.Source, controlPlane *controlplane.Server) error {\n\tif !config.IsAuthenticate(src.GetConfig().Options.Services) {\n\t\treturn nil\n\t}\n\n\tsvc, err := authenticate.New(src.GetConfig())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating authenticate service: %w\", err)\n\t}\n\n\tauthenticateURL, err := src.GetConfig().Options.GetInternalAuthenticateURL()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error getting authenticate URL: %w\", err)\n\t}\n\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\thost := urlutil.StripPort(authenticateURL.Host)\n\tsr := controlPlane.HTTPRouter.Host(host).Subrouter()\n\tsvc.Mount(sr)\n\tlog.Info(context.TODO()).Str(\"host\", host).Msg(\"enabled authenticate service\")\n\n\treturn nil\n}\n\nfunc setupAuthorize(ctx context.Context, src config.Source, controlPlane *controlplane.Server) (*authorize.Authorize, error) {\n\tsvc, err := authorize.New(src.GetConfig())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating authorize service: %w\", err)\n\t}\n\tenvoy_service_auth_v3.RegisterAuthorizationServer(controlPlane.GRPCServer, svc)\n\n\tlog.Info(context.TODO()).Msg(\"enabled authorize service\")\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\treturn svc, nil\n}\n\nfunc setupDataBroker(ctx context.Context, src config.Source, controlPlane *controlplane.Server) (*databroker_service.DataBroker, error) {\n\tsvc, err := databroker_service.New(src.GetConfig())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating databroker service: %w\", err)\n\t}\n\tsvc.Register(controlPlane.GRPCServer)\n\tlog.Info(context.TODO()).Msg(\"enabled databroker service\")\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\treturn svc, nil\n}\n\nfunc setupRegistryReporter(ctx context.Context, src config.Source) error {\n\treporter := registry.NewReporter()\n\tsrc.OnConfigChange(ctx, reporter.OnConfigChange)\n\treporter.OnConfigChange(ctx, src.GetConfig())\n\treturn nil\n}\n\nfunc setupProxy(ctx context.Context, src config.Source, controlPlane *controlplane.Server) error {\n\tif !config.IsProxy(src.GetConfig().Options.Services) {\n\t\treturn nil\n\t}\n\n\tsvc, err := proxy.New(src.GetConfig())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating proxy service: %w\", err)\n\t}\n\tcontrolPlane.HTTPRouter.PathPrefix(\"/\").Handler(svc)\n\n\tlog.Info(context.TODO()).Msg(\"enabled proxy service\")\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\n\treturn nil\n}\n", "// Package controlplane contains the HTTP and gRPC base servers and the xDS gRPC implementation for envoy.\npackage controlplane\n\nimport (\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"time\"\n\n\t\"github.com/CAFxX/httpcompression\"\n\t\"github.com/gorilla/handlers\"\n\n\t\"github.com/pomerium/pomerium/internal/httputil\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/requestid\"\n)\n\nfunc (srv *Server) addHTTPMiddleware() {\n\tcompressor, err := httpcompression.DefaultAdapter()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\troot := srv.HTTPRouter\n\troot.Use(compressor)\n\troot.Use(srv.reproxy.Middleware)\n\troot.Use(requestid.HTTPMiddleware())\n\troot.Use(log.NewHandler(log.Logger))\n\troot.Use(log.AccessHandler(func(r *http.Request, status, size int, duration time.Duration) {\n\t\tlog.FromRequest(r).Debug().\n\t\t\tDur(\"duration\", duration).\n\t\t\tInt(\"size\", size).\n\t\t\tInt(\"status\", status).\n\t\t\tStr(\"method\", r.Method).\n\t\t\tStr(\"host\", r.Host).\n\t\t\tStr(\"path\", r.URL.String()).\n\t\t\tMsg(\"http-request\")\n\t}))\n\troot.Use(handlers.RecoveryHandler())\n\troot.Use(log.HeadersHandler(httputil.HeadersXForwarded))\n\troot.Use(log.RemoteAddrHandler(\"ip\"))\n\troot.Use(log.UserAgentHandler(\"user_agent\"))\n\troot.Use(log.RefererHandler(\"referer\"))\n\troot.Use(log.RequestIDHandler(\"request-id\"))\n\troot.Use(telemetry.HTTPStatsHandler(func() string {\n\t\treturn srv.currentConfig.Load().Options.InstallationID\n\t}, srv.name))\n\troot.HandleFunc(\"/healthz\", httputil.HealthCheck)\n\troot.HandleFunc(\"/ping\", httputil.HealthCheck)\n\n\t// pprof\n\troot.Path(\"/debug/pprof/cmdline\").HandlerFunc(pprof.Cmdline)\n\troot.Path(\"/debug/pprof/profile\").HandlerFunc(pprof.Profile)\n\troot.Path(\"/debug/pprof/symbol\").HandlerFunc(pprof.Symbol)\n\troot.Path(\"/debug/pprof/trace\").HandlerFunc(pprof.Trace)\n\troot.PathPrefix(\"/debug/pprof/\").HandlerFunc(pprof.Index)\n\n\t// metrics\n\troot.Handle(\"/metrics\", srv.metricsMgr)\n}\n", "package controlplane\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\tenvoy_service_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/rs/zerolog\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/controlplane/xdsmgr\"\n\t\"github.com/pomerium/pomerium/internal/envoy/files\"\n\t\"github.com/pomerium/pomerium/internal/events\"\n\t\"github.com/pomerium/pomerium/internal/httputil/reproxy\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/requestid\"\n\t\"github.com/pomerium/pomerium/internal/version\"\n\tpom_grpc \"github.com/pomerium/pomerium/pkg/grpc\"\n\t\"github.com/pomerium/pomerium/pkg/grpcutil\"\n)\n\ntype versionedConfig struct {\n\t*config.Config\n\tversion int64\n}\n\ntype atomicVersionedConfig struct {\n\tvalue atomic.Value\n}\n\nfunc (avo *atomicVersionedConfig) Load() versionedConfig {\n\treturn avo.value.Load().(versionedConfig)\n}\n\nfunc (avo *atomicVersionedConfig) Store(cfg versionedConfig) {\n\tavo.value.Store(cfg)\n}\n\n// A Server is the control-plane gRPC and HTTP servers.\ntype Server struct {\n\tGRPCListener net.Listener\n\tGRPCServer   *grpc.Server\n\tHTTPListener net.Listener\n\tHTTPRouter   *mux.Router\n\tBuilder      *envoyconfig.Builder\n\n\tcurrentConfig atomicVersionedConfig\n\tname          string\n\txdsmgr        *xdsmgr.Manager\n\tfilemgr       *filemgr.Manager\n\tmetricsMgr    *config.MetricsManager\n\treproxy       *reproxy.Handler\n\n\thaveSetCapacity map[string]bool\n}\n\n// NewServer creates a new Server. Listener ports are chosen by the OS.\nfunc NewServer(cfg *config.Config, metricsMgr *config.MetricsManager) (*Server, error) {\n\tsrv := &Server{\n\t\tmetricsMgr:      metricsMgr,\n\t\treproxy:         reproxy.New(),\n\t\thaveSetCapacity: map[string]bool{},\n\t}\n\tsrv.currentConfig.Store(versionedConfig{\n\t\tConfig: cfg,\n\t})\n\n\tvar err error\n\n\t// setup gRPC\n\tsrv.GRPCListener, err = net.Listen(\"tcp4\", net.JoinHostPort(\"127.0.0.1\", cfg.GRPCPort))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tui, si := grpcutil.AttachMetadataInterceptors(\n\t\tmetadata.Pairs(\n\t\t\tgrpcutil.MetadataKeyEnvoyVersion, files.FullVersion(),\n\t\t\tgrpcutil.MetadataKeyPomeriumVersion, version.FullVersion(),\n\t\t),\n\t)\n\tsrv.GRPCServer = grpc.NewServer(\n\t\tgrpc.StatsHandler(telemetry.NewGRPCServerStatsHandler(cfg.Options.Services)),\n\t\tgrpc.ChainUnaryInterceptor(requestid.UnaryServerInterceptor(), ui),\n\t\tgrpc.ChainStreamInterceptor(requestid.StreamServerInterceptor(), si),\n\t)\n\treflection.Register(srv.GRPCServer)\n\tsrv.registerAccessLogHandlers()\n\n\tgrpc_health_v1.RegisterHealthServer(srv.GRPCServer, pom_grpc.NewHealthCheckServer())\n\n\t// setup HTTP\n\tsrv.HTTPListener, err = net.Listen(\"tcp4\", net.JoinHostPort(\"127.0.0.1\", cfg.HTTPPort))\n\tif err != nil {\n\t\t_ = srv.GRPCListener.Close()\n\t\treturn nil, err\n\t}\n\tsrv.HTTPRouter = mux.NewRouter()\n\tsrv.addHTTPMiddleware()\n\n\tsrv.filemgr = filemgr.NewManager()\n\tsrv.filemgr.ClearCache()\n\n\tsrv.Builder = envoyconfig.New(\n\t\tsrv.GRPCListener.Addr().String(),\n\t\tsrv.HTTPListener.Addr().String(),\n\t\tsrv.filemgr,\n\t\tsrv.reproxy,\n\t)\n\n\tctx := log.WithContext(context.Background(), func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"server_name\", cfg.Options.Services)\n\t})\n\n\tres, err := srv.buildDiscoveryResources(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsrv.xdsmgr = xdsmgr.NewManager(res)\n\tenvoy_service_discovery_v3.RegisterAggregatedDiscoveryServiceServer(srv.GRPCServer, srv.xdsmgr)\n\n\treturn srv, nil\n}\n\n// Run runs the control-plane gRPC and HTTP servers.\nfunc (srv *Server) Run(ctx context.Context) error {\n\teg, ctx := errgroup.WithContext(ctx)\n\n\thandle := events.Register(func(evt events.Event) {\n\t\twithGRPCBackoff(ctx, func() error {\n\t\t\treturn srv.storeEvent(ctx, evt)\n\t\t})\n\t})\n\tdefer events.Unregister(handle)\n\n\t// start the gRPC server\n\teg.Go(func() error {\n\t\tlog.Info(ctx).Str(\"addr\", srv.GRPCListener.Addr().String()).Msg(\"starting control-plane gRPC server\")\n\t\treturn srv.GRPCServer.Serve(srv.GRPCListener)\n\t})\n\n\t// gracefully stop the gRPC server on context cancellation\n\teg.Go(func() error {\n\t\t<-ctx.Done()\n\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tctx, cleanup := context.WithTimeout(ctx, time.Second*5)\n\t\tdefer cleanup()\n\n\t\tgo func() {\n\t\t\tsrv.GRPCServer.GracefulStop()\n\t\t\tcancel()\n\t\t}()\n\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tsrv.GRPCServer.Stop()\n\t\t\tcancel()\n\t\t}()\n\n\t\t<-ctx.Done()\n\n\t\treturn nil\n\t})\n\n\thsrv := (&http.Server{\n\t\tBaseContext: func(li net.Listener) context.Context {\n\t\t\treturn ctx\n\t\t},\n\t\tHandler: srv.HTTPRouter,\n\t})\n\n\t// start the HTTP server\n\teg.Go(func() error {\n\t\tlog.Info(ctx).Str(\"addr\", srv.HTTPListener.Addr().String()).Msg(\"starting control-plane HTTP server\")\n\t\treturn hsrv.Serve(srv.HTTPListener)\n\t})\n\n\t// gracefully stop the HTTP server on context cancellation\n\teg.Go(func() error {\n\t\t<-ctx.Done()\n\n\t\tctx, cleanup := context.WithTimeout(ctx, time.Second*5)\n\t\tdefer cleanup()\n\n\t\treturn hsrv.Shutdown(ctx)\n\t})\n\n\treturn eg.Wait()\n}\n\n// OnConfigChange updates the pomerium config options.\nfunc (srv *Server) OnConfigChange(ctx context.Context, cfg *config.Config) error {\n\tsrv.reproxy.Update(ctx, cfg)\n\tprev := srv.currentConfig.Load()\n\tsrv.currentConfig.Store(versionedConfig{\n\t\tConfig:  cfg,\n\t\tversion: prev.version + 1,\n\t})\n\tres, err := srv.buildDiscoveryResources(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.xdsmgr.Update(ctx, res)\n\treturn nil\n}\n", "package registry\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/pkg/grpc\"\n\tpb \"github.com/pomerium/pomerium/pkg/grpc/registry\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n)\n\n// Reporter periodically submits a list of services available on this instance to the service registry\ntype Reporter struct {\n\tcancel                 func()\n\toutboundGRPCConnection *grpc.CachedOutboundGRPClientConn\n}\n\n// NewReporter creates a new Reporter.\nfunc NewReporter() *Reporter {\n\treturn &Reporter{\n\t\toutboundGRPCConnection: new(grpc.CachedOutboundGRPClientConn),\n\t}\n}\n\n// OnConfigChange applies configuration changes to the reporter\nfunc (r *Reporter) OnConfigChange(ctx context.Context, cfg *config.Config) {\n\tif r.cancel != nil {\n\t\tr.cancel()\n\t}\n\n\tservices, err := getReportedServices(cfg)\n\tif err != nil {\n\t\tlog.Warn(ctx).Err(err).Msg(\"metrics announce to service registry is disabled\")\n\t}\n\n\tsharedKey, err := cfg.Options.GetSharedKey()\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"decoding shared key\")\n\t\treturn\n\t}\n\n\tregistryConn, err := r.outboundGRPCConnection.Get(ctx, &grpc.OutboundOptions{\n\t\tOutboundPort:   cfg.OutboundPort,\n\t\tInstallationID: cfg.Options.InstallationID,\n\t\tServiceName:    cfg.Options.Services,\n\t\tSignedJWTKey:   sharedKey,\n\t})\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"connecting to registry\")\n\t\treturn\n\t}\n\n\tif len(services) > 0 {\n\t\tctx, cancel := context.WithCancel(context.TODO())\n\t\tgo runReporter(ctx, pb.NewRegistryClient(registryConn), services)\n\t\tr.cancel = cancel\n\t}\n}\n\nfunc getReportedServices(cfg *config.Config) ([]*pb.Service, error) {\n\tmu, err := metricsURL(*cfg.Options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn []*pb.Service{\n\t\t{Kind: pb.ServiceKind_PROMETHEUS_METRICS, Endpoint: mu.String()},\n\t}, nil\n}\n\nfunc metricsURL(o config.Options) (*url.URL, error) {\n\thost, port, err := net.SplitHostPort(o.MetricsAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid metrics address %q: %w\", o.MetricsAddr, err)\n\t}\n\tif port == \"\" {\n\t\treturn nil, fmt.Errorf(\"invalid metrics value %q: port is required\", o.MetricsAddr)\n\t}\n\tif host == \"\" {\n\t\tif host, err = getHostOrIP(); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not guess hostname: %w\", err)\n\t\t}\n\t}\n\n\tu := url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   net.JoinHostPort(host, port),\n\t\tPath:   defaultMetricsPath,\n\t}\n\n\tif o.MetricsBasicAuth != \"\" {\n\t\ttxt, err := base64.StdEncoding.DecodeString(o.MetricsBasicAuth)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"metrics basic auth: %w\", err)\n\t\t}\n\t\tparts := strings.SplitN(string(txt), \":\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"expected username:password for basic auth\")\n\t\t}\n\t\tu.User = url.UserPassword(parts[0], parts[1])\n\t}\n\n\tif o.MetricsCertificate != \"\" || o.MetricsCertificateFile != \"\" {\n\t\tu.Scheme = \"https\"\n\t}\n\n\tif o.MetricsAddr == \"\" {\n\t\treturn nil, fmt.Errorf(\"no metrics address provided\")\n\t}\n\n\treturn &u, nil\n}\n\nfunc runReporter(\n\tctx context.Context,\n\tclient pb.RegistryClient,\n\tservices []*pb.Service,\n) {\n\tbackoff := backoff.NewExponentialBackOff()\n\tbackoff.MaxElapsedTime = 0\n\n\treq := &pb.RegisterRequest{Services: services}\n\tafter := minTTL\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(after):\n\t\t\tresp, err := client.Report(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlog.Ctx(ctx).Error().Err(err).Msg(\"grpc.service_registry.Report\")\n\t\t\t\tafter = backoff.NextBackOff()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tafter = resp.CallBackAfter.AsDuration()\n\t\t\tbackoff.Reset()\n\t\tcase <-ctx.Done():\n\t\t\tlog.Info(ctx).Msg(\"service registry reporter stopping\")\n\t\t\treturn\n\t\t}\n\t}\n}\n"], "fixing_code": ["package config\n\nimport (\n\t\"crypto/tls\"\n\n\t\"github.com/pomerium/pomerium/internal/hashutil\"\n)\n\n// Config holds pomerium configuration options.\ntype Config struct {\n\tOptions          *Options\n\tAutoCertificates []tls.Certificate\n\tEnvoyVersion     string\n\n\t// GRPCPort is the port the gRPC server is running on.\n\tGRPCPort string\n\t// HTTPPort is the port the HTTP server is running on.\n\tHTTPPort string\n\t// OutboundPort is the port the outbound gRPC listener is running on.\n\tOutboundPort string\n\t// MetricsPort is the port the metrics listener is running on.\n\tMetricsPort string\n\t// DebugPort is the port the debug listener is running on.\n\tDebugPort string\n}\n\n// Clone creates a clone of the config.\nfunc (cfg *Config) Clone() *Config {\n\tnewOptions := new(Options)\n\t*newOptions = *cfg.Options\n\treturn &Config{\n\t\tOptions:          newOptions,\n\t\tAutoCertificates: cfg.AutoCertificates,\n\t\tEnvoyVersion:     cfg.EnvoyVersion,\n\n\t\tGRPCPort:     cfg.GRPCPort,\n\t\tHTTPPort:     cfg.HTTPPort,\n\t\tOutboundPort: cfg.OutboundPort,\n\t\tMetricsPort:  cfg.MetricsPort,\n\t\tDebugPort:    cfg.DebugPort,\n\t}\n}\n\n// AllCertificates returns all the certificates in the config.\nfunc (cfg *Config) AllCertificates() ([]tls.Certificate, error) {\n\toptionCertificates, err := cfg.Options.GetCertificates()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar certs []tls.Certificate\n\tcerts = append(certs, optionCertificates...)\n\tcerts = append(certs, cfg.AutoCertificates...)\n\treturn certs, nil\n}\n\n// Checksum returns the config checksum.\nfunc (cfg *Config) Checksum() uint64 {\n\treturn hashutil.MustHash(cfg)\n}\n", "package config\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/google/uuid\"\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/pomerium/pomerium/internal/fileutil\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/netutil\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/metrics\"\n)\n\n// A ChangeListener is called when configuration changes.\ntype ChangeListener = func(context.Context, *Config)\n\n// A ChangeDispatcher manages listeners on config changes.\ntype ChangeDispatcher struct {\n\tsync.Mutex\n\tonConfigChangeListeners []ChangeListener\n}\n\n// Trigger triggers a change.\nfunc (dispatcher *ChangeDispatcher) Trigger(ctx context.Context, cfg *Config) {\n\tdispatcher.Lock()\n\tdefer dispatcher.Unlock()\n\n\tfor _, li := range dispatcher.onConfigChangeListeners {\n\t\tli(ctx, cfg)\n\t}\n}\n\n// OnConfigChange adds a listener.\nfunc (dispatcher *ChangeDispatcher) OnConfigChange(ctx context.Context, li ChangeListener) {\n\tdispatcher.Lock()\n\tdefer dispatcher.Unlock()\n\tdispatcher.onConfigChangeListeners = append(dispatcher.onConfigChangeListeners, li)\n}\n\n// A Source gets configuration.\ntype Source interface {\n\tGetConfig() *Config\n\tOnConfigChange(context.Context, ChangeListener)\n}\n\n// A StaticSource always returns the same config. Useful for testing.\ntype StaticSource struct {\n\tmu  sync.Mutex\n\tcfg *Config\n\tlis []ChangeListener\n}\n\n// NewStaticSource creates a new StaticSource.\nfunc NewStaticSource(cfg *Config) *StaticSource {\n\treturn &StaticSource{cfg: cfg}\n}\n\n// GetConfig gets the config.\nfunc (src *StaticSource) GetConfig() *Config {\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\treturn src.cfg\n}\n\n// SetConfig sets the config.\nfunc (src *StaticSource) SetConfig(ctx context.Context, cfg *Config) {\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\tsrc.cfg = cfg\n\tfor _, li := range src.lis {\n\t\tli(ctx, cfg)\n\t}\n}\n\n// OnConfigChange is ignored for the StaticSource.\nfunc (src *StaticSource) OnConfigChange(ctx context.Context, li ChangeListener) {\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\tsrc.lis = append(src.lis, li)\n}\n\n// A FileOrEnvironmentSource retrieves config options from a file or the environment.\ntype FileOrEnvironmentSource struct {\n\tconfigFile string\n\n\tmu     sync.RWMutex\n\tconfig *Config\n\n\tChangeDispatcher\n}\n\n// NewFileOrEnvironmentSource creates a new FileOrEnvironmentSource.\nfunc NewFileOrEnvironmentSource(\n\tconfigFile, envoyVersion string,\n) (*FileOrEnvironmentSource, error) {\n\tctx := log.WithContext(context.TODO(), func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"config_file_source\", configFile)\n\t})\n\n\toptions, err := newOptionsFromConfig(configFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tports, err := netutil.AllocatePorts(5)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgrpcPort := ports[0]\n\thttpPort := ports[1]\n\toutboundPort := ports[2]\n\tmetricsPort := ports[3]\n\tdebugPort := ports[4]\n\n\tcfg := &Config{\n\t\tOptions:      options,\n\t\tEnvoyVersion: envoyVersion,\n\n\t\tGRPCPort:     grpcPort,\n\t\tHTTPPort:     httpPort,\n\t\tOutboundPort: outboundPort,\n\t\tMetricsPort:  metricsPort,\n\t\tDebugPort:    debugPort,\n\t}\n\tmetrics.SetConfigInfo(ctx, cfg.Options.Services, \"local\", cfg.Checksum(), true)\n\n\tsrc := &FileOrEnvironmentSource{\n\t\tconfigFile: configFile,\n\t\tconfig:     cfg,\n\t}\n\toptions.viper.OnConfigChange(src.onConfigChange(ctx))\n\tgo options.viper.WatchConfig()\n\n\treturn src, nil\n}\n\nfunc (src *FileOrEnvironmentSource) onConfigChange(ctx context.Context) func(fsnotify.Event) {\n\treturn func(evt fsnotify.Event) {\n\t\tctx := log.WithContext(ctx, func(c zerolog.Context) zerolog.Context {\n\t\t\treturn c.Str(\"config_change_id\", uuid.New().String())\n\t\t})\n\t\tlog.Info(ctx).Msg(\"config: file updated, reconfiguring...\")\n\t\tsrc.mu.Lock()\n\t\tcfg := src.config\n\t\toptions, err := newOptionsFromConfig(src.configFile)\n\t\tif err == nil {\n\t\t\tcfg = cfg.Clone()\n\t\t\tcfg.Options = options\n\t\t\tmetrics.SetConfigInfo(ctx, cfg.Options.Services, \"local\", cfg.Checksum(), true)\n\t\t} else {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"config: error updating config\")\n\t\t\tmetrics.SetConfigInfo(ctx, cfg.Options.Services, \"local\", cfg.Checksum(), false)\n\t\t}\n\t\tsrc.mu.Unlock()\n\n\t\tsrc.Trigger(ctx, cfg)\n\t}\n}\n\n// GetConfig gets the config.\nfunc (src *FileOrEnvironmentSource) GetConfig() *Config {\n\tsrc.mu.RLock()\n\tdefer src.mu.RUnlock()\n\n\treturn src.config\n}\n\n// FileWatcherSource is a config source which triggers a change any time a file in the options changes.\ntype FileWatcherSource struct {\n\tunderlying Source\n\twatcher    *fileutil.Watcher\n\n\tmu             sync.RWMutex\n\tcomputedConfig *Config\n\n\tChangeDispatcher\n}\n\n// NewFileWatcherSource creates a new FileWatcherSource\nfunc NewFileWatcherSource(underlying Source) *FileWatcherSource {\n\tsrc := &FileWatcherSource{\n\t\tunderlying: underlying,\n\t\twatcher:    fileutil.NewWatcher(),\n\t}\n\n\tch := src.watcher.Bind()\n\tgo func() {\n\t\tfor range ch {\n\t\t\tsrc.check(context.TODO(), underlying.GetConfig())\n\t\t}\n\t}()\n\tunderlying.OnConfigChange(context.TODO(), func(ctx context.Context, cfg *Config) {\n\t\tsrc.check(ctx, cfg)\n\t})\n\tsrc.check(context.TODO(), underlying.GetConfig())\n\n\treturn src\n}\n\n// GetConfig gets the underlying config.\nfunc (src *FileWatcherSource) GetConfig() *Config {\n\tsrc.mu.RLock()\n\tdefer src.mu.RUnlock()\n\treturn src.computedConfig\n}\n\nfunc (src *FileWatcherSource) check(ctx context.Context, cfg *Config) {\n\tif cfg == nil || cfg.Options == nil {\n\t\treturn\n\t}\n\n\tsrc.mu.Lock()\n\tdefer src.mu.Unlock()\n\n\tsrc.watcher.Clear()\n\n\th := sha256.New()\n\tfs := []string{\n\t\tcfg.Options.CAFile,\n\t\tcfg.Options.CertFile,\n\t\tcfg.Options.ClientCAFile,\n\t\tcfg.Options.ClientCRLFile,\n\t\tcfg.Options.DataBrokerStorageCAFile,\n\t\tcfg.Options.DataBrokerStorageCertFile,\n\t\tcfg.Options.DataBrokerStorageCertKeyFile,\n\t\tcfg.Options.KeyFile,\n\t\tcfg.Options.PolicyFile,\n\t\tcfg.Options.MetricsClientCAFile,\n\t\tcfg.Options.MetricsCertificateFile,\n\t\tcfg.Options.MetricsCertificateKeyFile,\n\t}\n\n\tfor _, pair := range cfg.Options.CertificateFiles {\n\t\tfs = append(fs, pair.CertFile, pair.KeyFile)\n\t}\n\n\tfor _, policy := range cfg.Options.Policies {\n\t\tfs = append(fs,\n\t\t\tpolicy.KubernetesServiceAccountTokenFile,\n\t\t\tpolicy.TLSClientCertFile,\n\t\t\tpolicy.TLSClientKeyFile,\n\t\t\tpolicy.TLSCustomCAFile,\n\t\t\tpolicy.TLSDownstreamClientCAFile,\n\t\t)\n\t}\n\n\tfor _, f := range fs {\n\t\t_, _ = h.Write([]byte{0})\n\t\tbs, err := os.ReadFile(f)\n\t\tif err == nil {\n\t\t\tsrc.watcher.Add(f)\n\t\t\t_, _ = h.Write(bs)\n\t\t}\n\t}\n\n\t// update the computed config\n\tsrc.computedConfig = cfg.Clone()\n\n\t// trigger a change\n\tsrc.Trigger(ctx, src.computedConfig)\n}\n", "package envoyconfig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n)\n\nfunc TestBuilder_BuildBootstrapAdmin(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\tadminCfg, err := b.BuildBootstrapAdmin(&config.Config{\n\t\t\tOptions: &config.Options{\n\t\t\t\tEnvoyAdminAddress: \"localhost:9901\",\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"address\": {\n\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\"portValue\": 9901\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`, adminCfg)\n\t})\n\tt.Run(\"bad address\", func(t *testing.T) {\n\t\t_, err := b.BuildBootstrapAdmin(&config.Config{\n\t\t\tOptions: &config.Options{\n\t\t\t\tEnvoyAdminAddress: \"xyz1234:zyx4321\",\n\t\t\t},\n\t\t})\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestBuilder_BuildBootstrapLayeredRuntime(t *testing.T) {\n\tb := New(\"localhost:1111\", \"localhost:2222\", \"localhost:3333\", filemgr.NewManager(), nil)\n\tstaticCfg, err := b.BuildBootstrapLayeredRuntime()\n\tassert.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t{ \"layers\": [{\n\t\t\t\"name\": \"static_layer_0\",\n\t\t\t\"staticLayer\": {\n\t\t\t\t\"overload\": {\n\t\t\t\t\t\"global_downstream_max_connections\": 50000\n\t\t\t\t}\n\t\t\t}\n\t\t}] }\n\t`, staticCfg)\n}\n\nfunc TestBuilder_BuildBootstrapStaticResources(t *testing.T) {\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\tb := New(\"localhost:1111\", \"localhost:2222\", \"localhost:3333\", filemgr.NewManager(), nil)\n\t\tstaticCfg, err := b.BuildBootstrapStaticResources()\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"clusters\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"pomerium-control-plane-grpc\",\n\t\t\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\t\t\"connectTimeout\": \"5s\",\n\t\t\t\t\t\t\"http2ProtocolOptions\": {},\n\t\t\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\t\t\"clusterName\": \"pomerium-control-plane-grpc\",\n\t\t\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\t\t\"socketAddress\":{\n\t\t\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"portValue\": 1111\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t`, staticCfg)\n\t})\n\tt.Run(\"bad gRPC address\", func(t *testing.T) {\n\t\tb := New(\"xyz:zyx\", \"localhost:2222\", \"localhost:3333\", filemgr.NewManager(), nil)\n\t\t_, err := b.BuildBootstrapStaticResources()\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestBuilder_BuildBootstrapStatsConfig(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\tstatsCfg, err := b.BuildBootstrapStatsConfig(&config.Config{\n\t\t\tOptions: &config.Options{\n\t\t\t\tServices: \"all\",\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"statsTags\": [{\n\t\t\t\t\t\"tagName\": \"service\",\n\t\t\t\t\t\"fixedValue\": \"pomerium\"\n\t\t\t\t}]\n\t\t\t}\n\t\t`, statsCfg)\n\t})\n}\n", "package envoyconfig\n\nimport (\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/httputil/reproxy\"\n)\n\n// A Builder builds envoy config from pomerium config.\ntype Builder struct {\n\tlocalGRPCAddress    string\n\tlocalHTTPAddress    string\n\tlocalMetricsAddress string\n\tfilemgr             *filemgr.Manager\n\treproxy             *reproxy.Handler\n}\n\n// New creates a new Builder.\nfunc New(\n\tlocalGRPCAddress string,\n\tlocalHTTPAddress string,\n\tlocalMetricsAddress string,\n\tfileManager *filemgr.Manager,\n\treproxyHandler *reproxy.Handler,\n) *Builder {\n\treturn &Builder{\n\t\tlocalGRPCAddress:    localGRPCAddress,\n\t\tlocalHTTPAddress:    localHTTPAddress,\n\t\tlocalMetricsAddress: localMetricsAddress,\n\t\tfilemgr:             fileManager,\n\t\treproxy:             reproxyHandler,\n\t}\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\tenvoy_config_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tenvoy_config_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_config_endpoint_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3\"\n\tenvoy_extensions_transport_sockets_tls_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/anypb\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n)\n\n// BuildClusters builds envoy clusters from the given config.\nfunc (b *Builder) BuildClusters(ctx context.Context, cfg *config.Config) ([]*envoy_config_cluster_v3.Cluster, error) {\n\tgrpcURL := &url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   b.localGRPCAddress,\n\t}\n\thttpURL := &url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   b.localHTTPAddress,\n\t}\n\tmetricsURL := &url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   b.localMetricsAddress,\n\t}\n\tauthorizeURLs, err := cfg.Options.GetInternalAuthorizeURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdatabrokerURLs, err := cfg.Options.GetDataBrokerURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontrolGRPC, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-control-plane-grpc\", []*url.URL{grpcURL}, upstreamProtocolHTTP2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontrolHTTP, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-control-plane-http\", []*url.URL{httpURL}, upstreamProtocolAuto)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontrolMetrics, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-control-plane-metrics\", []*url.URL{metricsURL}, upstreamProtocolAuto)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tauthorizeCluster, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-authorize\", authorizeURLs, upstreamProtocolHTTP2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(authorizeURLs) > 1 {\n\t\tauthorizeCluster.HealthChecks = grpcHealthChecks(\"pomerium-authorize\")\n\t\tauthorizeCluster.OutlierDetection = grpcAuthorizeOutlierDetection()\n\t}\n\n\tdatabrokerCluster, err := b.buildInternalCluster(ctx, cfg.Options, \"pomerium-databroker\", databrokerURLs, upstreamProtocolHTTP2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(databrokerURLs) > 1 {\n\t\tauthorizeCluster.HealthChecks = grpcHealthChecks(\"pomerium-databroker\")\n\t\tauthorizeCluster.OutlierDetection = grpcAuthorizeOutlierDetection()\n\t}\n\n\tclusters := []*envoy_config_cluster_v3.Cluster{\n\t\tcontrolGRPC,\n\t\tcontrolHTTP,\n\t\tcontrolMetrics,\n\t\tauthorizeCluster,\n\t\tdatabrokerCluster,\n\t}\n\n\ttracingCluster, err := buildTracingCluster(cfg.Options)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if tracingCluster != nil {\n\t\tclusters = append(clusters, tracingCluster)\n\t}\n\n\tif config.IsProxy(cfg.Options.Services) {\n\t\tfor i, p := range cfg.Options.GetAllPolicies() {\n\t\t\tpolicy := p\n\t\t\tif policy.EnvoyOpts == nil {\n\t\t\t\tpolicy.EnvoyOpts = newDefaultEnvoyClusterConfig()\n\t\t\t}\n\t\t\tif len(policy.To) > 0 {\n\t\t\t\tcluster, err := b.buildPolicyCluster(ctx, cfg.Options, &policy)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"policy #%d: %w\", i, err)\n\t\t\t\t}\n\t\t\t\tclusters = append(clusters, cluster)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = validateClusters(clusters); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn clusters, nil\n}\n\nfunc (b *Builder) buildInternalCluster(\n\tctx context.Context,\n\toptions *config.Options,\n\tname string,\n\tdsts []*url.URL,\n\tupstreamProtocol upstreamProtocolConfig,\n) (*envoy_config_cluster_v3.Cluster, error) {\n\tcluster := newDefaultEnvoyClusterConfig()\n\tcluster.DnsLookupFamily = config.GetEnvoyDNSLookupFamily(options.DNSLookupFamily)\n\tvar endpoints []Endpoint\n\tfor _, dst := range dsts {\n\t\tts, err := b.buildInternalTransportSocket(ctx, options, dst)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tendpoints = append(endpoints, NewEndpoint(dst, ts, 1))\n\t}\n\tif err := b.buildCluster(cluster, name, endpoints, upstreamProtocol); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cluster, nil\n}\n\nfunc (b *Builder) buildPolicyCluster(ctx context.Context, options *config.Options, policy *config.Policy) (*envoy_config_cluster_v3.Cluster, error) {\n\tcluster := new(envoy_config_cluster_v3.Cluster)\n\tproto.Merge(cluster, policy.EnvoyOpts)\n\n\tif options.EnvoyBindConfigFreebind.IsSet() || options.EnvoyBindConfigSourceAddress != \"\" {\n\t\tcluster.UpstreamBindConfig = new(envoy_config_core_v3.BindConfig)\n\t\tif options.EnvoyBindConfigFreebind.IsSet() {\n\t\t\tcluster.UpstreamBindConfig.Freebind = wrapperspb.Bool(options.EnvoyBindConfigFreebind.Bool)\n\t\t}\n\t\tif options.EnvoyBindConfigSourceAddress != \"\" {\n\t\t\tcluster.UpstreamBindConfig.SourceAddress = &envoy_config_core_v3.SocketAddress{\n\t\t\t\tAddress: options.EnvoyBindConfigSourceAddress,\n\t\t\t\tPortSpecifier: &envoy_config_core_v3.SocketAddress_PortValue{\n\t\t\t\t\tPortValue: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tcluster.UpstreamBindConfig.SourceAddress = &envoy_config_core_v3.SocketAddress{\n\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\tPortSpecifier: &envoy_config_core_v3.SocketAddress_PortValue{\n\t\t\t\t\tPortValue: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tcluster.AltStatName = getClusterStatsName(policy)\n\tupstreamProtocol := getUpstreamProtocolForPolicy(ctx, policy)\n\n\tname := getClusterID(policy)\n\tendpoints, err := b.buildPolicyEndpoints(ctx, options, policy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cluster.DnsLookupFamily == envoy_config_cluster_v3.Cluster_AUTO {\n\t\tcluster.DnsLookupFamily = config.GetEnvoyDNSLookupFamily(options.DNSLookupFamily)\n\t}\n\n\tif policy.EnableGoogleCloudServerlessAuthentication {\n\t\tcluster.DnsLookupFamily = envoy_config_cluster_v3.Cluster_V4_ONLY\n\t}\n\n\tif err := b.buildCluster(cluster, name, endpoints, upstreamProtocol); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cluster, nil\n}\n\nfunc (b *Builder) buildPolicyEndpoints(\n\tctx context.Context,\n\toptions *config.Options,\n\tpolicy *config.Policy,\n) ([]Endpoint, error) {\n\tvar endpoints []Endpoint\n\tfor _, dst := range policy.To {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, options, policy, dst.URL)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tendpoints = append(endpoints, NewEndpoint(&dst.URL, ts, dst.LbWeight))\n\t}\n\treturn endpoints, nil\n}\n\nfunc (b *Builder) buildInternalTransportSocket(\n\tctx context.Context,\n\toptions *config.Options,\n\tendpoint *url.URL,\n) (*envoy_config_core_v3.TransportSocket, error) {\n\tif endpoint.Scheme != \"https\" {\n\t\treturn nil, nil\n\t}\n\n\tvalidationContext := &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\tMatchTypedSubjectAltNames: []*envoy_extensions_transport_sockets_tls_v3.SubjectAltNameMatcher{\n\t\t\tb.buildSubjectAltNameMatcher(endpoint, options.OverrideCertificateName),\n\t\t},\n\t}\n\tbs, err := getCombinedCertificateAuthority(options.CA, options.CAFile)\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"unable to enable certificate verification because no root CAs were found\")\n\t} else {\n\t\tvalidationContext.TrustedCa = b.filemgr.BytesDataSource(\"ca.pem\", bs)\n\t}\n\ttlsContext := &envoy_extensions_transport_sockets_tls_v3.UpstreamTlsContext{\n\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\tAlpnProtocols: []string{\"h2\", \"http/1.1\"},\n\t\t\tValidationContextType: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: validationContext,\n\t\t\t},\n\t\t},\n\t\tSni: b.buildSubjectNameIndication(endpoint, options.OverrideCertificateName),\n\t}\n\ttlsConfig := marshalAny(tlsContext)\n\treturn &envoy_config_core_v3.TransportSocket{\n\t\tName: \"tls\",\n\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\tTypedConfig: tlsConfig,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildPolicyTransportSocket(\n\tctx context.Context,\n\toptions *config.Options,\n\tpolicy *config.Policy,\n\tdst url.URL,\n) (*envoy_config_core_v3.TransportSocket, error) {\n\tif dst.Scheme != \"https\" {\n\t\treturn nil, nil\n\t}\n\n\tupstreamProtocol := getUpstreamProtocolForPolicy(ctx, policy)\n\n\tvc, err := b.buildPolicyValidationContext(ctx, options, policy, dst)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsni := dst.Hostname()\n\tif policy.TLSServerName != \"\" {\n\t\tsni = policy.TLSServerName\n\t}\n\ttlsContext := &envoy_extensions_transport_sockets_tls_v3.UpstreamTlsContext{\n\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\tTlsParams: &envoy_extensions_transport_sockets_tls_v3.TlsParameters{\n\t\t\t\tCipherSuites: []string{\n\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\"AES256-SHA\",\n\t\t\t\t},\n\t\t\t\tEcdhCurves: []string{\n\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\"P-521\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAlpnProtocols: buildUpstreamALPN(upstreamProtocol),\n\t\t\tValidationContextType: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: vc,\n\t\t\t},\n\t\t},\n\t\tSni: sni,\n\t}\n\tif policy.ClientCertificate != nil {\n\t\ttlsContext.CommonTlsContext.TlsCertificates = append(tlsContext.CommonTlsContext.TlsCertificates,\n\t\t\tb.envoyTLSCertificateFromGoTLSCertificate(ctx, policy.ClientCertificate))\n\t}\n\n\ttlsConfig := marshalAny(tlsContext)\n\treturn &envoy_config_core_v3.TransportSocket{\n\t\tName: \"tls\",\n\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\tTypedConfig: tlsConfig,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildPolicyValidationContext(\n\tctx context.Context,\n\toptions *config.Options,\n\tpolicy *config.Policy,\n\tdst url.URL,\n) (*envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext, error) {\n\tvalidationContext := &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\tMatchTypedSubjectAltNames: []*envoy_extensions_transport_sockets_tls_v3.SubjectAltNameMatcher{\n\t\t\tb.buildSubjectAltNameMatcher(&dst, policy.TLSServerName),\n\t\t},\n\t}\n\tif policy.TLSCustomCAFile != \"\" {\n\t\tvalidationContext.TrustedCa = b.filemgr.FileDataSource(policy.TLSCustomCAFile)\n\t} else if policy.TLSCustomCA != \"\" {\n\t\tbs, err := base64.StdEncoding.DecodeString(policy.TLSCustomCA)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"invalid custom CA certificate\")\n\t\t}\n\t\tvalidationContext.TrustedCa = b.filemgr.BytesDataSource(\"custom-ca.pem\", bs)\n\t} else {\n\t\tbs, err := getCombinedCertificateAuthority(options.CA, options.CAFile)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"unable to enable certificate verification because no root CAs were found\")\n\t\t} else {\n\t\t\tvalidationContext.TrustedCa = b.filemgr.BytesDataSource(\"ca.pem\", bs)\n\t\t}\n\t}\n\n\tif policy.TLSSkipVerify {\n\t\tvalidationContext.TrustChainVerification = envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_ACCEPT_UNTRUSTED\n\t}\n\n\treturn validationContext, nil\n}\n\nfunc (b *Builder) buildCluster(\n\tcluster *envoy_config_cluster_v3.Cluster,\n\tname string,\n\tendpoints []Endpoint,\n\tupstreamProtocol upstreamProtocolConfig,\n) error {\n\tif len(endpoints) == 0 {\n\t\treturn errNoEndpoints\n\t}\n\n\tif cluster.ConnectTimeout == nil {\n\t\tcluster.ConnectTimeout = defaultConnectionTimeout\n\t}\n\tcluster.RespectDnsTtl = true\n\tlbEndpoints, err := b.buildLbEndpoints(endpoints)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcluster.Name = name\n\tcluster.LoadAssignment = &envoy_config_endpoint_v3.ClusterLoadAssignment{\n\t\tClusterName: name,\n\t\tEndpoints: []*envoy_config_endpoint_v3.LocalityLbEndpoints{{\n\t\t\tLbEndpoints: lbEndpoints,\n\t\t}},\n\t}\n\tcluster.TransportSocketMatches, err = b.buildTransportSocketMatches(endpoints)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set the default transport socket to the first socket match. This is necessary so that ALPN\n\t// auto configuration works.\n\tif len(cluster.TransportSocketMatches) > 0 {\n\t\tcluster.TransportSocket = cluster.TransportSocketMatches[0].TransportSocket\n\t}\n\n\tcluster.TypedExtensionProtocolOptions = map[string]*anypb.Any{\n\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": marshalAny(buildUpstreamProtocolOptions(endpoints, upstreamProtocol)),\n\t}\n\n\tcluster.ClusterDiscoveryType = getClusterDiscoveryType(lbEndpoints)\n\n\treturn cluster.Validate()\n}\n\n// grpcAuthorizeOutlierDetection defines slightly more aggressive malfunction detection for authorize endpoints\nfunc grpcAuthorizeOutlierDetection() *envoy_config_cluster_v3.OutlierDetection {\n\treturn &envoy_config_cluster_v3.OutlierDetection{\n\t\tConsecutive_5Xx:                       wrapperspb.UInt32(5),\n\t\tInterval:                              durationpb.New(time.Second * 10),\n\t\tBaseEjectionTime:                      durationpb.New(time.Second * 30),\n\t\tMaxEjectionPercent:                    wrapperspb.UInt32(100),\n\t\tEnforcingConsecutive_5Xx:              wrapperspb.UInt32(100),\n\t\tEnforcingSuccessRate:                  wrapperspb.UInt32(100),\n\t\tSuccessRateMinimumHosts:               wrapperspb.UInt32(2),\n\t\tSuccessRateRequestVolume:              wrapperspb.UInt32(10),\n\t\tSuccessRateStdevFactor:                wrapperspb.UInt32(1900),\n\t\tConsecutiveGatewayFailure:             wrapperspb.UInt32(5),\n\t\tEnforcingConsecutiveGatewayFailure:    wrapperspb.UInt32(0),\n\t\tSplitExternalLocalOriginErrors:        false,\n\t\tFailurePercentageThreshold:            wrapperspb.UInt32(85),\n\t\tEnforcingFailurePercentage:            wrapperspb.UInt32(100),\n\t\tEnforcingFailurePercentageLocalOrigin: wrapperspb.UInt32(100),\n\t\tFailurePercentageMinimumHosts:         wrapperspb.UInt32(2),\n\t\tFailurePercentageRequestVolume:        wrapperspb.UInt32(10),\n\t\tMaxEjectionTime:                       durationpb.New(time.Minute * 5),\n\t}\n}\n\nfunc grpcHealthChecks(name string) []*envoy_config_core_v3.HealthCheck {\n\treturn []*envoy_config_core_v3.HealthCheck{{\n\t\tTimeout:               durationpb.New(time.Second * 10),\n\t\tInterval:              durationpb.New(time.Second * 10),\n\t\tInitialJitter:         durationpb.New(time.Millisecond * 100),\n\t\tIntervalJitter:        durationpb.New(time.Millisecond * 100),\n\t\tIntervalJitterPercent: 10,\n\t\tUnhealthyThreshold:    wrapperspb.UInt32(1),\n\t\tHealthyThreshold:      wrapperspb.UInt32(1),\n\t\tReuseConnection:       wrapperspb.Bool(true),\n\t\tNoTrafficInterval:     durationpb.New(time.Minute),\n\t\tHealthChecker: &envoy_config_core_v3.HealthCheck_GrpcHealthCheck_{\n\t\t\tGrpcHealthCheck: &envoy_config_core_v3.HealthCheck_GrpcHealthCheck{\n\t\t\t\tServiceName: name,\n\t\t\t},\n\t\t},\n\t}}\n}\n\nfunc (b *Builder) buildLbEndpoints(endpoints []Endpoint) ([]*envoy_config_endpoint_v3.LbEndpoint, error) {\n\tvar lbes []*envoy_config_endpoint_v3.LbEndpoint\n\tfor _, e := range endpoints {\n\t\tdefaultPort := 80\n\t\tif e.transportSocket != nil && e.transportSocket.Name == \"tls\" {\n\t\t\tdefaultPort = 443\n\t\t}\n\n\t\tu := e.url\n\t\tif e.url.Hostname() == \"localhost\" {\n\t\t\tu.Host = strings.Replace(e.url.Host, \"localhost\", \"127.0.0.1\", -1)\n\t\t}\n\n\t\tlbe := &envoy_config_endpoint_v3.LbEndpoint{\n\t\t\tHostIdentifier: &envoy_config_endpoint_v3.LbEndpoint_Endpoint{\n\t\t\t\tEndpoint: &envoy_config_endpoint_v3.Endpoint{\n\t\t\t\t\tAddress: buildAddress(u.Host, defaultPort),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLoadBalancingWeight: e.loadBalancerWeight,\n\t\t}\n\n\t\tif e.transportSocket != nil {\n\t\t\tlbe.Metadata = &envoy_config_core_v3.Metadata{\n\t\t\t\tFilterMetadata: map[string]*structpb.Struct{\n\t\t\t\t\t\"envoy.transport_socket_match\": {\n\t\t\t\t\t\tFields: map[string]*structpb.Value{\n\t\t\t\t\t\t\te.TransportSocketName(): structpb.NewBoolValue(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tlbes = append(lbes, lbe)\n\t}\n\treturn lbes, nil\n}\n\nfunc (b *Builder) buildTransportSocketMatches(endpoints []Endpoint) ([]*envoy_config_cluster_v3.Cluster_TransportSocketMatch, error) {\n\tvar tsms []*envoy_config_cluster_v3.Cluster_TransportSocketMatch\n\tseen := map[string]struct{}{}\n\tfor _, e := range endpoints {\n\t\tif e.transportSocket == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// only add unique transport sockets\n\t\tnm := e.TransportSocketName()\n\t\tif _, ok := seen[nm]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tseen[nm] = struct{}{}\n\n\t\ttsms = append(tsms, &envoy_config_cluster_v3.Cluster_TransportSocketMatch{\n\t\t\tName: nm,\n\t\t\tMatch: &structpb.Struct{\n\t\t\t\tFields: map[string]*structpb.Value{\n\t\t\t\t\tnm: structpb.NewBoolValue(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTransportSocket: e.transportSocket,\n\t\t})\n\t}\n\treturn tsms, nil\n}\n\n// validateClusters contains certain rules that must match\nfunc validateClusters(clusters []*envoy_config_cluster_v3.Cluster) error {\n\treturn validateClusterNamesUnique(clusters)\n}\n\n// validateClusterNamesUnique checks cluster names are unique, as they're effectively IDs\nfunc validateClusterNamesUnique(clusters []*envoy_config_cluster_v3.Cluster) error {\n\tnames := make(map[string]bool, len(clusters))\n\n\tfor _, c := range clusters {\n\t\tif _, there := names[c.Name]; there {\n\t\t\treturn fmt.Errorf(\"route %s is not unique\", c.Name)\n\t\t}\n\t\tnames[c.Name] = true\n\t}\n\n\treturn nil\n}\n\nfunc getClusterDiscoveryType(lbEndpoints []*envoy_config_endpoint_v3.LbEndpoint) *envoy_config_cluster_v3.Cluster_Type {\n\t// for IPs we use a static discovery type, otherwise we use DNS\n\tallIP := true\n\tfor _, lbe := range lbEndpoints {\n\t\tif net.ParseIP(urlutil.StripPort(lbe.GetEndpoint().GetAddress().GetSocketAddress().GetAddress())) == nil {\n\t\t\tallIP = false\n\t\t}\n\t}\n\tif allIP {\n\t\treturn &envoy_config_cluster_v3.Cluster_Type{Type: envoy_config_cluster_v3.Cluster_STATIC}\n\t}\n\treturn &envoy_config_cluster_v3.Cluster_Type{Type: envoy_config_cluster_v3.Cluster_STRICT_DNS}\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\tenvoy_config_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/volatiletech/null/v9\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n\t\"github.com/pomerium/pomerium/pkg/cryptutil\"\n)\n\nfunc Test_buildPolicyTransportSocket(t *testing.T) {\n\tctx := context.Background()\n\tcacheDir, _ := os.UserCacheDir()\n\tcustomCA := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"custom-ca-32484c314b584447463735303142374c31414145374650305a525539554938594d524855353757313942494d473847535231.pem\")\n\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\trootCABytes, _ := getCombinedCertificateAuthority(\"\", \"\")\n\trootCA := b.filemgr.BytesDataSource(\"ca.pem\", rootCABytes).GetFilename()\n\n\to1 := config.NewDefaultOptions()\n\to2 := config.NewDefaultOptions()\n\to2.CA = base64.StdEncoding.EncodeToString([]byte{0, 0, 0, 0})\n\n\tcombinedCABytes, _ := getCombinedCertificateAuthority(o2.CA, \"\")\n\tcombinedCA := b.filemgr.BytesDataSource(\"ca.pem\", combinedCABytes).GetFilename()\n\n\tt.Run(\"insecure\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://example.com\"),\n\t\t}, *mustParseURL(t, \"http://example.com\"))\n\t\trequire.NoError(t, err)\n\t\tassert.Nil(t, ts)\n\t})\n\tt.Run(\"host as sni\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"tls_server_name as sni\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:            mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tTLSServerName: \"use-this-name.example.com\",\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"use-this-name.example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"use-this-name.example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"tls_skip_verify\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:            mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tTLSSkipVerify: true,\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"trustChainVerification\": \"ACCEPT_UNTRUSTED\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"custom ca\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:          mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tTLSCustomCA: base64.StdEncoding.EncodeToString([]byte{0, 0, 0, 0}),\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+customCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"options custom ca\", func(t *testing.T) {\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o2, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+combinedCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n\tt.Run(\"client certificate\", func(t *testing.T) {\n\t\tclientCert, _ := cryptutil.CertificateFromBase64(aExampleComCert, aExampleComKey)\n\t\tts, err := b.buildPolicyTransportSocket(ctx, o1, &config.Policy{\n\t\t\tTo:                mustParseWeightedURLs(t, \"https://example.com\"),\n\t\t\tClientCertificate: clientCert,\n\t\t}, *mustParseURL(t, \"https://example.com\"))\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\"cipherSuites\": [\n            \t            \t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-RSA-AES256-GCM-SHA384\",\n            \t            \t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-RSA-AES128-GCM-SHA256\",\n            \t            \t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-RSA-CHACHA20-POLY1305\",\n            \t            \t\"ECDHE-ECDSA-AES128-SHA\",\n            \t            \t\"ECDHE-RSA-AES128-SHA\",\n            \t            \t\"AES128-GCM-SHA256\",\n            \t            \t\"AES128-SHA\",\n            \t            \t\"ECDHE-ECDSA-AES256-SHA\",\n            \t            \t\"ECDHE-RSA-AES256-SHA\",\n            \t            \t\"AES256-GCM-SHA384\",\n            \t            \t\"AES256-SHA\"\n            \t            ],\n\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"tlsCertificates\": [{\n\t\t\t\t\t\t\t\"certificateChain\":{\n\t\t\t\t\t\t\t\t\"filename\": \"`+filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-crt-354e49305a5a39414a545530374e58454e48334148524c4e324258463837364355564c4e4532464b54355139495547514a38.pem\")+`\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-key-3350415a38414e4e4a4655424e55393430474147324651433949384e485341334b5157364f424b4c5856365a545937383735.pem\")+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t}\n\t\t\t}\n\t\t`, ts)\n\t})\n}\n\nfunc Test_buildCluster(t *testing.T) {\n\tctx := context.Background()\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\trootCABytes, _ := getCombinedCertificateAuthority(\"\", \"\")\n\trootCA := b.filemgr.BytesDataSource(\"ca.pem\", rootCABytes).GetFilename()\n\to1 := config.NewDefaultOptions()\n\tt.Run(\"insecure\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://example.com\", \"http://1.2.3.4\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\tcluster.DnsLookupFamily = envoy_config_cluster_v3.Cluster_V4_ONLY\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STRICT_DNS\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"dnsLookupFamily\": \"V4_ONLY\",\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"1.2.3.4\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"secure\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t,\n\t\t\t\t\"https://example.com\",\n\t\t\t\t\"https://example.com\",\n\t\t\t),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STRICT_DNS\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"transportSocketMatches\": [{\n\t\t\t\t\t\"name\": \"`+endpoints[0].TransportSocketName()+`\",\n\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\"`+endpoints[0].TransportSocketName()+`\": true\n\t\t\t\t\t},\n\t\t\t\t\t\"transportSocket\": {\n\t\t\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}],\n\t\t\t\t\"transportSocket\": {\n\t\t\t\t\t\"name\": \"tls\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\",\n\t\t\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\t\t\t\"AES128-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-SHA\",\n\t\t\t\t\t\t\t\t\t\t\"AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\t\t\t\"AES256-SHA\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\"ecdhCurves\": [\n\t\t\t\t\t\t\t\t\t\"X25519\",\n\t\t\t\t\t\t\t\t\t\"P-256\",\n\t\t\t\t\t\t\t\t\t\"P-384\",\n\t\t\t\t\t\t\t\t\t\"P-521\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\t\t\t\"matchTypedSubjectAltNames\": [{\n\t\t\t\t\t\t\t\t\t\"sanType\": \"DNS\",\n\t\t\t\t\t\t\t\t\t\"matcher\": {\n\t\t\t\t\t\t\t\t\t\t\"exact\": \"example.com\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t\t\"trustedCa\": {\n\t\t\t\t\t\t\t\t\t\"filename\": \"`+rootCA+`\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"sni\": \"example.com\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 443\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\t\t\"envoy.transport_socket_match\": {\n\t\t\t\t\t\t\t\t\t\t\"`+endpoints[0].TransportSocketName()+`\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 443\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\t\t\"envoy.transport_socket_match\": {\n\t\t\t\t\t\t\t\t\t\t\"`+endpoints[0].TransportSocketName()+`\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"ip addresses\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://127.0.0.1\", \"http://127.0.0.2\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.2\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"weights\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://127.0.0.1:8080,1\", \"http://127.0.0.2,2\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 8080\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"loadBalancingWeight\": 1\n\t\t\t\t\t\t},{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.2\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"loadBalancingWeight\": 2\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"localhost\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://localhost\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STATIC\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n\tt.Run(\"outlier\", func(t *testing.T) {\n\t\tendpoints, err := b.buildPolicyEndpoints(ctx, o1, &config.Policy{\n\t\t\tTo: mustParseWeightedURLs(t, \"http://example.com\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tcluster := newDefaultEnvoyClusterConfig()\n\t\tcluster.DnsLookupFamily = envoy_config_cluster_v3.Cluster_V4_ONLY\n\t\tcluster.OutlierDetection = &envoy_config_cluster_v3.OutlierDetection{\n\t\t\tEnforcingConsecutive_5Xx:       wrapperspb.UInt32(17),\n\t\t\tSplitExternalLocalOriginErrors: true,\n\t\t}\n\t\terr = b.buildCluster(cluster, \"example\", endpoints, upstreamProtocolHTTP2)\n\t\trequire.NoErrorf(t, err, \"cluster %+v\", cluster)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"name\": \"example\",\n\t\t\t\t\"type\": \"STRICT_DNS\",\n\t\t\t\t\"connectTimeout\": \"10s\",\n\t\t\t\t\"respectDnsTtl\": true,\n\t\t\t\t\"perConnectionBufferLimitBytes\": 32768,\n\t\t\t\t\"typedExtensionProtocolOptions\": {\n\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\n\t\t\t\t\t\t\"explicitHttpConfig\": {\n\t\t\t\t\t\t\t\"http2ProtocolOptions\": {\n\t\t\t\t\t\t\t\t\"allowConnect\": true,\n\t\t\t\t\t\t\t\t\"initialConnectionWindowSize\": 1048576,\n\t\t\t\t\t\t\t\t\"initialStreamWindowSize\": 65536,\n\t\t\t\t\t\t\t\t\"maxConcurrentStreams\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"dnsLookupFamily\": \"V4_ONLY\",\n\t\t\t\t\"outlierDetection\": {\n\t\t\t\t\t\"enforcingConsecutive5xx\": 17,\n\t\t\t\t\t\"splitExternalLocalOriginErrors\": true\n\t\t\t\t},\n\t\t\t\t\"loadAssignment\": {\n\t\t\t\t\t\"clusterName\": \"example\",\n\t\t\t\t\t\"endpoints\": [{\n\t\t\t\t\t\t\"lbEndpoints\": [{\n\t\t\t\t\t\t\t\"endpoint\": {\n\t\t\t\t\t\t\t\t\"address\": {\n\t\t\t\t\t\t\t\t\t\"socketAddress\": {\n\t\t\t\t\t\t\t\t\t\t\"address\": \"example.com\",\n\t\t\t\t\t\t\t\t\t\t\"ipv4Compat\": true,\n\t\t\t\t\t\t\t\t\t\t\"portValue\": 80\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster)\n\t})\n}\n\nfunc Test_validateClusters(t *testing.T) {\n\ttype c []*envoy_config_cluster_v3.Cluster\n\ttestCases := []struct {\n\t\tclusters    c\n\t\texpectError bool\n\t}{\n\t\t{c{{Name: \"one\"}, {Name: \"one\"}}, true},\n\t\t{c{{Name: \"one\"}, {Name: \"two\"}}, false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\terr := validateClusters(tc.clusters)\n\t\tif tc.expectError {\n\t\t\tassert.Error(t, err, \"%#v\", tc.clusters)\n\t\t} else {\n\t\t\tassert.NoError(t, err, \"%#v\", tc.clusters)\n\t\t}\n\t}\n}\n\nfunc Test_bindConfig(t *testing.T) {\n\tctx, clearTimeout := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer clearTimeout()\n\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\tt.Run(\"no bind config\", func(t *testing.T) {\n\t\tcluster, err := b.buildPolicyCluster(ctx, &config.Options{}, &config.Policy{\n\t\t\tFrom: \"https://from.example.com\",\n\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, cluster.UpstreamBindConfig)\n\t})\n\tt.Run(\"freebind\", func(t *testing.T) {\n\t\tcluster, err := b.buildPolicyCluster(ctx, &config.Options{\n\t\t\tEnvoyBindConfigFreebind: null.BoolFrom(true),\n\t\t}, &config.Policy{\n\t\t\tFrom: \"https://from.example.com\",\n\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"freebind\": true,\n\t\t\t\t\"sourceAddress\": {\n\t\t\t\t\t\"address\": \"0.0.0.0\",\n\t\t\t\t\t\"portValue\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster.UpstreamBindConfig)\n\t})\n\tt.Run(\"source address\", func(t *testing.T) {\n\t\tcluster, err := b.buildPolicyCluster(ctx, &config.Options{\n\t\t\tEnvoyBindConfigSourceAddress: \"192.168.0.1\",\n\t\t}, &config.Policy{\n\t\t\tFrom: \"https://from.example.com\",\n\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t{\n\t\t\t\t\"sourceAddress\": {\n\t\t\t\t\t\"address\": \"192.168.0.1\",\n\t\t\t\t\t\"portValue\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t`, cluster.UpstreamBindConfig)\n\t})\n}\n\nfunc mustParseWeightedURLs(t *testing.T, urls ...string) []config.WeightedURL {\n\twu, err := config.ParseWeightedUrls(urls...)\n\trequire.NoError(t, err)\n\treturn wu\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"sort\"\n\t\"time\"\n\n\tenvoy_config_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_config_listener_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_extensions_filters_http_ext_authz_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ext_authz/v3\"\n\tenvoy_extensions_filters_http_lua_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/lua/v3\"\n\tenvoy_extensions_filters_listener_proxy_protocol_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/proxy_protocol/v3\"\n\tenvoy_http_connection_manager \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3\"\n\tenvoy_extensions_transport_sockets_tls_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3\"\n\tenvoy_type_v3 \"github.com/envoyproxy/go-control-plane/envoy/type/v3\"\n\t\"github.com/golang/protobuf/ptypes/any\"\n\t\"github.com/golang/protobuf/ptypes/wrappers\"\n\t\"github.com/scylladb/go-set\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/hashutil\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n\t\"github.com/pomerium/pomerium/pkg/cryptutil\"\n)\n\nconst listenerBufferLimit uint32 = 32 * 1024\n\nvar (\n\tdisableExtAuthz *any.Any\n\ttlsParams       = &envoy_extensions_transport_sockets_tls_v3.TlsParameters{\n\t\tCipherSuites: []string{\n\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\",\n\t\t},\n\t\tTlsMinimumProtocolVersion: envoy_extensions_transport_sockets_tls_v3.TlsParameters_TLSv1_2,\n\t}\n)\n\nfunc init() {\n\tdisableExtAuthz = marshalAny(&envoy_extensions_filters_http_ext_authz_v3.ExtAuthzPerRoute{\n\t\tOverride: &envoy_extensions_filters_http_ext_authz_v3.ExtAuthzPerRoute_Disabled{\n\t\t\tDisabled: true,\n\t\t},\n\t})\n}\n\n// BuildListeners builds envoy listeners from the given config.\nfunc (b *Builder) BuildListeners(ctx context.Context, cfg *config.Config) ([]*envoy_config_listener_v3.Listener, error) {\n\tvar listeners []*envoy_config_listener_v3.Listener\n\n\tif config.IsAuthenticate(cfg.Options.Services) || config.IsProxy(cfg.Options.Services) {\n\t\tli, err := b.buildMainListener(ctx, cfg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, li)\n\t}\n\n\tif config.IsAuthorize(cfg.Options.Services) || config.IsDataBroker(cfg.Options.Services) {\n\t\tli, err := b.buildGRPCListener(ctx, cfg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, li)\n\t}\n\n\tif cfg.Options.MetricsAddr != \"\" {\n\t\tli, err := b.buildMetricsListener(cfg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, li)\n\t}\n\n\tli, err := b.buildOutboundListener(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlisteners = append(listeners, li)\n\n\treturn listeners, nil\n}\n\nfunc (b *Builder) buildMainListener(ctx context.Context, cfg *config.Config) (*envoy_config_listener_v3.Listener, error) {\n\tlistenerFilters := []*envoy_config_listener_v3.ListenerFilter{}\n\tif cfg.Options.UseProxyProtocol {\n\t\tproxyCfg := marshalAny(&envoy_extensions_filters_listener_proxy_protocol_v3.ProxyProtocol{})\n\t\tlistenerFilters = append(listenerFilters, &envoy_config_listener_v3.ListenerFilter{\n\t\t\tName: \"envoy.filters.listener.proxy_protocol\",\n\t\t\tConfigType: &envoy_config_listener_v3.ListenerFilter_TypedConfig{\n\t\t\t\tTypedConfig: proxyCfg,\n\t\t\t},\n\t\t})\n\t}\n\n\tif cfg.Options.InsecureServer {\n\t\tallDomains, err := getAllRouteableDomains(cfg.Options, cfg.Options.Addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfilter, err := b.buildMainHTTPConnectionManagerFilter(cfg.Options, allDomains, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tli := newEnvoyListener(\"http-ingress\")\n\t\tli.Address = buildAddress(cfg.Options.Addr, 80)\n\t\tli.ListenerFilters = listenerFilters\n\t\tli.FilterChains = []*envoy_config_listener_v3.FilterChain{{\n\t\t\tFilters: []*envoy_config_listener_v3.Filter{\n\t\t\t\tfilter,\n\t\t\t},\n\t\t}}\n\t\treturn li, nil\n\t}\n\n\ttlsInspectorCfg := marshalAny(new(emptypb.Empty))\n\tlistenerFilters = append(listenerFilters, &envoy_config_listener_v3.ListenerFilter{\n\t\tName: \"envoy.filters.listener.tls_inspector\",\n\t\tConfigType: &envoy_config_listener_v3.ListenerFilter_TypedConfig{\n\t\t\tTypedConfig: tlsInspectorCfg,\n\t\t},\n\t})\n\n\tchains, err := b.buildFilterChains(cfg.Options, cfg.Options.Addr,\n\t\tfunc(tlsDomain string, httpDomains []string) (*envoy_config_listener_v3.FilterChain, error) {\n\t\t\tfilter, err := b.buildMainHTTPConnectionManagerFilter(cfg.Options, httpDomains, tlsDomain)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfilterChain := &envoy_config_listener_v3.FilterChain{\n\t\t\t\tFilters: []*envoy_config_listener_v3.Filter{filter},\n\t\t\t}\n\t\t\tif tlsDomain != \"*\" {\n\t\t\t\tfilterChain.FilterChainMatch = &envoy_config_listener_v3.FilterChainMatch{\n\t\t\t\t\tServerNames: []string{tlsDomain},\n\t\t\t\t}\n\t\t\t}\n\t\t\ttlsContext := b.buildDownstreamTLSContext(ctx, cfg, tlsDomain)\n\t\t\tif tlsContext != nil {\n\t\t\t\ttlsConfig := marshalAny(tlsContext)\n\t\t\t\tfilterChain.TransportSocket = &envoy_config_core_v3.TransportSocket{\n\t\t\t\t\tName: \"tls\",\n\t\t\t\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\t\t\t\tTypedConfig: tlsConfig,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filterChain, nil\n\t\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tli := newEnvoyListener(\"https-ingress\")\n\tli.Address = buildAddress(cfg.Options.Addr, 443)\n\tli.ListenerFilters = listenerFilters\n\tli.FilterChains = chains\n\treturn li, nil\n}\n\nfunc (b *Builder) buildMetricsListener(cfg *config.Config) (*envoy_config_listener_v3.Listener, error) {\n\tfilter, err := b.buildMetricsHTTPConnectionManagerFilter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilterChain := &envoy_config_listener_v3.FilterChain{\n\t\tFilters: []*envoy_config_listener_v3.Filter{\n\t\t\tfilter,\n\t\t},\n\t}\n\n\tcert, err := cfg.Options.GetMetricsCertificate()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif cert != nil {\n\t\tdtc := &envoy_extensions_transport_sockets_tls_v3.DownstreamTlsContext{\n\t\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\t\tTlsParams: tlsParams,\n\t\t\t\tTlsCertificates: []*envoy_extensions_transport_sockets_tls_v3.TlsCertificate{\n\t\t\t\t\tb.envoyTLSCertificateFromGoTLSCertificate(context.TODO(), cert),\n\t\t\t\t},\n\t\t\t\tAlpnProtocols: []string{\"h2\", \"http/1.1\"},\n\t\t\t},\n\t\t}\n\n\t\tif cfg.Options.MetricsClientCA != \"\" {\n\t\t\tbs, err := base64.StdEncoding.DecodeString(cfg.Options.MetricsClientCA)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"xds: invalid metrics_client_ca: %w\", err)\n\t\t\t}\n\n\t\t\tdtc.RequireClientCertificate = wrapperspb.Bool(true)\n\t\t\tdtc.CommonTlsContext.ValidationContextType = &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\t\t\t\tTrustChainVerification: envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_VERIFY_TRUST_CHAIN,\n\t\t\t\t\tTrustedCa:              b.filemgr.BytesDataSource(\"metrics_client_ca.pem\", bs),\n\t\t\t\t},\n\t\t\t}\n\t\t} else if cfg.Options.MetricsClientCAFile != \"\" {\n\t\t\tdtc.RequireClientCertificate = wrapperspb.Bool(true)\n\t\t\tdtc.CommonTlsContext.ValidationContextType = &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\t\t\tValidationContext: &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\t\t\t\tTrustChainVerification: envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_VERIFY_TRUST_CHAIN,\n\t\t\t\t\tTrustedCa:              b.filemgr.FileDataSource(cfg.Options.MetricsClientCAFile),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\ttc := marshalAny(dtc)\n\t\tfilterChain.TransportSocket = &envoy_config_core_v3.TransportSocket{\n\t\t\tName: \"tls\",\n\t\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\t\tTypedConfig: tc,\n\t\t\t},\n\t\t}\n\t}\n\n\t// we ignore the host part of the address, only binding to\n\thost, port, err := net.SplitHostPort(cfg.Options.MetricsAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"metrics_addr %s: %w\", cfg.Options.MetricsAddr, err)\n\t}\n\tif port == \"\" {\n\t\treturn nil, fmt.Errorf(\"metrics_addr %s: port is required\", cfg.Options.MetricsAddr)\n\t}\n\t// unless an explicit IP address was provided, and bind to all interfaces if hostname was provided\n\tif net.ParseIP(host) == nil {\n\t\thost = \"\"\n\t}\n\n\taddr := buildAddress(fmt.Sprintf(\"%s:%s\", host, port), 9902)\n\tli := newEnvoyListener(fmt.Sprintf(\"metrics-ingress-%d\", hashutil.MustHash(addr)))\n\tli.Address = addr\n\tli.FilterChains = []*envoy_config_listener_v3.FilterChain{filterChain}\n\treturn li, nil\n}\n\nfunc (b *Builder) buildFilterChains(\n\toptions *config.Options, addr string,\n\tcallback func(tlsDomain string, httpDomains []string) (*envoy_config_listener_v3.FilterChain, error),\n) ([]*envoy_config_listener_v3.FilterChain, error) {\n\tallDomains, err := getAllRouteableDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsDomains, err := getAllTLSDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar chains []*envoy_config_listener_v3.FilterChain\n\tfor _, domain := range tlsDomains {\n\t\trouteableDomains, err := getRouteableDomainsForTLSDomain(options, addr, domain)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// first we match on SNI\n\t\tchain, err := callback(domain, routeableDomains)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tchains = append(chains, chain)\n\t}\n\n\t// if there are no SNI matches we match on HTTP host\n\tchain, err := callback(\"*\", allDomains)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchains = append(chains, chain)\n\treturn chains, nil\n}\n\nfunc (b *Builder) buildMainHTTPConnectionManagerFilter(\n\toptions *config.Options,\n\tdomains []string,\n\ttlsDomain string,\n) (*envoy_config_listener_v3.Filter, error) {\n\tauthorizeURLs, err := options.GetInternalAuthorizeURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdataBrokerURLs, err := options.GetInternalDataBrokerURLs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar virtualHosts []*envoy_config_route_v3.VirtualHost\n\tfor _, domain := range domains {\n\t\tvh, err := b.buildVirtualHost(options, domain, domain)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif options.Addr == options.GetGRPCAddr() {\n\t\t\t// if this is a gRPC service domain and we're supposed to handle that, add those routes\n\t\t\tif (config.IsAuthorize(options.Services) && hostsMatchDomain(authorizeURLs, domain)) ||\n\t\t\t\t(config.IsDataBroker(options.Services) && hostsMatchDomain(dataBrokerURLs, domain)) {\n\t\t\t\trs, err := b.buildGRPCRoutes()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tvh.Routes = append(vh.Routes, rs...)\n\t\t\t}\n\t\t}\n\n\t\t// if we're the proxy, add all the policy routes\n\t\tif config.IsProxy(options.Services) {\n\t\t\trs, err := b.buildPolicyRoutes(options, domain)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvh.Routes = append(vh.Routes, rs...)\n\t\t}\n\n\t\tif len(vh.Routes) > 0 {\n\t\t\tvirtualHosts = append(virtualHosts, vh)\n\t\t}\n\t}\n\n\tvh, err := b.buildVirtualHost(options, \"catch-all\", \"*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvirtualHosts = append(virtualHosts, vh)\n\n\tvar grpcClientTimeout *durationpb.Duration\n\tif options.GRPCClientTimeout != 0 {\n\t\tgrpcClientTimeout = durationpb.New(options.GRPCClientTimeout)\n\t} else {\n\t\tgrpcClientTimeout = durationpb.New(30 * time.Second)\n\t}\n\n\textAuthZ := marshalAny(&envoy_extensions_filters_http_ext_authz_v3.ExtAuthz{\n\t\tStatusOnError: &envoy_type_v3.HttpStatus{\n\t\t\tCode: envoy_type_v3.StatusCode_InternalServerError,\n\t\t},\n\t\tServices: &envoy_extensions_filters_http_ext_authz_v3.ExtAuthz_GrpcService{\n\t\t\tGrpcService: &envoy_config_core_v3.GrpcService{\n\t\t\t\tTimeout: grpcClientTimeout,\n\t\t\t\tTargetSpecifier: &envoy_config_core_v3.GrpcService_EnvoyGrpc_{\n\t\t\t\t\tEnvoyGrpc: &envoy_config_core_v3.GrpcService_EnvoyGrpc{\n\t\t\t\t\t\tClusterName: \"pomerium-authorize\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tIncludePeerCertificate: true,\n\t\tTransportApiVersion:    envoy_config_core_v3.ApiVersion_V3,\n\t})\n\n\textAuthzSetCookieLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.ExtAuthzSetCookie,\n\t})\n\tcleanUpstreamLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.CleanUpstream,\n\t})\n\tremoveImpersonateHeadersLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.RemoveImpersonateHeaders,\n\t})\n\trewriteHeadersLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\tInlineCode: luascripts.RewriteHeaders,\n\t})\n\n\tfilters := []*envoy_http_connection_manager.HttpFilter{\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: removeImpersonateHeadersLua,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.ext_authz\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: extAuthZ,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: extAuthzSetCookieLua,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: cleanUpstreamLua,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: rewriteHeadersLua,\n\t\t\t},\n\t\t},\n\t}\n\tif tlsDomain != \"\" && tlsDomain != \"*\" {\n\t\tfixMisdirectedLua := marshalAny(&envoy_extensions_filters_http_lua_v3.Lua{\n\t\t\tInlineCode: fmt.Sprintf(luascripts.FixMisdirected, tlsDomain),\n\t\t})\n\t\tfilters = append(filters, &envoy_http_connection_manager.HttpFilter{\n\t\t\tName: \"envoy.filters.http.lua\",\n\t\t\tConfigType: &envoy_http_connection_manager.HttpFilter_TypedConfig{\n\t\t\t\tTypedConfig: fixMisdirectedLua,\n\t\t\t},\n\t\t})\n\t}\n\tfilters = append(filters, &envoy_http_connection_manager.HttpFilter{\n\t\tName: \"envoy.filters.http.router\",\n\t})\n\n\tvar maxStreamDuration *durationpb.Duration\n\tif options.WriteTimeout > 0 {\n\t\tmaxStreamDuration = durationpb.New(options.WriteTimeout)\n\t}\n\n\trc, err := b.buildRouteConfiguration(\"main\", virtualHosts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttracingProvider, err := buildTracingHTTP(options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttc := marshalAny(&envoy_http_connection_manager.HttpConnectionManager{\n\t\tCodecType:  options.GetCodecType().ToEnvoy(),\n\t\tStatPrefix: \"ingress\",\n\t\tRouteSpecifier: &envoy_http_connection_manager.HttpConnectionManager_RouteConfig{\n\t\t\tRouteConfig: rc,\n\t\t},\n\t\tHttpFilters: filters,\n\t\tAccessLog:   buildAccessLogs(options),\n\t\tCommonHttpProtocolOptions: &envoy_config_core_v3.HttpProtocolOptions{\n\t\t\tIdleTimeout:       durationpb.New(options.IdleTimeout),\n\t\t\tMaxStreamDuration: maxStreamDuration,\n\t\t},\n\t\tRequestTimeout: durationpb.New(options.ReadTimeout),\n\t\tTracing: &envoy_http_connection_manager.HttpConnectionManager_Tracing{\n\t\t\tRandomSampling: &envoy_type_v3.Percent{Value: options.TracingSampleRate * 100},\n\t\t\tProvider:       tracingProvider,\n\t\t},\n\t\t// See https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#x-forwarded-for\n\t\tUseRemoteAddress:  &wrappers.BoolValue{Value: true},\n\t\tSkipXffAppend:     options.SkipXffAppend,\n\t\tXffNumTrustedHops: options.XffNumTrustedHops,\n\t\tLocalReplyConfig:  b.buildLocalReplyConfig(options),\n\t})\n\n\treturn &envoy_config_listener_v3.Filter{\n\t\tName: \"envoy.filters.network.http_connection_manager\",\n\t\tConfigType: &envoy_config_listener_v3.Filter_TypedConfig{\n\t\t\tTypedConfig: tc,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildMetricsHTTPConnectionManagerFilter() (*envoy_config_listener_v3.Filter, error) {\n\trc, err := b.buildRouteConfiguration(\"metrics\", []*envoy_config_route_v3.VirtualHost{{\n\t\tName:    \"metrics\",\n\t\tDomains: []string{\"*\"},\n\t\tRoutes: []*envoy_config_route_v3.Route{{\n\t\t\tName: \"metrics\",\n\t\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: \"/\"},\n\t\t\t},\n\t\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\t\tCluster: \"pomerium-control-plane-metrics\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttc := marshalAny(&envoy_http_connection_manager.HttpConnectionManager{\n\t\tCodecType:  envoy_http_connection_manager.HttpConnectionManager_AUTO,\n\t\tStatPrefix: \"metrics\",\n\t\tRouteSpecifier: &envoy_http_connection_manager.HttpConnectionManager_RouteConfig{\n\t\t\tRouteConfig: rc,\n\t\t},\n\t\tHttpFilters: []*envoy_http_connection_manager.HttpFilter{{\n\t\t\tName: \"envoy.filters.http.router\",\n\t\t}},\n\t})\n\n\treturn &envoy_config_listener_v3.Filter{\n\t\tName: \"envoy.filters.network.http_connection_manager\",\n\t\tConfigType: &envoy_config_listener_v3.Filter_TypedConfig{\n\t\t\tTypedConfig: tc,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildGRPCListener(ctx context.Context, cfg *config.Config) (*envoy_config_listener_v3.Listener, error) {\n\tfilter, err := b.buildGRPCHTTPConnectionManagerFilter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Options.GetGRPCInsecure() {\n\t\tli := newEnvoyListener(\"grpc-ingress\")\n\t\tli.Address = buildAddress(cfg.Options.GetGRPCAddr(), 80)\n\t\tli.FilterChains = []*envoy_config_listener_v3.FilterChain{{\n\t\t\tFilters: []*envoy_config_listener_v3.Filter{\n\t\t\t\tfilter,\n\t\t\t},\n\t\t}}\n\t\treturn li, nil\n\t}\n\n\tchains, err := b.buildFilterChains(cfg.Options, cfg.Options.GRPCAddr,\n\t\tfunc(tlsDomain string, httpDomains []string) (*envoy_config_listener_v3.FilterChain, error) {\n\t\t\tfilterChain := &envoy_config_listener_v3.FilterChain{\n\t\t\t\tFilters: []*envoy_config_listener_v3.Filter{filter},\n\t\t\t}\n\t\t\tif tlsDomain != \"*\" {\n\t\t\t\tfilterChain.FilterChainMatch = &envoy_config_listener_v3.FilterChainMatch{\n\t\t\t\t\tServerNames: []string{tlsDomain},\n\t\t\t\t}\n\t\t\t}\n\t\t\ttlsContext := b.buildDownstreamTLSContext(ctx, cfg, tlsDomain)\n\t\t\tif tlsContext != nil {\n\t\t\t\ttlsConfig := marshalAny(tlsContext)\n\t\t\t\tfilterChain.TransportSocket = &envoy_config_core_v3.TransportSocket{\n\t\t\t\t\tName: \"tls\",\n\t\t\t\t\tConfigType: &envoy_config_core_v3.TransportSocket_TypedConfig{\n\t\t\t\t\t\tTypedConfig: tlsConfig,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filterChain, nil\n\t\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsInspectorCfg := marshalAny(new(emptypb.Empty))\n\tli := newEnvoyListener(\"grpc-ingress\")\n\tli.Address = buildAddress(cfg.Options.GetGRPCAddr(), 443)\n\tli.ListenerFilters = []*envoy_config_listener_v3.ListenerFilter{{\n\t\tName: \"envoy.filters.listener.tls_inspector\",\n\t\tConfigType: &envoy_config_listener_v3.ListenerFilter_TypedConfig{\n\t\t\tTypedConfig: tlsInspectorCfg,\n\t\t},\n\t}}\n\tli.FilterChains = chains\n\treturn li, nil\n}\n\nfunc (b *Builder) buildGRPCHTTPConnectionManagerFilter() (*envoy_config_listener_v3.Filter, error) {\n\trc, err := b.buildRouteConfiguration(\"grpc\", []*envoy_config_route_v3.VirtualHost{{\n\t\tName:    \"grpc\",\n\t\tDomains: []string{\"*\"},\n\t\tRoutes: []*envoy_config_route_v3.Route{{\n\t\t\tName: \"grpc\",\n\t\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: \"/\"},\n\t\t\t\tGrpc:          &envoy_config_route_v3.RouteMatch_GrpcRouteMatchOptions{},\n\t\t\t},\n\t\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\t\tCluster: \"pomerium-control-plane-grpc\",\n\t\t\t\t\t},\n\t\t\t\t\t// disable the timeout to support grpc streaming\n\t\t\t\t\tTimeout: &durationpb.Duration{\n\t\t\t\t\t\tSeconds: 0,\n\t\t\t\t\t},\n\t\t\t\t\tIdleTimeout: &durationpb.Duration{\n\t\t\t\t\t\tSeconds: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttc := marshalAny(&envoy_http_connection_manager.HttpConnectionManager{\n\t\tCodecType:  envoy_http_connection_manager.HttpConnectionManager_AUTO,\n\t\tStatPrefix: \"grpc_ingress\",\n\t\t// limit request first byte to last byte time\n\t\tRequestTimeout: &durationpb.Duration{\n\t\t\tSeconds: 15,\n\t\t},\n\t\tRouteSpecifier: &envoy_http_connection_manager.HttpConnectionManager_RouteConfig{\n\t\t\tRouteConfig: rc,\n\t\t},\n\t\tHttpFilters: []*envoy_http_connection_manager.HttpFilter{{\n\t\t\tName: \"envoy.filters.http.router\",\n\t\t}},\n\t})\n\treturn &envoy_config_listener_v3.Filter{\n\t\tName: \"envoy.filters.network.http_connection_manager\",\n\t\tConfigType: &envoy_config_listener_v3.Filter_TypedConfig{\n\t\t\tTypedConfig: tc,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildRouteConfiguration(name string, virtualHosts []*envoy_config_route_v3.VirtualHost) (*envoy_config_route_v3.RouteConfiguration, error) {\n\treturn &envoy_config_route_v3.RouteConfiguration{\n\t\tName:         name,\n\t\tVirtualHosts: virtualHosts,\n\t\t// disable cluster validation since the order of LDS/CDS updates isn't guaranteed\n\t\tValidateClusters: &wrappers.BoolValue{Value: false},\n\t}, nil\n}\n\nfunc (b *Builder) buildDownstreamTLSContext(ctx context.Context,\n\tcfg *config.Config,\n\tdomain string,\n) *envoy_extensions_transport_sockets_tls_v3.DownstreamTlsContext {\n\tcerts, err := cfg.AllCertificates()\n\tif err != nil {\n\t\tlog.Warn(ctx).Str(\"domain\", domain).Err(err).Msg(\"failed to get all certificates from config\")\n\t\treturn nil\n\t}\n\n\tcert, err := cryptutil.GetCertificateForDomain(certs, domain)\n\tif err != nil {\n\t\tlog.Warn(ctx).Str(\"domain\", domain).Err(err).Msg(\"failed to get certificate for domain\")\n\t\treturn nil\n\t}\n\n\terr = validateCertificate(cert)\n\tif err != nil {\n\t\tlog.Warn(ctx).Str(\"domain\", domain).Err(err).Msg(\"invalid certificate for domain\")\n\t\treturn nil\n\t}\n\n\tvar alpnProtocols []string\n\tswitch cfg.Options.GetCodecType() {\n\tcase config.CodecTypeHTTP1:\n\t\talpnProtocols = []string{\"http/1.1\"}\n\tcase config.CodecTypeHTTP2:\n\t\talpnProtocols = []string{\"h2\"}\n\tdefault:\n\t\talpnProtocols = []string{\"h2\", \"http/1.1\"}\n\t}\n\n\tenvoyCert := b.envoyTLSCertificateFromGoTLSCertificate(ctx, cert)\n\treturn &envoy_extensions_transport_sockets_tls_v3.DownstreamTlsContext{\n\t\tCommonTlsContext: &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext{\n\t\t\tTlsParams:             tlsParams,\n\t\t\tTlsCertificates:       []*envoy_extensions_transport_sockets_tls_v3.TlsCertificate{envoyCert},\n\t\t\tAlpnProtocols:         alpnProtocols,\n\t\t\tValidationContextType: b.buildDownstreamValidationContext(ctx, cfg, domain),\n\t\t},\n\t}\n}\n\nfunc (b *Builder) buildDownstreamValidationContext(ctx context.Context,\n\tcfg *config.Config,\n\tdomain string,\n) *envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext {\n\tneedsClientCert := false\n\n\tif ca, _ := cfg.Options.GetClientCA(); len(ca) > 0 {\n\t\tneedsClientCert = true\n\t}\n\tif !needsClientCert {\n\t\tfor _, p := range getPoliciesForDomain(cfg.Options, domain) {\n\t\t\tif p.TLSDownstreamClientCA != \"\" {\n\t\t\t\tneedsClientCert = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !needsClientCert {\n\t\treturn nil\n\t}\n\n\t// trusted_ca is left blank because we verify the client certificate in the authorize service\n\tvc := &envoy_extensions_transport_sockets_tls_v3.CommonTlsContext_ValidationContext{\n\t\tValidationContext: &envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext{\n\t\t\tTrustChainVerification: envoy_extensions_transport_sockets_tls_v3.CertificateValidationContext_ACCEPT_UNTRUSTED,\n\t\t},\n\t}\n\n\tif cfg.Options.ClientCRL != \"\" {\n\t\tbs, err := base64.StdEncoding.DecodeString(cfg.Options.ClientCRL)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"invalid client CRL\")\n\t\t} else {\n\t\t\tvc.ValidationContext.Crl = b.filemgr.BytesDataSource(\"client-crl.pem\", bs)\n\t\t}\n\t} else if cfg.Options.ClientCRLFile != \"\" {\n\t\tvc.ValidationContext.Crl = b.filemgr.FileDataSource(cfg.Options.ClientCRLFile)\n\t}\n\n\treturn vc\n}\n\nfunc getRouteableDomainsForTLSDomain(options *config.Options, addr string, tlsDomain string) ([]string, error) {\n\tallDomains, err := getAllRouteableDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar filtered []string\n\tfor _, domain := range allDomains {\n\t\tif urlutil.StripPort(domain) == tlsDomain {\n\t\t\tfiltered = append(filtered, domain)\n\t\t}\n\t}\n\treturn filtered, nil\n}\n\nfunc getAllRouteableDomains(options *config.Options, addr string) ([]string, error) {\n\tallDomains := set.NewStringSet()\n\n\tif addr == options.Addr {\n\t\tdomains, err := options.GetAllRouteableHTTPDomains()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tallDomains.Add(domains...)\n\t}\n\n\tif addr == options.GetGRPCAddr() {\n\t\tdomains, err := options.GetAllRouteableGRPCDomains()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tallDomains.Add(domains...)\n\t}\n\n\tdomains := allDomains.List()\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\nfunc getAllTLSDomains(options *config.Options, addr string) ([]string, error) {\n\tallDomains, err := getAllRouteableDomains(options, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlookup := map[string]struct{}{}\n\tfor _, hp := range allDomains {\n\t\tif d, _, err := net.SplitHostPort(hp); err == nil {\n\t\t\tlookup[d] = struct{}{}\n\t\t} else {\n\t\t\tlookup[hp] = struct{}{}\n\t\t}\n\t}\n\n\tdomains := make([]string, 0, len(lookup))\n\tfor domain := range lookup {\n\t\tdomains = append(domains, domain)\n\t}\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\nfunc hostsMatchDomain(urls []*url.URL, host string) bool {\n\tfor _, u := range urls {\n\t\tif hostMatchesDomain(u, host) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc hostMatchesDomain(u *url.URL, host string) bool {\n\tif u == nil {\n\t\treturn false\n\t}\n\n\tvar defaultPort string\n\tif u.Scheme == \"http\" {\n\t\tdefaultPort = \"80\"\n\t} else {\n\t\tdefaultPort = \"443\"\n\t}\n\n\th1, p1, err := net.SplitHostPort(u.Host)\n\tif err != nil {\n\t\th1 = u.Host\n\t\tp1 = defaultPort\n\t}\n\n\th2, p2, err := net.SplitHostPort(host)\n\tif err != nil {\n\t\th2 = host\n\t\tp2 = defaultPort\n\t}\n\n\treturn h1 == h2 && p1 == p2\n}\n\nfunc getPoliciesForDomain(options *config.Options, domain string) []config.Policy {\n\tvar policies []config.Policy\n\tfor _, p := range options.GetAllPolicies() {\n\t\tif p.Source != nil && p.Source.URL.Hostname() == domain {\n\t\t\tpolicies = append(policies, p)\n\t\t}\n\t}\n\treturn policies\n}\n\n// newEnvoyListener creates envoy listener with certain default values\nfunc newEnvoyListener(name string) *envoy_config_listener_v3.Listener {\n\treturn &envoy_config_listener_v3.Listener{\n\t\tName:                          name,\n\t\tPerConnectionBufferLimitBytes: wrapperspb.UInt32(listenerBufferLimit),\n\t}\n}\n", "package envoyconfig\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n)\n\nconst (\n\taExampleComCert = `LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVQVENDQXFXZ0F3SUJBZ0lSQUlWMDhHSVFYTWRVT0NXV3FocXlGR3N3RFFZSktvWklodmNOQVFFTEJRQXcKY3pFZU1Cd0dBMVVFQ2hNVmJXdGpaWEowSUdSbGRtVnNiM0J0Wlc1MElFTkJNU1F3SWdZRFZRUUxEQnRqWVd4bApZa0J3YjNBdGIzTWdLRU5oYkdWaUlFUnZlSE5sZVNreEt6QXBCZ05WQkFNTUltMXJZMlZ5ZENCallXeGxZa0J3CmIzQXRiM01nS0VOaGJHVmlJRVJ2ZUhObGVTa3dIaGNOTVRrd05qQXhNREF3TURBd1doY05NekF3TlRJeU1qRXoKT0RRMFdqQlBNU2N3SlFZRFZRUUtFeDV0YTJObGNuUWdaR1YyWld4dmNHMWxiblFnWTJWeWRHbG1hV05oZEdVeApKREFpQmdOVkJBc01HMk5oYkdWaVFIQnZjQzF2Y3lBb1EyRnNaV0lnUkc5NGMyVjVLVENDQVNJd0RRWUpLb1pJCmh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTm1HMWFKaXc0L29SMHFqUDMxUjRXeTZkOUVqZHc5K1kyelQKcjBDbGNYTDYxRk11R0YrKzJRclV6Y0VUZlZ2dGM1OXNQa0xkRHNtZ0Y2VlZCOTkyQ3ArWDlicWczWmQwSXZtbApVbjJvdTM5eUNEYnV2Q0E2d1gwbGNHL2JkRDE3TkRrS0poL3g5SDMzU3h4SG5UamlKdFBhbmt1MUI3ajdtRmM5Ck5jNXRyamFvUHBGaFJqMTJ1L0dWajRhWWs3SStpWHRpZHBjZXp2eWNDT0NtQlIwNHkzeWx5Q2sxSWNMTUhWOEEKNXphUFpVck15ZUtnTE1PTGlDSDBPeHhhUzh0Nk5vTjZudDdmOUp1TUxTN2V5SkxkQW05bGg0c092YXBPVklXZgpJQitaYnk5bkQ1dWl4N3V0a3llWTFOeE05SFZhUmZTQzcrejM4TDBWN3lJZlpCNkFLcWNDQXdFQUFhTndNRzR3CkRnWURWUjBQQVFIL0JBUURBZ1dnTUJNR0ExVWRKUVFNTUFvR0NDc0dBUVVGQndNQk1Bd0dBMVVkRXdFQi93UUMKTUFBd0h3WURWUjBqQkJnd0ZvQVVTaG9mWE5rY1hoMnE0d25uV1oyYmNvMjRYRVF3R0FZRFZSMFJCQkV3RDRJTgpZUzVsZUdGdGNHeGxMbU52YlRBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVlFQVA3aHVraThGeG54azRoVnJYUk93Ck51Uy9OUFhmQ3VaVDZWemJYUVUxbWNrZmhweVNDajVRZkFDQzdodVp6Qkp0NEtsUHViWHdRQ25YMFRMSmg1L0cKUzZBWEFXQ3VTSW5jTTZxNGs4MFAzVllWK3hXOS9rdERnTk1FTlNxSjdKR3lqdzBWWHlhOUZwdWd6Q3ZnN290RQo5STcrZTN0cmJnUDBHY3plSml6WTJBMVBWU082MVdKQ1lNQjNDLzcwVE9KMkZTNy82bURPTG9DSVJCY215cW5KClY2Vk5sRDl3Y2xmUWIrZUp0YlY0Vlg2RUY5UEYybUtncUNKT0FKLzBoMHAydTBhZGgzMkJDS2dIMDRSYUtuSS8KUzY1N0MrN1YzVEgzQ1VIVHgrdDRRRll4UEhRL0loQ3pYdUpVeFQzYWtYNEQ1czJkTHp2RnBJMFIzTVBwUE9VQQpUelpSdDI2T3FVNHlUdUFnb0kvZnZMdk55VTNZekF3ZUQ2Mndxc1hiVHAranNFcWpoODUvakpXWnA4RExKK0w3CmhXQW0rSVNKTzhrNWgwR0lIMFllb01heXBJbjRubWVsbHNSM1dvYzZRVTZ4cFFTd3V1NXE0ckJzOUxDWS9kZkwKNkEzMEhlYXVVK2sydGFUVlBMY2FCZm11NDJPaHMyYzQ0bzNPYnlvVkNDNi8KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=`\n\taExampleComKey  = `LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2Z0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktnd2dnU2tBZ0VBQW9JQkFRRFpodFdpWXNPUDZFZEsKb3o5OVVlRnN1bmZSSTNjUGZtTnMwNjlBcFhGeSt0UlRMaGhmdnRrSzFNM0JFMzFiN1hPZmJENUMzUTdKb0JlbApWUWZmZGdxZmwvVzZvTjJYZENMNXBWSjlxTHQvY2dnMjdyd2dPc0Y5SlhCdjIzUTllelE1Q2lZZjhmUjk5MHNjClI1MDQ0aWJUMnA1THRRZTQrNWhYUFRYT2JhNDJxRDZSWVVZOWRydnhsWStHbUpPeVBvbDdZbmFYSHM3OG5BamcKcGdVZE9NdDhwY2dwTlNIQ3pCMWZBT2MyajJWS3pNbmlvQ3pEaTRnaDlEc2NXa3ZMZWphRGVwN2UzL1NiakMwdQozc2lTM1FKdlpZZUxEcjJxVGxTRm55QWZtVzh2WncrYm9zZTdyWk1ubU5UY1RQUjFXa1gwZ3UvczkvQzlGZThpCkgyUWVnQ3FuQWdNQkFBRUNnZ0VCQUsrclFrLzNyck5EQkgvMFFrdTBtbll5U0p6dkpUR3dBaDlhL01jYVZQcGsKTXFCU000RHZJVnlyNnRZb0pTN2VIbWY3QkhUL0RQZ3JmNjBYZEZvMGUvUFN4ckhIUSswUjcwVHBEQ3RLM3REWAppR2JFZWMwVlpqam95VnFzUWIxOUIvbWdocFY1MHRiL3BQcmJvczdUWkVQbTQ3dUVJUTUwc055VEpDYm5VSy8xCnhla2ZmZ3hMbmZlRUxoaXhDNE1XYjMzWG9GNU5VdWduQ2pUakthUFNNUmpISm9YSFlGWjdZdEdlSEd1aDR2UGwKOU5TM0YxT2l0MWNnQzNCSm1BM28yZmhYbTRGR1FhQzNjYUdXTzE5eHAwRWE1eXQ0RHZOTWp5WlgvSkx1Qko0NQpsZU5jUSs3c3U0dW0vY0hqcFFVenlvZmoydFBIU085QXczWGY0L2lmN0hFQ2dZRUE1SWMzMzVKUUhJVlQwc003CnhkY3haYmppbUE5alBWMDFXSXh0di8zbzFJWm5TUGFocEFuYXVwZGZqRkhKZmJTYlZXaUJTaUZpb2RTR3pIdDgKTlZNTGFyVzVreDl5N1luYXdnZjJuQjc2VG03aFl6L3h5T3AxNXFRbmswVW9DdnQ2MHp6dDl5UE5KQ1pWalFwNgp4cUw4T1c4emNlUGpxZzJBTHRtcVhpNitZRXNDZ1lFQTg2ME5zSHMzNktFZE91Q1o1TXF6NVRLSmVYSzQ5ZkdBCjdxcjM5Sm9RcWYzbEhSSWozUlFlNERkWmQ5NUFXcFRKUEJXdnp6NVROOWdwNHVnb3VGc0tCaG82YWtsUEZTUFIKRkZwWCtGZE56eHJGTlAwZHhydmN0bXU2OW91MFR0QU1jd1hYWFJuR1BuK0xDTnVUUHZndHZTTnRwSEZMb0dzUQorVDFpTjhpWS9aVUNnWUJpMVJQVjdkb1ZxNWVuNCtWYTE0azJlL0lMWDBSRkNxV0NpU0VCMGxhNmF2SUtQUmVFCjhQb1dqbGExUWIzSlRxMkxEMm95M0NOaTU1M3dtMHNKYU1QY1A0RmxYa2wrNzRxYk5ZUnkybmJZS3QzdzVYdTAKcjZtVHVOU2d2VnptK3dHUWo1NCtyczRPWDBIS2dJaStsVWhOc29qbUxXK05ZTTlaODZyWmxvK2c1d0tCZ0VMQQplRXlOSko2c2JCWng2cFo3Vk5hSGhwTm5jdldreDc0WnhiMFM2MWUxL3FwOUNxZ0lXQUR5Q0tkR2tmaCtZN1g2Cjl1TmQzbXdnNGpDUGlvQWVLRnZObVl6K01oVEhjQUlVVVo3dFE1cGxhZnAvRUVZZHRuT2VoV1ArbDFFenV3VlQKWjFEUXU3YnBONHdnb25DUWllOFRJbmoydEZIb29vaTBZUkNJK2lnVkFvR0JBSUxaOXd4WDlnMmVNYU9xUFk1dgo5RGxxNFVEZlpaYkprNFZPbmhjR0pWQUNXbmlpNTU0Y1RCSEkxUTdBT0ZQOHRqK3d3YWJBOWRMaUpDdzJzd0E2ClQrdnhiK1NySGxEUnFON3NNRUQ1Z091REo0eHJxRVdLZ3ZkSEsvME9EMC9ZMUFvSCt2aDlJMHVaV0RRNnNLcXcKeFcrbDk0UTZXSW1xYnpDODZsa3JXa0lCCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K`\n)\n\nfunc Test_buildMetricsHTTPConnectionManagerFilter(t *testing.T) {\n\tcacheDir, _ := os.UserCacheDir()\n\tcertFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-crt-354e49305a5a39414a545530374e58454e48334148524c4e324258463837364355564c4e4532464b54355139495547514a38.pem\")\n\tkeyFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-key-3350415a38414e4e4a4655424e55393430474147324651433949384e485341334b5157364f424b4c5856365a545937383735.pem\")\n\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\tli, err := b.buildMetricsListener(&config.Config{\n\t\tOptions: &config.Options{\n\t\t\tMetricsAddr:           \"127.0.0.1:9902\",\n\t\t\tMetricsCertificate:    aExampleComCert,\n\t\t\tMetricsCertificateKey: aExampleComKey,\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n{\n\t\"name\": \"metrics-ingress-1566242852377945326\",\n\t\"perConnectionBufferLimitBytes\": 32768,\n\t\"address\": {\n\t\t\"socketAddress\": {\n\t\t\t\"address\": \"127.0.0.1\",\n\t\t\t\"ipv4Compat\": true,\n\t\t\t\"portValue\": 9902\n\t\t}\n\t},\n\t\"filterChains\": [{\n\t\t\"filters\": [{\n\t\t\t\"name\": \"envoy.filters.network.http_connection_manager\",\n\t\t\t\"typedConfig\": {\n\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\n\t\t\t\t\"httpFilters\": [{\n\t\t\t\t\t\"name\": \"envoy.filters.http.router\"\n\t\t\t\t}],\n\t\t\t\t\"routeConfig\": {\n\t\t\t\t\t\"name\": \"metrics\",\n\t\t\t\t\t\"validateClusters\": false,\n\t\t\t\t\t\"virtualHosts\": [{\n\t\t\t\t\t\t\"name\": \"metrics\",\n\t\t\t\t\t\t\"domains\": [\"*\"],\n\t\t\t\t\t\t\"routes\": [{\n\t\t\t\t\t\t\t\"name\": \"metrics\",\n\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-metrics\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t},\n\t\t\t\t\"statPrefix\": \"metrics\"\n\t\t\t}\n\t\t}],\n\t\t\"transportSocket\": {\n\t\t\t\"name\": \"tls\",\n\t\t\t\"typedConfig\": {\n\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\",\n\t\t\t\t\"commonTlsContext\": {\n\t\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t\t},\n\t\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]\n}`, li)\n}\n\nfunc Test_buildMainHTTPConnectionManagerFilter(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", nil, nil)\n\n\toptions := config.NewDefaultOptions()\n\toptions.SkipXffAppend = true\n\toptions.XffNumTrustedHops = 1\n\tfilter, err := b.buildMainHTTPConnectionManagerFilter(options, []string{\"example.com\"}, \"*\")\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\"name\": \"envoy.filters.network.http_connection_manager\",\n\t\t\"typedConfig\": {\n\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\n\t\t\t\"accessLog\": [{\n\t\t\t\t\"name\": \"envoy.access_loggers.http_grpc\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig\",\n\t\t\t\t\t\"commonConfig\": {\n\t\t\t\t\t\t\"grpcService\": {\n\t\t\t\t\t\t\t\"envoyGrpc\": {\n\t\t\t\t\t\t\t\t\"clusterName\": \"pomerium-control-plane-grpc\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"logName\": \"ingress-http\",\n\t\t\t\t\t\t\"transportApiVersion\": \"V3\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"codecType\": \"HTTP1\",\n\t\t\t\"commonHttpProtocolOptions\": {\n\t\t\t\t\"idleTimeout\": \"300s\"\n\t\t\t},\n\t\t\t\"httpFilters\": [\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"local function starts_with(str, start)\\n    return str:sub(1, #start) == start\\nend\\n\\nfunction envoy_on_request(request_handle)\\n    local headers = request_handle:headers()\\n    local metadata = request_handle:metadata()\\n\\n    local remove_impersonate_headers = metadata:get(\\\"remove_impersonate_headers\\\")\\n    if remove_impersonate_headers then\\n        local to_remove = {}\\n        for k, v in pairs(headers) do\\n            if starts_with(k, \\\"impersonate-extra-\\\") or k == \\\"impersonate-group\\\" or k == \\\"impersonate-user\\\" then\\n                table.insert(to_remove, k)\\n            end\\n        end\\n\\n        for k, v in pairs(to_remove) do\\n            headers:remove(v)\\n        end\\n    end\\nend\\n\\nfunction envoy_on_response(response_handle)\\nend\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.ext_authz\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\",\n\t\t\t\t\t\t\"grpcService\": {\n\t\t\t\t\t\t\t\"envoyGrpc\": {\n\t\t\t\t\t\t\t\t\"clusterName\": \"pomerium-authorize\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"timeout\": \"10s\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"includePeerCertificate\": true,\n\t\t\t\t\t\t\"statusOnError\": {\n\t\t\t\t\t\t\t\"code\": \"InternalServerError\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"transportApiVersion\": \"V3\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"function envoy_on_request(request_handle)\\n    local headers = request_handle:headers()\\n    local dynamic_meta = request_handle:streamInfo():dynamicMetadata()\\n    if headers:get(\\\"x-pomerium-set-cookie\\\") ~= nil then\\n        dynamic_meta:set(\\\"envoy.filters.http.lua\\\", \\\"pomerium_set_cookie\\\",\\n                         headers:get(\\\"x-pomerium-set-cookie\\\"))\\n        headers:remove(\\\"x-pomerium-set-cookie\\\")\\n    end\\nend\\n\\nfunction envoy_on_response(response_handle)\\n    local headers = response_handle:headers()\\n    local dynamic_meta = response_handle:streamInfo():dynamicMetadata()\\n    local tbl = dynamic_meta:get(\\\"envoy.filters.http.lua\\\")\\n    if tbl ~= nil and tbl[\\\"pomerium_set_cookie\\\"] ~= nil then\\n        headers:add(\\\"set-cookie\\\", tbl[\\\"pomerium_set_cookie\\\"])\\n    end\\nend\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"function remove_pomerium_cookie(cookie_name, cookie)\\n    -- lua doesn't support optional capture groups\\n    -- so we replace twice to handle pomerium=xyz at the end of the string\\n    cookie = cookie:gsub(cookie_name .. \\\"=[^;]+; \\\", \\\"\\\")\\n    cookie = cookie:gsub(cookie_name .. \\\"=[^;]+\\\", \\\"\\\")\\n    return cookie\\nend\\n\\nfunction has_prefix(str, prefix)\\n    return str ~= nil and str:sub(1, #prefix) == prefix\\nend\\n\\nfunction envoy_on_request(request_handle)\\n    local headers = request_handle:headers()\\n    local metadata = request_handle:metadata()\\n\\n    local remove_cookie_name = metadata:get(\\\"remove_pomerium_cookie\\\")\\n    if remove_cookie_name then\\n        local cookie = headers:get(\\\"cookie\\\")\\n        if cookie ~= nil then\\n            newcookie = remove_pomerium_cookie(remove_cookie_name, cookie)\\n            headers:replace(\\\"cookie\\\", newcookie)\\n        end\\n    end\\n\\n    local remove_authorization = metadata:get(\\\"remove_pomerium_authorization\\\")\\n    if remove_authorization then\\n        local authorization = headers:get(\\\"authorization\\\")\\n        local authorization_prefix = \\\"Pomerium \\\"\\n        if has_prefix(authorization, authorization_prefix) then\\n            headers:remove(\\\"authorization\\\")\\n        end\\n\\n        headers:remove('x-pomerium-authorization')\\n    end\\nend\\n\\nfunction envoy_on_response(response_handle) end\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.lua\",\n\t\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n\t\t\t\t\t\t\"inlineCode\": \"function replace_prefix(str, prefix, value)\\n    return str:gsub(\\\"^\\\"..prefix, value)\\nend\\n\\nfunction envoy_on_request(request_handle)\\nend\\n\\nfunction envoy_on_response(response_handle)\\n    local headers = response_handle:headers()\\n    local metadata = response_handle:metadata()\\n\\n    -- should be in the form:\\n    -- [{\\n    --   \\\"header\\\":\\\"Location\\\",\\n    --   \\\"prefix\\\":\\\"http://localhost:8000/two/\\\",\\n    --   \\\"value\\\":\\\"http://frontend/one/\\\"\\n    -- }]\\n    local rewrite_response_headers = metadata:get(\\\"rewrite_response_headers\\\")\\n    if rewrite_response_headers then\\n        for _, obj in pairs(rewrite_response_headers) do\\n            local hdr = headers:get(obj.header)\\n            if hdr ~= nil then\\n                local newhdr = replace_prefix(hdr, obj.prefix, obj.value)\\n                headers:replace(obj.header, newhdr)\\n            end\\n        end\\n    end\\nend\\n\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"envoy.filters.http.router\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"requestTimeout\": \"30s\",\n\t\t\t\"routeConfig\": {\n\t\t\t\t\"name\": \"main\",\n\t\t\t\t\"virtualHosts\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"example.com\",\n\t\t\t\t\t\t\"domains\": [\"example.com\"],\n\t\t\t\t\t\t\"responseHeadersToAdd\": [{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"Strict-Transport-Security\",\n\t\t\t\t\t\t\t\t\"value\": \"max-age=31536000; includeSubDomains; preload\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-Frame-Options\",\n\t\t\t\t\t\t\t\t\"value\": \"SAMEORIGIN\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-XSS-Protection\",\n\t\t\t\t\t\t\t\t\"value\": \"1; mode=block\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t\"routes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium/jwt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium/jwt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/ping\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/ping\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/healthz\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/healthz\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.well-known/pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.well-known/pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.well-known/pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.well-known/pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/robots.txt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/robots.txt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"name\": \"catch-all\",\n\t\t\t\t\t\t\"domains\": [\"*\"],\n\t\t\t\t\t\t\"responseHeadersToAdd\": [{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"Strict-Transport-Security\",\n\t\t\t\t\t\t\t\t\"value\": \"max-age=31536000; includeSubDomains; preload\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-Frame-Options\",\n\t\t\t\t\t\t\t\t\"value\": \"SAMEORIGIN\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"key\": \"X-XSS-Protection\",\n\t\t\t\t\t\t\t\t\"value\": \"1; mode=block\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t\"routes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium/jwt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium/jwt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/ping\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/ping\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/healthz\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/healthz\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/.well-known/pomerium\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/.well-known/pomerium\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-prefix-/.well-known/pomerium/\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"prefix\": \"/.well-known/pomerium/\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"pomerium-path-/robots.txt\",\n\t\t\t\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\t\t\t\"path\": \"/robots.txt\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"validateClusters\": false\n\t\t\t},\n\t\t\t\"statPrefix\": \"ingress\",\n\t\t\t\"tracing\": {\n\t\t\t\t\"randomSampling\": {\n\t\t\t\t\t\"value\": 0.01\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"useRemoteAddress\": true,\n\t\t\t\"skipXffAppend\": true,\n\t\t\t\"xffNumTrustedHops\": 1,\n\t\t\t\"localReplyConfig\":{\n\t\t\t\t\"mappers\":[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"filter\":{\n\t\t\t\t\t\t\t\"responseFlagFilter\":{}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"headersToAdd\":[\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"append\":false,\n\t\t\t\t\t\t\t\t\"header\":{\n\t\t\t\t\t\t\t\t\t\"key\":\"Strict-Transport-Security\",\n\t\t\t\t\t\t\t\t\t\"value\":\"max-age=31536000; includeSubDomains; preload\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"append\":false,\n\t\t\t\t\t\t\t\t\"header\":{\n\t\t\t\t\t\t\t\t\t\"key\":\"X-Frame-Options\",\n\t\t\t\t\t\t\t\t\t\"value\":\"SAMEORIGIN\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"append\":false,\n\t\t\t\t\t\t\t\t\"header\":{\n\t\t\t\t\t\t\t\t\t\"key\":\"X-XSS-Protection\",\n\t\t\t\t\t\t\t\t\t\"value\":\"1; mode=block\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t}`, filter)\n}\n\nfunc Test_buildDownstreamTLSContext(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", filemgr.NewManager(), nil)\n\n\tcacheDir, _ := os.UserCacheDir()\n\tcertFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-crt-354e49305a5a39414a545530374e58454e48334148524c4e324258463837364355564c4e4532464b54355139495547514a38.pem\")\n\tkeyFileName := filepath.Join(cacheDir, \"pomerium\", \"envoy\", \"files\", \"tls-key-3350415a38414e4e4a4655424e55393430474147324651433949384e485341334b5157364f424b4c5856365a545937383735.pem\")\n\n\tt.Run(\"no-validation\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert: aExampleComCert,\n\t\t\tKey:  aExampleComKey,\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"client-ca\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert:     aExampleComCert,\n\t\t\tKey:      aExampleComKey,\n\t\t\tClientCA: \"TEST\",\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\"trustChainVerification\": \"ACCEPT_UNTRUSTED\"\n\t\t\t\t}\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"policy-client-ca\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert: aExampleComCert,\n\t\t\tKey:  aExampleComKey,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:                &config.StringURL{URL: mustParseURL(t, \"https://a.example.com:1234\")},\n\t\t\t\t\tTLSDownstreamClientCA: \"TEST\",\n\t\t\t\t},\n\t\t\t},\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\", \"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"validationContext\": {\n\t\t\t\t\t\"trustChainVerification\": \"ACCEPT_UNTRUSTED\"\n\t\t\t\t}\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"http1\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert:      aExampleComCert,\n\t\t\tKey:       aExampleComKey,\n\t\t\tCodecType: config.CodecTypeHTTP1,\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"http/1.1\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n\tt.Run(\"http2\", func(t *testing.T) {\n\t\tdownstreamTLSContext := b.buildDownstreamTLSContext(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tCert:      aExampleComCert,\n\t\t\tKey:       aExampleComKey,\n\t\t\tCodecType: config.CodecTypeHTTP2,\n\t\t}}, \"a.example.com\")\n\n\t\ttestutil.AssertProtoJSONEqual(t, `{\n\t\t\t\"commonTlsContext\": {\n\t\t\t\t\"tlsParams\": {\n\t\t\t\t\t\"cipherSuites\": [\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES256-GCM-SHA384\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-RSA-AES128-GCM-SHA256\",\n\t\t\t\t\t\t\"ECDHE-ECDSA-CHACHA20-POLY1305\",\n\t\t\t\t\t\t\"ECDHE-RSA-CHACHA20-POLY1305\"\n\t\t\t\t\t],\n\t\t\t\t\t\"tlsMinimumProtocolVersion\": \"TLSv1_2\"\n\t\t\t\t},\n\t\t\t\t\"alpnProtocols\": [\"h2\"],\n\t\t\t\t\"tlsCertificates\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"certificateChain\": {\n\t\t\t\t\t\t\t\"filename\": \"`+certFileName+`\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privateKey\": {\n\t\t\t\t\t\t\t\"filename\": \"`+keyFileName+`\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`, downstreamTLSContext)\n\t})\n}\n\nfunc Test_getAllDomains(t *testing.T) {\n\toptions := &config.Options{\n\t\tAddr:                  \"127.0.0.1:9000\",\n\t\tGRPCAddr:              \"127.0.0.1:9001\",\n\t\tServices:              \"all\",\n\t\tAuthenticateURLString: \"https://authenticate.example.com\",\n\t\tAuthorizeURLString:    \"https://authorize.example.com:9001\",\n\t\tDataBrokerURLString:   \"https://cache.example.com:9001\",\n\t\tPolicies: []config.Policy{\n\t\t\t{Source: &config.StringURL{URL: mustParseURL(t, \"http://a.example.com\")}},\n\t\t\t{Source: &config.StringURL{URL: mustParseURL(t, \"https://b.example.com\")}},\n\t\t\t{Source: &config.StringURL{URL: mustParseURL(t, \"https://c.example.com\")}},\n\t\t},\n\t}\n\tt.Run(\"routable\", func(t *testing.T) {\n\t\tt.Run(\"http\", func(t *testing.T) {\n\t\t\tactual, err := getAllRouteableDomains(options, \"127.0.0.1:9000\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"a.example.com\",\n\t\t\t\t\"a.example.com:80\",\n\t\t\t\t\"authenticate.example.com\",\n\t\t\t\t\"authenticate.example.com:443\",\n\t\t\t\t\"b.example.com\",\n\t\t\t\t\"b.example.com:443\",\n\t\t\t\t\"c.example.com\",\n\t\t\t\t\"c.example.com:443\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t\tt.Run(\"grpc\", func(t *testing.T) {\n\t\t\tactual, err := getAllRouteableDomains(options, \"127.0.0.1:9001\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"authorize.example.com:9001\",\n\t\t\t\t\"cache.example.com:9001\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t\tt.Run(\"both\", func(t *testing.T) {\n\t\t\tnewOptions := *options\n\t\t\tnewOptions.GRPCAddr = newOptions.Addr\n\t\t\tactual, err := getAllRouteableDomains(&newOptions, \"127.0.0.1:9000\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"a.example.com\",\n\t\t\t\t\"a.example.com:80\",\n\t\t\t\t\"authenticate.example.com\",\n\t\t\t\t\"authenticate.example.com:443\",\n\t\t\t\t\"authorize.example.com:9001\",\n\t\t\t\t\"b.example.com\",\n\t\t\t\t\"b.example.com:443\",\n\t\t\t\t\"c.example.com\",\n\t\t\t\t\"c.example.com:443\",\n\t\t\t\t\"cache.example.com:9001\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t})\n\tt.Run(\"tls\", func(t *testing.T) {\n\t\tt.Run(\"http\", func(t *testing.T) {\n\t\t\tactual, err := getAllTLSDomains(options, \"127.0.0.1:9000\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"a.example.com\",\n\t\t\t\t\"authenticate.example.com\",\n\t\t\t\t\"b.example.com\",\n\t\t\t\t\"c.example.com\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t\tt.Run(\"grpc\", func(t *testing.T) {\n\t\t\tactual, err := getAllTLSDomains(options, \"127.0.0.1:9001\")\n\t\t\trequire.NoError(t, err)\n\t\t\texpect := []string{\n\t\t\t\t\"authorize.example.com\",\n\t\t\t\t\"cache.example.com\",\n\t\t\t}\n\t\t\tassert.Equal(t, expect, actual)\n\t\t})\n\t})\n}\n\nfunc Test_hostMatchesDomain(t *testing.T) {\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"http://example.com\"), \"example.com\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"http://example.com\"), \"example.com:80\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"https://example.com\"), \"example.com:443\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"https://example.com:443\"), \"example.com:443\"))\n\tassert.True(t, hostMatchesDomain(mustParseURL(t, \"https://example.com:443\"), \"example.com\"))\n\tassert.False(t, hostMatchesDomain(mustParseURL(t, \"http://example.com:81\"), \"example.com\"))\n\tassert.False(t, hostMatchesDomain(mustParseURL(t, \"http://example.com:81\"), \"example.com:80\"))\n}\n\nfunc Test_buildRouteConfiguration(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", nil, nil)\n\tvirtualHosts := make([]*envoy_config_route_v3.VirtualHost, 10)\n\trouteConfig, err := b.buildRouteConfiguration(\"test-route-configuration\", virtualHosts)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"test-route-configuration\", routeConfig.GetName())\n\tassert.Equal(t, virtualHosts, routeConfig.GetVirtualHosts())\n\tassert.False(t, routeConfig.GetValidateClusters().GetValue())\n}\n\nfunc Test_requireProxyProtocol(t *testing.T) {\n\tb := New(\"local-grpc\", \"local-http\", \"local-metrics\", nil, nil)\n\tt.Run(\"required\", func(t *testing.T) {\n\t\tli, err := b.buildMainListener(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tUseProxyProtocol: true,\n\t\t\tInsecureServer:   true,\n\t\t}})\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t{\n\t\t\t\t\"name\": \"envoy.filters.listener.proxy_protocol\",\n\t\t\t\t\"typedConfig\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol\"\n\t\t\t\t}\n\t\t\t}\n\t\t]`, li.GetListenerFilters())\n\t})\n\tt.Run(\"not required\", func(t *testing.T) {\n\t\tli, err := b.buildMainListener(context.Background(), &config.Config{Options: &config.Options{\n\t\t\tUseProxyProtocol: false,\n\t\t\tInsecureServer:   true,\n\t\t}})\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, li.GetListenerFilters(), 0)\n\t})\n}\n", "package envoyconfig\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"sort\"\n\n\tenvoy_config_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_type_matcher_v3 \"github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3\"\n\t\"github.com/golang/protobuf/ptypes/any\"\n\t\"github.com/golang/protobuf/ptypes/wrappers\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/httputil\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n)\n\nconst (\n\thttpCluster = \"pomerium-control-plane-http\"\n)\n\nfunc (b *Builder) buildGRPCRoutes() ([]*envoy_config_route_v3.Route, error) {\n\taction := &envoy_config_route_v3.Route_Route{\n\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\tCluster: \"pomerium-control-plane-grpc\",\n\t\t\t},\n\t\t},\n\t}\n\treturn []*envoy_config_route_v3.Route{{\n\t\tName: \"pomerium-grpc\",\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{\n\t\t\t\tPrefix: \"/\",\n\t\t\t},\n\t\t\tGrpc: &envoy_config_route_v3.RouteMatch_GrpcRouteMatchOptions{},\n\t\t},\n\t\tAction: action,\n\t\tTypedPerFilterConfig: map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t},\n\t}}, nil\n}\n\nfunc (b *Builder) buildPomeriumHTTPRoutes(options *config.Options, domain string) ([]*envoy_config_route_v3.Route, error) {\n\tvar routes []*envoy_config_route_v3.Route\n\n\t// if this is the pomerium proxy in front of the the authenticate service, don't add\n\t// these routes since they will be handled by authenticate\n\tisFrontingAuthenticate, err := isProxyFrontingAuthenticate(options, domain)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isFrontingAuthenticate {\n\t\troutes = append(routes,\n\t\t\t// enable ext_authz\n\t\t\tb.buildControlPlanePathRoute(\"/.pomerium/jwt\", true),\n\t\t\t// disable ext_authz and passthrough to proxy handlers\n\t\t\tb.buildControlPlanePathRoute(\"/ping\", false),\n\t\t\tb.buildControlPlanePathRoute(\"/healthz\", false),\n\t\t\tb.buildControlPlanePathRoute(\"/.pomerium\", false),\n\t\t\tb.buildControlPlanePrefixRoute(\"/.pomerium/\", false),\n\t\t\tb.buildControlPlanePathRoute(\"/.well-known/pomerium\", false),\n\t\t\tb.buildControlPlanePrefixRoute(\"/.well-known/pomerium/\", false),\n\t\t)\n\t\t// per #837, only add robots.txt if there are no unauthenticated routes\n\t\tif !hasPublicPolicyMatchingURL(options, url.URL{Scheme: \"https\", Host: domain, Path: \"/robots.txt\"}) {\n\t\t\troutes = append(routes, b.buildControlPlanePathRoute(\"/robots.txt\", false))\n\t\t}\n\t}\n\t// if we're handling authentication, add the oauth2 callback url\n\tauthenticateURL, err := options.GetInternalAuthenticateURL()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif config.IsAuthenticate(options.Services) && hostMatchesDomain(authenticateURL, domain) {\n\t\troutes = append(routes,\n\t\t\tb.buildControlPlanePathRoute(options.AuthenticateCallbackPath, false),\n\t\t\tb.buildControlPlanePathRoute(\"/\", false),\n\t\t)\n\t}\n\t// if we're the proxy and this is the forward-auth url\n\tforwardAuthURL, err := options.GetForwardAuthURL()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif config.IsProxy(options.Services) && hostMatchesDomain(forwardAuthURL, domain) {\n\t\t// disable ext_authz and pass request to proxy handlers that enable authN flow\n\t\tr, err := b.buildControlPlanePathAndQueryRoute(\"/verify\", []string{urlutil.QueryForwardAuthURI, urlutil.QuerySessionEncrypted, urlutil.QueryRedirectURI})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathAndQueryRoute(\"/\", []string{urlutil.QueryForwardAuthURI, urlutil.QuerySessionEncrypted, urlutil.QueryRedirectURI})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t\tr, err = b.buildControlPlanePathAndQueryRoute(\"/\", []string{urlutil.QueryForwardAuthURI})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\n\t\t// otherwise, enforce ext_authz; pass all other requests through to an upstream\n\t\t// handler that will simply respond with http status 200 / OK indicating that\n\t\t// the fronting forward-auth proxy can continue.\n\t\tr, err = b.buildControlPlaneProtectedPrefixRoute(\"/\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\troutes = append(routes, r)\n\t}\n\treturn routes, nil\n}\n\nfunc (b *Builder) buildControlPlaneProtectedPrefixRoute(prefix string) (*envoy_config_route_v3.Route, error) {\n\treturn &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-protected-prefix-\" + prefix,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: prefix},\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildControlPlanePathAndQueryRoute(path string, queryparams []string) (*envoy_config_route_v3.Route, error) {\n\tvar queryParameterMatchers []*envoy_config_route_v3.QueryParameterMatcher\n\tfor _, q := range queryparams {\n\t\tqueryParameterMatchers = append(queryParameterMatchers,\n\t\t\t&envoy_config_route_v3.QueryParameterMatcher{\n\t\t\t\tName:                         q,\n\t\t\t\tQueryParameterMatchSpecifier: &envoy_config_route_v3.QueryParameterMatcher_PresentMatch{PresentMatch: true},\n\t\t\t})\n\t}\n\n\treturn &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-path-and-query\" + path,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier:   &envoy_config_route_v3.RouteMatch_Path{Path: path},\n\t\t\tQueryParameters: queryParameterMatchers,\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTypedPerFilterConfig: map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t},\n\t}, nil\n}\n\nfunc (b *Builder) buildControlPlanePathRoute(path string, protected bool) *envoy_config_route_v3.Route {\n\tr := &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-path-\" + path,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Path{Path: path},\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif !protected {\n\t\tr.TypedPerFilterConfig = map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (b *Builder) buildControlPlanePrefixRoute(prefix string, protected bool) *envoy_config_route_v3.Route {\n\tr := &envoy_config_route_v3.Route{\n\t\tName: \"pomerium-prefix-\" + prefix,\n\t\tMatch: &envoy_config_route_v3.RouteMatch{\n\t\t\tPathSpecifier: &envoy_config_route_v3.RouteMatch_Prefix{Prefix: prefix},\n\t\t},\n\t\tAction: &envoy_config_route_v3.Route_Route{\n\t\t\tRoute: &envoy_config_route_v3.RouteAction{\n\t\t\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\t\t\tCluster: httpCluster,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif !protected {\n\t\tr.TypedPerFilterConfig = map[string]*any.Any{\n\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t}\n\t}\n\treturn r\n}\n\n// getClusterID returns a cluster ID\nvar getClusterID = func(policy *config.Policy) string {\n\tprefix := getClusterStatsName(policy)\n\tif prefix == \"\" {\n\t\tprefix = \"route\"\n\t}\n\n\tid, _ := policy.RouteID()\n\treturn fmt.Sprintf(\"%s-%x\", prefix, id)\n}\n\n// getClusterStatsName returns human readable name that would be used by envoy to emit statistics, available as envoy_cluster_name label\nfunc getClusterStatsName(policy *config.Policy) string {\n\tif policy.EnvoyOpts != nil && policy.EnvoyOpts.Name != \"\" {\n\t\treturn policy.EnvoyOpts.Name\n\t}\n\treturn \"\"\n}\n\nfunc (b *Builder) buildPolicyRoutes(options *config.Options, domain string) ([]*envoy_config_route_v3.Route, error) {\n\tvar routes []*envoy_config_route_v3.Route\n\n\tfor i, p := range options.GetAllPolicies() {\n\t\tpolicy := p\n\t\tif !hostMatchesDomain(policy.Source.URL, domain) {\n\t\t\tcontinue\n\t\t}\n\n\t\tmatch := mkRouteMatch(&policy)\n\t\tenvoyRoute := &envoy_config_route_v3.Route{\n\t\t\tName:                   fmt.Sprintf(\"policy-%d\", i),\n\t\t\tMatch:                  match,\n\t\t\tMetadata:               &envoy_config_core_v3.Metadata{},\n\t\t\tRequestHeadersToAdd:    toEnvoyHeaders(policy.SetRequestHeaders),\n\t\t\tRequestHeadersToRemove: getRequestHeadersToRemove(options, &policy),\n\t\t\tResponseHeadersToAdd:   toEnvoyHeaders(policy.SetResponseHeaders),\n\t\t}\n\t\tif policy.Redirect != nil {\n\t\t\taction, err := b.buildPolicyRouteRedirectAction(policy.Redirect)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tenvoyRoute.Action = &envoy_config_route_v3.Route_Redirect{Redirect: action}\n\t\t} else {\n\t\t\taction, err := b.buildPolicyRouteRouteAction(options, &policy)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tenvoyRoute.Action = &envoy_config_route_v3.Route_Route{Route: action}\n\t\t}\n\n\t\tluaMetadata := map[string]*structpb.Value{\n\t\t\t\"rewrite_response_headers\": getRewriteHeadersMetadata(policy.RewriteResponseHeaders),\n\t\t}\n\n\t\t// disable authentication entirely when the proxy is fronting authenticate\n\t\tisFrontingAuthenticate, err := isProxyFrontingAuthenticate(options, domain)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif isFrontingAuthenticate {\n\t\t\tenvoyRoute.TypedPerFilterConfig = map[string]*any.Any{\n\t\t\t\t\"envoy.filters.http.ext_authz\": disableExtAuthz,\n\t\t\t}\n\t\t} else {\n\t\t\tluaMetadata[\"remove_pomerium_cookie\"] = &structpb.Value{\n\t\t\t\tKind: &structpb.Value_StringValue{\n\t\t\t\t\tStringValue: options.CookieName,\n\t\t\t\t},\n\t\t\t}\n\t\t\tluaMetadata[\"remove_pomerium_authorization\"] = &structpb.Value{\n\t\t\t\tKind: &structpb.Value_BoolValue{\n\t\t\t\t\tBoolValue: true,\n\t\t\t\t},\n\t\t\t}\n\t\t\tluaMetadata[\"remove_impersonate_headers\"] = &structpb.Value{\n\t\t\t\tKind: &structpb.Value_BoolValue{\n\t\t\t\t\tBoolValue: policy.IsForKubernetes(),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif policy.IsForKubernetes() {\n\t\t\tpolicyID, _ := policy.RouteID()\n\t\t\tfor _, hdr := range b.reproxy.GetPolicyIDHeaders(policyID) {\n\t\t\t\tenvoyRoute.RequestHeadersToAdd = append(envoyRoute.RequestHeadersToAdd,\n\t\t\t\t\t&envoy_config_core_v3.HeaderValueOption{\n\t\t\t\t\t\tHeader: &envoy_config_core_v3.HeaderValue{\n\t\t\t\t\t\t\tKey:   hdr[0],\n\t\t\t\t\t\t\tValue: hdr[1],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tAppend: wrapperspb.Bool(false),\n\t\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tenvoyRoute.Metadata.FilterMetadata = map[string]*structpb.Struct{\n\t\t\t\"envoy.filters.http.lua\": {Fields: luaMetadata},\n\t\t}\n\n\t\troutes = append(routes, envoyRoute)\n\t}\n\treturn routes, nil\n}\n\nfunc (b *Builder) buildPolicyRouteRedirectAction(r *config.PolicyRedirect) (*envoy_config_route_v3.RedirectAction, error) {\n\taction := &envoy_config_route_v3.RedirectAction{}\n\tswitch {\n\tcase r.HTTPSRedirect != nil:\n\t\taction.SchemeRewriteSpecifier = &envoy_config_route_v3.RedirectAction_HttpsRedirect{\n\t\t\tHttpsRedirect: *r.HTTPSRedirect,\n\t\t}\n\tcase r.SchemeRedirect != nil:\n\t\taction.SchemeRewriteSpecifier = &envoy_config_route_v3.RedirectAction_SchemeRedirect{\n\t\t\tSchemeRedirect: *r.SchemeRedirect,\n\t\t}\n\t}\n\tif r.HostRedirect != nil {\n\t\taction.HostRedirect = *r.HostRedirect\n\t}\n\tif r.PortRedirect != nil {\n\t\taction.PortRedirect = *r.PortRedirect\n\t}\n\tswitch {\n\tcase r.PathRedirect != nil:\n\t\taction.PathRewriteSpecifier = &envoy_config_route_v3.RedirectAction_PathRedirect{\n\t\t\tPathRedirect: *r.PathRedirect,\n\t\t}\n\tcase r.PrefixRewrite != nil:\n\t\taction.PathRewriteSpecifier = &envoy_config_route_v3.RedirectAction_PrefixRewrite{\n\t\t\tPrefixRewrite: *r.PrefixRewrite,\n\t\t}\n\t}\n\tif r.ResponseCode != nil {\n\t\taction.ResponseCode = envoy_config_route_v3.RedirectAction_RedirectResponseCode(*r.ResponseCode)\n\t}\n\tif r.StripQuery != nil {\n\t\taction.StripQuery = *r.StripQuery\n\t}\n\treturn action, nil\n}\n\nfunc (b *Builder) buildPolicyRouteRouteAction(options *config.Options, policy *config.Policy) (*envoy_config_route_v3.RouteAction, error) {\n\tclusterName := getClusterID(policy)\n\t// kubernetes requests are sent to the http control plane to be reproxied\n\tif policy.IsForKubernetes() {\n\t\tclusterName = httpCluster\n\t}\n\trouteTimeout := getRouteTimeout(options, policy)\n\tidleTimeout := getRouteIdleTimeout(policy)\n\tprefixRewrite, regexRewrite := getRewriteOptions(policy)\n\tupgradeConfigs := []*envoy_config_route_v3.RouteAction_UpgradeConfig{\n\t\t{\n\t\t\tUpgradeType: \"websocket\",\n\t\t\tEnabled:     &wrappers.BoolValue{Value: policy.AllowWebsockets},\n\t\t},\n\t\t{\n\t\t\tUpgradeType: \"spdy/3.1\",\n\t\t\tEnabled:     &wrappers.BoolValue{Value: policy.AllowSPDY},\n\t\t},\n\t}\n\tif urlutil.IsTCP(policy.Source.URL) {\n\t\tupgradeConfigs = append(upgradeConfigs, &envoy_config_route_v3.RouteAction_UpgradeConfig{\n\t\t\tUpgradeType:   \"CONNECT\",\n\t\t\tEnabled:       &wrappers.BoolValue{Value: true},\n\t\t\tConnectConfig: &envoy_config_route_v3.RouteAction_UpgradeConfig_ConnectConfig{},\n\t\t})\n\t}\n\taction := &envoy_config_route_v3.RouteAction{\n\t\tClusterSpecifier: &envoy_config_route_v3.RouteAction_Cluster{\n\t\t\tCluster: clusterName,\n\t\t},\n\t\tUpgradeConfigs: upgradeConfigs,\n\t\tHostRewriteSpecifier: &envoy_config_route_v3.RouteAction_AutoHostRewrite{\n\t\t\tAutoHostRewrite: &wrappers.BoolValue{Value: !policy.PreserveHostHeader},\n\t\t},\n\t\tTimeout:       routeTimeout,\n\t\tIdleTimeout:   idleTimeout,\n\t\tPrefixRewrite: prefixRewrite,\n\t\tRegexRewrite:  regexRewrite,\n\t\tHashPolicy: []*envoy_config_route_v3.RouteAction_HashPolicy{\n\t\t\t// hash by the routing key, which is added by authorize.\n\t\t\t{\n\t\t\t\tPolicySpecifier: &envoy_config_route_v3.RouteAction_HashPolicy_Header_{\n\t\t\t\t\tHeader: &envoy_config_route_v3.RouteAction_HashPolicy_Header{\n\t\t\t\t\t\tHeaderName: httputil.HeaderPomeriumRoutingKey,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTerminal: true,\n\t\t\t},\n\t\t\t// if the routing key is missing, hash by the ip.\n\t\t\t{\n\t\t\t\tPolicySpecifier: &envoy_config_route_v3.RouteAction_HashPolicy_ConnectionProperties_{\n\t\t\t\t\tConnectionProperties: &envoy_config_route_v3.RouteAction_HashPolicy_ConnectionProperties{\n\t\t\t\t\t\tSourceIp: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTerminal: true,\n\t\t\t},\n\t\t},\n\t}\n\tsetHostRewriteOptions(policy, action)\n\n\treturn action, nil\n}\n\nfunc mkEnvoyHeader(k, v string) *envoy_config_core_v3.HeaderValueOption {\n\treturn &envoy_config_core_v3.HeaderValueOption{\n\t\tHeader: &envoy_config_core_v3.HeaderValue{\n\t\t\tKey:   k,\n\t\t\tValue: v,\n\t\t},\n\t\tAppend: &wrappers.BoolValue{Value: false},\n\t}\n}\n\nfunc toEnvoyHeaders(headers map[string]string) []*envoy_config_core_v3.HeaderValueOption {\n\tvar ks []string\n\tfor k := range headers {\n\t\tks = append(ks, k)\n\t}\n\tsort.Strings(ks)\n\n\tenvoyHeaders := make([]*envoy_config_core_v3.HeaderValueOption, 0, len(headers))\n\tfor _, k := range ks {\n\t\tenvoyHeaders = append(envoyHeaders, mkEnvoyHeader(k, headers[k]))\n\t}\n\treturn envoyHeaders\n}\n\nfunc mkRouteMatch(policy *config.Policy) *envoy_config_route_v3.RouteMatch {\n\tmatch := &envoy_config_route_v3.RouteMatch{}\n\tswitch {\n\tcase urlutil.IsTCP(policy.Source.URL):\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_ConnectMatcher_{\n\t\t\tConnectMatcher: &envoy_config_route_v3.RouteMatch_ConnectMatcher{},\n\t\t}\n\tcase policy.Regex != \"\":\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_SafeRegex{\n\t\t\tSafeRegex: &envoy_type_matcher_v3.RegexMatcher{\n\t\t\t\tEngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{\n\t\t\t\t\tGoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},\n\t\t\t\t},\n\t\t\t\tRegex: policy.Regex,\n\t\t\t},\n\t\t}\n\tcase policy.Path != \"\":\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_Path{Path: policy.Path}\n\tcase policy.Prefix != \"\":\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_Prefix{Prefix: policy.Prefix}\n\tdefault:\n\t\tmatch.PathSpecifier = &envoy_config_route_v3.RouteMatch_Prefix{Prefix: \"/\"}\n\t}\n\treturn match\n}\n\nfunc getRequestHeadersToRemove(options *config.Options, policy *config.Policy) []string {\n\trequestHeadersToRemove := policy.RemoveRequestHeaders\n\tif !policy.PassIdentityHeaders {\n\t\trequestHeadersToRemove = append(requestHeadersToRemove,\n\t\t\thttputil.HeaderPomeriumJWTAssertion,\n\t\t\thttputil.HeaderPomeriumJWTAssertionFor)\n\t\tfor headerName := range options.JWTClaimsHeaders {\n\t\t\trequestHeadersToRemove = append(requestHeadersToRemove, headerName)\n\t\t}\n\t}\n\t// remove these headers to prevent a user from re-proxying requests through the control plane\n\trequestHeadersToRemove = append(requestHeadersToRemove,\n\t\thttputil.HeaderPomeriumReproxyPolicy,\n\t\thttputil.HeaderPomeriumReproxyPolicyHMAC,\n\t)\n\treturn requestHeadersToRemove\n}\n\nfunc getRouteTimeout(options *config.Options, policy *config.Policy) *durationpb.Duration {\n\tvar routeTimeout *durationpb.Duration\n\tif policy.UpstreamTimeout != nil {\n\t\trouteTimeout = durationpb.New(*policy.UpstreamTimeout)\n\t} else if shouldDisableStreamIdleTimeout(policy) {\n\t\t// a non-zero value would conflict with idleTimeout and/or websocket / tcp calls\n\t\trouteTimeout = durationpb.New(0)\n\t} else {\n\t\trouteTimeout = durationpb.New(options.DefaultUpstreamTimeout)\n\t}\n\treturn routeTimeout\n}\n\nfunc getRouteIdleTimeout(policy *config.Policy) *durationpb.Duration {\n\tvar idleTimeout *durationpb.Duration\n\tif policy.IdleTimeout != nil {\n\t\tidleTimeout = durationpb.New(*policy.IdleTimeout)\n\t} else if shouldDisableStreamIdleTimeout(policy) {\n\t\tidleTimeout = durationpb.New(0)\n\t}\n\treturn idleTimeout\n}\n\nfunc shouldDisableStreamIdleTimeout(policy *config.Policy) bool {\n\treturn policy.AllowWebsockets ||\n\t\turlutil.IsTCP(policy.Source.URL) ||\n\t\tpolicy.IsForKubernetes() // disable for kubernetes so that tailing logs works (#2182)\n}\n\nfunc getRewriteOptions(policy *config.Policy) (prefixRewrite string, regexRewrite *envoy_type_matcher_v3.RegexMatchAndSubstitute) {\n\tif policy.PrefixRewrite != \"\" {\n\t\tprefixRewrite = policy.PrefixRewrite\n\t} else if policy.RegexRewritePattern != \"\" {\n\t\tregexRewrite = &envoy_type_matcher_v3.RegexMatchAndSubstitute{\n\t\t\tPattern: &envoy_type_matcher_v3.RegexMatcher{\n\t\t\t\tEngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{\n\t\t\t\t\tGoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},\n\t\t\t\t},\n\t\t\t\tRegex: policy.RegexRewritePattern,\n\t\t\t},\n\t\t\tSubstitution: policy.RegexRewriteSubstitution,\n\t\t}\n\t} else if len(policy.To) > 0 && policy.To[0].URL.Path != \"\" {\n\t\tprefixRewrite = policy.To[0].URL.Path\n\t}\n\n\treturn prefixRewrite, regexRewrite\n}\n\nfunc setHostRewriteOptions(policy *config.Policy, action *envoy_config_route_v3.RouteAction) {\n\tswitch {\n\tcase policy.HostRewrite != \"\":\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_HostRewriteLiteral{\n\t\t\tHostRewriteLiteral: policy.HostRewrite,\n\t\t}\n\tcase policy.HostRewriteHeader != \"\":\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_HostRewriteHeader{\n\t\t\tHostRewriteHeader: policy.HostRewriteHeader,\n\t\t}\n\tcase policy.HostPathRegexRewritePattern != \"\":\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_HostRewritePathRegex{\n\t\t\tHostRewritePathRegex: &envoy_type_matcher_v3.RegexMatchAndSubstitute{\n\t\t\t\tPattern: &envoy_type_matcher_v3.RegexMatcher{\n\t\t\t\t\tEngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{\n\t\t\t\t\t\tGoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},\n\t\t\t\t\t},\n\t\t\t\t\tRegex: policy.HostPathRegexRewritePattern,\n\t\t\t\t},\n\t\t\t\tSubstitution: policy.HostPathRegexRewriteSubstitution,\n\t\t\t},\n\t\t}\n\tcase policy.PreserveHostHeader:\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_AutoHostRewrite{\n\t\t\tAutoHostRewrite: wrapperspb.Bool(false),\n\t\t}\n\tdefault:\n\t\taction.HostRewriteSpecifier = &envoy_config_route_v3.RouteAction_AutoHostRewrite{\n\t\t\tAutoHostRewrite: wrapperspb.Bool(true),\n\t\t}\n\t}\n}\n\nfunc hasPublicPolicyMatchingURL(options *config.Options, requestURL url.URL) bool {\n\tfor _, policy := range options.GetAllPolicies() {\n\t\tif policy.AllowPublicUnauthenticatedAccess && policy.Matches(requestURL) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isProxyFrontingAuthenticate(options *config.Options, domain string) (bool, error) {\n\tauthenticateURL, err := options.GetAuthenticateURL()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif !config.IsAuthenticate(options.Services) && hostMatchesDomain(authenticateURL, domain) {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\nfunc getRewriteHeadersMetadata(headers []config.RewriteHeader) *structpb.Value {\n\tif len(headers) == 0 {\n\t\treturn &structpb.Value{\n\t\t\tKind: &structpb.Value_ListValue{\n\t\t\t\tListValue: new(structpb.ListValue),\n\t\t\t},\n\t\t}\n\t}\n\tvar obj interface{}\n\tbs, _ := json.Marshal(headers)\n\t_ = json.Unmarshal(bs, &obj)\n\tv, _ := structpb.NewValue(obj)\n\treturn v\n}\n", "package envoyconfig\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tenvoy_config_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tenvoy_config_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/testutil\"\n)\n\nfunc policyNameFunc() func(*config.Policy) string {\n\ti := 0\n\treturn func(*config.Policy) string {\n\t\ti++\n\t\treturn fmt.Sprintf(\"policy-%d\", i)\n\t}\n}\n\nfunc Test_buildGRPCRoutes(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troutes, err := b.buildGRPCRoutes()\n\trequire.NoError(t, err)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"pomerium-grpc\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"grpc\": {},\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"cluster\": \"pomerium-control-plane-grpc\"\n\t\t\t\t},\n\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t`, routes)\n}\n\nfunc Test_buildPomeriumHTTPRoutes(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\trouteString := func(typ, name string, protected bool) string {\n\t\tstr := `{\n\t\t\t\t\"name\": \"pomerium-` + typ + `-` + name + `\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"` + typ + `\": \"` + name + `\"\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t\t}\n\t\t\t`\n\t\tif !protected {\n\t\t\tstr += `,\n\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`\n\t\t}\n\t\tstr += \"}\"\n\t\treturn str\n\t}\n\tt.Run(\"authenticate\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"all\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t\tForwardAuthURLString:     \"https://forward-auth.example.com\",\n\t\t}\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"authenticate.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t`+routeString(\"path\", \"/.pomerium/jwt\", true)+`,\n\t\t\t`+routeString(\"path\", \"/ping\", false)+`,\n\t\t\t`+routeString(\"path\", \"/healthz\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.well-known/pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.well-known/pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/robots.txt\", false)+`,\n\t\t\t`+routeString(\"path\", \"/oauth2/callback\", false)+`,\n\t\t\t`+routeString(\"path\", \"/\", false)+`\n\t\t]`, routes)\n\t})\n\tt.Run(\"proxy fronting authenticate\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"proxy\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t}\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"authenticate.example.com\")\n\t\trequire.NoError(t, err)\n\t\ttestutil.AssertProtoJSONEqual(t, \"null\", routes)\n\t})\n\n\tt.Run(\"with robots\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"all\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t\tForwardAuthURLString:     \"https://forward-auth.example.com\",\n\t\t\tPolicies: []config.Policy{{\n\t\t\t\tFrom: \"https://from.example.com\",\n\t\t\t\tTo:   mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t\t}},\n\t\t}\n\t\t_ = options.Policies[0].Validate()\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"from.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t`+routeString(\"path\", \"/.pomerium/jwt\", true)+`,\n\t\t\t`+routeString(\"path\", \"/ping\", false)+`,\n\t\t\t`+routeString(\"path\", \"/healthz\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.well-known/pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.well-known/pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/robots.txt\", false)+`\n\t\t]`, routes)\n\t})\n\n\tt.Run(\"without robots\", func(t *testing.T) {\n\t\toptions := &config.Options{\n\t\t\tServices:                 \"all\",\n\t\t\tAuthenticateURLString:    \"https://authenticate.example.com\",\n\t\t\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\t\t\tForwardAuthURLString:     \"https://forward-auth.example.com\",\n\t\t\tPolicies: []config.Policy{{\n\t\t\t\tFrom:                             \"https://from.example.com\",\n\t\t\t\tTo:                               mustParseWeightedURLs(t, \"https://to.example.com\"),\n\t\t\t\tAllowPublicUnauthenticatedAccess: true,\n\t\t\t}},\n\t\t}\n\t\t_ = options.Policies[0].Validate()\n\t\troutes, err := b.buildPomeriumHTTPRoutes(options, \"from.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `[\n\t\t\t`+routeString(\"path\", \"/.pomerium/jwt\", true)+`,\n\t\t\t`+routeString(\"path\", \"/ping\", false)+`,\n\t\t\t`+routeString(\"path\", \"/healthz\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.pomerium/\", false)+`,\n\t\t\t`+routeString(\"path\", \"/.well-known/pomerium\", false)+`,\n\t\t\t`+routeString(\"prefix\", \"/.well-known/pomerium/\", false)+`\n\t\t]`, routes)\n\t})\n}\n\nfunc Test_buildControlPlanePathRoute(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troute := b.buildControlPlanePathRoute(\"/hello/world\", false)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t{\n\t\t\t\"name\": \"pomerium-path-/hello/world\",\n\t\t\t\"match\": {\n\t\t\t\t\"path\": \"/hello/world\"\n\t\t\t},\n\t\t\t\"route\": {\n\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t},\n\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\"disabled\": true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`, route)\n}\n\nfunc Test_buildControlPlanePrefixRoute(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troute := b.buildControlPlanePrefixRoute(\"/hello/world/\", false)\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t{\n\t\t\t\"name\": \"pomerium-prefix-/hello/world/\",\n\t\t\t\"match\": {\n\t\t\t\t\"prefix\": \"/hello/world/\"\n\t\t\t},\n\t\t\t\"route\": {\n\t\t\t\t\"cluster\": \"pomerium-control-plane-http\"\n\t\t\t},\n\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\"disabled\": true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`, route)\n}\n\nfunc TestTimeouts(t *testing.T) {\n\tdefer func(f func(*config.Policy) string) {\n\t\tgetClusterID = f\n\t}(getClusterID)\n\tgetClusterID = func(*config.Policy) string { return \"policy\" }\n\n\tgetDuration := func(txt string) *time.Duration {\n\t\tif txt == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\td, err := time.ParseDuration(txt)\n\t\trequire.NoError(t, err, txt)\n\t\treturn &d\n\t}\n\n\ttestCases := []struct {\n\t\tupstream, idle  string\n\t\tallowWebsockets bool\n\t\texpect          string\n\t}{\n\t\t{\"\", \"\", false, `\"timeout\": \"3s\"`},\n\t\t{\"\", \"\", true, `\"timeout\": \"0s\", \"idleTimeout\": \"0s\"`},\n\t\t{\"5s\", \"\", true, `\"timeout\": \"5s\", \"idleTimeout\": \"0s\"`},\n\t\t{\"\", \"0s\", false, `\"timeout\": \"3s\",\"idleTimeout\": \"0s\"`},\n\t\t{\"\", \"5s\", false, `\"timeout\": \"3s\",\"idleTimeout\": \"5s\"`},\n\t\t{\"5s\", \"\", false, `\"timeout\": \"5s\"`},\n\t\t{\"5s\", \"4s\", false, `\"timeout\": \"5s\",\"idleTimeout\": \"4s\"`},\n\t\t{\"0s\", \"4s\", false, `\"timeout\": \"0s\",\"idleTimeout\": \"4s\"`},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tb := &Builder{filemgr: filemgr.NewManager()}\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:          &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\t\tPath:            \"/test\",\n\t\t\t\t\tUpstreamTimeout: getDuration(tc.upstream),\n\t\t\t\t\tIdleTimeout:     getDuration(tc.idle),\n\t\t\t\t\tAllowWebsockets: tc.allowWebsockets,\n\t\t\t\t}},\n\t\t}, \"example.com\")\n\t\tif !assert.NoError(t, err, \"%v\", tc) || !assert.Len(t, routes, 1, tc) || !assert.NotNil(t, routes[0].GetRoute(), \"%v\", tc) {\n\t\t\tcontinue\n\t\t}\n\n\t\texpect := fmt.Sprintf(`{\n\t\t\t%s,\n\t\t\t\"autoHostRewrite\": true,\n\t\t\t\"cluster\": \"policy\",\n\t\t\t\"hashPolicy\": [\n\t\t\t\t{\n\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t},\n\t\t\t\t\t\"terminal\": true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t},\n\t\t\t\t\t\"terminal\": true\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"upgradeConfigs\": [\n\t\t\t\t{ \"enabled\": %v, \"upgradeType\": \"websocket\"},\n\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t]\n\t\t}`, tc.expect, tc.allowWebsockets)\n\t\ttestutil.AssertProtoJSONEqual(t, expect, routes[0].GetRoute())\n\t}\n}\n\nfunc Test_buildPolicyRoutes(t *testing.T) {\n\tdefer func(f func(*config.Policy) string) {\n\t\tgetClusterID = f\n\t}(getClusterID)\n\tgetClusterID = policyNameFunc()\n\n\toneMinute := time.Minute\n\tten := time.Second * 10\n\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\tCookieName:             \"pomerium\",\n\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\tPolicies: []config.Policy{\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://ignore.example.com\")},\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/some/path\",\n\t\t\t\tAllowWebsockets:     true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPrefix:              \"/some/prefix/\",\n\t\t\t\tSetRequestHeaders:   map[string]string{\"HEADER-KEY\": \"HEADER-VALUE\"},\n\t\t\t\tUpstreamTimeout:     &oneMinute,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tRegex:               `^/[a]+$`,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:               &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPrefix:               \"/some/prefix/\",\n\t\t\t\tRemoveRequestHeaders: []string{\"HEADER-KEY\"},\n\t\t\t\tUpstreamTimeout:      &oneMinute,\n\t\t\t\tPassIdentityHeaders:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/some/path\",\n\t\t\t\tAllowSPDY:           true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/some/path\",\n\t\t\t\tAllowSPDY:           true,\n\t\t\t\tAllowWebsockets:     true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tPath:                \"/websocket-timeout\",\n\t\t\t\tAllowWebsockets:     true,\n\t\t\t\tPreserveHostHeader:  true,\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tUpstreamTimeout:     &ten,\n\t\t\t},\n\t\t},\n\t}, \"example.com\")\n\trequire.NoError(t, err)\n\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"policy-1\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-1\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-2\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/some/path\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-2\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"0s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-3\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/some/prefix/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-3\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"60s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToAdd\": [{\n\t\t\t\t\t\"append\": false,\n\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\"key\": \"HEADER-KEY\",\n\t\t\t\t\t\t\"value\": \"HEADER-VALUE\"\n\t\t\t\t\t}\n\t\t\t\t}],\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-4\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"safeRegex\": {\n\t\t\t\t\t\t\"googleRe2\": {},\n\t\t\t\t\t\t\"regex\": \"^/[a]+$\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-4\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-5\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/some/prefix/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-5\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"60s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"HEADER-KEY\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-6\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/some/path\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-6\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-7\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/some/path\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-7\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"0s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-8\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"path\": \"/websocket-timeout\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": false,\n\t\t\t\t\t\"cluster\": \"policy-8\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"10s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t`, routes)\n\n\tt.Run(\"fronting-authenticate\", func(t *testing.T) {\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tAuthenticateURLString:  \"https://authenticate.example.com\",\n\t\t\tServices:               \"proxy\",\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://authenticate.example.com\")},\n\t\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\t},\n\t\t\t},\n\t\t}, \"authenticate.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t\t},\n\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\t\"cluster\": \"policy-9\",\n\t\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n        \t        \"requestHeadersToRemove\": [\n        \t           \t\"x-pomerium-reproxy-policy\",\n        \t           \t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t\t],\n\t\t\t\t\t\"typedPerFilterConfig\": {\n\t\t\t\t\t\t\"envoy.filters.http.ext_authz\": {\n\t\t\t\t\t\t\t\"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\",\n\t\t\t\t\t\t\t\"disabled\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t`, routes)\n\t})\n\n\tt.Run(\"tcp\", func(t *testing.T) {\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"tcp+https://example.com:22\")},\n\t\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"tcp+https://example.com:22\")},\n\t\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\t\tUpstreamTimeout:     &ten,\n\t\t\t\t},\n\t\t\t},\n\t\t}, \"example.com:22\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"connectMatcher\": {}\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-10\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"0s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"CONNECT\", \"connectConfig\": {} }\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-1\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"connectMatcher\": {}\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"cluster\": \"policy-11\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"idleTimeout\": \"0s\",\n\t\t\t\t\t\"timeout\": \"10s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"},\n\t\t\t\t\t\t{ \"enabled\": true, \"upgradeType\": \"CONNECT\", \"connectConfig\": {} }\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t`, routes)\n\t})\n\n\tt.Run(\"remove-pomerium-headers\", func(t *testing.T) {\n\t\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\t\tAuthenticateURLString:  \"https://authenticate.example.com\",\n\t\t\tServices:               \"proxy\",\n\t\t\tCookieName:             \"pomerium\",\n\t\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\t\tJWTClaimsHeaders: map[string]string{\n\t\t\t\t\"x-email\": \"email\",\n\t\t\t},\n\t\t\tPolicies: []config.Policy{\n\t\t\t\t{\n\t\t\t\t\tSource: &config.StringURL{URL: mustParseURL(t, \"https://from.example.com\")},\n\t\t\t\t},\n\t\t\t},\n\t\t}, \"from.example.com\")\n\t\trequire.NoError(t, err)\n\n\t\ttestutil.AssertProtoJSONEqual(t, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\t\"match\": {\n\t\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t\t},\n\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"route\": {\n\t\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\t\"cluster\": \"policy-12\",\n\t\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\t\"x-pomerium-jwt-assertion\",\n\t\t\t\t\t\t\"x-pomerium-jwt-assertion-for\",\n\t\t\t\t\t\t\"x-email\",\n\t\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t`, routes)\n\t})\n}\n\nfunc Test_buildPolicyRoutesRewrite(t *testing.T) {\n\tdefer func(f func(*config.Policy) string) {\n\t\tgetClusterID = f\n\t}(getClusterID)\n\tgetClusterID = policyNameFunc()\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\troutes, err := b.buildPolicyRoutes(&config.Options{\n\t\tCookieName:             \"pomerium\",\n\t\tDefaultUpstreamTimeout: time.Second * 3,\n\t\tPolicies: []config.Policy{\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tPrefixRewrite:       \"/foo\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:                   &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                       mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders:      true,\n\t\t\t\tRegexRewritePattern:      \"^/service/([^/]+)(/.*)$\",\n\t\t\t\tRegexRewriteSubstitution: \"\\\\2/instance/\\\\1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tHostRewrite:         \"literal.example.com\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:              &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                  mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders: true,\n\t\t\t\tHostRewriteHeader:   \"HOST_HEADER\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:                           &config.StringURL{URL: mustParseURL(t, \"https://example.com\")},\n\t\t\t\tTo:                               mustParseWeightedURLs(t, \"https://foo.example.com/bar\"),\n\t\t\t\tPassIdentityHeaders:              true,\n\t\t\t\tHostPathRegexRewritePattern:      \"^/(.+)/.+$\",\n\t\t\t\tHostPathRegexRewriteSubstitution: \"\\\\1\",\n\t\t\t},\n\t\t},\n\t}, \"example.com\")\n\trequire.NoError(t, err)\n\n\ttestutil.AssertProtoJSONEqual(t, `\n\t\t[\n\t\t\t{\n\t\t\t\t\"name\": \"policy-0\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-1\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-1\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"prefixRewrite\": \"/foo\",\n\t\t\t\t\t\"cluster\": \"policy-2\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-2\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"autoHostRewrite\": true,\n\t\t\t\t\t\"regexRewrite\": {\n\t\t\t\t\t\t\"pattern\": {\n\t\t\t\t\t\t\t\"googleRe2\": {},\n\t\t\t\t\t\t\t\"regex\": \"^/service/([^/]+)(/.*)$\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"substitution\": \"\\\\2/instance/\\\\1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"cluster\": \"policy-3\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-3\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"hostRewriteLiteral\": \"literal.example.com\",\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-4\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-4\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"hostRewriteHeader\": \"HOST_HEADER\",\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-5\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"policy-5\",\n\t\t\t\t\"match\": {\n\t\t\t\t\t\"prefix\": \"/\"\n\t\t\t\t},\n\t\t\t\t\"metadata\": {\n\t\t\t\t\t\"filterMetadata\": {\n\t\t\t\t\t\t\"envoy.filters.http.lua\": {\n\t\t\t\t\t\t\t\"remove_impersonate_headers\": false,\n\t\t\t\t\t\t\t\"remove_pomerium_authorization\": true,\n\t\t\t\t\t\t\t\"remove_pomerium_cookie\": \"pomerium\",\n\t\t\t\t\t\t\t\"rewrite_response_headers\": []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"route\": {\n\t\t\t\t\t\"hostRewritePathRegex\": {\n\t\t\t\t\t\t\"pattern\": {\n\t\t\t\t\t\t\t\"googleRe2\": {},\n\t\t\t\t\t\t\t\"regex\": \"^/(.+)/.+$\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"substitution\": \"\\\\1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"prefixRewrite\": \"/bar\",\n\t\t\t\t\t\"cluster\": \"policy-6\",\n\t\t\t\t\t\"hashPolicy\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"header\": {\n\t\t\t\t\t\t\t\t\"headerName\": \"x-pomerium-routing-key\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"connectionProperties\": {\n\t\t\t\t\t\t\t\t\"sourceIp\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"terminal\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"timeout\": \"3s\",\n\t\t\t\t\t\"upgradeConfigs\": [\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"websocket\"},\n\t\t\t\t\t\t{ \"enabled\": false, \"upgradeType\": \"spdy/3.1\"}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"requestHeadersToRemove\": [\n\t\t\t\t\t\"x-pomerium-reproxy-policy\",\n\t\t\t\t\t\"x-pomerium-reproxy-policy-hmac\"\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t`, routes)\n}\n\nfunc Test_buildPolicyRouteRedirectAction(t *testing.T) {\n\tb := &Builder{filemgr: filemgr.NewManager()}\n\tt.Run(\"HTTPSRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tHTTPSRedirect: proto.Bool(true),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tSchemeRewriteSpecifier: &envoy_config_route_v3.RedirectAction_HttpsRedirect{\n\t\t\t\tHttpsRedirect: true,\n\t\t\t},\n\t\t}, action)\n\n\t\taction, err = b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tHTTPSRedirect: proto.Bool(false),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tSchemeRewriteSpecifier: &envoy_config_route_v3.RedirectAction_HttpsRedirect{\n\t\t\t\tHttpsRedirect: false,\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"SchemeRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tSchemeRedirect: proto.String(\"https\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tSchemeRewriteSpecifier: &envoy_config_route_v3.RedirectAction_SchemeRedirect{\n\t\t\t\tSchemeRedirect: \"https\",\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"HostRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tHostRedirect: proto.String(\"HOST\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tHostRedirect: \"HOST\",\n\t\t}, action)\n\t})\n\tt.Run(\"PortRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tPortRedirect: proto.Uint32(1234),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tPortRedirect: 1234,\n\t\t}, action)\n\t})\n\tt.Run(\"PathRedirect\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tPathRedirect: proto.String(\"PATH\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tPathRewriteSpecifier: &envoy_config_route_v3.RedirectAction_PathRedirect{\n\t\t\t\tPathRedirect: \"PATH\",\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"PrefixRewrite\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tPrefixRewrite: proto.String(\"PREFIX_REWRITE\"),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tPathRewriteSpecifier: &envoy_config_route_v3.RedirectAction_PrefixRewrite{\n\t\t\t\tPrefixRewrite: \"PREFIX_REWRITE\",\n\t\t\t},\n\t\t}, action)\n\t})\n\tt.Run(\"ResponseCode\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tResponseCode: proto.Int32(301),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tResponseCode: 301,\n\t\t}, action)\n\t})\n\tt.Run(\"StripQuery\", func(t *testing.T) {\n\t\taction, err := b.buildPolicyRouteRedirectAction(&config.PolicyRedirect{\n\t\t\tStripQuery: proto.Bool(true),\n\t\t})\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, &envoy_config_route_v3.RedirectAction{\n\t\t\tStripQuery: true,\n\t\t}, action)\n\t})\n}\n\nfunc TestPolicyName(t *testing.T) {\n\t// policy names should form a unique ID when converted to envoy cluster names\n\t// however for metrics purposes we keep original name if present\n\tassert.NotEmpty(t, getClusterID(&config.Policy{}))\n\tassert.Empty(t, getClusterStatsName(&config.Policy{}))\n\tassert.True(t, strings.HasPrefix(getClusterID(&config.Policy{EnvoyOpts: &envoy_config_cluster_v3.Cluster{Name: \"my-pomerium-cluster\"}}), \"my-pomerium-cluster\"))\n\tassert.NotEqual(t, getClusterID(&config.Policy{EnvoyOpts: &envoy_config_cluster_v3.Cluster{Name: \"my-pomerium-cluster\"}}), \"my-pomerium-cluster\")\n\tassert.Equal(t, getClusterStatsName(&config.Policy{EnvoyOpts: &envoy_config_cluster_v3.Cluster{Name: \"my-pomerium-cluster\"}}), \"my-pomerium-cluster\")\n}\n\nfunc mustParseURL(t *testing.T, str string) *url.URL {\n\tu, err := url.Parse(str)\n\trequire.NoError(t, err, str)\n\treturn u\n}\n", "package config\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/middleware\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/metrics\"\n\n\t\"github.com/rs/zerolog\"\n)\n\n// A MetricsManager manages metrics for a given configuration.\ntype MetricsManager struct {\n\tmu                sync.RWMutex\n\tinstallationID    string\n\tserviceName       string\n\taddr              string\n\tbasicAuth         string\n\tenvoyAdminAddress string\n\thandler           http.Handler\n}\n\n// NewMetricsManager creates a new MetricsManager.\nfunc NewMetricsManager(ctx context.Context, src Source) *MetricsManager {\n\tctx = log.WithContext(ctx, func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"service\", \"metrics_manager\")\n\t})\n\tmgr := &MetricsManager{}\n\tmetrics.RegisterInfoMetrics()\n\tsrc.OnConfigChange(ctx, mgr.OnConfigChange)\n\tmgr.OnConfigChange(ctx, src.GetConfig())\n\treturn mgr\n}\n\n// Close closes any underlying http server.\nfunc (mgr *MetricsManager) Close() error {\n\treturn nil\n}\n\n// OnConfigChange updates the metrics manager when configuration is changed.\nfunc (mgr *MetricsManager) OnConfigChange(ctx context.Context, cfg *Config) {\n\tmgr.mu.Lock()\n\tdefer mgr.mu.Unlock()\n\n\tmgr.updateInfo(ctx, cfg)\n\tmgr.updateServer(ctx, cfg)\n}\n\nfunc (mgr *MetricsManager) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tmgr.mu.RLock()\n\tdefer mgr.mu.RUnlock()\n\n\tif mgr.handler == nil {\n\t\thttp.NotFound(w, r)\n\t\treturn\n\t}\n\tmgr.handler.ServeHTTP(w, r)\n}\n\nfunc (mgr *MetricsManager) updateInfo(ctx context.Context, cfg *Config) {\n\tserviceName := telemetry.ServiceName(cfg.Options.Services)\n\tif serviceName == mgr.serviceName {\n\t\treturn\n\t}\n\n\thostname, err := os.Hostname()\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"telemetry/metrics: failed to get OS hostname\")\n\t\thostname = \"__unknown__\"\n\t}\n\n\tmetrics.SetBuildInfo(serviceName, hostname, cfg.EnvoyVersion)\n\tmgr.serviceName = serviceName\n}\n\nfunc (mgr *MetricsManager) updateServer(ctx context.Context, cfg *Config) {\n\tif cfg.Options.MetricsAddr == mgr.addr &&\n\t\tcfg.Options.MetricsBasicAuth == mgr.basicAuth &&\n\t\tcfg.Options.InstallationID == mgr.installationID &&\n\t\tcfg.Options.EnvoyAdminAddress == mgr.envoyAdminAddress {\n\t\treturn\n\t}\n\n\tmgr.addr = cfg.Options.MetricsAddr\n\tmgr.basicAuth = cfg.Options.MetricsBasicAuth\n\tmgr.installationID = cfg.Options.InstallationID\n\tmgr.envoyAdminAddress = cfg.Options.EnvoyAdminAddress\n\tmgr.handler = nil\n\n\tif mgr.addr == \"\" {\n\t\tlog.Info(ctx).Msg(\"metrics: http server disabled\")\n\t\treturn\n\t}\n\n\tenvoyURL, err := url.Parse(\"http://\" + cfg.Options.EnvoyAdminAddress)\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"metrics: invalid envoy admin address, disabling\")\n\t\treturn\n\t}\n\n\thandler, err := metrics.PrometheusHandler(envoyURL, mgr.installationID)\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"metrics: failed to create prometheus handler\")\n\t\treturn\n\t}\n\n\tif username, password, ok := cfg.Options.GetMetricsBasicAuth(); ok {\n\t\thandler = middleware.RequireBasicAuth(username, password)(handler)\n\t}\n\n\tmgr.handler = handler\n}\n", "package config\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/mitchellh/mapstructure\"\n\t\"github.com/spf13/viper\"\n\t\"github.com/volatiletech/null/v9\"\n\n\t\"github.com/pomerium/pomerium/internal/directory/azure\"\n\t\"github.com/pomerium/pomerium/internal/directory/github\"\n\t\"github.com/pomerium/pomerium/internal/directory/gitlab\"\n\t\"github.com/pomerium/pomerium/internal/directory/google\"\n\t\"github.com/pomerium/pomerium/internal/directory/okta\"\n\t\"github.com/pomerium/pomerium/internal/directory/onelogin\"\n\t\"github.com/pomerium/pomerium/internal/hashutil\"\n\t\"github.com/pomerium/pomerium/internal/identity/oauth\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/metrics\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n\t\"github.com/pomerium/pomerium/pkg/cryptutil\"\n\t\"github.com/pomerium/pomerium/pkg/grpc/config\"\n)\n\n// DisableHeaderKey is the key used to check whether to disable setting header\nconst DisableHeaderKey = \"disable\"\n\nconst (\n\tidpCustomScopesDocLink = \"https://www.pomerium.io/reference/#identity-provider-scopes\"\n\tidpCustomScopesWarnMsg = \"config: using custom scopes may result in undefined behavior, see: \" + idpCustomScopesDocLink\n)\n\n// DefaultAlternativeAddr is the address used is two services are competing over\n// the same listener. Typically this is invisible to the end user (e.g. localhost)\n// gRPC server, or is used for healthchecks (authorize only service)\nconst DefaultAlternativeAddr = \":5443\"\n\n// The randomSharedKey is used if no shared key is supplied in all-in-one mode.\nvar randomSharedKey = cryptutil.NewBase64Key()\n\n// Options are the global environmental flags used to set up pomerium's services.\n// Use NewXXXOptions() methods for a safely initialized data structure.\ntype Options struct {\n\t// InstallationID is used to indicate a unique installation of pomerium. Useful for telemetry.\n\tInstallationID string `mapstructure:\"installation_id\" yaml:\"installation_id,omitempty\"`\n\n\t// Debug outputs human-readable logs to Stdout.\n\tDebug bool `mapstructure:\"pomerium_debug\" yaml:\"pomerium_debug,omitempty\"`\n\n\t// LogLevel sets the global override for log level. All Loggers will use at least this value.\n\t// Possible options are \"info\",\"warn\",\"debug\" and \"error\". Defaults to \"info\".\n\tLogLevel string `mapstructure:\"log_level\" yaml:\"log_level,omitempty\"`\n\n\t// ProxyLogLevel sets the log level for the proxy service.\n\t// Possible options are \"info\",\"warn\", and \"error\". Defaults to the value of `LogLevel`.\n\tProxyLogLevel string `mapstructure:\"proxy_log_level\" yaml:\"proxy_log_level,omitempty\"`\n\n\t// SharedKey is the shared secret authorization key used to mutually authenticate\n\t// requests between services.\n\tSharedKey string `mapstructure:\"shared_secret\" yaml:\"shared_secret,omitempty\"`\n\n\t// Services is a list enabled service mode. If none are selected, \"all\" is used.\n\t// Available options are : \"all\", \"authenticate\", \"proxy\".\n\tServices string `mapstructure:\"services\" yaml:\"services,omitempty\"`\n\n\t// Addr specifies the host and port on which the server should serve\n\t// HTTPS requests. If empty, \":443\" (localhost:443) is used.\n\tAddr string `mapstructure:\"address\" yaml:\"address,omitempty\"`\n\n\t// InsecureServer when enabled disables all transport security.\n\t// In this mode, Pomerium is susceptible to man-in-the-middle attacks.\n\t// This should be used only for testing.\n\tInsecureServer bool `mapstructure:\"insecure_server\" yaml:\"insecure_server,omitempty\"`\n\n\t// DNSLookupFamily is the DNS IP address resolution policy.\n\t// If this setting is not specified, the value defaults to AUTO.\n\tDNSLookupFamily string `mapstructure:\"dns_lookup_family\" yaml:\"dns_lookup_family,omitempty\"`\n\n\tCertificateFiles []certificateFilePair `mapstructure:\"certificates\" yaml:\"certificates,omitempty\"`\n\n\t// Cert and Key is the x509 certificate used to create the HTTPS server.\n\tCert string `mapstructure:\"certificate\" yaml:\"certificate,omitempty\"`\n\tKey  string `mapstructure:\"certificate_key\" yaml:\"certificate_key,omitempty\"`\n\n\t// CertFile and KeyFile is the x509 certificate used to hydrate TLSCertificate\n\tCertFile string `mapstructure:\"certificate_file\" yaml:\"certificate_file,omitempty\"`\n\tKeyFile  string `mapstructure:\"certificate_key_file\" yaml:\"certificate_key_file,omitempty\"`\n\n\t// HttpRedirectAddr, if set, specifies the host and port to run the HTTP\n\t// to HTTPS redirect server on. If empty, no redirect server is started.\n\tHTTPRedirectAddr string `mapstructure:\"http_redirect_addr\" yaml:\"http_redirect_addr,omitempty\"`\n\n\t// Timeout settings : https://github.com/pomerium/pomerium/issues/40\n\tReadTimeout  time.Duration `mapstructure:\"timeout_read\" yaml:\"timeout_read,omitempty\"`\n\tWriteTimeout time.Duration `mapstructure:\"timeout_write\" yaml:\"timeout_write,omitempty\"`\n\tIdleTimeout  time.Duration `mapstructure:\"timeout_idle\" yaml:\"timeout_idle,omitempty\"`\n\n\t// Policies define per-route configuration and access control policies.\n\tPolicies   []Policy `mapstructure:\"policy\"`\n\tPolicyFile string   `mapstructure:\"policy_file\" yaml:\"policy_file,omitempty\"`\n\tRoutes     []Policy `mapstructure:\"routes\"`\n\n\t// AdditionalPolicies are any additional policies added to the options.\n\tAdditionalPolicies []Policy `yaml:\"-\"`\n\n\t// AuthenticateURL represents the externally accessible http endpoints\n\t// used for authentication requests and callbacks\n\tAuthenticateURLString         string `mapstructure:\"authenticate_service_url\" yaml:\"authenticate_service_url,omitempty\"`\n\tAuthenticateInternalURLString string `mapstructure:\"authenticate_internal_service_url\" yaml:\"authenticate_internal_service_url,omitempty\"`\n\t// SignOutRedirectURL represents the url that  user will be redirected to after signing out.\n\tSignOutRedirectURLString string `mapstructure:\"signout_redirect_url\" yaml:\"signout_redirect_url,omitempty\"`\n\n\t// AuthenticateCallbackPath is the path to the HTTP endpoint that will\n\t// receive the response from your identity provider. The value must exactly\n\t// match one of the authorized redirect URIs for the OAuth 2.0 client.\n\t// Defaults to: `/oauth2/callback`\n\tAuthenticateCallbackPath string `mapstructure:\"authenticate_callback_path\" yaml:\"authenticate_callback_path,omitempty\"`\n\n\t// Session/Cookie management\n\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\n\tCookieName     string        `mapstructure:\"cookie_name\" yaml:\"cookie_name,omitempty\"`\n\tCookieSecret   string        `mapstructure:\"cookie_secret\" yaml:\"cookie_secret,omitempty\"`\n\tCookieDomain   string        `mapstructure:\"cookie_domain\" yaml:\"cookie_domain,omitempty\"`\n\tCookieSecure   bool          `mapstructure:\"cookie_secure\" yaml:\"cookie_secure,omitempty\"`\n\tCookieHTTPOnly bool          `mapstructure:\"cookie_http_only\" yaml:\"cookie_http_only,omitempty\"`\n\tCookieExpire   time.Duration `mapstructure:\"cookie_expire\" yaml:\"cookie_expire,omitempty\"`\n\n\t// Identity provider configuration variables as specified by RFC6749\n\t// https://openid.net/specs/openid-connect-basic-1_0.html#RFC6749\n\tClientID       string   `mapstructure:\"idp_client_id\" yaml:\"idp_client_id,omitempty\"`\n\tClientSecret   string   `mapstructure:\"idp_client_secret\" yaml:\"idp_client_secret,omitempty\"`\n\tProvider       string   `mapstructure:\"idp_provider\" yaml:\"idp_provider,omitempty\"`\n\tProviderURL    string   `mapstructure:\"idp_provider_url\" yaml:\"idp_provider_url,omitempty\"`\n\tScopes         []string `mapstructure:\"idp_scopes\" yaml:\"idp_scopes,omitempty\"`\n\tServiceAccount string   `mapstructure:\"idp_service_account\" yaml:\"idp_service_account,omitempty\"`\n\t// Identity provider refresh directory interval/timeout settings.\n\tRefreshDirectoryTimeout  time.Duration `mapstructure:\"idp_refresh_directory_timeout\" yaml:\"idp_refresh_directory_timeout,omitempty\"`\n\tRefreshDirectoryInterval time.Duration `mapstructure:\"idp_refresh_directory_interval\" yaml:\"idp_refresh_directory_interval,omitempty\"`\n\tQPS                      float64       `mapstructure:\"idp_qps\" yaml:\"idp_qps\"`\n\n\t// RequestParams are custom request params added to the signin request as\n\t// part of an Oauth2 code flow.\n\t//\n\t// https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml\n\t// https://openid.net/specs/openid-connect-basic-1_0.html#RequestParameters\n\tRequestParams map[string]string `mapstructure:\"idp_request_params\" yaml:\"idp_request_params,omitempty\"`\n\n\t// AuthorizeURLString is the routable destination of the authorize service's\n\t// gRPC endpoint. NOTE: As many load balancers do not support\n\t// externally routed gRPC so this may be an internal location.\n\tAuthorizeURLString         string   `mapstructure:\"authorize_service_url\" yaml:\"authorize_service_url,omitempty\"`\n\tAuthorizeURLStrings        []string `mapstructure:\"authorize_service_urls\" yaml:\"authorize_service_urls,omitempty\"`\n\tAuthorizeInternalURLString string   `mapstructure:\"authorize_internal_service_url\" yaml:\"authorize_internal_service_url,omitempty\"`\n\n\t// Settings to enable custom behind-the-ingress service communication\n\tOverrideCertificateName string `mapstructure:\"override_certificate_name\" yaml:\"override_certificate_name,omitempty\"`\n\tCA                      string `mapstructure:\"certificate_authority\" yaml:\"certificate_authority,omitempty\"`\n\tCAFile                  string `mapstructure:\"certificate_authority_file\" yaml:\"certificate_authority_file,omitempty\"`\n\n\t// SigningKey is the private key used to add a JWT-signature to upstream requests.\n\t// https://www.pomerium.io/docs/topics/getting-users-identity.html\n\tSigningKey string `mapstructure:\"signing_key\" yaml:\"signing_key,omitempty\"`\n\n\tHeadersEnv string `yaml:\",omitempty\"`\n\t// SetResponseHeaders to set on all proxied requests. Add a 'disable' key map to turn off.\n\tSetResponseHeaders map[string]string `yaml:\",omitempty\"`\n\n\t// List of JWT claims to insert as x-pomerium-claim-* headers on proxied requests\n\tJWTClaimsHeaders JWTClaimHeaders `mapstructure:\"jwt_claims_headers\" yaml:\"jwt_claims_headers,omitempty\"`\n\n\tDefaultUpstreamTimeout time.Duration `mapstructure:\"default_upstream_timeout\" yaml:\"default_upstream_timeout,omitempty\"`\n\n\t// Address/Port to bind to for prometheus metrics\n\tMetricsAddr string `mapstructure:\"metrics_address\" yaml:\"metrics_address,omitempty\"`\n\t// - require basic auth for prometheus metrics, base64 encoded user:pass string\n\tMetricsBasicAuth string `mapstructure:\"metrics_basic_auth\" yaml:\"metrics_basic_auth,omitempty\"`\n\t// - TLS options\n\tMetricsCertificate        string `mapstructure:\"metrics_certificate\" yaml:\"metrics_certificate,omitempty\"`\n\tMetricsCertificateKey     string `mapstructure:\"metrics_certificate_key\" yaml:\"metrics_certificate_key,omitempty\"`\n\tMetricsCertificateFile    string `mapstructure:\"metrics_certificate_file\" yaml:\"metrics_certificate_file,omitempty\"`\n\tMetricsCertificateKeyFile string `mapstructure:\"metrics_certificate_key_file\" yaml:\"metrics_certificate_key_file,omitempty\"`\n\tMetricsClientCA           string `mapstructure:\"metrics_client_ca\" yaml:\"metrics_client_ca,omitempty\"`\n\tMetricsClientCAFile       string `mapstructure:\"metrics_client_ca_file\" yaml:\"metrics_client_ca_file,omitempty\"`\n\n\t// Tracing shared settings\n\tTracingProvider   string  `mapstructure:\"tracing_provider\" yaml:\"tracing_provider,omitempty\"`\n\tTracingSampleRate float64 `mapstructure:\"tracing_sample_rate\" yaml:\"tracing_sample_rate,omitempty\"`\n\n\t// Datadog tracing address\n\tTracingDatadogAddress string `mapstructure:\"tracing_datadog_address\" yaml:\"tracing_datadog_address,omitempty\"`\n\n\t//  Jaeger\n\t//\n\t// CollectorEndpoint is the full url to the Jaeger HTTP Thrift collector.\n\t// For example, http://localhost:14268/api/traces\n\tTracingJaegerCollectorEndpoint string `mapstructure:\"tracing_jaeger_collector_endpoint\" yaml:\"tracing_jaeger_collector_endpoint,omitempty\"`\n\t// AgentEndpoint instructs exporter to send spans to jaeger-agent at this address.\n\t// For example, localhost:6831.\n\tTracingJaegerAgentEndpoint string `mapstructure:\"tracing_jaeger_agent_endpoint\" yaml:\"tracing_jaeger_agent_endpoint,omitempty\"`\n\n\t// Zipkin\n\t//\n\t// ZipkinEndpoint configures the zipkin collector URI\n\t// Example: http://zipkin:9411/api/v2/spans\n\tZipkinEndpoint string `mapstructure:\"tracing_zipkin_endpoint\" yaml:\"tracing_zipkin_endpoint\"`\n\n\t// GRPC Service Settings\n\n\t// GRPCAddr specifies the host and port on which the server should serve\n\t// gRPC requests. If running in all-in-one mode, \":5443\" (localhost:5443) is used.\n\tGRPCAddr string `mapstructure:\"grpc_address\" yaml:\"grpc_address,omitempty\"`\n\n\t// GRPCInsecure disables transport security.\n\t// If running in all-in-one mode, defaults to true.\n\tGRPCInsecure bool `mapstructure:\"grpc_insecure\" yaml:\"grpc_insecure,omitempty\"`\n\n\tGRPCClientTimeout       time.Duration `mapstructure:\"grpc_client_timeout\" yaml:\"grpc_client_timeout,omitempty\"`\n\tGRPCClientDNSRoundRobin bool          `mapstructure:\"grpc_client_dns_roundrobin\" yaml:\"grpc_client_dns_roundrobin,omitempty\"`\n\n\t// ForwardAuthEndpoint allows for a given route to be used as a forward-auth\n\t// endpoint instead of a reverse proxy. Some third-party proxies that do not\n\t// have rich access control capabilities (nginx, envoy, ambassador, traefik)\n\t// allow you to delegate and authenticate each request to your website\n\t// with an external server or service. Pomerium can be configured to accept\n\t// these requests with this switch\n\tForwardAuthURLString string `mapstructure:\"forward_auth_url\" yaml:\"forward_auth_url,omitempty\"`\n\n\t// DataBrokerURLString is the routable destination of the databroker service's gRPC endpiont.\n\tDataBrokerURLString         string   `mapstructure:\"databroker_service_url\" yaml:\"databroker_service_url,omitempty\"`\n\tDataBrokerURLStrings        []string `mapstructure:\"databroker_service_urls\" yaml:\"databroker_service_urls,omitempty\"`\n\tDataBrokerInternalURLString string   `mapstructure:\"databroker_internal_service_url\" yaml:\"databroker_internal_service_url,omitempty\"`\n\t// DataBrokerStorageType is the storage backend type that databroker will use.\n\t// Supported type: memory, redis\n\tDataBrokerStorageType string `mapstructure:\"databroker_storage_type\" yaml:\"databroker_storage_type,omitempty\"`\n\t// DataBrokerStorageConnectionString is the data source name for storage backend.\n\tDataBrokerStorageConnectionString string `mapstructure:\"databroker_storage_connection_string\" yaml:\"databroker_storage_connection_string,omitempty\"`\n\tDataBrokerStorageCertFile         string `mapstructure:\"databroker_storage_cert_file\" yaml:\"databroker_storage_cert_file,omitempty\"`\n\tDataBrokerStorageCertKeyFile      string `mapstructure:\"databroker_storage_key_file\" yaml:\"databroker_storage_key_file,omitempty\"`\n\tDataBrokerStorageCAFile           string `mapstructure:\"databroker_storage_ca_file\" yaml:\"databroker_storage_ca_file,omitempty\"`\n\tDataBrokerStorageCertSkipVerify   bool   `mapstructure:\"databroker_storage_tls_skip_verify\" yaml:\"databroker_storage_tls_skip_verify,omitempty\"`\n\n\t// ClientCA is the base64-encoded certificate authority to validate client mTLS certificates against.\n\tClientCA string `mapstructure:\"client_ca\" yaml:\"client_ca,omitempty\"`\n\t// ClientCAFile points to a file that contains the certificate authority to validate client mTLS certificates against.\n\tClientCAFile string `mapstructure:\"client_ca_file\" yaml:\"client_ca_file,omitempty\"`\n\t// ClientCRL is the base64-encoded certificate revocation list for client mTLS certificates.\n\tClientCRL string `mapstructure:\"client_crl\" yaml:\"client_crl,omitempty\"`\n\t// ClientCRLFile points to a file that contains the certificate revocation list for client mTLS certificates.\n\tClientCRLFile string `mapstructure:\"client_crl_file\" yaml:\"client_crl_file,omitempty\"`\n\n\t// GoogleCloudServerlessAuthenticationServiceAccount is the service account to use for GCP serverless authentication.\n\t// If unset, the GCP metadata server will be used to query for identity tokens.\n\tGoogleCloudServerlessAuthenticationServiceAccount string `mapstructure:\"google_cloud_serverless_authentication_service_account\" yaml:\"google_cloud_serverless_authentication_service_account,omitempty\"` //nolint\n\n\t// UseProxyProtocol configures the HTTP listener to require the HAProxy proxy protocol (either v1 or v2) on incoming requests.\n\tUseProxyProtocol bool `mapstructure:\"use_proxy_protocol\" yaml:\"use_proxy_protocol,omitempty\" json:\"use_proxy_protocol,omitempty\"`\n\n\tviper *viper.Viper\n\n\tAutocertOptions `mapstructure:\",squash\" yaml:\",inline\"`\n\n\t// SkipXffAppend instructs proxy not to append its IP address to x-forwarded-for header.\n\t// see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers.html?highlight=skip_xff_append#x-forwarded-for\n\tSkipXffAppend bool `mapstructure:\"skip_xff_append\" yaml:\"skip_xff_append,omitempty\" json:\"skip_xff_append,omitempty\"`\n\t// XffNumTrustedHops determines the trusted client address from x-forwarded-for addresses.\n\t// see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers.html?highlight=xff_num_trusted_hops#x-forwarded-for\n\tXffNumTrustedHops uint32 `mapstructure:\"xff_num_trusted_hops\" yaml:\"xff_num_trusted_hops,omitempty\" json:\"xff_num_trusted_hops,omitempty\"`\n\n\t// Envoy bootstrap options. These do not support dynamic updates.\n\tEnvoyAdminAccessLogPath      string    `mapstructure:\"envoy_admin_access_log_path\" yaml:\"envoy_admin_access_log_path\"`\n\tEnvoyAdminProfilePath        string    `mapstructure:\"envoy_admin_profile_path\" yaml:\"envoy_admin_profile_path\"`\n\tEnvoyAdminAddress            string    `mapstructure:\"envoy_admin_address\" yaml:\"envoy_admin_address\"`\n\tEnvoyBindConfigSourceAddress string    `mapstructure:\"envoy_bind_config_source_address\" yaml:\"envoy_bind_config_source_address,omitempty\"`\n\tEnvoyBindConfigFreebind      null.Bool `mapstructure:\"envoy_bind_config_freebind\" yaml:\"envoy_bind_config_freebind,omitempty\"`\n\n\t// ProgrammaticRedirectDomainWhitelist restricts the allowed redirect URLs when using programmatic login.\n\tProgrammaticRedirectDomainWhitelist []string `mapstructure:\"programmatic_redirect_domain_whitelist\" yaml:\"programmatic_redirect_domain_whitelist,omitempty\" json:\"programmatic_redirect_domain_whitelist,omitempty\"` //nolint\n\n\t// CodecType is the codec to use for downstream connections.\n\tCodecType CodecType `mapstructure:\"codec_type\" yaml:\"codec_type\"`\n\n\tAuditKey *PublicKeyEncryptionKeyOptions `mapstructure:\"audit_key\"`\n}\n\ntype certificateFilePair struct {\n\t// CertFile and KeyFile is the x509 certificate used to hydrate TLSCertificate\n\tCertFile string `mapstructure:\"cert\" yaml:\"cert,omitempty\"`\n\tKeyFile  string `mapstructure:\"key\" yaml:\"key,omitempty\"`\n}\n\n// DefaultOptions are the default configuration options for pomerium\nvar defaultOptions = Options{\n\tDebug:                  false,\n\tLogLevel:               \"info\",\n\tServices:               \"all\",\n\tCookieHTTPOnly:         true,\n\tCookieSecure:           true,\n\tCookieExpire:           14 * time.Hour,\n\tCookieName:             \"_pomerium\",\n\tDefaultUpstreamTimeout: 30 * time.Second,\n\tSetResponseHeaders: map[string]string{\n\t\t\"X-Frame-Options\":           \"SAMEORIGIN\",\n\t\t\"X-XSS-Protection\":          \"1; mode=block\",\n\t\t\"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains; preload\",\n\t},\n\tAddr:                     \":443\",\n\tReadTimeout:              30 * time.Second,\n\tWriteTimeout:             0, // support streaming by default\n\tIdleTimeout:              5 * time.Minute,\n\tGRPCAddr:                 \":443\",\n\tGRPCClientTimeout:        10 * time.Second, // Try to withstand transient service failures for a single request\n\tGRPCClientDNSRoundRobin:  true,\n\tAuthenticateCallbackPath: \"/oauth2/callback\",\n\tTracingSampleRate:        0.0001,\n\tRefreshDirectoryInterval: 10 * time.Minute,\n\tRefreshDirectoryTimeout:  1 * time.Minute,\n\tQPS:                      1.0,\n\n\tAutocertOptions: AutocertOptions{\n\t\tFolder: dataDir(),\n\t},\n\tDataBrokerStorageType:               \"memory\",\n\tSkipXffAppend:                       false,\n\tXffNumTrustedHops:                   0,\n\tEnvoyAdminAccessLogPath:             os.DevNull,\n\tEnvoyAdminProfilePath:               os.DevNull,\n\tEnvoyAdminAddress:                   \"127.0.0.1:9901\",\n\tProgrammaticRedirectDomainWhitelist: []string{\"localhost\"},\n}\n\n// NewDefaultOptions returns a copy the default options. It's the caller's\n// responsibility to do a follow up Validate call.\nfunc NewDefaultOptions() *Options {\n\tnewOpts := defaultOptions\n\tnewOpts.viper = viper.New()\n\treturn &newOpts\n}\n\n// newOptionsFromConfig builds the main binary's configuration options by parsing\n// environmental variables and config file\nfunc newOptionsFromConfig(configFile string) (*Options, error) {\n\to, err := optionsFromViper(configFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"config: options from config file %q: %w\", configFile, err)\n\t}\n\tserviceName := telemetry.ServiceName(o.Services)\n\tmetrics.AddPolicyCountCallback(serviceName, func() int64 {\n\t\treturn int64(len(o.GetAllPolicies()))\n\t})\n\n\treturn o, nil\n}\n\nfunc optionsFromViper(configFile string) (*Options, error) {\n\t// start a copy of the default options\n\to := NewDefaultOptions()\n\tv := o.viper\n\t// Load up config\n\terr := bindEnvs(o, v)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to bind options to env vars: %w\", err)\n\t}\n\n\tif configFile != \"\" {\n\t\tv.SetConfigFile(configFile)\n\t\tif err := v.ReadInConfig(); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read config: %w\", err)\n\t\t}\n\t}\n\n\tvar metadata mapstructure.Metadata\n\tif err := v.Unmarshal(o, ViperPolicyHooks, func(c *mapstructure.DecoderConfig) { c.Metadata = &metadata }); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal config: %w\", err)\n\t}\n\tcheckUnusedConfigFields(configFile, metadata.Unused)\n\n\t// This is necessary because v.Unmarshal will overwrite .viper field.\n\to.viper = v\n\n\tif err := o.Validate(); err != nil {\n\t\treturn nil, fmt.Errorf(\"validation error %w\", err)\n\t}\n\treturn o, nil\n}\n\nfunc checkUnusedConfigFields(configFile string, unused []string) {\n\tkeys := make([]string, 0, len(unused))\n\tfor _, k := range unused {\n\t\tif !strings.HasPrefix(k, \"policy[\") { // policy's embedded protobuf structs are decoded by separate hook and are unknown to mapstructure\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\tif len(keys) == 0 {\n\t\treturn\n\t}\n\tlog.Warn(context.Background()).Str(\"config_file\", configFile).Strs(\"keys\", keys).Msg(\"config contained unknown keys that were ignored\")\n}\n\n// parsePolicy initializes policy to the options from either base64 environmental\n// variables or from a file\nfunc (o *Options) parsePolicy() error {\n\tvar policies []Policy\n\tif err := o.viper.UnmarshalKey(\"policy\", &policies, ViperPolicyHooks); err != nil {\n\t\treturn err\n\t}\n\tif len(policies) != 0 {\n\t\to.Policies = policies\n\t}\n\n\tvar routes []Policy\n\tif err := o.viper.UnmarshalKey(\"routes\", &routes, ViperPolicyHooks); err != nil {\n\t\treturn err\n\t}\n\tif len(routes) != 0 {\n\t\to.Routes = routes\n\t}\n\n\t// Finish initializing policies\n\tfor i := range o.Policies {\n\t\tp := &o.Policies[i]\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor i := range o.Routes {\n\t\tp := &o.Routes[i]\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor i := range o.AdditionalPolicies {\n\t\tp := &o.AdditionalPolicies[i]\n\t\tif err := p.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (o *Options) viperSet(key string, value interface{}) {\n\to.viper.Set(key, value)\n}\n\nfunc (o *Options) viperIsSet(key string) bool {\n\treturn o.viper.IsSet(key)\n}\n\n// parseHeaders handles unmarshalling any custom headers correctly from the\n// environment or viper's parsed keys\nfunc (o *Options) parseHeaders(ctx context.Context) error {\n\tvar headers map[string]string\n\tif o.HeadersEnv != \"\" {\n\t\t// Handle JSON by default via viper\n\t\tif headers = o.viper.GetStringMapString(\"HeadersEnv\"); len(headers) == 0 {\n\t\t\t// Try to parse \"Key1:Value1,Key2:Value2\" syntax\n\t\t\theaderSlice := strings.Split(o.HeadersEnv, \",\")\n\t\t\tfor n := range headerSlice {\n\t\t\t\theaderFields := strings.SplitN(headerSlice[n], \":\", 2)\n\t\t\t\tif len(headerFields) == 2 {\n\t\t\t\t\theaders[headerFields[0]] = headerFields[1]\n\t\t\t\t} else {\n\t\t\t\t\t// Something went wrong\n\t\t\t\t\treturn fmt.Errorf(\"failed to decode headers from '%s'\", o.HeadersEnv)\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\to.SetResponseHeaders = headers\n\t\treturn nil\n\t}\n\n\tif o.viperIsSet(\"set_response_headers\") {\n\t\tif err := o.viper.UnmarshalKey(\"set_response_headers\", &headers); err != nil {\n\t\t\treturn fmt.Errorf(\"header %s failed to parse: %w\", o.viper.Get(\"set_response_headers\"), err)\n\t\t}\n\t\to.SetResponseHeaders = headers\n\t}\n\treturn nil\n}\n\n// bindEnvs binds a viper instance to each env var of an Options struct based\n// on the mapstructure tag\nfunc bindEnvs(o *Options, v *viper.Viper) error {\n\ttagName := `mapstructure`\n\tt := reflect.TypeOf(*o)\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tenvName := field.Tag.Get(tagName)\n\t\terr := v.BindEnv(envName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to bind field '%s' to env var '%s': %w\", field.Name, envName, err)\n\t\t}\n\n\t}\n\n\t// Statically bind fields\n\terr := v.BindEnv(\"Policy\", \"POLICY\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to bind field 'Policy' to env var 'POLICY': %w\", err)\n\t}\n\terr = v.BindEnv(\"HeadersEnv\", \"HEADERS\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to bind field 'HeadersEnv' to env var 'HEADERS': %w\", err)\n\t}\n\t// autocert options\n\tao := reflect.TypeOf(o.AutocertOptions)\n\tfor i := 0; i < ao.NumField(); i++ {\n\t\tfield := ao.Field(i)\n\t\tenvName := field.Tag.Get(tagName)\n\t\terr := v.BindEnv(envName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to bind field '%s' to env var '%s': %w\", field.Name, envName, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Validate ensures the Options fields are valid, and hydrated.\nfunc (o *Options) Validate() error {\n\tctx := context.TODO()\n\tif !IsValidService(o.Services) {\n\t\treturn fmt.Errorf(\"config: %s is an invalid service type\", o.Services)\n\t}\n\n\tswitch o.DataBrokerStorageType {\n\tcase StorageInMemoryName:\n\tcase StorageRedisName:\n\t\tif o.DataBrokerStorageConnectionString == \"\" {\n\t\t\treturn errors.New(\"config: missing databroker storage backend dsn\")\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"config: unknown databroker storage backend type\")\n\t}\n\n\t_, err := o.GetSharedKey()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"config: invalid shared secret: %w\", err)\n\t}\n\n\tif o.AuthenticateURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthenticateURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authenticate-url %s : %w\", o.AuthenticateURLString, err)\n\t\t}\n\t}\n\tif o.AuthenticateInternalURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthenticateInternalURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authenticate-internal-url %s : %w\", o.AuthenticateInternalURLString, err)\n\t\t}\n\t}\n\n\tif o.SignOutRedirectURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.SignOutRedirectURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad signout-redirect-url %s : %w\", o.SignOutRedirectURLString, err)\n\t\t}\n\t}\n\n\tif o.AuthorizeURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthorizeURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authorize-url %s : %w\", o.AuthorizeURLString, err)\n\t\t}\n\t}\n\tif o.AuthorizeInternalURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.AuthorizeInternalURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad authorize-internal-url %s : %w\", o.AuthorizeInternalURLString, err)\n\t\t}\n\t}\n\n\tif o.DataBrokerURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.DataBrokerURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker service url %s : %w\", o.DataBrokerURLString, err)\n\t\t}\n\t}\n\tif o.DataBrokerInternalURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.DataBrokerInternalURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker internal service url %s : %w\", o.DataBrokerInternalURLString, err)\n\t\t}\n\t}\n\n\tif o.ForwardAuthURLString != \"\" {\n\t\t_, err := urlutil.ParseAndValidateURL(o.ForwardAuthURLString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad forward-auth-url %s : %w\", o.ForwardAuthURLString, err)\n\t\t}\n\t}\n\n\tif o.PolicyFile != \"\" {\n\t\treturn errors.New(\"config: policy file setting is deprecated\")\n\t}\n\tif err := o.parsePolicy(); err != nil {\n\t\treturn fmt.Errorf(\"config: failed to parse policy: %w\", err)\n\t}\n\n\tif err := o.parseHeaders(ctx); err != nil {\n\t\treturn fmt.Errorf(\"config: failed to parse headers: %w\", err)\n\t}\n\n\thasCert := false\n\n\tif o.Cert != \"\" || o.Key != \"\" {\n\t\t_, err := cryptutil.CertificateFromBase64(o.Cert, o.Key)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad cert base64 %w\", err)\n\t\t}\n\t\thasCert = true\n\t}\n\n\tfor _, c := range o.CertificateFiles {\n\t\t_, err := cryptutil.CertificateFromBase64(c.CertFile, c.KeyFile)\n\t\tif err != nil {\n\t\t\t_, err = cryptutil.CertificateFromFile(c.CertFile, c.KeyFile)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad cert entry, base64 or file reference invalid. %w\", err)\n\t\t}\n\t\thasCert = true\n\t}\n\n\tif o.CertFile != \"\" || o.KeyFile != \"\" {\n\t\t_, err := cryptutil.CertificateFromFile(o.CertFile, o.KeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad cert file %w\", err)\n\t\t}\n\t\thasCert = true\n\t}\n\n\tif o.DataBrokerStorageCertFile != \"\" || o.DataBrokerStorageCertKeyFile != \"\" {\n\t\t_, err := cryptutil.CertificateFromFile(o.DataBrokerStorageCertFile, o.DataBrokerStorageCertKeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker cert file %w\", err)\n\t\t}\n\t}\n\n\tif o.DataBrokerStorageCAFile != \"\" {\n\t\tif _, err := os.Stat(o.DataBrokerStorageCAFile); err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad databroker ca file: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCA != \"\" {\n\t\tif _, err := base64.StdEncoding.DecodeString(o.ClientCA); err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client ca base64: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCAFile != \"\" {\n\t\t_, err := os.ReadFile(o.ClientCAFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client ca file: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCRL != \"\" {\n\t\t_, err = cryptutil.CRLFromBase64(o.ClientCRL)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client crl base64: %w\", err)\n\t\t}\n\t}\n\n\tif o.ClientCRLFile != \"\" {\n\t\t_, err = cryptutil.CRLFromFile(o.ClientCRLFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: bad client crl file: %w\", err)\n\t\t}\n\t}\n\n\t// if no service account was defined, there should not be any policies that\n\t// assert group membership (except for azure which can be derived from the client\n\t// id, secret and provider url)\n\tif o.ServiceAccount == \"\" && o.Provider != \"azure\" {\n\t\tfor _, p := range o.GetAllPolicies() {\n\t\t\tif len(p.AllowedGroups) != 0 {\n\t\t\t\treturn fmt.Errorf(\"config: `allowed_groups` requires `idp_service_account`\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// strip quotes from redirect address (#811)\n\to.HTTPRedirectAddr = strings.Trim(o.HTTPRedirectAddr, `\"'`)\n\n\tif !o.InsecureServer && !hasCert && !o.AutocertOptions.Enable {\n\t\tlog.Warn(ctx).Msg(\"neither `autocert`, \" +\n\t\t\t\"`insecure_server` or manually provided certificates were provided, server will be using a self-signed certificate\")\n\t}\n\n\tswitch o.Provider {\n\tcase azure.Name, github.Name, gitlab.Name, google.Name, okta.Name, onelogin.Name:\n\t\tif len(o.Scopes) > 0 {\n\t\t\tlog.Warn(ctx).Msg(idpCustomScopesWarnMsg)\n\t\t}\n\tdefault:\n\t}\n\n\tif err := ValidateDNSLookupFamily(o.DNSLookupFamily); err != nil {\n\t\treturn fmt.Errorf(\"config: %w\", err)\n\t}\n\n\tif o.MetricsAddr != \"\" {\n\t\tif err := ValidateMetricsAddress(o.MetricsAddr); err != nil {\n\t\t\treturn fmt.Errorf(\"config: invalid metrics_addr: %w\", err)\n\t\t}\n\t}\n\n\t// validate metrics basic auth\n\tif o.MetricsBasicAuth != \"\" {\n\t\tstr, err := base64.StdEncoding.DecodeString(o.MetricsBasicAuth)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: metrics_basic_auth must be a base64 encoded string\")\n\t\t}\n\n\t\tif !strings.Contains(string(str), \":\") {\n\t\t\treturn fmt.Errorf(\"config: metrics_basic_auth should contain a user name and password separated by a colon\")\n\t\t}\n\t}\n\n\tif o.MetricsCertificate != \"\" && o.MetricsCertificateKey != \"\" {\n\t\t_, err := cryptutil.CertificateFromBase64(o.MetricsCertificate, o.MetricsCertificateKey)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: invalid metrics_certificate or metrics_certificate_key: %w\", err)\n\t\t}\n\t}\n\n\tif o.MetricsCertificateFile != \"\" && o.MetricsCertificateKeyFile != \"\" {\n\t\t_, err := cryptutil.CertificateFromFile(o.MetricsCertificateFile, o.MetricsCertificateKeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"config: invalid metrics_certificate_file or metrics_certificate_key_file: %w\", err)\n\t\t}\n\t}\n\n\t// validate the Autocert options\n\terr = o.AutocertOptions.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// GetAuthenticateURL returns the AuthenticateURL in the options or 127.0.0.1.\nfunc (o *Options) GetAuthenticateURL() (*url.URL, error) {\n\trawurl := o.AuthenticateURLString\n\tif rawurl == \"\" {\n\t\trawurl = \"https://127.0.0.1\"\n\t}\n\treturn urlutil.ParseAndValidateURL(rawurl)\n}\n\n// GetInternalAuthenticateURL returns the internal AuthenticateURL in the options or the AuthenticateURL.\nfunc (o *Options) GetInternalAuthenticateURL() (*url.URL, error) {\n\trawurl := o.AuthenticateInternalURLString\n\tif rawurl == \"\" {\n\t\treturn o.GetAuthenticateURL()\n\t}\n\treturn urlutil.ParseAndValidateURL(o.AuthenticateInternalURLString)\n}\n\n// GetAuthorizeURLs returns the AuthorizeURLs in the options or 127.0.0.1:5443.\nfunc (o *Options) GetAuthorizeURLs() ([]*url.URL, error) {\n\tif IsAll(o.Services) && o.AuthorizeURLString == \"\" && len(o.AuthorizeURLStrings) == 0 {\n\t\tu, err := urlutil.ParseAndValidateURL(\"http://127.0.0.1\" + DefaultAlternativeAddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn []*url.URL{u}, nil\n\t}\n\treturn o.getURLs(append([]string{o.AuthorizeURLString}, o.AuthorizeURLStrings...)...)\n}\n\n// GetInternalAuthorizeURLs returns the internal AuthorizeURLs in the options or the AuthorizeURLs.\nfunc (o *Options) GetInternalAuthorizeURLs() ([]*url.URL, error) {\n\trawurl := o.AuthorizeInternalURLString\n\tif rawurl == \"\" {\n\t\treturn o.GetAuthorizeURLs()\n\t}\n\treturn o.getURLs(rawurl)\n}\n\n// GetDataBrokerURLs returns the DataBrokerURLs in the options or 127.0.0.1:5443.\nfunc (o *Options) GetDataBrokerURLs() ([]*url.URL, error) {\n\tif IsAll(o.Services) && o.DataBrokerURLString == \"\" && len(o.DataBrokerURLStrings) == 0 {\n\t\tu, err := urlutil.ParseAndValidateURL(\"http://127.0.0.1\" + DefaultAlternativeAddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn []*url.URL{u}, nil\n\t}\n\treturn o.getURLs(append([]string{o.DataBrokerURLString}, o.DataBrokerURLStrings...)...)\n}\n\n// GetInternalDataBrokerURLs returns the internal DataBrokerURLs in the options or the DataBrokerURLs.\nfunc (o *Options) GetInternalDataBrokerURLs() ([]*url.URL, error) {\n\trawurl := o.DataBrokerInternalURLString\n\tif rawurl == \"\" {\n\t\treturn o.GetDataBrokerURLs()\n\t}\n\treturn o.getURLs(rawurl)\n}\n\nfunc (o *Options) getURLs(strs ...string) ([]*url.URL, error) {\n\tvar urls []*url.URL\n\tif o != nil {\n\t\tfor _, str := range strs {\n\t\t\tif str == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tu, err := urlutil.ParseAndValidateURL(str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\turls = append(urls, u)\n\t\t}\n\t}\n\tif len(urls) == 0 {\n\t\tu, _ := url.Parse(\"http://127.0.0.1\" + DefaultAlternativeAddr)\n\t\turls = append(urls, u)\n\t}\n\treturn urls, nil\n}\n\n// GetForwardAuthURL returns the ForwardAuthURL.\nfunc (o *Options) GetForwardAuthURL() (*url.URL, error) {\n\trawurl := o.ForwardAuthURLString\n\tif rawurl == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn urlutil.ParseAndValidateURL(rawurl)\n}\n\n// GetGRPCAddr gets the gRPC address.\nfunc (o *Options) GetGRPCAddr() string {\n\t// to avoid port collision when running on localhost\n\tif IsAll(o.Services) && o.GRPCAddr == defaultOptions.GRPCAddr {\n\t\treturn DefaultAlternativeAddr\n\t}\n\treturn o.GRPCAddr\n}\n\n// GetGRPCInsecure gets whether or not gRPC is insecure.\nfunc (o *Options) GetGRPCInsecure() bool {\n\tif IsAll(o.Services) {\n\t\treturn true\n\t}\n\treturn o.GRPCInsecure\n}\n\n// GetSignOutRedirectURL gets the SignOutRedirectURL.\nfunc (o *Options) GetSignOutRedirectURL() (*url.URL, error) {\n\trawurl := o.SignOutRedirectURLString\n\tif rawurl == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn urlutil.ParseAndValidateURL(rawurl)\n}\n\n// GetMetricsCertificate returns the metrics certificate to use for TLS. `nil` will be\n// returned if there is no certificate.\nfunc (o *Options) GetMetricsCertificate() (*tls.Certificate, error) {\n\tif o.MetricsCertificate != \"\" && o.MetricsCertificateKey != \"\" {\n\t\treturn cryptutil.CertificateFromBase64(o.MetricsCertificate, o.MetricsCertificateKey)\n\t}\n\tif o.MetricsCertificateFile != \"\" && o.MetricsCertificateKeyFile != \"\" {\n\t\treturn cryptutil.CertificateFromFile(o.MetricsCertificateFile, o.MetricsCertificateKeyFile)\n\t}\n\treturn nil, nil\n}\n\n// GetOauthOptions gets the oauth.Options for the given config options.\nfunc (o *Options) GetOauthOptions() (oauth.Options, error) {\n\tredirectURL, err := o.GetAuthenticateURL()\n\tif err != nil {\n\t\treturn oauth.Options{}, err\n\t}\n\tredirectURL = redirectURL.ResolveReference(&url.URL{\n\t\tPath: o.AuthenticateCallbackPath,\n\t})\n\treturn oauth.Options{\n\t\tRedirectURL:    redirectURL,\n\t\tProviderName:   o.Provider,\n\t\tProviderURL:    o.ProviderURL,\n\t\tClientID:       o.ClientID,\n\t\tClientSecret:   o.ClientSecret,\n\t\tScopes:         o.Scopes,\n\t\tServiceAccount: o.ServiceAccount,\n\t}, nil\n}\n\n// GetAllPolicies gets all the policies in the options.\nfunc (o *Options) GetAllPolicies() []Policy {\n\tif o == nil {\n\t\treturn nil\n\t}\n\tpolicies := make([]Policy, 0, len(o.Policies)+len(o.Routes)+len(o.AdditionalPolicies))\n\tpolicies = append(policies, o.Policies...)\n\tpolicies = append(policies, o.Routes...)\n\tpolicies = append(policies, o.AdditionalPolicies...)\n\treturn policies\n}\n\n// GetMetricsBasicAuth gets the metrics basic auth username and password.\nfunc (o *Options) GetMetricsBasicAuth() (username, password string, ok bool) {\n\tif o.MetricsBasicAuth == \"\" {\n\t\treturn \"\", \"\", false\n\t}\n\n\tbs, err := base64.StdEncoding.DecodeString(o.MetricsBasicAuth)\n\tif err != nil {\n\t\treturn \"\", \"\", false\n\t}\n\n\tidx := bytes.Index(bs, []byte{':'})\n\tif idx == -1 {\n\t\treturn \"\", \"\", false\n\t}\n\n\treturn string(bs[:idx]), string(bs[idx+1:]), true\n}\n\n// GetClientCA returns the client certificate authority. If neither client_ca nor client_ca_file is specified nil will\n// be returned.\nfunc (o *Options) GetClientCA() ([]byte, error) {\n\tif o.ClientCA != \"\" {\n\t\treturn base64.StdEncoding.DecodeString(o.ClientCA)\n\t}\n\tif o.ClientCAFile != \"\" {\n\t\treturn os.ReadFile(o.ClientCAFile)\n\t}\n\treturn nil, nil\n}\n\n// GetDataBrokerCertificate gets the optional databroker certificate. This method will return nil if no certificate is\n// specified.\nfunc (o *Options) GetDataBrokerCertificate() (*tls.Certificate, error) {\n\tif o.DataBrokerStorageCertFile == \"\" || o.DataBrokerStorageCertKeyFile == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn cryptutil.CertificateFromFile(o.DataBrokerStorageCertFile, o.DataBrokerStorageCertKeyFile)\n}\n\n// GetCertificates gets all the certificates from the options.\nfunc (o *Options) GetCertificates() ([]tls.Certificate, error) {\n\tvar certs []tls.Certificate\n\tif o.Cert != \"\" && o.Key != \"\" {\n\t\tcert, err := cryptutil.CertificateFromBase64(o.Cert, o.Key)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config: invalid base64 certificate: %w\", err)\n\t\t}\n\t\tcerts = append(certs, *cert)\n\t}\n\tfor _, c := range o.CertificateFiles {\n\t\tcert, err := cryptutil.CertificateFromBase64(c.CertFile, c.KeyFile)\n\t\tif err != nil {\n\t\t\tcert, err = cryptutil.CertificateFromFile(c.CertFile, c.KeyFile)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config: invalid certificate entry: %w\", err)\n\t\t}\n\t\tcerts = append(certs, *cert)\n\t}\n\tif o.CertFile != \"\" && o.KeyFile != \"\" {\n\t\tcert, err := cryptutil.CertificateFromFile(o.CertFile, o.KeyFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config: bad cert file %w\", err)\n\t\t}\n\t\tcerts = append(certs, *cert)\n\t}\n\treturn certs, nil\n}\n\n// GetSharedKey gets the decoded shared key.\nfunc (o *Options) GetSharedKey() ([]byte, error) {\n\tsharedKey := o.SharedKey\n\t// mutual auth between services on the same host can be generated at runtime\n\tif IsAll(o.Services) && o.SharedKey == \"\" && o.DataBrokerStorageType == StorageInMemoryName {\n\t\tsharedKey = randomSharedKey\n\t}\n\tif sharedKey == \"\" {\n\t\treturn nil, errors.New(\"empty shared secret\")\n\t}\n\tif strings.TrimSpace(sharedKey) != sharedKey {\n\t\treturn nil, errors.New(\"shared secret contains whitespace\")\n\t}\n\treturn base64.StdEncoding.DecodeString(sharedKey)\n}\n\n// GetGoogleCloudServerlessAuthenticationServiceAccount gets the GoogleCloudServerlessAuthenticationServiceAccount.\nfunc (o *Options) GetGoogleCloudServerlessAuthenticationServiceAccount() string {\n\tif o.GoogleCloudServerlessAuthenticationServiceAccount == \"\" && o.Provider == \"google\" {\n\t\treturn o.ServiceAccount\n\t}\n\treturn o.GoogleCloudServerlessAuthenticationServiceAccount\n}\n\n// GetSetResponseHeaders gets the SetResponseHeaders.\nfunc (o *Options) GetSetResponseHeaders() map[string]string {\n\tif _, ok := o.SetResponseHeaders[DisableHeaderKey]; ok {\n\t\treturn map[string]string{}\n\t}\n\treturn o.SetResponseHeaders\n}\n\n// GetQPS gets the QPS.\nfunc (o *Options) GetQPS() float64 {\n\tif o.QPS < 1 {\n\t\treturn 1\n\t}\n\treturn o.QPS\n}\n\n// GetCodecType gets a codec type.\nfunc (o *Options) GetCodecType() CodecType {\n\tif o.CodecType == CodecTypeUnset {\n\t\tif IsAll(o.Services) {\n\t\t\treturn CodecTypeHTTP1\n\t\t}\n\t\treturn CodecTypeAuto\n\t}\n\treturn o.CodecType\n}\n\n// GetAllRouteableGRPCDomains returns all the possible gRPC domains handled by the Pomerium options.\nfunc (o *Options) GetAllRouteableGRPCDomains() ([]string, error) {\n\tlookup := map[string]struct{}{}\n\n\t// authorize urls\n\tif IsAll(o.Services) {\n\t\tauthorizeURLs, err := o.GetAuthorizeURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range authorizeURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t} else if IsAuthorize(o.Services) {\n\t\tauthorizeURLs, err := o.GetInternalAuthorizeURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range authorizeURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\t// databroker urls\n\tif IsAll(o.Services) {\n\t\tdataBrokerURLs, err := o.GetDataBrokerURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range dataBrokerURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t} else if IsDataBroker(o.Services) {\n\t\tdataBrokerURLs, err := o.GetInternalDataBrokerURLs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, u := range dataBrokerURLs {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*u) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\tdomains := make([]string, 0, len(lookup))\n\tfor domain := range lookup {\n\t\tdomains = append(domains, domain)\n\t}\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\n// GetAllRouteableHTTPDomains returns all the possible HTTP domains handled by the Pomerium options.\nfunc (o *Options) GetAllRouteableHTTPDomains() ([]string, error) {\n\tforwardAuthURL, err := o.GetForwardAuthURL()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlookup := map[string]struct{}{}\n\tif IsAuthenticate(o.Services) {\n\t\tauthenticateURL, err := o.GetInternalAuthenticateURL()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, h := range urlutil.GetDomainsForURL(*authenticateURL) {\n\t\t\tlookup[h] = struct{}{}\n\t\t}\n\t}\n\n\t// policy urls\n\tif IsProxy(o.Services) {\n\t\tfor _, policy := range o.GetAllPolicies() {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*policy.Source.URL) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tif forwardAuthURL != nil {\n\t\t\tfor _, h := range urlutil.GetDomainsForURL(*forwardAuthURL) {\n\t\t\t\tlookup[h] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\tdomains := make([]string, 0, len(lookup))\n\tfor domain := range lookup {\n\t\tdomains = append(domains, domain)\n\t}\n\tsort.Strings(domains)\n\n\treturn domains, nil\n}\n\n// Checksum returns the checksum of the current options struct\nfunc (o *Options) Checksum() uint64 {\n\treturn hashutil.MustHash(o)\n}\n\nfunc (o Options) indexCerts(ctx context.Context) certsIndex {\n\tidx := make(certsIndex)\n\n\tif o.CertFile != \"\" {\n\t\tcert, err := cryptutil.ParsePEMCertificateFromFile(o.CertFile)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Str(\"file\", o.CertFile).Msg(\"parsing local cert: skipped\")\n\t\t} else {\n\t\t\tidx.addCert(cert)\n\t\t}\n\t} else if o.Cert != \"\" {\n\t\tif data, err := base64.StdEncoding.DecodeString(o.Cert); err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"bad base64 for local cert: skipped\")\n\t\t} else if cert, err := cryptutil.ParsePEMCertificate(data); err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"parsing local cert: skipped\")\n\t\t} else {\n\t\t\tidx.addCert(cert)\n\t\t}\n\t}\n\n\tfor _, c := range o.CertificateFiles {\n\t\tcert, err := cryptutil.ParsePEMCertificateFromFile(c.CertFile)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Str(\"file\", c.CertFile).Msg(\"parsing local cert: skipped\")\n\t\t} else {\n\t\t\tidx.addCert(cert)\n\t\t}\n\t}\n\treturn idx\n}\n\nfunc (o *Options) applyExternalCerts(ctx context.Context, certs []*config.Settings_Certificate) {\n\tidx := o.indexCerts(ctx)\n\tfor _, c := range certs {\n\t\tcert, err := cryptutil.ParsePEMCertificate(c.CertBytes)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"parsing cert from databroker: skipped\")\n\t\t\tcontinue\n\t\t}\n\t\tif overlaps, name := idx.matchCert(cert); overlaps {\n\t\t\tlog.Error(ctx).Err(err).Str(\"domain\", name).Msg(\"overlaps with local certs: skipped\")\n\t\t\tcontinue\n\t\t}\n\t\tcfp := certificateFilePair{\n\t\t\tCertFile: c.CertFile,\n\t\t\tKeyFile:  c.KeyFile,\n\t\t}\n\t\tif cfp.CertFile == \"\" {\n\t\t\tcfp.CertFile = base64.StdEncoding.EncodeToString(c.CertBytes)\n\t\t}\n\t\tif cfp.KeyFile == \"\" {\n\t\t\tcfp.KeyFile = base64.StdEncoding.EncodeToString(c.KeyBytes)\n\t\t}\n\t\to.CertificateFiles = append(o.CertificateFiles, cfp)\n\t}\n}\n\n// ApplySettings modifies the config options using the given protobuf settings.\nfunc (o *Options) ApplySettings(ctx context.Context, settings *config.Settings) {\n\tif settings == nil {\n\t\treturn\n\t}\n\n\tif settings.InstallationId != nil {\n\t\to.InstallationID = settings.GetInstallationId()\n\t}\n\tif settings.Debug != nil {\n\t\to.Debug = settings.GetDebug()\n\t}\n\tif settings.LogLevel != nil {\n\t\to.LogLevel = settings.GetLogLevel()\n\t}\n\tif settings.ProxyLogLevel != nil {\n\t\to.ProxyLogLevel = settings.GetProxyLogLevel()\n\t}\n\tif settings.SharedSecret != nil {\n\t\to.SharedKey = settings.GetSharedSecret()\n\t}\n\tif settings.Services != nil {\n\t\to.Services = settings.GetServices()\n\t}\n\tif settings.Address != nil {\n\t\to.Addr = settings.GetAddress()\n\t}\n\tif settings.InsecureServer != nil {\n\t\to.InsecureServer = settings.GetInsecureServer()\n\t}\n\tif settings.DnsLookupFamily != nil {\n\t\to.DNSLookupFamily = settings.GetDnsLookupFamily()\n\t}\n\to.applyExternalCerts(ctx, settings.GetCertificates())\n\tif settings.HttpRedirectAddr != nil {\n\t\to.HTTPRedirectAddr = settings.GetHttpRedirectAddr()\n\t}\n\tif settings.TimeoutRead != nil {\n\t\to.ReadTimeout = settings.GetTimeoutRead().AsDuration()\n\t}\n\tif settings.TimeoutWrite != nil {\n\t\to.WriteTimeout = settings.GetTimeoutWrite().AsDuration()\n\t}\n\tif settings.TimeoutIdle != nil {\n\t\to.IdleTimeout = settings.GetTimeoutIdle().AsDuration()\n\t}\n\tif settings.AuthenticateServiceUrl != nil {\n\t\to.AuthenticateURLString = settings.GetAuthenticateServiceUrl()\n\t}\n\tif settings.AuthenticateInternalServiceUrl != nil {\n\t\to.AuthenticateInternalURLString = settings.GetAuthenticateInternalServiceUrl()\n\t}\n\tif settings.AuthenticateCallbackPath != nil {\n\t\to.AuthenticateCallbackPath = settings.GetAuthenticateCallbackPath()\n\t}\n\tif settings.CookieName != nil {\n\t\to.CookieName = settings.GetCookieName()\n\t}\n\tif settings.CookieSecret != nil {\n\t\to.CookieSecret = settings.GetCookieSecret()\n\t}\n\tif settings.CookieDomain != nil {\n\t\to.CookieDomain = settings.GetCookieDomain()\n\t}\n\tif settings.CookieSecure != nil {\n\t\to.CookieSecure = settings.GetCookieSecure()\n\t}\n\tif settings.CookieHttpOnly != nil {\n\t\to.CookieHTTPOnly = settings.GetCookieHttpOnly()\n\t}\n\tif settings.CookieExpire != nil {\n\t\to.CookieExpire = settings.GetCookieExpire().AsDuration()\n\t}\n\tif settings.IdpClientId != nil {\n\t\to.ClientID = settings.GetIdpClientId()\n\t}\n\tif settings.IdpClientSecret != nil {\n\t\to.ClientSecret = settings.GetIdpClientSecret()\n\t}\n\tif settings.IdpProvider != nil {\n\t\to.Provider = settings.GetIdpProvider()\n\t}\n\tif settings.IdpProviderUrl != nil {\n\t\to.ProviderURL = settings.GetIdpProviderUrl()\n\t}\n\tif len(settings.Scopes) > 0 {\n\t\to.Scopes = settings.Scopes\n\t}\n\tif settings.IdpServiceAccount != nil {\n\t\to.ServiceAccount = settings.GetIdpServiceAccount()\n\t}\n\tif settings.IdpRefreshDirectoryTimeout != nil {\n\t\to.RefreshDirectoryTimeout = settings.GetIdpRefreshDirectoryTimeout().AsDuration()\n\t}\n\tif settings.IdpRefreshDirectoryInterval != nil {\n\t\to.RefreshDirectoryInterval = settings.GetIdpRefreshDirectoryInterval().AsDuration()\n\t}\n\tif settings.RequestParams != nil && len(settings.RequestParams) > 0 {\n\t\to.RequestParams = settings.RequestParams\n\t}\n\tif len(settings.AuthorizeServiceUrls) > 0 {\n\t\to.AuthorizeURLStrings = settings.GetAuthorizeServiceUrls()\n\t}\n\tif settings.AuthorizeInternalServiceUrl != nil {\n\t\to.AuthorizeInternalURLString = settings.GetAuthorizeInternalServiceUrl()\n\t}\n\tif settings.OverrideCertificateName != nil {\n\t\to.OverrideCertificateName = settings.GetOverrideCertificateName()\n\t}\n\tif settings.CertificateAuthority != nil {\n\t\to.CA = settings.GetCertificateAuthority()\n\t}\n\tif settings.CertificateAuthorityFile != nil {\n\t\to.CAFile = settings.GetCertificateAuthorityFile()\n\t}\n\tif settings.SigningKey != nil {\n\t\to.SigningKey = settings.GetSigningKey()\n\t}\n\tif settings.SetResponseHeaders != nil && len(settings.SetResponseHeaders) > 0 {\n\t\to.SetResponseHeaders = settings.SetResponseHeaders\n\t}\n\tif len(settings.JwtClaimsHeaders) > 0 {\n\t\to.JWTClaimsHeaders = settings.GetJwtClaimsHeaders()\n\t}\n\tif settings.DefaultUpstreamTimeout != nil {\n\t\to.DefaultUpstreamTimeout = settings.GetDefaultUpstreamTimeout().AsDuration()\n\t}\n\tif settings.MetricsAddress != nil {\n\t\to.MetricsAddr = settings.GetMetricsAddress()\n\t}\n\tif settings.MetricsBasicAuth != nil {\n\t\to.MetricsBasicAuth = settings.GetMetricsBasicAuth()\n\t}\n\tif len(settings.GetMetricsCertificate().GetCertBytes()) > 0 {\n\t\to.MetricsCertificate = base64.StdEncoding.EncodeToString(settings.GetMetricsCertificate().GetCertBytes())\n\t}\n\tif len(settings.GetMetricsCertificate().GetKeyBytes()) > 0 {\n\t\to.MetricsCertificateKey = base64.StdEncoding.EncodeToString(settings.GetMetricsCertificate().GetKeyBytes())\n\t}\n\tif settings.GetMetricsCertificate().GetCertFile() != \"\" {\n\t\to.MetricsCertificateFile = settings.GetMetricsCertificate().GetCertFile()\n\t}\n\tif settings.GetMetricsCertificate().GetKeyFile() != \"\" {\n\t\to.MetricsCertificateKeyFile = settings.GetMetricsCertificate().GetKeyFile()\n\t}\n\tif settings.GetMetricsClientCa() != \"\" {\n\t\to.MetricsClientCA = settings.GetMetricsClientCa()\n\t}\n\tif settings.GetMetricsClientCaFile() != \"\" {\n\t\to.MetricsClientCAFile = settings.GetMetricsClientCaFile()\n\t}\n\tif settings.TracingProvider != nil {\n\t\to.TracingProvider = settings.GetTracingProvider()\n\t}\n\tif settings.TracingSampleRate != nil {\n\t\to.TracingSampleRate = settings.GetTracingSampleRate()\n\t}\n\tif settings.TracingJaegerCollectorEndpoint != nil {\n\t\to.TracingJaegerCollectorEndpoint = settings.GetTracingJaegerCollectorEndpoint()\n\t}\n\tif settings.TracingJaegerAgentEndpoint != nil {\n\t\to.TracingJaegerAgentEndpoint = settings.GetTracingJaegerAgentEndpoint()\n\t}\n\tif settings.TracingZipkinEndpoint != nil {\n\t\to.ZipkinEndpoint = settings.GetTracingZipkinEndpoint()\n\t}\n\tif settings.GrpcAddress != nil {\n\t\to.GRPCAddr = settings.GetGrpcAddress()\n\t}\n\tif settings.GrpcInsecure != nil {\n\t\to.GRPCInsecure = settings.GetGrpcInsecure()\n\t}\n\tif settings.ForwardAuthUrl != nil {\n\t\to.ForwardAuthURLString = settings.GetForwardAuthUrl()\n\t}\n\tif len(settings.DatabrokerServiceUrls) > 0 {\n\t\to.DataBrokerURLStrings = settings.GetDatabrokerServiceUrls()\n\t}\n\tif settings.DatabrokerInternalServiceUrl != nil {\n\t\to.DataBrokerInternalURLString = settings.GetDatabrokerInternalServiceUrl()\n\t}\n\tif settings.ClientCa != nil {\n\t\to.ClientCA = settings.GetClientCa()\n\t}\n\tif settings.ClientCaFile != nil {\n\t\to.ClientCAFile = settings.GetClientCaFile()\n\t}\n\tif settings.GoogleCloudServerlessAuthenticationServiceAccount != nil {\n\t\to.GoogleCloudServerlessAuthenticationServiceAccount = settings.GetGoogleCloudServerlessAuthenticationServiceAccount()\n\t}\n\tif settings.Autocert != nil {\n\t\to.AutocertOptions.Enable = settings.GetAutocert()\n\t}\n\tif settings.AutocertCa != nil {\n\t\to.AutocertOptions.CA = settings.GetAutocertCa()\n\t}\n\tif settings.AutocertEmail != nil {\n\t\to.AutocertOptions.Email = settings.GetAutocertEmail()\n\t}\n\tif settings.AutocertEabKeyId != nil {\n\t\to.AutocertOptions.EABKeyID = settings.GetAutocertEabKeyId()\n\t}\n\tif settings.AutocertEabMacKey != nil {\n\t\to.AutocertOptions.EABMACKey = settings.GetAutocertEabMacKey()\n\t}\n\tif settings.AutocertUseStaging != nil {\n\t\to.AutocertOptions.UseStaging = settings.GetAutocertUseStaging()\n\t}\n\tif settings.AutocertMustStaple != nil {\n\t\to.AutocertOptions.MustStaple = settings.GetAutocertMustStaple()\n\t}\n\tif settings.AutocertDir != nil {\n\t\to.AutocertOptions.Folder = settings.GetAutocertDir()\n\t}\n\tif settings.AutocertTrustedCa != nil {\n\t\to.AutocertOptions.TrustedCA = settings.GetAutocertTrustedCa()\n\t}\n\tif settings.AutocertTrustedCaFile != nil {\n\t\to.AutocertOptions.TrustedCAFile = settings.GetAutocertTrustedCaFile()\n\t}\n\tif settings.SkipXffAppend != nil {\n\t\to.SkipXffAppend = settings.GetSkipXffAppend()\n\t}\n\tif settings.XffNumTrustedHops != nil {\n\t\to.XffNumTrustedHops = settings.GetXffNumTrustedHops()\n\t}\n\tif len(settings.ProgrammaticRedirectDomainWhitelist) > 0 {\n\t\to.ProgrammaticRedirectDomainWhitelist = settings.GetProgrammaticRedirectDomainWhitelist()\n\t}\n\tif settings.AuditKey != nil {\n\t\to.AuditKey = &PublicKeyEncryptionKeyOptions{\n\t\t\tID:   settings.AuditKey.GetId(),\n\t\t\tData: base64.StdEncoding.EncodeToString(settings.AuditKey.GetData()),\n\t\t}\n\t}\n\tif settings.CodecType != nil {\n\t\to.CodecType = CodecTypeFromEnvoy(settings.GetCodecType())\n\t}\n\tif settings.ClientCrl != nil {\n\t\to.ClientCRL = settings.GetClientCrl()\n\t}\n\tif settings.ClientCrlFile != nil {\n\t\to.ClientCRLFile = settings.GetClientCrlFile()\n\t}\n}\n\nfunc dataDir() string {\n\thomeDir, _ := os.UserHomeDir()\n\tif homeDir == \"\" {\n\t\thomeDir = \".\"\n\t}\n\tbaseDir := filepath.Join(homeDir, \".local\", \"share\")\n\tif xdgData := os.Getenv(\"XDG_DATA_HOME\"); xdgData != \"\" {\n\t\tbaseDir = xdgData\n\t}\n\treturn filepath.Join(baseDir, \"pomerium\")\n}\n\nfunc compareByteSliceSlice(a, b [][]byte) int {\n\tsz := min(len(a), len(b))\n\tfor i := 0; i < sz; i++ {\n\t\tswitch bytes.Compare(a[i], b[i]) {\n\t\tcase -1:\n\t\t\treturn -1\n\t\tcase 1:\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tswitch {\n\tcase len(a) < len(b):\n\t\treturn -1\n\tcase len(b) < len(a):\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n// AtomicOptions are Options that can be access atomically.\ntype AtomicOptions struct {\n\tvalue atomic.Value\n}\n\n// NewAtomicOptions creates a new AtomicOptions.\nfunc NewAtomicOptions() *AtomicOptions {\n\tao := new(AtomicOptions)\n\tao.Store(new(Options))\n\treturn ao\n}\n\n// Load loads the options.\nfunc (a *AtomicOptions) Load() *Options {\n\treturn a.value.Load().(*Options)\n}\n\n// Store stores the options.\nfunc (a *AtomicOptions) Store(options *Options) {\n\ta.value.Store(options)\n}\n", "// Package pomerium houses the main pomerium CLI command.\n//\npackage pomerium\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\tenvoy_service_auth_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v3\"\n\t\"github.com/rs/zerolog\"\n\t\"golang.org/x/sync/errgroup\"\n\n\t\"github.com/pomerium/pomerium/authenticate\"\n\t\"github.com/pomerium/pomerium/authorize\"\n\t\"github.com/pomerium/pomerium/config\"\n\tdatabroker_service \"github.com/pomerium/pomerium/databroker\"\n\t\"github.com/pomerium/pomerium/internal/autocert\"\n\t\"github.com/pomerium/pomerium/internal/controlplane\"\n\t\"github.com/pomerium/pomerium/internal/databroker\"\n\t\"github.com/pomerium/pomerium/internal/envoy\"\n\t\"github.com/pomerium/pomerium/internal/envoy/files\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/registry\"\n\t\"github.com/pomerium/pomerium/internal/urlutil\"\n\t\"github.com/pomerium/pomerium/internal/version\"\n\t\"github.com/pomerium/pomerium/proxy\"\n)\n\n// Run runs the main pomerium application.\nfunc Run(ctx context.Context, configFile string) error {\n\tlog.Info(ctx).\n\t\tStr(\"envoy_version\", files.FullVersion()).\n\t\tStr(\"version\", version.FullVersion()).\n\t\tMsg(\"cmd/pomerium\")\n\n\tvar src config.Source\n\n\tsrc, err := config.NewFileOrEnvironmentSource(configFile, files.FullVersion())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsrc = databroker.NewConfigSource(ctx, src)\n\tlogMgr := config.NewLogManager(ctx, src)\n\tdefer logMgr.Close()\n\n\t// trigger changes when underlying files are changed\n\tsrc = config.NewFileWatcherSource(src)\n\n\tsrc, err = autocert.New(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// override the default http transport so we can use the custom CA in the TLS client config (#1570)\n\thttp.DefaultTransport = config.NewHTTPTransport(src)\n\n\tmetricsMgr := config.NewMetricsManager(ctx, src)\n\tdefer metricsMgr.Close()\n\ttraceMgr := config.NewTraceManager(ctx, src)\n\tdefer traceMgr.Close()\n\n\t// setup the control plane\n\tcontrolPlane, err := controlplane.NewServer(src.GetConfig(), metricsMgr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating control plane: %w\", err)\n\t}\n\tsrc.OnConfigChange(ctx,\n\t\tfunc(ctx context.Context, cfg *config.Config) {\n\t\t\tif err := controlPlane.OnConfigChange(ctx, cfg); err != nil {\n\t\t\t\tlog.Error(ctx).Err(err).Msg(\"config change\")\n\t\t\t}\n\t\t})\n\n\tif err = controlPlane.OnConfigChange(log.WithContext(ctx, func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"config_file_source\", configFile).Bool(\"bootstrap\", true)\n\t}), src.GetConfig()); err != nil {\n\t\treturn fmt.Errorf(\"applying config: %w\", err)\n\t}\n\n\tlog.Info(ctx).\n\t\tStr(\"grpc-port\", src.GetConfig().GRPCPort).\n\t\tStr(\"http-port\", src.GetConfig().HTTPPort).\n\t\tStr(\"outbound-port\", src.GetConfig().OutboundPort).\n\t\tStr(\"metrics-port\", src.GetConfig().MetricsPort).\n\t\tStr(\"debug-port\", src.GetConfig().DebugPort).\n\t\tMsg(\"server started\")\n\n\t// create envoy server\n\tenvoyServer, err := envoy.NewServer(ctx, src, controlPlane.Builder)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating envoy server: %w\", err)\n\t}\n\tdefer envoyServer.Close()\n\n\t// add services\n\tif err := setupAuthenticate(ctx, src, controlPlane); err != nil {\n\t\treturn err\n\t}\n\tvar authorizeServer *authorize.Authorize\n\tif config.IsAuthorize(src.GetConfig().Options.Services) {\n\t\tauthorizeServer, err = setupAuthorize(ctx, src, controlPlane)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tvar dataBrokerServer *databroker_service.DataBroker\n\tif config.IsDataBroker(src.GetConfig().Options.Services) {\n\t\tdataBrokerServer, err = setupDataBroker(ctx, src, controlPlane)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up databroker: %w\", err)\n\t\t}\n\t}\n\n\tif err = setupRegistryReporter(ctx, src); err != nil {\n\t\treturn fmt.Errorf(\"setting up registry reporter: %w\", err)\n\t}\n\tif err := setupProxy(ctx, src, controlPlane); err != nil {\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\tgo func(ctx context.Context) {\n\t\tch := make(chan os.Signal, 2)\n\t\tdefer signal.Stop(ch)\n\n\t\tsignal.Notify(ch, os.Interrupt)\n\t\tsignal.Notify(ch, syscall.SIGTERM)\n\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-ctx.Done():\n\t\t}\n\t\tcancel()\n\t}(ctx)\n\n\t// run everything\n\teg, ctx := errgroup.WithContext(ctx)\n\tif authorizeServer != nil {\n\t\teg.Go(func() error {\n\t\t\treturn authorizeServer.Run(ctx)\n\t\t})\n\t}\n\teg.Go(func() error {\n\t\treturn controlPlane.Run(ctx)\n\t})\n\tif dataBrokerServer != nil {\n\t\teg.Go(func() error {\n\t\t\treturn dataBrokerServer.Run(ctx)\n\t\t})\n\t}\n\treturn eg.Wait()\n}\n\nfunc setupAuthenticate(ctx context.Context, src config.Source, controlPlane *controlplane.Server) error {\n\tif !config.IsAuthenticate(src.GetConfig().Options.Services) {\n\t\treturn nil\n\t}\n\n\tsvc, err := authenticate.New(src.GetConfig())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating authenticate service: %w\", err)\n\t}\n\n\tauthenticateURL, err := src.GetConfig().Options.GetInternalAuthenticateURL()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error getting authenticate URL: %w\", err)\n\t}\n\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\thost := urlutil.StripPort(authenticateURL.Host)\n\tsr := controlPlane.HTTPRouter.Host(host).Subrouter()\n\tsvc.Mount(sr)\n\tlog.Info(context.TODO()).Str(\"host\", host).Msg(\"enabled authenticate service\")\n\n\treturn nil\n}\n\nfunc setupAuthorize(ctx context.Context, src config.Source, controlPlane *controlplane.Server) (*authorize.Authorize, error) {\n\tsvc, err := authorize.New(src.GetConfig())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating authorize service: %w\", err)\n\t}\n\tenvoy_service_auth_v3.RegisterAuthorizationServer(controlPlane.GRPCServer, svc)\n\n\tlog.Info(context.TODO()).Msg(\"enabled authorize service\")\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\treturn svc, nil\n}\n\nfunc setupDataBroker(ctx context.Context, src config.Source, controlPlane *controlplane.Server) (*databroker_service.DataBroker, error) {\n\tsvc, err := databroker_service.New(src.GetConfig())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating databroker service: %w\", err)\n\t}\n\tsvc.Register(controlPlane.GRPCServer)\n\tlog.Info(context.TODO()).Msg(\"enabled databroker service\")\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\treturn svc, nil\n}\n\nfunc setupRegistryReporter(ctx context.Context, src config.Source) error {\n\treporter := registry.NewReporter()\n\tsrc.OnConfigChange(ctx, reporter.OnConfigChange)\n\treporter.OnConfigChange(ctx, src.GetConfig())\n\treturn nil\n}\n\nfunc setupProxy(ctx context.Context, src config.Source, controlPlane *controlplane.Server) error {\n\tif !config.IsProxy(src.GetConfig().Options.Services) {\n\t\treturn nil\n\t}\n\n\tsvc, err := proxy.New(src.GetConfig())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating proxy service: %w\", err)\n\t}\n\tcontrolPlane.HTTPRouter.PathPrefix(\"/\").Handler(svc)\n\n\tlog.Info(context.TODO()).Msg(\"enabled proxy service\")\n\tsrc.OnConfigChange(ctx, svc.OnConfigChange)\n\tsvc.OnConfigChange(ctx, src.GetConfig())\n\n\treturn nil\n}\n", "// Package controlplane contains the HTTP and gRPC base servers and the xDS gRPC implementation for envoy.\npackage controlplane\n\nimport (\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"time\"\n\n\t\"github.com/CAFxX/httpcompression\"\n\t\"github.com/gorilla/handlers\"\n\n\t\"github.com/pomerium/pomerium/internal/httputil\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/requestid\"\n)\n\nfunc (srv *Server) addHTTPMiddleware() {\n\tcompressor, err := httpcompression.DefaultAdapter()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\troot := srv.HTTPRouter\n\troot.Use(compressor)\n\troot.Use(srv.reproxy.Middleware)\n\troot.Use(requestid.HTTPMiddleware())\n\troot.Use(log.NewHandler(log.Logger))\n\troot.Use(log.AccessHandler(func(r *http.Request, status, size int, duration time.Duration) {\n\t\tlog.FromRequest(r).Debug().\n\t\t\tDur(\"duration\", duration).\n\t\t\tInt(\"size\", size).\n\t\t\tInt(\"status\", status).\n\t\t\tStr(\"method\", r.Method).\n\t\t\tStr(\"host\", r.Host).\n\t\t\tStr(\"path\", r.URL.String()).\n\t\t\tMsg(\"http-request\")\n\t}))\n\troot.Use(handlers.RecoveryHandler())\n\troot.Use(log.HeadersHandler(httputil.HeadersXForwarded))\n\troot.Use(log.RemoteAddrHandler(\"ip\"))\n\troot.Use(log.UserAgentHandler(\"user_agent\"))\n\troot.Use(log.RefererHandler(\"referer\"))\n\troot.Use(log.RequestIDHandler(\"request-id\"))\n\troot.Use(telemetry.HTTPStatsHandler(func() string {\n\t\treturn srv.currentConfig.Load().Options.InstallationID\n\t}, srv.name))\n\troot.HandleFunc(\"/healthz\", httputil.HealthCheck)\n\troot.HandleFunc(\"/ping\", httputil.HealthCheck)\n\n\t// pprof\n\tsrv.DebugRouter.Path(\"/debug/pprof/cmdline\").HandlerFunc(pprof.Cmdline)\n\tsrv.DebugRouter.Path(\"/debug/pprof/profile\").HandlerFunc(pprof.Profile)\n\tsrv.DebugRouter.Path(\"/debug/pprof/symbol\").HandlerFunc(pprof.Symbol)\n\tsrv.DebugRouter.Path(\"/debug/pprof/trace\").HandlerFunc(pprof.Trace)\n\tsrv.DebugRouter.PathPrefix(\"/debug/pprof/\").HandlerFunc(pprof.Index)\n\n\t// metrics\n\tsrv.MetricsRouter.Handle(\"/metrics\", srv.metricsMgr)\n}\n", "package controlplane\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\tenvoy_service_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/rs/zerolog\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig\"\n\t\"github.com/pomerium/pomerium/config/envoyconfig/filemgr\"\n\t\"github.com/pomerium/pomerium/internal/controlplane/xdsmgr\"\n\t\"github.com/pomerium/pomerium/internal/envoy/files\"\n\t\"github.com/pomerium/pomerium/internal/events\"\n\t\"github.com/pomerium/pomerium/internal/httputil/reproxy\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/internal/telemetry\"\n\t\"github.com/pomerium/pomerium/internal/telemetry/requestid\"\n\t\"github.com/pomerium/pomerium/internal/version\"\n\tpom_grpc \"github.com/pomerium/pomerium/pkg/grpc\"\n\t\"github.com/pomerium/pomerium/pkg/grpcutil\"\n)\n\ntype versionedConfig struct {\n\t*config.Config\n\tversion int64\n}\n\ntype atomicVersionedConfig struct {\n\tvalue atomic.Value\n}\n\nfunc (avo *atomicVersionedConfig) Load() versionedConfig {\n\treturn avo.value.Load().(versionedConfig)\n}\n\nfunc (avo *atomicVersionedConfig) Store(cfg versionedConfig) {\n\tavo.value.Store(cfg)\n}\n\n// A Server is the control-plane gRPC and HTTP servers.\ntype Server struct {\n\tGRPCListener    net.Listener\n\tGRPCServer      *grpc.Server\n\tHTTPListener    net.Listener\n\tHTTPRouter      *mux.Router\n\tMetricsListener net.Listener\n\tMetricsRouter   *mux.Router\n\tDebugListener   net.Listener\n\tDebugRouter     *mux.Router\n\tBuilder         *envoyconfig.Builder\n\n\tcurrentConfig atomicVersionedConfig\n\tname          string\n\txdsmgr        *xdsmgr.Manager\n\tfilemgr       *filemgr.Manager\n\tmetricsMgr    *config.MetricsManager\n\treproxy       *reproxy.Handler\n\n\thaveSetCapacity map[string]bool\n}\n\n// NewServer creates a new Server. Listener ports are chosen by the OS.\nfunc NewServer(cfg *config.Config, metricsMgr *config.MetricsManager) (*Server, error) {\n\tsrv := &Server{\n\t\tmetricsMgr:      metricsMgr,\n\t\treproxy:         reproxy.New(),\n\t\thaveSetCapacity: map[string]bool{},\n\t}\n\tsrv.currentConfig.Store(versionedConfig{\n\t\tConfig: cfg,\n\t})\n\n\tvar err error\n\n\t// setup gRPC\n\tsrv.GRPCListener, err = net.Listen(\"tcp4\", net.JoinHostPort(\"127.0.0.1\", cfg.GRPCPort))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tui, si := grpcutil.AttachMetadataInterceptors(\n\t\tmetadata.Pairs(\n\t\t\tgrpcutil.MetadataKeyEnvoyVersion, files.FullVersion(),\n\t\t\tgrpcutil.MetadataKeyPomeriumVersion, version.FullVersion(),\n\t\t),\n\t)\n\tsrv.GRPCServer = grpc.NewServer(\n\t\tgrpc.StatsHandler(telemetry.NewGRPCServerStatsHandler(cfg.Options.Services)),\n\t\tgrpc.ChainUnaryInterceptor(requestid.UnaryServerInterceptor(), ui),\n\t\tgrpc.ChainStreamInterceptor(requestid.StreamServerInterceptor(), si),\n\t)\n\treflection.Register(srv.GRPCServer)\n\tsrv.registerAccessLogHandlers()\n\n\tgrpc_health_v1.RegisterHealthServer(srv.GRPCServer, pom_grpc.NewHealthCheckServer())\n\n\t// setup HTTP\n\tsrv.HTTPListener, err = net.Listen(\"tcp4\", net.JoinHostPort(\"127.0.0.1\", cfg.HTTPPort))\n\tif err != nil {\n\t\t_ = srv.GRPCListener.Close()\n\t\treturn nil, err\n\t}\n\n\tsrv.MetricsListener, err = net.Listen(\"tcp4\", net.JoinHostPort(\"127.0.0.1\", cfg.MetricsPort))\n\tif err != nil {\n\t\t_ = srv.GRPCListener.Close()\n\t\t_ = srv.HTTPListener.Close()\n\t\treturn nil, err\n\t}\n\n\tsrv.DebugListener, err = net.Listen(\"tcp4\", net.JoinHostPort(\"127.0.0.1\", cfg.DebugPort))\n\tif err != nil {\n\t\t_ = srv.GRPCListener.Close()\n\t\t_ = srv.HTTPListener.Close()\n\t\t_ = srv.DebugListener.Close()\n\t\treturn nil, err\n\t}\n\n\tsrv.HTTPRouter = mux.NewRouter()\n\tsrv.DebugRouter = mux.NewRouter()\n\tsrv.MetricsRouter = mux.NewRouter()\n\tsrv.addHTTPMiddleware()\n\n\tsrv.filemgr = filemgr.NewManager()\n\tsrv.filemgr.ClearCache()\n\n\tsrv.Builder = envoyconfig.New(\n\t\tsrv.GRPCListener.Addr().String(),\n\t\tsrv.HTTPListener.Addr().String(),\n\t\tsrv.MetricsListener.Addr().String(),\n\t\tsrv.filemgr,\n\t\tsrv.reproxy,\n\t)\n\n\tctx := log.WithContext(context.Background(), func(c zerolog.Context) zerolog.Context {\n\t\treturn c.Str(\"server_name\", cfg.Options.Services)\n\t})\n\n\tres, err := srv.buildDiscoveryResources(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsrv.xdsmgr = xdsmgr.NewManager(res)\n\tenvoy_service_discovery_v3.RegisterAggregatedDiscoveryServiceServer(srv.GRPCServer, srv.xdsmgr)\n\n\treturn srv, nil\n}\n\n// Run runs the control-plane gRPC and HTTP servers.\nfunc (srv *Server) Run(ctx context.Context) error {\n\teg, ctx := errgroup.WithContext(ctx)\n\n\thandle := events.Register(func(evt events.Event) {\n\t\twithGRPCBackoff(ctx, func() error {\n\t\t\treturn srv.storeEvent(ctx, evt)\n\t\t})\n\t})\n\tdefer events.Unregister(handle)\n\n\t// start the gRPC server\n\teg.Go(func() error {\n\t\tlog.Info(ctx).Str(\"addr\", srv.GRPCListener.Addr().String()).Msg(\"starting control-plane gRPC server\")\n\t\treturn srv.GRPCServer.Serve(srv.GRPCListener)\n\t})\n\n\t// gracefully stop the gRPC server on context cancellation\n\teg.Go(func() error {\n\t\t<-ctx.Done()\n\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tctx, cleanup := context.WithTimeout(ctx, time.Second*5)\n\t\tdefer cleanup()\n\n\t\tgo func() {\n\t\t\tsrv.GRPCServer.GracefulStop()\n\t\t\tcancel()\n\t\t}()\n\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tsrv.GRPCServer.Stop()\n\t\t\tcancel()\n\t\t}()\n\n\t\t<-ctx.Done()\n\n\t\treturn nil\n\t})\n\n\tfor _, entry := range []struct {\n\t\tName     string\n\t\tListener net.Listener\n\t\tHandler  *mux.Router\n\t}{\n\t\t{\"http\", srv.HTTPListener, srv.HTTPRouter},\n\t\t{\"debug\", srv.DebugListener, srv.DebugRouter},\n\t\t{\"metrics\", srv.MetricsListener, srv.MetricsRouter},\n\t} {\n\t\tentry := entry\n\t\thsrv := (&http.Server{\n\t\t\tBaseContext: func(li net.Listener) context.Context {\n\t\t\t\treturn ctx\n\t\t\t},\n\t\t\tHandler: entry.Handler,\n\t\t})\n\n\t\t// start the HTTP server\n\t\teg.Go(func() error {\n\t\t\tlog.Info(ctx).\n\t\t\t\tStr(\"addr\", entry.Listener.Addr().String()).\n\t\t\t\tMsgf(\"starting control-plane %s server\", entry.Name)\n\t\t\treturn hsrv.Serve(entry.Listener)\n\t\t})\n\n\t\t// gracefully stop the HTTP server on context cancellation\n\t\teg.Go(func() error {\n\t\t\t<-ctx.Done()\n\n\t\t\tctx, cleanup := context.WithTimeout(ctx, time.Second*5)\n\t\t\tdefer cleanup()\n\n\t\t\treturn hsrv.Shutdown(ctx)\n\t\t})\n\t}\n\n\treturn eg.Wait()\n}\n\n// OnConfigChange updates the pomerium config options.\nfunc (srv *Server) OnConfigChange(ctx context.Context, cfg *config.Config) error {\n\tsrv.reproxy.Update(ctx, cfg)\n\tprev := srv.currentConfig.Load()\n\tsrv.currentConfig.Store(versionedConfig{\n\t\tConfig:  cfg,\n\t\tversion: prev.version + 1,\n\t})\n\tres, err := srv.buildDiscoveryResources(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.xdsmgr.Update(ctx, res)\n\treturn nil\n}\n", "package registry\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pomerium/pomerium/config\"\n\t\"github.com/pomerium/pomerium/internal/log\"\n\t\"github.com/pomerium/pomerium/pkg/grpc\"\n\tpb \"github.com/pomerium/pomerium/pkg/grpc/registry\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n)\n\n// Reporter periodically submits a list of services available on this instance to the service registry\ntype Reporter struct {\n\tcancel                 func()\n\toutboundGRPCConnection *grpc.CachedOutboundGRPClientConn\n}\n\n// NewReporter creates a new Reporter.\nfunc NewReporter() *Reporter {\n\treturn &Reporter{\n\t\toutboundGRPCConnection: new(grpc.CachedOutboundGRPClientConn),\n\t}\n}\n\n// OnConfigChange applies configuration changes to the reporter\nfunc (r *Reporter) OnConfigChange(ctx context.Context, cfg *config.Config) {\n\tif r.cancel != nil {\n\t\tr.cancel()\n\t}\n\n\tservices, err := getReportedServices(cfg)\n\tif err != nil {\n\t\tlog.Warn(ctx).Err(err).Msg(\"metrics announce to service registry is disabled\")\n\t}\n\n\tsharedKey, err := cfg.Options.GetSharedKey()\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"decoding shared key\")\n\t\treturn\n\t}\n\n\tregistryConn, err := r.outboundGRPCConnection.Get(ctx, &grpc.OutboundOptions{\n\t\tOutboundPort:   cfg.OutboundPort,\n\t\tInstallationID: cfg.Options.InstallationID,\n\t\tServiceName:    cfg.Options.Services,\n\t\tSignedJWTKey:   sharedKey,\n\t})\n\tif err != nil {\n\t\tlog.Error(ctx).Err(err).Msg(\"connecting to registry\")\n\t\treturn\n\t}\n\n\tif len(services) > 0 {\n\t\tctx, cancel := context.WithCancel(context.TODO())\n\t\tgo runReporter(ctx, pb.NewRegistryClient(registryConn), services)\n\t\tr.cancel = cancel\n\t}\n}\n\nfunc getReportedServices(cfg *config.Config) ([]*pb.Service, error) {\n\tif cfg.Options.MetricsAddr == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tmu, err := metricsURL(*cfg.Options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn []*pb.Service{\n\t\t{Kind: pb.ServiceKind_PROMETHEUS_METRICS, Endpoint: mu.String()},\n\t}, nil\n}\n\nfunc metricsURL(o config.Options) (*url.URL, error) {\n\thost, port, err := net.SplitHostPort(o.MetricsAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid metrics address %q: %w\", o.MetricsAddr, err)\n\t}\n\tif port == \"\" {\n\t\treturn nil, fmt.Errorf(\"invalid metrics value %q: port is required\", o.MetricsAddr)\n\t}\n\tif host == \"\" {\n\t\tif host, err = getHostOrIP(); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not guess hostname: %w\", err)\n\t\t}\n\t}\n\n\tu := url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   net.JoinHostPort(host, port),\n\t\tPath:   defaultMetricsPath,\n\t}\n\n\tif o.MetricsBasicAuth != \"\" {\n\t\ttxt, err := base64.StdEncoding.DecodeString(o.MetricsBasicAuth)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"metrics basic auth: %w\", err)\n\t\t}\n\t\tparts := strings.SplitN(string(txt), \":\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"expected username:password for basic auth\")\n\t\t}\n\t\tu.User = url.UserPassword(parts[0], parts[1])\n\t}\n\n\tif o.MetricsCertificate != \"\" || o.MetricsCertificateFile != \"\" {\n\t\tu.Scheme = \"https\"\n\t}\n\n\tif o.MetricsAddr == \"\" {\n\t\treturn nil, fmt.Errorf(\"no metrics address provided\")\n\t}\n\n\treturn &u, nil\n}\n\nfunc runReporter(\n\tctx context.Context,\n\tclient pb.RegistryClient,\n\tservices []*pb.Service,\n) {\n\tbackoff := backoff.NewExponentialBackOff()\n\tbackoff.MaxElapsedTime = 0\n\n\treq := &pb.RegisterRequest{Services: services}\n\tafter := minTTL\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(after):\n\t\t\tresp, err := client.Report(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tlog.Ctx(ctx).Error().Err(err).Msg(\"grpc.service_registry.Report\")\n\t\t\t\tafter = backoff.NextBackOff()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tafter = resp.CallBackAfter.AsDuration()\n\t\t\tbackoff.Reset()\n\t\tcase <-ctx.Done():\n\t\t\tlog.Info(ctx).Msg(\"service registry reporter stopping\")\n\t\t\treturn\n\t\t}\n\t}\n}\n"], "filenames": ["config/config.go", "config/config_source.go", "config/envoyconfig/bootstrap_test.go", "config/envoyconfig/builder.go", "config/envoyconfig/clusters.go", "config/envoyconfig/clusters_test.go", "config/envoyconfig/listeners.go", "config/envoyconfig/listeners_test.go", "config/envoyconfig/routes.go", "config/envoyconfig/routes_test.go", "config/metrics.go", "config/options.go", "internal/cmd/pomerium/pomerium.go", "internal/controlplane/http.go", "internal/controlplane/server.go", "internal/registry/reporter.go"], "buggy_code_start_loc": [20, 113, 14, 10, 36, 28, 489, 28, 60, 99, 5, 51, 88, 52, 53, 68], "buggy_code_end_loc": [34, 127, 101, 28, 76, 862, 490, 819, 241, 195, 100, 54, 88, 60, 200, 68], "fixing_code_start_loc": [21, 113, 14, 10, 37, 28, 489, 28, 60, 99, 6, 50, 89, 52, 53, 69], "fixing_code_end_loc": [41, 132, 101, 31, 87, 862, 490, 819, 209, 194, 110, 50, 91, 60, 236, 73], "type": "CWE-200", "message": "Pomerium is an identity-aware access proxy. In distributed service mode, Pomerium's Authenticate service exposes pprof debug and prometheus metrics handlers to untrusted traffic. This can leak potentially sensitive environmental information or lead to limited denial of service conditions. This issue is patched in version v0.17.1 Workarounds: Block access to `/debug` and `/metrics` paths on the authenticate service. This can be done with any L7 proxy, including Pomerium's own proxy service.", "other": {"cve": {"id": "CVE-2022-24797", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-31T23:15:08.247", "lastModified": "2022-04-08T17:03:23.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pomerium is an identity-aware access proxy. In distributed service mode, Pomerium's Authenticate service exposes pprof debug and prometheus metrics handlers to untrusted traffic. This can leak potentially sensitive environmental information or lead to limited denial of service conditions. This issue is patched in version v0.17.1 Workarounds: Block access to `/debug` and `/metrics` paths on the authenticate service. This can be done with any L7 proxy, including Pomerium's own proxy service."}, {"lang": "es", "value": "Pomerium es un proxy de acceso consciente de la identidad. En el modo de servicio distribuido, el servicio de autenticaci\u00f3n de Pomerium expone los manejadores de depuraci\u00f3n pprof y de m\u00e9tricas prometheus al tr\u00e1fico no confiable. Esto puede filtrar informaci\u00f3n ambiental potencialmente confidencial o conllevar a condiciones limitadas de denegaci\u00f3n de servicio. Este problema ha sido parcheado en versi\u00f3n v0.17.1 Mitigaciones: Bloquear el acceso a las rutas \"/debug\" y \"/metrics\" en el servicio de autenticaci\u00f3n. Esto puede hacerse con cualquier proxy L7, incluyendo el propio servicio proxy de Pomerium"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pomerium:pomerium:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.16.0", "versionEndExcluding": "0.17.1", "matchCriteriaId": "10481143-FB07-45DD-B3B3-232D4F9EE63F"}]}]}], "references": [{"url": "https://github.com/pomerium/pomerium/commit/b435f73e2b54088da2aca5e8c3aa1808293d6903", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pomerium/pomerium/pull/3212", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/pomerium/pomerium/security/advisories/GHSA-q98f-2x4p-prjr", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pomerium/pomerium/commit/b435f73e2b54088da2aca5e8c3aa1808293d6903"}}