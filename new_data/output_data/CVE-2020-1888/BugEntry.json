{"buggy_code": ["/* JSON_parser.c */\n\n/* 2005-12-30 */\n\n/*\nCopyright (c) 2005 JSON.org\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nThe Software shall be used for Good, not Evil.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// If we have json-c then don't use this library since that one has a more\n// permissive licence\n#ifndef HAVE_JSONC\n\n#include \"hphp/runtime/ext/json/JSON_parser.h\"\n\n#include <folly/FBVector.h>\n\n#include \"hphp/runtime/base/array-provenance.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/string-buffer.h\"\n#include \"hphp/runtime/base/request-info.h\"\n#include \"hphp/runtime/base/tv-refcount.h\"\n#include \"hphp/runtime/base/init-fini-node.h\"\n#include \"hphp/runtime/base/utf8-decode.h\"\n#include \"hphp/runtime/ext/json/ext_json.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-map.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-vector.h\"\n#include \"hphp/system/systemlib.h\"\n#include \"hphp/util/fast_strtoll_base10.h\"\n#include \"hphp/zend/zend-strtod.h\"\n\n#define MAX_LENGTH_OF_LONG 20\nstatic const char long_min_digits[] = \"9223372036854775808\";\n\nnamespace HPHP {\n\n/*\n    Characters are mapped into these 32 symbol classes. This allows for\n    significant reductions in the size of the state transition table.\n*/\n\n/* error */\n#define S_ERR -1\n\n/* space */\n#define S_SPA 0\n\n/* other whitespace */\n#define S_WSP 1\n\n/* {  */\n#define S_LBE 2\n\n/* } */\n#define S_RBE 3\n\n/* [ */\n#define S_LBT 4\n\n/* ] */\n#define S_RBT 5\n\n/* : */\n#define S_COL 6\n\n/* , */\n#define S_COM 7\n\n/* \" */\n#define S_QUO 8\n\n/* \\ */\n#define S_BAC 9\n\n/* / */\n#define S_SLA 10\n\n/* + */\n#define S_PLU 11\n\n/* - */\n#define S_MIN 12\n\n/* . */\n#define S_DOT 13\n\n/* 0 */\n#define S_ZER 14\n\n/* 123456789 */\n#define S_DIG 15\n\n/* a */\n#define S__A_ 16\n\n/* b */\n#define S__B_ 17\n\n/* c */\n#define S__C_ 18\n\n/* d */\n#define S__D_ 19\n\n/* e */\n#define S__E_ 20\n\n/* f */\n#define S__F_ 21\n\n/* l */\n#define S__L_ 22\n\n/* n */\n#define S__N_ 23\n\n/* r */\n#define S__R_ 24\n\n/* s */\n#define S__S_ 25\n\n/* t */\n#define S__T_ 26\n\n/* u */\n#define S__U_ 27\n\n/* ABCDF */\n#define S_A_F 28\n\n/* E */\n#define S_E   29\n\n/* everything else */\n#define S_ETC 30\n\n\n/*\n    This table maps the 128 ASCII characters into the 32 character classes.\n    The remaining Unicode characters should be mapped to S_ETC.\n*/\nalignas(64) static const int8_t ascii_class[128] = {\n    S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n    S_ERR, S_WSP, S_WSP, S_ERR, S_ERR, S_WSP, S_ERR, S_ERR,\n    S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n    S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n\n    S_SPA, S_ETC, S_QUO, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_PLU, S_COM, S_MIN, S_DOT, S_SLA,\n    S_ZER, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG,\n    S_DIG, S_DIG, S_COL, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n\n    S_ETC, S_A_F, S_A_F, S_A_F, S_A_F, S_E  , S_A_F, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_LBT, S_BAC, S_RBT, S_ETC, S_ETC,\n\n    S_ETC, S__A_, S__B_, S__C_, S__D_, S__E_, S__F_, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_ETC, S__L_, S_ETC, S__N_, S_ETC,\n    S_ETC, S_ETC, S__R_, S__S_, S__T_, S__U_, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_LBE, S_ETC, S_RBE, S_ETC, S_ETC\n};\n\n/*<fb>*/\nalignas(64) static const int8_t loose_ascii_class[128] = {\n  S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n  S_ERR, S_WSP, S_WSP, S_ERR, S_ERR, S_WSP, S_ERR, S_ERR,\n  S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n  S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n\n  S_SPA, S_ETC, S_QUO, S_ETC, S_ETC, S_ETC, S_ETC, S_QUO,\n  S_ETC, S_ETC, S_ETC, S_PLU, S_COM, S_MIN, S_DOT, S_SLA,\n  S_ZER, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG,\n  S_DIG, S_DIG, S_COL, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n\n  S_ETC, S_A_F, S_A_F, S_A_F, S_A_F, S_E  , S_A_F, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_LBT, S_BAC, S_RBT, S_ETC, S_ETC,\n\n  S_ETC, S__A_, S__B_, S__C_, S__D_, S__E_, S__F_, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_ETC, S__L_, S_ETC, S__N_, S_ETC,\n  S_ETC, S_ETC, S__R_, S__S_, S__T_, S__U_, S_ETC, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_LBE, S_ETC, S_RBE, S_ETC, S_ETC\n};\n/*</fb>*/\n\n\n\n/*\n    The state transition table takes the current state and the current symbol,\n    and returns either a new state or an action. A new state is a number between\n    0 and 29. An action is a negative number between -1 and -9. A JSON text is\n    accepted if the end of the text is in state 9 and mode is Mode::DONE.\n*/\nalignas(64) static const int8_t state_transition_table[30][32] = {\n/* 0*/ { 0, 0,-8,-1,-6,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/* 1*/ { 1, 1,-1,-9,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/* 2*/ { 2, 2,-8,-1,-6,-5,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/* 3*/ { 3,-1, 3, 3, 3, 3, 3, 3,-4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},\n/* 4*/ {-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1, 3,-1, 3, 3,-1, 3, 5,-1,-1,-1},\n/* 5*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 6, 6, 6, 6, 6, 6, 6, 6,-1,-1,-1,-1,-1,-1, 6, 6,-1},\n/* 6*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 7, 7, 7, 7, 7, 7, 7, 7,-1,-1,-1,-1,-1,-1, 7, 7,-1},\n/* 7*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8, 8, 8, 8, 8, 8, 8, 8,-1,-1,-1,-1,-1,-1, 8, 8,-1},\n/* 8*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3, 3, 3, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3, 3,-1},\n/* 9*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*10*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1},\n/*11*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1},\n/*12*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*13*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*14*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,-1,-1},\n/*15*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,16,-1,-1,-1,-1,-1},\n/*16*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*17*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,-1,-1,-1},\n/*18*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1},\n/*19*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1},\n/*20*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*21*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,-1,-1,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*22*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,22,22,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*23*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,23,23,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*24*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,25,25,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*25*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*26*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*27*/ {27,27,-1,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*28*/ {28,28,-8,-1,-6,-1,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/*29*/ {29,29,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}\n};\n\n/*<fb>*/\n/*\n  Alternate \"loose\" transition table to support unquoted keys.\n\n  Note: State 3 has same outgoing transitions in both transition tables. This is\n  used below in the fast-case for appending simple characters (3 -> 3).\n*/\nalignas(64) static const int8_t loose_state_transition_table[31][32] = {\n/* 0*/ { 0, 0,-8,-1,-6,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/* 1*/ { 1, 1,-1,-9,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30},\n/* 2*/ { 2, 2,-8,-1,-6,-5,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/* 3*/ { 3,-1, 3, 3, 3, 3, 3, 3,-4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},\n/* 4*/ {-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1, 3,-1, 3, 3,-1, 3, 5,-1,-1,-1},\n/* 5*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 6, 6, 6, 6, 6, 6, 6, 6,-1,-1,-1,-1,-1,-1, 6, 6,-1},\n/* 6*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 7, 7, 7, 7, 7, 7, 7, 7,-1,-1,-1,-1,-1,-1, 7, 7,-1},\n/* 7*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8, 8, 8, 8, 8, 8, 8, 8,-1,-1,-1,-1,-1,-1, 8, 8,-1},\n/* 8*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3, 3, 3, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3, 3,-1},\n/* 9*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*10*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1},\n/*11*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1},\n/*12*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*13*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*14*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,-1,-1},\n/*15*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,16,-1,-1,-1,-1,-1},\n/*16*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*17*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,-1,-1,-1},\n/*18*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1},\n/*19*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1},\n/*20*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*21*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,-1,-1,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*22*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,22,22,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*23*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,23,23,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*24*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,25,25,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*25*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*26*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*27*/ {27,27,-1,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*28*/ {28,28,-8,-1,-6,-5,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/*29*/ {29,29,-1,-7,-1,-1,-1,-7, 3,-1,-1,-1,-1,-1,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30},\n/*30*/ {30,-1,30,30,30,30,-10,30,-4,4,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30}\n};\n/*</fb>*/\n\n/**\n * These modes can be pushed on the PDA stack.\n */\nenum class Mode {\n  INVALID = 0,\n  DONE = 1,\n  KEY = 2,\n  OBJECT = 3,\n  ARRAY = 4\n};\n\nnamespace {\n\nint dehexchar(char c) {\n  if (c >= '0' && c <= '9') return c - '0';\n  if (c >= 'A' && c <= 'F') return c - ('A' - 10);\n  if (c >= 'a' && c <= 'f') return c - ('a' - 10);\n  return -1;\n}\n\nNEVER_INLINE\nstatic void tvDecRefRange(TypedValue* begin, TypedValue* end) {\n  assertx(begin <= end);\n  for (auto tv = begin; tv != end; ++tv) {\n    tvDecRefGen(tv);\n  }\n}\n\n/*\n * Parses a subset of JSON. Currently unsupported:\n * - Non-ASCII\n * - Character escape sequences\n * - Non-string array keys\n * - Arrays nested > 255 levels\n */\nstruct SimpleParser {\n  static constexpr int kMaxArrayDepth = 255;\n\n  /*\n   * Returns buffer size in bytes needed to handle any input up to given length.\n   */\n  static size_t BufferBytesForLength(int length) {\n    return (length + 1) * sizeof(TypedValue) / 2;  // Worst case: \"[0,0,...,0]\"\n  }\n\n  /*\n   * Returns false for unsupported or malformed input (does not distinguish).\n   */\n  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    if (!ok ||\n        (parser.skipSpace(), parser.p != inp + length)) {\n      // Unsupported, malformed, or trailing garbage. Release entire stack.\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }\n\n private:\n  SimpleParser(const char* input, int length, TypedValue* buffer,\n               JSONContainerType container_type, bool is_tsimplejson)\n    : p(input)\n    , top(buffer)\n    , array_depth(-kMaxArrayDepth) /* Start negative to simplify check. */\n    , container_type(container_type)\n    , is_tsimplejson(is_tsimplejson)\n  {\n    assertx(input[length] == 0);  // Parser relies on sentinel to avoid checks.\n  }\n\n  /*\n   * Skip whitespace, then if next char is 'ch', consume it and return true,\n   * otherwise let it be and return false.\n   */\n  bool matchSeparator(char ch) {\n    if (LIKELY(*p++ == ch)) return true;\n    return matchSeparatorSlow(ch);\n  }\n  NEVER_INLINE\n  bool matchSeparatorSlow(char ch) {\n    --p;\n    skipSpace();\n    if (LIKELY(*p++ == ch)) return true;\n    --p;\n    return false;\n  }\n  NEVER_INLINE\n  void skipSpace() { while (isSpace(*p)) p++; }\n  bool isSpace(char ch) const {\n    return ch == ' ' || ch == '\\n' || ch == '\\t' || ch == '\\f';\n  }\n\n  /*\n   * Variant parser.\n   *\n   * JSON arrays don't permit leading 0's in numbers, so we have to thread that\n   * context through here to parseNumber().\n   */\n  bool parseValue(bool array_elem = false) {\n    auto const ch = *p++;\n    if (ch == '{') return parseMixed();\n    else if (ch == '[') return parsePacked();\n    else if (ch == '\\\"') return parseString();\n    else if ((ch >= '0' && ch <= '9') ||\n              ch == '-') return parseNumber(ch, array_elem);\n    else if (ch == 't') return parseRue();\n    else if (ch == 'f') return parseAlse();\n    else if (ch == 'n') return parseUll();\n    else if (isSpace(ch)) {\n      skipSpace();\n      return parseValue(array_elem);\n    }\n    else return false;\n  }\n\n  bool parseRue() {\n    if (*p++ != 'r') return false;\n    if (*p++ != 'u') return false;\n    if (*p++ != 'e') return false;\n    auto const tv = top++;\n    tv->m_type = KindOfBoolean;\n    tv->m_data.num = true;\n    return true;\n  }\n\n  bool parseAlse() {\n    if (*p++ != 'a') return false;\n    if (*p++ != 'l') return false;\n    if (*p++ != 's') return false;\n    if (*p++ != 'e') return false;\n    auto const tv = top++;\n    tv->m_type = KindOfBoolean;\n    tv->m_data.num = false;\n    return true;\n  }\n\n  bool parseUll() {\n    if (*p++ != 'u') return false;\n    if (*p++ != 'l') return false;\n    if (*p++ != 'l') return false;\n    top++->m_type = KindOfNull;\n    return true;\n  }\n\n  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; // includes check for end of string\n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }\n\n  bool parseRawString(int* len) {\n    assertx(p[-1] == '\"'); // SimpleParser only handles \"-quoted strings\n    *len = 0;\n    auto const charTop = reinterpret_cast<signed char*>(top);\n    for (signed char ch = *p++; ch != '\\\"'; ch = *p++) {\n      charTop[(*len)++] = ch; // overwritten later if `ch == '\\\\'`\n      if (ch < ' ') {\n        // `ch < ' '` catches null and also non-ASCII (since signed char)\n        return false;\n      } else if (ch == '\\\\') {\n        if (!handleBackslash(charTop[*len - 1])) return false;\n      }\n    }\n    return true;\n  }\n\n  bool parseString() {\n    int len;\n    if (!parseRawString(&len)) return false;\n    auto const start = reinterpret_cast<char*>(top);\n    pushStringData(StringData::Make(start, len, CopyString));\n    return true;\n  }\n\n  bool parseMixedKey() {\n    int len;\n    int64_t num;\n    if (!parseRawString(&len)) return false;\n    auto const start = reinterpret_cast<char*>(top);\n    auto const slice = folly::StringPiece(start, len);\n    start[len] = '\\0';\n    if (container_type != JSONContainerType::HACK_ARRAYS &&\n        container_type != JSONContainerType::LEGACY_HACK_ARRAYS &&\n        is_strictly_integer(start, len, num)) {\n      pushInt64(num);\n    } else if (auto const str = lookupStaticString(slice)) {\n      auto const tv = top++;\n      tv->m_type = KindOfPersistentString;\n      tv->m_data.pstr = str;\n    } else {\n      pushStringData(StringData::Make(start, len, CopyString));\n    }\n    return true;\n  }\n\n  bool parsePacked() {\n    auto const fp = top;\n    if (!matchSeparator(']')) {\n      if (++array_depth >= 0) return false;\n      do {\n        if (!parseValue(true)) return false;\n      } while (matchSeparator(','));\n      --array_depth;\n      if (!matchSeparator(']')) return false;  // Trailing ',' not supported.\n    }\n    auto arr = [&] {\n      if (container_type == JSONContainerType::HACK_ARRAYS) {\n        return top == fp\n          ? ArrayData::CreateVec()\n          : PackedArray::MakeVecNatural(top - fp, fp);\n      }\n      if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n        auto ret = top == fp\n          ? staticEmptyVecArray()->copy()\n          : PackedArray::MakeVecNatural(top - fp, fp);\n        ret->setLegacyArray(true);\n        return ret;\n      }\n      if (container_type == JSONContainerType::DARRAYS_AND_VARRAYS) {\n        return top == fp\n          ? ArrayData::CreateVArray()\n          : PackedArray::MakeVArrayNatural(top - fp, fp);\n      }\n      assertx(container_type == JSONContainerType::DARRAYS);\n      return top == fp\n        ? ArrayData::CreateDArray()\n        : MixedArray::MakeDArrayNatural(top - fp, fp);\n    }();\n    top = fp;\n    pushArrayData(arr);\n    check_non_safepoint_surprise();\n    return true;\n  }\n\n  bool parseMixed() {\n    auto const fp = top;\n    if (!matchSeparator('}')) {\n      if (++array_depth >= 0) return false;\n      do {\n        if (!matchSeparator('\\\"')) return false;  // Only support string keys.\n        if (!parseMixedKey()) return false;\n        // TODO(14491721): Precompute and save hash to avoid deref in MakeMixed.\n        if (!matchSeparator(':')) return false;\n        if (!parseValue(true)) return false;\n      } while (matchSeparator(','));\n      --array_depth;\n      if (!matchSeparator('}')) return false;  // Trailing ',' not supported.\n    }\n    auto arr = [&] {\n      if (container_type == JSONContainerType::HACK_ARRAYS) {\n        return top == fp\n          ? ArrayData::CreateDict()\n          : MixedArray::MakeDict((top - fp) >> 1, fp)->asArrayData();\n      }\n      if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n        auto ret = top == fp\n          ? staticEmptyDictArray()->copy()\n          : MixedArray::MakeDict((top - fp) >> 1, fp)->asArrayData();\n        ret->setLegacyArray(true);\n        return ret;\n      }\n      assertx(container_type == JSONContainerType::DARRAYS ||\n              container_type == JSONContainerType::DARRAYS_AND_VARRAYS);\n      return top == fp\n        ? ArrayData::CreateDArray()\n        : MixedArray::MakeDArray((top - fp) >> 1, fp)->asArrayData();\n    }();\n    // MixedArray::MakeMixed can return nullptr if there are duplicate keys\n    if (!arr) return false;\n    top = fp;\n    pushArrayData(arr);\n    check_non_safepoint_surprise();\n    return true;\n  }\n\n  /*\n   * Parse remainder of number after initial character firstChar (maybe '-').\n   */\n  bool parseNumber(char firstChar, bool array_elem = false) {\n    uint64_t x = 0;\n    bool neg = false;\n    const char* begin = p - 1;\n    if (firstChar == '-') {\n      neg = true;\n    } else {\n      x = firstChar - '0';  // first digit\n    }\n    // Parse maximal digit sequence into x (non-negative).\n    while (*p >= '0' && *p <= '9') {\n      x = (x * 10) + (*p - '0');\n      ++p;\n    }\n    if (*p == '.' || *p == 'e' || *p == 'E') {\n      pushDouble(zend_strtod(begin, &p));\n      return true;\n    }\n\n    auto len = p - begin;\n\n    // JSON arrays don't permit leading 0's in numbers.\n    if (UNLIKELY(len > 1 && firstChar == '0' && array_elem)) {\n      return false;\n    }\n\n    // Now 'x' is the usigned absolute value of a naively parsed integer, but\n    // potentially overflowed mod 2^64.\n    if (LIKELY(len < 19) || (len == 19 && firstChar <= '8')) {\n      int64_t sx = x;\n      pushInt64(neg ? -sx : sx);\n    } else {\n      parseBigInt(len);\n    }\n    return true;\n  }\n\n  /*\n   * Assuming 'len' characters ('0'-'9', maybe prefix '-') have been read,\n   * re-parse and push as an int64_t if possible, otherwise as a double.\n   */\n  void parseBigInt(int len) {\n    assertx(*p > '9' || *p < '0');  // Aleady read maximal digit sequence.\n    errno = 0;\n    const int64_t sx = strtoll(p - len, nullptr, 10);\n    if (errno == ERANGE) {\n      const double dval = zend_strtod(p - len, nullptr);\n      assertx(dval == floor(dval));\n      pushDouble(dval);\n    } else {\n      pushInt64(sx);\n    }\n  }\n\n  void pushDouble(double data) {\n    auto const tv = top++;\n    tv->m_type = KindOfDouble;\n    tv->m_data.dbl = data;\n  }\n\n  void pushInt64(int64_t data) {\n    auto const tv = top++;\n    tv->m_type = KindOfInt64;\n    tv->m_data.num = data;\n  }\n\n  void pushStringData(StringData* data) {\n    auto const tv = top++;\n    tv->m_type = KindOfString;\n    tv->m_data.pstr = data;\n  }\n\n  void pushArrayData(ArrayData* data) {\n    auto const tv = top++;\n    tv->m_type = data->toDataType();\n    tv->m_data.parr = data;\n    assertx(IMPLIES(arrprov::arrayWantsTag(data), arrprov::getTag(data)));\n  }\n\n  const char* p;\n  TypedValue* top;\n  int array_depth;\n  JSONContainerType container_type;\n  bool is_tsimplejson;\n};\n\n/*\n * String buffer wrapper that does NOT check its capacity in release mode. User\n * supplies the allocation and must ensure to never append past the end.\n */\nstruct UncheckedBuffer {\n  void clear() { p = begin; }\n  // Use given buffer with space for 'cap' chars, including '\\0'.\n  void setBuf(char* buf, size_t cap) {\n    begin = p = buf;\n#ifndef NDEBUG\n    end = begin + cap;\n#endif\n  }\n  void append(char c) {\n    assertx(p < end);\n    *p++ = c;\n  }\n  void shrinkBy(int decrease) {\n    p -= decrease;\n    assertx(p >= begin);\n  }\n  int size() { return p - begin; }\n  // NUL-terminates the output before returning it, for backward-compatibility.\n  char* data() {\n    assertx(p < end);\n    *p = 0;\n    return begin;\n  }\n  String copy() { return String(data(), size(), CopyString); }\n\n  char* p{nullptr};\n  char* begin{nullptr};\n#ifndef NDEBUG\n  char* end{nullptr};\n#endif\n};\n\n}\n\n/**\n * A stack maintains the states of nested structures.\n */\nstruct json_parser {\n  struct json_state {\n    Mode mode;\n    String key;\n    Variant val;\n  };\n  folly::fbvector<json_state> stack;\n  // check_non_safepoint_surprise() above will not trigger gc\n  TYPE_SCAN_IGNORE_FIELD(stack);\n  int top;\n  int mark; // the watermark\n  int depth;\n  json_error_codes error_code;\n  // Thread-local buffer; reused on each call. JSON parsing cannot lead to code\n  // execution and is not re-entrant. SimpleParser assumes no surprise checks.\n  union {\n    TypedValue* tv{nullptr};  // SimpleParser's stack.\n    char* raw;                // sb_buf/key\n  } tl_buffer;\n  TYPE_SCAN_IGNORE_FIELD(tv);\n  UncheckedBuffer sb_buf;\n  UncheckedBuffer sb_key;\n  int sb_cap{0};  // Capacity of each of sb_buf/key.\n\n  void initSb(int length) {\n    if (UNLIKELY(length >= sb_cap)) {\n      // No decoded string in the output can use more bytes than input size.\n      const auto new_cap = length + 1;\n      size_t bufSize = length <= RuntimeOption::EvalSimpleJsonMaxLength ?\n        SimpleParser::BufferBytesForLength(length) :\n        new_cap * 2;\n      if (tl_buffer.raw) {\n        json_free(tl_buffer.raw);\n        tl_buffer.raw = nullptr;\n      }\n      sb_cap = 0;\n      if (!tl_heap->preAllocOOM(bufSize)) {\n        tl_buffer.raw = (char*)json_malloc(bufSize);\n        if (!tl_buffer.raw) tl_heap->forceOOM();\n      }\n      check_non_safepoint_surprise();\n      always_assert(tl_buffer.raw);\n      sb_buf.setBuf(tl_buffer.raw, new_cap);\n      sb_key.setBuf(tl_buffer.raw + new_cap, new_cap);\n      // Set new capacity if and ony if allocations succeed.\n      sb_cap = new_cap;\n    } else {\n      sb_buf.clear();\n      sb_key.clear();\n    }\n  }\n  void flushSb() {\n    if (tl_buffer.raw) {\n      json_free(tl_buffer.raw);\n      tl_buffer.raw = nullptr;\n    }\n    sb_cap = 0;\n    sb_buf.setBuf(nullptr, 0);\n    sb_key.setBuf(nullptr, 0);\n  }\n private:\n  static void* json_malloc(size_t size) {\n    if (RuntimeOption::EvalJsonParserUseLocalArena) {\n      return local_malloc(size);\n    } else {\n      return malloc(size);\n    }\n  }\n  static void json_free(void* ptr) {\n    if (RuntimeOption::EvalJsonParserUseLocalArena) {\n      return local_free(ptr);\n    } else {\n      return free(ptr);\n    }\n  }\n};\n\nRDS_LOCAL(json_parser, s_json_parser);\n\n// In Zend, the json_parser struct is publicly\n// accessible. Thus the fields could be accessed\n// directly. Just using setter/accessor functions\n// to get around that.\njson_error_codes json_get_last_error_code() {\n  return s_json_parser->error_code;\n}\n\nvoid json_set_last_error_code(json_error_codes ec) {\n  s_json_parser->error_code = ec;\n}\n\nconst char *json_get_last_error_msg() {\n  switch (s_json_parser->error_code) {\n    case JSON_ERROR_NONE:\n      return \"No error\";\n    case JSON_ERROR_DEPTH:\n      return \"Maximum stack depth exceeded\";\n    case JSON_ERROR_STATE_MISMATCH:\n      return \"State mismatch (invalid or malformed JSON)\";\n    case JSON_ERROR_CTRL_CHAR:\n      return \"Control character error, possibly incorrectly encoded\";\n    case JSON_ERROR_SYNTAX:\n      return \"Syntax error\";\n    case JSON_ERROR_UTF8:\n      return \"Malformed UTF-8 characters, possibly incorrectly encoded\";\n    case json_error_codes::JSON_ERROR_RECURSION:\n      return \"Recursion detected\";\n    case json_error_codes::JSON_ERROR_INF_OR_NAN:\n      return \"Inf and NaN cannot be JSON encoded\";\n    case json_error_codes::JSON_ERROR_UNSUPPORTED_TYPE:\n      return \"Type is not supported\";\n    default:\n      return \"Unknown error\";\n  }\n}\n\n// For each request, make sure we start with the default error code.\nvoid json_parser_init() {\n  s_json_parser->error_code = JSON_ERROR_NONE;\n}\n\nvoid json_parser_flush_caches() {\n  s_json_parser->flushSb();\n}\n\n/**\n * Push a mode onto the stack. Return false if there is overflow.\n */\nstatic int push(json_parser *json, Mode mode) {\n  if (json->top + 1 >= json->depth) {\n    return false;\n  }\n  json->top += 1;\n  json->stack[json->top].mode = mode;\n  if (json->top > json->mark) {\n    json->mark = json->top;\n  }\n  return true;\n}\n\n\n/**\n * Pop the stack, assuring that the current mode matches the expectation.\n * Return false if there is underflow or if the modes mismatch.\n */\nstatic int pop(json_parser *json, Mode mode) {\n  if (json->top < 0 || json->stack[json->top].mode != mode) {\n    return false;\n  }\n  json->stack[json->top].mode = Mode::INVALID;\n  json->top -= 1;\n  return true;\n}\n\nstatic String copy_and_clear(UncheckedBuffer &buf) {\n  auto ret = buf.size() > 0 ? buf.copy() : empty_string();\n  buf.clear();\n  return ret;\n}\n\nstatic Variant to_double(UncheckedBuffer &buf) {\n  auto data = buf.data();\n  auto ret = data ? zend_strtod(data, nullptr) : 0.0;\n  buf.clear();\n  return ret;\n}\n\nstatic void json_create_zval(Variant &z, UncheckedBuffer &buf, DataType type,\n                             int64_t options) {\n  switch (type) {\n    case KindOfBoolean:\n      z = (buf.data() && (*buf.data() == 't'));\n      return;\n\n    case KindOfInt64: {\n      bool bigint = false;\n      const char *p = buf.data();\n      assertx(p);\n      if (p == NULL) {\n        z = int64_t(0);\n        return;\n      }\n\n      bool neg = *buf.data() == '-';\n\n      int len = buf.size();\n      if (neg) len--;\n      if (len >= MAX_LENGTH_OF_LONG - 1) {\n        if (len == MAX_LENGTH_OF_LONG - 1) {\n          int cmp = strcmp(p + (neg ? 1 : 0), long_min_digits);\n          if (!(cmp < 0 || (cmp == 0 && neg))) {\n            bigint = true;\n          }\n        } else {\n          bigint = true;\n        }\n      }\n\n      if (bigint) {\n        if (!(options & k_JSON_BIGINT_AS_STRING)) {\n          // See KindOfDouble (below)\n          z = to_double(buf);\n        } else {\n          z = copy_and_clear(buf);\n        }\n      } else {\n        z = fast_strtoll_base10(buf.data());\n      }\n      return;\n    }\n\n    case KindOfDouble:\n      // Use zend_strtod() instead of strtod() here since JSON specifies using\n      // a '.' for decimal separators regardless of locale.\n      z = to_double(buf);\n      return;\n\n    case KindOfString:\n      z = copy_and_clear(buf);\n      return;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfPersistentString:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfObject:\n    case KindOfResource:\n    case KindOfFunc:\n    case KindOfClass:\n    case KindOfClsMeth:\n    case KindOfRecord:\n      z = uninit_null();\n      return;\n  }\n  not_reached();\n}\n\nNEVER_INLINE\nvoid utf16_to_utf8_tail(UncheckedBuffer &buf, unsigned short utf16) {\n  if (utf16 < 0x800) {\n    buf.append((char)(0xc0 | (utf16 >> 6)));\n    buf.append((char)(0x80 | (utf16 & 0x3f)));\n  } else if ((utf16 & 0xfc00) == 0xdc00\n             && buf.size() >= 3\n             && ((unsigned char)buf.data()[buf.size() - 3]) == 0xed\n             && ((unsigned char)buf.data()[buf.size() - 2] & 0xf0) == 0xa0\n             && ((unsigned char)buf.data()[buf.size() - 1] & 0xc0) == 0x80) {\n    /* found surrogate pair */\n    unsigned long utf32;\n\n    utf32 = (((buf.data()[buf.size() - 2] & 0xf) << 16)\n             | ((buf.data()[buf.size() - 1] & 0x3f) << 10)\n             | (utf16 & 0x3ff)) + 0x10000;\n    buf.shrinkBy(3);\n\n    buf.append((char)(0xf0 | (utf32 >> 18)));\n    buf.append((char)(0x80 | ((utf32 >> 12) & 0x3f)));\n    buf.append((char)(0x80 | ((utf32 >> 6) & 0x3f)));\n    buf.append((char)(0x80 | (utf32 & 0x3f)));\n  } else {\n    buf.append((char)(0xe0 | (utf16 >> 12)));\n    buf.append((char)(0x80 | ((utf16 >> 6) & 0x3f)));\n    buf.append((char)(0x80 | (utf16 & 0x3f)));\n  }\n}\n\nALWAYS_INLINE\nvoid utf16_to_utf8(UncheckedBuffer &buf, unsigned short utf16) {\n  if (LIKELY(utf16 < 0x80)) {\n    buf.append((char)utf16);\n    return;\n  }\n  return utf16_to_utf8_tail(buf, utf16);\n}\n\nStaticString s__empty_(\"_empty_\");\n\nstatic void object_set(const json_parser* json,\n                       Variant &var,\n                       const String& key,\n                       const Variant& value,\n                       int assoc,\n                       JSONContainerType container_type) {\n  if (!assoc) {\n    // We know it is stdClass, and everything is public (and dynamic).\n    if (key.empty()) {\n      var.getObjectData()->setProp(nullptr, s__empty_.get(), *value.asTypedValue());\n    } else {\n      var.getObjectData()->o_set(key, value);\n    }\n  } else {\n    if (container_type == JSONContainerType::COLLECTIONS) {\n      auto keyTV = make_tv<KindOfString>(key.get());\n      collections::set(var.getObjectData(), &keyTV, value.asTypedValue());\n    } else if (container_type == JSONContainerType::HACK_ARRAYS ||\n               container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n      forceToDict(var).set(key, value);\n    } else {\n      int64_t i;\n      if (key.get()->isStrictlyInteger(i)) {\n        forceToDArray(var).set(i, value);\n      } else {\n        forceToDArray(var).set(key, value);\n      }\n    }\n    if (var.isArray()) {\n      DEBUG_ONLY auto const data = var.getArrayData();\n      assertx(IMPLIES(arrprov::arrayWantsTag(data), arrprov::getTag(data)));\n    }\n  }\n}\n\nstatic void attach_zval(json_parser *json,\n                        const String& key,\n                        int assoc,\n                        JSONContainerType container_type) {\n  if (json->top < 1) {\n    return;\n  }\n\n  auto& root = json->stack[json->top - 1].val;\n  auto& child =  json->stack[json->top].val;\n  auto up_mode = json->stack[json->top - 1].mode;\n\n  if (up_mode == Mode::ARRAY) {\n    if (container_type == JSONContainerType::COLLECTIONS) {\n      collections::append(root.getObjectData(), child.asTypedValue());\n    } else {\n      root.asArrRef().append(child);\n    }\n  } else if (up_mode == Mode::OBJECT) {\n    object_set(json, root, key, child, assoc, container_type);\n  }\n}\n\nJSONContainerType get_container_type_from_options(int64_t options) {\n  if ((options & k_JSON_FB_STABLE_MAPS) ||\n      (options & k_JSON_FB_COLLECTIONS)) {\n    return JSONContainerType::COLLECTIONS;\n  }\n\n  if (options & k_JSON_FB_HACK_ARRAYS) {\n    return JSONContainerType::HACK_ARRAYS;\n  }\n\n  if (options & k_JSON_FB_DARRAYS) {\n    return JSONContainerType::DARRAYS;\n  }\n\n  if (options & k_JSON_FB_DARRAYS_AND_VARRAYS) {\n    return JSONContainerType::DARRAYS_AND_VARRAYS;\n  }\n\n  if (options & k_JSON_FB_LEGACY_HACK_ARRAYS) {\n    return JSONContainerType::LEGACY_HACK_ARRAYS;\n  }\n\n  return JSONContainerType::DARRAYS;\n}\n\n/**\n * The JSON_parser takes a UTF-8 encoded string and determines if it is a\n * syntactically correct JSON text. Along the way, it creates a PHP variable.\n *\n * It is implemented as a Pushdown Automaton; that means it is a finite state\n * machine with a stack.\n *\n * The behavior is as follows:\n * Container Type       | is_assoc | JSON input => output type\n *\n * COLLECTIONS          | true     | \"{}\"       => c_Map\n * COLLECTIONS          | false    | \"{}\"       => c_Map\n * COLLECTIONS          | true     | \"[]\"       => c_Vector\n * COLLECTIONS          | false    | \"[]\"       => c_Vector\n *\n * HACK_ARRAYS          | true     | \"{}\"       => dict\n * HACK_ARRAYS          | false    | \"{}\"       => stdClass\n * HACK_ARRAYS          | true     | \"[]\"       => vec\n * HACK_ARRAYS          | false    | \"[]\"       => stdClass\n *\n * DARRAYS              | true     | \"{}\"       => darray\n * DARRAYS              | false    | \"{}\"       => stdClass\n * DARRAYS              | true     | \"[]\"       => darray\n * DARRAYS              | false    | \"[]\"       => stdClass\n *\n * DARRAYS_AND_VARRAYS  | true     | \"{}\"       => darray\n * DARRAYS_AND_VARRAYS  | false    | \"{}\"       => stdClass\n * DARRAYS_AND_VARRAYS  | true     | \"[]\"       => varray\n * DARRAYS_AND_VARRAYS  | false    | \"[]\"       => stdClass\n */\nbool JSON_parser(Variant &z, const char *p, int length, bool const assoc,\n                 int depth, int64_t options) {\n  // No GC safepoints during JSON parsing, please. Code is not re-entrant.\n  NoHandleSurpriseScope no_surprise(SafepointFlags);\n\n  json_parser *json = s_json_parser.get(); /* the parser state */\n  // Clear and reuse the thread-local string buffers. They are only freed if\n  // they exceed kMaxPersistentStringBufferCapacity at exit or if the thread\n  // is explicitly flushed (e.g., due to being idle).\n  json->initSb(length);\n  if (depth <= 0) {\n    json->error_code = json_error_codes::JSON_ERROR_DEPTH;\n    return false;\n  }\n  SCOPE_EXIT {\n    constexpr int kMaxPersistentStringBufferCapacity = 256 * 1024;\n    if (json->sb_cap > kMaxPersistentStringBufferCapacity) json->flushSb();\n  };\n  // SimpleParser only handles the most common set of options. Also, only use it\n  // if its array nesting depth check is *more* restrictive than what the user\n  // asks for, to ensure that the precise semantics of the general case is\n  // applied for all nesting overflows.\n  if (assoc &&\n      options == (options & (k_JSON_FB_LOOSE |\n                             k_JSON_FB_DARRAYS |\n                             k_JSON_FB_DARRAYS_AND_VARRAYS |\n                             k_JSON_FB_HACK_ARRAYS |\n                             k_JSON_FB_THRIFT_SIMPLE_JSON |\n                             k_JSON_FB_LEGACY_HACK_ARRAYS)) &&\n      depth >= SimpleParser::kMaxArrayDepth &&\n      length <= RuntimeOption::EvalSimpleJsonMaxLength &&\n      SimpleParser::TryParse(p, length, json->tl_buffer.tv, z,\n                             get_container_type_from_options(options),\n                             options & k_JSON_FB_THRIFT_SIMPLE_JSON)) {\n    return true;\n  }\n\n  int b;  /* the next character */\n  int c;  /* the next character class */\n  int s;  /* the next state */\n  int state = 0;\n\n  /*<fb>*/\n  bool const loose = options & k_JSON_FB_LOOSE;\n  JSONContainerType const container_type =\n    get_container_type_from_options(options);\n  int qchr = 0;\n  int8_t const *byte_class;\n  int8_t const (*next_state_table)[32];\n  if (loose) {\n    byte_class = loose_ascii_class;\n    next_state_table = loose_state_transition_table;\n  } else {\n    byte_class = ascii_class;\n    next_state_table = state_transition_table;\n  }\n  /*</fb>*/\n\n  UncheckedBuffer *buf = &json->sb_buf;\n  UncheckedBuffer *key = &json->sb_key;\n\n  DataType type = kInvalidDataType;\n  unsigned short escaped_bytes = 0;\n\n  auto reset_type = [&] { type = kInvalidDataType; };\n\n  json->depth = depth;\n  // Since the stack is maintainined on a per request basis, for performance\n  // reasons, it only makes sense to expand if necessary and cycles are wasted\n  // contracting. Calls with a depth other than default should be rare.\n  if (depth > json->stack.size()) {\n    json->stack.resize(depth);\n  }\n  SCOPE_EXIT {\n    if (json->stack.empty()) return;\n    for (int i = 0; i <= json->mark; i++) {\n      json->stack[i].key.reset();\n      json->stack[i].val.unset();\n    }\n    json->mark = -1;\n  };\n\n  json->mark = json->top = -1;\n  push(json, Mode::DONE);\n\n  UTF8To16Decoder decoder(p, length, loose);\n  for (;;) {\n    b = decoder.decode();\n    // Fast-case most common transition: append a simple string character.\n    if (state == 3 && type == KindOfString) {\n      while (b != '\\\"' &&  b != '\\\\' && b != '\\'' && b <= 127 && b >= ' ') {\n        buf->append((char)b);\n        b = decoder.decode();\n      }\n    }\n    if (b == UTF8_END) break; // UTF-8 decoding finishes successfully.\n    if (b == UTF8_ERROR) {\n      s_json_parser->error_code = JSON_ERROR_UTF8;\n      return false;\n    }\n    assertx(b >= 0);\n\n    if ((b & 127) == b) {\n      /*<fb>*/\n      c = byte_class[b];\n      /*</fb>*/\n      if (c <= S_ERR) {\n        s_json_parser->error_code = JSON_ERROR_CTRL_CHAR;\n        return false;\n      }\n    } else {\n      c = S_ETC;\n    }\n    /*\n      Get the next state from the transition table.\n    */\n\n    /*<fb>*/\n    s = next_state_table[state][c];\n\n    if (s == -4) {\n      if (b != qchr) {\n        s = 3;\n      } else {\n        qchr = 0;\n      }\n    }\n    /*</fb>*/\n\n    if (s < 0) {\n      /*\n        Perform one of the predefined actions.\n      */\n      switch (s) {\n        /*\n          empty }\n        */\n      case -9:\n        /*<fb>*/\n        if (json->top == 1) z = json->stack[json->top].val;\n        else {\n        /*</fb>*/\n          attach_zval(json, json->stack[json->top].key, assoc, container_type);\n        /*<fb>*/\n        }\n        /*</fb>*/\n        if (!pop(json, Mode::KEY)) {\n          return false;\n        }\n        state = 9;\n        break;\n        /*\n          {\n        */\n      case -8:\n        if (!push(json, Mode::KEY)) {\n          s_json_parser->error_code = JSON_ERROR_DEPTH;\n          return false;\n        }\n\n        state = 1;\n        if (json->top > 0) {\n          Variant &top = json->stack[json->top].val;\n          /*<fb>*/\n          if (container_type == JSONContainerType::COLLECTIONS) {\n            // stable_maps is meaningless\n            top = req::make<c_Map>();\n          } else {\n          /*</fb>*/\n            if (!assoc) {\n              top = SystemLib::AllocStdClassObject();\n            /* <fb> */\n            } else if (container_type == JSONContainerType::HACK_ARRAYS) {\n              top = Array::CreateDict();\n            } else if (container_type == JSONContainerType::DARRAYS ||\n                       container_type == JSONContainerType::DARRAYS_AND_VARRAYS)\n            {\n              top = Array::CreateDArray();\n            /* </fb> */\n            } else if (\n              container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n              auto arr = staticEmptyDictArray()->copy();\n              arr->setLegacyArray(true);\n              top = arr;\n            } else {\n              top = Array::CreateDArray();\n            }\n          /*<fb>*/\n          }\n          /*</fb>*/\n          json->stack[json->top].key = copy_and_clear(*key);\n          reset_type();\n        }\n        break;\n        /*\n          }\n        */\n      case -7:\n        /*** BEGIN Facebook: json_utf8_loose ***/\n        /*\n          If this is a trailing comma in an object definition,\n          we're in Mode::KEY. In that case, throw that off the\n          stack and restore Mode::OBJECT so that we pretend the\n          trailing comma just didn't happen.\n        */\n        if (loose) {\n          if (pop(json, Mode::KEY)) {\n            push(json, Mode::OBJECT);\n          }\n        }\n        /*** END Facebook: json_utf8_loose ***/\n\n        if (type != kInvalidDataType &&\n            json->stack[json->top].mode == Mode::OBJECT) {\n          Variant mval;\n          json_create_zval(mval, *buf, type, options);\n          Variant &top = json->stack[json->top].val;\n          object_set(json, top, copy_and_clear(*key),\n                     mval, assoc, container_type);\n          buf->clear();\n          reset_type();\n        }\n\n        /*<fb>*/\n        if (json->top == 1) z = json->stack[json->top].val;\n        else {\n        /*</fb>*/\n          attach_zval(json, json->stack[json->top].key,\n            assoc, container_type);\n        /*<fb>*/\n        }\n        /*</fb>*/\n        if (!pop(json, Mode::OBJECT)) {\n          s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;\n          return false;\n        }\n        state = 9;\n        break;\n        /*\n          [\n        */\n      case -6:\n        if (!push(json, Mode::ARRAY)) {\n          s_json_parser->error_code = JSON_ERROR_DEPTH;\n          return false;\n        }\n        state = 2;\n\n        if (json->top > 0) {\n          Variant &top = json->stack[json->top].val;\n          /*<fb>*/\n          if (container_type == JSONContainerType::COLLECTIONS) {\n            top = req::make<c_Vector>();\n          } else if (container_type == JSONContainerType::HACK_ARRAYS) {\n            top = Array::CreateVec();\n          } else if (container_type == JSONContainerType::DARRAYS_AND_VARRAYS) {\n            top = Array::CreateVArray();\n          } else if (container_type == JSONContainerType::DARRAYS) {\n            top = Array::CreateDArray();\n          } else if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n            auto arr = staticEmptyVecArray()->copy();\n            arr->setLegacyArray(true);\n            top = arr;\n          } else {\n            top = Array::CreateDArray();\n          }\n          /*</fb>*/\n          json->stack[json->top].key = copy_and_clear(*key);\n          reset_type();\n        }\n        break;\n        /*\n          ]\n        */\n      case -5:\n        {\n          if (type != kInvalidDataType &&\n               json->stack[json->top].mode == Mode::ARRAY) {\n            Variant mval;\n            json_create_zval(mval, *buf, type, options);\n            auto& top = json->stack[json->top].val;\n            if (container_type == JSONContainerType::COLLECTIONS) {\n              collections::append(top.getObjectData(), mval.asTypedValue());\n            } else {\n              top.asArrRef().append(mval);\n            }\n            buf->clear();\n            reset_type();\n          }\n\n          /*<fb>*/\n          if (json->top == 1) z = json->stack[json->top].val;\n          else {\n          /*</fb>*/\n            attach_zval(json, json->stack[json->top].key, assoc,\n              container_type);\n          /*<fb>*/\n          }\n          /*</fb>*/\n          if (!pop(json, Mode::ARRAY)) {\n            s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;\n            return false;\n          }\n          state = 9;\n        }\n        break;\n        /*\n          \"\n        */\n      case -4:\n        switch (json->stack[json->top].mode) {\n        case Mode::KEY:\n          state = 27;\n          std::swap(buf, key);\n          reset_type();\n          break;\n        case Mode::ARRAY:\n        case Mode::OBJECT:\n          state = 9;\n          break;\n        case Mode::DONE:\n          if (type == KindOfString) {\n            z = copy_and_clear(*buf);\n            state = 9;\n            break;\n          }\n          /* fall through if not KindOfString */\n        default:\n          s_json_parser->error_code = JSON_ERROR_SYNTAX;\n          return false;\n        }\n        break;\n        /*\n          ,\n        */\n      case -3:\n        {\n          Variant mval;\n          if (type != kInvalidDataType &&\n              (json->stack[json->top].mode == Mode::OBJECT ||\n               json->stack[json->top].mode == Mode::ARRAY)) {\n            json_create_zval(mval, *buf, type, options);\n          }\n\n          switch (json->stack[json->top].mode) {\n          case Mode::OBJECT:\n            if (pop(json, Mode::OBJECT) &&\n                push(json, Mode::KEY)) {\n              if (type != kInvalidDataType) {\n                Variant &top = json->stack[json->top].val;\n                object_set(\n                  json,\n                  top,\n                  copy_and_clear(*key),\n                  mval,\n                  assoc,\n                  container_type\n                );\n              }\n              state = 29;\n            }\n            break;\n          case Mode::ARRAY:\n            if (type != kInvalidDataType) {\n              auto& top = json->stack[json->top].val;\n              if (container_type == JSONContainerType::COLLECTIONS) {\n                collections::append(top.getObjectData(), mval.asTypedValue());\n              } else {\n                top.asArrRef().append(mval);\n              }\n            }\n            state = 28;\n            break;\n          default:\n            s_json_parser->error_code = JSON_ERROR_SYNTAX;\n            return false;\n          }\n          buf->clear();\n          reset_type();\n          check_non_safepoint_surprise();\n        }\n        break;\n\n        /*<fb>*/\n        /*\n          : (after unquoted string)\n        */\n      case -10:\n        if (json->stack[json->top].mode == Mode::KEY) {\n          state = 27;\n          std::swap(buf, key);\n          reset_type();\n          s = -2;\n        } else {\n          s = 3;\n          break;\n        }\n        /*</fb>*/\n\n        /*\n          :\n        */\n      case -2:\n        if (pop(json, Mode::KEY) && push(json, Mode::OBJECT)) {\n          state = 28;\n          break;\n        }\n        /*\n          syntax error\n        */\n      case -1:\n        s_json_parser->error_code = JSON_ERROR_SYNTAX;\n        return false;\n      }\n    } else {\n      /*\n        Change the state and iterate.\n      */\n      bool is_tsimplejson = options & k_JSON_FB_THRIFT_SIMPLE_JSON;\n      if (type == KindOfString) {\n        if (/*<fb>*/(/*</fb>*/s == 3/*<fb>*/ || s == 30)/*</fb>*/ &&\n            state != 8) {\n          if (state != 4) {\n            utf16_to_utf8(*buf, b);\n          } else {\n            switch (b) {\n            case 'b': buf->append('\\b'); break;\n            case 't': buf->append('\\t'); break;\n            case 'n': buf->append('\\n'); break;\n            case 'f': buf->append('\\f'); break;\n            case 'r': buf->append('\\r'); break;\n            default:\n              utf16_to_utf8(*buf, b);\n              break;\n            }\n          }\n        } else if (s == 6) {\n          if (UNLIKELY(is_tsimplejson)) {\n            if (UNLIKELY(b != '0'))  {\n              s_json_parser->error_code = JSON_ERROR_SYNTAX;\n              return false;\n            }\n            escaped_bytes = 0;\n          } else {\n            escaped_bytes = dehexchar(b) << 12;\n          }\n        } else if (s == 7) {\n          if (UNLIKELY(is_tsimplejson)) {\n            if (UNLIKELY(b != '0'))  {\n              s_json_parser->error_code = JSON_ERROR_SYNTAX;\n              return false;\n            }\n          } else {\n            escaped_bytes += dehexchar(b) << 8;\n          }\n        } else if (s == 8) {\n          escaped_bytes += dehexchar(b) << 4;\n        } else if (s == 3 && state == 8) {\n          escaped_bytes += dehexchar(b);\n          if (UNLIKELY(is_tsimplejson)) {\n            buf->append((char)escaped_bytes);\n          } else {\n            utf16_to_utf8(*buf, escaped_bytes);\n          }\n        }\n      } else if ((type == kInvalidDataType || type == KindOfNull) &&\n                 (c == S_DIG || c == S_ZER)) {\n        type = KindOfInt64;\n        buf->append((char)b);\n      } else if (type == KindOfInt64 && s == 24) {\n        type = KindOfDouble;\n        buf->append((char)b);\n      } else if ((type == kInvalidDataType || type == KindOfNull ||\n                  type == KindOfInt64) &&\n                 c == S_DOT) {\n        type = KindOfDouble;\n        buf->append((char)b);\n      } else if (type != KindOfString && c == S_QUO) {\n        type = KindOfString;\n        /*<fb>*/qchr = b;/*</fb>*/\n      } else if ((type == kInvalidDataType || type == KindOfNull ||\n                  type == KindOfInt64 || type == KindOfDouble) &&\n                 ((state == 12 && s == 9) ||\n                  (state == 16 && s == 9))) {\n        type = KindOfBoolean;\n      } else if (type == kInvalidDataType && state == 19 && s == 9) {\n        type = KindOfNull;\n      } else if (type != KindOfString && c > S_WSP) {\n        utf16_to_utf8(*buf, b);\n      }\n\n      state = s;\n    }\n  }\n\n  if (state == 9 && pop(json, Mode::DONE)) {\n    s_json_parser->error_code = JSON_ERROR_NONE;\n    return true;\n  }\n\n  s_json_parser->error_code = JSON_ERROR_SYNTAX;\n  return false;\n}\n}\n\n#endif /* HAVE_JSONC */\n", "<?hh\n\nvar_dump(json_decode('\"a\"', false, 0, 0));\nvar_dump(json_decode('\"abc', true, 1000, 0));\n", "NULL\nNULL\n"], "fixing_code": ["/* JSON_parser.c */\n\n/* 2005-12-30 */\n\n/*\nCopyright (c) 2005 JSON.org\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nThe Software shall be used for Good, not Evil.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// If we have json-c then don't use this library since that one has a more\n// permissive licence\n#ifndef HAVE_JSONC\n\n#include \"hphp/runtime/ext/json/JSON_parser.h\"\n\n#include <folly/FBVector.h>\n\n#include \"hphp/runtime/base/array-provenance.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/string-buffer.h\"\n#include \"hphp/runtime/base/request-info.h\"\n#include \"hphp/runtime/base/tv-refcount.h\"\n#include \"hphp/runtime/base/init-fini-node.h\"\n#include \"hphp/runtime/base/utf8-decode.h\"\n#include \"hphp/runtime/ext/json/ext_json.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-map.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-vector.h\"\n#include \"hphp/system/systemlib.h\"\n#include \"hphp/util/fast_strtoll_base10.h\"\n#include \"hphp/zend/zend-strtod.h\"\n\n#define MAX_LENGTH_OF_LONG 20\nstatic const char long_min_digits[] = \"9223372036854775808\";\n\nnamespace HPHP {\n\n/*\n    Characters are mapped into these 32 symbol classes. This allows for\n    significant reductions in the size of the state transition table.\n*/\n\n/* error */\n#define S_ERR -1\n\n/* space */\n#define S_SPA 0\n\n/* other whitespace */\n#define S_WSP 1\n\n/* {  */\n#define S_LBE 2\n\n/* } */\n#define S_RBE 3\n\n/* [ */\n#define S_LBT 4\n\n/* ] */\n#define S_RBT 5\n\n/* : */\n#define S_COL 6\n\n/* , */\n#define S_COM 7\n\n/* \" */\n#define S_QUO 8\n\n/* \\ */\n#define S_BAC 9\n\n/* / */\n#define S_SLA 10\n\n/* + */\n#define S_PLU 11\n\n/* - */\n#define S_MIN 12\n\n/* . */\n#define S_DOT 13\n\n/* 0 */\n#define S_ZER 14\n\n/* 123456789 */\n#define S_DIG 15\n\n/* a */\n#define S__A_ 16\n\n/* b */\n#define S__B_ 17\n\n/* c */\n#define S__C_ 18\n\n/* d */\n#define S__D_ 19\n\n/* e */\n#define S__E_ 20\n\n/* f */\n#define S__F_ 21\n\n/* l */\n#define S__L_ 22\n\n/* n */\n#define S__N_ 23\n\n/* r */\n#define S__R_ 24\n\n/* s */\n#define S__S_ 25\n\n/* t */\n#define S__T_ 26\n\n/* u */\n#define S__U_ 27\n\n/* ABCDF */\n#define S_A_F 28\n\n/* E */\n#define S_E   29\n\n/* everything else */\n#define S_ETC 30\n\n\n/*\n    This table maps the 128 ASCII characters into the 32 character classes.\n    The remaining Unicode characters should be mapped to S_ETC.\n*/\nalignas(64) static const int8_t ascii_class[128] = {\n    S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n    S_ERR, S_WSP, S_WSP, S_ERR, S_ERR, S_WSP, S_ERR, S_ERR,\n    S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n    S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n\n    S_SPA, S_ETC, S_QUO, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_PLU, S_COM, S_MIN, S_DOT, S_SLA,\n    S_ZER, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG,\n    S_DIG, S_DIG, S_COL, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n\n    S_ETC, S_A_F, S_A_F, S_A_F, S_A_F, S_E  , S_A_F, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_LBT, S_BAC, S_RBT, S_ETC, S_ETC,\n\n    S_ETC, S__A_, S__B_, S__C_, S__D_, S__E_, S__F_, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_ETC, S__L_, S_ETC, S__N_, S_ETC,\n    S_ETC, S_ETC, S__R_, S__S_, S__T_, S__U_, S_ETC, S_ETC,\n    S_ETC, S_ETC, S_ETC, S_LBE, S_ETC, S_RBE, S_ETC, S_ETC\n};\n\n/*<fb>*/\nalignas(64) static const int8_t loose_ascii_class[128] = {\n  S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n  S_ERR, S_WSP, S_WSP, S_ERR, S_ERR, S_WSP, S_ERR, S_ERR,\n  S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n  S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR, S_ERR,\n\n  S_SPA, S_ETC, S_QUO, S_ETC, S_ETC, S_ETC, S_ETC, S_QUO,\n  S_ETC, S_ETC, S_ETC, S_PLU, S_COM, S_MIN, S_DOT, S_SLA,\n  S_ZER, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG, S_DIG,\n  S_DIG, S_DIG, S_COL, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n\n  S_ETC, S_A_F, S_A_F, S_A_F, S_A_F, S_E  , S_A_F, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_LBT, S_BAC, S_RBT, S_ETC, S_ETC,\n\n  S_ETC, S__A_, S__B_, S__C_, S__D_, S__E_, S__F_, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_ETC, S__L_, S_ETC, S__N_, S_ETC,\n  S_ETC, S_ETC, S__R_, S__S_, S__T_, S__U_, S_ETC, S_ETC,\n  S_ETC, S_ETC, S_ETC, S_LBE, S_ETC, S_RBE, S_ETC, S_ETC\n};\n/*</fb>*/\n\n\n\n/*\n    The state transition table takes the current state and the current symbol,\n    and returns either a new state or an action. A new state is a number between\n    0 and 29. An action is a negative number between -1 and -9. A JSON text is\n    accepted if the end of the text is in state 9 and mode is Mode::DONE.\n*/\nalignas(64) static const int8_t state_transition_table[30][32] = {\n/* 0*/ { 0, 0,-8,-1,-6,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/* 1*/ { 1, 1,-1,-9,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/* 2*/ { 2, 2,-8,-1,-6,-5,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/* 3*/ { 3,-1, 3, 3, 3, 3, 3, 3,-4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},\n/* 4*/ {-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1, 3,-1, 3, 3,-1, 3, 5,-1,-1,-1},\n/* 5*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 6, 6, 6, 6, 6, 6, 6, 6,-1,-1,-1,-1,-1,-1, 6, 6,-1},\n/* 6*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 7, 7, 7, 7, 7, 7, 7, 7,-1,-1,-1,-1,-1,-1, 7, 7,-1},\n/* 7*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8, 8, 8, 8, 8, 8, 8, 8,-1,-1,-1,-1,-1,-1, 8, 8,-1},\n/* 8*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3, 3, 3, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3, 3,-1},\n/* 9*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*10*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1},\n/*11*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1},\n/*12*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*13*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*14*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,-1,-1},\n/*15*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,16,-1,-1,-1,-1,-1},\n/*16*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*17*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,-1,-1,-1},\n/*18*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1},\n/*19*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1},\n/*20*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*21*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,-1,-1,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*22*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,22,22,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*23*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,23,23,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*24*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,25,25,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*25*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*26*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*27*/ {27,27,-1,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*28*/ {28,28,-8,-1,-6,-1,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/*29*/ {29,29,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}\n};\n\n/*<fb>*/\n/*\n  Alternate \"loose\" transition table to support unquoted keys.\n\n  Note: State 3 has same outgoing transitions in both transition tables. This is\n  used below in the fast-case for appending simple characters (3 -> 3).\n*/\nalignas(64) static const int8_t loose_state_transition_table[31][32] = {\n/* 0*/ { 0, 0,-8,-1,-6,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/* 1*/ { 1, 1,-1,-9,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30},\n/* 2*/ { 2, 2,-8,-1,-6,-5,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/* 3*/ { 3,-1, 3, 3, 3, 3, 3, 3,-4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},\n/* 4*/ {-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1, 3,-1, 3, 3,-1, 3, 5,-1,-1,-1},\n/* 5*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 6, 6, 6, 6, 6, 6, 6, 6,-1,-1,-1,-1,-1,-1, 6, 6,-1},\n/* 6*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 7, 7, 7, 7, 7, 7, 7, 7,-1,-1,-1,-1,-1,-1, 7, 7,-1},\n/* 7*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8, 8, 8, 8, 8, 8, 8, 8,-1,-1,-1,-1,-1,-1, 8, 8,-1},\n/* 8*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 3, 3, 3, 3, 3, 3, 3, 3,-1,-1,-1,-1,-1,-1, 3, 3,-1},\n/* 9*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*10*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1},\n/*11*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1},\n/*12*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*13*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*14*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,-1,-1},\n/*15*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,16,-1,-1,-1,-1,-1},\n/*16*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*17*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,-1,-1,-1},\n/*18*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1},\n/*19*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9,-1,-1,-1,-1,-1,-1,-1,-1},\n/*20*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*21*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,-1,-1,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*22*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,23,22,22,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*23*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,23,23,-1,-1,-1,-1,24,-1,-1,-1,-1,-1,-1,-1,-1,24,-1},\n/*24*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,25,25,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*25*/ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*26*/ { 9, 9,-1,-7,-1,-5,-1,-3,-1,-1,-1,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*27*/ {27,27,-1,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},\n/*28*/ {28,28,-8,-1,-6,-5,-1,-1, 3,-1,-1,-1,20,-1,21,22,-1,-1,-1,-1,-1,13,-1,17,-1,-1,10,-1,-1,-1,-1},\n/*29*/ {29,29,-1,-7,-1,-1,-1,-7, 3,-1,-1,-1,-1,-1,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30},\n/*30*/ {30,-1,30,30,30,30,-10,30,-4,4,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30}\n};\n/*</fb>*/\n\n/**\n * These modes can be pushed on the PDA stack.\n */\nenum class Mode {\n  INVALID = 0,\n  DONE = 1,\n  KEY = 2,\n  OBJECT = 3,\n  ARRAY = 4\n};\n\nnamespace {\n\nint dehexchar(char c) {\n  if (c >= '0' && c <= '9') return c - '0';\n  if (c >= 'A' && c <= 'F') return c - ('A' - 10);\n  if (c >= 'a' && c <= 'f') return c - ('a' - 10);\n  return -1;\n}\n\nNEVER_INLINE\nstatic void tvDecRefRange(TypedValue* begin, TypedValue* end) {\n  assertx(begin <= end);\n  for (auto tv = begin; tv != end; ++tv) {\n    tvDecRefGen(tv);\n  }\n}\n\n/*\n * Parses a subset of JSON. Currently unsupported:\n * - Non-ASCII\n * - Character escape sequences\n * - Non-string array keys\n * - Arrays nested > 255 levels\n */\nstruct SimpleParser {\n  static constexpr int kMaxArrayDepth = 255;\n\n  /*\n   * Returns buffer size in bytes needed to handle any input up to given length.\n   */\n  static size_t BufferBytesForLength(int length) {\n    return (length + 1) * sizeof(TypedValue) / 2;  // Worst case: \"[0,0,...,0]\"\n  }\n\n  /*\n   * Returns false for unsupported or malformed input (does not distinguish).\n   */\n  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    if (!ok ||\n        (parser.skipSpace(), parser.p != inp + length)) {\n      // Unsupported, malformed, or trailing garbage. Release entire stack.\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }\n\n private:\n  SimpleParser(const char* input, int length, TypedValue* buffer,\n               JSONContainerType container_type, bool is_tsimplejson)\n    : p(input)\n    , top(buffer)\n    , array_depth(-kMaxArrayDepth) /* Start negative to simplify check. */\n    , container_type(container_type)\n    , is_tsimplejson(is_tsimplejson)\n  {\n    assertx(input[length] == 0);  // Parser relies on sentinel to avoid checks.\n  }\n\n  /*\n   * Skip whitespace, then if next char is 'ch', consume it and return true,\n   * otherwise let it be and return false.\n   */\n  bool matchSeparator(char ch) {\n    if (LIKELY(*p++ == ch)) return true;\n    return matchSeparatorSlow(ch);\n  }\n  NEVER_INLINE\n  bool matchSeparatorSlow(char ch) {\n    --p;\n    skipSpace();\n    if (LIKELY(*p++ == ch)) return true;\n    --p;\n    return false;\n  }\n  NEVER_INLINE\n  void skipSpace() { while (isSpace(*p)) p++; }\n  bool isSpace(char ch) const {\n    return ch == ' ' || ch == '\\n' || ch == '\\t' || ch == '\\f';\n  }\n\n  /*\n   * Variant parser.\n   *\n   * JSON arrays don't permit leading 0's in numbers, so we have to thread that\n   * context through here to parseNumber().\n   */\n  bool parseValue(bool array_elem = false) {\n    auto const ch = *p++;\n    if (ch == '{') return parseMixed();\n    else if (ch == '[') return parsePacked();\n    else if (ch == '\\\"') return parseString();\n    else if ((ch >= '0' && ch <= '9') ||\n              ch == '-') return parseNumber(ch, array_elem);\n    else if (ch == 't') return parseRue();\n    else if (ch == 'f') return parseAlse();\n    else if (ch == 'n') return parseUll();\n    else if (isSpace(ch)) {\n      skipSpace();\n      return parseValue(array_elem);\n    }\n    else return false;\n  }\n\n  bool parseRue() {\n    if (*p++ != 'r') return false;\n    if (*p++ != 'u') return false;\n    if (*p++ != 'e') return false;\n    auto const tv = top++;\n    tv->m_type = KindOfBoolean;\n    tv->m_data.num = true;\n    return true;\n  }\n\n  bool parseAlse() {\n    if (*p++ != 'a') return false;\n    if (*p++ != 'l') return false;\n    if (*p++ != 's') return false;\n    if (*p++ != 'e') return false;\n    auto const tv = top++;\n    tv->m_type = KindOfBoolean;\n    tv->m_data.num = false;\n    return true;\n  }\n\n  bool parseUll() {\n    if (*p++ != 'u') return false;\n    if (*p++ != 'l') return false;\n    if (*p++ != 'l') return false;\n    top++->m_type = KindOfNull;\n    return true;\n  }\n\n  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          if (UNLIKELY(ch1 != '0')) return false;\n          auto const ch2 = *p++;\n          if (UNLIKELY(ch2 != '0')) return false;\n          auto const dch3 = dehexchar(*p++);\n          if (UNLIKELY(dch3 < 0)) return false;\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(dch4 < 0)) return false;\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; // includes check for end of string\n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }\n\n  bool parseRawString(int* len) {\n    assertx(p[-1] == '\"'); // SimpleParser only handles \"-quoted strings\n    *len = 0;\n    auto const charTop = reinterpret_cast<signed char*>(top);\n    for (signed char ch = *p++; ch != '\\\"'; ch = *p++) {\n      charTop[(*len)++] = ch; // overwritten later if `ch == '\\\\'`\n      if (ch < ' ') {\n        // `ch < ' '` catches null and also non-ASCII (since signed char)\n        return false;\n      } else if (ch == '\\\\') {\n        if (!handleBackslash(charTop[*len - 1])) return false;\n      }\n    }\n    return true;\n  }\n\n  bool parseString() {\n    int len;\n    if (!parseRawString(&len)) return false;\n    auto const start = reinterpret_cast<char*>(top);\n    pushStringData(StringData::Make(start, len, CopyString));\n    return true;\n  }\n\n  bool parseMixedKey() {\n    int len;\n    int64_t num;\n    if (!parseRawString(&len)) return false;\n    auto const start = reinterpret_cast<char*>(top);\n    auto const slice = folly::StringPiece(start, len);\n    start[len] = '\\0';\n    if (container_type != JSONContainerType::HACK_ARRAYS &&\n        container_type != JSONContainerType::LEGACY_HACK_ARRAYS &&\n        is_strictly_integer(start, len, num)) {\n      pushInt64(num);\n    } else if (auto const str = lookupStaticString(slice)) {\n      auto const tv = top++;\n      tv->m_type = KindOfPersistentString;\n      tv->m_data.pstr = str;\n    } else {\n      pushStringData(StringData::Make(start, len, CopyString));\n    }\n    return true;\n  }\n\n  bool parsePacked() {\n    auto const fp = top;\n    if (!matchSeparator(']')) {\n      if (++array_depth >= 0) return false;\n      do {\n        if (!parseValue(true)) return false;\n      } while (matchSeparator(','));\n      --array_depth;\n      if (!matchSeparator(']')) return false;  // Trailing ',' not supported.\n    }\n    auto arr = [&] {\n      if (container_type == JSONContainerType::HACK_ARRAYS) {\n        return top == fp\n          ? ArrayData::CreateVec()\n          : PackedArray::MakeVecNatural(top - fp, fp);\n      }\n      if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n        auto ret = top == fp\n          ? staticEmptyVecArray()->copy()\n          : PackedArray::MakeVecNatural(top - fp, fp);\n        ret->setLegacyArray(true);\n        return ret;\n      }\n      if (container_type == JSONContainerType::DARRAYS_AND_VARRAYS) {\n        return top == fp\n          ? ArrayData::CreateVArray()\n          : PackedArray::MakeVArrayNatural(top - fp, fp);\n      }\n      assertx(container_type == JSONContainerType::DARRAYS);\n      return top == fp\n        ? ArrayData::CreateDArray()\n        : MixedArray::MakeDArrayNatural(top - fp, fp);\n    }();\n    top = fp;\n    pushArrayData(arr);\n    check_non_safepoint_surprise();\n    return true;\n  }\n\n  bool parseMixed() {\n    auto const fp = top;\n    if (!matchSeparator('}')) {\n      if (++array_depth >= 0) return false;\n      do {\n        if (!matchSeparator('\\\"')) return false;  // Only support string keys.\n        if (!parseMixedKey()) return false;\n        // TODO(14491721): Precompute and save hash to avoid deref in MakeMixed.\n        if (!matchSeparator(':')) return false;\n        if (!parseValue(true)) return false;\n      } while (matchSeparator(','));\n      --array_depth;\n      if (!matchSeparator('}')) return false;  // Trailing ',' not supported.\n    }\n    auto arr = [&] {\n      if (container_type == JSONContainerType::HACK_ARRAYS) {\n        return top == fp\n          ? ArrayData::CreateDict()\n          : MixedArray::MakeDict((top - fp) >> 1, fp)->asArrayData();\n      }\n      if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n        auto ret = top == fp\n          ? staticEmptyDictArray()->copy()\n          : MixedArray::MakeDict((top - fp) >> 1, fp)->asArrayData();\n        ret->setLegacyArray(true);\n        return ret;\n      }\n      assertx(container_type == JSONContainerType::DARRAYS ||\n              container_type == JSONContainerType::DARRAYS_AND_VARRAYS);\n      return top == fp\n        ? ArrayData::CreateDArray()\n        : MixedArray::MakeDArray((top - fp) >> 1, fp)->asArrayData();\n    }();\n    // MixedArray::MakeMixed can return nullptr if there are duplicate keys\n    if (!arr) return false;\n    top = fp;\n    pushArrayData(arr);\n    check_non_safepoint_surprise();\n    return true;\n  }\n\n  /*\n   * Parse remainder of number after initial character firstChar (maybe '-').\n   */\n  bool parseNumber(char firstChar, bool array_elem = false) {\n    uint64_t x = 0;\n    bool neg = false;\n    const char* begin = p - 1;\n    if (firstChar == '-') {\n      neg = true;\n    } else {\n      x = firstChar - '0';  // first digit\n    }\n    // Parse maximal digit sequence into x (non-negative).\n    while (*p >= '0' && *p <= '9') {\n      x = (x * 10) + (*p - '0');\n      ++p;\n    }\n    if (*p == '.' || *p == 'e' || *p == 'E') {\n      pushDouble(zend_strtod(begin, &p));\n      return true;\n    }\n\n    auto len = p - begin;\n\n    // JSON arrays don't permit leading 0's in numbers.\n    if (UNLIKELY(len > 1 && firstChar == '0' && array_elem)) {\n      return false;\n    }\n\n    // Now 'x' is the usigned absolute value of a naively parsed integer, but\n    // potentially overflowed mod 2^64.\n    if (LIKELY(len < 19) || (len == 19 && firstChar <= '8')) {\n      int64_t sx = x;\n      pushInt64(neg ? -sx : sx);\n    } else {\n      parseBigInt(len);\n    }\n    return true;\n  }\n\n  /*\n   * Assuming 'len' characters ('0'-'9', maybe prefix '-') have been read,\n   * re-parse and push as an int64_t if possible, otherwise as a double.\n   */\n  void parseBigInt(int len) {\n    assertx(*p > '9' || *p < '0');  // Aleady read maximal digit sequence.\n    errno = 0;\n    const int64_t sx = strtoll(p - len, nullptr, 10);\n    if (errno == ERANGE) {\n      const double dval = zend_strtod(p - len, nullptr);\n      assertx(dval == floor(dval));\n      pushDouble(dval);\n    } else {\n      pushInt64(sx);\n    }\n  }\n\n  void pushDouble(double data) {\n    auto const tv = top++;\n    tv->m_type = KindOfDouble;\n    tv->m_data.dbl = data;\n  }\n\n  void pushInt64(int64_t data) {\n    auto const tv = top++;\n    tv->m_type = KindOfInt64;\n    tv->m_data.num = data;\n  }\n\n  void pushStringData(StringData* data) {\n    auto const tv = top++;\n    tv->m_type = KindOfString;\n    tv->m_data.pstr = data;\n  }\n\n  void pushArrayData(ArrayData* data) {\n    auto const tv = top++;\n    tv->m_type = data->toDataType();\n    tv->m_data.parr = data;\n    assertx(IMPLIES(arrprov::arrayWantsTag(data), arrprov::getTag(data)));\n  }\n\n  const char* p;\n  TypedValue* top;\n  int array_depth;\n  JSONContainerType container_type;\n  bool is_tsimplejson;\n};\n\n/*\n * String buffer wrapper that does NOT check its capacity in release mode. User\n * supplies the allocation and must ensure to never append past the end.\n */\nstruct UncheckedBuffer {\n  void clear() { p = begin; }\n  // Use given buffer with space for 'cap' chars, including '\\0'.\n  void setBuf(char* buf, size_t cap) {\n    begin = p = buf;\n#ifndef NDEBUG\n    end = begin + cap;\n#endif\n  }\n  void append(char c) {\n    assertx(p < end);\n    *p++ = c;\n  }\n  void shrinkBy(int decrease) {\n    p -= decrease;\n    assertx(p >= begin);\n  }\n  int size() { return p - begin; }\n  // NUL-terminates the output before returning it, for backward-compatibility.\n  char* data() {\n    assertx(p < end);\n    *p = 0;\n    return begin;\n  }\n  String copy() { return String(data(), size(), CopyString); }\n\n  char* p{nullptr};\n  char* begin{nullptr};\n#ifndef NDEBUG\n  char* end{nullptr};\n#endif\n};\n\n}\n\n/**\n * A stack maintains the states of nested structures.\n */\nstruct json_parser {\n  struct json_state {\n    Mode mode;\n    String key;\n    Variant val;\n  };\n  folly::fbvector<json_state> stack;\n  // check_non_safepoint_surprise() above will not trigger gc\n  TYPE_SCAN_IGNORE_FIELD(stack);\n  int top;\n  int mark; // the watermark\n  int depth;\n  json_error_codes error_code;\n  // Thread-local buffer; reused on each call. JSON parsing cannot lead to code\n  // execution and is not re-entrant. SimpleParser assumes no surprise checks.\n  union {\n    TypedValue* tv{nullptr};  // SimpleParser's stack.\n    char* raw;                // sb_buf/key\n  } tl_buffer;\n  TYPE_SCAN_IGNORE_FIELD(tv);\n  UncheckedBuffer sb_buf;\n  UncheckedBuffer sb_key;\n  int sb_cap{0};  // Capacity of each of sb_buf/key.\n\n  void initSb(int length) {\n    if (UNLIKELY(length >= sb_cap)) {\n      // No decoded string in the output can use more bytes than input size.\n      const auto new_cap = length + 1;\n      size_t bufSize = length <= RuntimeOption::EvalSimpleJsonMaxLength ?\n        SimpleParser::BufferBytesForLength(length) :\n        new_cap * 2;\n      if (tl_buffer.raw) {\n        json_free(tl_buffer.raw);\n        tl_buffer.raw = nullptr;\n      }\n      sb_cap = 0;\n      if (!tl_heap->preAllocOOM(bufSize)) {\n        tl_buffer.raw = (char*)json_malloc(bufSize);\n        if (!tl_buffer.raw) tl_heap->forceOOM();\n      }\n      check_non_safepoint_surprise();\n      always_assert(tl_buffer.raw);\n      sb_buf.setBuf(tl_buffer.raw, new_cap);\n      sb_key.setBuf(tl_buffer.raw + new_cap, new_cap);\n      // Set new capacity if and ony if allocations succeed.\n      sb_cap = new_cap;\n    } else {\n      sb_buf.clear();\n      sb_key.clear();\n    }\n  }\n  void flushSb() {\n    if (tl_buffer.raw) {\n      json_free(tl_buffer.raw);\n      tl_buffer.raw = nullptr;\n    }\n    sb_cap = 0;\n    sb_buf.setBuf(nullptr, 0);\n    sb_key.setBuf(nullptr, 0);\n  }\n private:\n  static void* json_malloc(size_t size) {\n    if (RuntimeOption::EvalJsonParserUseLocalArena) {\n      return local_malloc(size);\n    } else {\n      return malloc(size);\n    }\n  }\n  static void json_free(void* ptr) {\n    if (RuntimeOption::EvalJsonParserUseLocalArena) {\n      return local_free(ptr);\n    } else {\n      return free(ptr);\n    }\n  }\n};\n\nRDS_LOCAL(json_parser, s_json_parser);\n\n// In Zend, the json_parser struct is publicly\n// accessible. Thus the fields could be accessed\n// directly. Just using setter/accessor functions\n// to get around that.\njson_error_codes json_get_last_error_code() {\n  return s_json_parser->error_code;\n}\n\nvoid json_set_last_error_code(json_error_codes ec) {\n  s_json_parser->error_code = ec;\n}\n\nconst char *json_get_last_error_msg() {\n  switch (s_json_parser->error_code) {\n    case JSON_ERROR_NONE:\n      return \"No error\";\n    case JSON_ERROR_DEPTH:\n      return \"Maximum stack depth exceeded\";\n    case JSON_ERROR_STATE_MISMATCH:\n      return \"State mismatch (invalid or malformed JSON)\";\n    case JSON_ERROR_CTRL_CHAR:\n      return \"Control character error, possibly incorrectly encoded\";\n    case JSON_ERROR_SYNTAX:\n      return \"Syntax error\";\n    case JSON_ERROR_UTF8:\n      return \"Malformed UTF-8 characters, possibly incorrectly encoded\";\n    case json_error_codes::JSON_ERROR_RECURSION:\n      return \"Recursion detected\";\n    case json_error_codes::JSON_ERROR_INF_OR_NAN:\n      return \"Inf and NaN cannot be JSON encoded\";\n    case json_error_codes::JSON_ERROR_UNSUPPORTED_TYPE:\n      return \"Type is not supported\";\n    default:\n      return \"Unknown error\";\n  }\n}\n\n// For each request, make sure we start with the default error code.\nvoid json_parser_init() {\n  s_json_parser->error_code = JSON_ERROR_NONE;\n}\n\nvoid json_parser_flush_caches() {\n  s_json_parser->flushSb();\n}\n\n/**\n * Push a mode onto the stack. Return false if there is overflow.\n */\nstatic int push(json_parser *json, Mode mode) {\n  if (json->top + 1 >= json->depth) {\n    return false;\n  }\n  json->top += 1;\n  json->stack[json->top].mode = mode;\n  if (json->top > json->mark) {\n    json->mark = json->top;\n  }\n  return true;\n}\n\n\n/**\n * Pop the stack, assuring that the current mode matches the expectation.\n * Return false if there is underflow or if the modes mismatch.\n */\nstatic int pop(json_parser *json, Mode mode) {\n  if (json->top < 0 || json->stack[json->top].mode != mode) {\n    return false;\n  }\n  json->stack[json->top].mode = Mode::INVALID;\n  json->top -= 1;\n  return true;\n}\n\nstatic String copy_and_clear(UncheckedBuffer &buf) {\n  auto ret = buf.size() > 0 ? buf.copy() : empty_string();\n  buf.clear();\n  return ret;\n}\n\nstatic Variant to_double(UncheckedBuffer &buf) {\n  auto data = buf.data();\n  auto ret = data ? zend_strtod(data, nullptr) : 0.0;\n  buf.clear();\n  return ret;\n}\n\nstatic void json_create_zval(Variant &z, UncheckedBuffer &buf, DataType type,\n                             int64_t options) {\n  switch (type) {\n    case KindOfBoolean:\n      z = (buf.data() && (*buf.data() == 't'));\n      return;\n\n    case KindOfInt64: {\n      bool bigint = false;\n      const char *p = buf.data();\n      assertx(p);\n      if (p == NULL) {\n        z = int64_t(0);\n        return;\n      }\n\n      bool neg = *buf.data() == '-';\n\n      int len = buf.size();\n      if (neg) len--;\n      if (len >= MAX_LENGTH_OF_LONG - 1) {\n        if (len == MAX_LENGTH_OF_LONG - 1) {\n          int cmp = strcmp(p + (neg ? 1 : 0), long_min_digits);\n          if (!(cmp < 0 || (cmp == 0 && neg))) {\n            bigint = true;\n          }\n        } else {\n          bigint = true;\n        }\n      }\n\n      if (bigint) {\n        if (!(options & k_JSON_BIGINT_AS_STRING)) {\n          // See KindOfDouble (below)\n          z = to_double(buf);\n        } else {\n          z = copy_and_clear(buf);\n        }\n      } else {\n        z = fast_strtoll_base10(buf.data());\n      }\n      return;\n    }\n\n    case KindOfDouble:\n      // Use zend_strtod() instead of strtod() here since JSON specifies using\n      // a '.' for decimal separators regardless of locale.\n      z = to_double(buf);\n      return;\n\n    case KindOfString:\n      z = copy_and_clear(buf);\n      return;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfPersistentString:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfObject:\n    case KindOfResource:\n    case KindOfFunc:\n    case KindOfClass:\n    case KindOfClsMeth:\n    case KindOfRecord:\n      z = uninit_null();\n      return;\n  }\n  not_reached();\n}\n\nNEVER_INLINE\nvoid utf16_to_utf8_tail(UncheckedBuffer &buf, unsigned short utf16) {\n  if (utf16 < 0x800) {\n    buf.append((char)(0xc0 | (utf16 >> 6)));\n    buf.append((char)(0x80 | (utf16 & 0x3f)));\n  } else if ((utf16 & 0xfc00) == 0xdc00\n             && buf.size() >= 3\n             && ((unsigned char)buf.data()[buf.size() - 3]) == 0xed\n             && ((unsigned char)buf.data()[buf.size() - 2] & 0xf0) == 0xa0\n             && ((unsigned char)buf.data()[buf.size() - 1] & 0xc0) == 0x80) {\n    /* found surrogate pair */\n    unsigned long utf32;\n\n    utf32 = (((buf.data()[buf.size() - 2] & 0xf) << 16)\n             | ((buf.data()[buf.size() - 1] & 0x3f) << 10)\n             | (utf16 & 0x3ff)) + 0x10000;\n    buf.shrinkBy(3);\n\n    buf.append((char)(0xf0 | (utf32 >> 18)));\n    buf.append((char)(0x80 | ((utf32 >> 12) & 0x3f)));\n    buf.append((char)(0x80 | ((utf32 >> 6) & 0x3f)));\n    buf.append((char)(0x80 | (utf32 & 0x3f)));\n  } else {\n    buf.append((char)(0xe0 | (utf16 >> 12)));\n    buf.append((char)(0x80 | ((utf16 >> 6) & 0x3f)));\n    buf.append((char)(0x80 | (utf16 & 0x3f)));\n  }\n}\n\nALWAYS_INLINE\nvoid utf16_to_utf8(UncheckedBuffer &buf, unsigned short utf16) {\n  if (LIKELY(utf16 < 0x80)) {\n    buf.append((char)utf16);\n    return;\n  }\n  return utf16_to_utf8_tail(buf, utf16);\n}\n\nStaticString s__empty_(\"_empty_\");\n\nstatic void object_set(const json_parser* json,\n                       Variant &var,\n                       const String& key,\n                       const Variant& value,\n                       int assoc,\n                       JSONContainerType container_type) {\n  if (!assoc) {\n    // We know it is stdClass, and everything is public (and dynamic).\n    if (key.empty()) {\n      var.getObjectData()->setProp(nullptr, s__empty_.get(), *value.asTypedValue());\n    } else {\n      var.getObjectData()->o_set(key, value);\n    }\n  } else {\n    if (container_type == JSONContainerType::COLLECTIONS) {\n      auto keyTV = make_tv<KindOfString>(key.get());\n      collections::set(var.getObjectData(), &keyTV, value.asTypedValue());\n    } else if (container_type == JSONContainerType::HACK_ARRAYS ||\n               container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n      forceToDict(var).set(key, value);\n    } else {\n      int64_t i;\n      if (key.get()->isStrictlyInteger(i)) {\n        forceToDArray(var).set(i, value);\n      } else {\n        forceToDArray(var).set(key, value);\n      }\n    }\n    if (var.isArray()) {\n      DEBUG_ONLY auto const data = var.getArrayData();\n      assertx(IMPLIES(arrprov::arrayWantsTag(data), arrprov::getTag(data)));\n    }\n  }\n}\n\nstatic void attach_zval(json_parser *json,\n                        const String& key,\n                        int assoc,\n                        JSONContainerType container_type) {\n  if (json->top < 1) {\n    return;\n  }\n\n  auto& root = json->stack[json->top - 1].val;\n  auto& child =  json->stack[json->top].val;\n  auto up_mode = json->stack[json->top - 1].mode;\n\n  if (up_mode == Mode::ARRAY) {\n    if (container_type == JSONContainerType::COLLECTIONS) {\n      collections::append(root.getObjectData(), child.asTypedValue());\n    } else {\n      root.asArrRef().append(child);\n    }\n  } else if (up_mode == Mode::OBJECT) {\n    object_set(json, root, key, child, assoc, container_type);\n  }\n}\n\nJSONContainerType get_container_type_from_options(int64_t options) {\n  if ((options & k_JSON_FB_STABLE_MAPS) ||\n      (options & k_JSON_FB_COLLECTIONS)) {\n    return JSONContainerType::COLLECTIONS;\n  }\n\n  if (options & k_JSON_FB_HACK_ARRAYS) {\n    return JSONContainerType::HACK_ARRAYS;\n  }\n\n  if (options & k_JSON_FB_DARRAYS) {\n    return JSONContainerType::DARRAYS;\n  }\n\n  if (options & k_JSON_FB_DARRAYS_AND_VARRAYS) {\n    return JSONContainerType::DARRAYS_AND_VARRAYS;\n  }\n\n  if (options & k_JSON_FB_LEGACY_HACK_ARRAYS) {\n    return JSONContainerType::LEGACY_HACK_ARRAYS;\n  }\n\n  return JSONContainerType::DARRAYS;\n}\n\n/**\n * The JSON_parser takes a UTF-8 encoded string and determines if it is a\n * syntactically correct JSON text. Along the way, it creates a PHP variable.\n *\n * It is implemented as a Pushdown Automaton; that means it is a finite state\n * machine with a stack.\n *\n * The behavior is as follows:\n * Container Type       | is_assoc | JSON input => output type\n *\n * COLLECTIONS          | true     | \"{}\"       => c_Map\n * COLLECTIONS          | false    | \"{}\"       => c_Map\n * COLLECTIONS          | true     | \"[]\"       => c_Vector\n * COLLECTIONS          | false    | \"[]\"       => c_Vector\n *\n * HACK_ARRAYS          | true     | \"{}\"       => dict\n * HACK_ARRAYS          | false    | \"{}\"       => stdClass\n * HACK_ARRAYS          | true     | \"[]\"       => vec\n * HACK_ARRAYS          | false    | \"[]\"       => stdClass\n *\n * DARRAYS              | true     | \"{}\"       => darray\n * DARRAYS              | false    | \"{}\"       => stdClass\n * DARRAYS              | true     | \"[]\"       => darray\n * DARRAYS              | false    | \"[]\"       => stdClass\n *\n * DARRAYS_AND_VARRAYS  | true     | \"{}\"       => darray\n * DARRAYS_AND_VARRAYS  | false    | \"{}\"       => stdClass\n * DARRAYS_AND_VARRAYS  | true     | \"[]\"       => varray\n * DARRAYS_AND_VARRAYS  | false    | \"[]\"       => stdClass\n */\nbool JSON_parser(Variant &z, const char *p, int length, bool const assoc,\n                 int depth, int64_t options) {\n  // No GC safepoints during JSON parsing, please. Code is not re-entrant.\n  NoHandleSurpriseScope no_surprise(SafepointFlags);\n\n  json_parser *json = s_json_parser.get(); /* the parser state */\n  // Clear and reuse the thread-local string buffers. They are only freed if\n  // they exceed kMaxPersistentStringBufferCapacity at exit or if the thread\n  // is explicitly flushed (e.g., due to being idle).\n  json->initSb(length);\n  if (depth <= 0) {\n    json->error_code = json_error_codes::JSON_ERROR_DEPTH;\n    return false;\n  }\n  SCOPE_EXIT {\n    constexpr int kMaxPersistentStringBufferCapacity = 256 * 1024;\n    if (json->sb_cap > kMaxPersistentStringBufferCapacity) json->flushSb();\n  };\n  // SimpleParser only handles the most common set of options. Also, only use it\n  // if its array nesting depth check is *more* restrictive than what the user\n  // asks for, to ensure that the precise semantics of the general case is\n  // applied for all nesting overflows.\n  if (assoc &&\n      options == (options & (k_JSON_FB_LOOSE |\n                             k_JSON_FB_DARRAYS |\n                             k_JSON_FB_DARRAYS_AND_VARRAYS |\n                             k_JSON_FB_HACK_ARRAYS |\n                             k_JSON_FB_THRIFT_SIMPLE_JSON |\n                             k_JSON_FB_LEGACY_HACK_ARRAYS)) &&\n      depth >= SimpleParser::kMaxArrayDepth &&\n      length <= RuntimeOption::EvalSimpleJsonMaxLength &&\n      SimpleParser::TryParse(p, length, json->tl_buffer.tv, z,\n                             get_container_type_from_options(options),\n                             options & k_JSON_FB_THRIFT_SIMPLE_JSON)) {\n    return true;\n  }\n\n  int b;  /* the next character */\n  int c;  /* the next character class */\n  int s;  /* the next state */\n  int state = 0;\n\n  /*<fb>*/\n  bool const loose = options & k_JSON_FB_LOOSE;\n  JSONContainerType const container_type =\n    get_container_type_from_options(options);\n  int qchr = 0;\n  int8_t const *byte_class;\n  int8_t const (*next_state_table)[32];\n  if (loose) {\n    byte_class = loose_ascii_class;\n    next_state_table = loose_state_transition_table;\n  } else {\n    byte_class = ascii_class;\n    next_state_table = state_transition_table;\n  }\n  /*</fb>*/\n\n  UncheckedBuffer *buf = &json->sb_buf;\n  UncheckedBuffer *key = &json->sb_key;\n\n  DataType type = kInvalidDataType;\n  unsigned short escaped_bytes = 0;\n\n  auto reset_type = [&] { type = kInvalidDataType; };\n\n  json->depth = depth;\n  // Since the stack is maintainined on a per request basis, for performance\n  // reasons, it only makes sense to expand if necessary and cycles are wasted\n  // contracting. Calls with a depth other than default should be rare.\n  if (depth > json->stack.size()) {\n    json->stack.resize(depth);\n  }\n  SCOPE_EXIT {\n    if (json->stack.empty()) return;\n    for (int i = 0; i <= json->mark; i++) {\n      json->stack[i].key.reset();\n      json->stack[i].val.unset();\n    }\n    json->mark = -1;\n  };\n\n  json->mark = json->top = -1;\n  push(json, Mode::DONE);\n\n  UTF8To16Decoder decoder(p, length, loose);\n  for (;;) {\n    b = decoder.decode();\n    // Fast-case most common transition: append a simple string character.\n    if (state == 3 && type == KindOfString) {\n      while (b != '\\\"' &&  b != '\\\\' && b != '\\'' && b <= 127 && b >= ' ') {\n        buf->append((char)b);\n        b = decoder.decode();\n      }\n    }\n    if (b == UTF8_END) break; // UTF-8 decoding finishes successfully.\n    if (b == UTF8_ERROR) {\n      s_json_parser->error_code = JSON_ERROR_UTF8;\n      return false;\n    }\n    assertx(b >= 0);\n\n    if ((b & 127) == b) {\n      /*<fb>*/\n      c = byte_class[b];\n      /*</fb>*/\n      if (c <= S_ERR) {\n        s_json_parser->error_code = JSON_ERROR_CTRL_CHAR;\n        return false;\n      }\n    } else {\n      c = S_ETC;\n    }\n    /*\n      Get the next state from the transition table.\n    */\n\n    /*<fb>*/\n    s = next_state_table[state][c];\n\n    if (s == -4) {\n      if (b != qchr) {\n        s = 3;\n      } else {\n        qchr = 0;\n      }\n    }\n    /*</fb>*/\n\n    if (s < 0) {\n      /*\n        Perform one of the predefined actions.\n      */\n      switch (s) {\n        /*\n          empty }\n        */\n      case -9:\n        /*<fb>*/\n        if (json->top == 1) z = json->stack[json->top].val;\n        else {\n        /*</fb>*/\n          attach_zval(json, json->stack[json->top].key, assoc, container_type);\n        /*<fb>*/\n        }\n        /*</fb>*/\n        if (!pop(json, Mode::KEY)) {\n          return false;\n        }\n        state = 9;\n        break;\n        /*\n          {\n        */\n      case -8:\n        if (!push(json, Mode::KEY)) {\n          s_json_parser->error_code = JSON_ERROR_DEPTH;\n          return false;\n        }\n\n        state = 1;\n        if (json->top > 0) {\n          Variant &top = json->stack[json->top].val;\n          /*<fb>*/\n          if (container_type == JSONContainerType::COLLECTIONS) {\n            // stable_maps is meaningless\n            top = req::make<c_Map>();\n          } else {\n          /*</fb>*/\n            if (!assoc) {\n              top = SystemLib::AllocStdClassObject();\n            /* <fb> */\n            } else if (container_type == JSONContainerType::HACK_ARRAYS) {\n              top = Array::CreateDict();\n            } else if (container_type == JSONContainerType::DARRAYS ||\n                       container_type == JSONContainerType::DARRAYS_AND_VARRAYS)\n            {\n              top = Array::CreateDArray();\n            /* </fb> */\n            } else if (\n              container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n              auto arr = staticEmptyDictArray()->copy();\n              arr->setLegacyArray(true);\n              top = arr;\n            } else {\n              top = Array::CreateDArray();\n            }\n          /*<fb>*/\n          }\n          /*</fb>*/\n          json->stack[json->top].key = copy_and_clear(*key);\n          reset_type();\n        }\n        break;\n        /*\n          }\n        */\n      case -7:\n        /*** BEGIN Facebook: json_utf8_loose ***/\n        /*\n          If this is a trailing comma in an object definition,\n          we're in Mode::KEY. In that case, throw that off the\n          stack and restore Mode::OBJECT so that we pretend the\n          trailing comma just didn't happen.\n        */\n        if (loose) {\n          if (pop(json, Mode::KEY)) {\n            push(json, Mode::OBJECT);\n          }\n        }\n        /*** END Facebook: json_utf8_loose ***/\n\n        if (type != kInvalidDataType &&\n            json->stack[json->top].mode == Mode::OBJECT) {\n          Variant mval;\n          json_create_zval(mval, *buf, type, options);\n          Variant &top = json->stack[json->top].val;\n          object_set(json, top, copy_and_clear(*key),\n                     mval, assoc, container_type);\n          buf->clear();\n          reset_type();\n        }\n\n        /*<fb>*/\n        if (json->top == 1) z = json->stack[json->top].val;\n        else {\n        /*</fb>*/\n          attach_zval(json, json->stack[json->top].key,\n            assoc, container_type);\n        /*<fb>*/\n        }\n        /*</fb>*/\n        if (!pop(json, Mode::OBJECT)) {\n          s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;\n          return false;\n        }\n        state = 9;\n        break;\n        /*\n          [\n        */\n      case -6:\n        if (!push(json, Mode::ARRAY)) {\n          s_json_parser->error_code = JSON_ERROR_DEPTH;\n          return false;\n        }\n        state = 2;\n\n        if (json->top > 0) {\n          Variant &top = json->stack[json->top].val;\n          /*<fb>*/\n          if (container_type == JSONContainerType::COLLECTIONS) {\n            top = req::make<c_Vector>();\n          } else if (container_type == JSONContainerType::HACK_ARRAYS) {\n            top = Array::CreateVec();\n          } else if (container_type == JSONContainerType::DARRAYS_AND_VARRAYS) {\n            top = Array::CreateVArray();\n          } else if (container_type == JSONContainerType::DARRAYS) {\n            top = Array::CreateDArray();\n          } else if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n            auto arr = staticEmptyVecArray()->copy();\n            arr->setLegacyArray(true);\n            top = arr;\n          } else {\n            top = Array::CreateDArray();\n          }\n          /*</fb>*/\n          json->stack[json->top].key = copy_and_clear(*key);\n          reset_type();\n        }\n        break;\n        /*\n          ]\n        */\n      case -5:\n        {\n          if (type != kInvalidDataType &&\n               json->stack[json->top].mode == Mode::ARRAY) {\n            Variant mval;\n            json_create_zval(mval, *buf, type, options);\n            auto& top = json->stack[json->top].val;\n            if (container_type == JSONContainerType::COLLECTIONS) {\n              collections::append(top.getObjectData(), mval.asTypedValue());\n            } else {\n              top.asArrRef().append(mval);\n            }\n            buf->clear();\n            reset_type();\n          }\n\n          /*<fb>*/\n          if (json->top == 1) z = json->stack[json->top].val;\n          else {\n          /*</fb>*/\n            attach_zval(json, json->stack[json->top].key, assoc,\n              container_type);\n          /*<fb>*/\n          }\n          /*</fb>*/\n          if (!pop(json, Mode::ARRAY)) {\n            s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;\n            return false;\n          }\n          state = 9;\n        }\n        break;\n        /*\n          \"\n        */\n      case -4:\n        switch (json->stack[json->top].mode) {\n        case Mode::KEY:\n          state = 27;\n          std::swap(buf, key);\n          reset_type();\n          break;\n        case Mode::ARRAY:\n        case Mode::OBJECT:\n          state = 9;\n          break;\n        case Mode::DONE:\n          if (type == KindOfString) {\n            z = copy_and_clear(*buf);\n            state = 9;\n            break;\n          }\n          /* fall through if not KindOfString */\n        default:\n          s_json_parser->error_code = JSON_ERROR_SYNTAX;\n          return false;\n        }\n        break;\n        /*\n          ,\n        */\n      case -3:\n        {\n          Variant mval;\n          if (type != kInvalidDataType &&\n              (json->stack[json->top].mode == Mode::OBJECT ||\n               json->stack[json->top].mode == Mode::ARRAY)) {\n            json_create_zval(mval, *buf, type, options);\n          }\n\n          switch (json->stack[json->top].mode) {\n          case Mode::OBJECT:\n            if (pop(json, Mode::OBJECT) &&\n                push(json, Mode::KEY)) {\n              if (type != kInvalidDataType) {\n                Variant &top = json->stack[json->top].val;\n                object_set(\n                  json,\n                  top,\n                  copy_and_clear(*key),\n                  mval,\n                  assoc,\n                  container_type\n                );\n              }\n              state = 29;\n            }\n            break;\n          case Mode::ARRAY:\n            if (type != kInvalidDataType) {\n              auto& top = json->stack[json->top].val;\n              if (container_type == JSONContainerType::COLLECTIONS) {\n                collections::append(top.getObjectData(), mval.asTypedValue());\n              } else {\n                top.asArrRef().append(mval);\n              }\n            }\n            state = 28;\n            break;\n          default:\n            s_json_parser->error_code = JSON_ERROR_SYNTAX;\n            return false;\n          }\n          buf->clear();\n          reset_type();\n          check_non_safepoint_surprise();\n        }\n        break;\n\n        /*<fb>*/\n        /*\n          : (after unquoted string)\n        */\n      case -10:\n        if (json->stack[json->top].mode == Mode::KEY) {\n          state = 27;\n          std::swap(buf, key);\n          reset_type();\n          s = -2;\n        } else {\n          s = 3;\n          break;\n        }\n        /*</fb>*/\n\n        /*\n          :\n        */\n      case -2:\n        if (pop(json, Mode::KEY) && push(json, Mode::OBJECT)) {\n          state = 28;\n          break;\n        }\n        /*\n          syntax error\n        */\n      case -1:\n        s_json_parser->error_code = JSON_ERROR_SYNTAX;\n        return false;\n      }\n    } else {\n      /*\n        Change the state and iterate.\n      */\n      bool is_tsimplejson = options & k_JSON_FB_THRIFT_SIMPLE_JSON;\n      if (type == KindOfString) {\n        if (/*<fb>*/(/*</fb>*/s == 3/*<fb>*/ || s == 30)/*</fb>*/ &&\n            state != 8) {\n          if (state != 4) {\n            utf16_to_utf8(*buf, b);\n          } else {\n            switch (b) {\n            case 'b': buf->append('\\b'); break;\n            case 't': buf->append('\\t'); break;\n            case 'n': buf->append('\\n'); break;\n            case 'f': buf->append('\\f'); break;\n            case 'r': buf->append('\\r'); break;\n            default:\n              utf16_to_utf8(*buf, b);\n              break;\n            }\n          }\n        } else if (s == 6) {\n          if (UNLIKELY(is_tsimplejson)) {\n            if (UNLIKELY(b != '0'))  {\n              s_json_parser->error_code = JSON_ERROR_SYNTAX;\n              return false;\n            }\n            escaped_bytes = 0;\n          } else {\n            escaped_bytes = dehexchar(b) << 12;\n          }\n        } else if (s == 7) {\n          if (UNLIKELY(is_tsimplejson)) {\n            if (UNLIKELY(b != '0'))  {\n              s_json_parser->error_code = JSON_ERROR_SYNTAX;\n              return false;\n            }\n          } else {\n            escaped_bytes += dehexchar(b) << 8;\n          }\n        } else if (s == 8) {\n          escaped_bytes += dehexchar(b) << 4;\n        } else if (s == 3 && state == 8) {\n          escaped_bytes += dehexchar(b);\n          if (UNLIKELY(is_tsimplejson)) {\n            buf->append((char)escaped_bytes);\n          } else {\n            utf16_to_utf8(*buf, escaped_bytes);\n          }\n        }\n      } else if ((type == kInvalidDataType || type == KindOfNull) &&\n                 (c == S_DIG || c == S_ZER)) {\n        type = KindOfInt64;\n        buf->append((char)b);\n      } else if (type == KindOfInt64 && s == 24) {\n        type = KindOfDouble;\n        buf->append((char)b);\n      } else if ((type == kInvalidDataType || type == KindOfNull ||\n                  type == KindOfInt64) &&\n                 c == S_DOT) {\n        type = KindOfDouble;\n        buf->append((char)b);\n      } else if (type != KindOfString && c == S_QUO) {\n        type = KindOfString;\n        /*<fb>*/qchr = b;/*</fb>*/\n      } else if ((type == kInvalidDataType || type == KindOfNull ||\n                  type == KindOfInt64 || type == KindOfDouble) &&\n                 ((state == 12 && s == 9) ||\n                  (state == 16 && s == 9))) {\n        type = KindOfBoolean;\n      } else if (type == kInvalidDataType && state == 19 && s == 9) {\n        type = KindOfNull;\n      } else if (type != KindOfString && c > S_WSP) {\n        utf16_to_utf8(*buf, b);\n      }\n\n      state = s;\n    }\n  }\n\n  if (state == 9 && pop(json, Mode::DONE)) {\n    s_json_parser->error_code = JSON_ERROR_NONE;\n    return true;\n  }\n\n  s_json_parser->error_code = JSON_ERROR_SYNTAX;\n  return false;\n}\n}\n\n#endif /* HAVE_JSONC */\n", "<?hh\n\nvar_dump(json_decode('\"a\"', false, 0, 0));\nvar_dump(json_decode('\"abc', true, 1000, 0));\nvar_dump(json_decode('\"\\\\u', true, 1000, 17180393472));\n", "NULL\nNULL\nNULL\n"], "filenames": ["hphp/runtime/ext/json/JSON_parser.cpp", "hphp/test/slow/ext_json/decode_crash.php", "hphp/test/slow/ext_json/decode_crash.php.expect"], "buggy_code_start_loc": [455, 4, 2], "buggy_code_end_loc": [462, 4, 2], "fixing_code_start_loc": [456, 5, 3], "fixing_code_end_loc": [463, 6, 4], "type": "CWE-125", "message": "Insufficient boundary checks when decoding JSON in handleBackslash reads out of bounds memory, potentially leading to DOS. This issue affects HHVM 4.45.0, 4.44.0, 4.43.0, 4.42.0, 4.41.0, 4.40.0, 4.39.0, versions between 4.33.0 and 4.38.0 (inclusive), versions between 4.9.0 and 4.32.0 (inclusive), and versions prior to 4.8.7.", "other": {"cve": {"id": "CVE-2020-1888", "sourceIdentifier": "cve-assign@fb.com", "published": "2020-03-03T15:15:11.883", "lastModified": "2020-03-05T20:23:33.857", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient boundary checks when decoding JSON in handleBackslash reads out of bounds memory, potentially leading to DOS. This issue affects HHVM 4.45.0, 4.44.0, 4.43.0, 4.42.0, 4.41.0, 4.40.0, 4.39.0, versions between 4.33.0 and 4.38.0 (inclusive), versions between 4.9.0 and 4.32.0 (inclusive), and versions prior to 4.8.7."}, {"lang": "es", "value": "Comprobaciones de l\u00edmites insuficientes cuando se decodifica JSON en handleBackslash lee la memoria fuera de l\u00edmites, conllevando potencialmente a una DOS. Este problema afecta a HHVM versiones 4.45.0, 4.44.0, 4.43.0, 4.42.0, 4.41.0, 4.40.0, 4.39.0, versiones entre 4.33.0 y 4.38.0 (inclusive), versiones entre 4.9.0 y 4.32.0 (inclusive), y versiones anteriores a 4.8.7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.8.7", "matchCriteriaId": "D1FC3F1B-FB6A-4EC4-8878-0C55652434F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9.0", "versionEndIncluding": "4.32.0", "matchCriteriaId": "D25B1929-CF0F-4D0F-9268-6022762717FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.33.0", "versionEndIncluding": "4.38.0", "matchCriteriaId": "87A4049D-2F34-4F15-83B4-0B620EB43500"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.39.0:*:*:*:*:*:*:*", "matchCriteriaId": "43688064-E2D3-461C-982C-A9702623A41F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.40.0:*:*:*:*:*:*:*", "matchCriteriaId": "EF8C8ED9-02DD-4F9C-9B76-751FACE3ED48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.41.0:*:*:*:*:*:*:*", "matchCriteriaId": "94FEC1E6-58FD-47C1-B05E-80BAE3840532"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.42.0:*:*:*:*:*:*:*", "matchCriteriaId": "503ED662-BA21-469D-9FDC-73622786B29D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.43.0:*:*:*:*:*:*:*", "matchCriteriaId": "F6F55273-3CA7-4432-9D43-951EC943E2B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.44.0:*:*:*:*:*:*:*", "matchCriteriaId": "89BDE742-DE38-444B-9B40-6F14D6047B14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.45.0:*:*:*:*:*:*:*", "matchCriteriaId": "90646244-2B6C-402F-9835-9D540DE1EBC9"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/b3679121bb3c7017ff04b4c08402ffff5cf59b13", "source": "cve-assign@fb.com", "tags": ["Patch"]}, {"url": "https://hhvm.com/blog/2020/02/20/security-update.html", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/b3679121bb3c7017ff04b4c08402ffff5cf59b13"}}