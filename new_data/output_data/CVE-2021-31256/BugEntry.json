{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Get the sample number\nGF_Err stbl_findEntryForTime(GF_SampleTableBox *stbl, u64 DTS, u8 useCTS, u32 *sampleNumber, u32 *prevSampleNumber)\n{\n\tu32 i, j, curSampNum, count;\n\ts32 CTSOffset;\n\tu64 curDTS;\n\tGF_SttsEntry *ent;\n\t(*sampleNumber) = 0;\n\t(*prevSampleNumber) = 0;\n\n\tif (!stbl->TimeToSample) return GF_ISOM_INVALID_FILE;\n\n\t/*CTS is ALWAYS disabled for now to make sure samples are fetched in decoding order. useCTS is therefore disabled*/\n#if 0\n\tif (!stbl->CompositionOffset) useCTS = 0;\n#endif\n\n\t//our cache\n\tif (stbl->TimeToSample->r_FirstSampleInEntry &&\n\t        (DTS >= stbl->TimeToSample->r_CurrentDTS) ) {\n\t\t//if we're using CTS, we don't really know whether we're in the good entry or not\n\t\t//(eg, the real DTS of the sample could be in a previous entry\n\t\ti = stbl->TimeToSample->r_currentEntryIndex;\n\t\tcurDTS = stbl->TimeToSample->r_CurrentDTS;\n\t\tcurSampNum = stbl->TimeToSample->r_FirstSampleInEntry;\n\t} else {\n\t\ti = 0;\n\t\tcurDTS = stbl->TimeToSample->r_CurrentDTS = 0;\n\t\tcurSampNum = stbl->TimeToSample->r_FirstSampleInEntry = 1;\n\t\tstbl->TimeToSample->r_currentEntryIndex = 0;\n\t}\n\n#if 0\n\t//we need to validate our cache if we are using CTS because of B-frames and co...\n\tif (i && useCTS) {\n\t\twhile (1) {\n\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, curSampNum, &CTSOffset);\n\t\t\t//we're too far, rewind\n\t\t\tif ( i && (curDTS + CTSOffset > DTS) ) {\n\t\t\t\tent = &stbl->TimeToSample->entries[i];\n\t\t\t\tcurSampNum -= ent->sampleCount;\n\t\t\t\tcurDTS -= (u64)ent->sampleDelta * ent->sampleCount;\n\t\t\t\ti --;\n\t\t\t} else if (!i) {\n\t\t\t\t//beginning of the table, no choice\n\t\t\t\tcurDTS = stbl->TimeToSample->r_CurrentDTS = 0;\n\t\t\t\tcurSampNum = stbl->TimeToSample->r_FirstSampleInEntry = 1;\n\t\t\t\tstbl->TimeToSample->r_currentEntryIndex = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t//OK now we're good\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t//look for the DTS from this entry\n\tcount = stbl->TimeToSample->nb_entries;\n\tfor (; i<count; i++) {\n\t\tent = &stbl->TimeToSample->entries[i];\n#if 0\n\t\tif (useCTS) {\n\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, curSampNum, &CTSOffset);\n\t\t} else\n#endif\n\t\t{\n\t\t\tCTSOffset = 0;\n\t\t}\n\t\tfor (j=0; j<ent->sampleCount; j++) {\n\t\t\tif (curDTS + CTSOffset >= DTS) goto entry_found;\n\t\t\tcurSampNum += 1;\n\t\t\tcurDTS += ent->sampleDelta;\n\t\t}\n\t\t//we're switching to the next entry, update the cache!\n\t\tstbl->TimeToSample->r_CurrentDTS += (u64)ent->sampleCount * ent->sampleDelta;\n\t\tstbl->TimeToSample->r_currentEntryIndex += 1;\n\t\tstbl->TimeToSample->r_FirstSampleInEntry += ent->sampleCount;\n\t}\n\t//return as is\n\treturn GF_OK;\n\nentry_found:\n\t//do we have the exact time ?\n\tif (curDTS + CTSOffset == DTS) {\n\t\t(*sampleNumber) = curSampNum;\n\t}\n\t//if we match the exact DTS also select this sample\n\telse if (curDTS == DTS) {\n\t\t(*sampleNumber) = curSampNum;\n\t} else {\n\t\t//exception for the first sample (we need to \"load\" the playback)\n\t\tif (curSampNum != 1) {\n\t\t\t(*prevSampleNumber) = curSampNum - 1;\n\t\t} else {\n\t\t\t(*prevSampleNumber) = 1;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//Get the Size of a given sample\nGF_Err stbl_GetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 *Size)\n{\n\tif (!stsz || !SampleNumber || (SampleNumber > stsz->sampleCount))\n\t\treturn GF_BAD_PARAM;\n\n\tif (stsz->sampleSize && (stsz->type != GF_ISOM_BOX_TYPE_STZ2)) {\n\t\t(*Size) = stsz->sampleSize;\n\t} else if (stsz->sizes) {\n\t\t(*Size) = stsz->sizes[SampleNumber - 1];\n\t} else {\n\t\t(*Size) = 0;\n\t}\n\treturn GF_OK;\n}\n\n\n\n//Get the CTS offset of a given sample\nGF_Err stbl_GetSampleCTS(GF_CompositionOffsetBox *ctts, u32 SampleNumber, s32 *CTSoffset)\n{\n\tu32 i;\n\n\t(*CTSoffset) = 0;\n\t//test on SampleNumber is done before\n\tif (!ctts || !SampleNumber) return GF_BAD_PARAM;\n\n\tif (ctts->r_FirstSampleInEntry && (ctts->r_FirstSampleInEntry < SampleNumber) ) {\n\t\ti = ctts->r_currentEntryIndex;\n\t} else {\n\t\tctts->r_FirstSampleInEntry = 1;\n\t\tctts->r_currentEntryIndex = 0;\n\t\ti = 0;\n\t}\n\tfor (; i< ctts->nb_entries; i++) {\n\t\tif (SampleNumber < ctts->r_FirstSampleInEntry + ctts->entries[i].sampleCount) break;\n\t\t//update our cache\n\t\tctts->r_currentEntryIndex += 1;\n\t\tctts->r_FirstSampleInEntry += ctts->entries[i].sampleCount;\n\t}\n\t//no ent, set everything to 0...\n\tif (i==ctts->nb_entries) return GF_OK;\n\t/*asked for a sample not in table - this means CTTS is 0 (that's due to out internal packing construction of CTTS)*/\n\tif (SampleNumber >= ctts->r_FirstSampleInEntry + ctts->entries[i].sampleCount) return GF_OK;\n\t(*CTSoffset) = ctts->entries[i].decodingOffset;\n\treturn GF_OK;\n}\n\n//Get the DTS of a sample\nGF_Err stbl_GetSampleDTS_and_Duration(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS, u32 *duration)\n{\n\tu32 i, j, count;\n\tGF_SttsEntry *ent;\n\n\t(*DTS) = 0;\n\tif (duration) {\n\t\t*duration = 0;\n\t}\n\tif (!stts || !SampleNumber) return GF_BAD_PARAM;\n\n\tent = NULL;\n\t//use our cache\n\tcount = stts->nb_entries;\n\tif (stts->r_FirstSampleInEntry\n\t        && (stts->r_FirstSampleInEntry <= SampleNumber)\n\t        //this is for read/write access\n\t        && (stts->r_currentEntryIndex < count) ) {\n\n\t\ti = stts->r_currentEntryIndex;\n\t} else {\n\t\ti = stts->r_currentEntryIndex = 0;\n\t\tstts->r_FirstSampleInEntry = 1;\n\t\tstts->r_CurrentDTS = 0;\n\t}\n\n\tfor (; i < count; i++) {\n\t\tent = &stts->entries[i];\n\n\t\t//in our entry\n\t\tif (ent->sampleCount + stts->r_FirstSampleInEntry >= 1 + SampleNumber) {\n\t\t\tj = SampleNumber - stts->r_FirstSampleInEntry;\n\t\t\tgoto found;\n\t\t}\n\n\t\t//update our cache\n\t\tstts->r_CurrentDTS += (u64)ent->sampleCount * ent->sampleDelta;\n\t\tstts->r_currentEntryIndex += 1;\n\t\tstts->r_FirstSampleInEntry += ent->sampleCount;\n\t}\n//\tif (SampleNumber >= stts->r_FirstSampleInEntry + ent->sampleCount) return GF_BAD_PARAM;\n\n\t//no ent, this is really weird. Let's assume the DTS is then what is written in the table\n\tif (!ent || (i == count)) {\n\t\t(*DTS) = stts->r_CurrentDTS;\n\t\tif (duration) *duration = ent ? ent->sampleDelta : 0;\n\t}\n\treturn GF_OK;\n\nfound:\n\t(*DTS) = stts->r_CurrentDTS + j * (u64) ent->sampleDelta;\n\tif (duration) *duration = ent->sampleDelta;\n\treturn GF_OK;\n}\n\nGF_Err stbl_GetSampleDTS(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS)\n{\n\treturn stbl_GetSampleDTS_and_Duration(stts, SampleNumber, DTS, NULL);\n}\n//Retrieve closes RAP for a given sample - if sample is RAP, sets the RAP flag\nGF_Err stbl_GetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP)\n{\n\tu32 i;\n\tif (prevRAP) *prevRAP = 0;\n\tif (nextRAP) *nextRAP = 0;\n\n\t(*IsRAP) = RAP_NO;\n\tif (!stss || !SampleNumber) return GF_BAD_PARAM;\n\n\tif (stss->r_LastSyncSample && (stss->r_LastSyncSample < SampleNumber) ) {\n\t\ti = stss->r_LastSampleIndex;\n\t} else {\n\t\ti = 0;\n\t}\n\tfor (; i < stss->nb_entries; i++) {\n\t\t//get the entry\n\t\tif (stss->sampleNumbers[i] == SampleNumber) {\n\t\t\t//update the cache\n\t\t\tstss->r_LastSyncSample = SampleNumber;\n\t\t\tstss->r_LastSampleIndex = i;\n\t\t\t(*IsRAP) = RAP;\n\t\t}\n\t\telse if (stss->sampleNumbers[i] > SampleNumber) {\n\t\t\tif (nextRAP) *nextRAP = stss->sampleNumbers[i];\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (prevRAP) *prevRAP = stss->sampleNumbers[i];\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_SearchSAPs(GF_SampleTableBox *stbl, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP)\n{\n\tu32 i, j, count, count2;\n\tassert(prevRAP);\n\tassert(nextRAP);\n\t(*prevRAP) = 0;\n\t(*nextRAP) = 0;\n\t(*IsRAP) = RAP_NO;\n\n\tif (!stbl->sampleGroups || !stbl->sampleGroupsDescription) return GF_OK;\n\n\tcount = gf_list_count(stbl->sampleGroups);\n\tcount2 = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdp = NULL;\n\t\tBool is_rap_group = 0;\n\t\ts32 roll_distance = 0;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tGF_SampleGroupBox *sg = gf_list_get(stbl->sampleGroups, i);\n\t\tswitch (sg->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tis_rap_group = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tsgdp = gf_list_get(stbl->sampleGroupsDescription, j);\n\t\t\tif (sgdp->grouping_type==sg->grouping_type) break;\n\t\t\tsgdp = NULL;\n\t\t}\n\t\tif (! sgdp) continue;\n\n\t\tfirst_sample_in_entry=1;\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tu32 first_rap_in_entry, last_rap_in_entry;\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\n\t\t\t/*samples in this entry are not RAPs, continue*/\n\t\t\tif (! sg->sample_entries[j].group_description_index) {\n\t\t\t\tfirst_sample_in_entry += sg->sample_entries[j].sample_count;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_rap_group) {\n\t\t\t\tGF_RollRecoveryEntry *entry = gf_list_get(sgdp->group_descriptions, sg->sample_entries[j].group_description_index - 1);\n\t\t\t\troll_distance = entry ? entry->roll_distance : 0;\n\t\t\t}\n\n\t\t\t/*we consider the first sample in a roll or rap group entry to be the RAP (eg, we have to decode from this sample anyway)\n\t\t\texcept if roll_distance is strictly negative in which case we have to rewind our sample numbers from roll_distance*/\n\t\t\tif (roll_distance < 0) {\n\t\t\t\tif ((s32) first_sample_in_entry + roll_distance>=0) first_rap_in_entry = first_sample_in_entry + roll_distance;\n\t\t\t\telse first_rap_in_entry = 0;\n\n\t\t\t\tif ((s32) last_sample_in_entry + roll_distance>=0) last_rap_in_entry = last_sample_in_entry + roll_distance;\n\t\t\t\telse last_rap_in_entry = 0;\n\t\t\t} else {\n\t\t\t\tfirst_rap_in_entry = first_sample_in_entry;\n\t\t\t\tlast_rap_in_entry = last_sample_in_entry;\n\t\t\t}\n\n\t\t\t/*store previous & next sample RAP - note that we do not store the closest previous RAP, only the first of the previous RAP group\n\t\t\tas RAPs are usually isolated this should not be an issue*/\n\t\t\tif (first_rap_in_entry <= SampleNumber) {\n\t\t\t\t*prevRAP = first_rap_in_entry;\n\t\t\t}\n\t\t\t*nextRAP = last_rap_in_entry;\n\t\t\t\n\t\t\t/*sample lies in this (rap) group, it is rap*/\n\t\t\tif (is_rap_group) {\n\t\t\t\tif ((first_rap_in_entry <= SampleNumber) && (SampleNumber <= last_rap_in_entry)) {\n\t\t\t\t\t(*IsRAP) = RAP;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*prevRAP or nextRAP matches SampleNumber, sample is RAP*/\n\t\t\t\tif ((*prevRAP == SampleNumber) || (*nextRAP == SampleNumber)) {\n\t\t\t\t\t(*IsRAP) = RAP;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*first sample in entry is after our target sample, abort*/\n\t\t\tif (first_rap_in_entry > SampleNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst_sample_in_entry += sg->sample_entries[j].sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//get the number of \"ghost chunk\" (implicit chunks described by an entry)\nvoid GetGhostNum(GF_StscEntry *ent, u32 EntryIndex, u32 count, GF_SampleTableBox *stbl)\n{\n\tGF_StscEntry *nextEnt;\n\tu32 ghostNum = 1;\n\n\tif (!ent) {\n\t\tstbl->SampleToChunk->ghostNumber = 0;\n\t\treturn;\n\t}\n\n\tif (!ent->nextChunk) {\n\t\tif (EntryIndex+1 == count) {\n\t\t\t//not specified in the spec, what if the last sample to chunk is no written?\n\t\t\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\t\tghostNum = (stco->nb_entries > ent->firstChunk) ? (1 + stco->nb_entries - ent->firstChunk) : 1;\n\t\t\t} else {\n\t\t\t\tGF_ChunkLargeOffsetBox *co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\t\tghostNum = (co64->nb_entries > ent->firstChunk) ? (1 + co64->nb_entries - ent->firstChunk) : 1;\n\t\t\t}\n\t\t} else {\n\t\t\t//this is an unknown case due to edit mode...\n\t\t\tnextEnt = &stbl->SampleToChunk->entries[EntryIndex+1];\n\t\t\tghostNum = nextEnt->firstChunk - ent->firstChunk;\n\t\t}\n\t} else {\n\t\tghostNum = (ent->nextChunk > ent->firstChunk) ? (ent->nextChunk - ent->firstChunk) : 1;\n\t}\n\tstbl->SampleToChunk->ghostNumber = ghostNum;\n}\n\n//Get the offset, descIndex and chunkNumber of a sample...\nGF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n{\n\tGF_Err e;\n\tu32 i, k, offsetInChunk, size, chunk_num;\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\n\t(*offset) = 0;\n\t(*chunkNumber) = (*descIndex) = 0;\n\tif (out_ent) (*out_ent) = NULL;\n\tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n\tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n\n\tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n\t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\t(*descIndex) = ent->sampleDescriptionIndex;\n\t\t(*chunkNumber) = sampleNumber;\n\t\tif (out_ent) *out_ent = ent;\n\t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n\t\t} else {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//check our cache: if desired sample is at or above current cache entry, start from here\n\tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n\t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n\n\t\ti = stbl->SampleToChunk->currentIndex;\n\t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n\t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\t//otherwise start from first entry\n\telse {\n\t\ti = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n\t\tent = &stbl->SampleToChunk->entries[0];\n\t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\n\t//first get the chunk\n\tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n\t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n\t\t//corrupted file (less sample2chunk info than sample count\n\t\tif (k > stbl->SampleToChunk->ghostNumber) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\n\t\t//check if sample is in current chunk\n\t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n\t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\tif (ent->samplesPerChunk) \n\t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n\n\t\tif (\n\t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n\t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n\t\t) {\n\n\t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n\t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n\t\t\tgoto sample_found;\n\t\t}\n\t\tmax_chunks_in_entry += 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n\t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n\n\t\t//not in this entry, get the next entry if not the last one\n\t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n\t\t\tent = &stbl->SampleToChunk->entries[i+1];\n\t\t\t//update the GhostNumber\n\t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n\t\t\t//update the entry in our cache\n\t\t\tstbl->SampleToChunk->currentIndex = i+1;\n\t\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\t\tk = 1;\n\t\t}\n\t}\n\t//if we get here, gasp, the sample was not found\n\treturn GF_ISOM_INVALID_FILE;\n\nsample_found:\n\n\t(*descIndex) = ent->sampleDescriptionIndex;\n\t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n\tif (out_ent) *out_ent = ent;\n\tif (! *chunkNumber)\n\t\treturn GF_ISOM_INVALID_FILE;\n\t\n\t//ok, get the size of all the previous samples in the chunk\n\toffsetInChunk = 0;\n\t//constant size\n\tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n\t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n\t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n\t\tif (e) return e;\n\t\tstbl->r_last_offset_in_chunk += size;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else {\n\t\t//warning, firstSampleInChunk is at least 1 - not 0\n\t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n\t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n\t\t\tif (e) return e;\n\t\t\toffsetInChunk += size;\n\t\t}\n\t\tstbl->r_last_chunk_num = chunk_num;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n\t}\n\t//OK, that's the size of our offset in the chunk\n\t//now get the chunk\n\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t} else {\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_GetSampleShadow(GF_ShadowSyncBox *stsh, u32 *sampleNumber, u32 *syncNum)\n{\n\tu32 i, count;\n\tGF_StshEntry *ent;\n\n\tif (stsh->r_LastFoundSample && (stsh->r_LastFoundSample <= *sampleNumber)) {\n\t\ti = stsh->r_LastEntryIndex;\n\t} else {\n\t\ti = 0;\n\t\tstsh->r_LastFoundSample = 1;\n\t}\n\n\tent = NULL;\n\t(*syncNum) = 0;\n\n\tcount = gf_list_count(stsh->entries);\n\tfor (; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\t//we get the exact desired sample !\n\t\tif (ent->shadowedSampleNumber == *sampleNumber) {\n\t\t\t(*syncNum) = ent->syncSampleNumber;\n\t\t\tstsh->r_LastFoundSample = *sampleNumber;\n\t\t\tstsh->r_LastEntryIndex = i;\n\t\t\treturn GF_OK;\n\t\t} else if (ent->shadowedSampleNumber > *sampleNumber) {\n\t\t\t//do we have an entry before ? If not, there is no shadowing available\n\t\t\t//for this sample\n\t\t\tif (!i) return GF_OK;\n\t\t\t//ok, indicate the previous ShadowedSample\n\t\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i-1);\n\t\t\t(*syncNum) = ent->syncSampleNumber;\n\t\t\t//change the sample number\n\t\t\t(*sampleNumber) = ent->shadowedSampleNumber;\n\t\t\t//reset the cache to the last ShadowedSample\n\t\t\tstsh->r_LastEntryIndex = i-1;\n\t\t\tstsh->r_LastFoundSample = ent->shadowedSampleNumber;\n\t\t}\n\t}\n\tstsh->r_LastEntryIndex = i-1;\n\tstsh->r_LastFoundSample = ent ? ent->shadowedSampleNumber : 0;\n\treturn GF_OK;\n}\n\n\n\nGF_Err stbl_GetPaddingBits(GF_PaddingBitsBox *padb, u32 SampleNumber, u8 *PadBits)\n{\n\tif (!PadBits) return GF_BAD_PARAM;\n\t*PadBits = 0;\n\tif (!padb || !padb->padbits) return GF_OK;\n\t//the spec says \"should\" not shall. return 0 padding\n\tif (padb->SampleCount < SampleNumber) return GF_OK;\n\t*PadBits = padb->padbits[SampleNumber-1];\n\treturn GF_OK;\n}\n\n//Set the RAP flag of a sample\nGF_Err stbl_GetSampleDepType(GF_SampleDependencyTypeBox *sdep, u32 SampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tu8 flag;\n\n\tassert(dependsOn && dependedOn && redundant);\n\t*dependsOn = *dependedOn = *redundant = 0;\n\n\tif (SampleNumber > sdep->sampleCount) {\n\t\treturn GF_OK;\n\t}\n\tflag = sdep->sample_info[SampleNumber-1];\n\t*isLeading = (flag >> 6) & 3;\n\t*dependsOn = (flag >> 4) & 3;\n\t*dependedOn = (flag >> 2) & 3;\n\t*redundant = (flag) & 3;\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Get the sample number\nGF_Err stbl_findEntryForTime(GF_SampleTableBox *stbl, u64 DTS, u8 useCTS, u32 *sampleNumber, u32 *prevSampleNumber)\n{\n\tu32 i, j, curSampNum, count;\n\ts32 CTSOffset;\n\tu64 curDTS;\n\tGF_SttsEntry *ent;\n\t(*sampleNumber) = 0;\n\t(*prevSampleNumber) = 0;\n\n\tif (!stbl->TimeToSample) return GF_ISOM_INVALID_FILE;\n\n\t/*CTS is ALWAYS disabled for now to make sure samples are fetched in decoding order. useCTS is therefore disabled*/\n#if 0\n\tif (!stbl->CompositionOffset) useCTS = 0;\n#endif\n\n\t//our cache\n\tif (stbl->TimeToSample->r_FirstSampleInEntry &&\n\t        (DTS >= stbl->TimeToSample->r_CurrentDTS) ) {\n\t\t//if we're using CTS, we don't really know whether we're in the good entry or not\n\t\t//(eg, the real DTS of the sample could be in a previous entry\n\t\ti = stbl->TimeToSample->r_currentEntryIndex;\n\t\tcurDTS = stbl->TimeToSample->r_CurrentDTS;\n\t\tcurSampNum = stbl->TimeToSample->r_FirstSampleInEntry;\n\t} else {\n\t\ti = 0;\n\t\tcurDTS = stbl->TimeToSample->r_CurrentDTS = 0;\n\t\tcurSampNum = stbl->TimeToSample->r_FirstSampleInEntry = 1;\n\t\tstbl->TimeToSample->r_currentEntryIndex = 0;\n\t}\n\n#if 0\n\t//we need to validate our cache if we are using CTS because of B-frames and co...\n\tif (i && useCTS) {\n\t\twhile (1) {\n\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, curSampNum, &CTSOffset);\n\t\t\t//we're too far, rewind\n\t\t\tif ( i && (curDTS + CTSOffset > DTS) ) {\n\t\t\t\tent = &stbl->TimeToSample->entries[i];\n\t\t\t\tcurSampNum -= ent->sampleCount;\n\t\t\t\tcurDTS -= (u64)ent->sampleDelta * ent->sampleCount;\n\t\t\t\ti --;\n\t\t\t} else if (!i) {\n\t\t\t\t//beginning of the table, no choice\n\t\t\t\tcurDTS = stbl->TimeToSample->r_CurrentDTS = 0;\n\t\t\t\tcurSampNum = stbl->TimeToSample->r_FirstSampleInEntry = 1;\n\t\t\t\tstbl->TimeToSample->r_currentEntryIndex = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t//OK now we're good\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t//look for the DTS from this entry\n\tcount = stbl->TimeToSample->nb_entries;\n\tfor (; i<count; i++) {\n\t\tent = &stbl->TimeToSample->entries[i];\n#if 0\n\t\tif (useCTS) {\n\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, curSampNum, &CTSOffset);\n\t\t} else\n#endif\n\t\t{\n\t\t\tCTSOffset = 0;\n\t\t}\n\t\tfor (j=0; j<ent->sampleCount; j++) {\n\t\t\tif (curDTS + CTSOffset >= DTS) goto entry_found;\n\t\t\tcurSampNum += 1;\n\t\t\tcurDTS += ent->sampleDelta;\n\t\t}\n\t\t//we're switching to the next entry, update the cache!\n\t\tstbl->TimeToSample->r_CurrentDTS += (u64)ent->sampleCount * ent->sampleDelta;\n\t\tstbl->TimeToSample->r_currentEntryIndex += 1;\n\t\tstbl->TimeToSample->r_FirstSampleInEntry += ent->sampleCount;\n\t}\n\t//return as is\n\treturn GF_OK;\n\nentry_found:\n\t//do we have the exact time ?\n\tif (curDTS + CTSOffset == DTS) {\n\t\t(*sampleNumber) = curSampNum;\n\t}\n\t//if we match the exact DTS also select this sample\n\telse if (curDTS == DTS) {\n\t\t(*sampleNumber) = curSampNum;\n\t} else {\n\t\t//exception for the first sample (we need to \"load\" the playback)\n\t\tif (curSampNum != 1) {\n\t\t\t(*prevSampleNumber) = curSampNum - 1;\n\t\t} else {\n\t\t\t(*prevSampleNumber) = 1;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//Get the Size of a given sample\nGF_Err stbl_GetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 *Size)\n{\n\tif (!stsz || !SampleNumber || (SampleNumber > stsz->sampleCount))\n\t\treturn GF_BAD_PARAM;\n\n\tif (stsz->sampleSize && (stsz->type != GF_ISOM_BOX_TYPE_STZ2)) {\n\t\t(*Size) = stsz->sampleSize;\n\t} else if (stsz->sizes) {\n\t\t(*Size) = stsz->sizes[SampleNumber - 1];\n\t} else {\n\t\t(*Size) = 0;\n\t}\n\treturn GF_OK;\n}\n\n\n\n//Get the CTS offset of a given sample\nGF_Err stbl_GetSampleCTS(GF_CompositionOffsetBox *ctts, u32 SampleNumber, s32 *CTSoffset)\n{\n\tu32 i;\n\n\t(*CTSoffset) = 0;\n\t//test on SampleNumber is done before\n\tif (!ctts || !SampleNumber) return GF_BAD_PARAM;\n\n\tif (ctts->r_FirstSampleInEntry && (ctts->r_FirstSampleInEntry < SampleNumber) ) {\n\t\ti = ctts->r_currentEntryIndex;\n\t} else {\n\t\tctts->r_FirstSampleInEntry = 1;\n\t\tctts->r_currentEntryIndex = 0;\n\t\ti = 0;\n\t}\n\tfor (; i< ctts->nb_entries; i++) {\n\t\tif (SampleNumber < ctts->r_FirstSampleInEntry + ctts->entries[i].sampleCount) break;\n\t\t//update our cache\n\t\tctts->r_currentEntryIndex += 1;\n\t\tctts->r_FirstSampleInEntry += ctts->entries[i].sampleCount;\n\t}\n\t//no ent, set everything to 0...\n\tif (i==ctts->nb_entries) return GF_OK;\n\t/*asked for a sample not in table - this means CTTS is 0 (that's due to out internal packing construction of CTTS)*/\n\tif (SampleNumber >= ctts->r_FirstSampleInEntry + ctts->entries[i].sampleCount) return GF_OK;\n\t(*CTSoffset) = ctts->entries[i].decodingOffset;\n\treturn GF_OK;\n}\n\n//Get the DTS of a sample\nGF_Err stbl_GetSampleDTS_and_Duration(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS, u32 *duration)\n{\n\tu32 i, j, count;\n\tGF_SttsEntry *ent;\n\n\t(*DTS) = 0;\n\tif (duration) {\n\t\t*duration = 0;\n\t}\n\tif (!stts || !SampleNumber) return GF_BAD_PARAM;\n\n\tent = NULL;\n\t//use our cache\n\tcount = stts->nb_entries;\n\tif (stts->r_FirstSampleInEntry\n\t        && (stts->r_FirstSampleInEntry <= SampleNumber)\n\t        //this is for read/write access\n\t        && (stts->r_currentEntryIndex < count) ) {\n\n\t\ti = stts->r_currentEntryIndex;\n\t} else {\n\t\ti = stts->r_currentEntryIndex = 0;\n\t\tstts->r_FirstSampleInEntry = 1;\n\t\tstts->r_CurrentDTS = 0;\n\t}\n\n\tfor (; i < count; i++) {\n\t\tent = &stts->entries[i];\n\n\t\t//in our entry\n\t\tif (ent->sampleCount + stts->r_FirstSampleInEntry >= 1 + SampleNumber) {\n\t\t\tj = SampleNumber - stts->r_FirstSampleInEntry;\n\t\t\tgoto found;\n\t\t}\n\n\t\t//update our cache\n\t\tstts->r_CurrentDTS += (u64)ent->sampleCount * ent->sampleDelta;\n\t\tstts->r_currentEntryIndex += 1;\n\t\tstts->r_FirstSampleInEntry += ent->sampleCount;\n\t}\n//\tif (SampleNumber >= stts->r_FirstSampleInEntry + ent->sampleCount) return GF_BAD_PARAM;\n\n\t//no ent, this is really weird. Let's assume the DTS is then what is written in the table\n\tif (!ent || (i == count)) {\n\t\t(*DTS) = stts->r_CurrentDTS;\n\t\tif (duration) *duration = ent ? ent->sampleDelta : 0;\n\t}\n\treturn GF_OK;\n\nfound:\n\t(*DTS) = stts->r_CurrentDTS + j * (u64) ent->sampleDelta;\n\tif (duration) *duration = ent->sampleDelta;\n\treturn GF_OK;\n}\n\nGF_Err stbl_GetSampleDTS(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS)\n{\n\treturn stbl_GetSampleDTS_and_Duration(stts, SampleNumber, DTS, NULL);\n}\n//Retrieve closes RAP for a given sample - if sample is RAP, sets the RAP flag\nGF_Err stbl_GetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP)\n{\n\tu32 i;\n\tif (prevRAP) *prevRAP = 0;\n\tif (nextRAP) *nextRAP = 0;\n\n\t(*IsRAP) = RAP_NO;\n\tif (!stss || !SampleNumber) return GF_BAD_PARAM;\n\n\tif (stss->r_LastSyncSample && (stss->r_LastSyncSample < SampleNumber) ) {\n\t\ti = stss->r_LastSampleIndex;\n\t} else {\n\t\ti = 0;\n\t}\n\tfor (; i < stss->nb_entries; i++) {\n\t\t//get the entry\n\t\tif (stss->sampleNumbers[i] == SampleNumber) {\n\t\t\t//update the cache\n\t\t\tstss->r_LastSyncSample = SampleNumber;\n\t\t\tstss->r_LastSampleIndex = i;\n\t\t\t(*IsRAP) = RAP;\n\t\t}\n\t\telse if (stss->sampleNumbers[i] > SampleNumber) {\n\t\t\tif (nextRAP) *nextRAP = stss->sampleNumbers[i];\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (prevRAP) *prevRAP = stss->sampleNumbers[i];\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stbl_SearchSAPs(GF_SampleTableBox *stbl, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP)\n{\n\tu32 i, j, count, count2;\n\tassert(prevRAP);\n\tassert(nextRAP);\n\t(*prevRAP) = 0;\n\t(*nextRAP) = 0;\n\t(*IsRAP) = RAP_NO;\n\n\tif (!stbl->sampleGroups || !stbl->sampleGroupsDescription) return GF_OK;\n\n\tcount = gf_list_count(stbl->sampleGroups);\n\tcount2 = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdp = NULL;\n\t\tBool is_rap_group = 0;\n\t\ts32 roll_distance = 0;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tGF_SampleGroupBox *sg = gf_list_get(stbl->sampleGroups, i);\n\t\tswitch (sg->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tis_rap_group = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tsgdp = gf_list_get(stbl->sampleGroupsDescription, j);\n\t\t\tif (sgdp->grouping_type==sg->grouping_type) break;\n\t\t\tsgdp = NULL;\n\t\t}\n\t\tif (! sgdp) continue;\n\n\t\tfirst_sample_in_entry=1;\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tu32 first_rap_in_entry, last_rap_in_entry;\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\n\t\t\t/*samples in this entry are not RAPs, continue*/\n\t\t\tif (! sg->sample_entries[j].group_description_index) {\n\t\t\t\tfirst_sample_in_entry += sg->sample_entries[j].sample_count;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_rap_group) {\n\t\t\t\tGF_RollRecoveryEntry *entry = gf_list_get(sgdp->group_descriptions, sg->sample_entries[j].group_description_index - 1);\n\t\t\t\troll_distance = entry ? entry->roll_distance : 0;\n\t\t\t}\n\n\t\t\t/*we consider the first sample in a roll or rap group entry to be the RAP (eg, we have to decode from this sample anyway)\n\t\t\texcept if roll_distance is strictly negative in which case we have to rewind our sample numbers from roll_distance*/\n\t\t\tif (roll_distance < 0) {\n\t\t\t\tif ((s32) first_sample_in_entry + roll_distance>=0) first_rap_in_entry = first_sample_in_entry + roll_distance;\n\t\t\t\telse first_rap_in_entry = 0;\n\n\t\t\t\tif ((s32) last_sample_in_entry + roll_distance>=0) last_rap_in_entry = last_sample_in_entry + roll_distance;\n\t\t\t\telse last_rap_in_entry = 0;\n\t\t\t} else {\n\t\t\t\tfirst_rap_in_entry = first_sample_in_entry;\n\t\t\t\tlast_rap_in_entry = last_sample_in_entry;\n\t\t\t}\n\n\t\t\t/*store previous & next sample RAP - note that we do not store the closest previous RAP, only the first of the previous RAP group\n\t\t\tas RAPs are usually isolated this should not be an issue*/\n\t\t\tif (first_rap_in_entry <= SampleNumber) {\n\t\t\t\t*prevRAP = first_rap_in_entry;\n\t\t\t}\n\t\t\t*nextRAP = last_rap_in_entry;\n\t\t\t\n\t\t\t/*sample lies in this (rap) group, it is rap*/\n\t\t\tif (is_rap_group) {\n\t\t\t\tif ((first_rap_in_entry <= SampleNumber) && (SampleNumber <= last_rap_in_entry)) {\n\t\t\t\t\t(*IsRAP) = RAP;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*prevRAP or nextRAP matches SampleNumber, sample is RAP*/\n\t\t\t\tif ((*prevRAP == SampleNumber) || (*nextRAP == SampleNumber)) {\n\t\t\t\t\t(*IsRAP) = RAP;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*first sample in entry is after our target sample, abort*/\n\t\t\tif (first_rap_in_entry > SampleNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst_sample_in_entry += sg->sample_entries[j].sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//get the number of \"ghost chunk\" (implicit chunks described by an entry)\nvoid GetGhostNum(GF_StscEntry *ent, u32 EntryIndex, u32 count, GF_SampleTableBox *stbl)\n{\n\tGF_StscEntry *nextEnt;\n\tu32 ghostNum = 1;\n\n\tif (!ent) {\n\t\tstbl->SampleToChunk->ghostNumber = 0;\n\t\treturn;\n\t}\n\n\tif (!ent->nextChunk) {\n\t\tif (EntryIndex+1 == count) {\n\t\t\t//not specified in the spec, what if the last sample to chunk is no written?\n\t\t\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\t\tghostNum = (stco->nb_entries > ent->firstChunk) ? (1 + stco->nb_entries - ent->firstChunk) : 1;\n\t\t\t} else {\n\t\t\t\tGF_ChunkLargeOffsetBox *co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\t\tghostNum = (co64->nb_entries > ent->firstChunk) ? (1 + co64->nb_entries - ent->firstChunk) : 1;\n\t\t\t}\n\t\t} else {\n\t\t\t//this is an unknown case due to edit mode...\n\t\t\tnextEnt = &stbl->SampleToChunk->entries[EntryIndex+1];\n\t\t\tghostNum = nextEnt->firstChunk - ent->firstChunk;\n\t\t}\n\t} else {\n\t\tghostNum = (ent->nextChunk > ent->firstChunk) ? (ent->nextChunk - ent->firstChunk) : 1;\n\t}\n\tstbl->SampleToChunk->ghostNumber = ghostNum;\n}\n\n//Get the offset, descIndex and chunkNumber of a sample...\nGF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n{\n\tGF_Err e;\n\tu32 i, k, offsetInChunk, size, chunk_num;\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\n\t(*offset) = 0;\n\t(*chunkNumber) = (*descIndex) = 0;\n\tif (out_ent) (*out_ent) = NULL;\n\tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n\tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n\n\tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n\t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\t(*descIndex) = ent->sampleDescriptionIndex;\n\t\t(*chunkNumber) = sampleNumber;\n\t\tif (out_ent) *out_ent = ent;\n\t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n\t\t\tif (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n\t\t} else {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n\t\t\tif (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//check our cache: if desired sample is at or above current cache entry, start from here\n\tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n\t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n\n\t\ti = stbl->SampleToChunk->currentIndex;\n\t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n\t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\t//otherwise start from first entry\n\telse {\n\t\ti = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n\t\tent = &stbl->SampleToChunk->entries[0];\n\t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\n\t//first get the chunk\n\tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n\t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n\t\t//corrupted file (less sample2chunk info than sample count\n\t\tif (k > stbl->SampleToChunk->ghostNumber) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\n\t\t//check if sample is in current chunk\n\t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n\t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\tif (ent->samplesPerChunk) \n\t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n\n\t\tif (\n\t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n\t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n\t\t) {\n\n\t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n\t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n\t\t\tgoto sample_found;\n\t\t}\n\t\tmax_chunks_in_entry += 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n\t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n\n\t\t//not in this entry, get the next entry if not the last one\n\t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n\t\t\tent = &stbl->SampleToChunk->entries[i+1];\n\t\t\t//update the GhostNumber\n\t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n\t\t\t//update the entry in our cache\n\t\t\tstbl->SampleToChunk->currentIndex = i+1;\n\t\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\t\tk = 1;\n\t\t}\n\t}\n\t//if we get here, gasp, the sample was not found\n\treturn GF_ISOM_INVALID_FILE;\n\nsample_found:\n\n\t(*descIndex) = ent->sampleDescriptionIndex;\n\t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n\tif (out_ent) *out_ent = ent;\n\tif (! *chunkNumber)\n\t\treturn GF_ISOM_INVALID_FILE;\n\t\n\t//ok, get the size of all the previous samples in the chunk\n\toffsetInChunk = 0;\n\t//constant size\n\tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n\t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n\t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n\t\tif (e) return e;\n\t\tstbl->r_last_offset_in_chunk += size;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else {\n\t\t//warning, firstSampleInChunk is at least 1 - not 0\n\t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n\t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n\t\t\tif (e) return e;\n\t\t\toffsetInChunk += size;\n\t\t}\n\t\tstbl->r_last_chunk_num = chunk_num;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n\t}\n\t//OK, that's the size of our offset in the chunk\n\t//now get the chunk\n\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t} else {\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stbl_GetSampleShadow(GF_ShadowSyncBox *stsh, u32 *sampleNumber, u32 *syncNum)\n{\n\tu32 i, count;\n\tGF_StshEntry *ent;\n\n\tif (stsh->r_LastFoundSample && (stsh->r_LastFoundSample <= *sampleNumber)) {\n\t\ti = stsh->r_LastEntryIndex;\n\t} else {\n\t\ti = 0;\n\t\tstsh->r_LastFoundSample = 1;\n\t}\n\n\tent = NULL;\n\t(*syncNum) = 0;\n\n\tcount = gf_list_count(stsh->entries);\n\tfor (; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\t//we get the exact desired sample !\n\t\tif (ent->shadowedSampleNumber == *sampleNumber) {\n\t\t\t(*syncNum) = ent->syncSampleNumber;\n\t\t\tstsh->r_LastFoundSample = *sampleNumber;\n\t\t\tstsh->r_LastEntryIndex = i;\n\t\t\treturn GF_OK;\n\t\t} else if (ent->shadowedSampleNumber > *sampleNumber) {\n\t\t\t//do we have an entry before ? If not, there is no shadowing available\n\t\t\t//for this sample\n\t\t\tif (!i) return GF_OK;\n\t\t\t//ok, indicate the previous ShadowedSample\n\t\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i-1);\n\t\t\t(*syncNum) = ent->syncSampleNumber;\n\t\t\t//change the sample number\n\t\t\t(*sampleNumber) = ent->shadowedSampleNumber;\n\t\t\t//reset the cache to the last ShadowedSample\n\t\t\tstsh->r_LastEntryIndex = i-1;\n\t\t\tstsh->r_LastFoundSample = ent->shadowedSampleNumber;\n\t\t}\n\t}\n\tstsh->r_LastEntryIndex = i-1;\n\tstsh->r_LastFoundSample = ent ? ent->shadowedSampleNumber : 0;\n\treturn GF_OK;\n}\n\n\n\nGF_Err stbl_GetPaddingBits(GF_PaddingBitsBox *padb, u32 SampleNumber, u8 *PadBits)\n{\n\tif (!PadBits) return GF_BAD_PARAM;\n\t*PadBits = 0;\n\tif (!padb || !padb->padbits) return GF_OK;\n\t//the spec says \"should\" not shall. return 0 padding\n\tif (padb->SampleCount < SampleNumber) return GF_OK;\n\t*PadBits = padb->padbits[SampleNumber-1];\n\treturn GF_OK;\n}\n\n//Set the RAP flag of a sample\nGF_Err stbl_GetSampleDepType(GF_SampleDependencyTypeBox *sdep, u32 SampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tu8 flag;\n\n\tassert(dependsOn && dependedOn && redundant);\n\t*dependsOn = *dependedOn = *redundant = 0;\n\n\tif (SampleNumber > sdep->sampleCount) {\n\t\treturn GF_OK;\n\t}\n\tflag = sdep->sample_info[SampleNumber-1];\n\t*isLeading = (flag >> 6) & 3;\n\t*dependsOn = (flag >> 4) & 3;\n\t*dependedOn = (flag >> 2) & 3;\n\t*redundant = (flag) & 3;\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/stbl_read.c"], "buggy_code_start_loc": [421], "buggy_code_end_loc": [426], "fixing_code_start_loc": [422], "fixing_code_end_loc": [429], "type": "CWE-401", "message": "Memory leak in the stbl_GetSampleInfos function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.", "other": {"cve": {"id": "CVE-2021-31256", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.203", "lastModified": "2022-05-03T16:04:40.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory leak in the stbl_GetSampleInfos function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n stbl_GetSampleInfos en MP4Box en GPAC versi\u00f3n 1.0.1, permite a atacantes leer la memoria por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/2da2f68bffd51d89b1d272d22aa8cc023c1c066e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1705", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/2da2f68bffd51d89b1d272d22aa8cc023c1c066e"}}