{"buggy_code": ["/* exif-data.c\n *\n * Copyright (c) 2001 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n\n#include <libexif/exif-mnote-data.h>\n#include <libexif/exif-data.h>\n#include <libexif/exif-ifd.h>\n#include <libexif/exif-mnote-data-priv.h>\n#include <libexif/exif-utils.h>\n#include <libexif/exif-loader.h>\n#include <libexif/exif-log.h>\n#include <libexif/i18n.h>\n#include <libexif/exif-system.h>\n\n#include <libexif/canon/exif-mnote-data-canon.h>\n#include <libexif/fuji/exif-mnote-data-fuji.h>\n#include <libexif/olympus/exif-mnote-data-olympus.h>\n#include <libexif/pentax/exif-mnote-data-pentax.h>\n\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#undef JPEG_MARKER_SOI\n#define JPEG_MARKER_SOI  0xd8\n#undef JPEG_MARKER_APP0\n#define JPEG_MARKER_APP0 0xe0\n#undef JPEG_MARKER_APP1\n#define JPEG_MARKER_APP1 0xe1\n\nstatic const unsigned char ExifHeader[] = {0x45, 0x78, 0x69, 0x66, 0x00, 0x00};\n\nstruct _ExifDataPrivate\n{\n\tExifByteOrder order;\n\n\tExifMnoteData *md;\n\n\tExifLog *log;\n\tExifMem *mem;\n\n\tunsigned int ref_count;\n\n\t/* Temporarily used while loading data */\n\tunsigned int offset_mnote;\n\n\tExifDataOption options;\n\tExifDataType data_type;\n};\n\nstatic void *\nexif_data_alloc (ExifData *data, unsigned int i)\n{\n\tvoid *d;\n\n\tif (!data || !i) \n\t\treturn NULL;\n\n\td = exif_mem_alloc (data->priv->mem, i);\n\tif (d) \n\t\treturn d;\n\n\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", i);\n\treturn NULL;\n}\n\nExifMnoteData *\nexif_data_get_mnote_data (ExifData *d)\n{\n\treturn (d && d->priv) ? d->priv->md : NULL;\n}\n\nExifData *\nexif_data_new (void)\n{\n\tExifMem *mem = exif_mem_new_default ();\n\tExifData *d = exif_data_new_mem (mem);\n\n\texif_mem_unref (mem);\n\n\treturn d;\n}\n\nExifData *\nexif_data_new_mem (ExifMem *mem)\n{\n\tExifData *data;\n\tunsigned int i;\n\n\tif (!mem) \n\t\treturn NULL;\n\n\tdata = exif_mem_alloc (mem, sizeof (ExifData));\n\tif (!data) \n\t\treturn (NULL);\n\tdata->priv = exif_mem_alloc (mem, sizeof (ExifDataPrivate));\n\tif (!data->priv) { \n\t  \texif_mem_free (mem, data); \n\t\treturn (NULL); \n\t}\n\tdata->priv->ref_count = 1;\n\n\tdata->priv->mem = mem;\n\texif_mem_ref (mem);\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++) {\n\t\tdata->ifd[i] = exif_content_new_mem (data->priv->mem);\n\t\tif (!data->ifd[i]) {\n\t\t\texif_data_free (data);\n\t\t\treturn (NULL);\n\t\t}\n\t\tdata->ifd[i]->parent = data;\n\t}\n\n\t/* Default options */\n#ifndef NO_VERBOSE_TAG_STRINGS\n\t/*\n\t * When the tag list is compiled away, setting this option prevents\n\t * any tags from being loaded\n\t */\n\texif_data_set_option (data, EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS);\n#endif\n\texif_data_set_option (data, EXIF_DATA_OPTION_FOLLOW_SPECIFICATION);\n\n\t/* Default data type: none */\n\texif_data_set_data_type (data, EXIF_DATA_TYPE_COUNT);\n\n\treturn (data);\n}\n\nExifData *\nexif_data_new_from_data (const unsigned char *data, unsigned int size)\n{\n\tExifData *edata;\n\n\tedata = exif_data_new ();\n\texif_data_load_data (edata, data, size);\n\treturn (edata);\n}\n\nstatic int\nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}\n\nstatic void\nexif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/*\n\t * Each entry is 12 bytes long. The memory for the entry has\n\t * already been allocated.\n\t */\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\t/* If this is the maker note tag, update it. */\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\t/* TODO: this is using the wrong ExifMem to free e->data */\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\t/* e->format is taken from input code,\n\t\t\t\t * but we need to make sure it is a 1 byte\n\t\t\t\t * entity due to the multiplication below. */\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not in\n\t * the entry but somewhere else.\n\t */\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\n\t\t/*\n\t\t * According to the TIFF specification,\n\t\t * the offset must be an even number. If we need to introduce\n\t\t * a padding byte, we set it to 0.\n\t\t */\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\n\t} else\n\t\tdoff = offset + 8;\n\n\t/* Write the data. Fill unneeded bytes with 0. Do not crash with\n\t * e->data is NULL */\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}\n\nstatic void\nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}\n\n#undef CHECK_REC\n#define CHECK_REC(i) \t\t\t\t\t\\\nif ((i) == ifd) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \\\n\t\t\"ExifData\", \"Recursive entry in IFD \"\t\\\n\t\t\"'%s' detected. Skipping...\",\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\nif (data->ifd[(i)]->count) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\t\\\n\t\t\"ExifData\", \"Attempt to load IFD \"\t\\\n\t\t\"'%s' multiple times detected. \"\t\\\n\t\t\"Skipping...\",\t\t\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\n\n/*! Calculate the recursion cost added by one level of IFD loading.\n *\n * The work performed is related to the cost in the exponential relation\n *   work=1.1**cost\n */\nstatic unsigned int\nlevel_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\n\t/* Adding 0.1 protects against the case where n==1 */\n\treturn ceil(log(n + 0.1)/log_1_1);\n}\n\n/*! Load data for an IFD.\n *\n * \\param[in,out] data #ExifData\n * \\param[in] ifd IFD to load\n * \\param[in] d pointer to buffer containing raw IFD data\n * \\param[in] ds size of raw data in buffer at \\c d\n * \\param[in] offset offset into buffer at \\c d at which IFD starts\n * \\param[in] recursion_cost factor indicating how expensive this recursive\n * call could be\n */\nstatic void\nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t          \"Loading %hu entries...\", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Short data; only loading %hu entries...\", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \"\\0\\0\\0\\0\", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t\t  \"Skipping empty entry at position %u in '%s'.\", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \"\n\t\t\t\t\t  \"to <libexif-devel@lists.sourceforge.net>.\", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \"ExifData\",\n                                          \"Could not allocate memory\");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\ncmp_func (const unsigned char *p1, const unsigned char *p2, ExifByteOrder o)\n{\n\tExifShort tag1 = exif_get_short (p1, o);\n\tExifShort tag2 = exif_get_short (p2, o);\n\n\treturn (tag1 < tag2) ? -1 : (tag1 > tag2) ? 1 : 0;\n}\n\nstatic int\ncmp_func_intel (const void *elem1, const void *elem2)\n{\n\treturn cmp_func ((const unsigned char *) elem1,\n\t\t\t (const unsigned char *) elem2, EXIF_BYTE_ORDER_INTEL);\n}\n\nstatic int\ncmp_func_motorola (const void *elem1, const void *elem2)\n{\n\treturn cmp_func ((const unsigned char *) elem1,\n\t\t\t (const unsigned char *) elem2, EXIF_BYTE_ORDER_MOTOROLA);\n}\n\nstatic void\nexif_data_save_data_content (ExifData *data, ExifContent *ifd,\n\t\t\t     unsigned char **d, unsigned int *ds,\n\t\t\t     unsigned int offset)\n{\n\tunsigned int j, n_ptr = 0, n_thumb = 0;\n\tExifIfd i;\n\tunsigned char *t;\n\tunsigned int ts;\n\n\tif (!data || !data->priv || !ifd || !d || !ds) \n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\tif (ifd == data->ifd[i])\n\t\t\tbreak;\n\tif (i == EXIF_IFD_COUNT)\n\t\treturn;\t/* error */\n\n\t/*\n\t * Check if we need some extra entries for pointers or the thumbnail.\n\t */\n\tswitch (i) {\n\tcase EXIF_IFD_0:\n\n\t\t/*\n\t\t * The pointer to IFD_EXIF is in IFD_0. The pointer to\n\t\t * IFD_INTEROPERABILITY is in IFD_EXIF.\n\t\t */\n\t\tif (data->ifd[EXIF_IFD_EXIF]->count ||\n\t\t    data->ifd[EXIF_IFD_INTEROPERABILITY]->count)\n\t\t\tn_ptr++;\n\n\t\t/* The pointer to IFD_GPS is in IFD_0. */\n\t\tif (data->ifd[EXIF_IFD_GPS]->count)\n\t\t\tn_ptr++;\n\n\t\tbreak;\n\tcase EXIF_IFD_1:\n\t\tif (data->size)\n\t\t\tn_thumb = 2;\n\t\tbreak;\n\tcase EXIF_IFD_EXIF:\n\t\tif (data->ifd[EXIF_IFD_INTEROPERABILITY]->count)\n\t\t\tn_ptr++;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Allocate enough memory for all entries\n\t * and the number of entries.\n\t */\n\tts = *ds + (2 + (ifd->count + n_ptr + n_thumb) * 12 + 4);\n\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\tif (!t) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t  \treturn;\n\t}\n\t*d = t;\n\t*ds = ts;\n\n\t/* Save the number of entries */\n\texif_set_short (*d + 6 + offset, data->priv->order,\n\t\t\t(ExifShort) (ifd->count + n_ptr + n_thumb));\n\toffset += 2;\n\n\t/*\n\t * Save each entry. Make sure that no memcpys from NULL pointers are\n\t * performed\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Saving %i entries (IFD '%s', offset: %i)...\",\n\t\t  ifd->count, exif_ifd_get_name (i), offset);\n\tfor (j = 0; j < ifd->count; j++) {\n\t\tif (ifd->entries[j]) {\n\t\t\texif_data_save_data_entry (data, ifd->entries[j], d, ds,\n\t\t\t\toffset + 12 * j);\n\t\t}\n\t}\n\n\toffset += 12 * ifd->count;\n\n\t/* Now save special entries. */\n\tswitch (i) {\n\tcase EXIF_IFD_0:\n\n\t\t/*\n\t\t * The pointer to IFD_EXIF is in IFD_0.\n\t\t * However, the pointer to IFD_INTEROPERABILITY is in IFD_EXIF,\n\t\t * therefore, if IFD_INTEROPERABILITY is not empty, we need\n\t\t * IFD_EXIF even if latter is empty.\n\t\t */\n\t\tif (data->ifd[EXIF_IFD_EXIF]->count ||\n\t\t    data->ifd[EXIF_IFD_INTEROPERABILITY]->count) {\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_EXIF_IFD_POINTER);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\texif_data_save_data_content (data,\n\t\t\t\t\t\t     data->ifd[EXIF_IFD_EXIF], d, ds, *ds - 6);\n\t\t\toffset += 12;\n\t\t}\n\n\t\t/* The pointer to IFD_GPS is in IFD_0, too. */\n\t\tif (data->ifd[EXIF_IFD_GPS]->count) {\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_GPS_INFO_IFD_POINTER);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\texif_data_save_data_content (data,\n\t\t\t\t\t\t     data->ifd[EXIF_IFD_GPS], d, ds, *ds - 6);\n\t\t\toffset += 12;\n\t\t}\n\n\t\tbreak;\n\tcase EXIF_IFD_EXIF:\n\n\t\t/*\n\t\t * The pointer to IFD_INTEROPERABILITY is in IFD_EXIF.\n\t\t * See note above.\n\t\t */\n\t\tif (data->ifd[EXIF_IFD_INTEROPERABILITY]->count) {\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_INTEROPERABILITY_IFD_POINTER);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\texif_data_save_data_content (data,\n\t\t\t\t\t\t     data->ifd[EXIF_IFD_INTEROPERABILITY], d, ds,\n\t\t\t\t\t\t     *ds - 6);\n\t\t\toffset += 12;\n\t\t}\n\n\t\tbreak;\n\tcase EXIF_IFD_1:\n\n\t\t/*\n\t\t * Information about the thumbnail (if any) is saved in\n\t\t * IFD_1.\n\t\t */\n\t\tif (data->size) {\n\n\t\t\t/* EXIF_TAG_JPEG_INTERCHANGE_FORMAT */\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_JPEG_INTERCHANGE_FORMAT);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\tts = *ds + data->size;\n\t\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\",\n\t\t\t\t\t\t    ts);\n\t\t\t  \treturn;\n\t\t\t}\n\t\t\t*d = t;\n\t\t\t*ds = ts;\n\t\t\tmemcpy (*d + *ds - data->size, data->data, data->size);\n\t\t\toffset += 12;\n\n\t\t\t/* EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH */\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\tdata->size);\n\t\t\toffset += 12;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Sort the directory according to TIFF specification */\n\tqsort (*d + 6 + offset - (ifd->count + n_ptr + n_thumb) * 12,\n\t       (ifd->count + n_ptr + n_thumb), 12,\n\t       (data->priv->order == EXIF_BYTE_ORDER_INTEL) ? cmp_func_intel : cmp_func_motorola);\n\n\t/* Correctly terminate the directory */\n\tif (i == EXIF_IFD_0 && (data->ifd[EXIF_IFD_1]->count ||\n\t\t\t\tdata->size)) {\n\n\t\t/*\n\t\t * We are saving IFD 0. Tell where IFD 1 starts and save\n\t\t * IFD 1.\n\t\t */\n\t\texif_set_long (*d + 6 + offset, data->priv->order, *ds - 6);\n\t\texif_data_save_data_content (data, data->ifd[EXIF_IFD_1], d, ds,\n\t\t\t\t\t     *ds - 6);\n\t} else\n\t\texif_set_long (*d + 6 + offset, data->priv->order, 0);\n}\n\ntypedef enum {\n\tEXIF_DATA_TYPE_MAKER_NOTE_NONE\t\t= 0,\n\tEXIF_DATA_TYPE_MAKER_NOTE_CANON\t\t= 1,\n\tEXIF_DATA_TYPE_MAKER_NOTE_OLYMPUS\t= 2,\n\tEXIF_DATA_TYPE_MAKER_NOTE_PENTAX\t= 3,\n\tEXIF_DATA_TYPE_MAKER_NOTE_NIKON\t\t= 4,\n\tEXIF_DATA_TYPE_MAKER_NOTE_CASIO\t\t= 5,\n\tEXIF_DATA_TYPE_MAKER_NOTE_FUJI \t\t= 6\n} ExifDataTypeMakerNote;\n\n/*! If MakerNote is recognized, load it.\n *\n * \\param[in,out] data #ExifData\n * \\param[in] d pointer to raw EXIF data\n * \\param[in] ds length of data at d\n */\nstatic void\ninterpret_maker_note(ExifData *data, const unsigned char *d, unsigned int ds)\n{\n\tint mnoteid;\n\tExifEntry* e = exif_data_get_entry (data, EXIF_TAG_MAKER_NOTE);\n\tif (!e)\n\t\treturn;\n\t\n\tif ((mnoteid = exif_mnote_data_olympus_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Olympus MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_olympus_new (data->priv->mem);\n\n\t} else if ((mnoteid = exif_mnote_data_canon_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Canon MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_canon_new (data->priv->mem, data->priv->options);\n\n\t} else if ((mnoteid = exif_mnote_data_fuji_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Fuji MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_fuji_new (data->priv->mem);\n\n\t/* NOTE: Must do Pentax detection last because some of the\n\t * heuristics are pretty general. */\n\t} else if ((mnoteid = exif_mnote_data_pentax_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Pentax MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_pentax_new (data->priv->mem);\n\t}\n\n\t/* \n\t * If we are able to interpret the maker note, do so.\n\t */\n\tif (data->priv->md) {\n\t\texif_mnote_data_log (data->priv->md, data->priv->log);\n\t\texif_mnote_data_set_byte_order (data->priv->md,\n\t\t\t\t\t\tdata->priv->order);\n\t\texif_mnote_data_set_offset (data->priv->md,\n\t\t\t\t\t    data->priv->offset_mnote);\n\t\texif_mnote_data_load (data->priv->md, d, ds);\n\t}\n}\n\n#define LOG_TOO_SMALL \\\nexif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\", \\\n\t\t_(\"Size of data too small to allow for EXIF data.\"));\n\nvoid\nexif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Parsing %i byte(s) EXIF data...\\n\", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Found EXIF header at start.\");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", _(\"EXIF marker not found.\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"We have to deal with %i byte(s) of EXIF data.\",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"EXIF header not found.\"));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Found EXIF header.\");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \"II\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \"MM\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"Unknown encoding.\"));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \n\t\t  \"IFD 0 at %i.\", (int) offset);\n\n\t/* Sanity check the offset, being careful about overflow */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"IFD 1 at %i.\", (int) offset);\n\n\t\t/* Sanity check. */\n\t\tif (offset > ds || offset + 6 > ds) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", \"Bogus offset of IFD1.\");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}\n\nvoid\nexif_data_save_data (ExifData *data, unsigned char **d, unsigned int *ds)\n{\n\tif (ds)\n\t\t*ds = 0;\t/* This means something went wrong */\n\n\tif (!data || !d || !ds)\n\t\treturn;\n\n\t/* Header */\n\t*ds = 14;\n\t*d = exif_data_alloc (data, *ds);\n\tif (!*d)  {\n\t\t*ds = 0;\n\t\treturn;\n\t}\n\tmemcpy (*d, ExifHeader, 6);\n\n\t/* Order (offset 6) */\n\tif (data->priv->order == EXIF_BYTE_ORDER_INTEL) {\n\t\tmemcpy (*d + 6, \"II\", 2);\n\t} else {\n\t\tmemcpy (*d + 6, \"MM\", 2);\n\t}\n\n\t/* Fixed value (2 bytes, offset 8) */\n\texif_set_short (*d + 8, data->priv->order, 0x002a);\n\n\t/*\n\t * IFD 0 offset (4 bytes, offset 10).\n\t * We will start 8 bytes after the\n\t * EXIF header (2 bytes for order, another 2 for the test, and\n\t * 4 bytes for the IFD 0 offset make 8 bytes together).\n\t */\n\texif_set_long (*d + 10, data->priv->order, 8);\n\n\t/* Now save IFD 0. IFD 1 will be saved automatically. */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Saving IFDs...\");\n\texif_data_save_data_content (data, data->ifd[EXIF_IFD_0], d, ds,\n\t\t\t\t     *ds - 6);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Saved %i byte(s) EXIF data.\", *ds);\n}\n\nExifData *\nexif_data_new_from_file (const char *path)\n{\n\tExifData *edata;\n\tExifLoader *loader;\n\n\tloader = exif_loader_new ();\n\texif_loader_write_file (loader, path);\n\tedata = exif_loader_get_data (loader);\n\texif_loader_unref (loader);\n\n\treturn (edata);\n}\n\nvoid\nexif_data_ref (ExifData *data)\n{\n\tif (!data)\n\t\treturn;\n\n\tdata->priv->ref_count++;\n}\n\nvoid\nexif_data_unref (ExifData *data)\n{\n\tif (!data) \n\t\treturn;\n\n\tdata->priv->ref_count--;\n\tif (!data->priv->ref_count) \n\t\texif_data_free (data);\n}\n\nvoid\nexif_data_free (ExifData *data)\n{\n\tunsigned int i;\n\tExifMem *mem = (data && data->priv) ? data->priv->mem : NULL;\n\n\tif (!data) \n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++) {\n\t\tif (data->ifd[i]) {\n\t\t\texif_content_unref (data->ifd[i]);\n\t\t\tdata->ifd[i] = NULL;\n\t\t}\n\t}\n\n\tif (data->data) {\n\t\texif_mem_free (mem, data->data);\n\t\tdata->data = NULL;\n\t}\n\n\tif (data->priv) {\n\t\tif (data->priv->log) {\n\t\t\texif_log_unref (data->priv->log);\n\t\t\tdata->priv->log = NULL;\n\t\t}\n\t\tif (data->priv->md) {\n\t\t\texif_mnote_data_unref (data->priv->md);\n\t\t\tdata->priv->md = NULL;\n\t\t}\n\t\texif_mem_free (mem, data->priv);\n\t\texif_mem_free (mem, data);\n\t}\n\n\texif_mem_unref (mem);\n}\n\nvoid\nexif_data_dump (ExifData *data)\n{\n\tunsigned int i;\n\n\tif (!data)\n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++) {\n\t\tif (data->ifd[i] && data->ifd[i]->count) {\n\t\t\tprintf (\"Dumping IFD '%s'...\\n\",\n\t\t\t\texif_ifd_get_name (i));\n\t\t\texif_content_dump (data->ifd[i], 0);\n\t\t}\n\t}\n\n\tif (data->data) {\n\t\tprintf (\"%i byte(s) thumbnail data available: \", data->size);\n\t\tif (data->size >= 4) {\n\t\t\tprintf (\"0x%02x 0x%02x ... 0x%02x 0x%02x\\n\",\n\t\t\t\tdata->data[0], data->data[1],\n\t\t\t\tdata->data[data->size - 2],\n\t\t\t\tdata->data[data->size - 1]);\n\t\t}\n\t}\n}\n\nExifByteOrder\nexif_data_get_byte_order (ExifData *data)\n{\n\tif (!data)\n\t\treturn (0);\n\n\treturn (data->priv->order);\n}\n\nvoid\nexif_data_foreach_content (ExifData *data, ExifDataForeachContentFunc func,\n\t\t\t   void *user_data)\n{\n\tunsigned int i;\n\n\tif (!data || !func)\n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\tfunc (data->ifd[i], user_data);\n}\n\ntypedef struct _ByteOrderChangeData ByteOrderChangeData;\nstruct _ByteOrderChangeData {\n\tExifByteOrder old, new;\n};\n\nstatic void\nentry_set_byte_order (ExifEntry *e, void *data)\n{\n\tByteOrderChangeData *d = data;\n\n\tif (!e)\n\t\treturn;\n\n\texif_array_set_byte_order (e->format, e->data, e->components, d->old, d->new);\n}\n\nstatic void\ncontent_set_byte_order (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, entry_set_byte_order, data);\n}\n\nvoid\nexif_data_set_byte_order (ExifData *data, ExifByteOrder order)\n{\n\tByteOrderChangeData d;\n\n\tif (!data || (order == data->priv->order))\n\t\treturn;\n\n\td.old = data->priv->order;\n\td.new = order;\n\texif_data_foreach_content (data, content_set_byte_order, &d);\n\tdata->priv->order = order;\n\tif (data->priv->md)\n\t\texif_mnote_data_set_byte_order (data->priv->md, order);\n}\n\nvoid\nexif_data_log (ExifData *data, ExifLog *log)\n{\n\tunsigned int i;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_log_unref (data->priv->log);\n\tdata->priv->log = log;\n\texif_log_ref (log);\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\texif_content_log (data->ifd[i], log);\n}\n\n/* Used internally within libexif */\nExifLog *exif_data_get_log (ExifData *);\nExifLog *\nexif_data_get_log (ExifData *data)\n{\n\tif (!data || !data->priv) \n\t\treturn NULL;\n\treturn data->priv->log;\n}\n\nstatic const struct {\n\tExifDataOption option;\n\tconst char *name;\n\tconst char *description;\n} exif_data_option[] = {\n\t{EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS, N_(\"Ignore unknown tags\"),\n\t N_(\"Ignore unknown tags when loading EXIF data.\")},\n\t{EXIF_DATA_OPTION_FOLLOW_SPECIFICATION, N_(\"Follow specification\"),\n\t N_(\"Add, correct and remove entries to get EXIF data that follows \"\n\t    \"the specification.\")},\n\t{EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE, N_(\"Do not change maker note\"),\n\t N_(\"When loading and resaving Exif data, save the maker note unmodified.\"\n\t    \" Be aware that the maker note can get corrupted.\")},\n\t{0, NULL, NULL}\n};\n\nconst char *\nexif_data_option_get_name (ExifDataOption o)\n{\n\tunsigned int i;\n\n\tfor (i = 0; exif_data_option[i].name; i++)\n\t\tif (exif_data_option[i].option == o) \n\t\t\tbreak;\n\treturn _(exif_data_option[i].name);\n}\n\nconst char *\nexif_data_option_get_description (ExifDataOption o)\n{\n\tunsigned int i;\n\n\tfor (i = 0; exif_data_option[i].description; i++)\n\t\tif (exif_data_option[i].option == o) \n\t\t\tbreak;\n\treturn _(exif_data_option[i].description);\n}\n\nvoid\nexif_data_set_option (ExifData *d, ExifDataOption o)\n{\n\tif (!d) \n\t\treturn;\n\n\td->priv->options |= o;\n}\n\nvoid\nexif_data_unset_option (ExifData *d, ExifDataOption o)\n{\n\tif (!d) \n\t\treturn;\n\n\td->priv->options &= ~o;\n}\n\nstatic void\nfix_func (ExifContent *c, void *UNUSED(data))\n{\n\tswitch (exif_content_get_ifd (c)) {\n\tcase EXIF_IFD_1:\n\t\tif (c->parent->data)\n\t\t\texif_content_fix (c);\n\t\telse if (c->count) {\n\t\t\texif_log (c->parent->priv->log, EXIF_LOG_CODE_DEBUG, \"exif-data\",\n\t\t\t\t  \"No thumbnail but entries on thumbnail. These entries have been \"\n\t\t\t\t  \"removed.\");\n\t\t\twhile (c->count) {\n\t\t\t\tunsigned int cnt = c->count;\n\t\t\t\texif_content_remove_entry (c, c->entries[c->count - 1]);\n\t\t\t\tif (cnt == c->count) {\n\t\t\t\t\t/* safety net */\n\t\t\t\t\texif_log (c->parent->priv->log, EXIF_LOG_CODE_DEBUG, \"exif-data\",\n\t\t\t\t\t\"failed to remove last entry from entries.\");\n\t\t\t\t\tc->count--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\texif_content_fix (c);\n\t}\n}\n\nvoid\nexif_data_fix (ExifData *d)\n{\n\texif_data_foreach_content (d, fix_func, NULL);\n}\n\nvoid\nexif_data_set_data_type (ExifData *d, ExifDataType dt)\n{\n\tif (!d || !d->priv) \n\t\treturn;\n\n\td->priv->data_type = dt;\n}\n\nExifDataType\nexif_data_get_data_type (ExifData *d)\n{\n\treturn (d && d->priv) ? d->priv->data_type : EXIF_DATA_TYPE_UNKNOWN;\n}\n"], "fixing_code": ["/* exif-data.c\n *\n * Copyright (c) 2001 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n\n#include <libexif/exif-mnote-data.h>\n#include <libexif/exif-data.h>\n#include <libexif/exif-ifd.h>\n#include <libexif/exif-mnote-data-priv.h>\n#include <libexif/exif-utils.h>\n#include <libexif/exif-loader.h>\n#include <libexif/exif-log.h>\n#include <libexif/i18n.h>\n#include <libexif/exif-system.h>\n\n#include <libexif/canon/exif-mnote-data-canon.h>\n#include <libexif/fuji/exif-mnote-data-fuji.h>\n#include <libexif/olympus/exif-mnote-data-olympus.h>\n#include <libexif/pentax/exif-mnote-data-pentax.h>\n\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#undef JPEG_MARKER_SOI\n#define JPEG_MARKER_SOI  0xd8\n#undef JPEG_MARKER_APP0\n#define JPEG_MARKER_APP0 0xe0\n#undef JPEG_MARKER_APP1\n#define JPEG_MARKER_APP1 0xe1\n\nstatic const unsigned char ExifHeader[] = {0x45, 0x78, 0x69, 0x66, 0x00, 0x00};\n\nstruct _ExifDataPrivate\n{\n\tExifByteOrder order;\n\n\tExifMnoteData *md;\n\n\tExifLog *log;\n\tExifMem *mem;\n\n\tunsigned int ref_count;\n\n\t/* Temporarily used while loading data */\n\tunsigned int offset_mnote;\n\n\tExifDataOption options;\n\tExifDataType data_type;\n};\n\nstatic void *\nexif_data_alloc (ExifData *data, unsigned int i)\n{\n\tvoid *d;\n\n\tif (!data || !i) \n\t\treturn NULL;\n\n\td = exif_mem_alloc (data->priv->mem, i);\n\tif (d) \n\t\treturn d;\n\n\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", i);\n\treturn NULL;\n}\n\nExifMnoteData *\nexif_data_get_mnote_data (ExifData *d)\n{\n\treturn (d && d->priv) ? d->priv->md : NULL;\n}\n\nExifData *\nexif_data_new (void)\n{\n\tExifMem *mem = exif_mem_new_default ();\n\tExifData *d = exif_data_new_mem (mem);\n\n\texif_mem_unref (mem);\n\n\treturn d;\n}\n\nExifData *\nexif_data_new_mem (ExifMem *mem)\n{\n\tExifData *data;\n\tunsigned int i;\n\n\tif (!mem) \n\t\treturn NULL;\n\n\tdata = exif_mem_alloc (mem, sizeof (ExifData));\n\tif (!data) \n\t\treturn (NULL);\n\tdata->priv = exif_mem_alloc (mem, sizeof (ExifDataPrivate));\n\tif (!data->priv) { \n\t  \texif_mem_free (mem, data); \n\t\treturn (NULL); \n\t}\n\tdata->priv->ref_count = 1;\n\n\tdata->priv->mem = mem;\n\texif_mem_ref (mem);\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++) {\n\t\tdata->ifd[i] = exif_content_new_mem (data->priv->mem);\n\t\tif (!data->ifd[i]) {\n\t\t\texif_data_free (data);\n\t\t\treturn (NULL);\n\t\t}\n\t\tdata->ifd[i]->parent = data;\n\t}\n\n\t/* Default options */\n#ifndef NO_VERBOSE_TAG_STRINGS\n\t/*\n\t * When the tag list is compiled away, setting this option prevents\n\t * any tags from being loaded\n\t */\n\texif_data_set_option (data, EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS);\n#endif\n\texif_data_set_option (data, EXIF_DATA_OPTION_FOLLOW_SPECIFICATION);\n\n\t/* Default data type: none */\n\texif_data_set_data_type (data, EXIF_DATA_TYPE_COUNT);\n\n\treturn (data);\n}\n\nExifData *\nexif_data_new_from_data (const unsigned char *data, unsigned int size)\n{\n\tExifData *edata;\n\n\tedata = exif_data_new ();\n\texif_data_load_data (edata, data, size);\n\treturn (edata);\n}\n\nstatic int\nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag starts past end of buffer (%u > %u)\", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}\n\nstatic void\nexif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/*\n\t * Each entry is 12 bytes long. The memory for the entry has\n\t * already been allocated.\n\t */\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\t/* If this is the maker note tag, update it. */\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\t/* TODO: this is using the wrong ExifMem to free e->data */\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\t/* e->format is taken from input code,\n\t\t\t\t * but we need to make sure it is a 1 byte\n\t\t\t\t * entity due to the multiplication below. */\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not in\n\t * the entry but somewhere else.\n\t */\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\n\t\t/*\n\t\t * According to the TIFF specification,\n\t\t * the offset must be an even number. If we need to introduce\n\t\t * a padding byte, we set it to 0.\n\t\t */\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\n\t} else\n\t\tdoff = offset + 8;\n\n\t/* Write the data. Fill unneeded bytes with 0. Do not crash with\n\t * e->data is NULL */\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}\n\nstatic void\nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}\n\n#undef CHECK_REC\n#define CHECK_REC(i) \t\t\t\t\t\\\nif ((i) == ifd) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \\\n\t\t\"ExifData\", \"Recursive entry in IFD \"\t\\\n\t\t\"'%s' detected. Skipping...\",\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\nif (data->ifd[(i)]->count) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\t\\\n\t\t\"ExifData\", \"Attempt to load IFD \"\t\\\n\t\t\"'%s' multiple times detected. \"\t\\\n\t\t\"Skipping...\",\t\t\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\n\n/*! Calculate the recursion cost added by one level of IFD loading.\n *\n * The work performed is related to the cost in the exponential relation\n *   work=1.1**cost\n */\nstatic unsigned int\nlevel_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\n\t/* Adding 0.1 protects against the case where n==1 */\n\treturn ceil(log(n + 0.1)/log_1_1);\n}\n\n/*! Load data for an IFD.\n *\n * \\param[in,out] data #ExifData\n * \\param[in] ifd IFD to load\n * \\param[in] d pointer to buffer containing raw IFD data\n * \\param[in] ds size of raw data in buffer at \\c d\n * \\param[in] offset offset into buffer at \\c d at which IFD starts\n * \\param[in] recursion_cost factor indicating how expensive this recursive\n * call could be\n */\nstatic void\nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t          \"Loading %hu entries...\", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Short data; only loading %hu entries...\", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \"\\0\\0\\0\\0\", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t\t  \"Skipping empty entry at position %u in '%s'.\", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \"\n\t\t\t\t\t  \"to <libexif-devel@lists.sourceforge.net>.\", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \"ExifData\",\n                                          \"Could not allocate memory\");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\ncmp_func (const unsigned char *p1, const unsigned char *p2, ExifByteOrder o)\n{\n\tExifShort tag1 = exif_get_short (p1, o);\n\tExifShort tag2 = exif_get_short (p2, o);\n\n\treturn (tag1 < tag2) ? -1 : (tag1 > tag2) ? 1 : 0;\n}\n\nstatic int\ncmp_func_intel (const void *elem1, const void *elem2)\n{\n\treturn cmp_func ((const unsigned char *) elem1,\n\t\t\t (const unsigned char *) elem2, EXIF_BYTE_ORDER_INTEL);\n}\n\nstatic int\ncmp_func_motorola (const void *elem1, const void *elem2)\n{\n\treturn cmp_func ((const unsigned char *) elem1,\n\t\t\t (const unsigned char *) elem2, EXIF_BYTE_ORDER_MOTOROLA);\n}\n\nstatic void\nexif_data_save_data_content (ExifData *data, ExifContent *ifd,\n\t\t\t     unsigned char **d, unsigned int *ds,\n\t\t\t     unsigned int offset)\n{\n\tunsigned int j, n_ptr = 0, n_thumb = 0;\n\tExifIfd i;\n\tunsigned char *t;\n\tunsigned int ts;\n\n\tif (!data || !data->priv || !ifd || !d || !ds) \n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\tif (ifd == data->ifd[i])\n\t\t\tbreak;\n\tif (i == EXIF_IFD_COUNT)\n\t\treturn;\t/* error */\n\n\t/*\n\t * Check if we need some extra entries for pointers or the thumbnail.\n\t */\n\tswitch (i) {\n\tcase EXIF_IFD_0:\n\n\t\t/*\n\t\t * The pointer to IFD_EXIF is in IFD_0. The pointer to\n\t\t * IFD_INTEROPERABILITY is in IFD_EXIF.\n\t\t */\n\t\tif (data->ifd[EXIF_IFD_EXIF]->count ||\n\t\t    data->ifd[EXIF_IFD_INTEROPERABILITY]->count)\n\t\t\tn_ptr++;\n\n\t\t/* The pointer to IFD_GPS is in IFD_0. */\n\t\tif (data->ifd[EXIF_IFD_GPS]->count)\n\t\t\tn_ptr++;\n\n\t\tbreak;\n\tcase EXIF_IFD_1:\n\t\tif (data->size)\n\t\t\tn_thumb = 2;\n\t\tbreak;\n\tcase EXIF_IFD_EXIF:\n\t\tif (data->ifd[EXIF_IFD_INTEROPERABILITY]->count)\n\t\t\tn_ptr++;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Allocate enough memory for all entries\n\t * and the number of entries.\n\t */\n\tts = *ds + (2 + (ifd->count + n_ptr + n_thumb) * 12 + 4);\n\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\tif (!t) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t  \treturn;\n\t}\n\t*d = t;\n\t*ds = ts;\n\n\t/* Save the number of entries */\n\texif_set_short (*d + 6 + offset, data->priv->order,\n\t\t\t(ExifShort) (ifd->count + n_ptr + n_thumb));\n\toffset += 2;\n\n\t/*\n\t * Save each entry. Make sure that no memcpys from NULL pointers are\n\t * performed\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Saving %i entries (IFD '%s', offset: %i)...\",\n\t\t  ifd->count, exif_ifd_get_name (i), offset);\n\tfor (j = 0; j < ifd->count; j++) {\n\t\tif (ifd->entries[j]) {\n\t\t\texif_data_save_data_entry (data, ifd->entries[j], d, ds,\n\t\t\t\toffset + 12 * j);\n\t\t}\n\t}\n\n\toffset += 12 * ifd->count;\n\n\t/* Now save special entries. */\n\tswitch (i) {\n\tcase EXIF_IFD_0:\n\n\t\t/*\n\t\t * The pointer to IFD_EXIF is in IFD_0.\n\t\t * However, the pointer to IFD_INTEROPERABILITY is in IFD_EXIF,\n\t\t * therefore, if IFD_INTEROPERABILITY is not empty, we need\n\t\t * IFD_EXIF even if latter is empty.\n\t\t */\n\t\tif (data->ifd[EXIF_IFD_EXIF]->count ||\n\t\t    data->ifd[EXIF_IFD_INTEROPERABILITY]->count) {\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_EXIF_IFD_POINTER);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\texif_data_save_data_content (data,\n\t\t\t\t\t\t     data->ifd[EXIF_IFD_EXIF], d, ds, *ds - 6);\n\t\t\toffset += 12;\n\t\t}\n\n\t\t/* The pointer to IFD_GPS is in IFD_0, too. */\n\t\tif (data->ifd[EXIF_IFD_GPS]->count) {\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_GPS_INFO_IFD_POINTER);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\texif_data_save_data_content (data,\n\t\t\t\t\t\t     data->ifd[EXIF_IFD_GPS], d, ds, *ds - 6);\n\t\t\toffset += 12;\n\t\t}\n\n\t\tbreak;\n\tcase EXIF_IFD_EXIF:\n\n\t\t/*\n\t\t * The pointer to IFD_INTEROPERABILITY is in IFD_EXIF.\n\t\t * See note above.\n\t\t */\n\t\tif (data->ifd[EXIF_IFD_INTEROPERABILITY]->count) {\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_INTEROPERABILITY_IFD_POINTER);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\texif_data_save_data_content (data,\n\t\t\t\t\t\t     data->ifd[EXIF_IFD_INTEROPERABILITY], d, ds,\n\t\t\t\t\t\t     *ds - 6);\n\t\t\toffset += 12;\n\t\t}\n\n\t\tbreak;\n\tcase EXIF_IFD_1:\n\n\t\t/*\n\t\t * Information about the thumbnail (if any) is saved in\n\t\t * IFD_1.\n\t\t */\n\t\tif (data->size) {\n\n\t\t\t/* EXIF_TAG_JPEG_INTERCHANGE_FORMAT */\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_JPEG_INTERCHANGE_FORMAT);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\t*ds - 6);\n\t\t\tts = *ds + data->size;\n\t\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\",\n\t\t\t\t\t\t    ts);\n\t\t\t  \treturn;\n\t\t\t}\n\t\t\t*d = t;\n\t\t\t*ds = ts;\n\t\t\tmemcpy (*d + *ds - data->size, data->data, data->size);\n\t\t\toffset += 12;\n\n\t\t\t/* EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH */\n\t\t\texif_set_short (*d + 6 + offset + 0, data->priv->order,\n\t\t\t\t\tEXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);\n\t\t\texif_set_short (*d + 6 + offset + 2, data->priv->order,\n\t\t\t\t\tEXIF_FORMAT_LONG);\n\t\t\texif_set_long  (*d + 6 + offset + 4, data->priv->order,\n\t\t\t\t\t1);\n\t\t\texif_set_long  (*d + 6 + offset + 8, data->priv->order,\n\t\t\t\t\tdata->size);\n\t\t\toffset += 12;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Sort the directory according to TIFF specification */\n\tqsort (*d + 6 + offset - (ifd->count + n_ptr + n_thumb) * 12,\n\t       (ifd->count + n_ptr + n_thumb), 12,\n\t       (data->priv->order == EXIF_BYTE_ORDER_INTEL) ? cmp_func_intel : cmp_func_motorola);\n\n\t/* Correctly terminate the directory */\n\tif (i == EXIF_IFD_0 && (data->ifd[EXIF_IFD_1]->count ||\n\t\t\t\tdata->size)) {\n\n\t\t/*\n\t\t * We are saving IFD 0. Tell where IFD 1 starts and save\n\t\t * IFD 1.\n\t\t */\n\t\texif_set_long (*d + 6 + offset, data->priv->order, *ds - 6);\n\t\texif_data_save_data_content (data, data->ifd[EXIF_IFD_1], d, ds,\n\t\t\t\t\t     *ds - 6);\n\t} else\n\t\texif_set_long (*d + 6 + offset, data->priv->order, 0);\n}\n\ntypedef enum {\n\tEXIF_DATA_TYPE_MAKER_NOTE_NONE\t\t= 0,\n\tEXIF_DATA_TYPE_MAKER_NOTE_CANON\t\t= 1,\n\tEXIF_DATA_TYPE_MAKER_NOTE_OLYMPUS\t= 2,\n\tEXIF_DATA_TYPE_MAKER_NOTE_PENTAX\t= 3,\n\tEXIF_DATA_TYPE_MAKER_NOTE_NIKON\t\t= 4,\n\tEXIF_DATA_TYPE_MAKER_NOTE_CASIO\t\t= 5,\n\tEXIF_DATA_TYPE_MAKER_NOTE_FUJI \t\t= 6\n} ExifDataTypeMakerNote;\n\n/*! If MakerNote is recognized, load it.\n *\n * \\param[in,out] data #ExifData\n * \\param[in] d pointer to raw EXIF data\n * \\param[in] ds length of data at d\n */\nstatic void\ninterpret_maker_note(ExifData *data, const unsigned char *d, unsigned int ds)\n{\n\tint mnoteid;\n\tExifEntry* e = exif_data_get_entry (data, EXIF_TAG_MAKER_NOTE);\n\tif (!e)\n\t\treturn;\n\t\n\tif ((mnoteid = exif_mnote_data_olympus_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Olympus MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_olympus_new (data->priv->mem);\n\n\t} else if ((mnoteid = exif_mnote_data_canon_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Canon MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_canon_new (data->priv->mem, data->priv->options);\n\n\t} else if ((mnoteid = exif_mnote_data_fuji_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Fuji MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_fuji_new (data->priv->mem);\n\n\t/* NOTE: Must do Pentax detection last because some of the\n\t * heuristics are pretty general. */\n\t} else if ((mnoteid = exif_mnote_data_pentax_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Pentax MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_pentax_new (data->priv->mem);\n\t}\n\n\t/* \n\t * If we are able to interpret the maker note, do so.\n\t */\n\tif (data->priv->md) {\n\t\texif_mnote_data_log (data->priv->md, data->priv->log);\n\t\texif_mnote_data_set_byte_order (data->priv->md,\n\t\t\t\t\t\tdata->priv->order);\n\t\texif_mnote_data_set_offset (data->priv->md,\n\t\t\t\t\t    data->priv->offset_mnote);\n\t\texif_mnote_data_load (data->priv->md, d, ds);\n\t}\n}\n\n#define LOG_TOO_SMALL \\\nexif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\", \\\n\t\t_(\"Size of data too small to allow for EXIF data.\"));\n\nvoid\nexif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Parsing %i byte(s) EXIF data...\\n\", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Found EXIF header at start.\");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", _(\"EXIF marker not found.\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"We have to deal with %i byte(s) of EXIF data.\",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"EXIF header not found.\"));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Found EXIF header.\");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \"II\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \"MM\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"Unknown encoding.\"));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \n\t\t  \"IFD 0 at %i.\", (int) offset);\n\n\t/* ds is restricted to 16 bit above, so offset is restricted too, and offset+8 should not overflow. */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\t/* offset < 2<<16, n is 16 bit at most, so this op will not overflow */\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"IFD 1 at %i.\", (int) offset);\n\n\t\t/* Sanity check. ds is ensured to be above 6 above, offset is 16bit */\n\t\tif (offset > ds - 6) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", \"Bogus offset of IFD1.\");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}\n\nvoid\nexif_data_save_data (ExifData *data, unsigned char **d, unsigned int *ds)\n{\n\tif (ds)\n\t\t*ds = 0;\t/* This means something went wrong */\n\n\tif (!data || !d || !ds)\n\t\treturn;\n\n\t/* Header */\n\t*ds = 14;\n\t*d = exif_data_alloc (data, *ds);\n\tif (!*d)  {\n\t\t*ds = 0;\n\t\treturn;\n\t}\n\tmemcpy (*d, ExifHeader, 6);\n\n\t/* Order (offset 6) */\n\tif (data->priv->order == EXIF_BYTE_ORDER_INTEL) {\n\t\tmemcpy (*d + 6, \"II\", 2);\n\t} else {\n\t\tmemcpy (*d + 6, \"MM\", 2);\n\t}\n\n\t/* Fixed value (2 bytes, offset 8) */\n\texif_set_short (*d + 8, data->priv->order, 0x002a);\n\n\t/*\n\t * IFD 0 offset (4 bytes, offset 10).\n\t * We will start 8 bytes after the\n\t * EXIF header (2 bytes for order, another 2 for the test, and\n\t * 4 bytes for the IFD 0 offset make 8 bytes together).\n\t */\n\texif_set_long (*d + 10, data->priv->order, 8);\n\n\t/* Now save IFD 0. IFD 1 will be saved automatically. */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Saving IFDs...\");\n\texif_data_save_data_content (data, data->ifd[EXIF_IFD_0], d, ds,\n\t\t\t\t     *ds - 6);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Saved %i byte(s) EXIF data.\", *ds);\n}\n\nExifData *\nexif_data_new_from_file (const char *path)\n{\n\tExifData *edata;\n\tExifLoader *loader;\n\n\tloader = exif_loader_new ();\n\texif_loader_write_file (loader, path);\n\tedata = exif_loader_get_data (loader);\n\texif_loader_unref (loader);\n\n\treturn (edata);\n}\n\nvoid\nexif_data_ref (ExifData *data)\n{\n\tif (!data)\n\t\treturn;\n\n\tdata->priv->ref_count++;\n}\n\nvoid\nexif_data_unref (ExifData *data)\n{\n\tif (!data) \n\t\treturn;\n\n\tdata->priv->ref_count--;\n\tif (!data->priv->ref_count) \n\t\texif_data_free (data);\n}\n\nvoid\nexif_data_free (ExifData *data)\n{\n\tunsigned int i;\n\tExifMem *mem = (data && data->priv) ? data->priv->mem : NULL;\n\n\tif (!data) \n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++) {\n\t\tif (data->ifd[i]) {\n\t\t\texif_content_unref (data->ifd[i]);\n\t\t\tdata->ifd[i] = NULL;\n\t\t}\n\t}\n\n\tif (data->data) {\n\t\texif_mem_free (mem, data->data);\n\t\tdata->data = NULL;\n\t}\n\n\tif (data->priv) {\n\t\tif (data->priv->log) {\n\t\t\texif_log_unref (data->priv->log);\n\t\t\tdata->priv->log = NULL;\n\t\t}\n\t\tif (data->priv->md) {\n\t\t\texif_mnote_data_unref (data->priv->md);\n\t\t\tdata->priv->md = NULL;\n\t\t}\n\t\texif_mem_free (mem, data->priv);\n\t\texif_mem_free (mem, data);\n\t}\n\n\texif_mem_unref (mem);\n}\n\nvoid\nexif_data_dump (ExifData *data)\n{\n\tunsigned int i;\n\n\tif (!data)\n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++) {\n\t\tif (data->ifd[i] && data->ifd[i]->count) {\n\t\t\tprintf (\"Dumping IFD '%s'...\\n\",\n\t\t\t\texif_ifd_get_name (i));\n\t\t\texif_content_dump (data->ifd[i], 0);\n\t\t}\n\t}\n\n\tif (data->data) {\n\t\tprintf (\"%i byte(s) thumbnail data available: \", data->size);\n\t\tif (data->size >= 4) {\n\t\t\tprintf (\"0x%02x 0x%02x ... 0x%02x 0x%02x\\n\",\n\t\t\t\tdata->data[0], data->data[1],\n\t\t\t\tdata->data[data->size - 2],\n\t\t\t\tdata->data[data->size - 1]);\n\t\t}\n\t}\n}\n\nExifByteOrder\nexif_data_get_byte_order (ExifData *data)\n{\n\tif (!data)\n\t\treturn (0);\n\n\treturn (data->priv->order);\n}\n\nvoid\nexif_data_foreach_content (ExifData *data, ExifDataForeachContentFunc func,\n\t\t\t   void *user_data)\n{\n\tunsigned int i;\n\n\tif (!data || !func)\n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\tfunc (data->ifd[i], user_data);\n}\n\ntypedef struct _ByteOrderChangeData ByteOrderChangeData;\nstruct _ByteOrderChangeData {\n\tExifByteOrder old, new;\n};\n\nstatic void\nentry_set_byte_order (ExifEntry *e, void *data)\n{\n\tByteOrderChangeData *d = data;\n\n\tif (!e)\n\t\treturn;\n\n\texif_array_set_byte_order (e->format, e->data, e->components, d->old, d->new);\n}\n\nstatic void\ncontent_set_byte_order (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, entry_set_byte_order, data);\n}\n\nvoid\nexif_data_set_byte_order (ExifData *data, ExifByteOrder order)\n{\n\tByteOrderChangeData d;\n\n\tif (!data || (order == data->priv->order))\n\t\treturn;\n\n\td.old = data->priv->order;\n\td.new = order;\n\texif_data_foreach_content (data, content_set_byte_order, &d);\n\tdata->priv->order = order;\n\tif (data->priv->md)\n\t\texif_mnote_data_set_byte_order (data->priv->md, order);\n}\n\nvoid\nexif_data_log (ExifData *data, ExifLog *log)\n{\n\tunsigned int i;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_log_unref (data->priv->log);\n\tdata->priv->log = log;\n\texif_log_ref (log);\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\texif_content_log (data->ifd[i], log);\n}\n\n/* Used internally within libexif */\nExifLog *exif_data_get_log (ExifData *);\nExifLog *\nexif_data_get_log (ExifData *data)\n{\n\tif (!data || !data->priv) \n\t\treturn NULL;\n\treturn data->priv->log;\n}\n\nstatic const struct {\n\tExifDataOption option;\n\tconst char *name;\n\tconst char *description;\n} exif_data_option[] = {\n\t{EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS, N_(\"Ignore unknown tags\"),\n\t N_(\"Ignore unknown tags when loading EXIF data.\")},\n\t{EXIF_DATA_OPTION_FOLLOW_SPECIFICATION, N_(\"Follow specification\"),\n\t N_(\"Add, correct and remove entries to get EXIF data that follows \"\n\t    \"the specification.\")},\n\t{EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE, N_(\"Do not change maker note\"),\n\t N_(\"When loading and resaving Exif data, save the maker note unmodified.\"\n\t    \" Be aware that the maker note can get corrupted.\")},\n\t{0, NULL, NULL}\n};\n\nconst char *\nexif_data_option_get_name (ExifDataOption o)\n{\n\tunsigned int i;\n\n\tfor (i = 0; exif_data_option[i].name; i++)\n\t\tif (exif_data_option[i].option == o) \n\t\t\tbreak;\n\treturn _(exif_data_option[i].name);\n}\n\nconst char *\nexif_data_option_get_description (ExifDataOption o)\n{\n\tunsigned int i;\n\n\tfor (i = 0; exif_data_option[i].description; i++)\n\t\tif (exif_data_option[i].option == o) \n\t\t\tbreak;\n\treturn _(exif_data_option[i].description);\n}\n\nvoid\nexif_data_set_option (ExifData *d, ExifDataOption o)\n{\n\tif (!d) \n\t\treturn;\n\n\td->priv->options |= o;\n}\n\nvoid\nexif_data_unset_option (ExifData *d, ExifDataOption o)\n{\n\tif (!d) \n\t\treturn;\n\n\td->priv->options &= ~o;\n}\n\nstatic void\nfix_func (ExifContent *c, void *UNUSED(data))\n{\n\tswitch (exif_content_get_ifd (c)) {\n\tcase EXIF_IFD_1:\n\t\tif (c->parent->data)\n\t\t\texif_content_fix (c);\n\t\telse if (c->count) {\n\t\t\texif_log (c->parent->priv->log, EXIF_LOG_CODE_DEBUG, \"exif-data\",\n\t\t\t\t  \"No thumbnail but entries on thumbnail. These entries have been \"\n\t\t\t\t  \"removed.\");\n\t\t\twhile (c->count) {\n\t\t\t\tunsigned int cnt = c->count;\n\t\t\t\texif_content_remove_entry (c, c->entries[c->count - 1]);\n\t\t\t\tif (cnt == c->count) {\n\t\t\t\t\t/* safety net */\n\t\t\t\t\texif_log (c->parent->priv->log, EXIF_LOG_CODE_DEBUG, \"exif-data\",\n\t\t\t\t\t\"failed to remove last entry from entries.\");\n\t\t\t\t\tc->count--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\texif_content_fix (c);\n\t}\n}\n\nvoid\nexif_data_fix (ExifData *d)\n{\n\texif_data_foreach_content (d, fix_func, NULL);\n}\n\nvoid\nexif_data_set_data_type (ExifData *d, ExifDataType dt)\n{\n\tif (!d || !d->priv) \n\t\treturn;\n\n\td->priv->data_type = dt;\n}\n\nExifDataType\nexif_data_get_data_type (ExifData *d)\n{\n\treturn (d && d->priv) ? d->priv->data_type : EXIF_DATA_TYPE_UNKNOWN;\n}\n"], "filenames": ["libexif/exif-data.c"], "buggy_code_start_loc": [195], "buggy_code_end_loc": [969], "fixing_code_start_loc": [195], "fixing_code_end_loc": [977], "type": "CWE-190", "message": "In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774", "other": {"cve": {"id": "CVE-2019-9278", "sourceIdentifier": "security@android.com", "published": "2019-09-27T19:15:19.060", "lastModified": "2022-10-14T01:47:34.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774"}, {"lang": "es", "value": "En libexif, se presenta una posible escritura fuera de l\u00edmites debido a un desbordamiento de enteros. Esto podr\u00eda conllevar a una escalada de privilegios remota en el proveedor de contenido multimedia sin ser necesarios privilegios de ejecuci\u00f3n adicionales. Es requerida una interacci\u00f3n del usuario para su explotaci\u00f3n. Producto: Android, Versiones: Android-10, ID de Android: A-112537774"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "D558D965-FA70-4822-A770-419E73BA9ED3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:*:*:*:*", "matchCriteriaId": "1F3EFED2-F6BC-46D9-AB22-D5ED87EF4549"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00000.html", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00017.html", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/10/25/17", "source": "security@android.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/10/27/1", "source": "security@android.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/11/07/1", "source": "security@android.com", "tags": ["Mailing List"]}, {"url": "https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566", "source": "security@android.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libexif/libexif/issues/26", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00007.html", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MO2VTHD7OLPJDCJBHKUQTBAHZOBBCF6X/", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VA5BPQLOFXIZOOJHBYDU635Z5KLUMTDD/", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Feb/9", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-05", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/android-10", "source": "security@android.com", "tags": ["Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/4277-1/", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4618", "source": "security@android.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566"}}