{"buggy_code": ["en:\n  reports:\n    currently_away:\n      title: Users currently away\n      labels:\n        username: Username\n\n  discourse_automation:\n    triggerables:\n      event_started:\n        title: Event started\n  system_messages:\n    discourse_calendar_holiday_region_invalid: \"The holiday region you provided does not exist.\"\n    discourse_calendar_enable_holiday_failed: \"This holiday could not be enabled, it's already enabled or it's not disabled.\"\n    discourse_post_event_bulk_invite_succeeded:\n      title: \"Event - Bulk Invite Succeeded\"\n      subject_template: \"Bulk invite processed successfully\"\n      text_body_template: \"Your bulk invite file was processed, %{processed} invitee(s) created.\"\n    discourse_post_event_bulk_invite_failed:\n      title: \"Event - Bulk Invite Failed\"\n      subject_template: \"Bulk invite processed with errors\"\n      text_body_template: |\n        Your bulk invite file was processed, %{processed} invitee(s) created with %{failed} error(s).\n\n        Here's the log:\n\n        ```text\n        %{logs}\n        ```\n\n  site_settings:\n    calendar_enabled: \"Enable the discourse-calendar plugin. This will add support for a [calendar][/calendar] tag in the first post of a topic.\"\n    discourse_post_event_enabled: \"[experimental] Enables to attach an event to a post. Note: also needs `calendar enabled` to be enabled.\"\n    displayed_invitees_limit: \"Limits the numbers of invitees displayed on an event.\"\n    display_post_event_date_on_topic_title: \"Displays the date of the event after the topic title.\"\n    use_local_event_date: \"Use local date after topic title instead of relative time.\"\n    discourse_post_event_allowed_on_groups: \"Groups that are allowed to create events.\"\n    discourse_post_event_allowed_custom_fields: \"Allows to let each event to set the value of custom fields.\"\n    discourse_post_event_edit_notifications_time_extension: \"Extends (in minutes) the period after the end of an event when `going` invitees are still being notified from edit in the original post.\"\n    holiday_calendar_topic_id: \"Topic ID of staffs holiday / absence calendar.\"\n    delete_expired_event_posts_after: \"Posts with expired events will be automatically deleted after (n) hours. Set to -1 to disable deletion.\"\n    all_day_event_start_time: \"Events that do not have a start time specified will start at this time. Format is HH:mm. For 6:00 am, enter 06:00\"\n    all_day_event_end_time: \"Events that do not have a end time specified will end at this time. Format is HH:mm. For 6:00 pm, enter 18:00\"\n    all_day_event_time_error: \"Invalid time. Format needs to be HH:mm (ex: 08:00).\"\n    calendar_categories: \"Display a calendar at the top of a category. Mandatory settings are categoryId and postId. eg: categoryId=6;postId=453\\n Other valid settings: tzPicker, weekends and defaultView.\"\n    calendar_categories_outlet: \"Allows to change which outlet should show the category calendar.\"\n    working_days: \"Set working days. You can display the availability of a group using the `timezones` tag in a post, eg: `[timezones group=admins][timezones]`\"\n    working_day_start_hour: \"Start time of the working day hours.\"\n    working_day_end_hour: \"End time of the working day hours.\"\n    close_to_working_day_hours_extension: \"Set extension time in working day hours to highlight the timezones.\"\n    events_calendar_categories: \"Display an events calendar at the top of a category.\"\n    sort_categories_by_event_start_date_enabled: \"Enable the sorting of category topics by event start date.\"\n    disable_resorting_on_categories_enabled: \"Allow categories to disable the ability for users to sort on the event category.\"\n  discourse_calendar:\n    invite_user_notification: \"%{username} invited you to: %{description}\"\n    calendar_must_be_in_first_post: \"Calendar tag can only be used in first post of a topic.\"\n    more_than_one_calendar: \"You can\u2019t have more than one calendar in a post.\"\n    more_than_two_dates: \"A post of a calendar topic can\u2019t contain more than two dates.\"\n    event_expired: \"Event expired\"\n    holiday_status:\n      description: \"On holiday\"\n  discourse_post_event:\n    notifications:\n      before_event_reminder: \"%{title} is about to start.\"\n      after_event_reminder: \"%{title} has ended.\"\n      ongoing_event_reminder: \"%{title} is ongoing.\"\n    errors:\n      bulk_invite:\n        max_invitees: \"First %{max_invittes} invitees have been created. Try splitting the file in smaller parts.\"\n        error: \"There was an error uploading that file. Please try again later.\"\n      models:\n        event:\n          only_one_event: \"A post can only have one event.\"\n          only_group: \"An event accepts only group names.\"\n          must_be_in_first_post: \"An event can only be in the first post of a topic.\"\n          raw_invitees_length: \"An event is limited to %{count} users/groups.\"\n          ends_at_before_starts_at: \"An event can't end before it starts.\"\n          start_must_be_present_and_a_valid_date: \"An event requires a valid start date.\"\n          end_must_be_a_valid_date: \"End date must be a valid date.\"\n          invalid_recurrence: \"Recurrence must be one of: every_month, every_week, every_two_weeks, every_day, every_weekday.\"\n          invalid_timezone: \"Timezone not recognized.\"\n          acting_user_not_allowed_to_create_event: \"Current user is not allowed to create events.\"\n          acting_user_not_allowed_to_act_on_this_event: \"Current user is not allowed to act on this event.\"\n          custom_field_is_invalid: \"The custom field `%{field}` is not allowed.\"\n          name:\n            length: \"Event name length must be between %{minimum} and %{maximum} characters.\"\n", "# frozen_string_literal: true\n\nmodule Jobs\n  class DiscoursePostEventBulkInvite < ::Jobs::Base\n    sidekiq_options retry: false\n\n    def initialize\n      super\n\n      @logs = []\n      @processed = 0\n      @failed = 0\n    end\n\n    def execute(args)\n      invitees = args[:invitees]\n      raise Discourse::InvalidParameters.new(:invitees) if invitees.blank?\n\n      @current_user = User.find_by(id: args[:current_user_id])\n      raise Discourse::InvalidParameters.new(:current_user_id) unless @current_user\n\n      @event = DiscoursePostEvent::Event.find_by(id: args[:event_id])\n      raise Discourse::InvalidParameters.new(:event_id) unless @event\n\n      @guardian = Guardian.new(@current_user)\n      @guardian.ensure_can_edit!(@event.post)\n\n      process_invitees(invitees)\n    ensure\n      notify_user\n    end\n\n    private\n\n    def process_invitees(invitees)\n      max_bulk_invitees = SiteSetting.discourse_post_event_max_bulk_invitees\n\n      invitees.each do |invitee|\n        break if @processed >= max_bulk_invitees\n        process_invitee(invitee)\n      end\n\n      if @processed > 0\n        @event.publish_update!\n        @event.notify_invitees!(predefined_attendance: true)\n      end\n    rescue Exception => e\n      save_log \"Bulk Invite Process Failed -- '#{e.message}'\"\n      @failed += 1\n    end\n\n    def process_invitee(invitee)\n      if @event.public?\n        users = User.where(username: invitee['identifier']).pluck(:id)\n      else\n        group = Group.find_by(name: invitee['identifier'])\n        if group\n          users = group.users.pluck(:id)\n          @event.update_with_params!(raw_invitees: (@event.raw_invitees || []).push(group.name).uniq)\n        end\n      end\n\n      if users.blank?\n        save_log \"Couldn't find user or group: '#{invitee['identifier']}' or the groups provided contained no users. Note that public events can't bulk invite groups. And other events can't bulk invite usernames.\"\n        @failed += 1\n        return\n      end\n\n      users.each do |user_id|\n        create_attendance(user_id, @event.post.id, invitee['attendance'] || 'going')\n      end\n\n      @processed += 1\n    rescue Exception => e\n      save_log \"Bulk Invite Process Failed -- '#{e.message}'\"\n      @failed += 1\n    end\n\n    def create_attendance(user_id, post_id, attendance)\n      unknown = DiscoursePostEvent::Invitee::UNKNOWN_ATTENDANCE\n\n      if attendance == unknown\n        DiscoursePostEvent::Invitee.where(user_id: user_id, post_id: post_id).destroy_all\n      else\n        status = DiscoursePostEvent::Invitee.statuses[attendance.to_sym]\n        invitee = DiscoursePostEvent::Invitee.find_or_initialize_by(user_id: user_id, post_id: post_id)\n        invitee.notified = false\n        invitee.status = status\n        invitee.save!\n      end\n    end\n\n    def save_log(message)\n      @logs << \"[#{Time.zone.now}] #{message}\"\n    end\n\n    def notify_user\n      if @current_user\n        if @processed > 0 && @failed == 0\n          SystemMessage.create_from_system_user(\n            @current_user,\n            :discourse_post_event_bulk_invite_succeeded,\n            processed: @processed\n          )\n        else\n          SystemMessage.create_from_system_user(\n            @current_user,\n            :discourse_post_event_bulk_invite_failed,\n            processed: @processed,\n            failed: @failed,\n            logs: @logs.join(\"\\n\")\n          )\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule DiscoursePostEvent\n  class EventValidator\n    VALID_RECURRENCES = %w[\n      every_month\n      every_week\n      every_two_weeks\n      every_day\n      every_weekday\n    ]\n\n    def initialize(post)\n      @post = post\n    end\n\n    def validate_event\n      extracted_events = DiscoursePostEvent::EventParser::extract_events(@post)\n\n      if extracted_events.count == 0\n        return false\n      end\n\n      if extracted_events.count > 1\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.only_one_event\"))\n        return false\n      end\n\n      if !@post.is_first_post?\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.must_be_in_first_post\"))\n        return false\n      end\n\n      extracted_event = extracted_events.first\n\n      if @post.acting_user && @post.event\n        if !@post.acting_user.can_act_on_discourse_post_event?(@post.event)\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.acting_user_not_allowed_to_act_on_this_event\"))\n          return false\n        end\n      else\n        if !@post.acting_user || !@post.acting_user.can_create_discourse_post_event?\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.acting_user_not_allowed_to_create_event\"))\n          return false\n        end\n      end\n\n      if extracted_event[:start].blank? || (DateTime.parse(extracted_event[:start]) rescue nil).nil?\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.start_must_be_present_and_a_valid_date\"))\n        return false\n      end\n\n      if extracted_event[:end].present? && (DateTime.parse(extracted_event[:end]) rescue nil).nil?\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.end_must_be_a_valid_date\"))\n        return false\n      end\n\n      if extracted_event[:start].present? && extracted_event[:end].present?\n        if Time.parse(extracted_event[:start]) > Time.parse(extracted_event[:end])\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.ends_at_before_starts_at\"))\n          return false\n        end\n      end\n\n      if extracted_event[:name].present?\n        if !(Event::MIN_NAME_LENGTH..Event::MAX_NAME_LENGTH).cover?(extracted_event[:name].length)\n          @post.errors.add(:base, I18n.t('discourse_post_event.errors.models.event.name.length', minimum: Event::MIN_NAME_LENGTH, maximum: Event::MAX_NAME_LENGTH))\n          return false\n        end\n      end\n\n      if extracted_event[:recurrence].present?\n        if !VALID_RECURRENCES.include?(extracted_event[:recurrence].to_s)\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.invalid_recurrence\"))\n        end\n      end\n\n      if extracted_event[:timezone].present?\n        if !ActiveSupport::TimeZone[extracted_event[:timezone]].present?\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.invalid_timezone\", timezone: extracted_event[:timezone]))\n        end\n      end\n\n      true\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'securerandom'\n\ndescribe Post do\n  Event ||= DiscoursePostEvent::Event\n  Invitee ||= DiscoursePostEvent::Invitee\n\n  before do\n    freeze_time\n    Jobs.run_immediately!\n    SiteSetting.calendar_enabled = true\n    SiteSetting.discourse_post_event_enabled = true\n  end\n\n  let(:user) { Fabricate(:user, admin: true) }\n\n  context 'with a public event' do\n    let(:post_1) { Fabricate(:post) }\n    let(:event_1) { Fabricate(:event, post: post_1, raw_invitees: ['trust_level_0']) }\n\n    context 'when a post is updated' do\n      context 'when the post has a valid event' do\n        context 'when the event markup is removed' do\n          it 'destroys the associated event' do\n            start = Time.now.utc.iso8601(3)\n\n            post = create_post_with_event(user)\n\n            expect(post.reload.event.persisted?).to eq(true)\n\n            revisor = PostRevisor.new(post, post.topic)\n            revisor.revise!(\n              user,\n              raw: 'The event is over. Come back another day.'\n            )\n\n            expect(post.reload.event).to be(nil)\n          end\n        end\n\n        context 'when event is on going' do\n          let(:going_user) { Fabricate(:user) }\n          let(:interested_user) { Fabricate(:user) }\n\n          before do\n            SiteSetting.editing_grace_period = 1.minute\n            PostActionNotifier.enable\n            SiteSetting.discourse_post_event_edit_notifications_time_extension =\n              180\n          end\n\n          context 'when in edit grace period' do\n            before do\n              event_1.event_dates.first.update_columns(\n                starts_at: 3.hours.ago, ends_at: 2.hours.ago\n              )\n\n              # clean state\n              Notification.destroy_all\n              interested_user.reload\n              going_user.reload\n            end\n\n            it 'sends a post revision to going invitees' do\n              Invitee.create_attendance!(going_user.id, post_1.id, :going)\n              Invitee.create_attendance!(\n                interested_user.id,\n                post_1.id,\n                :interested\n              )\n\n              expect {\n                revisor = PostRevisor.new(post_1)\n                revisor.revise!(\n                  user,\n                  { raw: post_1.raw + \"\\nWe are bout half way into our event!\" },\n                  revised_at: Time.now + 2.minutes\n                )\n              }.to change {\n                going_user.notifications.count\n              }.by(1)\n\n              expect(interested_user.notifications.count).to eq(0)\n            end\n          end\n\n          context 'when not edit grace period' do\n            before do\n              event_1.event_dates.first.update_columns(starts_at: 5.hours.ago)\n            end\n\n            it 'doesn\u2019t send a post revision to anyone' do\n              Invitee.create_attendance!(going_user.id, post_1.id, :going)\n              Invitee.create_attendance!(\n                interested_user.id,\n                event_1.id,\n                :interested\n              )\n\n              expect {\n                revisor = PostRevisor.new(event_1.post)\n                revisor.revise!(\n                  user,\n                  { raw: event_1.post.raw + \"\\nWe are bout half way into our event!\" },\n                  revised_at: Time.now + 2.minutes\n                )\n              }.to change {\n                going_user.notifications.count + interested_user.notifications.count\n              }.by(0)\n            end\n          end\n\n          context 'with an event with recurrence' do\n            before do\n              freeze_time Time.utc(2020, 8, 12, 16, 32)\n\n              event_1.update_with_params!(\n                recurrence: 'FREQ=WEEKLY;BYDAY=MO',\n                original_starts_at: 3.hours.ago,\n                original_ends_at: nil\n              )\n\n              Invitee.create_attendance!(going_user.id, event_1.id, :going)\n              Invitee.create_attendance!(\n                interested_user.id,\n                event_1.id,\n                :interested\n              )\n\n              event_1.reload\n\n              # we stop processing jobs immediately at this point to prevent infinite loop\n              # as future event ended job would finish now, trigger next recurrence, and anodther job...\n              Jobs.run_later!\n            end\n\n            context 'when the event ends' do\n              it 'sets the next dates' do\n                event_1.update_with_params!(original_ends_at: Time.now)\n\n                expect(event_1.starts_at.to_s).to eq('2020-08-19 13:32:00 UTC')\n                expect(event_1.ends_at.to_s).to eq('2020-08-19 16:32:00 UTC')\n              end\n\n              it 'it removes status from every invitees' do\n                expect(event_1.invitees.pluck(:status)).to match_array(\n                  [Invitee.statuses[:going], Invitee.statuses[:interested]]\n                )\n\n                event_1.update_with_params!(original_ends_at: Time.now)\n                expect(event_1.invitees.pluck(:status).compact).to eq([])\n              end\n\n              # that will be handled by new job, uncomment when finishedh\n              it 'resends event creation notification to invitees' do\n                expect { event_1.update_with_params!(original_ends_at: Time.now) }.to change {\n                  going_user.notifications.count\n                }.by(1)\n              end\n            end\n          end\n\n          context 'when updating raw_invitees' do\n            let(:lurker_1) { Fabricate(:user) }\n            let(:group_1) { Fabricate(:group) }\n\n            it 'doesn\u2019t accept usernames' do\n              event_1.update_with_params!(raw_invitees: [lurker_1.username])\n              expect(event_1.raw_invitees).to eq(['trust_level_0'])\n            end\n\n            it 'doesn\u2019t accept another group than trust_level_0' do\n              event_1.update_with_params!(raw_invitees: [group_1.name])\n              expect(event_1.raw_invitees).to eq(['trust_level_0'])\n            end\n          end\n\n          context 'when updating status to private' do\n            it 'it changes the status and force invitees' do\n              expect(event_1.raw_invitees).to eq(['trust_level_0'])\n              expect(event_1.status).to eq(Event.statuses[:public])\n\n              event_1.update_with_params!(status: Event.statuses[:private])\n\n              expect(event_1.raw_invitees).to eq([])\n              expect(event_1.status).to eq(Event.statuses[:private])\n            end\n          end\n        end\n      end\n    end\n\n    context 'when a post is created' do\n      context 'when the post contains one valid event' do\n        context 'when the acting user is admin' do\n          it 'creates the post event' do\n            start = Time.now.utc.iso8601(3)\n\n            post =\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party',\n                raw: \"[event start=\\\"#{start}\\\"]\\n[/event]\"\n              )\n\n            expect(post.reload.persisted?).to eq(true)\n            expect(post.event.persisted?).to eq(true)\n            expect(post.event.original_starts_at).to eq_time(Time.parse(start))\n          end\n\n          it 'works with name attribute' do\n            post = create_post_with_event(user, 'name=\"foo bar\"').reload\n            expect(post.event.name).to eq('foo bar')\n\n            post = create_post_with_event(user, 'name=\"\"').reload\n            expect(post.event.name).to be_blank\n\n            post = create_post_with_event(user, 'name=').reload\n            expect(post.event.name).to be_blank\n          end\n\n          it 'works with url attribute' do\n            url = 'https://www.discourse.org'\n\n            post = create_post_with_event(user, \"url=\\\"#{url}\\\"\").reload\n            expect(post.event.url).to eq(url)\n\n            post = create_post_with_event(user, 'url=\"\"').reload\n            expect(post.event.url).to be_blank\n\n            post = create_post_with_event(user, 'url=').reload\n            expect(post.event.url).to be_blank\n          end\n\n          it 'works with status attribute' do\n            post = create_post_with_event(user, 'status=\"private\"').reload\n            expect(post.event.status).to eq(\n              DiscoursePostEvent::Event.statuses[:private]\n            )\n\n            post = create_post_with_event(user, 'status=\"\"').reload\n            expect(post.event.status).to eq(\n              DiscoursePostEvent::Event.statuses[:standalone]\n            )\n\n            post = create_post_with_event(user, 'status=').reload\n            expect(post.event.status).to eq(\n              DiscoursePostEvent::Event.statuses[:standalone]\n            )\n          end\n\n          it 'works with allowedGroups attribute' do\n            post = create_post_with_event(user, 'allowedGroups=\"euro\"').reload\n            expect(post.event.raw_invitees).to eq([])\n\n            post =\n              create_post_with_event(user, 'status=\"public\" allowedGroups=\"euro\"')\n                .reload\n            expect(post.event.raw_invitees).to eq(%w[trust_level_0])\n\n            post =\n              create_post_with_event(\n                user,\n                'status=\"standalone\" allowedGroups=\"euro\"'\n              ).reload\n            expect(post.event.raw_invitees).to eq([])\n\n            post =\n              create_post_with_event(\n                user,\n                'status=\"private\" allowedGroups=\"euro\"'\n              ).reload\n            expect(post.event.raw_invitees).to eq(%w[euro])\n\n            post =\n              create_post_with_event(\n                user,\n                'status=\"private\" allowedGroups=\"euro,america\"'\n              ).reload\n            expect(post.event.raw_invitees).to match_array(%w[euro america])\n\n            post =\n              create_post_with_event(user, 'status=\"private\" allowedGroups=\"\"')\n                .reload\n            expect(post.event.raw_invitees).to eq([])\n\n            post =\n              create_post_with_event(user, 'status=\"private\" allowedGroups=')\n                .reload\n            expect(post.event.raw_invitees).to eq([])\n          end\n\n          it 'works with reminders attribute' do\n            post = create_post_with_event(user).reload\n            expect(post.event.reminders).to eq(nil)\n\n            post =\n              create_post_with_event(user, 'reminders=\"1.hours,-3.days\"').reload\n            expect(post.event.reminders).to eq('1.hours,-3.days')\n          end\n\n          context 'with custom fields' do\n            before do\n              SiteSetting.discourse_post_event_allowed_custom_fields = 'foo-bar|bar'\n            end\n\n            it 'works with allowed custom fields' do\n              post = create_post_with_event(user, 'fooBar=\"1\"').reload\n              expect(post.event.custom_fields['foo-bar']).to eq('1')\n\n              post = create_post_with_event(user, 'bar=\"2\"').reload\n              expect(post.event.custom_fields['bar']).to eq('2')\n            end\n\n            it 'doesn\u2019t work with not allowed custom fields' do\n              post = create_post_with_event(user, 'baz=\"3\"').reload\n              expect(post.event.custom_fields['baz']).to eq(nil)\n            end\n          end\n        end\n\n        context 'when the acting user has rights to create events' do\n          let(:user_with_rights) { Fabricate(:user) }\n          let(:group) { Fabricate(:group, users: [user_with_rights]) }\n\n          before do\n            SiteSetting.discourse_post_event_allowed_on_groups = group.id.to_s\n          end\n\n          it 'creates the post event' do\n            start = Time.now.utc.iso8601(3)\n\n            post =\n              PostCreator.create!(\n                user_with_rights,\n                title: 'Sell a boat party',\n                raw: \"[event start=\\\"#{start}\\\"]\\n[/event]\"\n              )\n\n            expect(post.reload.persisted?).to eq(true)\n            expect(post.event.persisted?).to eq(true)\n            expect(post.event.original_starts_at).to eq_time(Time.parse(start))\n          end\n        end\n\n        context 'when the acting user doesn\u2019t have rights to create events' do\n          let(:user_without_rights) { Fabricate(:user) }\n          let(:group) { Fabricate(:group, users: [user]) }\n\n          before do\n            SiteSetting.discourse_post_event_allowed_on_groups = group.id.to_s\n          end\n\n          it 'raises an error' do\n            start = Time.now.utc.iso8601(3)\n\n            expect do\n              PostCreator.create!(\n                user_without_rights,\n                title: 'Sell a boat party',\n                raw: \"[event start=\\\"#{start}\\\"]\\n[/event]\"\n              )\n            end.to(\n              raise_error(ActiveRecord::RecordNotSaved).with_message(\n                I18n.t(\n                  'discourse_post_event.errors.models.event.acting_user_not_allowed_to_create_event'\n                )\n              )\n            )\n          end\n        end\n      end\n\n      context 'when the post contains one invalid event' do\n        context 'when start is invalid' do\n          it 'raises an error' do\n            expect do\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party', raw: \"[event start=\\\"x\\\"]\\n[/event]\"\n              )\n            end.to(\n              raise_error(ActiveRecord::RecordNotSaved).with_message(\n                I18n.t(\n                  'discourse_post_event.errors.models.event.start_must_be_present_and_a_valid_date'\n                )\n              )\n            )\n          end\n        end\n\n        context 'when recurrence is invalid' do\n          it 'raises an error' do\n            expect {\n              create_post_with_event(user, 'recurrence=\"foo\"')\n            }.to raise_error(I18n.t(\"discourse_post_event.errors.models.event.invalid_recurrence\"))\n          end\n        end\n\n        context 'when start is not provided or' do\n          it 'is not cooked' do\n            post =\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party',\n                raw: <<~TXT\n                [event end=\\\"1\\\"]\n                [/event]\n              TXT\n              )\n\n            expect(!post.cooked.include?('discourse-post-event')).to be(true)\n          end\n        end\n\n        context 'when end is provided and is invalid' do\n          it 'raises an error' do\n            expect do\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party',\n                raw:\n                  \"[event start=\\\"#{\n                    Time.now.utc.iso8601(3)\n                  }\\\" end=\\\"d\\\"]\\n[/event]\"\n              )\n            end.to(\n              raise_error(ActiveRecord::RecordNotSaved).with_message(\n                I18n.t(\n                  'discourse_post_event.errors.models.event.end_must_be_a_valid_date'\n                )\n              )\n            )\n          end\n        end\n      end\n\n      context 'when the post contains multiple events' do\n        it 'raises an error' do\n          expect do\n            PostCreator.create!(\n              user,\n              title: 'Sell a boat party',\n              raw: <<~TXT\n                [event start=\\\"#{Time.now.utc.iso8601(3)}\\\"]\n                [/event]\n\n                [event start=\\\"#{Time.now.utc.iso8601(3)}\\\"]\n                [/event]\n              TXT\n            )\n          end.to(\n            raise_error(ActiveRecord::RecordNotSaved).with_message(\n              I18n.t('discourse_post_event.errors.models.event.only_one_event')\n            )\n          )\n        end\n      end\n    end\n\n    context 'when a post with an event is destroyed' do\n      it 'sets deleted_at on the post_event' do\n        expect(event_1.deleted_at).to be_nil\n\n        PostDestroyer.new(user, event_1.post).destroy\n        event_1.reload\n\n        expect(event_1.deleted_at).to eq_time(Time.now)\n      end\n    end\n\n    context 'when a post with an event is recovered' do\n      it 'nullifies deleted_at on the post_event' do\n        PostDestroyer.new(user, event_1.post).destroy\n\n        expect(event_1.reload.deleted_at).to eq_time(Time.now)\n\n        PostDestroyer.new(user, Post.with_deleted.find(event_1.id)).recover\n\n        expect(event_1.reload.deleted_at).to be_nil\n      end\n    end\n  end\n\n  context 'with a private event' do\n    before do\n      freeze_time Time.utc(2020, 8, 12, 16, 32)\n    end\n\n    let(:invitee_1) { Fabricate(:user) }\n    let(:invitee_2) { Fabricate(:user) }\n    let(:group_1) {\n      Fabricate(:group).tap do |g|\n        g.add(invitee_1)\n        g.add(invitee_2)\n        g.save!\n      end\n    }\n    let(:post_1) { Fabricate(:post) }\n    let(:event_1) {\n      Fabricate(\n        :event,\n        post: post_1,\n        status: Event.statuses[:private],\n        raw_invitees: [group_1.name],\n        original_starts_at: 3.hours.ago,\n        original_ends_at: nil\n      )\n    }\n\n    context 'with an event with recurrence' do\n      let(:event_1) {\n        Fabricate(\n          :event,\n          post: post_1,\n          status: Event.statuses[:private],\n          raw_invitees: [group_1.name],\n          recurrence: 'FREQ=WEEKLY;BYDAY=MO',\n          original_starts_at: 3.hours.ago,\n          original_ends_at: nil\n        )\n      }\n\n      before do\n        Invitee.create_attendance!(invitee_1.id, event_1.id, :going)\n\n        # we stop processing jobs immediately at this point to prevent infinite loop\n        # as future event ended job would finish now, trigger next recurrence, and anodther job...\n        Jobs.run_later!\n      end\n\n      context 'when updating the end' do\n        it 'resends event creation notification to invitees and possible invitees' do\n          expect(event_1.invitees.count).to eq(1)\n\n          expect { event_1.update_with_params!(original_ends_at: 2.hours.ago) }.to change {\n            invitee_1.notifications.count + invitee_2.notifications.count\n          }.by(2)\n        end\n      end\n    end\n\n    context 'when updating raw_invitees' do\n      let(:lurker_1) { Fabricate(:user) }\n      let(:group_2) { Fabricate(:group) }\n\n      it 'doesn\u2019t accept usernames' do\n        expect {\n          event_1.update_with_params!(raw_invitees: [lurker_1.username])\n        }.to raise_error(ActiveRecord::RecordInvalid)\n      end\n\n      it 'accepts another group than trust_level_0' do\n        event_1.update_with_params!(raw_invitees: [group_2.name])\n        expect(event_1.raw_invitees).to eq([group_2.name])\n      end\n    end\n\n    context 'when updating status to public' do\n      it 'it changes the status and force invitees' do\n        expect(event_1.raw_invitees).to eq([group_1.name])\n        expect(event_1.status).to eq(Event.statuses[:private])\n\n        event_1.update_with_params!(status: Event.statuses[:public])\n\n        expect(event_1.raw_invitees).to eq(['trust_level_0'])\n        expect(event_1.status).to eq(Event.statuses[:public])\n      end\n    end\n  end\n\n  context \"with holiday events\" do\n    let(:calendar_post) { create_post(raw: \"[calendar]\\n[/calendar]\") }\n\n    before do\n      SiteSetting.holiday_calendar_topic_id = calendar_post.topic_id\n    end\n\n    context \"when deleting a post with an event\" do\n      it \"clears user status that was previously set by the calendar plugin\" do\n        SiteSetting.enable_user_status = true\n        raw = 'Vacation [date=\"2018-06-05\" time=\"10:20:00\"] to [date=\"2018-06-06\" time=\"10:20:00\"]'\n        post = create_post(raw: raw, topic: calendar_post.topic)\n        freeze_time Time.utc(2018, 6, 5, 10, 30)\n        DiscourseCalendar::UpdateHolidayUsernames.new.execute(nil)\n\n        # the job has set the holiday status:\n        status = post.user.user_status\n        expect(status).to be_present\n        expect(status.description).to eq(I18n.t(\"discourse_calendar.holiday_status.description\"))\n        expect(status.emoji).to eq(DiscourseCalendar::HolidayStatus::EMOJI)\n        expect(status.ends_at).to eq_time(Time.utc(2018, 6, 6, 10, 20))\n\n        # after destroying the post the holiday status disappears:\n        PostDestroyer.new(user, post).destroy\n        post.user.reload\n\n        expect(post.user.user_status).to be_nil\n      end\n\n      it \"doesn't clear user status that wasn't set by the calendar plugin\" do\n        SiteSetting.enable_user_status = true\n        raw = 'Vacation [date=\"2018-06-05\" time=\"10:20:00\"] to [date=\"2018-06-06\" time=\"10:20:00\"]'\n        post = create_post(raw: raw, topic: calendar_post.topic)\n        freeze_time Time.utc(2018, 6, 5, 10, 30)\n        DiscourseCalendar::UpdateHolidayUsernames.new.execute(nil)\n\n        # the job has set the holiday status:\n        status = post.user.user_status\n        expect(status).to be_present\n        expect(status.description).to eq(I18n.t(\"discourse_calendar.holiday_status.description\"))\n        expect(status.emoji).to eq(DiscourseCalendar::HolidayStatus::EMOJI)\n        expect(status.ends_at).to eq_time(Time.utc(2018, 6, 6, 10, 20))\n\n        # user set their own status\n        custom_status = {\n          description: \"I am working on holiday\",\n          emoji: \"construction_worker_man\"\n        }\n        post.user.set_status!(custom_status[:description], custom_status[:emoji])\n\n        # the status that was set by user doesn't disappear after destroying the post:\n        PostDestroyer.new(user, post).destroy\n        post.user.reload\n\n        status = post.user.user_status\n        expect(status).to be_present\n        expect(status.description).to eq(custom_status[:description])\n        expect(status.emoji).to eq(custom_status[:emoji])\n      end\n    end\n  end\n\n  describe \"timezone handling\" do\n    before do\n      freeze_time Time.utc(2022, 7, 24, 13, 00)\n    end\n\n    it \"stores the correct information in the database\" do\n      expected_datetime = ActiveSupport::TimeZone[\"Australia/Sydney\"].parse(\"2022-07-24 14:01\")\n\n      post = PostCreator.create!(\n        user,\n        title: 'Beach party',\n        raw: \"[event start='2022-07-24 14:01' timezone='Australia/Sydney']\\n[/event]\"\n      ).reload\n\n      expect(post.event.timezone).to eq(\"Australia/Sydney\")\n      expect(post.event.original_starts_at).to eq_time(expected_datetime)\n      expect(post.event.starts_at).to eq_time(expected_datetime)\n      expect(post.event.event_dates.first.starts_at).to eq_time(expected_datetime)\n    end\n\n    it \"raises an error for invalid timezone\" do\n      expect {\n        PostCreator.create!(\n          user,\n          title: 'Beach party',\n          raw: \"[event start='2022-07-24 14:01' timezone='Westeros/Winterfell']\\n[/event]\"\n        )\n      }.to raise_error(I18n.t(\"discourse_post_event.errors.models.event.invalid_timezone\"))\n    end\n\n    it \"handles simple weekly recurrence correctly\" do\n      # Friday in Aus, Thursday in UTC\n      expected_original_datetime = ActiveSupport::TimeZone[\"Australia/Sydney\"].parse(\"2022-07-01 09:01\")\n      expected_next_datetime = ActiveSupport::TimeZone[\"Australia/Sydney\"].parse(\"2022-07-29 09:01\")\n\n      post = PostCreator.create!(\n        user,\n        title: 'Friday beach party',\n        raw: \"[event start='2022-07-01 09:01' end='2022-07-01 10:01' timezone='Australia/Sydney' recurrence='every_week']\\n[/event]\"\n      ).reload\n\n      expect(post.event.timezone).to eq(\"Australia/Sydney\")\n      expect(post.event.original_starts_at).to eq_time(expected_original_datetime)\n      expect(post.event.starts_at).to eq_time(expected_next_datetime)\n    end\n\n    it \"handles recurrence across daylight saving\" do\n      # DST starts on 27th March. Original datetime is before that. Expecting\n      # local time to be correct after the DST change\n      expected_original_datetime = ActiveSupport::TimeZone[\"Europe/Paris\"].parse(\"2022-03-20 09:01\")\n      expected_next_datetime = ActiveSupport::TimeZone[\"Europe/Paris\"].parse(\"2022-07-25 09:01\")\n\n      post = PostCreator.create!(\n        user,\n        title: 'Friday beach party',\n        raw: \"[event start='2022-03-20 09:01' end='2022-03-20 10:01' timezone='Europe/Paris' recurrence='every_day']\\n[/event]\"\n      ).reload\n\n      expect(post.event.timezone).to eq(\"Europe/Paris\")\n      expect(post.event.original_starts_at).to eq_time(expected_original_datetime)\n      expect(post.event.starts_at).to eq_time(expected_next_datetime)\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"rails_helper\"\n\nmodule DiscoursePostEvent\n  describe EventsController do\n    before do\n      Jobs.run_immediately!\n      SiteSetting.calendar_enabled = true\n      SiteSetting.discourse_post_event_enabled = true\n      SiteSetting.displayed_invitees_limit = 3\n    end\n\n    let(:user) { Fabricate(:user, admin: true) }\n    let(:topic) { Fabricate(:topic, user: user) }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:invitee1) { Fabricate(:user) }\n    let(:invitee2) { Fabricate(:user) }\n\n    context 'with an existing post' do\n      context 'with an existing event' do\n        let(:event_1) { Fabricate(:event, post: post1) }\n\n        before do\n          sign_in(user)\n        end\n\n        context 'when updating' do\n          context 'when doing csv bulk invite' do\n            let(:valid_file) {\n              file = Tempfile.new(\"valid.csv\")\n              file.write(\"bob,going\\n\")\n              file.write(\"sam,interested\\n\")\n              file.write(\"the_foo_bar_group,not_going\\n\")\n              file.rewind\n              file\n            }\n\n            let(:empty_file) {\n              file = Tempfile.new(\"invalid.pdf\")\n              file.rewind\n              file\n            }\n\n            context 'when current user can manage the event' do\n              context 'when no file is given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\"\n                  expect(response.parsed_body['error_type']).to eq('invalid_parameters')\n                end\n              end\n\n              context 'when an empty file is given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\", { params: { file: fixture_file_upload(empty_file) } }\n                  expect(response.status).to eq(422)\n                end\n              end\n\n              context 'when a valid file is given' do\n                before do\n                  Jobs.run_later!\n                end\n\n                it 'enqueues the job and returns 200' do\n                  expect_enqueued_with(job: :discourse_post_event_bulk_invite, args: {\n                    \"event_id\" => event_1.id,\n                    \"invitees\" => [\n                      { 'identifier' => 'bob', 'attendance' => 'going' },\n                      { 'identifier' => 'sam', 'attendance' => 'interested' },\n                      { 'identifier' => 'the_foo_bar_group', 'attendance' => 'not_going' }\n                    ],\n                    \"current_user_id\" => user.id\n                  }) do\n                    post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\", { params: { file: fixture_file_upload(valid_file) } }\n                  end\n\n                  expect(response.status).to eq(200)\n                end\n              end\n            end\n\n            context 'when current user can\u2019t manage the event' do\n              let(:lurker) { Fabricate(:user) }\n\n              before do\n                sign_in(lurker)\n              end\n\n              it 'returns an error' do\n                post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\"\n                expect(response.status).to eq(403)\n              end\n            end\n          end\n\n          context 'when doing bulk invite' do\n            context 'when current user can manage the event' do\n              context 'when no invitees are given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\"\n                  expect(response.parsed_body['error_type']).to eq('invalid_parameters')\n                end\n              end\n\n              context 'when empty invitees are given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\", { params: { invitees: [] } }\n                  expect(response.status).to eq(400)\n                end\n              end\n\n              context 'when valid invitees are given' do\n                before do\n                  Jobs.run_later!\n                end\n\n                it 'enqueues the job and returns 200' do\n                  expect_enqueued_with(job: :discourse_post_event_bulk_invite, args: {\n                    \"event_id\" => event_1.id,\n                    \"invitees\" => [\n                      { 'identifier' => 'bob', 'attendance' => 'going' },\n                      { 'identifier' => 'sam', 'attendance' => 'interested' },\n                      { 'identifier' => 'the_foo_bar_group', 'attendance' => 'not_going' }\n                    ],\n                    \"current_user_id\" => user.id\n                  }) do\n                    post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\", { params: { invitees: [\n                      { 'identifier' => 'bob', 'attendance' => 'going' },\n                      { 'identifier' => 'sam', 'attendance' => 'interested' },\n                      { 'identifier' => 'the_foo_bar_group', 'attendance' => 'not_going' }\n                    ] } }\n                  end\n\n                  expect(response.status).to eq(200)\n                end\n              end\n            end\n\n            context 'when current user can\u2019t manage the event' do\n              let(:lurker) { Fabricate(:user) }\n\n              before do\n                sign_in(lurker)\n              end\n\n              it 'returns an error' do\n                post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\"\n                expect(response.status).to eq(403)\n              end\n            end\n          end\n        end\n\n        context 'when acting user has created the event' do\n          it 'destroys a event' do\n            expect(event_1.persisted?).to be(true)\n\n            messages = MessageBus.track_publish do\n              delete \"/discourse-post-event/events/#{event_1.id}.json\"\n            end\n            expect(messages.count).to eq(1)\n            message = messages.first\n            expect(message.channel).to eq(\"/discourse-post-event/#{event_1.post.topic_id}\")\n            expect(message.data[:id]).to eq(event_1.id)\n            expect(response.status).to eq(200)\n            expect(Event).to_not exist(id: event_1.id)\n          end\n        end\n\n        context 'when acting user has not created the event' do\n          let(:lurker) { Fabricate(:user) }\n\n          before do\n            sign_in(lurker)\n          end\n\n          it 'doesn\u2019t destroy the event' do\n            expect(event_1.persisted?).to be(true)\n            delete \"/discourse-post-event/events/#{event_1.id}.json\"\n            expect(response.status).to eq(403)\n            expect(Event).to exist(id: event_1.id)\n          end\n        end\n\n        context 'when watching user is not logged' do\n          before do\n            sign_out\n          end\n\n          context 'when topic is public' do\n            it 'can see the event' do\n              get \"/discourse-post-event/events/#{event_1.id}.json\"\n\n              expect(response.status).to eq(200)\n            end\n          end\n\n          context 'when topic is not public' do\n            before do\n              event_1.post.topic.convert_to_private_message(Discourse.system_user)\n            end\n\n            it 'can\u2019t see the event' do\n              get \"/discourse-post-event/events/#{event_1.id}.json\"\n\n              expect(response.status).to eq(404)\n            end\n          end\n        end\n\n        context 'when filtering by category' do\n          it 'can filter the event by category' do\n            category = Fabricate(:category)\n            topic = Fabricate(:topic, category: category)\n            event_2 = Fabricate(:event, post: Fabricate(:post, post_number: 1, topic: topic))\n\n            get \"/discourse-post-event/events.json?category_id=#{category.id}\"\n\n            expect(response.status).to eq(200)\n            events = response.parsed_body[\"events\"]\n            expect(events.length).to eq(1)\n            expect(events[0][\"id\"]).to eq(event_2.id)\n          end\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["en:\n  reports:\n    currently_away:\n      title: Users currently away\n      labels:\n        username: Username\n\n  discourse_automation:\n    triggerables:\n      event_started:\n        title: Event started\n  system_messages:\n    discourse_calendar_holiday_region_invalid: \"The holiday region you provided does not exist.\"\n    discourse_calendar_enable_holiday_failed: \"This holiday could not be enabled, it's already enabled or it's not disabled.\"\n    discourse_post_event_bulk_invite_succeeded:\n      title: \"Event - Bulk Invite Succeeded\"\n      subject_template: \"Bulk invite processed successfully\"\n      text_body_template: \"Your bulk invite file was processed, %{processed} invitee(s) created.\"\n    discourse_post_event_bulk_invite_failed:\n      title: \"Event - Bulk Invite Failed\"\n      subject_template: \"Bulk invite processed with errors\"\n      text_body_template: |\n        Your bulk invite file was processed, %{processed} invitee(s) created with %{failed} error(s).\n\n        Here's the log:\n\n        ```text\n        %{logs}\n        ```\n\n  site_settings:\n    calendar_enabled: \"Enable the discourse-calendar plugin. This will add support for a [calendar][/calendar] tag in the first post of a topic.\"\n    discourse_post_event_enabled: \"[experimental] Enables to attach an event to a post. Note: also needs `calendar enabled` to be enabled.\"\n    displayed_invitees_limit: \"Limits the numbers of invitees displayed on an event.\"\n    display_post_event_date_on_topic_title: \"Displays the date of the event after the topic title.\"\n    use_local_event_date: \"Use local date after topic title instead of relative time.\"\n    discourse_post_event_allowed_on_groups: \"Groups that are allowed to create events.\"\n    discourse_post_event_allowed_custom_fields: \"Allows to let each event to set the value of custom fields.\"\n    discourse_post_event_edit_notifications_time_extension: \"Extends (in minutes) the period after the end of an event when `going` invitees are still being notified from edit in the original post.\"\n    holiday_calendar_topic_id: \"Topic ID of staffs holiday / absence calendar.\"\n    delete_expired_event_posts_after: \"Posts with expired events will be automatically deleted after (n) hours. Set to -1 to disable deletion.\"\n    all_day_event_start_time: \"Events that do not have a start time specified will start at this time. Format is HH:mm. For 6:00 am, enter 06:00\"\n    all_day_event_end_time: \"Events that do not have a end time specified will end at this time. Format is HH:mm. For 6:00 pm, enter 18:00\"\n    all_day_event_time_error: \"Invalid time. Format needs to be HH:mm (ex: 08:00).\"\n    calendar_categories: \"Display a calendar at the top of a category. Mandatory settings are categoryId and postId. eg: categoryId=6;postId=453\\n Other valid settings: tzPicker, weekends and defaultView.\"\n    calendar_categories_outlet: \"Allows to change which outlet should show the category calendar.\"\n    working_days: \"Set working days. You can display the availability of a group using the `timezones` tag in a post, eg: `[timezones group=admins][timezones]`\"\n    working_day_start_hour: \"Start time of the working day hours.\"\n    working_day_end_hour: \"End time of the working day hours.\"\n    close_to_working_day_hours_extension: \"Set extension time in working day hours to highlight the timezones.\"\n    events_calendar_categories: \"Display an events calendar at the top of a category.\"\n    sort_categories_by_event_start_date_enabled: \"Enable the sorting of category topics by event start date.\"\n    disable_resorting_on_categories_enabled: \"Allow categories to disable the ability for users to sort on the event category.\"\n  discourse_calendar:\n    invite_user_notification: \"%{username} invited you to: %{description}\"\n    calendar_must_be_in_first_post: \"Calendar tag can only be used in first post of a topic.\"\n    more_than_one_calendar: \"You can\u2019t have more than one calendar in a post.\"\n    more_than_two_dates: \"A post of a calendar topic can\u2019t contain more than two dates.\"\n    event_expired: \"Event expired\"\n    holiday_status:\n      description: \"On holiday\"\n  discourse_post_event:\n    notifications:\n      before_event_reminder: \"%{title} is about to start.\"\n      after_event_reminder: \"%{title} has ended.\"\n      ongoing_event_reminder: \"%{title} is ongoing.\"\n    errors:\n      bulk_invite:\n        max_invitees: \"First %{max_invittes} invitees have been created. Try splitting the file in smaller parts.\"\n        error: \"There was an error uploading that file. Please try again later.\"\n      models:\n        event:\n          only_one_event: \"A post can only have one event.\"\n          only_group: \"An event accepts only group names.\"\n          must_be_in_first_post: \"An event can only be in the first post of a topic.\"\n          raw_invitees_length: \"An event is limited to %{count} users/groups.\"\n          ends_at_before_starts_at: \"An event can't end before it starts.\"\n          start_must_be_present_and_a_valid_date: \"An event requires a valid start date.\"\n          end_must_be_a_valid_date: \"End date must be a valid date.\"\n          invalid_recurrence: \"Recurrence must be one of: every_month, every_week, every_two_weeks, every_day, every_weekday.\"\n          invalid_timezone: \"Timezone not recognized.\"\n          acting_user_not_allowed_to_create_event: \"Current user is not allowed to create events.\"\n          acting_user_not_allowed_to_act_on_this_event: \"Current user is not allowed to act on this event.\"\n          invalid_allowed_groups: \"Invalid allowed groups.\"\n          acting_user_not_allowed_to_invite_these_groups: \"Current user is not allowed to invite these groups.\"\n          custom_field_is_invalid: \"The custom field `%{field}` is not allowed.\"\n          name:\n            length: \"Event name length must be between %{minimum} and %{maximum} characters.\"\n", "# frozen_string_literal: true\n\nmodule Jobs\n  class DiscoursePostEventBulkInvite < ::Jobs::Base\n    sidekiq_options retry: false\n\n    def initialize\n      super\n\n      @logs = []\n      @processed = 0\n      @failed = 0\n    end\n\n    def execute(args)\n      invitees = args[:invitees]\n      raise Discourse::InvalidParameters.new(:invitees) if invitees.blank?\n\n      @current_user = User.find_by(id: args[:current_user_id])\n      raise Discourse::InvalidParameters.new(:current_user_id) unless @current_user\n\n      @event = DiscoursePostEvent::Event.find_by(id: args[:event_id])\n      raise Discourse::InvalidParameters.new(:event_id) unless @event\n\n      @guardian = Guardian.new(@current_user)\n      @guardian.ensure_can_edit!(@event.post)\n\n      process_invitees(invitees)\n    ensure\n      notify_user\n    end\n\n    private\n\n    def process_invitees(invitees)\n      invitees = filter_out_unavailable_groups(invitees)\n\n      max_bulk_invitees = SiteSetting.discourse_post_event_max_bulk_invitees\n\n      invitees.each do |invitee|\n        break if @processed >= max_bulk_invitees\n        process_invitee(invitee)\n      end\n\n      if @processed > 0\n        @event.publish_update!\n        @event.notify_invitees!(predefined_attendance: true)\n      end\n    rescue Exception => e\n      save_log \"Bulk Invite Process Failed -- '#{e.message}'\"\n      @failed += 1\n    end\n\n    def process_invitee(invitee)\n      if @event.public?\n        users = User.where(username: invitee['identifier']).pluck(:id)\n      else\n        group = Group.find_by(name: invitee['identifier'])\n        if group\n          users = group.users.pluck(:id)\n          @event.update_with_params!(raw_invitees: (@event.raw_invitees || []).push(group.name).uniq)\n        end\n      end\n\n      if users.blank?\n        save_log \"Couldn't find user or group: '#{invitee['identifier']}' or the groups provided contained no users. Note that public events can't bulk invite groups. And other events can't bulk invite usernames.\"\n        @failed += 1\n        return\n      end\n\n      users.each do |user_id|\n        create_attendance(user_id, @event.post.id, invitee['attendance'] || 'going')\n      end\n\n      @processed += 1\n    rescue Exception => e\n      save_log \"Bulk Invite Process Failed -- '#{e.message}'\"\n      @failed += 1\n    end\n\n    def create_attendance(user_id, post_id, attendance)\n      unknown = DiscoursePostEvent::Invitee::UNKNOWN_ATTENDANCE\n\n      if attendance == unknown\n        DiscoursePostEvent::Invitee.where(user_id: user_id, post_id: post_id).destroy_all\n      else\n        status = DiscoursePostEvent::Invitee.statuses[attendance.to_sym]\n        invitee = DiscoursePostEvent::Invitee.find_or_initialize_by(user_id: user_id, post_id: post_id)\n        invitee.notified = false\n        invitee.status = status\n        invitee.save!\n      end\n    end\n\n    def save_log(message)\n      @logs << \"[#{Time.zone.now}] #{message}\"\n    end\n\n    def notify_user\n      if @current_user\n        if @processed > 0 && @failed == 0\n          SystemMessage.create_from_system_user(\n            @current_user,\n            :discourse_post_event_bulk_invite_succeeded,\n            processed: @processed\n          )\n        else\n          SystemMessage.create_from_system_user(\n            @current_user,\n            :discourse_post_event_bulk_invite_failed,\n            processed: @processed,\n            failed: @failed,\n            logs: @logs.join(\"\\n\")\n          )\n        end\n      end\n    end\n\n    def invitee_groups(invitees)\n      Group.where(name: invitees.map { |i| i[:identifier] })\n    end\n\n    def filter_out_unavailable_groups(invitees)\n      groups = invitee_groups(invitees)\n      invitees.filter do |i|\n        group = groups.find { |g| g.name === i[:identifier] }\n\n        !group || (@guardian.can_see_group?(group) && @guardian.can_see_group_members?(group))\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule DiscoursePostEvent\n  class EventValidator\n    VALID_RECURRENCES = %w[\n      every_month\n      every_week\n      every_two_weeks\n      every_day\n      every_weekday\n    ]\n\n    def initialize(post)\n      @post = post\n    end\n\n    def validate_event\n      extracted_events = DiscoursePostEvent::EventParser::extract_events(@post)\n\n      if extracted_events.count == 0\n        return false\n      end\n\n      if extracted_events.count > 1\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.only_one_event\"))\n        return false\n      end\n\n      if !@post.is_first_post?\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.must_be_in_first_post\"))\n        return false\n      end\n\n      extracted_event = extracted_events.first\n\n      return false unless can_invite_groups?(extracted_event)\n\n      if @post.acting_user && @post.event\n        if !@post.acting_user.can_act_on_discourse_post_event?(@post.event)\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.acting_user_not_allowed_to_act_on_this_event\"))\n          return false\n        end\n      else\n        if !@post.acting_user || !@post.acting_user.can_create_discourse_post_event?\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.acting_user_not_allowed_to_create_event\"))\n          return false\n        end\n      end\n\n      if extracted_event[:start].blank? || (DateTime.parse(extracted_event[:start]) rescue nil).nil?\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.start_must_be_present_and_a_valid_date\"))\n        return false\n      end\n\n      if extracted_event[:end].present? && (DateTime.parse(extracted_event[:end]) rescue nil).nil?\n        @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.end_must_be_a_valid_date\"))\n        return false\n      end\n\n      if extracted_event[:start].present? && extracted_event[:end].present?\n        if Time.parse(extracted_event[:start]) > Time.parse(extracted_event[:end])\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.ends_at_before_starts_at\"))\n          return false\n        end\n      end\n\n      if extracted_event[:name].present?\n        if !(Event::MIN_NAME_LENGTH..Event::MAX_NAME_LENGTH).cover?(extracted_event[:name].length)\n          @post.errors.add(:base, I18n.t('discourse_post_event.errors.models.event.name.length', minimum: Event::MIN_NAME_LENGTH, maximum: Event::MAX_NAME_LENGTH))\n          return false\n        end\n      end\n\n      if extracted_event[:recurrence].present?\n        if !VALID_RECURRENCES.include?(extracted_event[:recurrence].to_s)\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.invalid_recurrence\"))\n        end\n      end\n\n      if extracted_event[:timezone].present?\n        if !ActiveSupport::TimeZone[extracted_event[:timezone]].present?\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.invalid_timezone\", timezone: extracted_event[:timezone]))\n        end\n      end\n\n      true\n    end\n\n    private\n\n    def can_invite_groups?(event)\n      guardian = Guardian.new(@post.acting_user)\n      return true unless event[:\"allowed-groups\"]\n\n      event[:\"allowed-groups\"].split(',').each do |group_name|\n        group = Group.find_by(name: group_name)\n\n        if !group || !guardian.can_see_group?(group)\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.invalid_allowed_groups\"))\n          return false\n        end\n\n        if !guardian.can_see_group_members?(group)\n          @post.errors.add(:base, I18n.t(\"discourse_post_event.errors.models.event.acting_user_not_allowed_to_invite_these_groups\"))\n          return false\n        end\n      end\n\n      true\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'securerandom'\n\ndescribe Post do\n  Event ||= DiscoursePostEvent::Event\n  Invitee ||= DiscoursePostEvent::Invitee\n\n  before do\n    freeze_time\n    Jobs.run_immediately!\n    SiteSetting.calendar_enabled = true\n    SiteSetting.discourse_post_event_enabled = true\n  end\n\n  let(:user) { Fabricate(:user, admin: true) }\n\n  context 'with a public event' do\n    let(:post_1) { Fabricate(:post) }\n    let(:event_1) { Fabricate(:event, post: post_1, raw_invitees: ['trust_level_0']) }\n\n    context 'when a post is updated' do\n      context 'when the post has a valid event' do\n        context 'when the event markup is removed' do\n          it 'destroys the associated event' do\n            start = Time.now.utc.iso8601(3)\n\n            post = create_post_with_event(user)\n\n            expect(post.reload.event.persisted?).to eq(true)\n\n            revisor = PostRevisor.new(post, post.topic)\n            revisor.revise!(\n              user,\n              raw: 'The event is over. Come back another day.'\n            )\n\n            expect(post.reload.event).to be(nil)\n          end\n        end\n\n        context 'when event is on going' do\n          let(:going_user) { Fabricate(:user) }\n          let(:interested_user) { Fabricate(:user) }\n\n          before do\n            SiteSetting.editing_grace_period = 1.minute\n            PostActionNotifier.enable\n            SiteSetting.discourse_post_event_edit_notifications_time_extension =\n              180\n          end\n\n          context 'when in edit grace period' do\n            before do\n              event_1.event_dates.first.update_columns(\n                starts_at: 3.hours.ago, ends_at: 2.hours.ago\n              )\n\n              # clean state\n              Notification.destroy_all\n              interested_user.reload\n              going_user.reload\n            end\n\n            it 'sends a post revision to going invitees' do\n              Invitee.create_attendance!(going_user.id, post_1.id, :going)\n              Invitee.create_attendance!(\n                interested_user.id,\n                post_1.id,\n                :interested\n              )\n\n              expect {\n                revisor = PostRevisor.new(post_1)\n                revisor.revise!(\n                  user,\n                  { raw: post_1.raw + \"\\nWe are bout half way into our event!\" },\n                  revised_at: Time.now + 2.minutes\n                )\n              }.to change {\n                going_user.notifications.count\n              }.by(1)\n\n              expect(interested_user.notifications.count).to eq(0)\n            end\n          end\n\n          context 'when not edit grace period' do\n            before do\n              event_1.event_dates.first.update_columns(starts_at: 5.hours.ago)\n            end\n\n            it 'doesn\u2019t send a post revision to anyone' do\n              Invitee.create_attendance!(going_user.id, post_1.id, :going)\n              Invitee.create_attendance!(\n                interested_user.id,\n                event_1.id,\n                :interested\n              )\n\n              expect {\n                revisor = PostRevisor.new(event_1.post)\n                revisor.revise!(\n                  user,\n                  { raw: event_1.post.raw + \"\\nWe are bout half way into our event!\" },\n                  revised_at: Time.now + 2.minutes\n                )\n              }.to change {\n                going_user.notifications.count + interested_user.notifications.count\n              }.by(0)\n            end\n          end\n\n          context 'with an event with recurrence' do\n            before do\n              freeze_time Time.utc(2020, 8, 12, 16, 32)\n\n              event_1.update_with_params!(\n                recurrence: 'FREQ=WEEKLY;BYDAY=MO',\n                original_starts_at: 3.hours.ago,\n                original_ends_at: nil\n              )\n\n              Invitee.create_attendance!(going_user.id, event_1.id, :going)\n              Invitee.create_attendance!(\n                interested_user.id,\n                event_1.id,\n                :interested\n              )\n\n              event_1.reload\n\n              # we stop processing jobs immediately at this point to prevent infinite loop\n              # as future event ended job would finish now, trigger next recurrence, and anodther job...\n              Jobs.run_later!\n            end\n\n            context 'when the event ends' do\n              it 'sets the next dates' do\n                event_1.update_with_params!(original_ends_at: Time.now)\n\n                expect(event_1.starts_at.to_s).to eq('2020-08-19 13:32:00 UTC')\n                expect(event_1.ends_at.to_s).to eq('2020-08-19 16:32:00 UTC')\n              end\n\n              it 'it removes status from every invitees' do\n                expect(event_1.invitees.pluck(:status)).to match_array(\n                  [Invitee.statuses[:going], Invitee.statuses[:interested]]\n                )\n\n                event_1.update_with_params!(original_ends_at: Time.now)\n                expect(event_1.invitees.pluck(:status).compact).to eq([])\n              end\n\n              # that will be handled by new job, uncomment when finishedh\n              it 'resends event creation notification to invitees' do\n                expect { event_1.update_with_params!(original_ends_at: Time.now) }.to change {\n                  going_user.notifications.count\n                }.by(1)\n              end\n            end\n          end\n\n          context 'when updating raw_invitees' do\n            let(:lurker_1) { Fabricate(:user) }\n            let(:group_1) { Fabricate(:group) }\n\n            it 'doesn\u2019t accept usernames' do\n              event_1.update_with_params!(raw_invitees: [lurker_1.username])\n              expect(event_1.raw_invitees).to eq(['trust_level_0'])\n            end\n\n            it 'doesn\u2019t accept another group than trust_level_0' do\n              event_1.update_with_params!(raw_invitees: [group_1.name])\n              expect(event_1.raw_invitees).to eq(['trust_level_0'])\n            end\n          end\n\n          context 'when updating status to private' do\n            it 'it changes the status and force invitees' do\n              expect(event_1.raw_invitees).to eq(['trust_level_0'])\n              expect(event_1.status).to eq(Event.statuses[:public])\n\n              event_1.update_with_params!(status: Event.statuses[:private])\n\n              expect(event_1.raw_invitees).to eq([])\n              expect(event_1.status).to eq(Event.statuses[:private])\n            end\n          end\n        end\n      end\n    end\n\n    context 'when a post is created' do\n      context 'when the post contains one valid event' do\n        context 'when the acting user is admin' do\n          it 'creates the post event' do\n            start = Time.now.utc.iso8601(3)\n\n            post =\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party',\n                raw: \"[event start=\\\"#{start}\\\"]\\n[/event]\"\n              )\n\n            expect(post.reload.persisted?).to eq(true)\n            expect(post.event.persisted?).to eq(true)\n            expect(post.event.original_starts_at).to eq_time(Time.parse(start))\n          end\n\n          it 'works with name attribute' do\n            post = create_post_with_event(user, 'name=\"foo bar\"').reload\n            expect(post.event.name).to eq('foo bar')\n\n            post = create_post_with_event(user, 'name=\"\"').reload\n            expect(post.event.name).to be_blank\n\n            post = create_post_with_event(user, 'name=').reload\n            expect(post.event.name).to be_blank\n          end\n\n          it 'works with url attribute' do\n            url = 'https://www.discourse.org'\n\n            post = create_post_with_event(user, \"url=\\\"#{url}\\\"\").reload\n            expect(post.event.url).to eq(url)\n\n            post = create_post_with_event(user, 'url=\"\"').reload\n            expect(post.event.url).to be_blank\n\n            post = create_post_with_event(user, 'url=').reload\n            expect(post.event.url).to be_blank\n          end\n\n          it 'works with status attribute' do\n            post = create_post_with_event(user, 'status=\"private\"').reload\n            expect(post.event.status).to eq(\n              DiscoursePostEvent::Event.statuses[:private]\n            )\n\n            post = create_post_with_event(user, 'status=\"\"').reload\n            expect(post.event.status).to eq(\n              DiscoursePostEvent::Event.statuses[:standalone]\n            )\n\n            post = create_post_with_event(user, 'status=').reload\n            expect(post.event.status).to eq(\n              DiscoursePostEvent::Event.statuses[:standalone]\n            )\n          end\n\n          it 'works with allowedGroups attribute' do\n            Fabricate(:group, name: \"euro\")\n            Fabricate(:group, name: \"america\")\n\n            post = create_post_with_event(user, 'allowedGroups=\"euro\"').reload\n            expect(post.event.raw_invitees).to eq([])\n\n            post =\n              create_post_with_event(user, 'status=\"public\" allowedGroups=\"euro\"')\n                .reload\n            expect(post.event.raw_invitees).to eq(%w[trust_level_0])\n\n            post =\n              create_post_with_event(\n                user,\n                'status=\"standalone\" allowedGroups=\"euro\"'\n              ).reload\n            expect(post.event.raw_invitees).to eq([])\n\n            post =\n              create_post_with_event(\n                user,\n                'status=\"private\" allowedGroups=\"euro\"'\n              ).reload\n            expect(post.event.raw_invitees).to eq(%w[euro])\n\n            post =\n              create_post_with_event(\n                user,\n                'status=\"private\" allowedGroups=\"euro,america\"'\n              ).reload\n            expect(post.event.raw_invitees).to match_array(%w[euro america])\n\n            post =\n              create_post_with_event(user, 'status=\"private\" allowedGroups=\"\"')\n                .reload\n            expect(post.event.raw_invitees).to eq([])\n\n            post =\n              create_post_with_event(user, 'status=\"private\" allowedGroups=')\n                .reload\n            expect(post.event.raw_invitees).to eq([])\n          end\n\n          it 'works with reminders attribute' do\n            post = create_post_with_event(user).reload\n            expect(post.event.reminders).to eq(nil)\n\n            post =\n              create_post_with_event(user, 'reminders=\"1.hours,-3.days\"').reload\n            expect(post.event.reminders).to eq('1.hours,-3.days')\n          end\n\n          context 'with custom fields' do\n            before do\n              SiteSetting.discourse_post_event_allowed_custom_fields = 'foo-bar|bar'\n            end\n\n            it 'works with allowed custom fields' do\n              post = create_post_with_event(user, 'fooBar=\"1\"').reload\n              expect(post.event.custom_fields['foo-bar']).to eq('1')\n\n              post = create_post_with_event(user, 'bar=\"2\"').reload\n              expect(post.event.custom_fields['bar']).to eq('2')\n            end\n\n            it 'doesn\u2019t work with not allowed custom fields' do\n              post = create_post_with_event(user, 'baz=\"3\"').reload\n              expect(post.event.custom_fields['baz']).to eq(nil)\n            end\n          end\n        end\n\n        context 'when the acting user has rights to create events' do\n          let(:user_with_rights) { Fabricate(:user) }\n          let(:group) { Fabricate(:group, users: [user_with_rights]) }\n\n          before do\n            SiteSetting.discourse_post_event_allowed_on_groups = group.id.to_s\n          end\n\n          it 'creates the post event' do\n            start = Time.now.utc.iso8601(3)\n\n            post =\n              PostCreator.create!(\n                user_with_rights,\n                title: 'Sell a boat party',\n                raw: \"[event start=\\\"#{start}\\\"]\\n[/event]\"\n              )\n\n            expect(post.reload.persisted?).to eq(true)\n            expect(post.event.persisted?).to eq(true)\n            expect(post.event.original_starts_at).to eq_time(Time.parse(start))\n          end\n        end\n\n        context 'when the acting user doesn\u2019t have rights to create events' do\n          let(:user_without_rights) { Fabricate(:user) }\n          let(:group) { Fabricate(:group, users: [user]) }\n\n          before do\n            SiteSetting.discourse_post_event_allowed_on_groups = group.id.to_s\n          end\n\n          it 'raises an error' do\n            start = Time.now.utc.iso8601(3)\n\n            expect do\n              PostCreator.create!(\n                user_without_rights,\n                title: 'Sell a boat party',\n                raw: \"[event start=\\\"#{start}\\\"]\\n[/event]\"\n              )\n            end.to(\n              raise_error(ActiveRecord::RecordNotSaved).with_message(\n                I18n.t(\n                  'discourse_post_event.errors.models.event.acting_user_not_allowed_to_create_event'\n                )\n              )\n            )\n          end\n        end\n      end\n\n      context 'when the post contains one invalid event' do\n        context 'when start is invalid' do\n          it 'raises an error' do\n            expect do\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party', raw: \"[event start=\\\"x\\\"]\\n[/event]\"\n              )\n            end.to(\n              raise_error(ActiveRecord::RecordNotSaved).with_message(\n                I18n.t(\n                  'discourse_post_event.errors.models.event.start_must_be_present_and_a_valid_date'\n                )\n              )\n            )\n          end\n        end\n\n        context 'when recurrence is invalid' do\n          it 'raises an error' do\n            expect {\n              create_post_with_event(user, 'recurrence=\"foo\"')\n            }.to raise_error(I18n.t(\"discourse_post_event.errors.models.event.invalid_recurrence\"))\n          end\n        end\n\n        context 'when start is not provided or' do\n          it 'is not cooked' do\n            post =\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party',\n                raw: <<~TXT\n                [event end=\\\"1\\\"]\n                [/event]\n              TXT\n              )\n\n            expect(!post.cooked.include?('discourse-post-event')).to be(true)\n          end\n        end\n\n        context 'when end is provided and is invalid' do\n          it 'raises an error' do\n            expect do\n              PostCreator.create!(\n                user,\n                title: 'Sell a boat party',\n                raw:\n                  \"[event start=\\\"#{\n                    Time.now.utc.iso8601(3)\n                  }\\\" end=\\\"d\\\"]\\n[/event]\"\n              )\n            end.to(\n              raise_error(ActiveRecord::RecordNotSaved).with_message(\n                I18n.t(\n                  'discourse_post_event.errors.models.event.end_must_be_a_valid_date'\n                )\n              )\n            )\n          end\n        end\n      end\n\n      context 'when the post contains multiple events' do\n        it 'raises an error' do\n          expect do\n            PostCreator.create!(\n              user,\n              title: 'Sell a boat party',\n              raw: <<~TXT\n                [event start=\\\"#{Time.now.utc.iso8601(3)}\\\"]\n                [/event]\n\n                [event start=\\\"#{Time.now.utc.iso8601(3)}\\\"]\n                [/event]\n              TXT\n            )\n          end.to(\n            raise_error(ActiveRecord::RecordNotSaved).with_message(\n              I18n.t('discourse_post_event.errors.models.event.only_one_event')\n            )\n          )\n        end\n      end\n    end\n\n    context 'when a post with an event is destroyed' do\n      it 'sets deleted_at on the post_event' do\n        expect(event_1.deleted_at).to be_nil\n\n        PostDestroyer.new(user, event_1.post).destroy\n        event_1.reload\n\n        expect(event_1.deleted_at).to eq_time(Time.now)\n      end\n    end\n\n    context 'when a post with an event is recovered' do\n      it 'nullifies deleted_at on the post_event' do\n        PostDestroyer.new(user, event_1.post).destroy\n\n        expect(event_1.reload.deleted_at).to eq_time(Time.now)\n\n        PostDestroyer.new(user, Post.with_deleted.find(event_1.id)).recover\n\n        expect(event_1.reload.deleted_at).to be_nil\n      end\n    end\n  end\n\n  context 'with a private event' do\n    before do\n      freeze_time Time.utc(2020, 8, 12, 16, 32)\n    end\n\n    let(:invitee_1) { Fabricate(:user) }\n    let(:invitee_2) { Fabricate(:user) }\n    let(:group_1) {\n      Fabricate(:group).tap do |g|\n        g.add(invitee_1)\n        g.add(invitee_2)\n        g.save!\n      end\n    }\n    let(:post_1) { Fabricate(:post) }\n    let(:event_1) {\n      Fabricate(\n        :event,\n        post: post_1,\n        status: Event.statuses[:private],\n        raw_invitees: [group_1.name],\n        original_starts_at: 3.hours.ago,\n        original_ends_at: nil\n      )\n    }\n\n    context 'with an event with recurrence' do\n      let(:event_1) {\n        Fabricate(\n          :event,\n          post: post_1,\n          status: Event.statuses[:private],\n          raw_invitees: [group_1.name],\n          recurrence: 'FREQ=WEEKLY;BYDAY=MO',\n          original_starts_at: 3.hours.ago,\n          original_ends_at: nil\n        )\n      }\n\n      before do\n        Invitee.create_attendance!(invitee_1.id, event_1.id, :going)\n\n        # we stop processing jobs immediately at this point to prevent infinite loop\n        # as future event ended job would finish now, trigger next recurrence, and anodther job...\n        Jobs.run_later!\n      end\n\n      context 'when updating the end' do\n        it 'resends event creation notification to invitees and possible invitees' do\n          expect(event_1.invitees.count).to eq(1)\n\n          expect { event_1.update_with_params!(original_ends_at: 2.hours.ago) }.to change {\n            invitee_1.notifications.count + invitee_2.notifications.count\n          }.by(2)\n        end\n      end\n    end\n\n    context 'when updating raw_invitees' do\n      let(:lurker_1) { Fabricate(:user) }\n      let(:group_2) { Fabricate(:group) }\n\n      it 'doesn\u2019t accept usernames' do\n        expect {\n          event_1.update_with_params!(raw_invitees: [lurker_1.username])\n        }.to raise_error(ActiveRecord::RecordInvalid)\n      end\n\n      it 'accepts another group than trust_level_0' do\n        event_1.update_with_params!(raw_invitees: [group_2.name])\n        expect(event_1.raw_invitees).to eq([group_2.name])\n      end\n    end\n\n    context 'when updating status to public' do\n      it 'it changes the status and force invitees' do\n        expect(event_1.raw_invitees).to eq([group_1.name])\n        expect(event_1.status).to eq(Event.statuses[:private])\n\n        event_1.update_with_params!(status: Event.statuses[:public])\n\n        expect(event_1.raw_invitees).to eq(['trust_level_0'])\n        expect(event_1.status).to eq(Event.statuses[:public])\n      end\n    end\n\n    it \"rejects private groups in allowedGroups\" do\n      moderator = Fabricate(:user, moderator: true)\n      private_group = Fabricate(\n        :group,\n        visibility_level: Group.visibility_levels[:owners])\n\n      expect {\n        create_post_with_event(moderator, \"allowedGroups='#{private_group.name}'\")\n      }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n\n    it \"rejects non-existent groups in allowedGroups\" do\n      moderator = Fabricate(:user, moderator: true)\n\n      expect {\n        create_post_with_event(moderator, \"allowedGroups='non-existent_group_name'\")\n      }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n\n    it \"rejects public groups with private members in allowedGroups\" do\n      moderator = Fabricate(:user, moderator: true)\n      public_group_with_private_members = Fabricate(\n        :group,\n        visibility_level: Group.visibility_levels[:public],\n        members_visibility_level: Group.visibility_levels[:owners])\n\n      expect {\n        create_post_with_event(moderator, \"allowedGroups='#{public_group_with_private_members.name}'\")\n      }.to raise_error(ActiveRecord::RecordNotSaved)\n    end\n  end\n\n  context \"with holiday events\" do\n    let(:calendar_post) { create_post(raw: \"[calendar]\\n[/calendar]\") }\n\n    before do\n      SiteSetting.holiday_calendar_topic_id = calendar_post.topic_id\n    end\n\n    context \"when deleting a post with an event\" do\n      it \"clears user status that was previously set by the calendar plugin\" do\n        SiteSetting.enable_user_status = true\n        raw = 'Vacation [date=\"2018-06-05\" time=\"10:20:00\"] to [date=\"2018-06-06\" time=\"10:20:00\"]'\n        post = create_post(raw: raw, topic: calendar_post.topic)\n        freeze_time Time.utc(2018, 6, 5, 10, 30)\n        DiscourseCalendar::UpdateHolidayUsernames.new.execute(nil)\n\n        # the job has set the holiday status:\n        status = post.user.user_status\n        expect(status).to be_present\n        expect(status.description).to eq(I18n.t(\"discourse_calendar.holiday_status.description\"))\n        expect(status.emoji).to eq(DiscourseCalendar::HolidayStatus::EMOJI)\n        expect(status.ends_at).to eq_time(Time.utc(2018, 6, 6, 10, 20))\n\n        # after destroying the post the holiday status disappears:\n        PostDestroyer.new(user, post).destroy\n        post.user.reload\n\n        expect(post.user.user_status).to be_nil\n      end\n\n      it \"doesn't clear user status that wasn't set by the calendar plugin\" do\n        SiteSetting.enable_user_status = true\n        raw = 'Vacation [date=\"2018-06-05\" time=\"10:20:00\"] to [date=\"2018-06-06\" time=\"10:20:00\"]'\n        post = create_post(raw: raw, topic: calendar_post.topic)\n        freeze_time Time.utc(2018, 6, 5, 10, 30)\n        DiscourseCalendar::UpdateHolidayUsernames.new.execute(nil)\n\n        # the job has set the holiday status:\n        status = post.user.user_status\n        expect(status).to be_present\n        expect(status.description).to eq(I18n.t(\"discourse_calendar.holiday_status.description\"))\n        expect(status.emoji).to eq(DiscourseCalendar::HolidayStatus::EMOJI)\n        expect(status.ends_at).to eq_time(Time.utc(2018, 6, 6, 10, 20))\n\n        # user set their own status\n        custom_status = {\n          description: \"I am working on holiday\",\n          emoji: \"construction_worker_man\"\n        }\n        post.user.set_status!(custom_status[:description], custom_status[:emoji])\n\n        # the status that was set by user doesn't disappear after destroying the post:\n        PostDestroyer.new(user, post).destroy\n        post.user.reload\n\n        status = post.user.user_status\n        expect(status).to be_present\n        expect(status.description).to eq(custom_status[:description])\n        expect(status.emoji).to eq(custom_status[:emoji])\n      end\n    end\n  end\n\n  describe \"timezone handling\" do\n    before do\n      freeze_time Time.utc(2022, 7, 24, 13, 00)\n    end\n\n    it \"stores the correct information in the database\" do\n      expected_datetime = ActiveSupport::TimeZone[\"Australia/Sydney\"].parse(\"2022-07-24 14:01\")\n\n      post = PostCreator.create!(\n        user,\n        title: 'Beach party',\n        raw: \"[event start='2022-07-24 14:01' timezone='Australia/Sydney']\\n[/event]\"\n      ).reload\n\n      expect(post.event.timezone).to eq(\"Australia/Sydney\")\n      expect(post.event.original_starts_at).to eq_time(expected_datetime)\n      expect(post.event.starts_at).to eq_time(expected_datetime)\n      expect(post.event.event_dates.first.starts_at).to eq_time(expected_datetime)\n    end\n\n    it \"raises an error for invalid timezone\" do\n      expect {\n        PostCreator.create!(\n          user,\n          title: 'Beach party',\n          raw: \"[event start='2022-07-24 14:01' timezone='Westeros/Winterfell']\\n[/event]\"\n        )\n      }.to raise_error(I18n.t(\"discourse_post_event.errors.models.event.invalid_timezone\"))\n    end\n\n    it \"handles simple weekly recurrence correctly\" do\n      # Friday in Aus, Thursday in UTC\n      expected_original_datetime = ActiveSupport::TimeZone[\"Australia/Sydney\"].parse(\"2022-07-01 09:01\")\n      expected_next_datetime = ActiveSupport::TimeZone[\"Australia/Sydney\"].parse(\"2022-07-29 09:01\")\n\n      post = PostCreator.create!(\n        user,\n        title: 'Friday beach party',\n        raw: \"[event start='2022-07-01 09:01' end='2022-07-01 10:01' timezone='Australia/Sydney' recurrence='every_week']\\n[/event]\"\n      ).reload\n\n      expect(post.event.timezone).to eq(\"Australia/Sydney\")\n      expect(post.event.original_starts_at).to eq_time(expected_original_datetime)\n      expect(post.event.starts_at).to eq_time(expected_next_datetime)\n    end\n\n    it \"handles recurrence across daylight saving\" do\n      # DST starts on 27th March. Original datetime is before that. Expecting\n      # local time to be correct after the DST change\n      expected_original_datetime = ActiveSupport::TimeZone[\"Europe/Paris\"].parse(\"2022-03-20 09:01\")\n      expected_next_datetime = ActiveSupport::TimeZone[\"Europe/Paris\"].parse(\"2022-07-25 09:01\")\n\n      post = PostCreator.create!(\n        user,\n        title: 'Friday beach party',\n        raw: \"[event start='2022-03-20 09:01' end='2022-03-20 10:01' timezone='Europe/Paris' recurrence='every_day']\\n[/event]\"\n      ).reload\n\n      expect(post.event.timezone).to eq(\"Europe/Paris\")\n      expect(post.event.original_starts_at).to eq_time(expected_original_datetime)\n      expect(post.event.starts_at).to eq_time(expected_next_datetime)\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"rails_helper\"\n\nmodule DiscoursePostEvent\n  describe EventsController do\n    before do\n      Jobs.run_immediately!\n      SiteSetting.calendar_enabled = true\n      SiteSetting.discourse_post_event_enabled = true\n      SiteSetting.displayed_invitees_limit = 3\n    end\n\n    context 'with an existing post' do\n      let(:user) { Fabricate(:user, admin: true) }\n      let(:topic) { Fabricate(:topic, user: user) }\n      let(:post1) { Fabricate(:post, user: user, topic: topic) }\n      let(:invitee1) { Fabricate(:user) }\n      let(:invitee2) { Fabricate(:user) }\n\n      context 'with an existing event' do\n        let(:event_1) { Fabricate(:event, post: post1) }\n\n        before do\n          sign_in(user)\n        end\n\n        context 'when updating' do\n          context 'when doing csv bulk invite' do\n            let(:valid_file) {\n              file = Tempfile.new(\"valid.csv\")\n              file.write(\"bob,going\\n\")\n              file.write(\"sam,interested\\n\")\n              file.write(\"the_foo_bar_group,not_going\\n\")\n              file.rewind\n              file\n            }\n\n            let(:empty_file) {\n              file = Tempfile.new(\"invalid.pdf\")\n              file.rewind\n              file\n            }\n\n            context 'when current user can manage the event' do\n              context 'when no file is given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\"\n                  expect(response.parsed_body['error_type']).to eq('invalid_parameters')\n                end\n              end\n\n              context 'when an empty file is given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\", { params: { file: fixture_file_upload(empty_file) } }\n                  expect(response.status).to eq(422)\n                end\n              end\n\n              context 'when a valid file is given' do\n                before do\n                  Jobs.run_later!\n                end\n\n                it 'enqueues the job and returns 200' do\n                  expect_enqueued_with(job: :discourse_post_event_bulk_invite, args: {\n                    \"event_id\" => event_1.id,\n                    \"invitees\" => [\n                      { 'identifier' => 'bob', 'attendance' => 'going' },\n                      { 'identifier' => 'sam', 'attendance' => 'interested' },\n                      { 'identifier' => 'the_foo_bar_group', 'attendance' => 'not_going' }\n                    ],\n                    \"current_user_id\" => user.id\n                  }) do\n                    post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\", { params: { file: fixture_file_upload(valid_file) } }\n                  end\n\n                  expect(response.status).to eq(200)\n                end\n              end\n            end\n\n            context 'when current user can\u2019t manage the event' do\n              let(:lurker) { Fabricate(:user) }\n\n              before do\n                sign_in(lurker)\n              end\n\n              it 'returns an error' do\n                post \"/discourse-post-event/events/#{event_1.id}/csv-bulk-invite.json\"\n                expect(response.status).to eq(403)\n              end\n            end\n          end\n\n          context 'when doing bulk invite' do\n            context 'when current user can manage the event' do\n              context 'when no invitees are given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\"\n                  expect(response.parsed_body['error_type']).to eq('invalid_parameters')\n                end\n              end\n\n              context 'when empty invitees are given' do\n                it 'returns an error' do\n                  post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\", { params: { invitees: [] } }\n                  expect(response.status).to eq(400)\n                end\n              end\n\n              context 'when valid invitees are given' do\n                before do\n                  Jobs.run_later!\n                end\n\n                it 'enqueues the job and returns 200' do\n                  expect_enqueued_with(job: :discourse_post_event_bulk_invite, args: {\n                    \"event_id\" => event_1.id,\n                    \"invitees\" => [\n                      { 'identifier' => 'bob', 'attendance' => 'going' },\n                      { 'identifier' => 'sam', 'attendance' => 'interested' },\n                      { 'identifier' => 'the_foo_bar_group', 'attendance' => 'not_going' }\n                    ],\n                    \"current_user_id\" => user.id\n                  }) do\n                    post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\", { params: { invitees: [\n                      { 'identifier' => 'bob', 'attendance' => 'going' },\n                      { 'identifier' => 'sam', 'attendance' => 'interested' },\n                      { 'identifier' => 'the_foo_bar_group', 'attendance' => 'not_going' }\n                    ] } }\n                  end\n\n                  expect(response.status).to eq(200)\n                end\n              end\n            end\n\n            context 'when current user can\u2019t manage the event' do\n              let(:lurker) { Fabricate(:user) }\n\n              before do\n                sign_in(lurker)\n              end\n\n              it 'returns an error' do\n                post \"/discourse-post-event/events/#{event_1.id}/bulk-invite.json\"\n                expect(response.status).to eq(403)\n              end\n            end\n          end\n        end\n\n        context 'when acting user has created the event' do\n          it 'destroys a event' do\n            expect(event_1.persisted?).to be(true)\n\n            messages = MessageBus.track_publish do\n              delete \"/discourse-post-event/events/#{event_1.id}.json\"\n            end\n            expect(messages.count).to eq(1)\n            message = messages.first\n            expect(message.channel).to eq(\"/discourse-post-event/#{event_1.post.topic_id}\")\n            expect(message.data[:id]).to eq(event_1.id)\n            expect(response.status).to eq(200)\n            expect(Event).to_not exist(id: event_1.id)\n          end\n        end\n\n        context 'when acting user has not created the event' do\n          let(:lurker) { Fabricate(:user) }\n\n          before do\n            sign_in(lurker)\n          end\n\n          it 'doesn\u2019t destroy the event' do\n            expect(event_1.persisted?).to be(true)\n            delete \"/discourse-post-event/events/#{event_1.id}.json\"\n            expect(response.status).to eq(403)\n            expect(Event).to exist(id: event_1.id)\n          end\n        end\n\n        context 'when watching user is not logged' do\n          before do\n            sign_out\n          end\n\n          context 'when topic is public' do\n            it 'can see the event' do\n              get \"/discourse-post-event/events/#{event_1.id}.json\"\n\n              expect(response.status).to eq(200)\n            end\n          end\n\n          context 'when topic is not public' do\n            before do\n              event_1.post.topic.convert_to_private_message(Discourse.system_user)\n            end\n\n            it 'can\u2019t see the event' do\n              get \"/discourse-post-event/events/#{event_1.id}.json\"\n\n              expect(response.status).to eq(404)\n            end\n          end\n        end\n\n        context 'when filtering by category' do\n          it 'can filter the event by category' do\n            category = Fabricate(:category)\n            topic = Fabricate(:topic, category: category)\n            event_2 = Fabricate(:event, post: Fabricate(:post, post_number: 1, topic: topic))\n\n            get \"/discourse-post-event/events.json?category_id=#{category.id}\"\n\n            expect(response.status).to eq(200)\n            events = response.parsed_body[\"events\"]\n            expect(events.length).to eq(1)\n            expect(events[0][\"id\"]).to eq(event_2.id)\n          end\n        end\n      end\n    end\n\n    context 'with a private event' do\n      let(:moderator) { Fabricate(:user, moderator: true) }\n      let(:topic) { Fabricate(:topic, user: moderator) }\n      let(:first_post) { Fabricate(:post, user: moderator, topic: topic) }\n      let(:private_event) { Fabricate(:event, post: first_post, status: Event.statuses[:private]) }\n\n      before do\n        sign_in(moderator)\n      end\n\n      context 'when bulk inviting via CSV file' do\n        def csv_file(content)\n          file = Tempfile.new(\"invites.csv\")\n          file.write(content)\n          file.rewind\n          file\n        end\n\n        it \"doesn't invite a private group\" do\n          private_group = Fabricate(:group, visibility_level: Group.visibility_levels[:owners])\n\n          file = csv_file(\"#{private_group.name},going\\n\")\n          params = { file: fixture_file_upload(file) }\n          post \"/discourse-post-event/events/#{private_event.id}/csv-bulk-invite.json\", { params: params }\n\n          expect(response.status).to eq(200)\n          private_event.reload\n          expect(private_event.raw_invitees).to be_nil\n        end\n\n        it \"returns 200 when inviting a non-existent group\" do\n          file = csv_file(\"non-existent group name,going\\n\")\n          params = { file: fixture_file_upload(file) }\n          post \"/discourse-post-event/events/#{private_event.id}/csv-bulk-invite.json\", { params: params }\n\n          expect(response.status).to eq(200)\n        end\n\n        it \"doesn't invite a public group with private members\" do\n          public_group_with_private_members = Fabricate(\n            :group,\n            visibility_level: Group.visibility_levels[:public],\n            members_visibility_level: Group.visibility_levels[:owners])\n\n          file = csv_file(\"#{public_group_with_private_members.name},going\\n\")\n          params = { file: fixture_file_upload(file) }\n          post \"/discourse-post-event/events/#{private_event.id}/csv-bulk-invite.json\", { params: params }\n\n          expect(response.status).to eq(200)\n          private_event.reload\n          expect(private_event.raw_invitees).to be_nil\n        end\n      end\n\n      context 'when doing bulk inviting via UI' do\n        it \"doesn't invite a private group\" do\n          private_group = Fabricate(:group, visibility_level: Group.visibility_levels[:owners])\n\n          params = { invitees: [\n            { 'identifier' => private_group.name, 'attendance' => 'going' }\n          ] }\n          post \"/discourse-post-event/events/#{private_event.id}/bulk-invite.json\", { params: params }\n\n          expect(response.status).to eq(200)\n          private_event.reload\n          expect(private_event.raw_invitees).to be_nil\n        end\n\n        it \"returns 200 when inviting a non-existent group\" do\n          params = { invitees: [\n            { 'identifier' => 'non-existent group name', 'attendance' => 'going' }\n          ] }\n          post \"/discourse-post-event/events/#{private_event.id}/bulk-invite.json\", { params: params }\n\n          expect(response.status).to eq(200)\n        end\n\n        it \"doesn't invite a public group with private members\" do\n          public_group_with_private_members = Fabricate(\n            :group,\n            visibility_level: Group.visibility_levels[:public],\n            members_visibility_level: Group.visibility_levels[:owners])\n\n          params = { invitees: [\n            { 'identifier' => public_group_with_private_members.name, 'attendance' => 'going' }\n          ] }\n          post \"/discourse-post-event/events/#{private_event.id}/bulk-invite.json\", { params: params }\n\n          expect(response.status).to eq(200)\n          private_event.reload\n          expect(private_event.raw_invitees).to be_nil\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["config/locales/server.en.yml", "jobs/regular/discourse_post_event/bulk_invite.rb", "lib/discourse_post_event/event_validator.rb", "spec/integration/post_spec.rb", "spec/requests/events_controller_spec.rb"], "buggy_code_start_loc": [83, 35, 34, 254, 13], "buggy_code_end_loc": [83, 115, 85, 571, 226], "fixing_code_start_loc": [84, 36, 35, 255, 12], "fixing_code_end_loc": [86, 131, 111, 606, 322], "type": "NVD-CWE-noinfo", "message": "Discourse-calendar is a plugin for the Discourse messaging platform which adds the ability to create a dynamic calendar in the first post of a topic. Members of private groups or public groups with private members can be listed by users, who can create and edit post events. This vulnerability only affects sites which have discourse post events enabled. This issue has been patched in commit `ca5ae3e7e` which will be included in future releases. Users unable to upgrade should disable the `discourse_post_event_enabled` setting to fully mitigate the issue. Also, it's possible to prevent regular users from using this vulnerability by removing all groups from the `discourse_post_event_allowed_on_groups` but note that moderators will still be able to use it.", "other": {"cve": {"id": "CVE-2022-41913", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-14T21:15:18.320", "lastModified": "2022-11-17T19:40:41.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse-calendar is a plugin for the Discourse messaging platform which adds the ability to create a dynamic calendar in the first post of a topic. Members of private groups or public groups with private members can be listed by users, who can create and edit post events. This vulnerability only affects sites which have discourse post events enabled. This issue has been patched in commit `ca5ae3e7e` which will be included in future releases. Users unable to upgrade should disable the `discourse_post_event_enabled` setting to fully mitigate the issue. Also, it's possible to prevent regular users from using this vulnerability by removing all groups from the `discourse_post_event_allowed_on_groups` but note that moderators will still be able to use it."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:calendar:0.2:*:*:*:*:*:*:*", "matchCriteriaId": "6075B2AF-7E63-4EC1-B3E5-1C8E1AACCAF4"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-calendar/commit/ca5ae3e7e0c2b32af5ca4ec69c95e95b2ecef2e9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse-calendar/security/advisories/GHSA-jh96-w279-g7r9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-calendar/commit/ca5ae3e7e0c2b32af5ca4ec69c95e95b2ecef2e9"}}