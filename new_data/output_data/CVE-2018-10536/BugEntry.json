{"buggy_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// riff.c\n\n// This module is a helper to the WavPack command-line programs to support WAV files\n// (both MS standard and rf64 varients).\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define CS64ChunkFormat \"4D\"\n#define DS64ChunkFormat \"DDDL\"\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\n    int64_t total_samples = 0, infilesize;\n    RiffChunkHeader riff_chunk_header;\n    ChunkHeader chunk_header;\n    WaveHeader WaveHeader;\n    DS64Chunk ds64_chunk;\n    uint32_t bcount;\n\n    CLEAR (WaveHeader);\n    CLEAR (ds64_chunk);\n    infilesize = DoGetFileSize (infile);\n\n    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\n        error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    memcpy (&riff_chunk_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\n        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\n            error_line (\"%s is not a valid .WAV file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\n            bcount != sizeof (ChunkHeader)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\n\n        if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n            if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n                bcount != sizeof (DS64Chunk)) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            got_ds64 = 1;\n            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\n\n            if (debug_logging_mode)\n                error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\n\n            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            while (ds64_chunk.tableLength--) {\n                CS64Chunk cs64_chunk;\n                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\n                    bcount != sizeof (CS64Chunk) ||\n                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\n                        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                        return WAVPACK_SOFT_ERROR;\n                }\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and\n            int supported = TRUE, format;                        // make sure it's a .wav file we can handle\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .WAV format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this WAV file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else if (config->float_norm_exp)\n                    error_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\n                        config->float_norm_exp - 126, 150 - config->float_norm_exp);\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop\n\n            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\n                ds64_chunk.dataSize64 : chunk_header.ckSize;\n\n\n            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\n                error_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (config->qmode & QMODE_IGNORE_LENGTH) {\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                total_samples = data_chunk_size / WaveHeader.BlockAlign;\n\n                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (!total_samples) {\n                    error_line (\"this .WAV file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid RIFF wav header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes > 0xff000000) {\n        if (debug_logging_mode)\n            error_line (\"total_data_bytes = %lld, so rf64\", total_data_bytes);\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n    else if (debug_logging_mode)\n        error_line (\"total_data_bytes = %lld, so riff\", total_data_bytes);\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    // again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// wave64.c\n\n// This module is a helper to the WavPack command-line programs to support Sony's\n// Wave64 WAV file varient. Note that unlike the WAV/RF64 version, this does not\n// fall back to conventional WAV in the < 4GB case.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n    char formType [16];\n} Wave64FileHeader;\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n} Wave64ChunkHeader;\n\n#define Wave64ChunkHeaderFormat \"88D\"\n\nstatic const unsigned char riff_guid [16] = { 'r','i','f','f', 0x2e,0x91,0xcf,0x11,0xa5,0xd6,0x28,0xdb,0x04,0xc1,0x00,0x00 };\nstatic const unsigned char wave_guid [16] = { 'w','a','v','e', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char  fmt_guid [16] = { 'f','m','t',' ', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char data_guid [16] = { 'd','a','t','a', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&filehdr, fourcc, 4);\n\n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n    // loop through all elements of the wave64 header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .wav file we can handle\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteWave64Header (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    Wave64ChunkHeader datahdr, fmthdr;\n    Wave64FileHeader filehdr;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_file_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid Wave64 header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    total_file_bytes = sizeof (filehdr) + sizeof (fmthdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 7) & ~(int64_t)7);\n\n    memcpy (filehdr.ckID, riff_guid, sizeof (riff_guid));\n    memcpy (filehdr.formType, wave_guid, sizeof (wave_guid));\n    filehdr.ckSize = total_file_bytes;\n\n    memcpy (fmthdr.ckID, fmt_guid, sizeof (fmt_guid));\n    fmthdr.ckSize = sizeof (fmthdr) + wavhdrsize;\n\n    memcpy (datahdr.ckID, data_guid, sizeof (data_guid));\n    datahdr.ckSize = total_data_bytes + sizeof (datahdr);\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&filehdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, Wave64ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &filehdr, sizeof (filehdr), &bcount) || bcount != sizeof (filehdr) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .W64 data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n"], "fixing_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// riff.c\n\n// This module is a helper to the WavPack command-line programs to support WAV files\n// (both MS standard and rf64 varients).\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define CS64ChunkFormat \"4D\"\n#define DS64ChunkFormat \"DDDL\"\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0, format_chunk = 0;\n    int64_t total_samples = 0, infilesize;\n    RiffChunkHeader riff_chunk_header;\n    ChunkHeader chunk_header;\n    WaveHeader WaveHeader;\n    DS64Chunk ds64_chunk;\n    uint32_t bcount;\n\n    CLEAR (WaveHeader);\n    CLEAR (ds64_chunk);\n    infilesize = DoGetFileSize (infile);\n\n    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\n        error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    memcpy (&riff_chunk_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\n        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\n            error_line (\"%s is not a valid .WAV file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\n            bcount != sizeof (ChunkHeader)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\n\n        if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n            if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n                bcount != sizeof (DS64Chunk)) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            got_ds64 = 1;\n            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\n\n            if (debug_logging_mode)\n                error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\n\n            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            while (ds64_chunk.tableLength--) {\n                CS64Chunk cs64_chunk;\n                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\n                    bcount != sizeof (CS64Chunk) ||\n                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\n                        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                        return WAVPACK_SOFT_ERROR;\n                }\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and\n            int supported = TRUE, format;                        // make sure it's a .wav file we can handle\n\n            if (format_chunk++) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .WAV format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this WAV file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else if (config->float_norm_exp)\n                    error_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\n                        config->float_norm_exp - 126, 150 - config->float_norm_exp);\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop\n\n            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\n                ds64_chunk.dataSize64 : chunk_header.ckSize;\n\n\n            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\n                error_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (config->qmode & QMODE_IGNORE_LENGTH) {\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                total_samples = data_chunk_size / WaveHeader.BlockAlign;\n\n                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (!total_samples) {\n                    error_line (\"this .WAV file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid RIFF wav header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes > 0xff000000) {\n        if (debug_logging_mode)\n            error_line (\"total_data_bytes = %lld, so rf64\", total_data_bytes);\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n    else if (debug_logging_mode)\n        error_line (\"total_data_bytes = %lld, so riff\", total_data_bytes);\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    // again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// wave64.c\n\n// This module is a helper to the WavPack command-line programs to support Sony's\n// Wave64 WAV file varient. Note that unlike the WAV/RF64 version, this does not\n// fall back to conventional WAV in the < 4GB case.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n    char formType [16];\n} Wave64FileHeader;\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n} Wave64ChunkHeader;\n\n#define Wave64ChunkHeaderFormat \"88D\"\n\nstatic const unsigned char riff_guid [16] = { 'r','i','f','f', 0x2e,0x91,0xcf,0x11,0xa5,0xd6,0x28,0xdb,0x04,0xc1,0x00,0x00 };\nstatic const unsigned char wave_guid [16] = { 'w','a','v','e', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char  fmt_guid [16] = { 'f','m','t',' ', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char data_guid [16] = { 'd','a','t','a', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n    int format_chunk = 0;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&filehdr, fourcc, 4);\n\n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n    // loop through all elements of the wave64 header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .wav file we can handle\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            if (format_chunk++) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteWave64Header (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    Wave64ChunkHeader datahdr, fmthdr;\n    Wave64FileHeader filehdr;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_file_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid Wave64 header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    total_file_bytes = sizeof (filehdr) + sizeof (fmthdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 7) & ~(int64_t)7);\n\n    memcpy (filehdr.ckID, riff_guid, sizeof (riff_guid));\n    memcpy (filehdr.formType, wave_guid, sizeof (wave_guid));\n    filehdr.ckSize = total_file_bytes;\n\n    memcpy (fmthdr.ckID, fmt_guid, sizeof (fmt_guid));\n    fmthdr.ckSize = sizeof (fmthdr) + wavhdrsize;\n\n    memcpy (datahdr.ckID, data_guid, sizeof (data_guid));\n    datahdr.ckSize = total_data_bytes + sizeof (datahdr);\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&filehdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, Wave64ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &filehdr, sizeof (filehdr), &bcount) || bcount != sizeof (filehdr) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .W64 data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n"], "filenames": ["cli/riff.c", "cli/wave64.c"], "buggy_code_start_loc": [56, 55], "buggy_code_end_loc": [141, 105], "fixing_code_start_loc": [56, 56], "fixing_code_end_loc": [147, 112], "type": "CWE-787", "message": "An issue was discovered in WavPack 5.1.0 and earlier. The WAV parser component contains a vulnerability that allows writing to memory because ParseRiffHeaderConfig in riff.c does not reject multiple format chunks.", "other": {"cve": {"id": "CVE-2018-10536", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-29T15:29:00.333", "lastModified": "2019-12-20T10:15:11.763", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in WavPack 5.1.0 and earlier. The WAV parser component contains a vulnerability that allows writing to memory because ParseRiffHeaderConfig in riff.c does not reject multiple format chunks."}, {"lang": "es", "value": "Se ha descubierto un problema en WavPack 5.1.0 y anteriores. El componente de analizador WAV contiene una vulnerabilidad que permite la escritura en la memoria debido a que ParseRiffHeaderConfig en riff.c no rechaza m\u00faltiples fragmentos de formato."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wavpack:wavpack:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.1.0", "matchCriteriaId": "A5AF1FF6-17E5-429C-8280-8215E7010571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/155743/Slackware-Security-Advisory-wavpack-Updates.html", "source": "cve@mitre.org"}, {"url": "https://github.com/dbry/WavPack/commit/26cb47f99d481ad9b93eeff80d26e6b63bbd7e15", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/30", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/31", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/32", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6CFFFWIWALGQPKINRDW3PRGRD5LOLGZA/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BRWQNE3TH5UF64IKHKKHVCHJHUOVKJUH/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Dec/37", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3637-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4197", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dbry/WavPack/commit/26cb47f99d481ad9b93eeff80d26e6b63bbd7e15"}}