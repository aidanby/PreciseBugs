{"buggy_code": ["/*\n * AirSpy SDR driver\n *\n * Copyright (C) 2014 Antti Palosaari <crope@iki.fi>\n *\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n/* AirSpy USB API commands (from AirSpy Library) */\nenum {\n\tCMD_INVALID                       = 0x00,\n\tCMD_RECEIVER_MODE                 = 0x01,\n\tCMD_SI5351C_WRITE                 = 0x02,\n\tCMD_SI5351C_READ                  = 0x03,\n\tCMD_R820T_WRITE                   = 0x04,\n\tCMD_R820T_READ                    = 0x05,\n\tCMD_SPIFLASH_ERASE                = 0x06,\n\tCMD_SPIFLASH_WRITE                = 0x07,\n\tCMD_SPIFLASH_READ                 = 0x08,\n\tCMD_BOARD_ID_READ                 = 0x09,\n\tCMD_VERSION_STRING_READ           = 0x0a,\n\tCMD_BOARD_PARTID_SERIALNO_READ    = 0x0b,\n\tCMD_SET_SAMPLE_RATE               = 0x0c,\n\tCMD_SET_FREQ                      = 0x0d,\n\tCMD_SET_LNA_GAIN                  = 0x0e,\n\tCMD_SET_MIXER_GAIN                = 0x0f,\n\tCMD_SET_VGA_GAIN                  = 0x10,\n\tCMD_SET_LNA_AGC                   = 0x11,\n\tCMD_SET_MIXER_AGC                 = 0x12,\n\tCMD_SET_PACKING                   = 0x13,\n};\n\n/*\n *       bEndpointAddress     0x81  EP 1 IN\n *         Transfer Type            Bulk\n *       wMaxPacketSize     0x0200  1x 512 bytes\n */\n#define MAX_BULK_BUFS            (6)\n#define BULK_BUFFER_SIZE         (128 * 512)\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   = 20000000,\n\t\t.rangehigh  = 20000000,\n\t},\n};\n\nstatic const struct v4l2_frequency_band bands_rf[] = {\n\t{\n\t\t.tuner = 1,\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =   24000000,\n\t\t.rangehigh  = 1750000000,\n\t},\n};\n\n/* stream formats */\nstruct airspy_format {\n\tchar\t*name;\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\n\n/* format descriptions for capture and preview */\nstatic struct airspy_format formats[] = {\n\t{\n\t\t.name\t\t= \"Real U12LE\",\n\t\t.pixelformat\t= V4L2_SDR_FMT_RU12LE,\n\t\t.buffersize\t= BULK_BUFFER_SIZE,\n\t},\n};\n\nstatic const unsigned int NUM_FORMATS = ARRAY_SIZE(formats);\n\n/* intermediate buffers with raw data from the USB device */\nstruct airspy_frame_buf {\n\t/* common v4l buffer stuff -- must be first */\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstruct airspy {\n#define POWER_ON\t   1\n#define USB_STATE_URB_BUF  2\n\tunsigned long flags;\n\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\n\t/* videobuf2 queue and queued buffers list */\n\tstruct vb2_queue vb_queue;\n\tstruct list_head queued_bufs;\n\tspinlock_t queued_bufs_lock; /* Protects queued_bufs */\n\tunsigned sequence;\t     /* Buffer sequence counter */\n\tunsigned int vb_full;        /* vb is full and packets dropped */\n\n\t/* Note if taking both locks v4l2_lock must always be locked first! */\n\tstruct mutex v4l2_lock;      /* Protects everything else */\n\tstruct mutex vb_queue_lock;  /* Protects vb_queue and capt_file */\n\n\tstruct urb     *urb_list[MAX_BULK_BUFS];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8             *buf_list[MAX_BULK_BUFS];\n\tdma_addr_t     dma_addr[MAX_BULK_BUFS];\n\tint            urbs_initialized;\n\tint            urbs_submitted;\n\n\t/* USB control message buffer */\n\t#define BUF_SIZE 128\n\tu8 buf[BUF_SIZE];\n\n\t/* Current configuration */\n\tunsigned int f_adc;\n\tunsigned int f_rf;\n\tu32 pixelformat;\n\tu32 buffersize;\n\n\t/* Controls */\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *lna_gain_auto;\n\tstruct v4l2_ctrl *lna_gain;\n\tstruct v4l2_ctrl *mixer_gain_auto;\n\tstruct v4l2_ctrl *mixer_gain;\n\tstruct v4l2_ctrl *if_gain;\n\n\t/* Sample rate calc */\n\tunsigned long jiffies_next;\n\tunsigned int sample;\n\tunsigned int sample_measured;\n};\n\n#define airspy_dbg_usb_control_msg(_dev, _r, _t, _v, _i, _b, _l) { \\\n\tchar *_direction; \\\n\tif (_t & USB_DIR_IN) \\\n\t\t_direction = \"<<<\"; \\\n\telse \\\n\t\t_direction = \">>>\"; \\\n\tdev_dbg(_dev, \"%02x %02x %02x %02x %02x %02x %02x %02x %s %*ph\\n\", \\\n\t\t\t_t, _r, _v & 0xff, _v >> 8, _i & 0xff, _i >> 8, \\\n\t\t\t_l & 0xff, _l >> 8, _direction, _l, _b); \\\n}\n\n/* execute firmware command */\nstatic int airspy_ctrl_msg(struct airspy *s, u8 request, u16 value, u16 index,\n\t\tu8 *data, u16 size)\n{\n\tint ret;\n\tunsigned int pipe;\n\tu8 requesttype;\n\n\tswitch (request) {\n\tcase CMD_RECEIVER_MODE:\n\tcase CMD_SET_FREQ:\n\t\tpipe = usb_sndctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tbreak;\n\tcase CMD_BOARD_ID_READ:\n\tcase CMD_VERSION_STRING_READ:\n\tcase CMD_BOARD_PARTID_SERIALNO_READ:\n\tcase CMD_SET_LNA_GAIN:\n\tcase CMD_SET_MIXER_GAIN:\n\tcase CMD_SET_VGA_GAIN:\n\tcase CMD_SET_LNA_AGC:\n\tcase CMD_SET_MIXER_AGC:\n\t\tpipe = usb_rcvctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(s->dev, \"Unknown command %02x\\n\", request);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* write request */\n\tif (!(requesttype & USB_DIR_IN))\n\t\tmemcpy(s->buf, data, size);\n\n\tret = usb_control_msg(s->udev, pipe, request, requesttype, value,\n\t\t\tindex, s->buf, size, 1000);\n\tairspy_dbg_usb_control_msg(s->dev, request, requesttype, value,\n\t\t\tindex, s->buf, size);\n\tif (ret < 0) {\n\t\tdev_err(s->dev, \"usb_control_msg() failed %d request %02x\\n\",\n\t\t\t\tret, request);\n\t\tgoto err;\n\t}\n\n\t/* read request */\n\tif (requesttype & USB_DIR_IN)\n\t\tmemcpy(data, s->buf, size);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\n/* Private functions */\nstatic struct airspy_frame_buf *airspy_get_next_fill_buf(struct airspy *s)\n{\n\tunsigned long flags;\n\tstruct airspy_frame_buf *buf = NULL;\n\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\n\tif (list_empty(&s->queued_bufs))\n\t\tgoto leave;\n\n\tbuf = list_entry(s->queued_bufs.next,\n\t\t\tstruct airspy_frame_buf, list);\n\tlist_del(&buf->list);\nleave:\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\n\treturn buf;\n}\n\nstatic unsigned int airspy_convert_stream(struct airspy *s,\n\t\tvoid *dst, void *src, unsigned int src_len)\n{\n\tunsigned int dst_len;\n\n\tif (s->pixelformat == V4L2_SDR_FMT_RU12LE) {\n\t\tmemcpy(dst, src, src_len);\n\t\tdst_len = src_len;\n\t} else {\n\t\tdst_len = 0;\n\t}\n\n\t/* calculate sample rate and output it in 10 seconds intervals */\n\tif (unlikely(time_is_before_jiffies(s->jiffies_next))) {\n\t\t#define MSECS 10000UL\n\t\tunsigned int msecs = jiffies_to_msecs(jiffies -\n\t\t\t\ts->jiffies_next + msecs_to_jiffies(MSECS));\n\t\tunsigned int samples = s->sample - s->sample_measured;\n\n\t\ts->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\n\t\ts->sample_measured = s->sample;\n\t\tdev_dbg(s->dev, \"slen=%u samples=%u msecs=%u sample rate=%lu\\n\",\n\t\t\t\tsrc_len, samples, msecs,\n\t\t\t\tsamples * 1000UL / msecs);\n\t}\n\n\t/* total number of samples */\n\ts->sample += src_len / 2;\n\n\treturn dst_len;\n}\n\n/*\n * This gets called for the bulk stream pipe. This is done in interrupt\n * time, so it has to be fast, not crash, and not stall. Neat.\n */\nstatic void airspy_urb_complete(struct urb *urb)\n{\n\tstruct airspy *s = urb->context;\n\tstruct airspy_frame_buf *fbuf;\n\n\tdev_dbg_ratelimited(s->dev, \"status=%d length=%d/%d errors=%d\\n\",\n\t\t\turb->status, urb->actual_length,\n\t\t\turb->transfer_buffer_length, urb->error_count);\n\n\tswitch (urb->status) {\n\tcase 0:             /* success */\n\tcase -ETIMEDOUT:    /* NAK */\n\t\tbreak;\n\tcase -ECONNRESET:   /* kill */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:            /* error */\n\t\tdev_err_ratelimited(s->dev, \"URB failed %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tif (likely(urb->actual_length > 0)) {\n\t\tvoid *ptr;\n\t\tunsigned int len;\n\t\t/* get free framebuffer */\n\t\tfbuf = airspy_get_next_fill_buf(s);\n\t\tif (unlikely(fbuf == NULL)) {\n\t\t\ts->vb_full++;\n\t\t\tdev_notice_ratelimited(s->dev,\n\t\t\t\t\t\"videobuf is full, %d packets dropped\\n\",\n\t\t\t\t\ts->vb_full);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* fill framebuffer */\n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\n\t\tlen = airspy_convert_stream(s, ptr, urb->transfer_buffer,\n\t\t\t\turb->actual_length);\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\n\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tfbuf->vb.sequence = s->sequence++;\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\nskip:\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int airspy_kill_urbs(struct airspy *s)\n{\n\tint i;\n\n\tfor (i = s->urbs_submitted - 1; i >= 0; i--) {\n\t\tdev_dbg(s->dev, \"kill urb=%d\\n\", i);\n\t\t/* stop the URB */\n\t\tusb_kill_urb(s->urb_list[i]);\n\t}\n\ts->urbs_submitted = 0;\n\n\treturn 0;\n}\n\nstatic int airspy_submit_urbs(struct airspy *s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < s->urbs_initialized; i++) {\n\t\tdev_dbg(s->dev, \"submit urb=%d\\n\", i);\n\t\tret = usb_submit_urb(s->urb_list[i], GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_err(s->dev, \"Could not submit URB no. %d - get them all back\\n\",\n\t\t\t\t\ti);\n\t\t\tairspy_kill_urbs(s);\n\t\t\treturn ret;\n\t\t}\n\t\ts->urbs_submitted++;\n\t}\n\n\treturn 0;\n}\n\nstatic int airspy_free_stream_bufs(struct airspy *s)\n{\n\tif (test_bit(USB_STATE_URB_BUF, &s->flags)) {\n\t\twhile (s->buf_num) {\n\t\t\ts->buf_num--;\n\t\t\tdev_dbg(s->dev, \"free buf=%d\\n\", s->buf_num);\n\t\t\tusb_free_coherent(s->udev, s->buf_size,\n\t\t\t\t\t  s->buf_list[s->buf_num],\n\t\t\t\t\t  s->dma_addr[s->buf_num]);\n\t\t}\n\t}\n\tclear_bit(USB_STATE_URB_BUF, &s->flags);\n\n\treturn 0;\n}\n\nstatic int airspy_alloc_stream_bufs(struct airspy *s)\n{\n\ts->buf_num = 0;\n\ts->buf_size = BULK_BUFFER_SIZE;\n\n\tdev_dbg(s->dev, \"all in all I will use %u bytes for streaming\\n\",\n\t\t\tMAX_BULK_BUFS * BULK_BUFFER_SIZE);\n\n\tfor (s->buf_num = 0; s->buf_num < MAX_BULK_BUFS; s->buf_num++) {\n\t\ts->buf_list[s->buf_num] = usb_alloc_coherent(s->udev,\n\t\t\t\tBULK_BUFFER_SIZE, GFP_ATOMIC,\n\t\t\t\t&s->dma_addr[s->buf_num]);\n\t\tif (!s->buf_list[s->buf_num]) {\n\t\t\tdev_dbg(s->dev, \"alloc buf=%d failed\\n\", s->buf_num);\n\t\t\tairspy_free_stream_bufs(s);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_dbg(s->dev, \"alloc buf=%d %p (dma %llu)\\n\", s->buf_num,\n\t\t\t\ts->buf_list[s->buf_num],\n\t\t\t\t(long long)s->dma_addr[s->buf_num]);\n\t\tset_bit(USB_STATE_URB_BUF, &s->flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int airspy_free_urbs(struct airspy *s)\n{\n\tint i;\n\n\tairspy_kill_urbs(s);\n\n\tfor (i = s->urbs_initialized - 1; i >= 0; i--) {\n\t\tif (s->urb_list[i]) {\n\t\t\tdev_dbg(s->dev, \"free urb=%d\\n\", i);\n\t\t\t/* free the URBs */\n\t\t\tusb_free_urb(s->urb_list[i]);\n\t\t}\n\t}\n\ts->urbs_initialized = 0;\n\n\treturn 0;\n}\n\nstatic int airspy_alloc_urbs(struct airspy *s)\n{\n\tint i, j;\n\n\t/* allocate the URBs */\n\tfor (i = 0; i < MAX_BULK_BUFS; i++) {\n\t\tdev_dbg(s->dev, \"alloc urb=%d\\n\", i);\n\t\ts->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!s->urb_list[i]) {\n\t\t\tdev_dbg(s->dev, \"failed\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(s->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_bulk_urb(s->urb_list[i],\n\t\t\t\ts->udev,\n\t\t\t\tusb_rcvbulkpipe(s->udev, 0x81),\n\t\t\t\ts->buf_list[i],\n\t\t\t\tBULK_BUFFER_SIZE,\n\t\t\t\tairspy_urb_complete, s);\n\n\t\ts->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\ts->urb_list[i]->transfer_dma = s->dma_addr[i];\n\t\ts->urbs_initialized++;\n\t}\n\n\treturn 0;\n}\n\n/* Must be called with vb_queue_lock hold */\nstatic void airspy_cleanup_queued_bufs(struct airspy *s)\n{\n\tunsigned long flags;\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\n\twhile (!list_empty(&s->queued_bufs)) {\n\t\tstruct airspy_frame_buf *buf;\n\n\t\tbuf = list_entry(s->queued_bufs.next,\n\t\t\t\tstruct airspy_frame_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\n}\n\n/* The user yanked out the cable... */\nstatic void airspy_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v = usb_get_intfdata(intf);\n\tstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tmutex_lock(&s->vb_queue_lock);\n\tmutex_lock(&s->v4l2_lock);\n\t/* No need to keep the urbs around after disconnection */\n\ts->udev = NULL;\n\tv4l2_device_disconnect(&s->v4l2_dev);\n\tvideo_unregister_device(&s->vdev);\n\tmutex_unlock(&s->v4l2_lock);\n\tmutex_unlock(&s->vb_queue_lock);\n\n\tv4l2_device_put(&s->v4l2_dev);\n}\n\n/* Videobuf2 operations */\nstatic int airspy_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbuffers,\n\t\tunsigned int *nplanes, unsigned int sizes[], void *alloc_ctxs[])\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\n\tdev_dbg(s->dev, \"nbuffers=%d\\n\", *nbuffers);\n\n\t/* Need at least 8 buffers */\n\tif (vq->num_buffers + *nbuffers < 8)\n\t\t*nbuffers = 8 - vq->num_buffers;\n\t*nplanes = 1;\n\tsizes[0] = PAGE_ALIGN(s->buffersize);\n\n\tdev_dbg(s->dev, \"nbuffers=%d sizes[0]=%d\\n\", *nbuffers, sizes[0]);\n\treturn 0;\n}\n\nstatic void airspy_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct airspy *s = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct airspy_frame_buf *buf =\n\t\t\tcontainer_of(vbuf, struct airspy_frame_buf, vb);\n\tunsigned long flags;\n\n\t/* Check the device has not disconnected between prep and queuing */\n\tif (unlikely(!s->udev)) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\n\tlist_add_tail(&buf->list, &s->queued_bufs);\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\n}\n\nstatic int airspy_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tif (!s->udev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&s->v4l2_lock);\n\n\ts->sequence = 0;\n\n\tset_bit(POWER_ON, &s->flags);\n\n\tret = airspy_alloc_stream_bufs(s);\n\tif (ret)\n\t\tgoto err_clear_bit;\n\n\tret = airspy_alloc_urbs(s);\n\tif (ret)\n\t\tgoto err_free_stream_bufs;\n\n\tret = airspy_submit_urbs(s);\n\tif (ret)\n\t\tgoto err_free_urbs;\n\n\t/* start hardware streaming */\n\tret = airspy_ctrl_msg(s, CMD_RECEIVER_MODE, 1, 0, NULL, 0);\n\tif (ret)\n\t\tgoto err_kill_urbs;\n\n\tgoto exit_mutex_unlock;\n\nerr_kill_urbs:\n\tairspy_kill_urbs(s);\nerr_free_urbs:\n\tairspy_free_urbs(s);\nerr_free_stream_bufs:\n\tairspy_free_stream_bufs(s);\nerr_clear_bit:\n\tclear_bit(POWER_ON, &s->flags);\n\n\t/* return all queued buffers to vb2 */\n\t{\n\t\tstruct airspy_frame_buf *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &s->queued_bufs, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\nexit_mutex_unlock:\n\tmutex_unlock(&s->v4l2_lock);\n\n\treturn ret;\n}\n\nstatic void airspy_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tmutex_lock(&s->v4l2_lock);\n\n\t/* stop hardware streaming */\n\tairspy_ctrl_msg(s, CMD_RECEIVER_MODE, 0, 0, NULL, 0);\n\n\tairspy_kill_urbs(s);\n\tairspy_free_urbs(s);\n\tairspy_free_stream_bufs(s);\n\n\tairspy_cleanup_queued_bufs(s);\n\n\tclear_bit(POWER_ON, &s->flags);\n\n\tmutex_unlock(&s->v4l2_lock);\n}\n\nstatic struct vb2_ops airspy_vb2_ops = {\n\t.queue_setup            = airspy_queue_setup,\n\t.buf_queue              = airspy_buf_queue,\n\t.start_streaming        = airspy_start_streaming,\n\t.stop_streaming         = airspy_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nstatic int airspy_querycap(struct file *file, void *fh,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct airspy *s = video_drvdata(file);\n\n\tstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrlcpy(cap->card, s->vdev.name, sizeof(cap->card));\n\tusb_make_path(s->udev, cap->bus_info, sizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\tV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}\n\nstatic int airspy_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int airspy_g_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\n\tf->fmt.sdr.pixelformat = s->pixelformat;\n\tf->fmt.sdr.buffersize = s->buffersize;\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\n\treturn 0;\n}\n\nstatic int airspy_s_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tstruct vb2_queue *q = &s->vb_queue;\n\tint i;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\ts->pixelformat = formats[i].pixelformat;\n\t\t\ts->buffersize = formats[i].buffersize;\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int airspy_try_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tint i;\n\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int airspy_s_tuner(struct file *file, void *priv,\n\t\tconst struct v4l2_tuner *v)\n{\n\tint ret;\n\n\tif (v->index == 0)\n\t\tret = 0;\n\telse if (v->index == 1)\n\t\tret = 0;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int airspy_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\n{\n\tint ret;\n\n\tif (v->index == 0) {\n\t\tstrlcpy(v->name, \"AirSpy ADC\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_ADC;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow  = bands[0].rangelow;\n\t\tv->rangehigh = bands[0].rangehigh;\n\t\tret = 0;\n\t} else if (v->index == 1) {\n\t\tstrlcpy(v->name, \"AirSpy RF\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_RF;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow  = bands_rf[0].rangelow;\n\t\tv->rangehigh = bands_rf[0].rangehigh;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int airspy_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\n\tif (f->tuner == 0) {\n\t\tf->type = V4L2_TUNER_ADC;\n\t\tf->frequency = s->f_adc;\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tf->frequency = s->f_rf;\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int airspy_s_frequency(struct file *file, void *priv,\n\t\tconst struct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\tu8 buf[4];\n\n\tif (f->tuner == 0) {\n\t\ts->f_adc = clamp_t(unsigned int, f->frequency,\n\t\t\t\tbands[0].rangelow,\n\t\t\t\tbands[0].rangehigh);\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\ts->f_rf = clamp_t(unsigned int, f->frequency,\n\t\t\t\tbands_rf[0].rangelow,\n\t\t\t\tbands_rf[0].rangehigh);\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tbuf[0] = (s->f_rf >>  0) & 0xff;\n\t\tbuf[1] = (s->f_rf >>  8) & 0xff;\n\t\tbuf[2] = (s->f_rf >> 16) & 0xff;\n\t\tbuf[3] = (s->f_rf >> 24) & 0xff;\n\t\tret = airspy_ctrl_msg(s, CMD_SET_FREQ, 0, 0, buf, 4);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int airspy_enum_freq_bands(struct file *file, void *priv,\n\t\tstruct v4l2_frequency_band *band)\n{\n\tint ret;\n\n\tif (band->tuner == 0) {\n\t\tif (band->index >= ARRAY_SIZE(bands)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else if (band->tuner == 1) {\n\t\tif (band->index >= ARRAY_SIZE(bands_rf)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands_rf[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops airspy_ioctl_ops = {\n\t.vidioc_querycap          = airspy_querycap,\n\n\t.vidioc_enum_fmt_sdr_cap  = airspy_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap     = airspy_g_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap     = airspy_s_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap   = airspy_try_fmt_sdr_cap,\n\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\n\t.vidioc_g_tuner           = airspy_g_tuner,\n\t.vidioc_s_tuner           = airspy_s_tuner,\n\n\t.vidioc_g_frequency       = airspy_g_frequency,\n\t.vidioc_s_frequency       = airspy_s_frequency,\n\t.vidioc_enum_freq_bands   = airspy_enum_freq_bands,\n\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\n\nstatic const struct v4l2_file_operations airspy_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\n\nstatic struct video_device airspy_template = {\n\t.name                     = \"AirSpy SDR\",\n\t.release                  = video_device_release_empty,\n\t.fops                     = &airspy_fops,\n\t.ioctl_ops                = &airspy_ioctl_ops,\n};\n\nstatic void airspy_video_release(struct v4l2_device *v)\n{\n\tstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\n\n\tv4l2_ctrl_handler_free(&s->hdl);\n\tv4l2_device_unregister(&s->v4l2_dev);\n\tkfree(s);\n}\n\nstatic int airspy_set_lna_gain(struct airspy *s)\n{\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(s->dev, \"lna auto=%d->%d val=%d->%d\\n\",\n\t\t\ts->lna_gain_auto->cur.val, s->lna_gain_auto->val,\n\t\t\ts->lna_gain->cur.val, s->lna_gain->val);\n\n\tret = airspy_ctrl_msg(s, CMD_SET_LNA_AGC, 0, s->lna_gain_auto->val,\n\t\t\t&u8tmp, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tif (s->lna_gain_auto->val == false) {\n\t\tret = airspy_ctrl_msg(s, CMD_SET_LNA_GAIN, 0, s->lna_gain->val,\n\t\t\t\t&u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tif (ret)\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int airspy_set_mixer_gain(struct airspy *s)\n{\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(s->dev, \"mixer auto=%d->%d val=%d->%d\\n\",\n\t\t\ts->mixer_gain_auto->cur.val, s->mixer_gain_auto->val,\n\t\t\ts->mixer_gain->cur.val, s->mixer_gain->val);\n\n\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_AGC, 0, s->mixer_gain_auto->val,\n\t\t\t&u8tmp, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tif (s->mixer_gain_auto->val == false) {\n\t\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_GAIN, 0,\n\t\t\t\ts->mixer_gain->val, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tif (ret)\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int airspy_set_if_gain(struct airspy *s)\n{\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(s->dev, \"val=%d->%d\\n\", s->if_gain->cur.val, s->if_gain->val);\n\n\tret = airspy_ctrl_msg(s, CMD_SET_VGA_GAIN, 0, s->if_gain->val,\n\t\t\t&u8tmp, 1);\n\tif (ret)\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int airspy_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct airspy *s = container_of(ctrl->handler, struct airspy, hdl);\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tret = airspy_set_lna_gain(s);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN:\n\t\tret = airspy_set_mixer_gain(s);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN:\n\t\tret = airspy_set_if_gain(s);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(s->dev, \"unknown ctrl: id=%d name=%s\\n\",\n\t\t\t\tctrl->id, ctrl->name);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops airspy_ctrl_ops = {\n\t.s_ctrl = airspy_s_ctrl,\n};\n\nstatic int airspy_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct airspy *s;\n\tint ret;\n\tu8 u8tmp, buf[BUF_SIZE];\n\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\n\tif (s == NULL) {\n\t\tdev_err(&intf->dev, \"Could not allocate memory for state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&s->v4l2_lock);\n\tmutex_init(&s->vb_queue_lock);\n\tspin_lock_init(&s->queued_bufs_lock);\n\tINIT_LIST_HEAD(&s->queued_bufs);\n\ts->dev = &intf->dev;\n\ts->udev = interface_to_usbdev(intf);\n\ts->f_adc = bands[0].rangelow;\n\ts->f_rf = bands_rf[0].rangelow;\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\n\t/* Detect device */\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not detect board\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\tbuf[BUF_SIZE - 1] = '\\0';\n\n\tdev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);\n\tdev_info(s->dev, \"Firmware version: %s\\n\", buf);\n\n\t/* Init videobuf2 queue structure */\n\ts->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\ts->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\ts->vb_queue.drv_priv = s;\n\ts->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\n\ts->vb_queue.ops = &airspy_vb2_ops;\n\ts->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\ts->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&s->vb_queue);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\t/* Init video_device structure */\n\ts->vdev = airspy_template;\n\ts->vdev.queue = &s->vb_queue;\n\ts->vdev.queue->lock = &s->vb_queue_lock;\n\tvideo_set_drvdata(&s->vdev, s);\n\n\t/* Register the v4l2_device structure */\n\ts->v4l2_dev.release = airspy_video_release;\n\tret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\n\t/* Register controls */\n\tv4l2_ctrl_handler_init(&s->hdl, 5);\n\ts->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\n\ts->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\n\ts->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\n\ts->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\n\ts->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\n\tif (s->hdl.error) {\n\t\tret = s->hdl.error;\n\t\tdev_err(s->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_free_controls;\n\t}\n\n\tv4l2_ctrl_handler_setup(&s->hdl);\n\n\ts->v4l2_dev.ctrl_handler = &s->hdl;\n\ts->vdev.v4l2_dev = &s->v4l2_dev;\n\ts->vdev.lock = &s->v4l2_lock;\n\n\tret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\n\t\t\t\tret);\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\tdev_info(s->dev, \"Registered as %s\\n\",\n\t\t\tvideo_device_node_name(&s->vdev));\n\tdev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\n\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&s->hdl);\nerr_unregister_v4l2_dev:\n\tv4l2_device_unregister(&s->v4l2_dev);\nerr_free_mem:\n\tkfree(s);\n\treturn ret;\n}\n\n/* USB device ID list */\nstatic struct usb_device_id airspy_id_table[] = {\n\t{ USB_DEVICE(0x1d50, 0x60a1) }, /* AirSpy */\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, airspy_id_table);\n\n/* USB subsystem interface */\nstatic struct usb_driver airspy_driver = {\n\t.name                     = KBUILD_MODNAME,\n\t.probe                    = airspy_probe,\n\t.disconnect               = airspy_disconnect,\n\t.id_table                 = airspy_id_table,\n};\n\nmodule_usb_driver(airspy_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"AirSpy SDR\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * AirSpy SDR driver\n *\n * Copyright (C) 2014 Antti Palosaari <crope@iki.fi>\n *\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n/* AirSpy USB API commands (from AirSpy Library) */\nenum {\n\tCMD_INVALID                       = 0x00,\n\tCMD_RECEIVER_MODE                 = 0x01,\n\tCMD_SI5351C_WRITE                 = 0x02,\n\tCMD_SI5351C_READ                  = 0x03,\n\tCMD_R820T_WRITE                   = 0x04,\n\tCMD_R820T_READ                    = 0x05,\n\tCMD_SPIFLASH_ERASE                = 0x06,\n\tCMD_SPIFLASH_WRITE                = 0x07,\n\tCMD_SPIFLASH_READ                 = 0x08,\n\tCMD_BOARD_ID_READ                 = 0x09,\n\tCMD_VERSION_STRING_READ           = 0x0a,\n\tCMD_BOARD_PARTID_SERIALNO_READ    = 0x0b,\n\tCMD_SET_SAMPLE_RATE               = 0x0c,\n\tCMD_SET_FREQ                      = 0x0d,\n\tCMD_SET_LNA_GAIN                  = 0x0e,\n\tCMD_SET_MIXER_GAIN                = 0x0f,\n\tCMD_SET_VGA_GAIN                  = 0x10,\n\tCMD_SET_LNA_AGC                   = 0x11,\n\tCMD_SET_MIXER_AGC                 = 0x12,\n\tCMD_SET_PACKING                   = 0x13,\n};\n\n/*\n *       bEndpointAddress     0x81  EP 1 IN\n *         Transfer Type            Bulk\n *       wMaxPacketSize     0x0200  1x 512 bytes\n */\n#define MAX_BULK_BUFS            (6)\n#define BULK_BUFFER_SIZE         (128 * 512)\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   = 20000000,\n\t\t.rangehigh  = 20000000,\n\t},\n};\n\nstatic const struct v4l2_frequency_band bands_rf[] = {\n\t{\n\t\t.tuner = 1,\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =   24000000,\n\t\t.rangehigh  = 1750000000,\n\t},\n};\n\n/* stream formats */\nstruct airspy_format {\n\tchar\t*name;\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\n\n/* format descriptions for capture and preview */\nstatic struct airspy_format formats[] = {\n\t{\n\t\t.name\t\t= \"Real U12LE\",\n\t\t.pixelformat\t= V4L2_SDR_FMT_RU12LE,\n\t\t.buffersize\t= BULK_BUFFER_SIZE,\n\t},\n};\n\nstatic const unsigned int NUM_FORMATS = ARRAY_SIZE(formats);\n\n/* intermediate buffers with raw data from the USB device */\nstruct airspy_frame_buf {\n\t/* common v4l buffer stuff -- must be first */\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstruct airspy {\n#define POWER_ON\t   1\n#define USB_STATE_URB_BUF  2\n\tunsigned long flags;\n\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\n\t/* videobuf2 queue and queued buffers list */\n\tstruct vb2_queue vb_queue;\n\tstruct list_head queued_bufs;\n\tspinlock_t queued_bufs_lock; /* Protects queued_bufs */\n\tunsigned sequence;\t     /* Buffer sequence counter */\n\tunsigned int vb_full;        /* vb is full and packets dropped */\n\n\t/* Note if taking both locks v4l2_lock must always be locked first! */\n\tstruct mutex v4l2_lock;      /* Protects everything else */\n\tstruct mutex vb_queue_lock;  /* Protects vb_queue and capt_file */\n\n\tstruct urb     *urb_list[MAX_BULK_BUFS];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8             *buf_list[MAX_BULK_BUFS];\n\tdma_addr_t     dma_addr[MAX_BULK_BUFS];\n\tint            urbs_initialized;\n\tint            urbs_submitted;\n\n\t/* USB control message buffer */\n\t#define BUF_SIZE 128\n\tu8 buf[BUF_SIZE];\n\n\t/* Current configuration */\n\tunsigned int f_adc;\n\tunsigned int f_rf;\n\tu32 pixelformat;\n\tu32 buffersize;\n\n\t/* Controls */\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *lna_gain_auto;\n\tstruct v4l2_ctrl *lna_gain;\n\tstruct v4l2_ctrl *mixer_gain_auto;\n\tstruct v4l2_ctrl *mixer_gain;\n\tstruct v4l2_ctrl *if_gain;\n\n\t/* Sample rate calc */\n\tunsigned long jiffies_next;\n\tunsigned int sample;\n\tunsigned int sample_measured;\n};\n\n#define airspy_dbg_usb_control_msg(_dev, _r, _t, _v, _i, _b, _l) { \\\n\tchar *_direction; \\\n\tif (_t & USB_DIR_IN) \\\n\t\t_direction = \"<<<\"; \\\n\telse \\\n\t\t_direction = \">>>\"; \\\n\tdev_dbg(_dev, \"%02x %02x %02x %02x %02x %02x %02x %02x %s %*ph\\n\", \\\n\t\t\t_t, _r, _v & 0xff, _v >> 8, _i & 0xff, _i >> 8, \\\n\t\t\t_l & 0xff, _l >> 8, _direction, _l, _b); \\\n}\n\n/* execute firmware command */\nstatic int airspy_ctrl_msg(struct airspy *s, u8 request, u16 value, u16 index,\n\t\tu8 *data, u16 size)\n{\n\tint ret;\n\tunsigned int pipe;\n\tu8 requesttype;\n\n\tswitch (request) {\n\tcase CMD_RECEIVER_MODE:\n\tcase CMD_SET_FREQ:\n\t\tpipe = usb_sndctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tbreak;\n\tcase CMD_BOARD_ID_READ:\n\tcase CMD_VERSION_STRING_READ:\n\tcase CMD_BOARD_PARTID_SERIALNO_READ:\n\tcase CMD_SET_LNA_GAIN:\n\tcase CMD_SET_MIXER_GAIN:\n\tcase CMD_SET_VGA_GAIN:\n\tcase CMD_SET_LNA_AGC:\n\tcase CMD_SET_MIXER_AGC:\n\t\tpipe = usb_rcvctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(s->dev, \"Unknown command %02x\\n\", request);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* write request */\n\tif (!(requesttype & USB_DIR_IN))\n\t\tmemcpy(s->buf, data, size);\n\n\tret = usb_control_msg(s->udev, pipe, request, requesttype, value,\n\t\t\tindex, s->buf, size, 1000);\n\tairspy_dbg_usb_control_msg(s->dev, request, requesttype, value,\n\t\t\tindex, s->buf, size);\n\tif (ret < 0) {\n\t\tdev_err(s->dev, \"usb_control_msg() failed %d request %02x\\n\",\n\t\t\t\tret, request);\n\t\tgoto err;\n\t}\n\n\t/* read request */\n\tif (requesttype & USB_DIR_IN)\n\t\tmemcpy(data, s->buf, size);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\n/* Private functions */\nstatic struct airspy_frame_buf *airspy_get_next_fill_buf(struct airspy *s)\n{\n\tunsigned long flags;\n\tstruct airspy_frame_buf *buf = NULL;\n\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\n\tif (list_empty(&s->queued_bufs))\n\t\tgoto leave;\n\n\tbuf = list_entry(s->queued_bufs.next,\n\t\t\tstruct airspy_frame_buf, list);\n\tlist_del(&buf->list);\nleave:\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\n\treturn buf;\n}\n\nstatic unsigned int airspy_convert_stream(struct airspy *s,\n\t\tvoid *dst, void *src, unsigned int src_len)\n{\n\tunsigned int dst_len;\n\n\tif (s->pixelformat == V4L2_SDR_FMT_RU12LE) {\n\t\tmemcpy(dst, src, src_len);\n\t\tdst_len = src_len;\n\t} else {\n\t\tdst_len = 0;\n\t}\n\n\t/* calculate sample rate and output it in 10 seconds intervals */\n\tif (unlikely(time_is_before_jiffies(s->jiffies_next))) {\n\t\t#define MSECS 10000UL\n\t\tunsigned int msecs = jiffies_to_msecs(jiffies -\n\t\t\t\ts->jiffies_next + msecs_to_jiffies(MSECS));\n\t\tunsigned int samples = s->sample - s->sample_measured;\n\n\t\ts->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\n\t\ts->sample_measured = s->sample;\n\t\tdev_dbg(s->dev, \"slen=%u samples=%u msecs=%u sample rate=%lu\\n\",\n\t\t\t\tsrc_len, samples, msecs,\n\t\t\t\tsamples * 1000UL / msecs);\n\t}\n\n\t/* total number of samples */\n\ts->sample += src_len / 2;\n\n\treturn dst_len;\n}\n\n/*\n * This gets called for the bulk stream pipe. This is done in interrupt\n * time, so it has to be fast, not crash, and not stall. Neat.\n */\nstatic void airspy_urb_complete(struct urb *urb)\n{\n\tstruct airspy *s = urb->context;\n\tstruct airspy_frame_buf *fbuf;\n\n\tdev_dbg_ratelimited(s->dev, \"status=%d length=%d/%d errors=%d\\n\",\n\t\t\turb->status, urb->actual_length,\n\t\t\turb->transfer_buffer_length, urb->error_count);\n\n\tswitch (urb->status) {\n\tcase 0:             /* success */\n\tcase -ETIMEDOUT:    /* NAK */\n\t\tbreak;\n\tcase -ECONNRESET:   /* kill */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:            /* error */\n\t\tdev_err_ratelimited(s->dev, \"URB failed %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tif (likely(urb->actual_length > 0)) {\n\t\tvoid *ptr;\n\t\tunsigned int len;\n\t\t/* get free framebuffer */\n\t\tfbuf = airspy_get_next_fill_buf(s);\n\t\tif (unlikely(fbuf == NULL)) {\n\t\t\ts->vb_full++;\n\t\t\tdev_notice_ratelimited(s->dev,\n\t\t\t\t\t\"videobuf is full, %d packets dropped\\n\",\n\t\t\t\t\ts->vb_full);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* fill framebuffer */\n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\n\t\tlen = airspy_convert_stream(s, ptr, urb->transfer_buffer,\n\t\t\t\turb->actual_length);\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\n\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tfbuf->vb.sequence = s->sequence++;\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\nskip:\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int airspy_kill_urbs(struct airspy *s)\n{\n\tint i;\n\n\tfor (i = s->urbs_submitted - 1; i >= 0; i--) {\n\t\tdev_dbg(s->dev, \"kill urb=%d\\n\", i);\n\t\t/* stop the URB */\n\t\tusb_kill_urb(s->urb_list[i]);\n\t}\n\ts->urbs_submitted = 0;\n\n\treturn 0;\n}\n\nstatic int airspy_submit_urbs(struct airspy *s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < s->urbs_initialized; i++) {\n\t\tdev_dbg(s->dev, \"submit urb=%d\\n\", i);\n\t\tret = usb_submit_urb(s->urb_list[i], GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_err(s->dev, \"Could not submit URB no. %d - get them all back\\n\",\n\t\t\t\t\ti);\n\t\t\tairspy_kill_urbs(s);\n\t\t\treturn ret;\n\t\t}\n\t\ts->urbs_submitted++;\n\t}\n\n\treturn 0;\n}\n\nstatic int airspy_free_stream_bufs(struct airspy *s)\n{\n\tif (test_bit(USB_STATE_URB_BUF, &s->flags)) {\n\t\twhile (s->buf_num) {\n\t\t\ts->buf_num--;\n\t\t\tdev_dbg(s->dev, \"free buf=%d\\n\", s->buf_num);\n\t\t\tusb_free_coherent(s->udev, s->buf_size,\n\t\t\t\t\t  s->buf_list[s->buf_num],\n\t\t\t\t\t  s->dma_addr[s->buf_num]);\n\t\t}\n\t}\n\tclear_bit(USB_STATE_URB_BUF, &s->flags);\n\n\treturn 0;\n}\n\nstatic int airspy_alloc_stream_bufs(struct airspy *s)\n{\n\ts->buf_num = 0;\n\ts->buf_size = BULK_BUFFER_SIZE;\n\n\tdev_dbg(s->dev, \"all in all I will use %u bytes for streaming\\n\",\n\t\t\tMAX_BULK_BUFS * BULK_BUFFER_SIZE);\n\n\tfor (s->buf_num = 0; s->buf_num < MAX_BULK_BUFS; s->buf_num++) {\n\t\ts->buf_list[s->buf_num] = usb_alloc_coherent(s->udev,\n\t\t\t\tBULK_BUFFER_SIZE, GFP_ATOMIC,\n\t\t\t\t&s->dma_addr[s->buf_num]);\n\t\tif (!s->buf_list[s->buf_num]) {\n\t\t\tdev_dbg(s->dev, \"alloc buf=%d failed\\n\", s->buf_num);\n\t\t\tairspy_free_stream_bufs(s);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_dbg(s->dev, \"alloc buf=%d %p (dma %llu)\\n\", s->buf_num,\n\t\t\t\ts->buf_list[s->buf_num],\n\t\t\t\t(long long)s->dma_addr[s->buf_num]);\n\t\tset_bit(USB_STATE_URB_BUF, &s->flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int airspy_free_urbs(struct airspy *s)\n{\n\tint i;\n\n\tairspy_kill_urbs(s);\n\n\tfor (i = s->urbs_initialized - 1; i >= 0; i--) {\n\t\tif (s->urb_list[i]) {\n\t\t\tdev_dbg(s->dev, \"free urb=%d\\n\", i);\n\t\t\t/* free the URBs */\n\t\t\tusb_free_urb(s->urb_list[i]);\n\t\t}\n\t}\n\ts->urbs_initialized = 0;\n\n\treturn 0;\n}\n\nstatic int airspy_alloc_urbs(struct airspy *s)\n{\n\tint i, j;\n\n\t/* allocate the URBs */\n\tfor (i = 0; i < MAX_BULK_BUFS; i++) {\n\t\tdev_dbg(s->dev, \"alloc urb=%d\\n\", i);\n\t\ts->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!s->urb_list[i]) {\n\t\t\tdev_dbg(s->dev, \"failed\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(s->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_bulk_urb(s->urb_list[i],\n\t\t\t\ts->udev,\n\t\t\t\tusb_rcvbulkpipe(s->udev, 0x81),\n\t\t\t\ts->buf_list[i],\n\t\t\t\tBULK_BUFFER_SIZE,\n\t\t\t\tairspy_urb_complete, s);\n\n\t\ts->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\ts->urb_list[i]->transfer_dma = s->dma_addr[i];\n\t\ts->urbs_initialized++;\n\t}\n\n\treturn 0;\n}\n\n/* Must be called with vb_queue_lock hold */\nstatic void airspy_cleanup_queued_bufs(struct airspy *s)\n{\n\tunsigned long flags;\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\n\twhile (!list_empty(&s->queued_bufs)) {\n\t\tstruct airspy_frame_buf *buf;\n\n\t\tbuf = list_entry(s->queued_bufs.next,\n\t\t\t\tstruct airspy_frame_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\n}\n\n/* The user yanked out the cable... */\nstatic void airspy_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v = usb_get_intfdata(intf);\n\tstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tmutex_lock(&s->vb_queue_lock);\n\tmutex_lock(&s->v4l2_lock);\n\t/* No need to keep the urbs around after disconnection */\n\ts->udev = NULL;\n\tv4l2_device_disconnect(&s->v4l2_dev);\n\tvideo_unregister_device(&s->vdev);\n\tmutex_unlock(&s->v4l2_lock);\n\tmutex_unlock(&s->vb_queue_lock);\n\n\tv4l2_device_put(&s->v4l2_dev);\n}\n\n/* Videobuf2 operations */\nstatic int airspy_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbuffers,\n\t\tunsigned int *nplanes, unsigned int sizes[], void *alloc_ctxs[])\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\n\tdev_dbg(s->dev, \"nbuffers=%d\\n\", *nbuffers);\n\n\t/* Need at least 8 buffers */\n\tif (vq->num_buffers + *nbuffers < 8)\n\t\t*nbuffers = 8 - vq->num_buffers;\n\t*nplanes = 1;\n\tsizes[0] = PAGE_ALIGN(s->buffersize);\n\n\tdev_dbg(s->dev, \"nbuffers=%d sizes[0]=%d\\n\", *nbuffers, sizes[0]);\n\treturn 0;\n}\n\nstatic void airspy_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct airspy *s = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct airspy_frame_buf *buf =\n\t\t\tcontainer_of(vbuf, struct airspy_frame_buf, vb);\n\tunsigned long flags;\n\n\t/* Check the device has not disconnected between prep and queuing */\n\tif (unlikely(!s->udev)) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\n\tlist_add_tail(&buf->list, &s->queued_bufs);\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\n}\n\nstatic int airspy_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tif (!s->udev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&s->v4l2_lock);\n\n\ts->sequence = 0;\n\n\tset_bit(POWER_ON, &s->flags);\n\n\tret = airspy_alloc_stream_bufs(s);\n\tif (ret)\n\t\tgoto err_clear_bit;\n\n\tret = airspy_alloc_urbs(s);\n\tif (ret)\n\t\tgoto err_free_stream_bufs;\n\n\tret = airspy_submit_urbs(s);\n\tif (ret)\n\t\tgoto err_free_urbs;\n\n\t/* start hardware streaming */\n\tret = airspy_ctrl_msg(s, CMD_RECEIVER_MODE, 1, 0, NULL, 0);\n\tif (ret)\n\t\tgoto err_kill_urbs;\n\n\tgoto exit_mutex_unlock;\n\nerr_kill_urbs:\n\tairspy_kill_urbs(s);\nerr_free_urbs:\n\tairspy_free_urbs(s);\nerr_free_stream_bufs:\n\tairspy_free_stream_bufs(s);\nerr_clear_bit:\n\tclear_bit(POWER_ON, &s->flags);\n\n\t/* return all queued buffers to vb2 */\n\t{\n\t\tstruct airspy_frame_buf *buf, *tmp;\n\n\t\tlist_for_each_entry_safe(buf, tmp, &s->queued_bufs, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\nexit_mutex_unlock:\n\tmutex_unlock(&s->v4l2_lock);\n\n\treturn ret;\n}\n\nstatic void airspy_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\n\tdev_dbg(s->dev, \"\\n\");\n\n\tmutex_lock(&s->v4l2_lock);\n\n\t/* stop hardware streaming */\n\tairspy_ctrl_msg(s, CMD_RECEIVER_MODE, 0, 0, NULL, 0);\n\n\tairspy_kill_urbs(s);\n\tairspy_free_urbs(s);\n\tairspy_free_stream_bufs(s);\n\n\tairspy_cleanup_queued_bufs(s);\n\n\tclear_bit(POWER_ON, &s->flags);\n\n\tmutex_unlock(&s->v4l2_lock);\n}\n\nstatic struct vb2_ops airspy_vb2_ops = {\n\t.queue_setup            = airspy_queue_setup,\n\t.buf_queue              = airspy_buf_queue,\n\t.start_streaming        = airspy_start_streaming,\n\t.stop_streaming         = airspy_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nstatic int airspy_querycap(struct file *file, void *fh,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct airspy *s = video_drvdata(file);\n\n\tstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrlcpy(cap->card, s->vdev.name, sizeof(cap->card));\n\tusb_make_path(s->udev, cap->bus_info, sizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\tV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}\n\nstatic int airspy_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int airspy_g_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\n\tf->fmt.sdr.pixelformat = s->pixelformat;\n\tf->fmt.sdr.buffersize = s->buffersize;\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\n\treturn 0;\n}\n\nstatic int airspy_s_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tstruct vb2_queue *q = &s->vb_queue;\n\tint i;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\ts->pixelformat = formats[i].pixelformat;\n\t\t\ts->buffersize = formats[i].buffersize;\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int airspy_try_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tint i;\n\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int airspy_s_tuner(struct file *file, void *priv,\n\t\tconst struct v4l2_tuner *v)\n{\n\tint ret;\n\n\tif (v->index == 0)\n\t\tret = 0;\n\telse if (v->index == 1)\n\t\tret = 0;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int airspy_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\n{\n\tint ret;\n\n\tif (v->index == 0) {\n\t\tstrlcpy(v->name, \"AirSpy ADC\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_ADC;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow  = bands[0].rangelow;\n\t\tv->rangehigh = bands[0].rangehigh;\n\t\tret = 0;\n\t} else if (v->index == 1) {\n\t\tstrlcpy(v->name, \"AirSpy RF\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_RF;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow  = bands_rf[0].rangelow;\n\t\tv->rangehigh = bands_rf[0].rangehigh;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int airspy_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\n\tif (f->tuner == 0) {\n\t\tf->type = V4L2_TUNER_ADC;\n\t\tf->frequency = s->f_adc;\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tf->frequency = s->f_rf;\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int airspy_s_frequency(struct file *file, void *priv,\n\t\tconst struct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\tu8 buf[4];\n\n\tif (f->tuner == 0) {\n\t\ts->f_adc = clamp_t(unsigned int, f->frequency,\n\t\t\t\tbands[0].rangelow,\n\t\t\t\tbands[0].rangehigh);\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\ts->f_rf = clamp_t(unsigned int, f->frequency,\n\t\t\t\tbands_rf[0].rangelow,\n\t\t\t\tbands_rf[0].rangehigh);\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tbuf[0] = (s->f_rf >>  0) & 0xff;\n\t\tbuf[1] = (s->f_rf >>  8) & 0xff;\n\t\tbuf[2] = (s->f_rf >> 16) & 0xff;\n\t\tbuf[3] = (s->f_rf >> 24) & 0xff;\n\t\tret = airspy_ctrl_msg(s, CMD_SET_FREQ, 0, 0, buf, 4);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int airspy_enum_freq_bands(struct file *file, void *priv,\n\t\tstruct v4l2_frequency_band *band)\n{\n\tint ret;\n\n\tif (band->tuner == 0) {\n\t\tif (band->index >= ARRAY_SIZE(bands)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else if (band->tuner == 1) {\n\t\tif (band->index >= ARRAY_SIZE(bands_rf)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands_rf[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops airspy_ioctl_ops = {\n\t.vidioc_querycap          = airspy_querycap,\n\n\t.vidioc_enum_fmt_sdr_cap  = airspy_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap     = airspy_g_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap     = airspy_s_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap   = airspy_try_fmt_sdr_cap,\n\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\n\t.vidioc_g_tuner           = airspy_g_tuner,\n\t.vidioc_s_tuner           = airspy_s_tuner,\n\n\t.vidioc_g_frequency       = airspy_g_frequency,\n\t.vidioc_s_frequency       = airspy_s_frequency,\n\t.vidioc_enum_freq_bands   = airspy_enum_freq_bands,\n\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\n\nstatic const struct v4l2_file_operations airspy_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\n\nstatic struct video_device airspy_template = {\n\t.name                     = \"AirSpy SDR\",\n\t.release                  = video_device_release_empty,\n\t.fops                     = &airspy_fops,\n\t.ioctl_ops                = &airspy_ioctl_ops,\n};\n\nstatic void airspy_video_release(struct v4l2_device *v)\n{\n\tstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\n\n\tv4l2_ctrl_handler_free(&s->hdl);\n\tv4l2_device_unregister(&s->v4l2_dev);\n\tkfree(s);\n}\n\nstatic int airspy_set_lna_gain(struct airspy *s)\n{\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(s->dev, \"lna auto=%d->%d val=%d->%d\\n\",\n\t\t\ts->lna_gain_auto->cur.val, s->lna_gain_auto->val,\n\t\t\ts->lna_gain->cur.val, s->lna_gain->val);\n\n\tret = airspy_ctrl_msg(s, CMD_SET_LNA_AGC, 0, s->lna_gain_auto->val,\n\t\t\t&u8tmp, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tif (s->lna_gain_auto->val == false) {\n\t\tret = airspy_ctrl_msg(s, CMD_SET_LNA_GAIN, 0, s->lna_gain->val,\n\t\t\t\t&u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tif (ret)\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int airspy_set_mixer_gain(struct airspy *s)\n{\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(s->dev, \"mixer auto=%d->%d val=%d->%d\\n\",\n\t\t\ts->mixer_gain_auto->cur.val, s->mixer_gain_auto->val,\n\t\t\ts->mixer_gain->cur.val, s->mixer_gain->val);\n\n\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_AGC, 0, s->mixer_gain_auto->val,\n\t\t\t&u8tmp, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tif (s->mixer_gain_auto->val == false) {\n\t\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_GAIN, 0,\n\t\t\t\ts->mixer_gain->val, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tif (ret)\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int airspy_set_if_gain(struct airspy *s)\n{\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(s->dev, \"val=%d->%d\\n\", s->if_gain->cur.val, s->if_gain->val);\n\n\tret = airspy_ctrl_msg(s, CMD_SET_VGA_GAIN, 0, s->if_gain->val,\n\t\t\t&u8tmp, 1);\n\tif (ret)\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int airspy_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct airspy *s = container_of(ctrl->handler, struct airspy, hdl);\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tret = airspy_set_lna_gain(s);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN:\n\t\tret = airspy_set_mixer_gain(s);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN:\n\t\tret = airspy_set_if_gain(s);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(s->dev, \"unknown ctrl: id=%d name=%s\\n\",\n\t\t\t\tctrl->id, ctrl->name);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops airspy_ctrl_ops = {\n\t.s_ctrl = airspy_s_ctrl,\n};\n\nstatic int airspy_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct airspy *s;\n\tint ret;\n\tu8 u8tmp, buf[BUF_SIZE];\n\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\n\tif (s == NULL) {\n\t\tdev_err(&intf->dev, \"Could not allocate memory for state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&s->v4l2_lock);\n\tmutex_init(&s->vb_queue_lock);\n\tspin_lock_init(&s->queued_bufs_lock);\n\tINIT_LIST_HEAD(&s->queued_bufs);\n\ts->dev = &intf->dev;\n\ts->udev = interface_to_usbdev(intf);\n\ts->f_adc = bands[0].rangelow;\n\ts->f_rf = bands_rf[0].rangelow;\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\n\t/* Detect device */\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not detect board\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\tbuf[BUF_SIZE - 1] = '\\0';\n\n\tdev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);\n\tdev_info(s->dev, \"Firmware version: %s\\n\", buf);\n\n\t/* Init videobuf2 queue structure */\n\ts->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\ts->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\ts->vb_queue.drv_priv = s;\n\ts->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\n\ts->vb_queue.ops = &airspy_vb2_ops;\n\ts->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\ts->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&s->vb_queue);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\t/* Init video_device structure */\n\ts->vdev = airspy_template;\n\ts->vdev.queue = &s->vb_queue;\n\ts->vdev.queue->lock = &s->vb_queue_lock;\n\tvideo_set_drvdata(&s->vdev, s);\n\n\t/* Register the v4l2_device structure */\n\ts->v4l2_dev.release = airspy_video_release;\n\tret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\n\t/* Register controls */\n\tv4l2_ctrl_handler_init(&s->hdl, 5);\n\ts->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\n\ts->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\n\ts->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\n\ts->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\n\ts->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\n\tif (s->hdl.error) {\n\t\tret = s->hdl.error;\n\t\tdev_err(s->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_free_controls;\n\t}\n\n\tv4l2_ctrl_handler_setup(&s->hdl);\n\n\ts->v4l2_dev.ctrl_handler = &s->hdl;\n\ts->vdev.v4l2_dev = &s->v4l2_dev;\n\ts->vdev.lock = &s->v4l2_lock;\n\n\tret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\n\t\t\t\tret);\n\t\tgoto err_free_controls;\n\t}\n\tdev_info(s->dev, \"Registered as %s\\n\",\n\t\t\tvideo_device_node_name(&s->vdev));\n\tdev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\n\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&s->hdl);\n\tv4l2_device_unregister(&s->v4l2_dev);\nerr_free_mem:\n\tkfree(s);\n\treturn ret;\n}\n\n/* USB device ID list */\nstatic struct usb_device_id airspy_id_table[] = {\n\t{ USB_DEVICE(0x1d50, 0x60a1) }, /* AirSpy */\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, airspy_id_table);\n\n/* USB subsystem interface */\nstatic struct usb_driver airspy_driver = {\n\t.name                     = KBUILD_MODNAME,\n\t.probe                    = airspy_probe,\n\t.disconnect               = airspy_disconnect,\n\t.id_table                 = airspy_id_table,\n};\n\nmodule_usb_driver(airspy_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"AirSpy SDR\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/media/usb/airspy/airspy.c"], "buggy_code_start_loc": [1075], "buggy_code_end_loc": [1085], "fixing_code_start_loc": [1075], "fixing_code_end_loc": [1083], "type": "CWE-119", "message": "Memory leak in the airspy_probe function in drivers/media/usb/airspy/airspy.c in the airspy USB driver in the Linux kernel before 4.7 allows local users to cause a denial of service (memory consumption) via a crafted USB device that emulates many VFL_TYPE_SDR or VFL_TYPE_SUBDEV devices and performs many connect and disconnect operations.", "other": {"cve": {"id": "CVE-2016-5400", "sourceIdentifier": "secalert@redhat.com", "published": "2016-08-06T20:59:02.720", "lastModified": "2017-09-01T01:29:28.837", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leak in the airspy_probe function in drivers/media/usb/airspy/airspy.c in the airspy USB driver in the Linux kernel before 4.7 allows local users to cause a denial of service (memory consumption) via a crafted USB device that emulates many VFL_TYPE_SDR or VFL_TYPE_SUBDEV devices and performs many connect and disconnect operations."}, {"lang": "es", "value": "P\u00e9rdida de memoria en la funci\u00f3n airspy_probe en drivers/media/usb/airspy/airspy.c en el controlador USB airspy en el kernel de Linux en versiones anteriores a 4.7 permite a usuarios locales provocar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de un dispositivo USB manipulado que emula muchos dispositivos VFL_TYPE_SDR o VFL_TYPE_SUBDEV y realiza muchas operaciones de conexi\u00f3n y desconexi\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.6.6", "matchCriteriaId": "52847A0D-725D-40BB-B852-8937D886C0E1"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aa93d1fee85c890a34f2510a310e55ee76a27848", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/25/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92104", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1036432", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-3070-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-3070-2", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-3070-3", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-3070-4", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1358184", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848"}}