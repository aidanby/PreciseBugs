{"buggy_code": ["/*\n * taskstats.c - Export per-task statistics to userland\n *\n * Copyright (C) Shailabh Nagar, IBM Corp. 2006\n *           (C) Balbir Singh,   IBM Corp. 2006\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/taskstats_kern.h>\n#include <linux/tsacct_kern.h>\n#include <linux/delayacct.h>\n#include <linux/cpumask.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/cgroupstats.h>\n#include <linux/cgroup.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <net/genetlink.h>\n#include <linux/atomic.h>\n\n/*\n * Maximum length of a cpumask that can be specified in\n * the TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK attribute\n */\n#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic int family_registered;\nstruct kmem_cache *taskstats_cache;\n\nstatic struct genl_family family = {\n\t.id\t\t= GENL_ID_GENERATE,\n\t.name\t\t= TASKSTATS_GENL_NAME,\n\t.version\t= TASKSTATS_GENL_VERSION,\n\t.maxattr\t= TASKSTATS_CMD_ATTR_MAX,\n};\n\nstatic const struct nla_policy taskstats_cmd_get_policy[TASKSTATS_CMD_ATTR_MAX+1] = {\n\t[TASKSTATS_CMD_ATTR_PID]  = { .type = NLA_U32 },\n\t[TASKSTATS_CMD_ATTR_TGID] = { .type = NLA_U32 },\n\t[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK] = { .type = NLA_STRING },\n\t[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK] = { .type = NLA_STRING },};\n\nstatic const struct nla_policy cgroupstats_cmd_get_policy[CGROUPSTATS_CMD_ATTR_MAX+1] = {\n\t[CGROUPSTATS_CMD_ATTR_FD] = { .type = NLA_U32 },\n};\n\nstruct listener {\n\tstruct list_head list;\n\tpid_t pid;\n\tchar valid;\n};\n\nstruct listener_list {\n\tstruct rw_semaphore sem;\n\tstruct list_head list;\n};\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nenum actions {\n\tREGISTER,\n\tDEREGISTER,\n\tCPU_DONT_CARE\n};\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}\n\n/*\n * Send taskstats data in @skb to listener with nl_pid @pid\n */\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc;\n\n\trc = genlmsg_end(skb, reply);\n\tif (rc < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn rc;\n\t}\n\n\treturn genlmsg_reply(skb, info);\n}\n\n/*\n * Send taskstats data in @skb to listeners registered for @cpu's exit data\n */\nstatic void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc, delcount = 0;\n\n\trc = genlmsg_end(skb, reply);\n\tif (rc < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn;\n\t}\n\n\trc = 0;\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t/* Delete invalidated entries */\n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}\n\nstatic void fill_stats(struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}\n\nstatic int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\trcu_read_lock();\n\ttsk = find_task_by_vpid(pid);\n\tif (tsk)\n\t\tget_task_struct(tsk);\n\trcu_read_unlock();\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}\n\nstatic int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}\n\nstatic void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t/*\n\t * Each accounting subsystem calls its functions here to\n\t * accumalate its per-task stats for tsk, into the per-tgid structure\n\t *\n\t *\tper-task-foo(tsk->signal->stats, tsk);\n\t */\n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}\n\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s)\n\t\t\t\tgoto cleanup;\n\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn 0;\n}\n\nstatic int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}\n\n#if defined(CONFIG_64BIT) && !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n#define TASKSTATS_NEEDS_PADDING 1\n#endif\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\t/*\n\t * The taskstats structure is internally aligned on 8 byte\n\t * boundaries but the layout of the aggregrate reply, with\n\t * two NLA headers and the pid (each 4 bytes), actually\n\t * force the entire structure to be unaligned. This causes\n\t * the kernel to issue unaligned access warnings on some\n\t * architectures like ia64. Unfortunately, some software out there\n\t * doesn't properly unroll the NLA packet and assumes that the start\n\t * of the taskstats structure will always be 20 bytes from the start\n\t * of the netlink payload. Aligning the start of the taskstats\n\t * structure breaks this software, which we don't want. So, for now\n\t * the alignment only happens on architectures that require it\n\t * and those users will have to update to fixed versions of those\n\t * packages. Space is reserved in the packet only when needed.\n\t * This ifdef should be removed in several years e.g. 2012 once\n\t * we can be confident that fixed versions are installed on most\n\t * systems. We add the padding before the aggregate since the\n\t * aggregate is already a defined type.\n\t */\n#ifdef TASKSTATS_NEEDS_PADDING\n\tif (nla_put(skb, TASKSTATS_TYPE_NULL, 0, NULL) < 0)\n\t\tgoto err;\n#endif\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0)\n\t\tgoto err;\n\tret = nla_reserve(skb, TASKSTATS_TYPE_STATS, sizeof(struct taskstats));\n\tif (!ret)\n\t\tgoto err;\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}\n\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct file *file;\n\tint fput_needed;\n\n\tna = info->attrs[CGROUPSTATS_CMD_ATTR_FD];\n\tif (!na)\n\t\treturn -EINVAL;\n\n\tfd = nla_get_u32(info->attrs[CGROUPSTATS_CMD_ATTR_FD]);\n\tfile = fget_light(fd, &fput_needed);\n\tif (!file)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct cgroupstats));\n\n\trc = prepare_reply(info, CGROUPSTATS_CMD_NEW, &rep_skb,\n\t\t\t\tsize);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, CGROUPSTATS_TYPE_CGROUP_STATS,\n\t\t\t\tsizeof(struct cgroupstats));\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, file->f_dentry);\n\tif (rc < 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfput_light(file, fput_needed);\n\treturn rc;\n}\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_pid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}\n\nstatic int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_pid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size(sizeof(struct taskstats)) + nla_total_size(0);\n#ifdef TASKSTATS_NEEDS_PADDING\n\tsize += nla_total_size(0); /* Padding for alignment */\n#endif\n\treturn size;\n}\n\nstatic int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])\n\t\treturn cmd_attr_register_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])\n\t\treturn cmd_attr_deregister_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])\n\t\treturn cmd_attr_pid(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])\n\t\treturn cmd_attr_tgid(info);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats;\n\n\tif (sig->stats || thread_group_empty(tsk))\n\t\tgoto ret;\n\n\t/* No problem if kmem_cache_zalloc() fails */\n\tstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!sig->stats) {\n\t\tsig->stats = stats;\n\t\tstats = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats)\n\t\tkmem_cache_free(taskstats_cache, stats);\nret:\n\treturn sig->stats;\n}\n\n/* Send pid data out on exit */\nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = __this_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, tsk->pid);\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tsk->tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}\n\nstatic struct genl_ops taskstats_ops = {\n\t.cmd\t\t= TASKSTATS_CMD_GET,\n\t.doit\t\t= taskstats_user_cmd,\n\t.policy\t\t= taskstats_cmd_get_policy,\n};\n\nstatic struct genl_ops cgroupstats_ops = {\n\t.cmd\t\t= CGROUPSTATS_CMD_GET,\n\t.doit\t\t= cgroupstats_user_cmd,\n\t.policy\t\t= cgroupstats_cmd_get_policy,\n};\n\n/* Needed early in initialization */\nvoid __init taskstats_init_early(void)\n{\n\tunsigned int i;\n\n\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\n\tfor_each_possible_cpu(i) {\n\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\n\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));\n\t}\n}\n\nstatic int __init taskstats_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&family);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genl_register_ops(&family, &taskstats_ops);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = genl_register_ops(&family, &cgroupstats_ops);\n\tif (rc < 0)\n\t\tgoto err_cgroup_ops;\n\n\tfamily_registered = 1;\n\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);\n\treturn 0;\nerr_cgroup_ops:\n\tgenl_unregister_ops(&family, &taskstats_ops);\nerr:\n\tgenl_unregister_family(&family);\n\treturn rc;\n}\n\n/*\n * late initcall ensures initialization of statistics collection\n * mechanisms precedes initialization of the taskstats interface\n */\nlate_initcall(taskstats_init);\n"], "fixing_code": ["/*\n * taskstats.c - Export per-task statistics to userland\n *\n * Copyright (C) Shailabh Nagar, IBM Corp. 2006\n *           (C) Balbir Singh,   IBM Corp. 2006\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/taskstats_kern.h>\n#include <linux/tsacct_kern.h>\n#include <linux/delayacct.h>\n#include <linux/cpumask.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/cgroupstats.h>\n#include <linux/cgroup.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <net/genetlink.h>\n#include <linux/atomic.h>\n\n/*\n * Maximum length of a cpumask that can be specified in\n * the TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK attribute\n */\n#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic int family_registered;\nstruct kmem_cache *taskstats_cache;\n\nstatic struct genl_family family = {\n\t.id\t\t= GENL_ID_GENERATE,\n\t.name\t\t= TASKSTATS_GENL_NAME,\n\t.version\t= TASKSTATS_GENL_VERSION,\n\t.maxattr\t= TASKSTATS_CMD_ATTR_MAX,\n};\n\nstatic const struct nla_policy taskstats_cmd_get_policy[TASKSTATS_CMD_ATTR_MAX+1] = {\n\t[TASKSTATS_CMD_ATTR_PID]  = { .type = NLA_U32 },\n\t[TASKSTATS_CMD_ATTR_TGID] = { .type = NLA_U32 },\n\t[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK] = { .type = NLA_STRING },\n\t[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK] = { .type = NLA_STRING },};\n\nstatic const struct nla_policy cgroupstats_cmd_get_policy[CGROUPSTATS_CMD_ATTR_MAX+1] = {\n\t[CGROUPSTATS_CMD_ATTR_FD] = { .type = NLA_U32 },\n};\n\nstruct listener {\n\tstruct list_head list;\n\tpid_t pid;\n\tchar valid;\n};\n\nstruct listener_list {\n\tstruct rw_semaphore sem;\n\tstruct list_head list;\n};\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nenum actions {\n\tREGISTER,\n\tDEREGISTER,\n\tCPU_DONT_CARE\n};\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}\n\n/*\n * Send taskstats data in @skb to listener with nl_pid @pid\n */\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc;\n\n\trc = genlmsg_end(skb, reply);\n\tif (rc < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn rc;\n\t}\n\n\treturn genlmsg_reply(skb, info);\n}\n\n/*\n * Send taskstats data in @skb to listeners registered for @cpu's exit data\n */\nstatic void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc, delcount = 0;\n\n\trc = genlmsg_end(skb, reply);\n\tif (rc < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn;\n\t}\n\n\trc = 0;\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t/* Delete invalidated entries */\n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}\n\nstatic void fill_stats(struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}\n\nstatic int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\trcu_read_lock();\n\ttsk = find_task_by_vpid(pid);\n\tif (tsk)\n\t\tget_task_struct(tsk);\n\trcu_read_unlock();\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}\n\nstatic int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}\n\nstatic void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t/*\n\t * Each accounting subsystem calls its functions here to\n\t * accumalate its per-task stats for tsk, into the per-tgid structure\n\t *\n\t *\tper-task-foo(tsk->signal->stats, tsk);\n\t */\n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}\n\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s)\n\t\t\t\tgoto cleanup;\n\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn 0;\n}\n\nstatic int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}\n\n#if defined(CONFIG_64BIT) && !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n#define TASKSTATS_NEEDS_PADDING 1\n#endif\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\t/*\n\t * The taskstats structure is internally aligned on 8 byte\n\t * boundaries but the layout of the aggregrate reply, with\n\t * two NLA headers and the pid (each 4 bytes), actually\n\t * force the entire structure to be unaligned. This causes\n\t * the kernel to issue unaligned access warnings on some\n\t * architectures like ia64. Unfortunately, some software out there\n\t * doesn't properly unroll the NLA packet and assumes that the start\n\t * of the taskstats structure will always be 20 bytes from the start\n\t * of the netlink payload. Aligning the start of the taskstats\n\t * structure breaks this software, which we don't want. So, for now\n\t * the alignment only happens on architectures that require it\n\t * and those users will have to update to fixed versions of those\n\t * packages. Space is reserved in the packet only when needed.\n\t * This ifdef should be removed in several years e.g. 2012 once\n\t * we can be confident that fixed versions are installed on most\n\t * systems. We add the padding before the aggregate since the\n\t * aggregate is already a defined type.\n\t */\n#ifdef TASKSTATS_NEEDS_PADDING\n\tif (nla_put(skb, TASKSTATS_TYPE_NULL, 0, NULL) < 0)\n\t\tgoto err;\n#endif\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0)\n\t\tgoto err;\n\tret = nla_reserve(skb, TASKSTATS_TYPE_STATS, sizeof(struct taskstats));\n\tif (!ret)\n\t\tgoto err;\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}\n\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct file *file;\n\tint fput_needed;\n\n\tna = info->attrs[CGROUPSTATS_CMD_ATTR_FD];\n\tif (!na)\n\t\treturn -EINVAL;\n\n\tfd = nla_get_u32(info->attrs[CGROUPSTATS_CMD_ATTR_FD]);\n\tfile = fget_light(fd, &fput_needed);\n\tif (!file)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct cgroupstats));\n\n\trc = prepare_reply(info, CGROUPSTATS_CMD_NEW, &rep_skb,\n\t\t\t\tsize);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, CGROUPSTATS_TYPE_CGROUP_STATS,\n\t\t\t\tsizeof(struct cgroupstats));\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, file->f_dentry);\n\tif (rc < 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfput_light(file, fput_needed);\n\treturn rc;\n}\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_pid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}\n\nstatic int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_pid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size(sizeof(struct taskstats)) + nla_total_size(0);\n#ifdef TASKSTATS_NEEDS_PADDING\n\tsize += nla_total_size(0); /* Padding for alignment */\n#endif\n\treturn size;\n}\n\nstatic int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])\n\t\treturn cmd_attr_register_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])\n\t\treturn cmd_attr_deregister_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])\n\t\treturn cmd_attr_pid(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])\n\t\treturn cmd_attr_tgid(info);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats;\n\n\tif (sig->stats || thread_group_empty(tsk))\n\t\tgoto ret;\n\n\t/* No problem if kmem_cache_zalloc() fails */\n\tstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!sig->stats) {\n\t\tsig->stats = stats;\n\t\tstats = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats)\n\t\tkmem_cache_free(taskstats_cache, stats);\nret:\n\treturn sig->stats;\n}\n\n/* Send pid data out on exit */\nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = __this_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, tsk->pid);\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tsk->tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}\n\nstatic struct genl_ops taskstats_ops = {\n\t.cmd\t\t= TASKSTATS_CMD_GET,\n\t.doit\t\t= taskstats_user_cmd,\n\t.policy\t\t= taskstats_cmd_get_policy,\n\t.flags\t\t= GENL_ADMIN_PERM,\n};\n\nstatic struct genl_ops cgroupstats_ops = {\n\t.cmd\t\t= CGROUPSTATS_CMD_GET,\n\t.doit\t\t= cgroupstats_user_cmd,\n\t.policy\t\t= cgroupstats_cmd_get_policy,\n};\n\n/* Needed early in initialization */\nvoid __init taskstats_init_early(void)\n{\n\tunsigned int i;\n\n\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\n\tfor_each_possible_cpu(i) {\n\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\n\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));\n\t}\n}\n\nstatic int __init taskstats_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&family);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genl_register_ops(&family, &taskstats_ops);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = genl_register_ops(&family, &cgroupstats_ops);\n\tif (rc < 0)\n\t\tgoto err_cgroup_ops;\n\n\tfamily_registered = 1;\n\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);\n\treturn 0;\nerr_cgroup_ops:\n\tgenl_unregister_ops(&family, &taskstats_ops);\nerr:\n\tgenl_unregister_family(&family);\n\treturn rc;\n}\n\n/*\n * late initcall ensures initialization of statistics collection\n * mechanisms precedes initialization of the taskstats interface\n */\nlate_initcall(taskstats_init);\n"], "filenames": ["kernel/taskstats.c"], "buggy_code_start_loc": [657], "buggy_code_end_loc": [657], "fixing_code_start_loc": [658], "fixing_code_end_loc": [659], "type": "CWE-200", "message": "kernel/taskstats.c in the Linux kernel before 3.1 allows local users to obtain sensitive I/O statistics by sending taskstats commands to a netlink socket, as demonstrated by discovering the length of another user's password.", "other": {"cve": {"id": "CVE-2011-2494", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:55.780", "lastModified": "2023-02-13T00:18:02.510", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "kernel/taskstats.c in the Linux kernel before 3.1 allows local users to obtain sensitive I/O statistics by sending taskstats commands to a netlink socket, as demonstrated by discovering the length of another user's password."}, {"lang": "es", "value": "kernel/taskstats.c del kernel de Linux en versiones anteriores a la 3.1 permite a usuarios locales obtener informaci\u00f3n confidencial de estad\u00edsticas de I/O enviando comandos taskstats al socket netlink, tal como se ha demostrado descubriendo la longitud de la contrase\u00f1a de otro usuario."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.34", "matchCriteriaId": "2C8D5D79-7C04-470B-BBE8-339D4E176451"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=1a51410abe7d0ee4b1d112780f46df87d3621043", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-04/msg00021.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/06/27/1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=716842", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/1a51410abe7d0ee4b1d112780f46df87d3621043", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1a51410abe7d0ee4b1d112780f46df87d3621043"}}