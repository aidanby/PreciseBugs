{"buggy_code": ["/*\n *    Copyright IBM Corp. 2007, 2009\n *    Author(s): Utz Bacher <utz.bacher@de.ibm.com>,\n *\t\t Frank Pavlic <fpavlic@de.ibm.com>,\n *\t\t Thomas Spatzier <tspat@de.ibm.com>,\n *\t\t Frank Blaschka <frank.blaschka@de.ibm.com>\n */\n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/mii.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <net/iucv/af_iucv.h>\n\n#include <asm/ebcdic.h>\n#include <asm/io.h>\n#include <asm/sysinfo.h>\n#include <asm/compat.h>\n\n#include \"qeth_core.h\"\n\nstruct qeth_dbf_info qeth_dbf[QETH_DBF_INFOS] = {\n\t/* define dbf - Name, Pages, Areas, Maxlen, Level, View, Handle */\n\t/*                   N  P  A    M  L  V                      H  */\n\t[QETH_DBF_SETUP] = {\"qeth_setup\",\n\t\t\t\t8, 1,   8, 5, &debug_hex_ascii_view, NULL},\n\t[QETH_DBF_MSG]   = {\"qeth_msg\",\n\t\t\t\t8, 1, 128, 3, &debug_sprintf_view,   NULL},\n\t[QETH_DBF_CTRL]  = {\"qeth_control\",\n\t\t8, 1, QETH_DBF_CTRL_LEN, 5, &debug_hex_ascii_view, NULL},\n};\nEXPORT_SYMBOL_GPL(qeth_dbf);\n\nstruct qeth_card_list_struct qeth_core_card_list;\nEXPORT_SYMBOL_GPL(qeth_core_card_list);\nstruct kmem_cache *qeth_core_header_cache;\nEXPORT_SYMBOL_GPL(qeth_core_header_cache);\nstatic struct kmem_cache *qeth_qdio_outbuf_cache;\n\nstatic struct device *qeth_core_root_dev;\nstatic unsigned int known_devices[][6] = QETH_MODELLIST_ARRAY;\nstatic struct lock_class_key qdio_out_skb_queue_key;\nstatic struct mutex qeth_mod_mutex;\n\nstatic void qeth_send_control_data_cb(struct qeth_channel *,\n\t\t\tstruct qeth_cmd_buffer *);\nstatic int qeth_issue_next_read(struct qeth_card *);\nstatic struct qeth_cmd_buffer *qeth_get_buffer(struct qeth_channel *);\nstatic void qeth_setup_ccw(struct qeth_channel *, unsigned char *, __u32);\nstatic void qeth_free_buffer_pool(struct qeth_card *);\nstatic int qeth_qdio_establish(struct qeth_card *);\nstatic void qeth_free_qdio_buffers(struct qeth_card *);\nstatic void qeth_notify_skbs(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum iucv_tx_notify notification);\nstatic void qeth_release_skbs(struct qeth_qdio_out_buffer *buf);\nstatic void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum qeth_qdio_buffer_states newbufstate);\nstatic int qeth_init_qdio_out_buf(struct qeth_qdio_out_q *, int);\n\nstatic struct workqueue_struct *qeth_wq;\n\nstatic void qeth_close_dev_handler(struct work_struct *work)\n{\n\tstruct qeth_card *card;\n\n\tcard = container_of(work, struct qeth_card, close_dev_work);\n\tQETH_CARD_TEXT(card, 2, \"cldevhdl\");\n\trtnl_lock();\n\tdev_close(card->dev);\n\trtnl_unlock();\n\tccwgroup_set_offline(card->gdev);\n}\n\nvoid qeth_close_dev(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"cldevsubm\");\n\tqueue_work(qeth_wq, &card->close_dev_work);\n}\nEXPORT_SYMBOL_GPL(qeth_close_dev);\n\nstatic inline const char *qeth_get_cardname(struct qeth_card *card)\n{\n\tif (card->info.guestlan) {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \" Virtual NIC QDIO\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \" Virtual NIC Hiper\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \" Virtual NIC QDIO - OSM\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \" Virtual NIC QDIO - OSX\";\n\t\tdefault:\n\t\t\treturn \" unknown\";\n\t\t}\n\t} else {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \" OSD Express\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \" HiperSockets\";\n\t\tcase QETH_CARD_TYPE_OSN:\n\t\t\treturn \" OSN QDIO\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \" OSM QDIO\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \" OSX QDIO\";\n\t\tdefault:\n\t\t\treturn \" unknown\";\n\t\t}\n\t}\n\treturn \" n/a\";\n}\n\n/* max length to be returned: 14 */\nconst char *qeth_get_cardname_short(struct qeth_card *card)\n{\n\tif (card->info.guestlan) {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \"Virt.NIC QDIO\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \"Virt.NIC Hiper\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \"Virt.NIC OSM\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \"Virt.NIC OSX\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t\t}\n\t} else {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\tswitch (card->info.link_type) {\n\t\t\tcase QETH_LINK_TYPE_FAST_ETH:\n\t\t\t\treturn \"OSD_100\";\n\t\t\tcase QETH_LINK_TYPE_HSTR:\n\t\t\t\treturn \"HSTR\";\n\t\t\tcase QETH_LINK_TYPE_GBIT_ETH:\n\t\t\t\treturn \"OSD_1000\";\n\t\t\tcase QETH_LINK_TYPE_10GBIT_ETH:\n\t\t\t\treturn \"OSD_10GIG\";\n\t\t\tcase QETH_LINK_TYPE_LANE_ETH100:\n\t\t\t\treturn \"OSD_FE_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\t\treturn \"OSD_TR_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE_ETH1000:\n\t\t\t\treturn \"OSD_GbE_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE:\n\t\t\t\treturn \"OSD_ATM_LANE\";\n\t\t\tdefault:\n\t\t\t\treturn \"OSD_Express\";\n\t\t\t}\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \"HiperSockets\";\n\t\tcase QETH_CARD_TYPE_OSN:\n\t\t\treturn \"OSN\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \"OSM_1000\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \"OSX_10GIG\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t\t}\n\t}\n\treturn \"n/a\";\n}\n\nvoid qeth_set_recovery_task(struct qeth_card *card)\n{\n\tcard->recovery_task = current;\n}\nEXPORT_SYMBOL_GPL(qeth_set_recovery_task);\n\nvoid qeth_clear_recovery_task(struct qeth_card *card)\n{\n\tcard->recovery_task = NULL;\n}\nEXPORT_SYMBOL_GPL(qeth_clear_recovery_task);\n\nstatic bool qeth_is_recovery_task(const struct qeth_card *card)\n{\n\treturn card->recovery_task == current;\n}\n\nvoid qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,\n\t\t\t int clear_start_mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_allowed_mask = threads;\n\tif (clear_start_mask)\n\t\tcard->thread_start_mask &= threads;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_set_allowed_threads);\n\nint qeth_threads_running(struct qeth_card *card, unsigned long threads)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\trc = (card->thread_running_mask & threads);\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_threads_running);\n\nint qeth_wait_for_threads(struct qeth_card *card, unsigned long threads)\n{\n\tif (qeth_is_recovery_task(card))\n\t\treturn 0;\n\treturn wait_event_interruptible(card->wait_q,\n\t\t\tqeth_threads_running(card, threads) == 0);\n}\nEXPORT_SYMBOL_GPL(qeth_wait_for_threads);\n\nvoid qeth_clear_working_pool_list(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry, *tmp;\n\n\tQETH_CARD_TEXT(card, 5, \"clwrklst\");\n\tlist_for_each_entry_safe(pool_entry, tmp,\n\t\t\t    &card->qdio.in_buf_pool.entry_list, list){\n\t\t\tlist_del(&pool_entry->list);\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_clear_working_pool_list);\n\nstatic int qeth_alloc_buffer_pool(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry;\n\tvoid *ptr;\n\tint i, j;\n\n\tQETH_CARD_TEXT(card, 5, \"alocpool\");\n\tfor (i = 0; i < card->qdio.init_pool.buf_count; ++i) {\n\t\tpool_entry = kzalloc(sizeof(*pool_entry), GFP_KERNEL);\n\t\tif (!pool_entry) {\n\t\t\tqeth_free_buffer_pool(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (j = 0; j < QETH_MAX_BUFFER_ELEMENTS(card); ++j) {\n\t\t\tptr = (void *) __get_free_page(GFP_KERNEL);\n\t\t\tif (!ptr) {\n\t\t\t\twhile (j > 0)\n\t\t\t\t\tfree_page((unsigned long)\n\t\t\t\t\t\t  pool_entry->elements[--j]);\n\t\t\t\tkfree(pool_entry);\n\t\t\t\tqeth_free_buffer_pool(card);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpool_entry->elements[j] = ptr;\n\t\t}\n\t\tlist_add(&pool_entry->init_list,\n\t\t\t &card->qdio.init_pool.entry_list);\n\t}\n\treturn 0;\n}\n\nint qeth_realloc_buffer_pool(struct qeth_card *card, int bufcnt)\n{\n\tQETH_CARD_TEXT(card, 2, \"realcbp\");\n\n\tif ((card->state != CARD_STATE_DOWN) &&\n\t    (card->state != CARD_STATE_RECOVER))\n\t\treturn -EPERM;\n\n\t/* TODO: steel/add buffers from/to a running card's buffer pool (?) */\n\tqeth_clear_working_pool_list(card);\n\tqeth_free_buffer_pool(card);\n\tcard->qdio.in_buf_pool.buf_count = bufcnt;\n\tcard->qdio.init_pool.buf_count = bufcnt;\n\treturn qeth_alloc_buffer_pool(card);\n}\nEXPORT_SYMBOL_GPL(qeth_realloc_buffer_pool);\n\nstatic inline int qeth_cq_init(struct qeth_card *card)\n{\n\tint rc;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"cqinit\");\n\t\tmemset(card->qdio.c_q->qdio_bufs, 0,\n\t\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));\n\t\tcard->qdio.c_q->next_buf_to_init = 127;\n\t\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT,\n\t\t\t     card->qdio.no_in_queues - 1, 0,\n\t\t\t     127);\n\t\tif (rc) {\n\t\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic inline int qeth_alloc_cq(struct qeth_card *card)\n{\n\tint rc;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tint i;\n\t\tstruct qdio_outbuf_state *outbuf_states;\n\n\t\tQETH_DBF_TEXT(SETUP, 2, \"cqon\");\n\t\tcard->qdio.c_q = kzalloc(sizeof(struct qeth_qdio_q),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!card->qdio.c_q) {\n\t\t\trc = -1;\n\t\t\tgoto kmsg_out;\n\t\t}\n\t\tQETH_DBF_HEX(SETUP, 2, &card->qdio.c_q, sizeof(void *));\n\n\t\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\t\tcard->qdio.c_q->bufs[i].buffer =\n\t\t\t\t&card->qdio.c_q->qdio_bufs[i];\n\t\t}\n\n\t\tcard->qdio.no_in_queues = 2;\n\n\t\tcard->qdio.out_bufstates =\n\t\t\tkzalloc(card->qdio.no_out_queues *\n\t\t\t\tQDIO_MAX_BUFFERS_PER_Q *\n\t\t\t\tsizeof(struct qdio_outbuf_state), GFP_KERNEL);\n\t\toutbuf_states = card->qdio.out_bufstates;\n\t\tif (outbuf_states == NULL) {\n\t\t\trc = -1;\n\t\t\tgoto free_cq_out;\n\t\t}\n\t\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\t\tcard->qdio.out_qs[i]->bufstates = outbuf_states;\n\t\t\toutbuf_states += QDIO_MAX_BUFFERS_PER_Q;\n\t\t}\n\t} else {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"nocq\");\n\t\tcard->qdio.c_q = NULL;\n\t\tcard->qdio.no_in_queues = 1;\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"iqc%d\", card->qdio.no_in_queues);\n\trc = 0;\nout:\n\treturn rc;\nfree_cq_out:\n\tkfree(card->qdio.c_q);\n\tcard->qdio.c_q = NULL;\nkmsg_out:\n\tdev_err(&card->gdev->dev, \"Failed to create completion queue\\n\");\n\tgoto out;\n}\n\nstatic inline void qeth_free_cq(struct qeth_card *card)\n{\n\tif (card->qdio.c_q) {\n\t\t--card->qdio.no_in_queues;\n\t\tkfree(card->qdio.c_q);\n\t\tcard->qdio.c_q = NULL;\n\t}\n\tkfree(card->qdio.out_bufstates);\n\tcard->qdio.out_bufstates = NULL;\n}\n\nstatic inline enum iucv_tx_notify qeth_compute_cq_notification(int sbalf15,\n\tint delayed) {\n\tenum iucv_tx_notify n;\n\n\tswitch (sbalf15) {\n\tcase 0:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_OK : TX_NOTIFY_OK;\n\t\tbreak;\n\tcase 4:\n\tcase 16:\n\tcase 17:\n\tcase 18:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_UNREACHABLE :\n\t\t\tTX_NOTIFY_UNREACHABLE;\n\t\tbreak;\n\tdefault:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_GENERALERROR :\n\t\t\tTX_NOTIFY_GENERALERROR;\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n\nstatic inline void qeth_cleanup_handled_pending(struct qeth_qdio_out_q *q,\n\tint bidx, int forced_cleanup)\n{\n\tif (q->card->options.cq != QETH_CQ_ENABLED)\n\t\treturn;\n\n\tif (q->bufs[bidx]->next_pending != NULL) {\n\t\tstruct qeth_qdio_out_buffer *head = q->bufs[bidx];\n\t\tstruct qeth_qdio_out_buffer *c = q->bufs[bidx]->next_pending;\n\n\t\twhile (c) {\n\t\t\tif (forced_cleanup ||\n\t\t\t    atomic_read(&c->state) ==\n\t\t\t      QETH_QDIO_BUF_HANDLED_DELAYED) {\n\t\t\t\tstruct qeth_qdio_out_buffer *f = c;\n\t\t\t\tQETH_CARD_TEXT(f->q->card, 5, \"fp\");\n\t\t\t\tQETH_CARD_TEXT_(f->q->card, 5, \"%lx\", (long) f);\n\t\t\t\t/* release here to avoid interleaving between\n\t\t\t\t   outbound tasklet and inbound tasklet\n\t\t\t\t   regarding notifications and lifecycle */\n\t\t\t\tqeth_release_skbs(c);\n\n\t\t\t\tc = f->next_pending;\n\t\t\t\tWARN_ON_ONCE(head->next_pending != f);\n\t\t\t\thead->next_pending = c;\n\t\t\t\tkmem_cache_free(qeth_qdio_outbuf_cache, f);\n\t\t\t} else {\n\t\t\t\thead = c;\n\t\t\t\tc = c->next_pending;\n\t\t\t}\n\n\t\t}\n\t}\n\tif (forced_cleanup && (atomic_read(&(q->bufs[bidx]->state)) ==\n\t\t\t\t\tQETH_QDIO_BUF_HANDLED_DELAYED)) {\n\t\t/* for recovery situations */\n\t\tq->bufs[bidx]->aob = q->bufstates[bidx].aob;\n\t\tqeth_init_qdio_out_buf(q, bidx);\n\t\tQETH_CARD_TEXT(q->card, 2, \"clprecov\");\n\t}\n}\n\n\nstatic inline void qeth_qdio_handle_aob(struct qeth_card *card,\n\t\tunsigned long phys_aob_addr) {\n\tstruct qaob *aob;\n\tstruct qeth_qdio_out_buffer *buffer;\n\tenum iucv_tx_notify notification;\n\n\taob = (struct qaob *) phys_to_virt(phys_aob_addr);\n\tQETH_CARD_TEXT(card, 5, \"haob\");\n\tQETH_CARD_TEXT_(card, 5, \"%lx\", phys_aob_addr);\n\tbuffer = (struct qeth_qdio_out_buffer *) aob->user1;\n\tQETH_CARD_TEXT_(card, 5, \"%lx\", aob->user1);\n\n\tif (atomic_cmpxchg(&buffer->state, QETH_QDIO_BUF_PRIMED,\n\t\t\t   QETH_QDIO_BUF_IN_CQ) == QETH_QDIO_BUF_PRIMED) {\n\t\tnotification = TX_NOTIFY_OK;\n\t} else {\n\t\tWARN_ON_ONCE(atomic_read(&buffer->state) !=\n\t\t\t\t\t\t\tQETH_QDIO_BUF_PENDING);\n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_IN_CQ);\n\t\tnotification = TX_NOTIFY_DELAYED_OK;\n\t}\n\n\tif (aob->aorc != 0)  {\n\t\tQETH_CARD_TEXT_(card, 2, \"aorc%02X\", aob->aorc);\n\t\tnotification = qeth_compute_cq_notification(aob->aorc, 1);\n\t}\n\tqeth_notify_skbs(buffer->q, buffer, notification);\n\n\tbuffer->aob = NULL;\n\tqeth_clear_output_buffer(buffer->q, buffer,\n\t\t\t\t QETH_QDIO_BUF_HANDLED_DELAYED);\n\n\t/* from here on: do not touch buffer anymore */\n\tqdio_release_aob(aob);\n}\n\nstatic inline int qeth_is_cq(struct qeth_card *card, unsigned int queue)\n{\n\treturn card->options.cq == QETH_CQ_ENABLED &&\n\t    card->qdio.c_q != NULL &&\n\t    queue != 0 &&\n\t    queue == card->qdio.no_in_queues - 1;\n}\n\n\nstatic int qeth_issue_next_read(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 5, \"issnxrd\");\n\tif (card->read.state != CH_STATE_UP)\n\t\treturn -EIO;\n\tiob = qeth_get_buffer(&card->read);\n\tif (!iob) {\n\t\tdev_warn(&card->gdev->dev, \"The qeth device driver \"\n\t\t\t\"failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"%s issue_next_read failed: no iob \"\n\t\t\t\"available\\n\", dev_name(&card->gdev->dev));\n\t\treturn -ENOMEM;\n\t}\n\tqeth_setup_ccw(&card->read, iob->data, QETH_BUFSIZE);\n\tQETH_CARD_TEXT(card, 6, \"noirqpnd\");\n\trc = ccw_device_start(card->read.ccwdev, &card->read.ccw,\n\t\t\t      (addr_t) iob, 0, 0);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"%s error in starting next read ccw! \"\n\t\t\t\"rc=%i\\n\", dev_name(&card->gdev->dev), rc);\n\t\tatomic_set(&card->read.irq_pending, 0);\n\t\tcard->read_or_write_problem = 1;\n\t\tqeth_schedule_recovery(card);\n\t\twake_up(&card->wait_q);\n\t}\n\treturn rc;\n}\n\nstatic struct qeth_reply *qeth_alloc_reply(struct qeth_card *card)\n{\n\tstruct qeth_reply *reply;\n\n\treply = kzalloc(sizeof(struct qeth_reply), GFP_ATOMIC);\n\tif (reply) {\n\t\tatomic_set(&reply->refcnt, 1);\n\t\tatomic_set(&reply->received, 0);\n\t\treply->card = card;\n\t}\n\treturn reply;\n}\n\nstatic void qeth_get_reply(struct qeth_reply *reply)\n{\n\tWARN_ON(atomic_read(&reply->refcnt) <= 0);\n\tatomic_inc(&reply->refcnt);\n}\n\nstatic void qeth_put_reply(struct qeth_reply *reply)\n{\n\tWARN_ON(atomic_read(&reply->refcnt) <= 0);\n\tif (atomic_dec_and_test(&reply->refcnt))\n\t\tkfree(reply);\n}\n\nstatic void qeth_issue_ipa_msg(struct qeth_ipa_cmd *cmd, int rc,\n\t\tstruct qeth_card *card)\n{\n\tchar *ipa_name;\n\tint com = cmd->hdr.command;\n\tipa_name = qeth_get_ipa_cmd_name(com);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"IPA: %s(x%X) for %s/%s returned \"\n\t\t\t\t\"x%X \\\"%s\\\"\\n\",\n\t\t\t\tipa_name, com, dev_name(&card->gdev->dev),\n\t\t\t\tQETH_CARD_IFNAME(card), rc,\n\t\t\t\tqeth_get_ipa_msg(rc));\n\telse\n\t\tQETH_DBF_MESSAGE(5, \"IPA: %s(x%X) for %s/%s succeeded\\n\",\n\t\t\t\tipa_name, com, dev_name(&card->gdev->dev),\n\t\t\t\tQETH_CARD_IFNAME(card));\n}\n\nstatic struct qeth_ipa_cmd *qeth_check_ipa_data(struct qeth_card *card,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_ipa_cmd *cmd = NULL;\n\n\tQETH_CARD_TEXT(card, 5, \"chkipad\");\n\tif (IS_IPA(iob->data)) {\n\t\tcmd = (struct qeth_ipa_cmd *) PDU_ENCAPSULATION(iob->data);\n\t\tif (IS_IPA_REPLY(cmd)) {\n\t\t\tif (cmd->hdr.command != IPA_CMD_SETCCID &&\n\t\t\t    cmd->hdr.command != IPA_CMD_DELCCID &&\n\t\t\t    cmd->hdr.command != IPA_CMD_MODCCID &&\n\t\t\t    cmd->hdr.command != IPA_CMD_SET_DIAG_ASS)\n\t\t\t\tqeth_issue_ipa_msg(cmd,\n\t\t\t\t\t\tcmd->hdr.return_code, card);\n\t\t\treturn cmd;\n\t\t} else {\n\t\t\tswitch (cmd->hdr.command) {\n\t\t\tcase IPA_CMD_STOPLAN:\n\t\t\t\tif (cmd->hdr.return_code ==\n\t\t\t\t\t\tIPA_RC_VEPA_TO_VEB_TRANSITION) {\n\t\t\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\t\t   \"Interface %s is down because the \"\n\t\t\t\t\t   \"adjacent port is no longer in \"\n\t\t\t\t\t   \"reflective relay mode\\n\",\n\t\t\t\t\t   QETH_CARD_IFNAME(card));\n\t\t\t\t\tqeth_close_dev(card);\n\t\t\t\t} else {\n\t\t\t\t\tdev_warn(&card->gdev->dev,\n\t\t\t\t\t   \"The link for interface %s on CHPID\"\n\t\t\t\t\t   \" 0x%X failed\\n\",\n\t\t\t\t\t   QETH_CARD_IFNAME(card),\n\t\t\t\t\t   card->info.chpid);\n\t\t\t\t\tqeth_issue_ipa_msg(cmd,\n\t\t\t\t\t\tcmd->hdr.return_code, card);\n\t\t\t\t}\n\t\t\t\tcard->lan_online = 0;\n\t\t\t\tif (card->dev && netif_carrier_ok(card->dev))\n\t\t\t\t\tnetif_carrier_off(card->dev);\n\t\t\t\treturn NULL;\n\t\t\tcase IPA_CMD_STARTLAN:\n\t\t\t\tdev_info(&card->gdev->dev,\n\t\t\t\t\t   \"The link for %s on CHPID 0x%X has\"\n\t\t\t\t\t   \" been restored\\n\",\n\t\t\t\t\t   QETH_CARD_IFNAME(card),\n\t\t\t\t\t   card->info.chpid);\n\t\t\t\tnetif_carrier_on(card->dev);\n\t\t\t\tcard->lan_online = 1;\n\t\t\t\tif (card->info.hwtrap)\n\t\t\t\t\tcard->info.hwtrap = 2;\n\t\t\t\tqeth_schedule_recovery(card);\n\t\t\t\treturn NULL;\n\t\t\tcase IPA_CMD_MODCCID:\n\t\t\t\treturn cmd;\n\t\t\tcase IPA_CMD_REGISTER_LOCAL_ADDR:\n\t\t\t\tQETH_CARD_TEXT(card, 3, \"irla\");\n\t\t\t\tbreak;\n\t\t\tcase IPA_CMD_UNREGISTER_LOCAL_ADDR:\n\t\t\t\tQETH_CARD_TEXT(card, 3, \"urla\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tQETH_DBF_MESSAGE(2, \"Received data is IPA \"\n\t\t\t\t\t   \"but not a reply!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn cmd;\n}\n\nvoid qeth_clear_ipacmd_list(struct qeth_card *card)\n{\n\tstruct qeth_reply *reply, *r;\n\tunsigned long flags;\n\n\tQETH_CARD_TEXT(card, 4, \"clipalst\");\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {\n\t\tqeth_get_reply(reply);\n\t\treply->rc = -EIO;\n\t\tatomic_inc(&reply->received);\n\t\tlist_del_init(&reply->list);\n\t\twake_up(&reply->wait_q);\n\t\tqeth_put_reply(reply);\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tatomic_set(&card->write.irq_pending, 0);\n}\nEXPORT_SYMBOL_GPL(qeth_clear_ipacmd_list);\n\nstatic int qeth_check_idx_response(struct qeth_card *card,\n\tunsigned char *buffer)\n{\n\tif (!buffer)\n\t\treturn 0;\n\n\tQETH_DBF_HEX(CTRL, 2, buffer, QETH_DBF_CTRL_LEN);\n\tif ((buffer[2] & 0xc0) == 0xc0) {\n\t\tQETH_DBF_MESSAGE(2, \"received an IDX TERMINATE \"\n\t\t\t   \"with cause code 0x%02x%s\\n\",\n\t\t\t   buffer[4],\n\t\t\t   ((buffer[4] == 0x22) ?\n\t\t\t    \" -- try another portname\" : \"\"));\n\t\tQETH_CARD_TEXT(card, 2, \"ckidxres\");\n\t\tQETH_CARD_TEXT(card, 2, \" idxterm\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -EIO);\n\t\tif (buffer[4] == 0xf6) {\n\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\"The qeth device is not configured \"\n\t\t\t\"for the OSI layer required by z/VM\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_setup_ccw(struct qeth_channel *channel, unsigned char *iob,\n\t\t__u32 len)\n{\n\tstruct qeth_card *card;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 4, \"setupccw\");\n\tif (channel == &card->read)\n\t\tmemcpy(&channel->ccw, READ_CCW, sizeof(struct ccw1));\n\telse\n\t\tmemcpy(&channel->ccw, WRITE_CCW, sizeof(struct ccw1));\n\tchannel->ccw.count = len;\n\tchannel->ccw.cda = (__u32) __pa(iob);\n}\n\nstatic struct qeth_cmd_buffer *__qeth_get_buffer(struct qeth_channel *channel)\n{\n\t__u8 index;\n\n\tQETH_CARD_TEXT(CARD_FROM_CDEV(channel->ccwdev), 6, \"getbuff\");\n\tindex = channel->io_buf_no;\n\tdo {\n\t\tif (channel->iob[index].state == BUF_STATE_FREE) {\n\t\t\tchannel->iob[index].state = BUF_STATE_LOCKED;\n\t\t\tchannel->io_buf_no = (channel->io_buf_no + 1) %\n\t\t\t\tQETH_CMD_BUFFER_NO;\n\t\t\tmemset(channel->iob[index].data, 0, QETH_BUFSIZE);\n\t\t\treturn channel->iob + index;\n\t\t}\n\t\tindex = (index + 1) % QETH_CMD_BUFFER_NO;\n\t} while (index != channel->io_buf_no);\n\n\treturn NULL;\n}\n\nvoid qeth_release_buffer(struct qeth_channel *channel,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tunsigned long flags;\n\n\tQETH_CARD_TEXT(CARD_FROM_CDEV(channel->ccwdev), 6, \"relbuff\");\n\tspin_lock_irqsave(&channel->iob_lock, flags);\n\tmemset(iob->data, 0, QETH_BUFSIZE);\n\tiob->state = BUF_STATE_FREE;\n\tiob->callback = qeth_send_control_data_cb;\n\tiob->rc = 0;\n\tspin_unlock_irqrestore(&channel->iob_lock, flags);\n\twake_up(&channel->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_release_buffer);\n\nstatic struct qeth_cmd_buffer *qeth_get_buffer(struct qeth_channel *channel)\n{\n\tstruct qeth_cmd_buffer *buffer = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->iob_lock, flags);\n\tbuffer = __qeth_get_buffer(channel);\n\tspin_unlock_irqrestore(&channel->iob_lock, flags);\n\treturn buffer;\n}\n\nstruct qeth_cmd_buffer *qeth_wait_for_buffer(struct qeth_channel *channel)\n{\n\tstruct qeth_cmd_buffer *buffer;\n\twait_event(channel->wait_q,\n\t\t   ((buffer = qeth_get_buffer(channel)) != NULL));\n\treturn buffer;\n}\nEXPORT_SYMBOL_GPL(qeth_wait_for_buffer);\n\nvoid qeth_clear_cmd_buffers(struct qeth_channel *channel)\n{\n\tint cnt;\n\n\tfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++)\n\t\tqeth_release_buffer(channel, &channel->iob[cnt]);\n\tchannel->buf_no = 0;\n\tchannel->io_buf_no = 0;\n}\nEXPORT_SYMBOL_GPL(qeth_clear_cmd_buffers);\n\nstatic void qeth_send_control_data_cb(struct qeth_channel *channel,\n\t\t  struct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_card *card;\n\tstruct qeth_reply *reply, *r;\n\tstruct qeth_ipa_cmd *cmd;\n\tunsigned long flags;\n\tint keep_reply;\n\tint rc = 0;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 4, \"sndctlcb\");\n\trc = qeth_check_idx_response(card, iob->data);\n\tswitch (rc) {\n\tcase 0:\n\t\tbreak;\n\tcase -EIO:\n\t\tqeth_clear_ipacmd_list(card);\n\t\tqeth_schedule_recovery(card);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tcmd = qeth_check_ipa_data(card, iob);\n\tif ((cmd == NULL) && (card->state != CARD_STATE_DOWN))\n\t\tgoto out;\n\t/*in case of OSN : check if cmd is set */\n\tif (card->info.type == QETH_CARD_TYPE_OSN &&\n\t    cmd &&\n\t    cmd->hdr.command != IPA_CMD_STARTLAN &&\n\t    card->osn_info.assist_cb != NULL) {\n\t\tcard->osn_info.assist_cb(card->dev, cmd);\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {\n\t\tif ((reply->seqno == QETH_IDX_COMMAND_SEQNO) ||\n\t\t    ((cmd) && (reply->seqno == cmd->hdr.seqno))) {\n\t\t\tqeth_get_reply(reply);\n\t\t\tlist_del_init(&reply->list);\n\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\tkeep_reply = 0;\n\t\t\tif (reply->callback != NULL) {\n\t\t\t\tif (cmd) {\n\t\t\t\t\treply->offset = (__u16)((char *)cmd -\n\t\t\t\t\t\t\t(char *)iob->data);\n\t\t\t\t\tkeep_reply = reply->callback(card,\n\t\t\t\t\t\t\treply,\n\t\t\t\t\t\t\t(unsigned long)cmd);\n\t\t\t\t} else\n\t\t\t\t\tkeep_reply = reply->callback(card,\n\t\t\t\t\t\t\treply,\n\t\t\t\t\t\t\t(unsigned long)iob);\n\t\t\t}\n\t\t\tif (cmd)\n\t\t\t\treply->rc = (u16) cmd->hdr.return_code;\n\t\t\telse if (iob->rc)\n\t\t\t\treply->rc = iob->rc;\n\t\t\tif (keep_reply) {\n\t\t\t\tspin_lock_irqsave(&card->lock, flags);\n\t\t\t\tlist_add_tail(&reply->list,\n\t\t\t\t\t      &card->cmd_waiter_list);\n\t\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\t} else {\n\t\t\t\tatomic_inc(&reply->received);\n\t\t\t\twake_up(&reply->wait_q);\n\t\t\t}\n\t\t\tqeth_put_reply(reply);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\nout:\n\tmemcpy(&card->seqno.pdu_hdr_ack,\n\t\tQETH_PDU_HEADER_SEQ_NO(iob->data),\n\t\tQETH_SEQ_NO_LENGTH);\n\tqeth_release_buffer(channel, iob);\n}\n\nstatic int qeth_setup_channel(struct qeth_channel *channel)\n{\n\tint cnt;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"setupch\");\n\tfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++) {\n\t\tchannel->iob[cnt].data =\n\t\t\tkzalloc(QETH_BUFSIZE, GFP_DMA|GFP_KERNEL);\n\t\tif (channel->iob[cnt].data == NULL)\n\t\t\tbreak;\n\t\tchannel->iob[cnt].state = BUF_STATE_FREE;\n\t\tchannel->iob[cnt].channel = channel;\n\t\tchannel->iob[cnt].callback = qeth_send_control_data_cb;\n\t\tchannel->iob[cnt].rc = 0;\n\t}\n\tif (cnt < QETH_CMD_BUFFER_NO) {\n\t\twhile (cnt-- > 0)\n\t\t\tkfree(channel->iob[cnt].data);\n\t\treturn -ENOMEM;\n\t}\n\tchannel->buf_no = 0;\n\tchannel->io_buf_no = 0;\n\tatomic_set(&channel->irq_pending, 0);\n\tspin_lock_init(&channel->iob_lock);\n\n\tinit_waitqueue_head(&channel->wait_q);\n\treturn 0;\n}\n\nstatic int qeth_set_thread_start_bit(struct qeth_card *card,\n\t\tunsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tif (!(card->thread_allowed_mask & thread) ||\n\t      (card->thread_start_mask & thread)) {\n\t\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\t\treturn -EPERM;\n\t}\n\tcard->thread_start_mask |= thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn 0;\n}\n\nvoid qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_start_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_clear_thread_start_bit);\n\nvoid qeth_clear_thread_running_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_running_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_clear_thread_running_bit);\n\nstatic int __qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tif (card->thread_start_mask & thread) {\n\t\tif ((card->thread_allowed_mask & thread) &&\n\t\t    !(card->thread_running_mask & thread)) {\n\t\t\trc = 1;\n\t\t\tcard->thread_start_mask &= ~thread;\n\t\t\tcard->thread_running_mask |= thread;\n\t\t} else\n\t\t\trc = -EPERM;\n\t}\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\n\nint qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\n{\n\tint rc = 0;\n\n\twait_event(card->wait_q,\n\t\t   (rc = __qeth_do_run_thread(card, thread)) >= 0);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_do_run_thread);\n\nvoid qeth_schedule_recovery(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"startrec\");\n\tif (qeth_set_thread_start_bit(card, QETH_RECOVER_THREAD) == 0)\n\t\tschedule_work(&card->kernel_thread_starter);\n}\nEXPORT_SYMBOL_GPL(qeth_schedule_recovery);\n\nstatic int qeth_get_problem(struct ccw_device *cdev, struct irb *irb)\n{\n\tint dstat, cstat;\n\tchar *sense;\n\tstruct qeth_card *card;\n\n\tsense = (char *) irb->ecw;\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\tcard = CARD_FROM_CDEV(cdev);\n\n\tif (cstat & (SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK |\n\t\t     SCHN_STAT_CHN_DATA_CHK | SCHN_STAT_CHAIN_CHECK |\n\t\t     SCHN_STAT_PROT_CHECK | SCHN_STAT_PROG_CHECK)) {\n\t\tQETH_CARD_TEXT(card, 2, \"CGENCHK\");\n\t\tdev_warn(&cdev->dev, \"The qeth device driver \"\n\t\t\t\"failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"%s check on device dstat=x%x, cstat=x%x\\n\",\n\t\t\tdev_name(&cdev->dev), dstat, cstat);\n\t\tprint_hex_dump(KERN_WARNING, \"qeth: irb \", DUMP_PREFIX_OFFSET,\n\t\t\t\t16, 1, irb, 64, 1);\n\t\treturn 1;\n\t}\n\n\tif (dstat & DEV_STAT_UNIT_CHECK) {\n\t\tif (sense[SENSE_RESETTING_EVENT_BYTE] &\n\t\t    SENSE_RESETTING_EVENT_FLAG) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"REVIND\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (sense[SENSE_COMMAND_REJECT_BYTE] &\n\t\t    SENSE_COMMAND_REJECT_FLAG) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"CMDREJi\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((sense[2] == 0xaf) && (sense[3] == 0xfe)) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"AFFE\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((!sense[0]) && (!sense[1]) && (!sense[2]) && (!sense[3])) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"ZEROSEN\");\n\t\t\treturn 0;\n\t\t}\n\t\tQETH_CARD_TEXT(card, 2, \"DGENCHK\");\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic long __qeth_check_irb_error(struct ccw_device *cdev,\n\t\tunsigned long intparm, struct irb *irb)\n{\n\tstruct qeth_card *card;\n\n\tcard = CARD_FROM_CDEV(cdev);\n\n\tif (!IS_ERR(irb))\n\t\treturn 0;\n\n\tswitch (PTR_ERR(irb)) {\n\tcase -EIO:\n\t\tQETH_DBF_MESSAGE(2, \"%s i/o-error on device\\n\",\n\t\t\tdev_name(&cdev->dev));\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -EIO);\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tdev_warn(&cdev->dev, \"A hardware operation timed out\"\n\t\t\t\" on the device\\n\");\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -ETIMEDOUT);\n\t\tif (intparm == QETH_RCD_PARM) {\n\t\t\tif (card && (card->data.ccwdev == cdev)) {\n\t\t\t\tcard->data.state = CH_STATE_DOWN;\n\t\t\t\twake_up(&card->wait_q);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(2, \"%s unknown error %ld on device\\n\",\n\t\t\tdev_name(&cdev->dev), PTR_ERR(irb));\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT(card, 2, \"  rc???\");\n\t}\n\treturn PTR_ERR(irb);\n}\n\nstatic void qeth_irq(struct ccw_device *cdev, unsigned long intparm,\n\t\tstruct irb *irb)\n{\n\tint rc;\n\tint cstat, dstat;\n\tstruct qeth_cmd_buffer *buffer;\n\tstruct qeth_channel *channel;\n\tstruct qeth_card *card;\n\tstruct qeth_cmd_buffer *iob;\n\t__u8 index;\n\n\tif (__qeth_check_irb_error(cdev, intparm, irb))\n\t\treturn;\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\n\tcard = CARD_FROM_CDEV(cdev);\n\tif (!card)\n\t\treturn;\n\n\tQETH_CARD_TEXT(card, 5, \"irq\");\n\n\tif (card->read.ccwdev == cdev) {\n\t\tchannel = &card->read;\n\t\tQETH_CARD_TEXT(card, 5, \"read\");\n\t} else if (card->write.ccwdev == cdev) {\n\t\tchannel = &card->write;\n\t\tQETH_CARD_TEXT(card, 5, \"write\");\n\t} else {\n\t\tchannel = &card->data;\n\t\tQETH_CARD_TEXT(card, 5, \"data\");\n\t}\n\tatomic_set(&channel->irq_pending, 0);\n\n\tif (irb->scsw.cmd.fctl & (SCSW_FCTL_CLEAR_FUNC))\n\t\tchannel->state = CH_STATE_STOPPED;\n\n\tif (irb->scsw.cmd.fctl & (SCSW_FCTL_HALT_FUNC))\n\t\tchannel->state = CH_STATE_HALTED;\n\n\t/*let's wake up immediately on data channel*/\n\tif ((channel == &card->data) && (intparm != 0) &&\n\t    (intparm != QETH_RCD_PARM))\n\t\tgoto out;\n\n\tif (intparm == QETH_CLEAR_CHANNEL_PARM) {\n\t\tQETH_CARD_TEXT(card, 6, \"clrchpar\");\n\t\t/* we don't have to handle this further */\n\t\tintparm = 0;\n\t}\n\tif (intparm == QETH_HALT_CHANNEL_PARM) {\n\t\tQETH_CARD_TEXT(card, 6, \"hltchpar\");\n\t\t/* we don't have to handle this further */\n\t\tintparm = 0;\n\t}\n\tif ((dstat & DEV_STAT_UNIT_EXCEP) ||\n\t    (dstat & DEV_STAT_UNIT_CHECK) ||\n\t    (cstat)) {\n\t\tif (irb->esw.esw0.erw.cons) {\n\t\t\tdev_warn(&channel->ccwdev->dev,\n\t\t\t\t\"The qeth device driver failed to recover \"\n\t\t\t\t\"an error on the device\\n\");\n\t\t\tQETH_DBF_MESSAGE(2, \"%s sense data available. cstat \"\n\t\t\t\t\"0x%X dstat 0x%X\\n\",\n\t\t\t\tdev_name(&channel->ccwdev->dev), cstat, dstat);\n\t\t\tprint_hex_dump(KERN_WARNING, \"qeth: irb \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1, irb, 32, 1);\n\t\t\tprint_hex_dump(KERN_WARNING, \"qeth: sense data \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1, irb->ecw, 32, 1);\n\t\t}\n\t\tif (intparm == QETH_RCD_PARM) {\n\t\t\tchannel->state = CH_STATE_DOWN;\n\t\t\tgoto out;\n\t\t}\n\t\trc = qeth_get_problem(cdev, irb);\n\t\tif (rc) {\n\t\t\tqeth_clear_ipacmd_list(card);\n\t\t\tqeth_schedule_recovery(card);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (intparm == QETH_RCD_PARM) {\n\t\tchannel->state = CH_STATE_RCD_DONE;\n\t\tgoto out;\n\t}\n\tif (intparm) {\n\t\tbuffer = (struct qeth_cmd_buffer *) __va((addr_t)intparm);\n\t\tbuffer->state = BUF_STATE_PROCESSED;\n\t}\n\tif (channel == &card->data)\n\t\treturn;\n\tif (channel == &card->read &&\n\t    channel->state == CH_STATE_UP)\n\t\tqeth_issue_next_read(card);\n\n\tiob = channel->iob;\n\tindex = channel->buf_no;\n\twhile (iob[index].state == BUF_STATE_PROCESSED) {\n\t\tif (iob[index].callback != NULL)\n\t\t\tiob[index].callback(channel, iob + index);\n\n\t\tindex = (index + 1) % QETH_CMD_BUFFER_NO;\n\t}\n\tchannel->buf_no = index;\nout:\n\twake_up(&card->wait_q);\n\treturn;\n}\n\nstatic void qeth_notify_skbs(struct qeth_qdio_out_q *q,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum iucv_tx_notify notification)\n{\n\tstruct sk_buff *skb;\n\n\tif (skb_queue_empty(&buf->skb_list))\n\t\tgoto out;\n\tskb = skb_peek(&buf->skb_list);\n\twhile (skb) {\n\t\tQETH_CARD_TEXT_(q->card, 5, \"skbn%d\", notification);\n\t\tQETH_CARD_TEXT_(q->card, 5, \"%lx\", (long) skb);\n\t\tif (skb->protocol == ETH_P_AF_IUCV) {\n\t\t\tif (skb->sk) {\n\t\t\t\tstruct iucv_sock *iucv = iucv_sk(skb->sk);\n\t\t\t\tiucv->sk_txnotify(skb, notification);\n\t\t\t}\n\t\t}\n\t\tif (skb_queue_is_last(&buf->skb_list, skb))\n\t\t\tskb = NULL;\n\t\telse\n\t\t\tskb = skb_queue_next(&buf->skb_list, skb);\n\t}\nout:\n\treturn;\n}\n\nstatic void qeth_release_skbs(struct qeth_qdio_out_buffer *buf)\n{\n\tstruct sk_buff *skb;\n\tstruct iucv_sock *iucv;\n\tint notify_general_error = 0;\n\n\tif (atomic_read(&buf->state) == QETH_QDIO_BUF_PENDING)\n\t\tnotify_general_error = 1;\n\n\t/* release may never happen from within CQ tasklet scope */\n\tWARN_ON_ONCE(atomic_read(&buf->state) == QETH_QDIO_BUF_IN_CQ);\n\n\tskb = skb_dequeue(&buf->skb_list);\n\twhile (skb) {\n\t\tQETH_CARD_TEXT(buf->q->card, 5, \"skbr\");\n\t\tQETH_CARD_TEXT_(buf->q->card, 5, \"%lx\", (long) skb);\n\t\tif (notify_general_error && skb->protocol == ETH_P_AF_IUCV) {\n\t\t\tif (skb->sk) {\n\t\t\t\tiucv = iucv_sk(skb->sk);\n\t\t\t\tiucv->sk_txnotify(skb, TX_NOTIFY_GENERALERROR);\n\t\t\t}\n\t\t}\n\t\tatomic_dec(&skb->users);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = skb_dequeue(&buf->skb_list);\n\t}\n}\n\nstatic void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum qeth_qdio_buffer_states newbufstate)\n{\n\tint i;\n\n\t/* is PCI flag set on buffer? */\n\tif (buf->buffer->element[0].sflags & SBAL_SFLAGS0_PCI_REQ)\n\t\tatomic_dec(&queue->set_pci_flags_count);\n\n\tif (newbufstate == QETH_QDIO_BUF_EMPTY) {\n\t\tqeth_release_skbs(buf);\n\t}\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(queue->card); ++i) {\n\t\tif (buf->buffer->element[i].addr && buf->is_header[i])\n\t\t\tkmem_cache_free(qeth_core_header_cache,\n\t\t\t\tbuf->buffer->element[i].addr);\n\t\tbuf->is_header[i] = 0;\n\t\tbuf->buffer->element[i].length = 0;\n\t\tbuf->buffer->element[i].addr = NULL;\n\t\tbuf->buffer->element[i].eflags = 0;\n\t\tbuf->buffer->element[i].sflags = 0;\n\t}\n\tbuf->buffer->element[15].eflags = 0;\n\tbuf->buffer->element[15].sflags = 0;\n\tbuf->next_element_to_fill = 0;\n\tatomic_set(&buf->state, newbufstate);\n}\n\nstatic void qeth_clear_outq_buffers(struct qeth_qdio_out_q *q, int free)\n{\n\tint j;\n\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (!q->bufs[j])\n\t\t\tcontinue;\n\t\tqeth_cleanup_handled_pending(q, j, 1);\n\t\tqeth_clear_output_buffer(q, q->bufs[j], QETH_QDIO_BUF_EMPTY);\n\t\tif (free) {\n\t\t\tkmem_cache_free(qeth_qdio_outbuf_cache, q->bufs[j]);\n\t\t\tq->bufs[j] = NULL;\n\t\t}\n\t}\n}\n\nvoid qeth_clear_qdio_buffers(struct qeth_card *card)\n{\n\tint i;\n\n\tQETH_CARD_TEXT(card, 2, \"clearqdbf\");\n\t/* clear outbound buffers to free skbs */\n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tif (card->qdio.out_qs[i]) {\n\t\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 0);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_clear_qdio_buffers);\n\nstatic void qeth_free_buffer_pool(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry, *tmp;\n\tint i = 0;\n\tlist_for_each_entry_safe(pool_entry, tmp,\n\t\t\t\t &card->qdio.init_pool.entry_list, init_list){\n\t\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i)\n\t\t\tfree_page((unsigned long)pool_entry->elements[i]);\n\t\tlist_del(&pool_entry->init_list);\n\t\tkfree(pool_entry);\n\t}\n}\n\nstatic void qeth_free_qdio_buffers(struct qeth_card *card)\n{\n\tint i, j;\n\n\tif (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==\n\t\tQETH_QDIO_UNINITIALIZED)\n\t\treturn;\n\n\tqeth_free_cq(card);\n\tcancel_delayed_work_sync(&card->buffer_reclaim_work);\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (card->qdio.in_q->bufs[j].rx_skb)\n\t\t\tdev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);\n\t}\n\tkfree(card->qdio.in_q);\n\tcard->qdio.in_q = NULL;\n\t/* inbound buffer pool */\n\tqeth_free_buffer_pool(card);\n\t/* free outbound qdio_qs */\n\tif (card->qdio.out_qs) {\n\t\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\n\t\t\tkfree(card->qdio.out_qs[i]);\n\t\t}\n\t\tkfree(card->qdio.out_qs);\n\t\tcard->qdio.out_qs = NULL;\n\t}\n}\n\nstatic void qeth_clean_channel(struct qeth_channel *channel)\n{\n\tint cnt;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"freech\");\n\tfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++)\n\t\tkfree(channel->iob[cnt].data);\n}\n\nstatic void qeth_set_single_write_queues(struct qeth_card *card)\n{\n\tif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\n\t    (card->qdio.no_out_queues == 4))\n\t\tqeth_free_qdio_buffers(card);\n\n\tcard->qdio.no_out_queues = 1;\n\tif (card->qdio.default_out_queue != 0)\n\t\tdev_info(&card->gdev->dev, \"Priority Queueing not supported\\n\");\n\n\tcard->qdio.default_out_queue = 0;\n}\n\nstatic void qeth_set_multiple_write_queues(struct qeth_card *card)\n{\n\tif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\n\t    (card->qdio.no_out_queues == 1)) {\n\t\tqeth_free_qdio_buffers(card);\n\t\tcard->qdio.default_out_queue = 2;\n\t}\n\tcard->qdio.no_out_queues = 4;\n}\n\nstatic void qeth_update_from_chp_desc(struct qeth_card *card)\n{\n\tstruct ccw_device *ccwdev;\n\tstruct channelPath_dsc {\n\t\tu8 flags;\n\t\tu8 lsn;\n\t\tu8 desc;\n\t\tu8 chpid;\n\t\tu8 swla;\n\t\tu8 zeroes;\n\t\tu8 chla;\n\t\tu8 chpp;\n\t} *chp_dsc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"chp_desc\");\n\n\tccwdev = card->data.ccwdev;\n\tchp_dsc = ccw_device_get_chp_desc(ccwdev, 0);\n\tif (!chp_dsc)\n\t\tgoto out;\n\n\tcard->info.func_level = 0x4100 + chp_dsc->desc;\n\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\tgoto out;\n\n\t/* CHPP field bit 6 == 1 -> single queue */\n\tif ((chp_dsc->chpp & 0x02) == 0x02)\n\t\tqeth_set_single_write_queues(card);\n\telse\n\t\tqeth_set_multiple_write_queues(card);\nout:\n\tkfree(chp_dsc);\n\tQETH_DBF_TEXT_(SETUP, 2, \"nr:%x\", card->qdio.no_out_queues);\n\tQETH_DBF_TEXT_(SETUP, 2, \"lvl:%02x\", card->info.func_level);\n}\n\nstatic void qeth_init_qdio_info(struct qeth_card *card)\n{\n\tQETH_DBF_TEXT(SETUP, 4, \"intqdinf\");\n\tatomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\n\t/* inbound */\n\tcard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\n\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\tcard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_HSDEFAULT;\n\telse\n\t\tcard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_DEFAULT;\n\tcard->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;\n\tINIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);\n\tINIT_LIST_HEAD(&card->qdio.init_pool.entry_list);\n}\n\nstatic void qeth_set_intial_options(struct qeth_card *card)\n{\n\tcard->options.route4.type = NO_ROUTER;\n\tcard->options.route6.type = NO_ROUTER;\n\tcard->options.fake_broadcast = 0;\n\tcard->options.add_hhlen = DEFAULT_ADD_HHLEN;\n\tcard->options.performance_stats = 0;\n\tcard->options.rx_sg_cb = QETH_RX_SG_CB;\n\tcard->options.isolation = ISOLATION_MODE_NONE;\n\tcard->options.cq = QETH_CQ_DISABLED;\n}\n\nstatic int qeth_do_start_thread(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tQETH_CARD_TEXT_(card, 4, \"  %02x%02x%02x\",\n\t\t\t(u8) card->thread_start_mask,\n\t\t\t(u8) card->thread_allowed_mask,\n\t\t\t(u8) card->thread_running_mask);\n\trc = (card->thread_start_mask & thread);\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\n\nstatic void qeth_start_kernel_thread(struct work_struct *work)\n{\n\tstruct task_struct *ts;\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\t\t\t\tkernel_thread_starter);\n\tQETH_CARD_TEXT(card , 2, \"strthrd\");\n\n\tif (card->read.state != CH_STATE_UP &&\n\t    card->write.state != CH_STATE_UP)\n\t\treturn;\n\tif (qeth_do_start_thread(card, QETH_RECOVER_THREAD)) {\n\t\tts = kthread_run(card->discipline->recover, (void *)card,\n\t\t\t\t\"qeth_recover\");\n\t\tif (IS_ERR(ts)) {\n\t\t\tqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\n\t\t\tqeth_clear_thread_running_bit(card,\n\t\t\t\tQETH_RECOVER_THREAD);\n\t\t}\n\t}\n}\n\nstatic int qeth_setup_card(struct qeth_card *card)\n{\n\n\tQETH_DBF_TEXT(SETUP, 2, \"setupcrd\");\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\n\tcard->read.state  = CH_STATE_DOWN;\n\tcard->write.state = CH_STATE_DOWN;\n\tcard->data.state  = CH_STATE_DOWN;\n\tcard->state = CARD_STATE_DOWN;\n\tcard->lan_online = 0;\n\tcard->read_or_write_problem = 0;\n\tcard->dev = NULL;\n\tspin_lock_init(&card->vlanlock);\n\tspin_lock_init(&card->mclock);\n\tspin_lock_init(&card->lock);\n\tspin_lock_init(&card->ip_lock);\n\tspin_lock_init(&card->thread_mask_lock);\n\tmutex_init(&card->conf_mutex);\n\tmutex_init(&card->discipline_mutex);\n\tcard->thread_start_mask = 0;\n\tcard->thread_allowed_mask = 0;\n\tcard->thread_running_mask = 0;\n\tINIT_WORK(&card->kernel_thread_starter, qeth_start_kernel_thread);\n\tINIT_LIST_HEAD(&card->ip_list);\n\tINIT_LIST_HEAD(card->ip_tbd_list);\n\tINIT_LIST_HEAD(&card->cmd_waiter_list);\n\tinit_waitqueue_head(&card->wait_q);\n\t/* initial options */\n\tqeth_set_intial_options(card);\n\t/* IP address takeover */\n\tINIT_LIST_HEAD(&card->ipato.entries);\n\tcard->ipato.enabled = 0;\n\tcard->ipato.invert4 = 0;\n\tcard->ipato.invert6 = 0;\n\t/* init QDIO stuff */\n\tqeth_init_qdio_info(card);\n\tINIT_DELAYED_WORK(&card->buffer_reclaim_work, qeth_buffer_reclaim_work);\n\tINIT_WORK(&card->close_dev_work, qeth_close_dev_handler);\n\treturn 0;\n}\n\nstatic void qeth_core_sl_print(struct seq_file *m, struct service_level *slr)\n{\n\tstruct qeth_card *card = container_of(slr, struct qeth_card,\n\t\t\t\t\tqeth_service_level);\n\tif (card->info.mcl_level[0])\n\t\tseq_printf(m, \"qeth: %s firmware level %s\\n\",\n\t\t\tCARD_BUS_ID(card), card->info.mcl_level);\n}\n\nstatic struct qeth_card *qeth_alloc_card(void)\n{\n\tstruct qeth_card *card;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"alloccrd\");\n\tcard = kzalloc(sizeof(struct qeth_card), GFP_DMA|GFP_KERNEL);\n\tif (!card)\n\t\tgoto out;\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\tcard->ip_tbd_list = kzalloc(sizeof(struct list_head), GFP_KERNEL);\n\tif (!card->ip_tbd_list) {\n\t\tQETH_DBF_TEXT(SETUP, 0, \"iptbdnom\");\n\t\tgoto out_card;\n\t}\n\tif (qeth_setup_channel(&card->read))\n\t\tgoto out_ip;\n\tif (qeth_setup_channel(&card->write))\n\t\tgoto out_channel;\n\tcard->options.layer2 = -1;\n\tcard->qeth_service_level.seq_print = qeth_core_sl_print;\n\tregister_service_level(&card->qeth_service_level);\n\treturn card;\n\nout_channel:\n\tqeth_clean_channel(&card->read);\nout_ip:\n\tkfree(card->ip_tbd_list);\nout_card:\n\tkfree(card);\nout:\n\treturn NULL;\n}\n\nstatic int qeth_determine_card_type(struct qeth_card *card)\n{\n\tint i = 0;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"detcdtyp\");\n\n\tcard->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;\n\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\twhile (known_devices[i][QETH_DEV_MODEL_IND]) {\n\t\tif ((CARD_RDEV(card)->id.dev_type ==\n\t\t\t\tknown_devices[i][QETH_DEV_TYPE_IND]) &&\n\t\t    (CARD_RDEV(card)->id.dev_model ==\n\t\t\t\tknown_devices[i][QETH_DEV_MODEL_IND])) {\n\t\t\tcard->info.type = known_devices[i][QETH_DEV_MODEL_IND];\n\t\t\tcard->qdio.no_out_queues =\n\t\t\t\tknown_devices[i][QETH_QUEUE_NO_IND];\n\t\t\tcard->qdio.no_in_queues = 1;\n\t\t\tcard->info.is_multicast_different =\n\t\t\t\tknown_devices[i][QETH_MULTICAST_IND];\n\t\t\tqeth_update_from_chp_desc(card);\n\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t}\n\tcard->info.type = QETH_CARD_TYPE_UNKNOWN;\n\tdev_err(&card->gdev->dev, \"The adapter hardware is of an \"\n\t\t\"unknown type\\n\");\n\treturn -ENOENT;\n}\n\nstatic int qeth_clear_channel(struct qeth_channel *channel)\n{\n\tunsigned long flags;\n\tstruct qeth_card *card;\n\tint rc;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 3, \"clearch\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_clear(channel->ccwdev, QETH_CLEAR_CHANNEL_PARM);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc)\n\t\treturn rc;\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_STOPPED, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_STOPPED)\n\t\treturn -ETIME;\n\tchannel->state = CH_STATE_DOWN;\n\treturn 0;\n}\n\nstatic int qeth_halt_channel(struct qeth_channel *channel)\n{\n\tunsigned long flags;\n\tstruct qeth_card *card;\n\tint rc;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 3, \"haltch\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_halt(channel->ccwdev, QETH_HALT_CHANNEL_PARM);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc)\n\t\treturn rc;\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_HALTED, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_HALTED)\n\t\treturn -ETIME;\n\treturn 0;\n}\n\nstatic int qeth_halt_channels(struct qeth_card *card)\n{\n\tint rc1 = 0, rc2 = 0, rc3 = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"haltchs\");\n\trc1 = qeth_halt_channel(&card->read);\n\trc2 = qeth_halt_channel(&card->write);\n\trc3 = qeth_halt_channel(&card->data);\n\tif (rc1)\n\t\treturn rc1;\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc3;\n}\n\nstatic int qeth_clear_channels(struct qeth_card *card)\n{\n\tint rc1 = 0, rc2 = 0, rc3 = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"clearchs\");\n\trc1 = qeth_clear_channel(&card->read);\n\trc2 = qeth_clear_channel(&card->write);\n\trc3 = qeth_clear_channel(&card->data);\n\tif (rc1)\n\t\treturn rc1;\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc3;\n}\n\nstatic int qeth_clear_halt_card(struct qeth_card *card, int halt)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"clhacrd\");\n\n\tif (halt)\n\t\trc = qeth_halt_channels(card);\n\tif (rc)\n\t\treturn rc;\n\treturn qeth_clear_channels(card);\n}\n\nint qeth_qdio_clear_card(struct qeth_card *card, int use_halt)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"qdioclr\");\n\tswitch (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ESTABLISHED,\n\t\tQETH_QDIO_CLEANING)) {\n\tcase QETH_QDIO_ESTABLISHED:\n\t\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\t\trc = qdio_shutdown(CARD_DDEV(card),\n\t\t\t\tQDIO_FLAG_CLEANUP_USING_HALT);\n\t\telse\n\t\t\trc = qdio_shutdown(CARD_DDEV(card),\n\t\t\t\tQDIO_FLAG_CLEANUP_USING_CLEAR);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 3, \"1err%d\", rc);\n\t\tqdio_free(CARD_DDEV(card));\n\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\tbreak;\n\tcase QETH_QDIO_CLEANING:\n\t\treturn rc;\n\tdefault:\n\t\tbreak;\n\t}\n\trc = qeth_clear_halt_card(card, use_halt);\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 3, \"2err%d\", rc);\n\tcard->state = CARD_STATE_DOWN;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_clear_card);\n\nstatic int qeth_read_conf_data(struct qeth_card *card, void **buffer,\n\t\t\t       int *length)\n{\n\tstruct ciw *ciw;\n\tchar *rcd_buf;\n\tint ret;\n\tstruct qeth_channel *channel = &card->data;\n\tunsigned long flags;\n\n\t/*\n\t * scan for RCD command in extended SenseID data\n\t */\n\tciw = ccw_device_get_ciw(channel->ccwdev, CIW_TYPE_RCD);\n\tif (!ciw || ciw->cmd == 0)\n\t\treturn -EOPNOTSUPP;\n\trcd_buf = kzalloc(ciw->count, GFP_KERNEL | GFP_DMA);\n\tif (!rcd_buf)\n\t\treturn -ENOMEM;\n\n\tchannel->ccw.cmd_code = ciw->cmd;\n\tchannel->ccw.cda = (__u32) __pa(rcd_buf);\n\tchannel->ccw.count = ciw->count;\n\tchannel->ccw.flags = CCW_FLAG_SLI;\n\tchannel->state = CH_STATE_RCD;\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\tret = ccw_device_start_timeout(channel->ccwdev, &channel->ccw,\n\t\t\t\t       QETH_RCD_PARM, LPM_ANYPATH, 0,\n\t\t\t\t       QETH_RCD_TIMEOUT);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\tif (!ret)\n\t\twait_event(card->wait_q,\n\t\t\t   (channel->state == CH_STATE_RCD_DONE ||\n\t\t\t    channel->state == CH_STATE_DOWN));\n\tif (channel->state == CH_STATE_DOWN)\n\t\tret = -EIO;\n\telse\n\t\tchannel->state = CH_STATE_DOWN;\n\tif (ret) {\n\t\tkfree(rcd_buf);\n\t\t*buffer = NULL;\n\t\t*length = 0;\n\t} else {\n\t\t*length = ciw->count;\n\t\t*buffer = rcd_buf;\n\t}\n\treturn ret;\n}\n\nstatic void qeth_configure_unitaddr(struct qeth_card *card, char *prcd)\n{\n\tQETH_DBF_TEXT(SETUP, 2, \"cfgunit\");\n\tcard->info.chpid = prcd[30];\n\tcard->info.unit_addr2 = prcd[31];\n\tcard->info.cula = prcd[63];\n\tcard->info.guestlan = ((prcd[0x10] == _ascebc['V']) &&\n\t\t\t       (prcd[0x11] == _ascebc['M']));\n}\n\nstatic void qeth_configure_blkt_default(struct qeth_card *card, char *prcd)\n{\n\tQETH_DBF_TEXT(SETUP, 2, \"cfgblkt\");\n\n\tif (prcd[74] == 0xF0 && prcd[75] == 0xF0 &&\n\t    prcd[76] >= 0xF1 && prcd[76] <= 0xF4) {\n\t\tcard->info.blkt.time_total = 0;\n\t\tcard->info.blkt.inter_packet = 0;\n\t\tcard->info.blkt.inter_packet_jumbo = 0;\n\t} else {\n\t\tcard->info.blkt.time_total = 250;\n\t\tcard->info.blkt.inter_packet = 5;\n\t\tcard->info.blkt.inter_packet_jumbo = 15;\n\t}\n}\n\nstatic void qeth_init_tokens(struct qeth_card *card)\n{\n\tcard->token.issuer_rm_w = 0x00010103UL;\n\tcard->token.cm_filter_w = 0x00010108UL;\n\tcard->token.cm_connection_w = 0x0001010aUL;\n\tcard->token.ulp_filter_w = 0x0001010bUL;\n\tcard->token.ulp_connection_w = 0x0001010dUL;\n}\n\nstatic void qeth_init_func_level(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_IQD:\n\t\tcard->info.func_level =\tQETH_IDX_FUNC_LEVEL_IQD;\n\t\tbreak;\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSN:\n\t\tcard->info.func_level = QETH_IDX_FUNC_LEVEL_OSD;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int qeth_idx_activate_get_answer(struct qeth_channel *channel,\n\t\tvoid (*idx_reply_cb)(struct qeth_channel *,\n\t\t\tstruct qeth_cmd_buffer *))\n{\n\tstruct qeth_cmd_buffer *iob;\n\tunsigned long flags;\n\tint rc;\n\tstruct qeth_card *card;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"idxanswr\");\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tiob = qeth_get_buffer(channel);\n\tiob->callback = idx_reply_cb;\n\tmemcpy(&channel->ccw, READ_CCW, sizeof(struct ccw1));\n\tchannel->ccw.count = QETH_BUFSIZE;\n\tchannel->ccw.cda = (__u32) __pa(iob->data);\n\n\twait_event(card->wait_q,\n\t\t   atomic_cmpxchg(&channel->irq_pending, 0, 1) == 0);\n\tQETH_DBF_TEXT(SETUP, 6, \"noirqpnd\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_start(channel->ccwdev,\n\t\t\t      &channel->ccw, (addr_t) iob, 0, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"Error2 in activating channel rc=%d\\n\", rc);\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", rc);\n\t\tatomic_set(&channel->irq_pending, 0);\n\t\twake_up(&card->wait_q);\n\t\treturn rc;\n\t}\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\t channel->state == CH_STATE_UP, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_UP) {\n\t\trc = -ETIME;\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tqeth_clear_cmd_buffers(channel);\n\t} else\n\t\trc = 0;\n\treturn rc;\n}\n\nstatic int qeth_idx_activate_channel(struct qeth_channel *channel,\n\t\tvoid (*idx_reply_cb)(struct qeth_channel *,\n\t\t\tstruct qeth_cmd_buffer *))\n{\n\tstruct qeth_card *card;\n\tstruct qeth_cmd_buffer *iob;\n\tunsigned long flags;\n\t__u16 temp;\n\t__u8 tmp;\n\tint rc;\n\tstruct ccw_dev_id temp_devid;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\n\tQETH_DBF_TEXT(SETUP, 2, \"idxactch\");\n\n\tiob = qeth_get_buffer(channel);\n\tiob->callback = idx_reply_cb;\n\tmemcpy(&channel->ccw, WRITE_CCW, sizeof(struct ccw1));\n\tchannel->ccw.count = IDX_ACTIVATE_SIZE;\n\tchannel->ccw.cda = (__u32) __pa(iob->data);\n\tif (channel == &card->write) {\n\t\tmemcpy(iob->data, IDX_ACTIVATE_WRITE, IDX_ACTIVATE_SIZE);\n\t\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\n\t\t       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\n\t\tcard->seqno.trans_hdr++;\n\t} else {\n\t\tmemcpy(iob->data, IDX_ACTIVATE_READ, IDX_ACTIVATE_SIZE);\n\t\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\n\t\t       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\n\t}\n\ttmp = ((__u8)card->info.portno) | 0x80;\n\tmemcpy(QETH_IDX_ACT_PNO(iob->data), &tmp, 1);\n\tmemcpy(QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_IDX_ACT_FUNC_LEVEL(iob->data),\n\t       &card->info.func_level, sizeof(__u16));\n\tccw_device_get_id(CARD_DDEV(card), &temp_devid);\n\tmemcpy(QETH_IDX_ACT_QDIO_DEV_CUA(iob->data), &temp_devid.devno, 2);\n\ttemp = (card->info.cula << 8) + card->info.unit_addr2;\n\tmemcpy(QETH_IDX_ACT_QDIO_DEV_REALADDR(iob->data), &temp, 2);\n\n\twait_event(card->wait_q,\n\t\t   atomic_cmpxchg(&channel->irq_pending, 0, 1) == 0);\n\tQETH_DBF_TEXT(SETUP, 6, \"noirqpnd\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_start(channel->ccwdev,\n\t\t\t      &channel->ccw, (addr_t) iob, 0, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"Error1 in activating channel. rc=%d\\n\",\n\t\t\trc);\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\tatomic_set(&channel->irq_pending, 0);\n\t\twake_up(&card->wait_q);\n\t\treturn rc;\n\t}\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_ACTIVATING, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_ACTIVATING) {\n\t\tdev_warn(&channel->ccwdev->dev, \"The qeth device driver\"\n\t\t\t\" failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"%s IDX activate timed out\\n\",\n\t\t\tdev_name(&channel->ccwdev->dev));\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", -ETIME);\n\t\tqeth_clear_cmd_buffers(channel);\n\t\treturn -ETIME;\n\t}\n\treturn qeth_idx_activate_get_answer(channel, idx_reply_cb);\n}\n\nstatic int qeth_peer_func_level(int level)\n{\n\tif ((level & 0xff) == 8)\n\t\treturn (level & 0xff) + 0x400;\n\tif (((level >> 8) & 3) == 1)\n\t\treturn (level & 0xff) + 0x200;\n\treturn level;\n}\n\nstatic void qeth_idx_write_cb(struct qeth_channel *channel,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_card *card;\n\t__u16 temp;\n\n\tQETH_DBF_TEXT(SETUP , 2, \"idxwrcb\");\n\n\tif (channel->state == CH_STATE_DOWN) {\n\t\tchannel->state = CH_STATE_ACTIVATING;\n\t\tgoto out;\n\t}\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\n\tif (!(QETH_IS_IDX_ACT_POS_REPLY(iob->data))) {\n\t\tif (QETH_IDX_ACT_CAUSE_CODE(iob->data) == QETH_IDX_ACT_ERR_EXCL)\n\t\t\tdev_err(&card->write.ccwdev->dev,\n\t\t\t\t\"The adapter is used exclusively by another \"\n\t\t\t\t\"host\\n\");\n\t\telse\n\t\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on write channel:\"\n\t\t\t\t\" negative reply\\n\",\n\t\t\t\tdev_name(&card->write.ccwdev->dev));\n\t\tgoto out;\n\t}\n\tmemcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\n\tif ((temp & ~0x0100) != qeth_peer_func_level(card->info.func_level)) {\n\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on write channel: \"\n\t\t\t\"function level mismatch (sent: 0x%x, received: \"\n\t\t\t\"0x%x)\\n\", dev_name(&card->write.ccwdev->dev),\n\t\t\tcard->info.func_level, temp);\n\t\tgoto out;\n\t}\n\tchannel->state = CH_STATE_UP;\nout:\n\tqeth_release_buffer(channel, iob);\n}\n\nstatic void qeth_idx_read_cb(struct qeth_channel *channel,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_card *card;\n\t__u16 temp;\n\n\tQETH_DBF_TEXT(SETUP , 2, \"idxrdcb\");\n\tif (channel->state == CH_STATE_DOWN) {\n\t\tchannel->state = CH_STATE_ACTIVATING;\n\t\tgoto out;\n\t}\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tif (qeth_check_idx_response(card, iob->data))\n\t\t\tgoto out;\n\n\tif (!(QETH_IS_IDX_ACT_POS_REPLY(iob->data))) {\n\t\tswitch (QETH_IDX_ACT_CAUSE_CODE(iob->data)) {\n\t\tcase QETH_IDX_ACT_ERR_EXCL:\n\t\t\tdev_err(&card->write.ccwdev->dev,\n\t\t\t\t\"The adapter is used exclusively by another \"\n\t\t\t\t\"host\\n\");\n\t\t\tbreak;\n\t\tcase QETH_IDX_ACT_ERR_AUTH:\n\t\tcase QETH_IDX_ACT_ERR_AUTH_USER:\n\t\t\tdev_err(&card->read.ccwdev->dev,\n\t\t\t\t\"Setting the device online failed because of \"\n\t\t\t\t\"insufficient authorization\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on read channel:\"\n\t\t\t\t\" negative reply\\n\",\n\t\t\t\tdev_name(&card->read.ccwdev->dev));\n\t\t}\n\t\tQETH_CARD_TEXT_(card, 2, \"idxread%c\",\n\t\t\tQETH_IDX_ACT_CAUSE_CODE(iob->data));\n\t\tgoto out;\n\t}\n\n/**\n *  * temporary fix for microcode bug\n *   * to revert it,replace OR by AND\n *    */\n\tif ((!QETH_IDX_NO_PORTNAME_REQUIRED(iob->data)) ||\n\t     (card->info.type == QETH_CARD_TYPE_OSD))\n\t\tcard->info.portname_required = 1;\n\n\tmemcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\n\tif (temp != qeth_peer_func_level(card->info.func_level)) {\n\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on read channel: function \"\n\t\t\t\"level mismatch (sent: 0x%x, received: 0x%x)\\n\",\n\t\t\tdev_name(&card->read.ccwdev->dev),\n\t\t\tcard->info.func_level, temp);\n\t\tgoto out;\n\t}\n\tmemcpy(&card->token.issuer_rm_r,\n\t       QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(&card->info.mcl_level[0],\n\t       QETH_IDX_REPLY_LEVEL(iob->data), QETH_MCL_LENGTH);\n\tchannel->state = CH_STATE_UP;\nout:\n\tqeth_release_buffer(channel, iob);\n}\n\nvoid qeth_prepare_control_data(struct qeth_card *card, int len,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tqeth_setup_ccw(&card->write, iob->data, len);\n\tiob->callback = qeth_release_buffer;\n\n\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\n\t       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\n\tcard->seqno.trans_hdr++;\n\tmemcpy(QETH_PDU_HEADER_SEQ_NO(iob->data),\n\t       &card->seqno.pdu_hdr, QETH_SEQ_NO_LENGTH);\n\tcard->seqno.pdu_hdr++;\n\tmemcpy(QETH_PDU_HEADER_ACK_SEQ_NO(iob->data),\n\t       &card->seqno.pdu_hdr_ack, QETH_SEQ_NO_LENGTH);\n\tQETH_DBF_HEX(CTRL, 2, iob->data, QETH_DBF_CTRL_LEN);\n}\nEXPORT_SYMBOL_GPL(qeth_prepare_control_data);\n\nint qeth_send_control_data(struct qeth_card *card, int len,\n\t\tstruct qeth_cmd_buffer *iob,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct qeth_reply *reply = NULL;\n\tunsigned long timeout, event_timeout;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 2, \"sendctl\");\n\n\tif (card->read_or_write_problem) {\n\t\tqeth_release_buffer(iob->channel, iob);\n\t\treturn -EIO;\n\t}\n\treply = qeth_alloc_reply(card);\n\tif (!reply) {\n\t\treturn -ENOMEM;\n\t}\n\treply->callback = reply_cb;\n\treply->param = reply_param;\n\tif (card->state == CARD_STATE_DOWN)\n\t\treply->seqno = QETH_IDX_COMMAND_SEQNO;\n\telse\n\t\treply->seqno = card->seqno.ipa++;\n\tinit_waitqueue_head(&reply->wait_q);\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_add_tail(&reply->list, &card->cmd_waiter_list);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tQETH_DBF_HEX(CTRL, 2, iob->data, QETH_DBF_CTRL_LEN);\n\n\twhile (atomic_cmpxchg(&card->write.irq_pending, 0, 1)) ;\n\tqeth_prepare_control_data(card, len, iob);\n\n\tif (IS_IPA(iob->data))\n\t\tevent_timeout = QETH_IPA_TIMEOUT;\n\telse\n\t\tevent_timeout = QETH_TIMEOUT;\n\ttimeout = jiffies + event_timeout;\n\n\tQETH_CARD_TEXT(card, 6, \"noirqpnd\");\n\tspin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);\n\trc = ccw_device_start(card->write.ccwdev, &card->write.ccw,\n\t\t\t      (addr_t) iob, 0, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"%s qeth_send_control_data: \"\n\t\t\t\"ccw_device_start rc = %i\\n\",\n\t\t\tdev_name(&card->write.ccwdev->dev), rc);\n\t\tQETH_CARD_TEXT_(card, 2, \" err%d\", rc);\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tlist_del_init(&reply->list);\n\t\tqeth_put_reply(reply);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tqeth_release_buffer(iob->channel, iob);\n\t\tatomic_set(&card->write.irq_pending, 0);\n\t\twake_up(&card->wait_q);\n\t\treturn rc;\n\t}\n\n\t/* we have only one long running ipassist, since we can ensure\n\t   process context of this command we can sleep */\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tif ((cmd->hdr.command == IPA_CMD_SETIP) &&\n\t    (cmd->hdr.prot_version == QETH_PROT_IPV4)) {\n\t\tif (!wait_event_timeout(reply->wait_q,\n\t\t    atomic_read(&reply->received), event_timeout))\n\t\t\tgoto time_err;\n\t} else {\n\t\twhile (!atomic_read(&reply->received)) {\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\tgoto time_err;\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\n\tif (reply->rc == -EIO)\n\t\tgoto error;\n\trc = reply->rc;\n\tqeth_put_reply(reply);\n\treturn rc;\n\ntime_err:\n\treply->rc = -ETIME;\n\tspin_lock_irqsave(&reply->card->lock, flags);\n\tlist_del_init(&reply->list);\n\tspin_unlock_irqrestore(&reply->card->lock, flags);\n\tatomic_inc(&reply->received);\nerror:\n\tatomic_set(&card->write.irq_pending, 0);\n\tqeth_release_buffer(iob->channel, iob);\n\tcard->write.buf_no = (card->write.buf_no + 1) % QETH_CMD_BUFFER_NO;\n\trc = reply->rc;\n\tqeth_put_reply(reply);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_control_data);\n\nstatic int qeth_cm_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmenblcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_filter_r,\n\t       QETH_CM_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_cm_enable(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmenable\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, CM_ENABLE, CM_ENABLE_SIZE);\n\tmemcpy(QETH_CM_ENABLE_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);\n\n\trc = qeth_send_control_data(card, CM_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_cm_enable_cb, NULL);\n\treturn rc;\n}\n\nstatic int qeth_cm_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmsetpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_connection_r,\n\t       QETH_CM_SETUP_RESP_DEST_ADDR(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_cm_setup(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmsetup\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, CM_SETUP, CM_SETUP_SIZE);\n\tmemcpy(QETH_CM_SETUP_DEST_ADDR(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_SETUP_CONNECTION_TOKEN(iob->data),\n\t       &card->token.cm_connection_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_SETUP_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_r, QETH_MPC_TOKEN_LENGTH);\n\trc = qeth_send_control_data(card, CM_SETUP_SIZE, iob,\n\t\t\t\t    qeth_cm_setup_cb, NULL);\n\treturn rc;\n\n}\n\nstatic inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\t\treturn 1500;\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn card->info.max_mtu;\n\tcase QETH_CARD_TYPE_OSD:\n\t\tswitch (card->info.link_type) {\n\t\tcase QETH_LINK_TYPE_HSTR:\n\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\treturn 2000;\n\t\tdefault:\n\t\t\treturn card->options.layer2 ? 1500 : 1492;\n\t\t}\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\treturn card->options.layer2 ? 1500 : 1492;\n\tdefault:\n\t\treturn 1500;\n\t}\n}\n\nstatic inline int qeth_get_mtu_outof_framesize(int framesize)\n{\n\tswitch (framesize) {\n\tcase 0x4000:\n\t\treturn 8192;\n\tcase 0x6000:\n\t\treturn 16384;\n\tcase 0xa000:\n\t\treturn 32768;\n\tcase 0xffff:\n\t\treturn 57344;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int qeth_mtu_is_valid(struct qeth_card *card, int mtu)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn ((mtu >= 576) &&\n\t\t\t(mtu <= card->info.max_mtu));\n\tcase QETH_CARD_TYPE_OSN:\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int qeth_ulp_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\n\t__u16 mtu, framesize;\n\t__u16 len;\n\t__u8 link_type;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpenacb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_filter_r,\n\t       QETH_ULP_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (card->info.type == QETH_CARD_TYPE_IQD) {\n\t\tmemcpy(&framesize, QETH_ULP_ENABLE_RESP_MAX_MTU(iob->data), 2);\n\t\tmtu = qeth_get_mtu_outof_framesize(framesize);\n\t\tif (!mtu) {\n\t\t\tiob->rc = -EINVAL;\n\t\t\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\t\t\treturn 0;\n\t\t}\n\t\tif (card->info.initial_mtu && (card->info.initial_mtu != mtu)) {\n\t\t\t/* frame size has changed */\n\t\t\tif (card->dev &&\n\t\t\t    ((card->dev->mtu == card->info.initial_mtu) ||\n\t\t\t     (card->dev->mtu > mtu)))\n\t\t\t\tcard->dev->mtu = mtu;\n\t\t\tqeth_free_qdio_buffers(card);\n\t\t}\n\t\tcard->info.initial_mtu = mtu;\n\t\tcard->info.max_mtu = mtu;\n\t\tcard->qdio.in_buf_size = mtu + 2 * PAGE_SIZE;\n\t} else {\n\t\tcard->info.max_mtu = *(__u16 *)QETH_ULP_ENABLE_RESP_MAX_MTU(\n\t\t\tiob->data);\n\t\tcard->info.initial_mtu = min(card->info.max_mtu,\n\t\t\t\t\tqeth_get_initial_mtu_for_card(card));\n\t\tcard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\n\t}\n\n\tmemcpy(&len, QETH_ULP_ENABLE_RESP_DIFINFO_LEN(iob->data), 2);\n\tif (len >= QETH_MPC_DIFINFO_LEN_INDICATES_LINK_TYPE) {\n\t\tmemcpy(&link_type,\n\t\t       QETH_ULP_ENABLE_RESP_LINK_TYPE(iob->data), 1);\n\t\tcard->info.link_type = link_type;\n\t} else\n\t\tcard->info.link_type = 0;\n\tQETH_DBF_TEXT_(SETUP, 2, \"link%d\", card->info.link_type);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_ulp_enable(struct qeth_card *card)\n{\n\tint rc;\n\tchar prot_type;\n\tstruct qeth_cmd_buffer *iob;\n\n\t/*FIXME: trace view callbacks*/\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpenabl\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, ULP_ENABLE, ULP_ENABLE_SIZE);\n\n\t*(QETH_ULP_ENABLE_LINKNUM(iob->data)) =\n\t\t(__u8) card->info.portno;\n\tif (card->options.layer2)\n\t\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\t\tprot_type = QETH_PROT_OSN2;\n\t\telse\n\t\t\tprot_type = QETH_PROT_LAYER2;\n\telse\n\t\tprot_type = QETH_PROT_TCPIP;\n\n\tmemcpy(QETH_ULP_ENABLE_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_ULP_ENABLE_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_PORTNAME_AND_LL(iob->data),\n\t       card->info.portname, 9);\n\trc = qeth_send_control_data(card, ULP_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_ulp_enable_cb, NULL);\n\treturn rc;\n\n}\n\nstatic int qeth_ulp_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpstpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_connection_r,\n\t       QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (!strncmp(\"00S\", QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t\t     3)) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"olmlimit\");\n\t\tdev_err(&card->gdev->dev, \"A connection could not be \"\n\t\t\t\"established because of an OLM limit\\n\");\n\t\tiob->rc = -EMLINK;\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_ulp_setup(struct qeth_card *card)\n{\n\tint rc;\n\t__u16 temp;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct ccw_dev_id dev_id;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpsetup\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, ULP_SETUP, ULP_SETUP_SIZE);\n\n\tmemcpy(QETH_ULP_SETUP_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_SETUP_CONNECTION_TOKEN(iob->data),\n\t       &card->token.ulp_connection_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_SETUP_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_r, QETH_MPC_TOKEN_LENGTH);\n\n\tccw_device_get_id(CARD_DDEV(card), &dev_id);\n\tmemcpy(QETH_ULP_SETUP_CUA(iob->data), &dev_id.devno, 2);\n\ttemp = (card->info.cula << 8) + card->info.unit_addr2;\n\tmemcpy(QETH_ULP_SETUP_REAL_DEVADDR(iob->data), &temp, 2);\n\trc = qeth_send_control_data(card, ULP_SETUP_SIZE, iob,\n\t\t\t\t    qeth_ulp_setup_cb, NULL);\n\treturn rc;\n}\n\nstatic int qeth_init_qdio_out_buf(struct qeth_qdio_out_q *q, int bidx)\n{\n\tint rc;\n\tstruct qeth_qdio_out_buffer *newbuf;\n\n\trc = 0;\n\tnewbuf = kmem_cache_zalloc(qeth_qdio_outbuf_cache, GFP_ATOMIC);\n\tif (!newbuf) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewbuf->buffer = &q->qdio_bufs[bidx];\n\tskb_queue_head_init(&newbuf->skb_list);\n\tlockdep_set_class(&newbuf->skb_list.lock, &qdio_out_skb_queue_key);\n\tnewbuf->q = q;\n\tnewbuf->aob = NULL;\n\tnewbuf->next_pending = q->bufs[bidx];\n\tatomic_set(&newbuf->state, QETH_QDIO_BUF_EMPTY);\n\tq->bufs[bidx] = newbuf;\n\tif (q->bufstates) {\n\t\tq->bufstates[bidx].user = newbuf;\n\t\tQETH_CARD_TEXT_(q->card, 2, \"nbs%d\", bidx);\n\t\tQETH_CARD_TEXT_(q->card, 2, \"%lx\", (long) newbuf);\n\t\tQETH_CARD_TEXT_(q->card, 2, \"%lx\",\n\t\t\t\t(long) newbuf->next_pending);\n\t}\nout:\n\treturn rc;\n}\n\n\nstatic int qeth_alloc_qdio_buffers(struct qeth_card *card)\n{\n\tint i, j;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"allcqdbf\");\n\n\tif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED,\n\t\tQETH_QDIO_ALLOCATED) != QETH_QDIO_UNINITIALIZED)\n\t\treturn 0;\n\n\tcard->qdio.in_q = kzalloc(sizeof(struct qeth_qdio_q),\n\t\t\t\t   GFP_KERNEL);\n\tif (!card->qdio.in_q)\n\t\tgoto out_nomem;\n\tQETH_DBF_TEXT(SETUP, 2, \"inq\");\n\tQETH_DBF_HEX(SETUP, 2, &card->qdio.in_q, sizeof(void *));\n\tmemset(card->qdio.in_q, 0, sizeof(struct qeth_qdio_q));\n\t/* give inbound qeth_qdio_buffers their qdio_buffers */\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\tcard->qdio.in_q->bufs[i].buffer =\n\t\t\t&card->qdio.in_q->qdio_bufs[i];\n\t\tcard->qdio.in_q->bufs[i].rx_skb = NULL;\n\t}\n\t/* inbound buffer pool */\n\tif (qeth_alloc_buffer_pool(card))\n\t\tgoto out_freeinq;\n\n\t/* outbound */\n\tcard->qdio.out_qs =\n\t\tkzalloc(card->qdio.no_out_queues *\n\t\t\tsizeof(struct qeth_qdio_out_q *), GFP_KERNEL);\n\tif (!card->qdio.out_qs)\n\t\tgoto out_freepool;\n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tcard->qdio.out_qs[i] = kzalloc(sizeof(struct qeth_qdio_out_q),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!card->qdio.out_qs[i])\n\t\t\tgoto out_freeoutq;\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"outq %i\", i);\n\t\tQETH_DBF_HEX(SETUP, 2, &card->qdio.out_qs[i], sizeof(void *));\n\t\tcard->qdio.out_qs[i]->queue_no = i;\n\t\t/* give outbound qeth_qdio_buffers their qdio_buffers */\n\t\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\t\tWARN_ON(card->qdio.out_qs[i]->bufs[j] != NULL);\n\t\t\tif (qeth_init_qdio_out_buf(card->qdio.out_qs[i], j))\n\t\t\t\tgoto out_freeoutqbufs;\n\t\t}\n\t}\n\n\t/* completion */\n\tif (qeth_alloc_cq(card))\n\t\tgoto out_freeoutq;\n\n\treturn 0;\n\nout_freeoutqbufs:\n\twhile (j > 0) {\n\t\t--j;\n\t\tkmem_cache_free(qeth_qdio_outbuf_cache,\n\t\t\t\tcard->qdio.out_qs[i]->bufs[j]);\n\t\tcard->qdio.out_qs[i]->bufs[j] = NULL;\n\t}\nout_freeoutq:\n\twhile (i > 0) {\n\t\tkfree(card->qdio.out_qs[--i]);\n\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\n\t}\n\tkfree(card->qdio.out_qs);\n\tcard->qdio.out_qs = NULL;\nout_freepool:\n\tqeth_free_buffer_pool(card);\nout_freeinq:\n\tkfree(card->qdio.in_q);\n\tcard->qdio.in_q = NULL;\nout_nomem:\n\tatomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\n\treturn -ENOMEM;\n}\n\nstatic void qeth_create_qib_param_field(struct qeth_card *card,\n\t\tchar *param_field)\n{\n\n\tparam_field[0] = _ascebc['P'];\n\tparam_field[1] = _ascebc['C'];\n\tparam_field[2] = _ascebc['I'];\n\tparam_field[3] = _ascebc['T'];\n\t*((unsigned int *) (&param_field[4])) = QETH_PCI_THRESHOLD_A(card);\n\t*((unsigned int *) (&param_field[8])) = QETH_PCI_THRESHOLD_B(card);\n\t*((unsigned int *) (&param_field[12])) = QETH_PCI_TIMER_VALUE(card);\n}\n\nstatic void qeth_create_qib_param_field_blkt(struct qeth_card *card,\n\t\tchar *param_field)\n{\n\tparam_field[16] = _ascebc['B'];\n\tparam_field[17] = _ascebc['L'];\n\tparam_field[18] = _ascebc['K'];\n\tparam_field[19] = _ascebc['T'];\n\t*((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;\n\t*((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;\n\t*((unsigned int *) (&param_field[28])) =\n\t\tcard->info.blkt.inter_packet_jumbo;\n}\n\nstatic int qeth_qdio_activate(struct qeth_card *card)\n{\n\tQETH_DBF_TEXT(SETUP, 3, \"qdioact\");\n\treturn qdio_activate(CARD_DDEV(card));\n}\n\nstatic int qeth_dm_act(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"dmact\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, DM_ACT, DM_ACT_SIZE);\n\n\tmemcpy(QETH_DM_ACT_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_DM_ACT_CONNECTION_TOKEN(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n\trc = qeth_send_control_data(card, DM_ACT_SIZE, iob, NULL, NULL);\n\treturn rc;\n}\n\nstatic int qeth_mpc_initialize(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"mpcinit\");\n\n\trc = qeth_issue_next_read(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_cm_enable(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_cm_setup(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_ulp_enable(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"4err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_ulp_setup(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_alloc_qdio_buffers(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_qdio_establish(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"6err%d\", rc);\n\t\tqeth_free_qdio_buffers(card);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_qdio_activate(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"7err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_dm_act(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"8err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\n\treturn 0;\nout_qdio:\n\tqeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);\n\treturn rc;\n}\n\nstatic void qeth_print_status_with_portname(struct qeth_card *card)\n{\n\tchar dbf_text[15];\n\tint i;\n\n\tsprintf(dbf_text, \"%s\", card->info.portname + 1);\n\tfor (i = 0; i < 8; i++)\n\t\tdbf_text[i] =\n\t\t\t(char) _ebcasc[(__u8) dbf_text[i]];\n\tdbf_text[8] = 0;\n\tdev_info(&card->gdev->dev, \"Device is a%s card%s%s%s\\n\"\n\t       \"with link type %s (portname: %s)\\n\",\n\t       qeth_get_cardname(card),\n\t       (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t       (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t       (card->info.mcl_level[0]) ? \")\" : \"\",\n\t       qeth_get_cardname_short(card),\n\t       dbf_text);\n\n}\n\nstatic void qeth_print_status_no_portname(struct qeth_card *card)\n{\n\tif (card->info.portname[0])\n\t\tdev_info(&card->gdev->dev, \"Device is a%s \"\n\t\t       \"card%s%s%s\\nwith link type %s \"\n\t\t       \"(no portname needed by interface).\\n\",\n\t\t       qeth_get_cardname(card),\n\t\t       (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t\t       (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t\t       (card->info.mcl_level[0]) ? \")\" : \"\",\n\t\t       qeth_get_cardname_short(card));\n\telse\n\t\tdev_info(&card->gdev->dev, \"Device is a%s \"\n\t\t       \"card%s%s%s\\nwith link type %s.\\n\",\n\t\t       qeth_get_cardname(card),\n\t\t       (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t\t       (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t\t       (card->info.mcl_level[0]) ? \")\" : \"\",\n\t\t       qeth_get_cardname_short(card));\n}\n\nvoid qeth_print_status_message(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\t/* VM will use a non-zero first character\n\t\t * to indicate a HiperSockets like reporting\n\t\t * of the level OSA sets the first character to zero\n\t\t * */\n\t\tif (!card->info.mcl_level[0]) {\n\t\t\tsprintf(card->info.mcl_level, \"%02x%02x\",\n\t\t\t\tcard->info.mcl_level[2],\n\t\t\t\tcard->info.mcl_level[3]);\n\n\t\t\tcard->info.mcl_level[QETH_MCL_LENGTH] = 0;\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tcase QETH_CARD_TYPE_IQD:\n\t\tif ((card->info.guestlan) ||\n\t\t    (card->info.mcl_level[0] & 0x80)) {\n\t\t\tcard->info.mcl_level[0] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[0]];\n\t\t\tcard->info.mcl_level[1] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[1]];\n\t\t\tcard->info.mcl_level[2] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[2]];\n\t\t\tcard->info.mcl_level[3] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[3]];\n\t\t\tcard->info.mcl_level[QETH_MCL_LENGTH] = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmemset(&card->info.mcl_level[0], 0, QETH_MCL_LENGTH + 1);\n\t}\n\tif (card->info.portname_required)\n\t\tqeth_print_status_with_portname(card);\n\telse\n\t\tqeth_print_status_no_portname(card);\n}\nEXPORT_SYMBOL_GPL(qeth_print_status_message);\n\nstatic void qeth_initialize_working_pool_list(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *entry;\n\n\tQETH_CARD_TEXT(card, 5, \"inwrklst\");\n\n\tlist_for_each_entry(entry,\n\t\t\t    &card->qdio.init_pool.entry_list, init_list) {\n\t\tqeth_put_buffer_pool_entry(card, entry);\n\t}\n}\n\nstatic inline struct qeth_buffer_pool_entry *qeth_find_free_buffer_pool_entry(\n\t\tstruct qeth_card *card)\n{\n\tstruct list_head *plh;\n\tstruct qeth_buffer_pool_entry *entry;\n\tint i, free;\n\tstruct page *page;\n\n\tif (list_empty(&card->qdio.in_buf_pool.entry_list))\n\t\treturn NULL;\n\n\tlist_for_each(plh, &card->qdio.in_buf_pool.entry_list) {\n\t\tentry = list_entry(plh, struct qeth_buffer_pool_entry, list);\n\t\tfree = 1;\n\t\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\t\tif (page_count(virt_to_page(entry->elements[i])) > 1) {\n\t\t\t\tfree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (free) {\n\t\t\tlist_del_init(&entry->list);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\t/* no free buffer in pool so take first one and swap pages */\n\tentry = list_entry(card->qdio.in_buf_pool.entry_list.next,\n\t\t\tstruct qeth_buffer_pool_entry, list);\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\tif (page_count(virt_to_page(entry->elements[i])) > 1) {\n\t\t\tpage = alloc_page(GFP_ATOMIC);\n\t\t\tif (!page) {\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tfree_page((unsigned long)entry->elements[i]);\n\t\t\t\tentry->elements[i] = page_address(page);\n\t\t\t\tif (card->options.performance_stats)\n\t\t\t\t\tcard->perf_stats.sg_alloc_page_rx++;\n\t\t\t}\n\t\t}\n\t}\n\tlist_del_init(&entry->list);\n\treturn entry;\n}\n\nstatic int qeth_init_input_buffer(struct qeth_card *card,\n\t\tstruct qeth_qdio_buffer *buf)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry;\n\tint i;\n\n\tif ((card->options.cq == QETH_CQ_ENABLED) && (!buf->rx_skb)) {\n\t\tbuf->rx_skb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\n\t\tif (!buf->rx_skb)\n\t\t\treturn 1;\n\t}\n\n\tpool_entry = qeth_find_free_buffer_pool_entry(card);\n\tif (!pool_entry)\n\t\treturn 1;\n\n\t/*\n\t * since the buffer is accessed only from the input_tasklet\n\t * there shouldn't be a need to synchronize; also, since we use\n\t * the QETH_IN_BUF_REQUEUE_THRESHOLD we should never run  out off\n\t * buffers\n\t */\n\n\tbuf->pool_entry = pool_entry;\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\tbuf->buffer->element[i].length = PAGE_SIZE;\n\t\tbuf->buffer->element[i].addr =  pool_entry->elements[i];\n\t\tif (i == QETH_MAX_BUFFER_ELEMENTS(card) - 1)\n\t\t\tbuf->buffer->element[i].eflags = SBAL_EFLAGS_LAST_ENTRY;\n\t\telse\n\t\t\tbuf->buffer->element[i].eflags = 0;\n\t\tbuf->buffer->element[i].sflags = 0;\n\t}\n\treturn 0;\n}\n\nint qeth_init_qdio_queues(struct qeth_card *card)\n{\n\tint i, j;\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"initqdqs\");\n\n\t/* inbound queue */\n\tmemset(card->qdio.in_q->qdio_bufs, 0,\n\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));\n\tqeth_initialize_working_pool_list(card);\n\t/*give only as many buffers to hardware as we have buffer pool entries*/\n\tfor (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)\n\t\tqeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);\n\tcard->qdio.in_q->next_buf_to_init =\n\t\tcard->qdio.in_buf_pool.buf_count - 1;\n\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,\n\t\t     card->qdio.in_buf_pool.buf_count - 1);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\treturn rc;\n\t}\n\n\t/* completion */\n\trc = qeth_cq_init(card);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* outbound queue */\n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tmemset(card->qdio.out_qs[i]->qdio_bufs, 0,\n\t\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));\n\t\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\t\tqeth_clear_output_buffer(card->qdio.out_qs[i],\n\t\t\t\t\tcard->qdio.out_qs[i]->bufs[j],\n\t\t\t\t\tQETH_QDIO_BUF_EMPTY);\n\t\t}\n\t\tcard->qdio.out_qs[i]->card = card;\n\t\tcard->qdio.out_qs[i]->next_buf_to_fill = 0;\n\t\tcard->qdio.out_qs[i]->do_pack = 0;\n\t\tatomic_set(&card->qdio.out_qs[i]->used_buffers, 0);\n\t\tatomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);\n\t\tatomic_set(&card->qdio.out_qs[i]->state,\n\t\t\t   QETH_OUT_Q_UNLOCKED);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_init_qdio_queues);\n\nstatic inline __u8 qeth_get_ipa_adp_type(enum qeth_link_types link_type)\n{\n\tswitch (link_type) {\n\tcase QETH_LINK_TYPE_HSTR:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void qeth_fill_ipacmd_header(struct qeth_card *card,\n\t\tstruct qeth_ipa_cmd *cmd, __u8 command,\n\t\tenum qeth_prot_versions prot)\n{\n\tmemset(cmd, 0, sizeof(struct qeth_ipa_cmd));\n\tcmd->hdr.command = command;\n\tcmd->hdr.initiator = IPA_CMD_INITIATOR_HOST;\n\tcmd->hdr.seqno = card->seqno.ipa;\n\tcmd->hdr.adapter_type = qeth_get_ipa_adp_type(card->info.link_type);\n\tcmd->hdr.rel_adapter_no = (__u8) card->info.portno;\n\tif (card->options.layer2)\n\t\tcmd->hdr.prim_version_no = 2;\n\telse\n\t\tcmd->hdr.prim_version_no = 1;\n\tcmd->hdr.param_count = 1;\n\tcmd->hdr.prot_version = prot;\n\tcmd->hdr.ipa_supported = 0;\n\tcmd->hdr.ipa_enabled = 0;\n}\n\nstruct qeth_cmd_buffer *qeth_get_ipacmd_buffer(struct qeth_card *card,\n\t\tenum qeth_ipa_cmds ipacmd, enum qeth_prot_versions prot)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tqeth_fill_ipacmd_header(card, cmd, ipacmd, prot);\n\n\treturn iob;\n}\nEXPORT_SYMBOL_GPL(qeth_get_ipacmd_buffer);\n\nvoid qeth_prepare_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\n\t\tchar prot_type)\n{\n\tmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\n\tmemcpy(QETH_IPA_CMD_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n}\nEXPORT_SYMBOL_GPL(qeth_prepare_ipa_cmd);\n\nint qeth_send_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply*,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tint rc;\n\tchar prot_type;\n\n\tQETH_CARD_TEXT(card, 4, \"sendipa\");\n\n\tif (card->options.layer2)\n\t\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\t\tprot_type = QETH_PROT_OSN2;\n\t\telse\n\t\t\tprot_type = QETH_PROT_LAYER2;\n\telse\n\t\tprot_type = QETH_PROT_TCPIP;\n\tqeth_prepare_ipa_cmd(card, iob, prot_type);\n\trc = qeth_send_control_data(card, IPA_CMD_LENGTH,\n\t\t\t\t\t\tiob, reply_cb, reply_param);\n\tif (rc == -ETIME) {\n\t\tqeth_clear_ipacmd_list(card);\n\t\tqeth_schedule_recovery(card);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_ipa_cmd);\n\nint qeth_send_startlan(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"strtlan\");\n\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_STARTLAN, 0);\n\trc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_startlan);\n\nstatic int qeth_default_setadapterparms_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"defadpcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (cmd->hdr.return_code == 0)\n\t\tcmd->hdr.return_code =\n\t\t\tcmd->data.setadapterparms.hdr.return_code;\n\treturn 0;\n}\n\nstatic int qeth_query_setadapterparms_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 3, \"quyadpcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (cmd->data.setadapterparms.data.query_cmds_supp.lan_type & 0x7f) {\n\t\tcard->info.link_type =\n\t\t      cmd->data.setadapterparms.data.query_cmds_supp.lan_type;\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"lnk %d\", card->info.link_type);\n\t}\n\tcard->options.adp.supported_funcs =\n\t\tcmd->data.setadapterparms.data.query_cmds_supp.supported_cmds;\n\treturn qeth_default_setadapterparms_cb(card, reply, (unsigned long)cmd);\n}\n\nstatic struct qeth_cmd_buffer *qeth_get_adapter_cmd(struct qeth_card *card,\n\t\t__u32 command, __u32 cmdlen)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETADAPTERPARMS,\n\t\t\t\t     QETH_PROT_IPV4);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.setadapterparms.hdr.cmdlength = cmdlen;\n\tcmd->data.setadapterparms.hdr.command_code = command;\n\tcmd->data.setadapterparms.hdr.used_total = 1;\n\tcmd->data.setadapterparms.hdr.seq_no = 1;\n\n\treturn iob;\n}\n\nint qeth_query_setadapterparms(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 3, \"queryadp\");\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_COMMANDS_SUPPORTED,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms));\n\trc = qeth_send_ipa_cmd(card, iob, qeth_query_setadapterparms_cb, NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_query_setadapterparms);\n\nstatic int qeth_query_ipassists_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"qipasscb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\n\tswitch (cmd->hdr.return_code) {\n\tcase IPA_RC_NOTSUPP:\n\tcase IPA_RC_L2_UNSUPPORTED_CMD:\n\t\tQETH_DBF_TEXT(SETUP, 2, \"ipaunsup\");\n\t\tcard->options.ipa4.supported_funcs |= IPA_SETADAPTERPARMS;\n\t\tcard->options.ipa6.supported_funcs |= IPA_SETADAPTERPARMS;\n\t\treturn -0;\n\tdefault:\n\t\tif (cmd->hdr.return_code) {\n\t\t\tQETH_DBF_MESSAGE(1, \"%s IPA_CMD_QIPASSIST: Unhandled \"\n\t\t\t\t\t\t\"rc=%d\\n\",\n\t\t\t\t\t\tdev_name(&card->gdev->dev),\n\t\t\t\t\t\tcmd->hdr.return_code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (cmd->hdr.prot_version == QETH_PROT_IPV4) {\n\t\tcard->options.ipa4.supported_funcs = cmd->hdr.ipa_supported;\n\t\tcard->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;\n\t} else if (cmd->hdr.prot_version == QETH_PROT_IPV6) {\n\t\tcard->options.ipa6.supported_funcs = cmd->hdr.ipa_supported;\n\t\tcard->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;\n\t} else\n\t\tQETH_DBF_MESSAGE(1, \"%s IPA_CMD_QIPASSIST: Flawed LIC detected\"\n\t\t\t\t\t\"\\n\", dev_name(&card->gdev->dev));\n\treturn 0;\n}\n\nint qeth_query_ipassists(struct qeth_card *card, enum qeth_prot_versions prot)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"qipassi%i\", prot);\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_QIPASSIST, prot);\n\trc = qeth_send_ipa_cmd(card, iob, qeth_query_ipassists_cb, NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_query_ipassists);\n\nstatic int qeth_query_setdiagass_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\t__u16 rc;\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\trc = cmd->hdr.return_code;\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"diagq:%x\", rc);\n\telse\n\t\tcard->info.diagass_support = cmd->data.diagass.ext;\n\treturn 0;\n}\n\nstatic int qeth_query_setdiagass(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd    *cmd;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"qdiagass\");\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.diagass.subcmd_len = 16;\n\tcmd->data.diagass.subcmd = QETH_DIAGS_CMD_QUERY;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_query_setdiagass_cb, NULL);\n}\n\nstatic void qeth_get_trap_id(struct qeth_card *card, struct qeth_trap_id *tid)\n{\n\tunsigned long info = get_zeroed_page(GFP_KERNEL);\n\tstruct sysinfo_2_2_2 *info222 = (struct sysinfo_2_2_2 *)info;\n\tstruct sysinfo_3_2_2 *info322 = (struct sysinfo_3_2_2 *)info;\n\tstruct ccw_dev_id ccwid;\n\tint level;\n\n\ttid->chpid = card->info.chpid;\n\tccw_device_get_id(CARD_RDEV(card), &ccwid);\n\ttid->ssid = ccwid.ssid;\n\ttid->devno = ccwid.devno;\n\tif (!info)\n\t\treturn;\n\tlevel = stsi(NULL, 0, 0, 0);\n\tif ((level >= 2) && (stsi(info222, 2, 2, 2) == 0))\n\t\ttid->lparnr = info222->lpar_number;\n\tif ((level >= 3) && (stsi(info322, 3, 2, 2) == 0)) {\n\t\tEBCASC(info322->vm[0].name, sizeof(info322->vm[0].name));\n\t\tmemcpy(tid->vmname, info322->vm[0].name, sizeof(tid->vmname));\n\t}\n\tfree_page(info);\n\treturn;\n}\n\nstatic int qeth_hw_trap_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\t__u16 rc;\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\trc = cmd->hdr.return_code;\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"trapc:%x\", rc);\n\treturn 0;\n}\n\nint qeth_hw_trap(struct qeth_card *card, enum qeth_diags_trap_action action)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"diagtrap\");\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.diagass.subcmd_len = 80;\n\tcmd->data.diagass.subcmd = QETH_DIAGS_CMD_TRAP;\n\tcmd->data.diagass.type = 1;\n\tcmd->data.diagass.action = action;\n\tswitch (action) {\n\tcase QETH_DIAGS_TRAP_ARM:\n\t\tcmd->data.diagass.options = 0x0003;\n\t\tcmd->data.diagass.ext = 0x00010000 +\n\t\t\tsizeof(struct qeth_trap_id);\n\t\tqeth_get_trap_id(card,\n\t\t\t(struct qeth_trap_id *)cmd->data.diagass.cdata);\n\t\tbreak;\n\tcase QETH_DIAGS_TRAP_DISARM:\n\t\tcmd->data.diagass.options = 0x0001;\n\t\tbreak;\n\tcase QETH_DIAGS_TRAP_CAPTURE:\n\t\tbreak;\n\t}\n\treturn qeth_send_ipa_cmd(card, iob, qeth_hw_trap_cb, NULL);\n}\nEXPORT_SYMBOL_GPL(qeth_hw_trap);\n\nint qeth_check_qdio_errors(struct qeth_card *card, struct qdio_buffer *buf,\n\t\tunsigned int qdio_error, const char *dbftext)\n{\n\tif (qdio_error) {\n\t\tQETH_CARD_TEXT(card, 2, dbftext);\n\t\tQETH_CARD_TEXT_(card, 2, \" F15=%02X\",\n\t\t\t       buf->element[15].sflags);\n\t\tQETH_CARD_TEXT_(card, 2, \" F14=%02X\",\n\t\t\t       buf->element[14].sflags);\n\t\tQETH_CARD_TEXT_(card, 2, \" qerr=%X\", qdio_error);\n\t\tif ((buf->element[15].sflags) == 0x12) {\n\t\t\tcard->stats.rx_dropped++;\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_check_qdio_errors);\n\nvoid qeth_buffer_reclaim_work(struct work_struct *work)\n{\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\tbuffer_reclaim_work.work);\n\n\tQETH_CARD_TEXT_(card, 2, \"brw:%x\", card->reclaim_index);\n\tqeth_queue_input_buffer(card, card->reclaim_index);\n}\n\nvoid qeth_queue_input_buffer(struct qeth_card *card, int index)\n{\n\tstruct qeth_qdio_q *queue = card->qdio.in_q;\n\tstruct list_head *lh;\n\tint count;\n\tint i;\n\tint rc;\n\tint newcount = 0;\n\n\tcount = (index < queue->next_buf_to_init)?\n\t\tcard->qdio.in_buf_pool.buf_count -\n\t\t(queue->next_buf_to_init - index) :\n\t\tcard->qdio.in_buf_pool.buf_count -\n\t\t(queue->next_buf_to_init + QDIO_MAX_BUFFERS_PER_Q - index);\n\t/* only requeue at a certain threshold to avoid SIGAs */\n\tif (count >= QETH_IN_BUF_REQUEUE_THRESHOLD(card)) {\n\t\tfor (i = queue->next_buf_to_init;\n\t\t     i < queue->next_buf_to_init + count; ++i) {\n\t\t\tif (qeth_init_input_buffer(card,\n\t\t\t\t&queue->bufs[i % QDIO_MAX_BUFFERS_PER_Q])) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tnewcount++;\n\t\t\t}\n\t\t}\n\n\t\tif (newcount < count) {\n\t\t\t/* we are in memory shortage so we switch back to\n\t\t\t   traditional skb allocation and drop packages */\n\t\t\tatomic_set(&card->force_alloc_skb, 3);\n\t\t\tcount = newcount;\n\t\t} else {\n\t\t\tatomic_add_unless(&card->force_alloc_skb, -1, 0);\n\t\t}\n\n\t\tif (!count) {\n\t\t\ti = 0;\n\t\t\tlist_for_each(lh, &card->qdio.in_buf_pool.entry_list)\n\t\t\t\ti++;\n\t\t\tif (i == card->qdio.in_buf_pool.buf_count) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"qsarbw\");\n\t\t\t\tcard->reclaim_index = index;\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t&card->buffer_reclaim_work,\n\t\t\t\t\tQETH_RECLAIM_WORK_TIME);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * according to old code it should be avoided to requeue all\n\t\t * 128 buffers in order to benefit from PCI avoidance.\n\t\t * this function keeps at least one buffer (the buffer at\n\t\t * 'index') un-requeued -> this buffer is the first buffer that\n\t\t * will be requeued the next time\n\t\t */\n\t\tif (card->options.performance_stats) {\n\t\t\tcard->perf_stats.inbound_do_qdio_cnt++;\n\t\t\tcard->perf_stats.inbound_do_qdio_start_time =\n\t\t\t\tqeth_get_micros();\n\t\t}\n\t\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0,\n\t\t\t     queue->next_buf_to_init, count);\n\t\tif (card->options.performance_stats)\n\t\t\tcard->perf_stats.inbound_do_qdio_time +=\n\t\t\t\tqeth_get_micros() -\n\t\t\t\tcard->perf_stats.inbound_do_qdio_start_time;\n\t\tif (rc) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"qinberr\");\n\t\t}\n\t\tqueue->next_buf_to_init = (queue->next_buf_to_init + count) %\n\t\t\t\t\t  QDIO_MAX_BUFFERS_PER_Q;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_queue_input_buffer);\n\nstatic int qeth_handle_send_error(struct qeth_card *card,\n\t\tstruct qeth_qdio_out_buffer *buffer, unsigned int qdio_err)\n{\n\tint sbalf15 = buffer->buffer->element[15].sflags;\n\n\tQETH_CARD_TEXT(card, 6, \"hdsnderr\");\n\tif (card->info.type == QETH_CARD_TYPE_IQD) {\n\t\tif (sbalf15 == 0) {\n\t\t\tqdio_err = 0;\n\t\t} else {\n\t\t\tqdio_err = 1;\n\t\t}\n\t}\n\tqeth_check_qdio_errors(card, buffer->buffer, qdio_err, \"qouterr\");\n\n\tif (!qdio_err)\n\t\treturn QETH_SEND_ERROR_NONE;\n\n\tif ((sbalf15 >= 15) && (sbalf15 <= 31))\n\t\treturn QETH_SEND_ERROR_RETRY;\n\n\tQETH_CARD_TEXT(card, 1, \"lnkfail\");\n\tQETH_CARD_TEXT_(card, 1, \"%04x %02x\",\n\t\t       (u16)qdio_err, (u8)sbalf15);\n\treturn QETH_SEND_ERROR_LINK_FAILURE;\n}\n\n/*\n * Switched to packing state if the number of used buffers on a queue\n * reaches a certain limit.\n */\nstatic void qeth_switch_to_packing_if_needed(struct qeth_qdio_out_q *queue)\n{\n\tif (!queue->do_pack) {\n\t\tif (atomic_read(&queue->used_buffers)\n\t\t    >= QETH_HIGH_WATERMARK_PACK){\n\t\t\t/* switch non-PACKING -> PACKING */\n\t\t\tQETH_CARD_TEXT(queue->card, 6, \"np->pack\");\n\t\t\tif (queue->card->options.performance_stats)\n\t\t\t\tqueue->card->perf_stats.sc_dp_p++;\n\t\t\tqueue->do_pack = 1;\n\t\t}\n\t}\n}\n\n/*\n * Switches from packing to non-packing mode. If there is a packing\n * buffer on the queue this buffer will be prepared to be flushed.\n * In that case 1 is returned to inform the caller. If no buffer\n * has to be flushed, zero is returned.\n */\nstatic int qeth_switch_to_nonpacking_if_needed(struct qeth_qdio_out_q *queue)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint flush_count = 0;\n\n\tif (queue->do_pack) {\n\t\tif (atomic_read(&queue->used_buffers)\n\t\t    <= QETH_LOW_WATERMARK_PACK) {\n\t\t\t/* switch PACKING -> non-PACKING */\n\t\t\tQETH_CARD_TEXT(queue->card, 6, \"pack->np\");\n\t\t\tif (queue->card->options.performance_stats)\n\t\t\t\tqueue->card->perf_stats.sc_p_dp++;\n\t\t\tqueue->do_pack = 0;\n\t\t\t/* flush packing buffers */\n\t\t\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t\t\tif ((atomic_read(&buffer->state) ==\n\t\t\t\t\t\tQETH_QDIO_BUF_EMPTY) &&\n\t\t\t    (buffer->next_element_to_fill > 0)) {\n\t\t\t\tatomic_set(&buffer->state,\n\t\t\t\t\t   QETH_QDIO_BUF_PRIMED);\n\t\t\t\tflush_count++;\n\t\t\t\tqueue->next_buf_to_fill =\n\t\t\t\t\t(queue->next_buf_to_fill + 1) %\n\t\t\t\t\tQDIO_MAX_BUFFERS_PER_Q;\n\t\t\t}\n\t\t}\n\t}\n\treturn flush_count;\n}\n\n\n/*\n * Called to flush a packing buffer if no more pci flags are on the queue.\n * Checks if there is a packing buffer and prepares it to be flushed.\n * In that case returns 1, otherwise zero.\n */\nstatic int qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\tif ((atomic_read(&buffer->state) == QETH_QDIO_BUF_EMPTY) &&\n\t   (buffer->next_element_to_fill > 0)) {\n\t\t/* it's a packing buffer */\n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\tqueue->next_buf_to_fill =\n\t\t\t(queue->next_buf_to_fill + 1) % QDIO_MAX_BUFFERS_PER_Q;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_flush_buffers(struct qeth_qdio_out_q *queue, int index,\n\t\t\t       int count)\n{\n\tstruct qeth_qdio_out_buffer *buf;\n\tint rc;\n\tint i;\n\tunsigned int qdio_flags;\n\n\tfor (i = index; i < index + count; ++i) {\n\t\tint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tbuf = queue->bufs[bidx];\n\t\tbuf->buffer->element[buf->next_element_to_fill - 1].eflags |=\n\t\t\t\tSBAL_EFLAGS_LAST_ENTRY;\n\n\t\tif (queue->bufstates)\n\t\t\tqueue->bufstates[bidx].user = buf;\n\n\t\tif (queue->card->info.type == QETH_CARD_TYPE_IQD)\n\t\t\tcontinue;\n\n\t\tif (!queue->do_pack) {\n\t\t\tif ((atomic_read(&queue->used_buffers) >=\n\t\t\t\t(QETH_HIGH_WATERMARK_PACK -\n\t\t\t\t QETH_WATERMARK_PACK_FUZZ)) &&\n\t\t\t    !atomic_read(&queue->set_pci_flags_count)) {\n\t\t\t\t/* it's likely that we'll go to packing\n\t\t\t\t * mode soon */\n\t\t\t\tatomic_inc(&queue->set_pci_flags_count);\n\t\t\t\tbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!atomic_read(&queue->set_pci_flags_count)) {\n\t\t\t\t/*\n\t\t\t\t * there's no outstanding PCI any more, so we\n\t\t\t\t * have to request a PCI to be sure the the PCI\n\t\t\t\t * will wake at some time in the future then we\n\t\t\t\t * can flush packed buffers that might still be\n\t\t\t\t * hanging around, which can happen if no\n\t\t\t\t * further send was requested by the stack\n\t\t\t\t */\n\t\t\t\tatomic_inc(&queue->set_pci_flags_count);\n\t\t\t\tbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue->card->dev->trans_start = jiffies;\n\tif (queue->card->options.performance_stats) {\n\t\tqueue->card->perf_stats.outbound_do_qdio_cnt++;\n\t\tqueue->card->perf_stats.outbound_do_qdio_start_time =\n\t\t\tqeth_get_micros();\n\t}\n\tqdio_flags = QDIO_FLAG_SYNC_OUTPUT;\n\tif (atomic_read(&queue->set_pci_flags_count))\n\t\tqdio_flags |= QDIO_FLAG_PCI_OUT;\n\trc = do_QDIO(CARD_DDEV(queue->card), qdio_flags,\n\t\t     queue->queue_no, index, count);\n\tif (queue->card->options.performance_stats)\n\t\tqueue->card->perf_stats.outbound_do_qdio_time +=\n\t\t\tqeth_get_micros() -\n\t\t\tqueue->card->perf_stats.outbound_do_qdio_start_time;\n\tatomic_add(count, &queue->used_buffers);\n\tif (rc) {\n\t\tqueue->card->stats.tx_errors += count;\n\t\t/* ignore temporary SIGA errors without busy condition */\n\t\tif (rc == -ENOBUFS)\n\t\t\treturn;\n\t\tQETH_CARD_TEXT(queue->card, 2, \"flushbuf\");\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" q%d\", queue->queue_no);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" idx%d\", index);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" c%d\", count);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" err%d\", rc);\n\n\t\t/* this must not happen under normal circumstances. if it\n\t\t * happens something is really wrong -> recover */\n\t\tqeth_schedule_recovery(queue->card);\n\t\treturn;\n\t}\n\tif (queue->card->options.performance_stats)\n\t\tqueue->card->perf_stats.bufs_sent += count;\n}\n\nstatic void qeth_check_outbound_queue(struct qeth_qdio_out_q *queue)\n{\n\tint index;\n\tint flush_cnt = 0;\n\tint q_was_packing = 0;\n\n\t/*\n\t * check if weed have to switch to non-packing mode or if\n\t * we have to get a pci flag out on the queue\n\t */\n\tif ((atomic_read(&queue->used_buffers) <= QETH_LOW_WATERMARK_PACK) ||\n\t    !atomic_read(&queue->set_pci_flags_count)) {\n\t\tif (atomic_xchg(&queue->state, QETH_OUT_Q_LOCKED_FLUSH) ==\n\t\t\t\tQETH_OUT_Q_UNLOCKED) {\n\t\t\t/*\n\t\t\t * If we get in here, there was no action in\n\t\t\t * do_send_packet. So, we check if there is a\n\t\t\t * packing buffer to be flushed here.\n\t\t\t */\n\t\t\tnetif_stop_queue(queue->card->dev);\n\t\t\tindex = queue->next_buf_to_fill;\n\t\t\tq_was_packing = queue->do_pack;\n\t\t\t/* queue->do_pack may change */\n\t\t\tbarrier();\n\t\t\tflush_cnt += qeth_switch_to_nonpacking_if_needed(queue);\n\t\t\tif (!flush_cnt &&\n\t\t\t    !atomic_read(&queue->set_pci_flags_count))\n\t\t\t\tflush_cnt +=\n\t\t\t\t\tqeth_flush_buffers_on_no_pci(queue);\n\t\t\tif (queue->card->options.performance_stats &&\n\t\t\t    q_was_packing)\n\t\t\t\tqueue->card->perf_stats.bufs_sent_pack +=\n\t\t\t\t\tflush_cnt;\n\t\t\tif (flush_cnt)\n\t\t\t\tqeth_flush_buffers(queue, index, flush_cnt);\n\t\t\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\t\t}\n\t}\n}\n\nvoid qeth_qdio_start_poll(struct ccw_device *ccwdev, int queue,\n\t\tunsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tif (card->dev && (card->dev->flags & IFF_UP))\n\t\tnapi_schedule(&card->napi);\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_start_poll);\n\nint qeth_configure_cq(struct qeth_card *card, enum qeth_cq cq)\n{\n\tint rc;\n\n\tif (card->options.cq ==  QETH_CQ_NOTAVAILABLE) {\n\t\trc = -1;\n\t\tgoto out;\n\t} else {\n\t\tif (card->options.cq == cq) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (card->state != CARD_STATE_DOWN &&\n\t\t    card->state != CARD_STATE_RECOVER) {\n\t\t\trc = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tqeth_free_qdio_buffers(card);\n\t\tcard->options.cq = cq;\n\t\trc = 0;\n\t}\nout:\n\treturn rc;\n\n}\nEXPORT_SYMBOL_GPL(qeth_configure_cq);\n\n\nstatic void qeth_qdio_cq_handler(struct qeth_card *card,\n\t\tunsigned int qdio_err,\n\t\tunsigned int queue, int first_element, int count) {\n\tstruct qeth_qdio_q *cq = card->qdio.c_q;\n\tint i;\n\tint rc;\n\n\tif (!qeth_is_cq(card, queue))\n\t\tgoto out;\n\n\tQETH_CARD_TEXT_(card, 5, \"qcqhe%d\", first_element);\n\tQETH_CARD_TEXT_(card, 5, \"qcqhc%d\", count);\n\tQETH_CARD_TEXT_(card, 5, \"qcqherr%d\", qdio_err);\n\n\tif (qdio_err) {\n\t\tnetif_stop_queue(card->dev);\n\t\tqeth_schedule_recovery(card);\n\t\tgoto out;\n\t}\n\n\tif (card->options.performance_stats) {\n\t\tcard->perf_stats.cq_cnt++;\n\t\tcard->perf_stats.cq_start_time = qeth_get_micros();\n\t}\n\n\tfor (i = first_element; i < first_element + count; ++i) {\n\t\tint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tstruct qdio_buffer *buffer = &cq->qdio_bufs[bidx];\n\t\tint e;\n\n\t\te = 0;\n\t\twhile (buffer->element[e].addr) {\n\t\t\tunsigned long phys_aob_addr;\n\n\t\t\tphys_aob_addr = (unsigned long) buffer->element[e].addr;\n\t\t\tqeth_qdio_handle_aob(card, phys_aob_addr);\n\t\t\tbuffer->element[e].addr = NULL;\n\t\t\tbuffer->element[e].eflags = 0;\n\t\t\tbuffer->element[e].sflags = 0;\n\t\t\tbuffer->element[e].length = 0;\n\n\t\t\t++e;\n\t\t}\n\n\t\tbuffer->element[15].eflags = 0;\n\t\tbuffer->element[15].sflags = 0;\n\t}\n\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, queue,\n\t\t    card->qdio.c_q->next_buf_to_init,\n\t\t    count);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t\"QDIO reported an error, rc=%i\\n\", rc);\n\t\tQETH_CARD_TEXT(card, 2, \"qcqherr\");\n\t}\n\tcard->qdio.c_q->next_buf_to_init = (card->qdio.c_q->next_buf_to_init\n\t\t\t\t   + count) % QDIO_MAX_BUFFERS_PER_Q;\n\n\tnetif_wake_queue(card->dev);\n\n\tif (card->options.performance_stats) {\n\t\tint delta_t = qeth_get_micros();\n\t\tdelta_t -= card->perf_stats.cq_start_time;\n\t\tcard->perf_stats.cq_time += delta_t;\n\t}\nout:\n\treturn;\n}\n\nvoid qeth_qdio_input_handler(struct ccw_device *ccwdev, unsigned int qdio_err,\n\t\tunsigned int queue, int first_elem, int count,\n\t\tunsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tQETH_CARD_TEXT_(card, 2, \"qihq%d\", queue);\n\tQETH_CARD_TEXT_(card, 2, \"qiec%d\", qdio_err);\n\n\tif (qeth_is_cq(card, queue))\n\t\tqeth_qdio_cq_handler(card, qdio_err, queue, first_elem, count);\n\telse if (qdio_err)\n\t\tqeth_schedule_recovery(card);\n\n\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_input_handler);\n\nvoid qeth_qdio_output_handler(struct ccw_device *ccwdev,\n\t\tunsigned int qdio_error, int __queue, int first_element,\n\t\tint count, unsigned long card_ptr)\n{\n\tstruct qeth_card *card        = (struct qeth_card *) card_ptr;\n\tstruct qeth_qdio_out_q *queue = card->qdio.out_qs[__queue];\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint i;\n\n\tQETH_CARD_TEXT(card, 6, \"qdouhdl\");\n\tif (qdio_error & QDIO_ERROR_FATAL) {\n\t\tQETH_CARD_TEXT(card, 2, \"achkcond\");\n\t\tnetif_stop_queue(card->dev);\n\t\tqeth_schedule_recovery(card);\n\t\treturn;\n\t}\n\tif (card->options.performance_stats) {\n\t\tcard->perf_stats.outbound_handler_cnt++;\n\t\tcard->perf_stats.outbound_handler_start_time =\n\t\t\tqeth_get_micros();\n\t}\n\tfor (i = first_element; i < (first_element + count); ++i) {\n\t\tint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tbuffer = queue->bufs[bidx];\n\t\tqeth_handle_send_error(card, buffer, qdio_error);\n\n\t\tif (queue->bufstates &&\n\t\t    (queue->bufstates[bidx].flags &\n\t\t     QDIO_OUTBUF_STATE_FLAG_PENDING) != 0) {\n\t\t\tWARN_ON_ONCE(card->options.cq != QETH_CQ_ENABLED);\n\n\t\t\tif (atomic_cmpxchg(&buffer->state,\n\t\t\t\t\t   QETH_QDIO_BUF_PRIMED,\n\t\t\t\t\t   QETH_QDIO_BUF_PENDING) ==\n\t\t\t\tQETH_QDIO_BUF_PRIMED) {\n\t\t\t\tqeth_notify_skbs(queue, buffer,\n\t\t\t\t\t\t TX_NOTIFY_PENDING);\n\t\t\t}\n\t\t\tbuffer->aob = queue->bufstates[bidx].aob;\n\t\t\tQETH_CARD_TEXT_(queue->card, 5, \"pel%d\", bidx);\n\t\t\tQETH_CARD_TEXT(queue->card, 5, \"aob\");\n\t\t\tQETH_CARD_TEXT_(queue->card, 5, \"%lx\",\n\t\t\t\t\tvirt_to_phys(buffer->aob));\n\t\t\tif (qeth_init_qdio_out_buf(queue, bidx)) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"outofbuf\");\n\t\t\t\tqeth_schedule_recovery(card);\n\t\t\t}\n\t\t} else {\n\t\t\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\t\t\tenum iucv_tx_notify n;\n\n\t\t\t\tn = qeth_compute_cq_notification(\n\t\t\t\t\tbuffer->buffer->element[15].sflags, 0);\n\t\t\t\tqeth_notify_skbs(queue, buffer, n);\n\t\t\t}\n\n\t\t\tqeth_clear_output_buffer(queue, buffer,\n\t\t\t\t\t\tQETH_QDIO_BUF_EMPTY);\n\t\t}\n\t\tqeth_cleanup_handled_pending(queue, bidx, 0);\n\t}\n\tatomic_sub(count, &queue->used_buffers);\n\t/* check if we need to do something on this outbound queue */\n\tif (card->info.type != QETH_CARD_TYPE_IQD)\n\t\tqeth_check_outbound_queue(queue);\n\n\tnetif_wake_queue(queue->card->dev);\n\tif (card->options.performance_stats)\n\t\tcard->perf_stats.outbound_handler_time += qeth_get_micros() -\n\t\t\tcard->perf_stats.outbound_handler_start_time;\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_output_handler);\n\nint qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb,\n\t\t\tint ipv, int cast_type)\n{\n\tif (!ipv && (card->info.type == QETH_CARD_TYPE_OSD ||\n\t\t     card->info.type == QETH_CARD_TYPE_OSX))\n\t\treturn card->qdio.default_out_queue;\n\tswitch (card->qdio.no_out_queues) {\n\tcase 4:\n\t\tif (cast_type && card->info.is_multicast_different)\n\t\t\treturn card->info.is_multicast_different &\n\t\t\t\t(card->qdio.no_out_queues - 1);\n\t\tif (card->qdio.do_prio_queueing && (ipv == 4)) {\n\t\t\tconst u8 tos = ip_hdr(skb)->tos;\n\n\t\t\tif (card->qdio.do_prio_queueing ==\n\t\t\t\tQETH_PRIO_Q_ING_TOS) {\n\t\t\t\tif (tos & IP_TOS_NOTIMPORTANT)\n\t\t\t\t\treturn 3;\n\t\t\t\tif (tos & IP_TOS_HIGHRELIABILITY)\n\t\t\t\t\treturn 2;\n\t\t\t\tif (tos & IP_TOS_HIGHTHROUGHPUT)\n\t\t\t\t\treturn 1;\n\t\t\t\tif (tos & IP_TOS_LOWDELAY)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (card->qdio.do_prio_queueing ==\n\t\t\t\tQETH_PRIO_Q_ING_PREC)\n\t\t\t\treturn 3 - (tos >> 6);\n\t\t} else if (card->qdio.do_prio_queueing && (ipv == 6)) {\n\t\t\t/* TODO: IPv6!!! */\n\t\t}\n\t\treturn card->qdio.default_out_queue;\n\tcase 1: /* fallthrough for single-out-queue 1920-device */\n\tdefault:\n\t\treturn card->qdio.default_out_queue;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_get_priority_queue);\n\nint qeth_get_elements_for_frags(struct sk_buff *skb)\n{\n\tint cnt, length, e, elements = 0;\n\tstruct skb_frag_struct *frag;\n\tchar *data;\n\n\tfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\n\t\tfrag = &skb_shinfo(skb)->frags[cnt];\n\t\tdata = (char *)page_to_phys(skb_frag_page(frag)) +\n\t\t\tfrag->page_offset;\n\t\tlength = frag->size;\n\t\te = PFN_UP((unsigned long)data + length - 1) -\n\t\t\tPFN_DOWN((unsigned long)data);\n\t\telements += e;\n\t}\n\treturn elements;\n}\nEXPORT_SYMBOL_GPL(qeth_get_elements_for_frags);\n\nint qeth_get_elements_no(struct qeth_card *card,\n\t\t     struct sk_buff *skb, int elems)\n{\n\tint dlen = skb->len - skb->data_len;\n\tint elements_needed = PFN_UP((unsigned long)skb->data + dlen - 1) -\n\t\tPFN_DOWN((unsigned long)skb->data);\n\n\telements_needed += qeth_get_elements_for_frags(skb);\n\n\tif ((elements_needed + elems) > QETH_MAX_BUFFER_ELEMENTS(card)) {\n\t\tQETH_DBF_MESSAGE(2, \"Invalid size of IP packet \"\n\t\t\t\"(Number=%d / Length=%d). Discarded.\\n\",\n\t\t\t(elements_needed+elems), skb->len);\n\t\treturn 0;\n\t}\n\treturn elements_needed;\n}\nEXPORT_SYMBOL_GPL(qeth_get_elements_no);\n\nint qeth_hdr_chk_and_bounce(struct sk_buff *skb, struct qeth_hdr **hdr, int len)\n{\n\tint hroom, inpage, rest;\n\n\tif (((unsigned long)skb->data & PAGE_MASK) !=\n\t    (((unsigned long)skb->data + len - 1) & PAGE_MASK)) {\n\t\throom = skb_headroom(skb);\n\t\tinpage = PAGE_SIZE - ((unsigned long) skb->data % PAGE_SIZE);\n\t\trest = len - inpage;\n\t\tif (rest > hroom)\n\t\t\treturn 1;\n\t\tmemmove(skb->data - rest, skb->data, skb->len - skb->data_len);\n\t\tskb->data -= rest;\n\t\tskb->tail -= rest;\n\t\t*hdr = (struct qeth_hdr *)skb->data;\n\t\tQETH_DBF_MESSAGE(2, \"skb bounce len: %d rest: %d\\n\", len, rest);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_hdr_chk_and_bounce);\n\nstatic inline void __qeth_fill_buffer(struct sk_buff *skb,\n\tstruct qdio_buffer *buffer, int is_tso, int *next_element_to_fill,\n\tint offset)\n{\n\tint length = skb->len - skb->data_len;\n\tint length_here;\n\tint element;\n\tchar *data;\n\tint first_lap, cnt;\n\tstruct skb_frag_struct *frag;\n\n\telement = *next_element_to_fill;\n\tdata = skb->data;\n\tfirst_lap = (is_tso == 0 ? 1 : 0);\n\n\tif (offset >= 0) {\n\t\tdata = skb->data + offset;\n\t\tlength -= offset;\n\t\tfirst_lap = 0;\n\t}\n\n\twhile (length > 0) {\n\t\t/* length_here is the remaining amount of data in this page */\n\t\tlength_here = PAGE_SIZE - ((unsigned long) data % PAGE_SIZE);\n\t\tif (length < length_here)\n\t\t\tlength_here = length;\n\n\t\tbuffer->element[element].addr = data;\n\t\tbuffer->element[element].length = length_here;\n\t\tlength -= length_here;\n\t\tif (!length) {\n\t\t\tif (first_lap)\n\t\t\t\tif (skb_shinfo(skb)->nr_frags)\n\t\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t\t\tSBAL_EFLAGS_FIRST_FRAG;\n\t\t\t\telse\n\t\t\t\t\tbuffer->element[element].eflags = 0;\n\t\t\telse\n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t    SBAL_EFLAGS_MIDDLE_FRAG;\n\t\t} else {\n\t\t\tif (first_lap)\n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t    SBAL_EFLAGS_FIRST_FRAG;\n\t\t\telse\n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t    SBAL_EFLAGS_MIDDLE_FRAG;\n\t\t}\n\t\tdata += length_here;\n\t\telement++;\n\t\tfirst_lap = 0;\n\t}\n\n\tfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\n\t\tfrag = &skb_shinfo(skb)->frags[cnt];\n\t\tdata = (char *)page_to_phys(skb_frag_page(frag)) +\n\t\t\tfrag->page_offset;\n\t\tlength = frag->size;\n\t\twhile (length > 0) {\n\t\t\tlength_here = PAGE_SIZE -\n\t\t\t\t((unsigned long) data % PAGE_SIZE);\n\t\t\tif (length < length_here)\n\t\t\t\tlength_here = length;\n\n\t\t\tbuffer->element[element].addr = data;\n\t\t\tbuffer->element[element].length = length_here;\n\t\t\tbuffer->element[element].eflags =\n\t\t\t\tSBAL_EFLAGS_MIDDLE_FRAG;\n\t\t\tlength -= length_here;\n\t\t\tdata += length_here;\n\t\t\telement++;\n\t\t}\n\t}\n\n\tif (buffer->element[element - 1].eflags)\n\t\tbuffer->element[element - 1].eflags = SBAL_EFLAGS_LAST_FRAG;\n\t*next_element_to_fill = element;\n}\n\nstatic inline int qeth_fill_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf, struct sk_buff *skb,\n\t\tstruct qeth_hdr *hdr, int offset, int hd_len)\n{\n\tstruct qdio_buffer *buffer;\n\tint flush_cnt = 0, hdr_len, large_send = 0;\n\n\tbuffer = buf->buffer;\n\tatomic_inc(&skb->users);\n\tskb_queue_tail(&buf->skb_list, skb);\n\n\t/*check first on TSO ....*/\n\tif (hdr->hdr.l3.id == QETH_HEADER_TYPE_TSO) {\n\t\tint element = buf->next_element_to_fill;\n\n\t\thdr_len = sizeof(struct qeth_hdr_tso) +\n\t\t\t((struct qeth_hdr_tso *)hdr)->ext.dg_hdr_len;\n\t\t/*fill first buffer entry only with header information */\n\t\tbuffer->element[element].addr = skb->data;\n\t\tbuffer->element[element].length = hdr_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->next_element_to_fill++;\n\t\tskb->data += hdr_len;\n\t\tskb->len  -= hdr_len;\n\t\tlarge_send = 1;\n\t}\n\n\tif (offset >= 0) {\n\t\tint element = buf->next_element_to_fill;\n\t\tbuffer->element[element].addr = hdr;\n\t\tbuffer->element[element].length = sizeof(struct qeth_hdr) +\n\t\t\t\t\t\t\thd_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->is_header[element] = 1;\n\t\tbuf->next_element_to_fill++;\n\t}\n\n\t__qeth_fill_buffer(skb, buffer, large_send,\n\t\t(int *)&buf->next_element_to_fill, offset);\n\n\tif (!queue->do_pack) {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfnp\");\n\t\t/* set state to PRIMED -> will be flushed */\n\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\tflush_cnt = 1;\n\t} else {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfpa\");\n\t\tif (queue->card->options.performance_stats)\n\t\t\tqueue->card->perf_stats.skbs_sent_pack++;\n\t\tif (buf->next_element_to_fill >=\n\t\t\t\tQETH_MAX_BUFFER_ELEMENTS(queue->card)) {\n\t\t\t/*\n\t\t\t * packed buffer if full -> set state PRIMED\n\t\t\t * -> will be flushed\n\t\t\t */\n\t\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_cnt = 1;\n\t\t}\n\t}\n\treturn flush_cnt;\n}\n\nint qeth_do_send_packet_fast(struct qeth_card *card,\n\t\tstruct qeth_qdio_out_q *queue, struct sk_buff *skb,\n\t\tstruct qeth_hdr *hdr, int elements_needed,\n\t\tint offset, int hd_len)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint index;\n\n\t/* spin until we get the queue ... */\n\twhile (atomic_cmpxchg(&queue->state, QETH_OUT_Q_UNLOCKED,\n\t\t\t      QETH_OUT_Q_LOCKED) != QETH_OUT_Q_UNLOCKED);\n\t/* ... now we've got the queue */\n\tindex = queue->next_buf_to_fill;\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t/*\n\t * check if buffer is empty to make sure that we do not 'overtake'\n\t * ourselves and try to fill a buffer that is already primed\n\t */\n\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY)\n\t\tgoto out;\n\tqueue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %\n\t\t\t\t\t  QDIO_MAX_BUFFERS_PER_Q;\n\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\tqeth_fill_buffer(queue, buffer, skb, hdr, offset, hd_len);\n\tqeth_flush_buffers(queue, index, 1);\n\treturn 0;\nout:\n\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(qeth_do_send_packet_fast);\n\nint qeth_do_send_packet(struct qeth_card *card, struct qeth_qdio_out_q *queue,\n\t\tstruct sk_buff *skb, struct qeth_hdr *hdr,\n\t\tint elements_needed)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint start_index;\n\tint flush_count = 0;\n\tint do_pack = 0;\n\tint tmp;\n\tint rc = 0;\n\n\t/* spin until we get the queue ... */\n\twhile (atomic_cmpxchg(&queue->state, QETH_OUT_Q_UNLOCKED,\n\t\t\t      QETH_OUT_Q_LOCKED) != QETH_OUT_Q_UNLOCKED);\n\tstart_index = queue->next_buf_to_fill;\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t/*\n\t * check if buffer is empty to make sure that we do not 'overtake'\n\t * ourselves and try to fill a buffer that is already primed\n\t */\n\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY) {\n\t\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\t\treturn -EBUSY;\n\t}\n\t/* check if we need to switch packing state of this queue */\n\tqeth_switch_to_packing_if_needed(queue);\n\tif (queue->do_pack) {\n\t\tdo_pack = 1;\n\t\t/* does packet fit in current buffer? */\n\t\tif ((QETH_MAX_BUFFER_ELEMENTS(card) -\n\t\t    buffer->next_element_to_fill) < elements_needed) {\n\t\t\t/* ... no -> set state PRIMED */\n\t\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_count++;\n\t\t\tqueue->next_buf_to_fill =\n\t\t\t\t(queue->next_buf_to_fill + 1) %\n\t\t\t\tQDIO_MAX_BUFFERS_PER_Q;\n\t\t\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t\t\t/* we did a step forward, so check buffer state\n\t\t\t * again */\n\t\t\tif (atomic_read(&buffer->state) !=\n\t\t\t    QETH_QDIO_BUF_EMPTY) {\n\t\t\t\tqeth_flush_buffers(queue, start_index,\n\t\t\t\t\t\t\t   flush_count);\n\t\t\t\tatomic_set(&queue->state,\n\t\t\t\t\t\tQETH_OUT_Q_UNLOCKED);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\ttmp = qeth_fill_buffer(queue, buffer, skb, hdr, -1, 0);\n\tqueue->next_buf_to_fill = (queue->next_buf_to_fill + tmp) %\n\t\t\t\t  QDIO_MAX_BUFFERS_PER_Q;\n\tflush_count += tmp;\n\tif (flush_count)\n\t\tqeth_flush_buffers(queue, start_index, flush_count);\n\telse if (!atomic_read(&queue->set_pci_flags_count))\n\t\tatomic_xchg(&queue->state, QETH_OUT_Q_LOCKED_FLUSH);\n\t/*\n\t * queue->state will go from LOCKED -> UNLOCKED or from\n\t * LOCKED_FLUSH -> LOCKED if output_handler wanted to 'notify' us\n\t * (switch packing state or flush buffer to get another pci flag out).\n\t * In that case we will enter this loop\n\t */\n\twhile (atomic_dec_return(&queue->state)) {\n\t\tflush_count = 0;\n\t\tstart_index = queue->next_buf_to_fill;\n\t\t/* check if we can go back to non-packing state */\n\t\tflush_count += qeth_switch_to_nonpacking_if_needed(queue);\n\t\t/*\n\t\t * check if we need to flush a packing buffer to get a pci\n\t\t * flag out on the queue\n\t\t */\n\t\tif (!flush_count && !atomic_read(&queue->set_pci_flags_count))\n\t\t\tflush_count += qeth_flush_buffers_on_no_pci(queue);\n\t\tif (flush_count)\n\t\t\tqeth_flush_buffers(queue, start_index, flush_count);\n\t}\n\t/* at this point the queue is UNLOCKED again */\n\tif (queue->card->options.performance_stats && do_pack)\n\t\tqueue->card->perf_stats.bufs_sent_pack += flush_count;\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_do_send_packet);\n\nstatic int qeth_setadp_promisc_mode_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_ipacmd_setadpparms *setparms;\n\n\tQETH_CARD_TEXT(card, 4, \"prmadpcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tsetparms = &(cmd->data.setadapterparms);\n\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long)cmd);\n\tif (cmd->hdr.return_code) {\n\t\tQETH_CARD_TEXT_(card, 4, \"prmrc%2.2x\", cmd->hdr.return_code);\n\t\tsetparms->data.mode = SET_PROMISC_MODE_OFF;\n\t}\n\tcard->info.promisc_mode = setparms->data.mode;\n\treturn 0;\n}\n\nvoid qeth_setadp_promisc_mode(struct qeth_card *card)\n{\n\tenum qeth_ipa_promisc_modes mode;\n\tstruct net_device *dev = card->dev;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"setprom\");\n\n\tif (((dev->flags & IFF_PROMISC) &&\n\t     (card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||\n\t    (!(dev->flags & IFF_PROMISC) &&\n\t     (card->info.promisc_mode == SET_PROMISC_MODE_OFF)))\n\t\treturn;\n\tmode = SET_PROMISC_MODE_OFF;\n\tif (dev->flags & IFF_PROMISC)\n\t\tmode = SET_PROMISC_MODE_ON;\n\tQETH_CARD_TEXT_(card, 4, \"mode:%x\", mode);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_PROMISC_MODE,\n\t\t\tsizeof(struct qeth_ipacmd_setadpparms));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data + IPA_PDU_HEADER_SIZE);\n\tcmd->data.setadapterparms.data.mode = mode;\n\tqeth_send_ipa_cmd(card, iob, qeth_setadp_promisc_mode_cb, NULL);\n}\nEXPORT_SYMBOL_GPL(qeth_setadp_promisc_mode);\n\nint qeth_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct qeth_card *card;\n\tchar dbf_text[15];\n\n\tcard = dev->ml_priv;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmtu\");\n\tsprintf(dbf_text, \"%8x\", new_mtu);\n\tQETH_CARD_TEXT(card, 4, dbf_text);\n\n\tif (new_mtu < 64)\n\t\treturn -EINVAL;\n\tif (new_mtu > 65535)\n\t\treturn -EINVAL;\n\tif ((!qeth_is_supported(card, IPA_IP_FRAGMENTATION)) &&\n\t    (!qeth_mtu_is_valid(card, new_mtu)))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_change_mtu);\n\nstruct net_device_stats *qeth_get_stats(struct net_device *dev)\n{\n\tstruct qeth_card *card;\n\n\tcard = dev->ml_priv;\n\n\tQETH_CARD_TEXT(card, 5, \"getstat\");\n\n\treturn &card->stats;\n}\nEXPORT_SYMBOL_GPL(qeth_get_stats);\n\nstatic int qeth_setadpparms_change_macaddr_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmaccb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (!card->options.layer2 ||\n\t    !(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {\n\t\tmemcpy(card->dev->dev_addr,\n\t\t       &cmd->data.setadapterparms.data.change_addr.addr,\n\t\t       OSA_ADDR_LEN);\n\t\tcard->info.mac_bits |= QETH_LAYER2_MAC_READ;\n\t}\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\n\treturn 0;\n}\n\nint qeth_setadpparms_change_macaddr(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmac\");\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_ALTER_MAC_ADDRESS,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.setadapterparms.data.change_addr.cmd = CHANGE_ADDR_READ_MAC;\n\tcmd->data.setadapterparms.data.change_addr.addr_size = OSA_ADDR_LEN;\n\tmemcpy(&cmd->data.setadapterparms.data.change_addr.addr,\n\t       card->dev->dev_addr, OSA_ADDR_LEN);\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_change_macaddr_cb,\n\t\t\t       NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_setadpparms_change_macaddr);\n\nstatic int qeth_setadpparms_set_access_ctrl_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_set_access_ctrl *access_ctrl_req;\n\tint fallback = *(int *)reply->param;\n\n\tQETH_CARD_TEXT(card, 4, \"setaccb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\taccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\n\tQETH_DBF_TEXT_(SETUP, 2, \"setaccb\");\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", card->gdev->dev.kobj.name);\n\tQETH_DBF_TEXT_(SETUP, 2, \"rc=%d\",\n\t\tcmd->data.setadapterparms.hdr.return_code);\n\tif (cmd->data.setadapterparms.hdr.return_code !=\n\t\t\t\t\t\tSET_ACCESS_CTRL_RC_SUCCESS)\n\t\tQETH_DBF_MESSAGE(3, \"ERR:SET_ACCESS_CTRL(%s,%d)==%d\\n\",\n\t\t\t\tcard->gdev->dev.kobj.name,\n\t\t\t\taccess_ctrl_req->subcmd_code,\n\t\t\t\tcmd->data.setadapterparms.hdr.return_code);\n\tswitch (cmd->data.setadapterparms.hdr.return_code) {\n\tcase SET_ACCESS_CTRL_RC_SUCCESS:\n\t\tif (card->options.isolation == ISOLATION_MODE_NONE) {\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t    \"QDIO data connection isolation is deactivated\\n\");\n\t\t} else {\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t    \"QDIO data connection isolation is activated\\n\");\n\t\t}\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_ALREADY_NOT_ISOLATED:\n\t\tQETH_DBF_MESSAGE(2, \"%s QDIO data connection isolation already \"\n\t\t\t\t\"deactivated\\n\", dev_name(&card->gdev->dev));\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_ALREADY_ISOLATED:\n\t\tQETH_DBF_MESSAGE(2, \"%s QDIO data connection isolation already\"\n\t\t\t\t\" activated\\n\", dev_name(&card->gdev->dev));\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_NOT_SUPPORTED:\n\t\tdev_err(&card->gdev->dev, \"Adapter does not \"\n\t\t\t\"support QDIO data connection isolation\\n\");\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_NONE_SHARED_ADAPTER:\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"Adapter is dedicated. \"\n\t\t\t\"QDIO data connection isolation not supported\\n\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_ACTIVE_CHECKSUM_OFF:\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"TSO does not permit QDIO data connection isolation\\n\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_UNSUPPORTED:\n\t\tdev_err(&card->gdev->dev, \"The adjacent switch port does not \"\n\t\t\t\"support reflective relay mode\\n\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_FAILED:\n\t\tdev_err(&card->gdev->dev, \"The reflective relay mode cannot be \"\n\t\t\t\t\t\"enabled at the adjacent switch port\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_DEACT_FAILED:\n\t\tdev_warn(&card->gdev->dev, \"Turning off reflective relay mode \"\n\t\t\t\t\t\"at the adjacent switch failed\\n\");\n\t\tbreak;\n\tdefault:\n\t\t/* this should never happen */\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\t}\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\n\treturn 0;\n}\n\nstatic int qeth_setadpparms_set_access_ctrl(struct qeth_card *card,\n\t\tenum qeth_ipa_isolation_modes isolation, int fallback)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_set_access_ctrl *access_ctrl_req;\n\n\tQETH_CARD_TEXT(card, 4, \"setacctl\");\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"setacctl\");\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", card->gdev->dev.kobj.name);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_ACCESS_CONTROL,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms_hdr) +\n\t\t\t\t   sizeof(struct qeth_set_access_ctrl));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\taccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\n\taccess_ctrl_req->subcmd_code = isolation;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_set_access_ctrl_cb,\n\t\t\t       &fallback);\n\tQETH_DBF_TEXT_(SETUP, 2, \"rc=%d\", rc);\n\treturn rc;\n}\n\nint qeth_set_access_ctrl_online(struct qeth_card *card, int fallback)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 4, \"setactlo\");\n\n\tif ((card->info.type == QETH_CARD_TYPE_OSD ||\n\t     card->info.type == QETH_CARD_TYPE_OSX) &&\n\t     qeth_adp_supported(card, IPA_SETADP_SET_ACCESS_CONTROL)) {\n\t\trc = qeth_setadpparms_set_access_ctrl(card,\n\t\t\tcard->options.isolation, fallback);\n\t\tif (rc) {\n\t\t\tQETH_DBF_MESSAGE(3,\n\t\t\t\t\"IPA(SET_ACCESS_CTRL,%s,%d) sent failed\\n\",\n\t\t\t\tcard->gdev->dev.kobj.name,\n\t\t\t\trc);\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else if (card->options.isolation != ISOLATION_MODE_NONE) {\n\t\tcard->options.isolation = ISOLATION_MODE_NONE;\n\n\t\tdev_err(&card->gdev->dev, \"Adapter does not \"\n\t\t\t\"support QDIO data connection isolation\\n\");\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_set_access_ctrl_online);\n\nvoid qeth_tx_timeout(struct net_device *dev)\n{\n\tstruct qeth_card *card;\n\n\tcard = dev->ml_priv;\n\tQETH_CARD_TEXT(card, 4, \"txtimeo\");\n\tcard->stats.tx_errors++;\n\tqeth_schedule_recovery(card);\n}\nEXPORT_SYMBOL_GPL(qeth_tx_timeout);\n\nint qeth_mdio_read(struct net_device *dev, int phy_id, int regnum)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc = 0;\n\n\tswitch (regnum) {\n\tcase MII_BMCR: /* Basic mode control register */\n\t\trc = BMCR_FULLDPLX;\n\t\tif ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_OSN) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))\n\t\t\trc |= BMCR_SPEED100;\n\t\tbreak;\n\tcase MII_BMSR: /* Basic mode status register */\n\t\trc = BMSR_ERCAP | BMSR_ANEGCOMPLETE | BMSR_LSTATUS |\n\t\t     BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | BMSR_100FULL |\n\t\t     BMSR_100BASE4;\n\t\tbreak;\n\tcase MII_PHYSID1: /* PHYS ID 1 */\n\t\trc = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 8) |\n\t\t     dev->dev_addr[2];\n\t\trc = (rc >> 5) & 0xFFFF;\n\t\tbreak;\n\tcase MII_PHYSID2: /* PHYS ID 2 */\n\t\trc = (dev->dev_addr[2] << 10) & 0xFFFF;\n\t\tbreak;\n\tcase MII_ADVERTISE: /* Advertisement control reg */\n\t\trc = ADVERTISE_ALL;\n\t\tbreak;\n\tcase MII_LPA: /* Link partner ability reg */\n\t\trc = LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL |\n\t\t     LPA_100BASE4 | LPA_LPACK;\n\t\tbreak;\n\tcase MII_EXPANSION: /* Expansion register */\n\t\tbreak;\n\tcase MII_DCOUNTER: /* disconnect counter */\n\t\tbreak;\n\tcase MII_FCSCOUNTER: /* false carrier counter */\n\t\tbreak;\n\tcase MII_NWAYTEST: /* N-way auto-neg test register */\n\t\tbreak;\n\tcase MII_RERRCOUNTER: /* rx error counter */\n\t\trc = card->stats.rx_errors;\n\t\tbreak;\n\tcase MII_SREVISION: /* silicon revision */\n\t\tbreak;\n\tcase MII_RESV1: /* reserved 1 */\n\t\tbreak;\n\tcase MII_LBRERROR: /* loopback, rx, bypass error */\n\t\tbreak;\n\tcase MII_PHYADDR: /* physical address */\n\t\tbreak;\n\tcase MII_RESV2: /* reserved 2 */\n\t\tbreak;\n\tcase MII_TPISTATUS: /* TPI status for 10mbps */\n\t\tbreak;\n\tcase MII_NCONFIG: /* network interface config */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_mdio_read);\n\nstatic int qeth_send_ipa_snmp_cmd(struct qeth_card *card,\n\t\tstruct qeth_cmd_buffer *iob, int len,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tu16 s1, s2;\n\n\tQETH_CARD_TEXT(card, 4, \"sendsnmp\");\n\n\tmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\n\tmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n\t/* adjust PDU length fields in IPA_PDU_HEADER */\n\ts1 = (u32) IPA_PDU_HEADER_SIZE + len;\n\ts2 = (u32) len;\n\tmemcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);\n\treturn qeth_send_control_data(card, IPA_PDU_HEADER_SIZE + len, iob,\n\t\t\t\t      reply_cb, reply_param);\n}\n\nstatic int qeth_snmp_command_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long sdata)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_arp_query_info *qinfo;\n\tstruct qeth_snmp_cmd *snmp;\n\tunsigned char *data;\n\t__u16 data_len;\n\n\tQETH_CARD_TEXT(card, 3, \"snpcmdcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) sdata;\n\tdata = (unsigned char *)((char *)cmd - reply->offset);\n\tqinfo = (struct qeth_arp_query_info *) reply->param;\n\tsnmp = &cmd->data.setadapterparms.data.snmp;\n\n\tif (cmd->hdr.return_code) {\n\t\tQETH_CARD_TEXT_(card, 4, \"scer1%i\", cmd->hdr.return_code);\n\t\treturn 0;\n\t}\n\tif (cmd->data.setadapterparms.hdr.return_code) {\n\t\tcmd->hdr.return_code =\n\t\t\tcmd->data.setadapterparms.hdr.return_code;\n\t\tQETH_CARD_TEXT_(card, 4, \"scer2%i\", cmd->hdr.return_code);\n\t\treturn 0;\n\t}\n\tdata_len = *((__u16 *)QETH_IPA_PDU_LEN_PDU1(data));\n\tif (cmd->data.setadapterparms.hdr.seq_no == 1)\n\t\tdata_len -= (__u16)((char *)&snmp->data - (char *)cmd);\n\telse\n\t\tdata_len -= (__u16)((char *)&snmp->request - (char *)cmd);\n\n\t/* check if there is enough room in userspace */\n\tif ((qinfo->udata_len - qinfo->udata_offset) < data_len) {\n\t\tQETH_CARD_TEXT_(card, 4, \"scer3%i\", -ENOMEM);\n\t\tcmd->hdr.return_code = IPA_RC_ENOMEM;\n\t\treturn 0;\n\t}\n\tQETH_CARD_TEXT_(card, 4, \"snore%i\",\n\t\t       cmd->data.setadapterparms.hdr.used_total);\n\tQETH_CARD_TEXT_(card, 4, \"sseqn%i\",\n\t\tcmd->data.setadapterparms.hdr.seq_no);\n\t/*copy entries to user buffer*/\n\tif (cmd->data.setadapterparms.hdr.seq_no == 1) {\n\t\tmemcpy(qinfo->udata + qinfo->udata_offset,\n\t\t       (char *)snmp,\n\t\t       data_len + offsetof(struct qeth_snmp_cmd, data));\n\t\tqinfo->udata_offset += offsetof(struct qeth_snmp_cmd, data);\n\t} else {\n\t\tmemcpy(qinfo->udata + qinfo->udata_offset,\n\t\t       (char *)&snmp->request, data_len);\n\t}\n\tqinfo->udata_offset += data_len;\n\t/* check if all replies received ... */\n\t\tQETH_CARD_TEXT_(card, 4, \"srtot%i\",\n\t\t\t       cmd->data.setadapterparms.hdr.used_total);\n\t\tQETH_CARD_TEXT_(card, 4, \"srseq%i\",\n\t\t\t       cmd->data.setadapterparms.hdr.seq_no);\n\tif (cmd->data.setadapterparms.hdr.seq_no <\n\t    cmd->data.setadapterparms.hdr.used_total)\n\t\treturn 1;\n\treturn 0;\n}\n\nint qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* skip 4 bytes (data_len struct member) to get req_len */\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_snmp_command);\n\nstatic int qeth_setadpparms_query_oat_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_qoat_priv *priv;\n\tchar *resdata;\n\tint resdatalen;\n\n\tQETH_CARD_TEXT(card, 3, \"qoatcb\");\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\tpriv = (struct qeth_qoat_priv *)reply->param;\n\tresdatalen = cmd->data.setadapterparms.hdr.cmdlength;\n\tresdata = (char *)data + 28;\n\n\tif (resdatalen > (priv->buffer_len - priv->response_len)) {\n\t\tcmd->hdr.return_code = IPA_RC_FFFF;\n\t\treturn 0;\n\t}\n\n\tmemcpy((priv->buffer + priv->response_len), resdata,\n\t\tresdatalen);\n\tpriv->response_len += resdatalen;\n\n\tif (cmd->data.setadapterparms.hdr.seq_no <\n\t    cmd->data.setadapterparms.hdr.used_total)\n\t\treturn 1;\n\treturn 0;\n}\n\nint qeth_query_oat_command(struct qeth_card *card, char __user *udata)\n{\n\tint rc = 0;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_query_oat *oat_req;\n\tstruct qeth_query_oat_data oat_data;\n\tstruct qeth_qoat_priv priv;\n\tvoid __user *tmp;\n\n\tQETH_CARD_TEXT(card, 3, \"qoatcmd\");\n\n\tif (!qeth_adp_supported(card, IPA_SETADP_QUERY_OAT)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&oat_data, udata,\n\t    sizeof(struct qeth_query_oat_data))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t}\n\n\tpriv.buffer_len = oat_data.buffer_len;\n\tpriv.response_len = 0;\n\tpriv.buffer =  kzalloc(oat_data.buffer_len, GFP_KERNEL);\n\tif (!priv.buffer) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_OAT,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms_hdr) +\n\t\t\t\t   sizeof(struct qeth_query_oat));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\toat_req = &cmd->data.setadapterparms.data.query_oat;\n\toat_req->subcmd_code = oat_data.command;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_query_oat_cb,\n\t\t\t       &priv);\n\tif (!rc) {\n\t\tif (is_compat_task())\n\t\t\ttmp = compat_ptr(oat_data.ptr);\n\t\telse\n\t\t\ttmp = (void __user *)(unsigned long)oat_data.ptr;\n\n\t\tif (copy_to_user(tmp, priv.buffer,\n\t\t    priv.response_len)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\toat_data.response_len = priv.response_len;\n\n\t\tif (copy_to_user(udata, &oat_data,\n\t\t    sizeof(struct qeth_query_oat_data)))\n\t\t\trc = -EFAULT;\n\t} else\n\t\tif (rc == IPA_RC_FFFF)\n\t\t\trc = -EFAULT;\n\nout_free:\n\tkfree(priv.buffer);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_query_oat_command);\n\nstatic inline int qeth_get_qdio_q_format(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void qeth_determine_capabilities(struct qeth_card *card)\n{\n\tint rc;\n\tint length;\n\tchar *prcd;\n\tstruct ccw_device *ddev;\n\tint ddev_offline = 0;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"detcapab\");\n\tddev = CARD_DDEV(card);\n\tif (!ddev->online) {\n\t\tddev_offline = 1;\n\t\trc = ccw_device_set_online(ddev);\n\t\tif (rc) {\n\t\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = qeth_read_conf_data(card, (void **) &prcd, &length);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"%s qeth_read_conf_data returned %i\\n\",\n\t\t\tdev_name(&card->gdev->dev), rc);\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out_offline;\n\t}\n\tqeth_configure_unitaddr(card, prcd);\n\tif (ddev_offline)\n\t\tqeth_configure_blkt_default(card, prcd);\n\tkfree(prcd);\n\n\trc = qdio_get_ssqd_desc(ddev, &card->ssqd);\n\tif (rc)\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"6err%d\", rc);\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"qfmt%d\", card->ssqd.qfmt);\n\tQETH_DBF_TEXT_(SETUP, 2, \"%d\", card->ssqd.qdioac1);\n\tQETH_DBF_TEXT_(SETUP, 2, \"%d\", card->ssqd.qdioac3);\n\tQETH_DBF_TEXT_(SETUP, 2, \"icnt%d\", card->ssqd.icnt);\n\tif (!((card->ssqd.qfmt != QDIO_IQDIO_QFMT) ||\n\t    ((card->ssqd.qdioac1 & CHSC_AC1_INITIATE_INPUTQ) == 0) ||\n\t    ((card->ssqd.qdioac3 & CHSC_AC3_FORMAT2_CQ_AVAILABLE) == 0))) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t\"Completion Queueing supported\\n\");\n\t} else {\n\t\tcard->options.cq = QETH_CQ_NOTAVAILABLE;\n\t}\n\n\nout_offline:\n\tif (ddev_offline == 1)\n\t\tccw_device_set_offline(ddev);\nout:\n\treturn;\n}\n\nstatic inline void qeth_qdio_establish_cq(struct qeth_card *card,\n\tstruct qdio_buffer **in_sbal_ptrs,\n\tvoid (**queue_start_poll) (struct ccw_device *, int, unsigned long)) {\n\tint i;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tint offset = QDIO_MAX_BUFFERS_PER_Q *\n\t\t\t     (card->qdio.no_in_queues - 1);\n\t\ti = QDIO_MAX_BUFFERS_PER_Q * (card->qdio.no_in_queues - 1);\n\t\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\t\tin_sbal_ptrs[offset + i] = (struct qdio_buffer *)\n\t\t\t\tvirt_to_phys(card->qdio.c_q->bufs[i].buffer);\n\t\t}\n\n\t\tqueue_start_poll[card->qdio.no_in_queues - 1] = NULL;\n\t}\n}\n\nstatic int qeth_qdio_establish(struct qeth_card *card)\n{\n\tstruct qdio_initialize init_data;\n\tchar *qib_param_field;\n\tstruct qdio_buffer **in_sbal_ptrs;\n\tvoid (**queue_start_poll) (struct ccw_device *, int, unsigned long);\n\tstruct qdio_buffer **out_sbal_ptrs;\n\tint i, j, k;\n\tint rc = 0;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"qdioest\");\n\n\tqib_param_field = kzalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(char),\n\t\t\t      GFP_KERNEL);\n\tif (!qib_param_field) {\n\t\trc =  -ENOMEM;\n\t\tgoto out_free_nothing;\n\t}\n\n\tqeth_create_qib_param_field(card, qib_param_field);\n\tqeth_create_qib_param_field_blkt(card, qib_param_field);\n\n\tin_sbal_ptrs = kzalloc(card->qdio.no_in_queues *\n\t\t\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(void *),\n\t\t\t       GFP_KERNEL);\n\tif (!in_sbal_ptrs) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_qib_param;\n\t}\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\tin_sbal_ptrs[i] = (struct qdio_buffer *)\n\t\t\tvirt_to_phys(card->qdio.in_q->bufs[i].buffer);\n\t}\n\n\tqueue_start_poll = kzalloc(sizeof(void *) * card->qdio.no_in_queues,\n\t\t\t\t   GFP_KERNEL);\n\tif (!queue_start_poll) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_in_sbals;\n\t}\n\tfor (i = 0; i < card->qdio.no_in_queues; ++i)\n\t\tqueue_start_poll[i] = card->discipline->start_poll;\n\n\tqeth_qdio_establish_cq(card, in_sbal_ptrs, queue_start_poll);\n\n\tout_sbal_ptrs =\n\t\tkzalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q *\n\t\t\tsizeof(void *), GFP_KERNEL);\n\tif (!out_sbal_ptrs) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_queue_start_poll;\n\t}\n\tfor (i = 0, k = 0; i < card->qdio.no_out_queues; ++i)\n\t\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j, ++k) {\n\t\t\tout_sbal_ptrs[k] = (struct qdio_buffer *)virt_to_phys(\n\t\t\t\tcard->qdio.out_qs[i]->bufs[j]->buffer);\n\t\t}\n\n\tmemset(&init_data, 0, sizeof(struct qdio_initialize));\n\tinit_data.cdev                   = CARD_DDEV(card);\n\tinit_data.q_format               = qeth_get_qdio_q_format(card);\n\tinit_data.qib_param_field_format = 0;\n\tinit_data.qib_param_field        = qib_param_field;\n\tinit_data.no_input_qs            = card->qdio.no_in_queues;\n\tinit_data.no_output_qs           = card->qdio.no_out_queues;\n\tinit_data.input_handler \t = card->discipline->input_handler;\n\tinit_data.output_handler\t = card->discipline->output_handler;\n\tinit_data.queue_start_poll_array = queue_start_poll;\n\tinit_data.int_parm               = (unsigned long) card;\n\tinit_data.input_sbal_addr_array  = (void **) in_sbal_ptrs;\n\tinit_data.output_sbal_addr_array = (void **) out_sbal_ptrs;\n\tinit_data.output_sbal_state_array = card->qdio.out_bufstates;\n\tinit_data.scan_threshold =\n\t\t(card->info.type == QETH_CARD_TYPE_IQD) ? 1 : 32;\n\n\tif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ALLOCATED,\n\t\tQETH_QDIO_ESTABLISHED) == QETH_QDIO_ALLOCATED) {\n\t\trc = qdio_allocate(&init_data);\n\t\tif (rc) {\n\t\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\t\tgoto out;\n\t\t}\n\t\trc = qdio_establish(&init_data);\n\t\tif (rc) {\n\t\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\t\tqdio_free(CARD_DDEV(card));\n\t\t}\n\t}\n\n\tswitch (card->options.cq) {\n\tcase QETH_CQ_ENABLED:\n\t\tdev_info(&card->gdev->dev, \"Completion Queue support enabled\");\n\t\tbreak;\n\tcase QETH_CQ_DISABLED:\n\t\tdev_info(&card->gdev->dev, \"Completion Queue support disabled\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\tkfree(out_sbal_ptrs);\nout_free_queue_start_poll:\n\tkfree(queue_start_poll);\nout_free_in_sbals:\n\tkfree(in_sbal_ptrs);\nout_free_qib_param:\n\tkfree(qib_param_field);\nout_free_nothing:\n\treturn rc;\n}\n\nstatic void qeth_core_free_card(struct qeth_card *card)\n{\n\n\tQETH_DBF_TEXT(SETUP, 2, \"freecrd\");\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\tqeth_clean_channel(&card->read);\n\tqeth_clean_channel(&card->write);\n\tif (card->dev)\n\t\tfree_netdev(card->dev);\n\tkfree(card->ip_tbd_list);\n\tqeth_free_qdio_buffers(card);\n\tunregister_service_level(&card->qeth_service_level);\n\tkfree(card);\n}\n\nvoid qeth_trace_features(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"features\");\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa4.supported_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa4.enabled_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa6.supported_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa6.enabled_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.adp.supported_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.adp.enabled_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->info.diagass_support);\n}\nEXPORT_SYMBOL_GPL(qeth_trace_features);\n\nstatic struct ccw_device_id qeth_ids[] = {\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x01, 0x1732, 0x01),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSD},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x05, 0x1732, 0x05),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_IQD},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x06, 0x1732, 0x06),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSN},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x02, 0x1732, 0x03),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSM},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x02, 0x1732, 0x02),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSX},\n\t{},\n};\nMODULE_DEVICE_TABLE(ccw, qeth_ids);\n\nstatic struct ccw_driver qeth_ccw_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"qeth\",\n\t},\n\t.ids = qeth_ids,\n\t.probe = ccwgroup_probe_ccwdev,\n\t.remove = ccwgroup_remove_ccwdev,\n};\n\nint qeth_core_hardsetup_card(struct qeth_card *card)\n{\n\tint retries = 3;\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"hrdsetup\");\n\tatomic_set(&card->force_alloc_skb, 0);\n\tqeth_update_from_chp_desc(card);\nretry:\n\tif (retries < 3)\n\t\tQETH_DBF_MESSAGE(2, \"%s Retrying to do IDX activates.\\n\",\n\t\t\tdev_name(&card->gdev->dev));\n\tccw_device_set_offline(CARD_DDEV(card));\n\tccw_device_set_offline(CARD_WDEV(card));\n\tccw_device_set_offline(CARD_RDEV(card));\n\trc = ccw_device_set_online(CARD_RDEV(card));\n\tif (rc)\n\t\tgoto retriable;\n\trc = ccw_device_set_online(CARD_WDEV(card));\n\tif (rc)\n\t\tgoto retriable;\n\trc = ccw_device_set_online(CARD_DDEV(card));\n\tif (rc)\n\t\tgoto retriable;\n\trc = qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);\nretriable:\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"break1\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\tqeth_determine_capabilities(card);\n\tqeth_init_tokens(card);\n\tqeth_init_func_level(card);\n\trc = qeth_idx_activate_channel(&card->read, qeth_idx_read_cb);\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"break2\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\trc = qeth_idx_activate_channel(&card->write, qeth_idx_write_cb);\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"break3\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"4err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\tcard->read_or_write_problem = 0;\n\trc = qeth_mpc_initialize(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out;\n\t}\n\n\tcard->options.ipa4.supported_funcs = 0;\n\tcard->options.adp.supported_funcs = 0;\n\tcard->info.diagass_support = 0;\n\tqeth_query_ipassists(card, QETH_PROT_IPV4);\n\tif (qeth_is_supported(card, IPA_SETADAPTERPARMS))\n\t\tqeth_query_setadapterparms(card);\n\tif (qeth_adp_supported(card, IPA_SETADP_SET_DIAG_ASSIST))\n\t\tqeth_query_setdiagass(card);\n\treturn 0;\nout:\n\tdev_warn(&card->gdev->dev, \"The qeth device driver failed to recover \"\n\t\t\"an error on the device\\n\");\n\tQETH_DBF_MESSAGE(2, \"%s Initialization in hardsetup failed! rc=%d\\n\",\n\t\tdev_name(&card->gdev->dev), rc);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_core_hardsetup_card);\n\nstatic inline int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,\n\t\tstruct qdio_buffer_element *element,\n\t\tstruct sk_buff **pskb, int offset, int *pfrag, int data_len)\n{\n\tstruct page *page = virt_to_page(element->addr);\n\tif (*pskb == NULL) {\n\t\tif (qethbuffer->rx_skb) {\n\t\t\t/* only if qeth_card.options.cq == QETH_CQ_ENABLED */\n\t\t\t*pskb = qethbuffer->rx_skb;\n\t\t\tqethbuffer->rx_skb = NULL;\n\t\t} else {\n\t\t\t*pskb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\n\t\t\tif (!(*pskb))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_reserve(*pskb, ETH_HLEN);\n\t\tif (data_len <= QETH_RX_PULL_LEN) {\n\t\t\tmemcpy(skb_put(*pskb, data_len), element->addr + offset,\n\t\t\t\tdata_len);\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tmemcpy(skb_put(*pskb, QETH_RX_PULL_LEN),\n\t\t\t       element->addr + offset, QETH_RX_PULL_LEN);\n\t\t\tskb_fill_page_desc(*pskb, *pfrag, page,\n\t\t\t\toffset + QETH_RX_PULL_LEN,\n\t\t\t\tdata_len - QETH_RX_PULL_LEN);\n\t\t\t(*pskb)->data_len += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pskb)->len      += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pskb)->truesize += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pfrag)++;\n\t\t}\n\t} else {\n\t\tget_page(page);\n\t\tskb_fill_page_desc(*pskb, *pfrag, page, offset, data_len);\n\t\t(*pskb)->data_len += data_len;\n\t\t(*pskb)->len      += data_len;\n\t\t(*pskb)->truesize += data_len;\n\t\t(*pfrag)++;\n\t}\n\n\n\treturn 0;\n}\n\nstruct sk_buff *qeth_core_get_next_skb(struct qeth_card *card,\n\t\tstruct qeth_qdio_buffer *qethbuffer,\n\t\tstruct qdio_buffer_element **__element, int *__offset,\n\t\tstruct qeth_hdr **hdr)\n{\n\tstruct qdio_buffer_element *element = *__element;\n\tstruct qdio_buffer *buffer = qethbuffer->buffer;\n\tint offset = *__offset;\n\tstruct sk_buff *skb = NULL;\n\tint skb_len = 0;\n\tvoid *data_ptr;\n\tint data_len;\n\tint headroom = 0;\n\tint use_rx_sg = 0;\n\tint frag = 0;\n\n\t/* qeth_hdr must not cross element boundaries */\n\tif (element->length < offset + sizeof(struct qeth_hdr)) {\n\t\tif (qeth_is_last_sbale(element))\n\t\t\treturn NULL;\n\t\telement++;\n\t\toffset = 0;\n\t\tif (element->length < sizeof(struct qeth_hdr))\n\t\t\treturn NULL;\n\t}\n\t*hdr = element->addr + offset;\n\n\toffset += sizeof(struct qeth_hdr);\n\tswitch ((*hdr)->hdr.l2.id) {\n\tcase QETH_HEADER_TYPE_LAYER2:\n\t\tskb_len = (*hdr)->hdr.l2.pkt_length;\n\t\tbreak;\n\tcase QETH_HEADER_TYPE_LAYER3:\n\t\tskb_len = (*hdr)->hdr.l3.length;\n\t\theadroom = ETH_HLEN;\n\t\tbreak;\n\tcase QETH_HEADER_TYPE_OSN:\n\t\tskb_len = (*hdr)->hdr.osn.pdu_length;\n\t\theadroom = sizeof(struct qeth_hdr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!skb_len)\n\t\treturn NULL;\n\n\tif (((skb_len >= card->options.rx_sg_cb) &&\n\t     (!(card->info.type == QETH_CARD_TYPE_OSN)) &&\n\t     (!atomic_read(&card->force_alloc_skb))) ||\n\t    (card->options.cq == QETH_CQ_ENABLED)) {\n\t\tuse_rx_sg = 1;\n\t} else {\n\t\tskb = dev_alloc_skb(skb_len + headroom);\n\t\tif (!skb)\n\t\t\tgoto no_mem;\n\t\tif (headroom)\n\t\t\tskb_reserve(skb, headroom);\n\t}\n\n\tdata_ptr = element->addr + offset;\n\twhile (skb_len) {\n\t\tdata_len = min(skb_len, (int)(element->length - offset));\n\t\tif (data_len) {\n\t\t\tif (use_rx_sg) {\n\t\t\t\tif (qeth_create_skb_frag(qethbuffer, element,\n\t\t\t\t    &skb, offset, &frag, data_len))\n\t\t\t\t\tgoto no_mem;\n\t\t\t} else {\n\t\t\t\tmemcpy(skb_put(skb, data_len), data_ptr,\n\t\t\t\t\tdata_len);\n\t\t\t}\n\t\t}\n\t\tskb_len -= data_len;\n\t\tif (skb_len) {\n\t\t\tif (qeth_is_last_sbale(element)) {\n\t\t\t\tQETH_CARD_TEXT(card, 4, \"unexeob\");\n\t\t\t\tQETH_CARD_HEX(card, 2, buffer, sizeof(void *));\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tcard->stats.rx_errors++;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telement++;\n\t\t\toffset = 0;\n\t\t\tdata_ptr = element->addr;\n\t\t} else {\n\t\t\toffset += data_len;\n\t\t}\n\t}\n\t*__element = element;\n\t*__offset = offset;\n\tif (use_rx_sg && card->options.performance_stats) {\n\t\tcard->perf_stats.sg_skbs_rx++;\n\t\tcard->perf_stats.sg_frags_rx += skb_shinfo(skb)->nr_frags;\n\t}\n\treturn skb;\nno_mem:\n\tif (net_ratelimit()) {\n\t\tQETH_CARD_TEXT(card, 2, \"noskbmem\");\n\t}\n\tcard->stats.rx_dropped++;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_next_skb);\n\nstatic void qeth_unregister_dbf_views(void)\n{\n\tint x;\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\tdebug_unregister(qeth_dbf[x].id);\n\t\tqeth_dbf[x].id = NULL;\n\t}\n}\n\nvoid qeth_dbf_longtext(debug_info_t *id, int level, char *fmt, ...)\n{\n\tchar dbf_txt_buf[32];\n\tva_list args;\n\n\tif (level > id->level)\n\t\treturn;\n\tva_start(args, fmt);\n\tvsnprintf(dbf_txt_buf, sizeof(dbf_txt_buf), fmt, args);\n\tva_end(args);\n\tdebug_text_event(id, level, dbf_txt_buf);\n}\nEXPORT_SYMBOL_GPL(qeth_dbf_longtext);\n\nstatic int qeth_register_dbf_views(void)\n{\n\tint ret;\n\tint x;\n\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\t/* register the areas */\n\t\tqeth_dbf[x].id = debug_register(qeth_dbf[x].name,\n\t\t\t\t\t\tqeth_dbf[x].pages,\n\t\t\t\t\t\tqeth_dbf[x].areas,\n\t\t\t\t\t\tqeth_dbf[x].len);\n\t\tif (qeth_dbf[x].id == NULL) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* register a view */\n\t\tret = debug_register_view(qeth_dbf[x].id, qeth_dbf[x].view);\n\t\tif (ret) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* set a passing level */\n\t\tdebug_set_level(qeth_dbf[x].id, qeth_dbf[x].level);\n\t}\n\n\treturn 0;\n}\n\nint qeth_core_load_discipline(struct qeth_card *card,\n\t\tenum qeth_discipline_id discipline)\n{\n\tint rc = 0;\n\tmutex_lock(&qeth_mod_mutex);\n\tswitch (discipline) {\n\tcase QETH_DISCIPLINE_LAYER3:\n\t\tcard->discipline = try_then_request_module(\n\t\t\tsymbol_get(qeth_l3_discipline), \"qeth_l3\");\n\t\tbreak;\n\tcase QETH_DISCIPLINE_LAYER2:\n\t\tcard->discipline = try_then_request_module(\n\t\t\tsymbol_get(qeth_l2_discipline), \"qeth_l2\");\n\t\tbreak;\n\t}\n\tif (!card->discipline) {\n\t\tdev_err(&card->gdev->dev, \"There is no kernel module to \"\n\t\t\t\"support discipline %d\\n\", discipline);\n\t\trc = -EINVAL;\n\t}\n\tmutex_unlock(&qeth_mod_mutex);\n\treturn rc;\n}\n\nvoid qeth_core_free_discipline(struct qeth_card *card)\n{\n\tif (card->options.layer2)\n\t\tsymbol_put(qeth_l2_discipline);\n\telse\n\t\tsymbol_put(qeth_l3_discipline);\n\tcard->discipline = NULL;\n}\n\nstatic const struct device_type qeth_generic_devtype = {\n\t.name = \"qeth_generic\",\n\t.groups = qeth_generic_attr_groups,\n};\nstatic const struct device_type qeth_osn_devtype = {\n\t.name = \"qeth_osn\",\n\t.groups = qeth_osn_attr_groups,\n};\n\n#define DBF_NAME_LEN\t20\n\nstruct qeth_dbf_entry {\n\tchar dbf_name[DBF_NAME_LEN];\n\tdebug_info_t *dbf_info;\n\tstruct list_head dbf_list;\n};\n\nstatic LIST_HEAD(qeth_dbf_list);\nstatic DEFINE_MUTEX(qeth_dbf_list_mutex);\n\nstatic debug_info_t *qeth_get_dbf_entry(char *name)\n{\n\tstruct qeth_dbf_entry *entry;\n\tdebug_info_t *rc = NULL;\n\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_for_each_entry(entry, &qeth_dbf_list, dbf_list) {\n\t\tif (strcmp(entry->dbf_name, name) == 0) {\n\t\t\trc = entry->dbf_info;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&qeth_dbf_list_mutex);\n\treturn rc;\n}\n\nstatic int qeth_add_dbf_entry(struct qeth_card *card, char *name)\n{\n\tstruct qeth_dbf_entry *new_entry;\n\n\tcard->debug = debug_register(name, 2, 1, 8);\n\tif (!card->debug) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", \"qcdbf\");\n\t\tgoto err;\n\t}\n\tif (debug_register_view(card->debug, &debug_hex_ascii_view))\n\t\tgoto err_dbg;\n\tnew_entry = kzalloc(sizeof(struct qeth_dbf_entry), GFP_KERNEL);\n\tif (!new_entry)\n\t\tgoto err_dbg;\n\tstrncpy(new_entry->dbf_name, name, DBF_NAME_LEN);\n\tnew_entry->dbf_info = card->debug;\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_add(&new_entry->dbf_list, &qeth_dbf_list);\n\tmutex_unlock(&qeth_dbf_list_mutex);\n\n\treturn 0;\n\nerr_dbg:\n\tdebug_unregister(card->debug);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void qeth_clear_dbf_list(void)\n{\n\tstruct qeth_dbf_entry *entry, *tmp;\n\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_for_each_entry_safe(entry, tmp, &qeth_dbf_list, dbf_list) {\n\t\tlist_del(&entry->dbf_list);\n\t\tdebug_unregister(entry->dbf_info);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&qeth_dbf_list_mutex);\n}\n\nstatic int qeth_core_probe_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card;\n\tstruct device *dev;\n\tint rc;\n\tunsigned long flags;\n\tchar dbf_name[DBF_NAME_LEN];\n\n\tQETH_DBF_TEXT(SETUP, 2, \"probedev\");\n\n\tdev = &gdev->dev;\n\tif (!get_device(dev))\n\t\treturn -ENODEV;\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", dev_name(&gdev->dev));\n\n\tcard = qeth_alloc_card();\n\tif (!card) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", -ENOMEM);\n\t\trc = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\n\tsnprintf(dbf_name, sizeof(dbf_name), \"qeth_card_%s\",\n\t\tdev_name(&gdev->dev));\n\tcard->debug = qeth_get_dbf_entry(dbf_name);\n\tif (!card->debug) {\n\t\trc = qeth_add_dbf_entry(card, dbf_name);\n\t\tif (rc)\n\t\t\tgoto err_card;\n\t}\n\n\tcard->read.ccwdev  = gdev->cdev[0];\n\tcard->write.ccwdev = gdev->cdev[1];\n\tcard->data.ccwdev  = gdev->cdev[2];\n\tdev_set_drvdata(&gdev->dev, card);\n\tcard->gdev = gdev;\n\tgdev->cdev[0]->handler = qeth_irq;\n\tgdev->cdev[1]->handler = qeth_irq;\n\tgdev->cdev[2]->handler = qeth_irq;\n\n\trc = qeth_determine_card_type(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tgoto err_card;\n\t}\n\trc = qeth_setup_card(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", rc);\n\t\tgoto err_card;\n\t}\n\n\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\tgdev->dev.type = &qeth_osn_devtype;\n\telse\n\t\tgdev->dev.type = &qeth_generic_devtype;\n\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSN:\n\tcase QETH_CARD_TYPE_OSM:\n\t\trc = qeth_core_load_discipline(card, QETH_DISCIPLINE_LAYER2);\n\t\tif (rc)\n\t\t\tgoto err_card;\n\t\trc = card->discipline->setup(card->gdev);\n\t\tif (rc)\n\t\t\tgoto err_disc;\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSX:\n\tdefault:\n\t\tbreak;\n\t}\n\n\twrite_lock_irqsave(&qeth_core_card_list.rwlock, flags);\n\tlist_add_tail(&card->list, &qeth_core_card_list.list);\n\twrite_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\n\n\tqeth_determine_capabilities(card);\n\treturn 0;\n\nerr_disc:\n\tqeth_core_free_discipline(card);\nerr_card:\n\tqeth_core_free_card(card);\nerr_dev:\n\tput_device(dev);\n\treturn rc;\n}\n\nstatic void qeth_core_remove_device(struct ccwgroup_device *gdev)\n{\n\tunsigned long flags;\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\n\tQETH_DBF_TEXT(SETUP, 2, \"removedv\");\n\n\tif (card->discipline) {\n\t\tcard->discipline->remove(gdev);\n\t\tqeth_core_free_discipline(card);\n\t}\n\n\twrite_lock_irqsave(&qeth_core_card_list.rwlock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\n\tqeth_core_free_card(card);\n\tdev_set_drvdata(&gdev->dev, NULL);\n\tput_device(&gdev->dev);\n\treturn;\n}\n\nstatic int qeth_core_set_online(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tint rc = 0;\n\tint def_discipline;\n\n\tif (!card->discipline) {\n\t\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\t\tdef_discipline = QETH_DISCIPLINE_LAYER3;\n\t\telse\n\t\t\tdef_discipline = QETH_DISCIPLINE_LAYER2;\n\t\trc = qeth_core_load_discipline(card, def_discipline);\n\t\tif (rc)\n\t\t\tgoto err;\n\t\trc = card->discipline->setup(card->gdev);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\trc = card->discipline->set_online(gdev);\nerr:\n\treturn rc;\n}\n\nstatic int qeth_core_set_offline(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\treturn card->discipline->set_offline(gdev);\n}\n\nstatic void qeth_core_shutdown(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->shutdown)\n\t\tcard->discipline->shutdown(gdev);\n}\n\nstatic int qeth_core_prepare(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->prepare)\n\t\treturn card->discipline->prepare(gdev);\n\treturn 0;\n}\n\nstatic void qeth_core_complete(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->complete)\n\t\tcard->discipline->complete(gdev);\n}\n\nstatic int qeth_core_freeze(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->freeze)\n\t\treturn card->discipline->freeze(gdev);\n\treturn 0;\n}\n\nstatic int qeth_core_thaw(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->thaw)\n\t\treturn card->discipline->thaw(gdev);\n\treturn 0;\n}\n\nstatic int qeth_core_restore(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->restore)\n\t\treturn card->discipline->restore(gdev);\n\treturn 0;\n}\n\nstatic struct ccwgroup_driver qeth_core_ccwgroup_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"qeth\",\n\t},\n\t.setup = qeth_core_probe_device,\n\t.remove = qeth_core_remove_device,\n\t.set_online = qeth_core_set_online,\n\t.set_offline = qeth_core_set_offline,\n\t.shutdown = qeth_core_shutdown,\n\t.prepare = qeth_core_prepare,\n\t.complete = qeth_core_complete,\n\t.freeze = qeth_core_freeze,\n\t.thaw = qeth_core_thaw,\n\t.restore = qeth_core_restore,\n};\n\nstatic ssize_t qeth_core_driver_group_store(struct device_driver *ddrv,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tint err;\n\n\terr = ccwgroup_create_dev(qeth_core_root_dev,\n\t\t\t\t  &qeth_core_ccwgroup_driver, 3, buf);\n\n\treturn err ? err : count;\n}\nstatic DRIVER_ATTR(group, 0200, NULL, qeth_core_driver_group_store);\n\nstatic struct attribute *qeth_drv_attrs[] = {\n\t&driver_attr_group.attr,\n\tNULL,\n};\nstatic struct attribute_group qeth_drv_attr_group = {\n\t.attrs = qeth_drv_attrs,\n};\nstatic const struct attribute_group *qeth_drv_attr_groups[] = {\n\t&qeth_drv_attr_group,\n\tNULL,\n};\n\nstatic struct {\n\tconst char str[ETH_GSTRING_LEN];\n} qeth_ethtool_stats_keys[] = {\n/*  0 */{\"rx skbs\"},\n\t{\"rx buffers\"},\n\t{\"tx skbs\"},\n\t{\"tx buffers\"},\n\t{\"tx skbs no packing\"},\n\t{\"tx buffers no packing\"},\n\t{\"tx skbs packing\"},\n\t{\"tx buffers packing\"},\n\t{\"tx sg skbs\"},\n\t{\"tx sg frags\"},\n/* 10 */{\"rx sg skbs\"},\n\t{\"rx sg frags\"},\n\t{\"rx sg page allocs\"},\n\t{\"tx large kbytes\"},\n\t{\"tx large count\"},\n\t{\"tx pk state ch n->p\"},\n\t{\"tx pk state ch p->n\"},\n\t{\"tx pk watermark low\"},\n\t{\"tx pk watermark high\"},\n\t{\"queue 0 buffer usage\"},\n/* 20 */{\"queue 1 buffer usage\"},\n\t{\"queue 2 buffer usage\"},\n\t{\"queue 3 buffer usage\"},\n\t{\"rx poll time\"},\n\t{\"rx poll count\"},\n\t{\"rx do_QDIO time\"},\n\t{\"rx do_QDIO count\"},\n\t{\"tx handler time\"},\n\t{\"tx handler count\"},\n\t{\"tx time\"},\n/* 30 */{\"tx count\"},\n\t{\"tx do_QDIO time\"},\n\t{\"tx do_QDIO count\"},\n\t{\"tx csum\"},\n\t{\"tx lin\"},\n\t{\"cq handler count\"},\n\t{\"cq handler time\"}\n};\n\nint qeth_core_get_sset_count(struct net_device *dev, int stringset)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\treturn (sizeof(qeth_ethtool_stats_keys) / ETH_GSTRING_LEN);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_sset_count);\n\nvoid qeth_core_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tdata[0] = card->stats.rx_packets -\n\t\t\t\tcard->perf_stats.initial_rx_packets;\n\tdata[1] = card->perf_stats.bufs_rec;\n\tdata[2] = card->stats.tx_packets -\n\t\t\t\tcard->perf_stats.initial_tx_packets;\n\tdata[3] = card->perf_stats.bufs_sent;\n\tdata[4] = card->stats.tx_packets - card->perf_stats.initial_tx_packets\n\t\t\t- card->perf_stats.skbs_sent_pack;\n\tdata[5] = card->perf_stats.bufs_sent - card->perf_stats.bufs_sent_pack;\n\tdata[6] = card->perf_stats.skbs_sent_pack;\n\tdata[7] = card->perf_stats.bufs_sent_pack;\n\tdata[8] = card->perf_stats.sg_skbs_sent;\n\tdata[9] = card->perf_stats.sg_frags_sent;\n\tdata[10] = card->perf_stats.sg_skbs_rx;\n\tdata[11] = card->perf_stats.sg_frags_rx;\n\tdata[12] = card->perf_stats.sg_alloc_page_rx;\n\tdata[13] = (card->perf_stats.large_send_bytes >> 10);\n\tdata[14] = card->perf_stats.large_send_cnt;\n\tdata[15] = card->perf_stats.sc_dp_p;\n\tdata[16] = card->perf_stats.sc_p_dp;\n\tdata[17] = QETH_LOW_WATERMARK_PACK;\n\tdata[18] = QETH_HIGH_WATERMARK_PACK;\n\tdata[19] = atomic_read(&card->qdio.out_qs[0]->used_buffers);\n\tdata[20] = (card->qdio.no_out_queues > 1) ?\n\t\t\tatomic_read(&card->qdio.out_qs[1]->used_buffers) : 0;\n\tdata[21] = (card->qdio.no_out_queues > 2) ?\n\t\t\tatomic_read(&card->qdio.out_qs[2]->used_buffers) : 0;\n\tdata[22] = (card->qdio.no_out_queues > 3) ?\n\t\t\tatomic_read(&card->qdio.out_qs[3]->used_buffers) : 0;\n\tdata[23] = card->perf_stats.inbound_time;\n\tdata[24] = card->perf_stats.inbound_cnt;\n\tdata[25] = card->perf_stats.inbound_do_qdio_time;\n\tdata[26] = card->perf_stats.inbound_do_qdio_cnt;\n\tdata[27] = card->perf_stats.outbound_handler_time;\n\tdata[28] = card->perf_stats.outbound_handler_cnt;\n\tdata[29] = card->perf_stats.outbound_time;\n\tdata[30] = card->perf_stats.outbound_cnt;\n\tdata[31] = card->perf_stats.outbound_do_qdio_time;\n\tdata[32] = card->perf_stats.outbound_do_qdio_cnt;\n\tdata[33] = card->perf_stats.tx_csum;\n\tdata[34] = card->perf_stats.tx_lin;\n\tdata[35] = card->perf_stats.cq_cnt;\n\tdata[36] = card->perf_stats.cq_time;\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_ethtool_stats);\n\nvoid qeth_core_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, &qeth_ethtool_stats_keys,\n\t\t\tsizeof(qeth_ethtool_stats_keys));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_strings);\n\nvoid qeth_core_get_drvinfo(struct net_device *dev,\n\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tstrlcpy(info->driver, card->options.layer2 ? \"qeth_l2\" : \"qeth_l3\",\n\t\tsizeof(info->driver));\n\tstrlcpy(info->version, \"1.0\", sizeof(info->version));\n\tstrlcpy(info->fw_version, card->info.mcl_level,\n\t\tsizeof(info->fw_version));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"%s/%s/%s\",\n\t\t CARD_RDEV_ID(card), CARD_WDEV_ID(card), CARD_DDEV_ID(card));\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_drvinfo);\n\nint qeth_core_ethtool_get_settings(struct net_device *netdev,\n\t\t\t\t\tstruct ethtool_cmd *ecmd)\n{\n\tstruct qeth_card *card = netdev->ml_priv;\n\tenum qeth_link_types link_type;\n\n\tif ((card->info.type == QETH_CARD_TYPE_IQD) || (card->info.guestlan))\n\t\tlink_type = QETH_LINK_TYPE_10GBIT_ETH;\n\telse\n\t\tlink_type = card->info.link_type;\n\n\tecmd->transceiver = XCVR_INTERNAL;\n\tecmd->supported = SUPPORTED_Autoneg;\n\tecmd->advertising = ADVERTISED_Autoneg;\n\tecmd->duplex = DUPLEX_FULL;\n\tecmd->autoneg = AUTONEG_ENABLE;\n\n\tswitch (link_type) {\n\tcase QETH_LINK_TYPE_FAST_ETH:\n\tcase QETH_LINK_TYPE_LANE_ETH100:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_100baseT_Half |\n\t\t\t\t\tSUPPORTED_100baseT_Full |\n\t\t\t\t\tSUPPORTED_TP;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_TP;\n\t\tecmd->speed = SPEED_100;\n\t\tecmd->port = PORT_TP;\n\t\tbreak;\n\n\tcase QETH_LINK_TYPE_GBIT_ETH:\n\tcase QETH_LINK_TYPE_LANE_ETH1000:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_100baseT_Half |\n\t\t\t\t\tSUPPORTED_100baseT_Full |\n\t\t\t\t\tSUPPORTED_1000baseT_Half |\n\t\t\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\t\t\tSUPPORTED_FIBRE;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_1000baseT_Half |\n\t\t\t\t\tADVERTISED_1000baseT_Full |\n\t\t\t\t\tADVERTISED_FIBRE;\n\t\tecmd->speed = SPEED_1000;\n\t\tecmd->port = PORT_FIBRE;\n\t\tbreak;\n\n\tcase QETH_LINK_TYPE_10GBIT_ETH:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_100baseT_Half |\n\t\t\t\t\tSUPPORTED_100baseT_Full |\n\t\t\t\t\tSUPPORTED_1000baseT_Half |\n\t\t\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\t\t\tSUPPORTED_10000baseT_Full |\n\t\t\t\t\tSUPPORTED_FIBRE;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_1000baseT_Half |\n\t\t\t\t\tADVERTISED_1000baseT_Full |\n\t\t\t\t\tADVERTISED_10000baseT_Full |\n\t\t\t\t\tADVERTISED_FIBRE;\n\t\tecmd->speed = SPEED_10000;\n\t\tecmd->port = PORT_FIBRE;\n\t\tbreak;\n\n\tdefault:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_TP;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_TP;\n\t\tecmd->speed = SPEED_10;\n\t\tecmd->port = PORT_TP;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_core_ethtool_get_settings);\n\nstatic int __init qeth_core_init(void)\n{\n\tint rc;\n\n\tpr_info(\"loading core functions\\n\");\n\tINIT_LIST_HEAD(&qeth_core_card_list.list);\n\tINIT_LIST_HEAD(&qeth_dbf_list);\n\trwlock_init(&qeth_core_card_list.rwlock);\n\tmutex_init(&qeth_mod_mutex);\n\n\tqeth_wq = create_singlethread_workqueue(\"qeth_wq\");\n\n\trc = qeth_register_dbf_views();\n\tif (rc)\n\t\tgoto out_err;\n\tqeth_core_root_dev = root_device_register(\"qeth\");\n\trc = PTR_RET(qeth_core_root_dev);\n\tif (rc)\n\t\tgoto register_err;\n\tqeth_core_header_cache = kmem_cache_create(\"qeth_hdr\",\n\t\t\tsizeof(struct qeth_hdr) + ETH_HLEN, 64, 0, NULL);\n\tif (!qeth_core_header_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto slab_err;\n\t}\n\tqeth_qdio_outbuf_cache = kmem_cache_create(\"qeth_buf\",\n\t\t\tsizeof(struct qeth_qdio_out_buffer), 0, 0, NULL);\n\tif (!qeth_qdio_outbuf_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto cqslab_err;\n\t}\n\trc = ccw_driver_register(&qeth_ccw_driver);\n\tif (rc)\n\t\tgoto ccw_err;\n\tqeth_core_ccwgroup_driver.driver.groups = qeth_drv_attr_groups;\n\trc = ccwgroup_driver_register(&qeth_core_ccwgroup_driver);\n\tif (rc)\n\t\tgoto ccwgroup_err;\n\n\treturn 0;\n\nccwgroup_err:\n\tccw_driver_unregister(&qeth_ccw_driver);\nccw_err:\n\tkmem_cache_destroy(qeth_qdio_outbuf_cache);\ncqslab_err:\n\tkmem_cache_destroy(qeth_core_header_cache);\nslab_err:\n\troot_device_unregister(qeth_core_root_dev);\nregister_err:\n\tqeth_unregister_dbf_views();\nout_err:\n\tpr_err(\"Initializing the qeth device driver failed\\n\");\n\treturn rc;\n}\n\nstatic void __exit qeth_core_exit(void)\n{\n\tqeth_clear_dbf_list();\n\tdestroy_workqueue(qeth_wq);\n\tccwgroup_driver_unregister(&qeth_core_ccwgroup_driver);\n\tccw_driver_unregister(&qeth_ccw_driver);\n\tkmem_cache_destroy(qeth_qdio_outbuf_cache);\n\tkmem_cache_destroy(qeth_core_header_cache);\n\troot_device_unregister(qeth_core_root_dev);\n\tqeth_unregister_dbf_views();\n\tpr_info(\"core functions removed\\n\");\n}\n\nmodule_init(qeth_core_init);\nmodule_exit(qeth_core_exit);\nMODULE_AUTHOR(\"Frank Blaschka <frank.blaschka@de.ibm.com>\");\nMODULE_DESCRIPTION(\"qeth core functions\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n *    Copyright IBM Corp. 2007, 2009\n *    Author(s): Utz Bacher <utz.bacher@de.ibm.com>,\n *\t\t Frank Pavlic <fpavlic@de.ibm.com>,\n *\t\t Thomas Spatzier <tspat@de.ibm.com>,\n *\t\t Frank Blaschka <frank.blaschka@de.ibm.com>\n */\n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/mii.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <net/iucv/af_iucv.h>\n\n#include <asm/ebcdic.h>\n#include <asm/io.h>\n#include <asm/sysinfo.h>\n#include <asm/compat.h>\n\n#include \"qeth_core.h\"\n\nstruct qeth_dbf_info qeth_dbf[QETH_DBF_INFOS] = {\n\t/* define dbf - Name, Pages, Areas, Maxlen, Level, View, Handle */\n\t/*                   N  P  A    M  L  V                      H  */\n\t[QETH_DBF_SETUP] = {\"qeth_setup\",\n\t\t\t\t8, 1,   8, 5, &debug_hex_ascii_view, NULL},\n\t[QETH_DBF_MSG]   = {\"qeth_msg\",\n\t\t\t\t8, 1, 128, 3, &debug_sprintf_view,   NULL},\n\t[QETH_DBF_CTRL]  = {\"qeth_control\",\n\t\t8, 1, QETH_DBF_CTRL_LEN, 5, &debug_hex_ascii_view, NULL},\n};\nEXPORT_SYMBOL_GPL(qeth_dbf);\n\nstruct qeth_card_list_struct qeth_core_card_list;\nEXPORT_SYMBOL_GPL(qeth_core_card_list);\nstruct kmem_cache *qeth_core_header_cache;\nEXPORT_SYMBOL_GPL(qeth_core_header_cache);\nstatic struct kmem_cache *qeth_qdio_outbuf_cache;\n\nstatic struct device *qeth_core_root_dev;\nstatic unsigned int known_devices[][6] = QETH_MODELLIST_ARRAY;\nstatic struct lock_class_key qdio_out_skb_queue_key;\nstatic struct mutex qeth_mod_mutex;\n\nstatic void qeth_send_control_data_cb(struct qeth_channel *,\n\t\t\tstruct qeth_cmd_buffer *);\nstatic int qeth_issue_next_read(struct qeth_card *);\nstatic struct qeth_cmd_buffer *qeth_get_buffer(struct qeth_channel *);\nstatic void qeth_setup_ccw(struct qeth_channel *, unsigned char *, __u32);\nstatic void qeth_free_buffer_pool(struct qeth_card *);\nstatic int qeth_qdio_establish(struct qeth_card *);\nstatic void qeth_free_qdio_buffers(struct qeth_card *);\nstatic void qeth_notify_skbs(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum iucv_tx_notify notification);\nstatic void qeth_release_skbs(struct qeth_qdio_out_buffer *buf);\nstatic void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum qeth_qdio_buffer_states newbufstate);\nstatic int qeth_init_qdio_out_buf(struct qeth_qdio_out_q *, int);\n\nstatic struct workqueue_struct *qeth_wq;\n\nstatic void qeth_close_dev_handler(struct work_struct *work)\n{\n\tstruct qeth_card *card;\n\n\tcard = container_of(work, struct qeth_card, close_dev_work);\n\tQETH_CARD_TEXT(card, 2, \"cldevhdl\");\n\trtnl_lock();\n\tdev_close(card->dev);\n\trtnl_unlock();\n\tccwgroup_set_offline(card->gdev);\n}\n\nvoid qeth_close_dev(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"cldevsubm\");\n\tqueue_work(qeth_wq, &card->close_dev_work);\n}\nEXPORT_SYMBOL_GPL(qeth_close_dev);\n\nstatic inline const char *qeth_get_cardname(struct qeth_card *card)\n{\n\tif (card->info.guestlan) {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \" Virtual NIC QDIO\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \" Virtual NIC Hiper\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \" Virtual NIC QDIO - OSM\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \" Virtual NIC QDIO - OSX\";\n\t\tdefault:\n\t\t\treturn \" unknown\";\n\t\t}\n\t} else {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \" OSD Express\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \" HiperSockets\";\n\t\tcase QETH_CARD_TYPE_OSN:\n\t\t\treturn \" OSN QDIO\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \" OSM QDIO\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \" OSX QDIO\";\n\t\tdefault:\n\t\t\treturn \" unknown\";\n\t\t}\n\t}\n\treturn \" n/a\";\n}\n\n/* max length to be returned: 14 */\nconst char *qeth_get_cardname_short(struct qeth_card *card)\n{\n\tif (card->info.guestlan) {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \"Virt.NIC QDIO\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \"Virt.NIC Hiper\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \"Virt.NIC OSM\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \"Virt.NIC OSX\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t\t}\n\t} else {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\tswitch (card->info.link_type) {\n\t\t\tcase QETH_LINK_TYPE_FAST_ETH:\n\t\t\t\treturn \"OSD_100\";\n\t\t\tcase QETH_LINK_TYPE_HSTR:\n\t\t\t\treturn \"HSTR\";\n\t\t\tcase QETH_LINK_TYPE_GBIT_ETH:\n\t\t\t\treturn \"OSD_1000\";\n\t\t\tcase QETH_LINK_TYPE_10GBIT_ETH:\n\t\t\t\treturn \"OSD_10GIG\";\n\t\t\tcase QETH_LINK_TYPE_LANE_ETH100:\n\t\t\t\treturn \"OSD_FE_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\t\treturn \"OSD_TR_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE_ETH1000:\n\t\t\t\treturn \"OSD_GbE_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE:\n\t\t\t\treturn \"OSD_ATM_LANE\";\n\t\t\tdefault:\n\t\t\t\treturn \"OSD_Express\";\n\t\t\t}\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \"HiperSockets\";\n\t\tcase QETH_CARD_TYPE_OSN:\n\t\t\treturn \"OSN\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \"OSM_1000\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \"OSX_10GIG\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t\t}\n\t}\n\treturn \"n/a\";\n}\n\nvoid qeth_set_recovery_task(struct qeth_card *card)\n{\n\tcard->recovery_task = current;\n}\nEXPORT_SYMBOL_GPL(qeth_set_recovery_task);\n\nvoid qeth_clear_recovery_task(struct qeth_card *card)\n{\n\tcard->recovery_task = NULL;\n}\nEXPORT_SYMBOL_GPL(qeth_clear_recovery_task);\n\nstatic bool qeth_is_recovery_task(const struct qeth_card *card)\n{\n\treturn card->recovery_task == current;\n}\n\nvoid qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,\n\t\t\t int clear_start_mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_allowed_mask = threads;\n\tif (clear_start_mask)\n\t\tcard->thread_start_mask &= threads;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_set_allowed_threads);\n\nint qeth_threads_running(struct qeth_card *card, unsigned long threads)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\trc = (card->thread_running_mask & threads);\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_threads_running);\n\nint qeth_wait_for_threads(struct qeth_card *card, unsigned long threads)\n{\n\tif (qeth_is_recovery_task(card))\n\t\treturn 0;\n\treturn wait_event_interruptible(card->wait_q,\n\t\t\tqeth_threads_running(card, threads) == 0);\n}\nEXPORT_SYMBOL_GPL(qeth_wait_for_threads);\n\nvoid qeth_clear_working_pool_list(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry, *tmp;\n\n\tQETH_CARD_TEXT(card, 5, \"clwrklst\");\n\tlist_for_each_entry_safe(pool_entry, tmp,\n\t\t\t    &card->qdio.in_buf_pool.entry_list, list){\n\t\t\tlist_del(&pool_entry->list);\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_clear_working_pool_list);\n\nstatic int qeth_alloc_buffer_pool(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry;\n\tvoid *ptr;\n\tint i, j;\n\n\tQETH_CARD_TEXT(card, 5, \"alocpool\");\n\tfor (i = 0; i < card->qdio.init_pool.buf_count; ++i) {\n\t\tpool_entry = kzalloc(sizeof(*pool_entry), GFP_KERNEL);\n\t\tif (!pool_entry) {\n\t\t\tqeth_free_buffer_pool(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (j = 0; j < QETH_MAX_BUFFER_ELEMENTS(card); ++j) {\n\t\t\tptr = (void *) __get_free_page(GFP_KERNEL);\n\t\t\tif (!ptr) {\n\t\t\t\twhile (j > 0)\n\t\t\t\t\tfree_page((unsigned long)\n\t\t\t\t\t\t  pool_entry->elements[--j]);\n\t\t\t\tkfree(pool_entry);\n\t\t\t\tqeth_free_buffer_pool(card);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpool_entry->elements[j] = ptr;\n\t\t}\n\t\tlist_add(&pool_entry->init_list,\n\t\t\t &card->qdio.init_pool.entry_list);\n\t}\n\treturn 0;\n}\n\nint qeth_realloc_buffer_pool(struct qeth_card *card, int bufcnt)\n{\n\tQETH_CARD_TEXT(card, 2, \"realcbp\");\n\n\tif ((card->state != CARD_STATE_DOWN) &&\n\t    (card->state != CARD_STATE_RECOVER))\n\t\treturn -EPERM;\n\n\t/* TODO: steel/add buffers from/to a running card's buffer pool (?) */\n\tqeth_clear_working_pool_list(card);\n\tqeth_free_buffer_pool(card);\n\tcard->qdio.in_buf_pool.buf_count = bufcnt;\n\tcard->qdio.init_pool.buf_count = bufcnt;\n\treturn qeth_alloc_buffer_pool(card);\n}\nEXPORT_SYMBOL_GPL(qeth_realloc_buffer_pool);\n\nstatic inline int qeth_cq_init(struct qeth_card *card)\n{\n\tint rc;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"cqinit\");\n\t\tmemset(card->qdio.c_q->qdio_bufs, 0,\n\t\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));\n\t\tcard->qdio.c_q->next_buf_to_init = 127;\n\t\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT,\n\t\t\t     card->qdio.no_in_queues - 1, 0,\n\t\t\t     127);\n\t\tif (rc) {\n\t\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic inline int qeth_alloc_cq(struct qeth_card *card)\n{\n\tint rc;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tint i;\n\t\tstruct qdio_outbuf_state *outbuf_states;\n\n\t\tQETH_DBF_TEXT(SETUP, 2, \"cqon\");\n\t\tcard->qdio.c_q = kzalloc(sizeof(struct qeth_qdio_q),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!card->qdio.c_q) {\n\t\t\trc = -1;\n\t\t\tgoto kmsg_out;\n\t\t}\n\t\tQETH_DBF_HEX(SETUP, 2, &card->qdio.c_q, sizeof(void *));\n\n\t\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\t\tcard->qdio.c_q->bufs[i].buffer =\n\t\t\t\t&card->qdio.c_q->qdio_bufs[i];\n\t\t}\n\n\t\tcard->qdio.no_in_queues = 2;\n\n\t\tcard->qdio.out_bufstates =\n\t\t\tkzalloc(card->qdio.no_out_queues *\n\t\t\t\tQDIO_MAX_BUFFERS_PER_Q *\n\t\t\t\tsizeof(struct qdio_outbuf_state), GFP_KERNEL);\n\t\toutbuf_states = card->qdio.out_bufstates;\n\t\tif (outbuf_states == NULL) {\n\t\t\trc = -1;\n\t\t\tgoto free_cq_out;\n\t\t}\n\t\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\t\tcard->qdio.out_qs[i]->bufstates = outbuf_states;\n\t\t\toutbuf_states += QDIO_MAX_BUFFERS_PER_Q;\n\t\t}\n\t} else {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"nocq\");\n\t\tcard->qdio.c_q = NULL;\n\t\tcard->qdio.no_in_queues = 1;\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"iqc%d\", card->qdio.no_in_queues);\n\trc = 0;\nout:\n\treturn rc;\nfree_cq_out:\n\tkfree(card->qdio.c_q);\n\tcard->qdio.c_q = NULL;\nkmsg_out:\n\tdev_err(&card->gdev->dev, \"Failed to create completion queue\\n\");\n\tgoto out;\n}\n\nstatic inline void qeth_free_cq(struct qeth_card *card)\n{\n\tif (card->qdio.c_q) {\n\t\t--card->qdio.no_in_queues;\n\t\tkfree(card->qdio.c_q);\n\t\tcard->qdio.c_q = NULL;\n\t}\n\tkfree(card->qdio.out_bufstates);\n\tcard->qdio.out_bufstates = NULL;\n}\n\nstatic inline enum iucv_tx_notify qeth_compute_cq_notification(int sbalf15,\n\tint delayed) {\n\tenum iucv_tx_notify n;\n\n\tswitch (sbalf15) {\n\tcase 0:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_OK : TX_NOTIFY_OK;\n\t\tbreak;\n\tcase 4:\n\tcase 16:\n\tcase 17:\n\tcase 18:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_UNREACHABLE :\n\t\t\tTX_NOTIFY_UNREACHABLE;\n\t\tbreak;\n\tdefault:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_GENERALERROR :\n\t\t\tTX_NOTIFY_GENERALERROR;\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n\nstatic inline void qeth_cleanup_handled_pending(struct qeth_qdio_out_q *q,\n\tint bidx, int forced_cleanup)\n{\n\tif (q->card->options.cq != QETH_CQ_ENABLED)\n\t\treturn;\n\n\tif (q->bufs[bidx]->next_pending != NULL) {\n\t\tstruct qeth_qdio_out_buffer *head = q->bufs[bidx];\n\t\tstruct qeth_qdio_out_buffer *c = q->bufs[bidx]->next_pending;\n\n\t\twhile (c) {\n\t\t\tif (forced_cleanup ||\n\t\t\t    atomic_read(&c->state) ==\n\t\t\t      QETH_QDIO_BUF_HANDLED_DELAYED) {\n\t\t\t\tstruct qeth_qdio_out_buffer *f = c;\n\t\t\t\tQETH_CARD_TEXT(f->q->card, 5, \"fp\");\n\t\t\t\tQETH_CARD_TEXT_(f->q->card, 5, \"%lx\", (long) f);\n\t\t\t\t/* release here to avoid interleaving between\n\t\t\t\t   outbound tasklet and inbound tasklet\n\t\t\t\t   regarding notifications and lifecycle */\n\t\t\t\tqeth_release_skbs(c);\n\n\t\t\t\tc = f->next_pending;\n\t\t\t\tWARN_ON_ONCE(head->next_pending != f);\n\t\t\t\thead->next_pending = c;\n\t\t\t\tkmem_cache_free(qeth_qdio_outbuf_cache, f);\n\t\t\t} else {\n\t\t\t\thead = c;\n\t\t\t\tc = c->next_pending;\n\t\t\t}\n\n\t\t}\n\t}\n\tif (forced_cleanup && (atomic_read(&(q->bufs[bidx]->state)) ==\n\t\t\t\t\tQETH_QDIO_BUF_HANDLED_DELAYED)) {\n\t\t/* for recovery situations */\n\t\tq->bufs[bidx]->aob = q->bufstates[bidx].aob;\n\t\tqeth_init_qdio_out_buf(q, bidx);\n\t\tQETH_CARD_TEXT(q->card, 2, \"clprecov\");\n\t}\n}\n\n\nstatic inline void qeth_qdio_handle_aob(struct qeth_card *card,\n\t\tunsigned long phys_aob_addr) {\n\tstruct qaob *aob;\n\tstruct qeth_qdio_out_buffer *buffer;\n\tenum iucv_tx_notify notification;\n\n\taob = (struct qaob *) phys_to_virt(phys_aob_addr);\n\tQETH_CARD_TEXT(card, 5, \"haob\");\n\tQETH_CARD_TEXT_(card, 5, \"%lx\", phys_aob_addr);\n\tbuffer = (struct qeth_qdio_out_buffer *) aob->user1;\n\tQETH_CARD_TEXT_(card, 5, \"%lx\", aob->user1);\n\n\tif (atomic_cmpxchg(&buffer->state, QETH_QDIO_BUF_PRIMED,\n\t\t\t   QETH_QDIO_BUF_IN_CQ) == QETH_QDIO_BUF_PRIMED) {\n\t\tnotification = TX_NOTIFY_OK;\n\t} else {\n\t\tWARN_ON_ONCE(atomic_read(&buffer->state) !=\n\t\t\t\t\t\t\tQETH_QDIO_BUF_PENDING);\n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_IN_CQ);\n\t\tnotification = TX_NOTIFY_DELAYED_OK;\n\t}\n\n\tif (aob->aorc != 0)  {\n\t\tQETH_CARD_TEXT_(card, 2, \"aorc%02X\", aob->aorc);\n\t\tnotification = qeth_compute_cq_notification(aob->aorc, 1);\n\t}\n\tqeth_notify_skbs(buffer->q, buffer, notification);\n\n\tbuffer->aob = NULL;\n\tqeth_clear_output_buffer(buffer->q, buffer,\n\t\t\t\t QETH_QDIO_BUF_HANDLED_DELAYED);\n\n\t/* from here on: do not touch buffer anymore */\n\tqdio_release_aob(aob);\n}\n\nstatic inline int qeth_is_cq(struct qeth_card *card, unsigned int queue)\n{\n\treturn card->options.cq == QETH_CQ_ENABLED &&\n\t    card->qdio.c_q != NULL &&\n\t    queue != 0 &&\n\t    queue == card->qdio.no_in_queues - 1;\n}\n\n\nstatic int qeth_issue_next_read(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 5, \"issnxrd\");\n\tif (card->read.state != CH_STATE_UP)\n\t\treturn -EIO;\n\tiob = qeth_get_buffer(&card->read);\n\tif (!iob) {\n\t\tdev_warn(&card->gdev->dev, \"The qeth device driver \"\n\t\t\t\"failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"%s issue_next_read failed: no iob \"\n\t\t\t\"available\\n\", dev_name(&card->gdev->dev));\n\t\treturn -ENOMEM;\n\t}\n\tqeth_setup_ccw(&card->read, iob->data, QETH_BUFSIZE);\n\tQETH_CARD_TEXT(card, 6, \"noirqpnd\");\n\trc = ccw_device_start(card->read.ccwdev, &card->read.ccw,\n\t\t\t      (addr_t) iob, 0, 0);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"%s error in starting next read ccw! \"\n\t\t\t\"rc=%i\\n\", dev_name(&card->gdev->dev), rc);\n\t\tatomic_set(&card->read.irq_pending, 0);\n\t\tcard->read_or_write_problem = 1;\n\t\tqeth_schedule_recovery(card);\n\t\twake_up(&card->wait_q);\n\t}\n\treturn rc;\n}\n\nstatic struct qeth_reply *qeth_alloc_reply(struct qeth_card *card)\n{\n\tstruct qeth_reply *reply;\n\n\treply = kzalloc(sizeof(struct qeth_reply), GFP_ATOMIC);\n\tif (reply) {\n\t\tatomic_set(&reply->refcnt, 1);\n\t\tatomic_set(&reply->received, 0);\n\t\treply->card = card;\n\t}\n\treturn reply;\n}\n\nstatic void qeth_get_reply(struct qeth_reply *reply)\n{\n\tWARN_ON(atomic_read(&reply->refcnt) <= 0);\n\tatomic_inc(&reply->refcnt);\n}\n\nstatic void qeth_put_reply(struct qeth_reply *reply)\n{\n\tWARN_ON(atomic_read(&reply->refcnt) <= 0);\n\tif (atomic_dec_and_test(&reply->refcnt))\n\t\tkfree(reply);\n}\n\nstatic void qeth_issue_ipa_msg(struct qeth_ipa_cmd *cmd, int rc,\n\t\tstruct qeth_card *card)\n{\n\tchar *ipa_name;\n\tint com = cmd->hdr.command;\n\tipa_name = qeth_get_ipa_cmd_name(com);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"IPA: %s(x%X) for %s/%s returned \"\n\t\t\t\t\"x%X \\\"%s\\\"\\n\",\n\t\t\t\tipa_name, com, dev_name(&card->gdev->dev),\n\t\t\t\tQETH_CARD_IFNAME(card), rc,\n\t\t\t\tqeth_get_ipa_msg(rc));\n\telse\n\t\tQETH_DBF_MESSAGE(5, \"IPA: %s(x%X) for %s/%s succeeded\\n\",\n\t\t\t\tipa_name, com, dev_name(&card->gdev->dev),\n\t\t\t\tQETH_CARD_IFNAME(card));\n}\n\nstatic struct qeth_ipa_cmd *qeth_check_ipa_data(struct qeth_card *card,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_ipa_cmd *cmd = NULL;\n\n\tQETH_CARD_TEXT(card, 5, \"chkipad\");\n\tif (IS_IPA(iob->data)) {\n\t\tcmd = (struct qeth_ipa_cmd *) PDU_ENCAPSULATION(iob->data);\n\t\tif (IS_IPA_REPLY(cmd)) {\n\t\t\tif (cmd->hdr.command != IPA_CMD_SETCCID &&\n\t\t\t    cmd->hdr.command != IPA_CMD_DELCCID &&\n\t\t\t    cmd->hdr.command != IPA_CMD_MODCCID &&\n\t\t\t    cmd->hdr.command != IPA_CMD_SET_DIAG_ASS)\n\t\t\t\tqeth_issue_ipa_msg(cmd,\n\t\t\t\t\t\tcmd->hdr.return_code, card);\n\t\t\treturn cmd;\n\t\t} else {\n\t\t\tswitch (cmd->hdr.command) {\n\t\t\tcase IPA_CMD_STOPLAN:\n\t\t\t\tif (cmd->hdr.return_code ==\n\t\t\t\t\t\tIPA_RC_VEPA_TO_VEB_TRANSITION) {\n\t\t\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\t\t   \"Interface %s is down because the \"\n\t\t\t\t\t   \"adjacent port is no longer in \"\n\t\t\t\t\t   \"reflective relay mode\\n\",\n\t\t\t\t\t   QETH_CARD_IFNAME(card));\n\t\t\t\t\tqeth_close_dev(card);\n\t\t\t\t} else {\n\t\t\t\t\tdev_warn(&card->gdev->dev,\n\t\t\t\t\t   \"The link for interface %s on CHPID\"\n\t\t\t\t\t   \" 0x%X failed\\n\",\n\t\t\t\t\t   QETH_CARD_IFNAME(card),\n\t\t\t\t\t   card->info.chpid);\n\t\t\t\t\tqeth_issue_ipa_msg(cmd,\n\t\t\t\t\t\tcmd->hdr.return_code, card);\n\t\t\t\t}\n\t\t\t\tcard->lan_online = 0;\n\t\t\t\tif (card->dev && netif_carrier_ok(card->dev))\n\t\t\t\t\tnetif_carrier_off(card->dev);\n\t\t\t\treturn NULL;\n\t\t\tcase IPA_CMD_STARTLAN:\n\t\t\t\tdev_info(&card->gdev->dev,\n\t\t\t\t\t   \"The link for %s on CHPID 0x%X has\"\n\t\t\t\t\t   \" been restored\\n\",\n\t\t\t\t\t   QETH_CARD_IFNAME(card),\n\t\t\t\t\t   card->info.chpid);\n\t\t\t\tnetif_carrier_on(card->dev);\n\t\t\t\tcard->lan_online = 1;\n\t\t\t\tif (card->info.hwtrap)\n\t\t\t\t\tcard->info.hwtrap = 2;\n\t\t\t\tqeth_schedule_recovery(card);\n\t\t\t\treturn NULL;\n\t\t\tcase IPA_CMD_MODCCID:\n\t\t\t\treturn cmd;\n\t\t\tcase IPA_CMD_REGISTER_LOCAL_ADDR:\n\t\t\t\tQETH_CARD_TEXT(card, 3, \"irla\");\n\t\t\t\tbreak;\n\t\t\tcase IPA_CMD_UNREGISTER_LOCAL_ADDR:\n\t\t\t\tQETH_CARD_TEXT(card, 3, \"urla\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tQETH_DBF_MESSAGE(2, \"Received data is IPA \"\n\t\t\t\t\t   \"but not a reply!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn cmd;\n}\n\nvoid qeth_clear_ipacmd_list(struct qeth_card *card)\n{\n\tstruct qeth_reply *reply, *r;\n\tunsigned long flags;\n\n\tQETH_CARD_TEXT(card, 4, \"clipalst\");\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {\n\t\tqeth_get_reply(reply);\n\t\treply->rc = -EIO;\n\t\tatomic_inc(&reply->received);\n\t\tlist_del_init(&reply->list);\n\t\twake_up(&reply->wait_q);\n\t\tqeth_put_reply(reply);\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tatomic_set(&card->write.irq_pending, 0);\n}\nEXPORT_SYMBOL_GPL(qeth_clear_ipacmd_list);\n\nstatic int qeth_check_idx_response(struct qeth_card *card,\n\tunsigned char *buffer)\n{\n\tif (!buffer)\n\t\treturn 0;\n\n\tQETH_DBF_HEX(CTRL, 2, buffer, QETH_DBF_CTRL_LEN);\n\tif ((buffer[2] & 0xc0) == 0xc0) {\n\t\tQETH_DBF_MESSAGE(2, \"received an IDX TERMINATE \"\n\t\t\t   \"with cause code 0x%02x%s\\n\",\n\t\t\t   buffer[4],\n\t\t\t   ((buffer[4] == 0x22) ?\n\t\t\t    \" -- try another portname\" : \"\"));\n\t\tQETH_CARD_TEXT(card, 2, \"ckidxres\");\n\t\tQETH_CARD_TEXT(card, 2, \" idxterm\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -EIO);\n\t\tif (buffer[4] == 0xf6) {\n\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\"The qeth device is not configured \"\n\t\t\t\"for the OSI layer required by z/VM\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_setup_ccw(struct qeth_channel *channel, unsigned char *iob,\n\t\t__u32 len)\n{\n\tstruct qeth_card *card;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 4, \"setupccw\");\n\tif (channel == &card->read)\n\t\tmemcpy(&channel->ccw, READ_CCW, sizeof(struct ccw1));\n\telse\n\t\tmemcpy(&channel->ccw, WRITE_CCW, sizeof(struct ccw1));\n\tchannel->ccw.count = len;\n\tchannel->ccw.cda = (__u32) __pa(iob);\n}\n\nstatic struct qeth_cmd_buffer *__qeth_get_buffer(struct qeth_channel *channel)\n{\n\t__u8 index;\n\n\tQETH_CARD_TEXT(CARD_FROM_CDEV(channel->ccwdev), 6, \"getbuff\");\n\tindex = channel->io_buf_no;\n\tdo {\n\t\tif (channel->iob[index].state == BUF_STATE_FREE) {\n\t\t\tchannel->iob[index].state = BUF_STATE_LOCKED;\n\t\t\tchannel->io_buf_no = (channel->io_buf_no + 1) %\n\t\t\t\tQETH_CMD_BUFFER_NO;\n\t\t\tmemset(channel->iob[index].data, 0, QETH_BUFSIZE);\n\t\t\treturn channel->iob + index;\n\t\t}\n\t\tindex = (index + 1) % QETH_CMD_BUFFER_NO;\n\t} while (index != channel->io_buf_no);\n\n\treturn NULL;\n}\n\nvoid qeth_release_buffer(struct qeth_channel *channel,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tunsigned long flags;\n\n\tQETH_CARD_TEXT(CARD_FROM_CDEV(channel->ccwdev), 6, \"relbuff\");\n\tspin_lock_irqsave(&channel->iob_lock, flags);\n\tmemset(iob->data, 0, QETH_BUFSIZE);\n\tiob->state = BUF_STATE_FREE;\n\tiob->callback = qeth_send_control_data_cb;\n\tiob->rc = 0;\n\tspin_unlock_irqrestore(&channel->iob_lock, flags);\n\twake_up(&channel->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_release_buffer);\n\nstatic struct qeth_cmd_buffer *qeth_get_buffer(struct qeth_channel *channel)\n{\n\tstruct qeth_cmd_buffer *buffer = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->iob_lock, flags);\n\tbuffer = __qeth_get_buffer(channel);\n\tspin_unlock_irqrestore(&channel->iob_lock, flags);\n\treturn buffer;\n}\n\nstruct qeth_cmd_buffer *qeth_wait_for_buffer(struct qeth_channel *channel)\n{\n\tstruct qeth_cmd_buffer *buffer;\n\twait_event(channel->wait_q,\n\t\t   ((buffer = qeth_get_buffer(channel)) != NULL));\n\treturn buffer;\n}\nEXPORT_SYMBOL_GPL(qeth_wait_for_buffer);\n\nvoid qeth_clear_cmd_buffers(struct qeth_channel *channel)\n{\n\tint cnt;\n\n\tfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++)\n\t\tqeth_release_buffer(channel, &channel->iob[cnt]);\n\tchannel->buf_no = 0;\n\tchannel->io_buf_no = 0;\n}\nEXPORT_SYMBOL_GPL(qeth_clear_cmd_buffers);\n\nstatic void qeth_send_control_data_cb(struct qeth_channel *channel,\n\t\t  struct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_card *card;\n\tstruct qeth_reply *reply, *r;\n\tstruct qeth_ipa_cmd *cmd;\n\tunsigned long flags;\n\tint keep_reply;\n\tint rc = 0;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 4, \"sndctlcb\");\n\trc = qeth_check_idx_response(card, iob->data);\n\tswitch (rc) {\n\tcase 0:\n\t\tbreak;\n\tcase -EIO:\n\t\tqeth_clear_ipacmd_list(card);\n\t\tqeth_schedule_recovery(card);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tcmd = qeth_check_ipa_data(card, iob);\n\tif ((cmd == NULL) && (card->state != CARD_STATE_DOWN))\n\t\tgoto out;\n\t/*in case of OSN : check if cmd is set */\n\tif (card->info.type == QETH_CARD_TYPE_OSN &&\n\t    cmd &&\n\t    cmd->hdr.command != IPA_CMD_STARTLAN &&\n\t    card->osn_info.assist_cb != NULL) {\n\t\tcard->osn_info.assist_cb(card->dev, cmd);\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {\n\t\tif ((reply->seqno == QETH_IDX_COMMAND_SEQNO) ||\n\t\t    ((cmd) && (reply->seqno == cmd->hdr.seqno))) {\n\t\t\tqeth_get_reply(reply);\n\t\t\tlist_del_init(&reply->list);\n\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\tkeep_reply = 0;\n\t\t\tif (reply->callback != NULL) {\n\t\t\t\tif (cmd) {\n\t\t\t\t\treply->offset = (__u16)((char *)cmd -\n\t\t\t\t\t\t\t(char *)iob->data);\n\t\t\t\t\tkeep_reply = reply->callback(card,\n\t\t\t\t\t\t\treply,\n\t\t\t\t\t\t\t(unsigned long)cmd);\n\t\t\t\t} else\n\t\t\t\t\tkeep_reply = reply->callback(card,\n\t\t\t\t\t\t\treply,\n\t\t\t\t\t\t\t(unsigned long)iob);\n\t\t\t}\n\t\t\tif (cmd)\n\t\t\t\treply->rc = (u16) cmd->hdr.return_code;\n\t\t\telse if (iob->rc)\n\t\t\t\treply->rc = iob->rc;\n\t\t\tif (keep_reply) {\n\t\t\t\tspin_lock_irqsave(&card->lock, flags);\n\t\t\t\tlist_add_tail(&reply->list,\n\t\t\t\t\t      &card->cmd_waiter_list);\n\t\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\t} else {\n\t\t\t\tatomic_inc(&reply->received);\n\t\t\t\twake_up(&reply->wait_q);\n\t\t\t}\n\t\t\tqeth_put_reply(reply);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\nout:\n\tmemcpy(&card->seqno.pdu_hdr_ack,\n\t\tQETH_PDU_HEADER_SEQ_NO(iob->data),\n\t\tQETH_SEQ_NO_LENGTH);\n\tqeth_release_buffer(channel, iob);\n}\n\nstatic int qeth_setup_channel(struct qeth_channel *channel)\n{\n\tint cnt;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"setupch\");\n\tfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++) {\n\t\tchannel->iob[cnt].data =\n\t\t\tkzalloc(QETH_BUFSIZE, GFP_DMA|GFP_KERNEL);\n\t\tif (channel->iob[cnt].data == NULL)\n\t\t\tbreak;\n\t\tchannel->iob[cnt].state = BUF_STATE_FREE;\n\t\tchannel->iob[cnt].channel = channel;\n\t\tchannel->iob[cnt].callback = qeth_send_control_data_cb;\n\t\tchannel->iob[cnt].rc = 0;\n\t}\n\tif (cnt < QETH_CMD_BUFFER_NO) {\n\t\twhile (cnt-- > 0)\n\t\t\tkfree(channel->iob[cnt].data);\n\t\treturn -ENOMEM;\n\t}\n\tchannel->buf_no = 0;\n\tchannel->io_buf_no = 0;\n\tatomic_set(&channel->irq_pending, 0);\n\tspin_lock_init(&channel->iob_lock);\n\n\tinit_waitqueue_head(&channel->wait_q);\n\treturn 0;\n}\n\nstatic int qeth_set_thread_start_bit(struct qeth_card *card,\n\t\tunsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tif (!(card->thread_allowed_mask & thread) ||\n\t      (card->thread_start_mask & thread)) {\n\t\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\t\treturn -EPERM;\n\t}\n\tcard->thread_start_mask |= thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn 0;\n}\n\nvoid qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_start_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_clear_thread_start_bit);\n\nvoid qeth_clear_thread_running_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_running_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_clear_thread_running_bit);\n\nstatic int __qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tif (card->thread_start_mask & thread) {\n\t\tif ((card->thread_allowed_mask & thread) &&\n\t\t    !(card->thread_running_mask & thread)) {\n\t\t\trc = 1;\n\t\t\tcard->thread_start_mask &= ~thread;\n\t\t\tcard->thread_running_mask |= thread;\n\t\t} else\n\t\t\trc = -EPERM;\n\t}\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\n\nint qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\n{\n\tint rc = 0;\n\n\twait_event(card->wait_q,\n\t\t   (rc = __qeth_do_run_thread(card, thread)) >= 0);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_do_run_thread);\n\nvoid qeth_schedule_recovery(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"startrec\");\n\tif (qeth_set_thread_start_bit(card, QETH_RECOVER_THREAD) == 0)\n\t\tschedule_work(&card->kernel_thread_starter);\n}\nEXPORT_SYMBOL_GPL(qeth_schedule_recovery);\n\nstatic int qeth_get_problem(struct ccw_device *cdev, struct irb *irb)\n{\n\tint dstat, cstat;\n\tchar *sense;\n\tstruct qeth_card *card;\n\n\tsense = (char *) irb->ecw;\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\tcard = CARD_FROM_CDEV(cdev);\n\n\tif (cstat & (SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK |\n\t\t     SCHN_STAT_CHN_DATA_CHK | SCHN_STAT_CHAIN_CHECK |\n\t\t     SCHN_STAT_PROT_CHECK | SCHN_STAT_PROG_CHECK)) {\n\t\tQETH_CARD_TEXT(card, 2, \"CGENCHK\");\n\t\tdev_warn(&cdev->dev, \"The qeth device driver \"\n\t\t\t\"failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"%s check on device dstat=x%x, cstat=x%x\\n\",\n\t\t\tdev_name(&cdev->dev), dstat, cstat);\n\t\tprint_hex_dump(KERN_WARNING, \"qeth: irb \", DUMP_PREFIX_OFFSET,\n\t\t\t\t16, 1, irb, 64, 1);\n\t\treturn 1;\n\t}\n\n\tif (dstat & DEV_STAT_UNIT_CHECK) {\n\t\tif (sense[SENSE_RESETTING_EVENT_BYTE] &\n\t\t    SENSE_RESETTING_EVENT_FLAG) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"REVIND\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (sense[SENSE_COMMAND_REJECT_BYTE] &\n\t\t    SENSE_COMMAND_REJECT_FLAG) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"CMDREJi\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((sense[2] == 0xaf) && (sense[3] == 0xfe)) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"AFFE\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((!sense[0]) && (!sense[1]) && (!sense[2]) && (!sense[3])) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"ZEROSEN\");\n\t\t\treturn 0;\n\t\t}\n\t\tQETH_CARD_TEXT(card, 2, \"DGENCHK\");\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic long __qeth_check_irb_error(struct ccw_device *cdev,\n\t\tunsigned long intparm, struct irb *irb)\n{\n\tstruct qeth_card *card;\n\n\tcard = CARD_FROM_CDEV(cdev);\n\n\tif (!IS_ERR(irb))\n\t\treturn 0;\n\n\tswitch (PTR_ERR(irb)) {\n\tcase -EIO:\n\t\tQETH_DBF_MESSAGE(2, \"%s i/o-error on device\\n\",\n\t\t\tdev_name(&cdev->dev));\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -EIO);\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tdev_warn(&cdev->dev, \"A hardware operation timed out\"\n\t\t\t\" on the device\\n\");\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -ETIMEDOUT);\n\t\tif (intparm == QETH_RCD_PARM) {\n\t\t\tif (card && (card->data.ccwdev == cdev)) {\n\t\t\t\tcard->data.state = CH_STATE_DOWN;\n\t\t\t\twake_up(&card->wait_q);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(2, \"%s unknown error %ld on device\\n\",\n\t\t\tdev_name(&cdev->dev), PTR_ERR(irb));\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT(card, 2, \"  rc???\");\n\t}\n\treturn PTR_ERR(irb);\n}\n\nstatic void qeth_irq(struct ccw_device *cdev, unsigned long intparm,\n\t\tstruct irb *irb)\n{\n\tint rc;\n\tint cstat, dstat;\n\tstruct qeth_cmd_buffer *buffer;\n\tstruct qeth_channel *channel;\n\tstruct qeth_card *card;\n\tstruct qeth_cmd_buffer *iob;\n\t__u8 index;\n\n\tif (__qeth_check_irb_error(cdev, intparm, irb))\n\t\treturn;\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\n\tcard = CARD_FROM_CDEV(cdev);\n\tif (!card)\n\t\treturn;\n\n\tQETH_CARD_TEXT(card, 5, \"irq\");\n\n\tif (card->read.ccwdev == cdev) {\n\t\tchannel = &card->read;\n\t\tQETH_CARD_TEXT(card, 5, \"read\");\n\t} else if (card->write.ccwdev == cdev) {\n\t\tchannel = &card->write;\n\t\tQETH_CARD_TEXT(card, 5, \"write\");\n\t} else {\n\t\tchannel = &card->data;\n\t\tQETH_CARD_TEXT(card, 5, \"data\");\n\t}\n\tatomic_set(&channel->irq_pending, 0);\n\n\tif (irb->scsw.cmd.fctl & (SCSW_FCTL_CLEAR_FUNC))\n\t\tchannel->state = CH_STATE_STOPPED;\n\n\tif (irb->scsw.cmd.fctl & (SCSW_FCTL_HALT_FUNC))\n\t\tchannel->state = CH_STATE_HALTED;\n\n\t/*let's wake up immediately on data channel*/\n\tif ((channel == &card->data) && (intparm != 0) &&\n\t    (intparm != QETH_RCD_PARM))\n\t\tgoto out;\n\n\tif (intparm == QETH_CLEAR_CHANNEL_PARM) {\n\t\tQETH_CARD_TEXT(card, 6, \"clrchpar\");\n\t\t/* we don't have to handle this further */\n\t\tintparm = 0;\n\t}\n\tif (intparm == QETH_HALT_CHANNEL_PARM) {\n\t\tQETH_CARD_TEXT(card, 6, \"hltchpar\");\n\t\t/* we don't have to handle this further */\n\t\tintparm = 0;\n\t}\n\tif ((dstat & DEV_STAT_UNIT_EXCEP) ||\n\t    (dstat & DEV_STAT_UNIT_CHECK) ||\n\t    (cstat)) {\n\t\tif (irb->esw.esw0.erw.cons) {\n\t\t\tdev_warn(&channel->ccwdev->dev,\n\t\t\t\t\"The qeth device driver failed to recover \"\n\t\t\t\t\"an error on the device\\n\");\n\t\t\tQETH_DBF_MESSAGE(2, \"%s sense data available. cstat \"\n\t\t\t\t\"0x%X dstat 0x%X\\n\",\n\t\t\t\tdev_name(&channel->ccwdev->dev), cstat, dstat);\n\t\t\tprint_hex_dump(KERN_WARNING, \"qeth: irb \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1, irb, 32, 1);\n\t\t\tprint_hex_dump(KERN_WARNING, \"qeth: sense data \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1, irb->ecw, 32, 1);\n\t\t}\n\t\tif (intparm == QETH_RCD_PARM) {\n\t\t\tchannel->state = CH_STATE_DOWN;\n\t\t\tgoto out;\n\t\t}\n\t\trc = qeth_get_problem(cdev, irb);\n\t\tif (rc) {\n\t\t\tqeth_clear_ipacmd_list(card);\n\t\t\tqeth_schedule_recovery(card);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (intparm == QETH_RCD_PARM) {\n\t\tchannel->state = CH_STATE_RCD_DONE;\n\t\tgoto out;\n\t}\n\tif (intparm) {\n\t\tbuffer = (struct qeth_cmd_buffer *) __va((addr_t)intparm);\n\t\tbuffer->state = BUF_STATE_PROCESSED;\n\t}\n\tif (channel == &card->data)\n\t\treturn;\n\tif (channel == &card->read &&\n\t    channel->state == CH_STATE_UP)\n\t\tqeth_issue_next_read(card);\n\n\tiob = channel->iob;\n\tindex = channel->buf_no;\n\twhile (iob[index].state == BUF_STATE_PROCESSED) {\n\t\tif (iob[index].callback != NULL)\n\t\t\tiob[index].callback(channel, iob + index);\n\n\t\tindex = (index + 1) % QETH_CMD_BUFFER_NO;\n\t}\n\tchannel->buf_no = index;\nout:\n\twake_up(&card->wait_q);\n\treturn;\n}\n\nstatic void qeth_notify_skbs(struct qeth_qdio_out_q *q,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum iucv_tx_notify notification)\n{\n\tstruct sk_buff *skb;\n\n\tif (skb_queue_empty(&buf->skb_list))\n\t\tgoto out;\n\tskb = skb_peek(&buf->skb_list);\n\twhile (skb) {\n\t\tQETH_CARD_TEXT_(q->card, 5, \"skbn%d\", notification);\n\t\tQETH_CARD_TEXT_(q->card, 5, \"%lx\", (long) skb);\n\t\tif (skb->protocol == ETH_P_AF_IUCV) {\n\t\t\tif (skb->sk) {\n\t\t\t\tstruct iucv_sock *iucv = iucv_sk(skb->sk);\n\t\t\t\tiucv->sk_txnotify(skb, notification);\n\t\t\t}\n\t\t}\n\t\tif (skb_queue_is_last(&buf->skb_list, skb))\n\t\t\tskb = NULL;\n\t\telse\n\t\t\tskb = skb_queue_next(&buf->skb_list, skb);\n\t}\nout:\n\treturn;\n}\n\nstatic void qeth_release_skbs(struct qeth_qdio_out_buffer *buf)\n{\n\tstruct sk_buff *skb;\n\tstruct iucv_sock *iucv;\n\tint notify_general_error = 0;\n\n\tif (atomic_read(&buf->state) == QETH_QDIO_BUF_PENDING)\n\t\tnotify_general_error = 1;\n\n\t/* release may never happen from within CQ tasklet scope */\n\tWARN_ON_ONCE(atomic_read(&buf->state) == QETH_QDIO_BUF_IN_CQ);\n\n\tskb = skb_dequeue(&buf->skb_list);\n\twhile (skb) {\n\t\tQETH_CARD_TEXT(buf->q->card, 5, \"skbr\");\n\t\tQETH_CARD_TEXT_(buf->q->card, 5, \"%lx\", (long) skb);\n\t\tif (notify_general_error && skb->protocol == ETH_P_AF_IUCV) {\n\t\t\tif (skb->sk) {\n\t\t\t\tiucv = iucv_sk(skb->sk);\n\t\t\t\tiucv->sk_txnotify(skb, TX_NOTIFY_GENERALERROR);\n\t\t\t}\n\t\t}\n\t\tatomic_dec(&skb->users);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = skb_dequeue(&buf->skb_list);\n\t}\n}\n\nstatic void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum qeth_qdio_buffer_states newbufstate)\n{\n\tint i;\n\n\t/* is PCI flag set on buffer? */\n\tif (buf->buffer->element[0].sflags & SBAL_SFLAGS0_PCI_REQ)\n\t\tatomic_dec(&queue->set_pci_flags_count);\n\n\tif (newbufstate == QETH_QDIO_BUF_EMPTY) {\n\t\tqeth_release_skbs(buf);\n\t}\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(queue->card); ++i) {\n\t\tif (buf->buffer->element[i].addr && buf->is_header[i])\n\t\t\tkmem_cache_free(qeth_core_header_cache,\n\t\t\t\tbuf->buffer->element[i].addr);\n\t\tbuf->is_header[i] = 0;\n\t\tbuf->buffer->element[i].length = 0;\n\t\tbuf->buffer->element[i].addr = NULL;\n\t\tbuf->buffer->element[i].eflags = 0;\n\t\tbuf->buffer->element[i].sflags = 0;\n\t}\n\tbuf->buffer->element[15].eflags = 0;\n\tbuf->buffer->element[15].sflags = 0;\n\tbuf->next_element_to_fill = 0;\n\tatomic_set(&buf->state, newbufstate);\n}\n\nstatic void qeth_clear_outq_buffers(struct qeth_qdio_out_q *q, int free)\n{\n\tint j;\n\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (!q->bufs[j])\n\t\t\tcontinue;\n\t\tqeth_cleanup_handled_pending(q, j, 1);\n\t\tqeth_clear_output_buffer(q, q->bufs[j], QETH_QDIO_BUF_EMPTY);\n\t\tif (free) {\n\t\t\tkmem_cache_free(qeth_qdio_outbuf_cache, q->bufs[j]);\n\t\t\tq->bufs[j] = NULL;\n\t\t}\n\t}\n}\n\nvoid qeth_clear_qdio_buffers(struct qeth_card *card)\n{\n\tint i;\n\n\tQETH_CARD_TEXT(card, 2, \"clearqdbf\");\n\t/* clear outbound buffers to free skbs */\n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tif (card->qdio.out_qs[i]) {\n\t\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 0);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_clear_qdio_buffers);\n\nstatic void qeth_free_buffer_pool(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry, *tmp;\n\tint i = 0;\n\tlist_for_each_entry_safe(pool_entry, tmp,\n\t\t\t\t &card->qdio.init_pool.entry_list, init_list){\n\t\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i)\n\t\t\tfree_page((unsigned long)pool_entry->elements[i]);\n\t\tlist_del(&pool_entry->init_list);\n\t\tkfree(pool_entry);\n\t}\n}\n\nstatic void qeth_free_qdio_buffers(struct qeth_card *card)\n{\n\tint i, j;\n\n\tif (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==\n\t\tQETH_QDIO_UNINITIALIZED)\n\t\treturn;\n\n\tqeth_free_cq(card);\n\tcancel_delayed_work_sync(&card->buffer_reclaim_work);\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (card->qdio.in_q->bufs[j].rx_skb)\n\t\t\tdev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);\n\t}\n\tkfree(card->qdio.in_q);\n\tcard->qdio.in_q = NULL;\n\t/* inbound buffer pool */\n\tqeth_free_buffer_pool(card);\n\t/* free outbound qdio_qs */\n\tif (card->qdio.out_qs) {\n\t\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\n\t\t\tkfree(card->qdio.out_qs[i]);\n\t\t}\n\t\tkfree(card->qdio.out_qs);\n\t\tcard->qdio.out_qs = NULL;\n\t}\n}\n\nstatic void qeth_clean_channel(struct qeth_channel *channel)\n{\n\tint cnt;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"freech\");\n\tfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++)\n\t\tkfree(channel->iob[cnt].data);\n}\n\nstatic void qeth_set_single_write_queues(struct qeth_card *card)\n{\n\tif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\n\t    (card->qdio.no_out_queues == 4))\n\t\tqeth_free_qdio_buffers(card);\n\n\tcard->qdio.no_out_queues = 1;\n\tif (card->qdio.default_out_queue != 0)\n\t\tdev_info(&card->gdev->dev, \"Priority Queueing not supported\\n\");\n\n\tcard->qdio.default_out_queue = 0;\n}\n\nstatic void qeth_set_multiple_write_queues(struct qeth_card *card)\n{\n\tif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\n\t    (card->qdio.no_out_queues == 1)) {\n\t\tqeth_free_qdio_buffers(card);\n\t\tcard->qdio.default_out_queue = 2;\n\t}\n\tcard->qdio.no_out_queues = 4;\n}\n\nstatic void qeth_update_from_chp_desc(struct qeth_card *card)\n{\n\tstruct ccw_device *ccwdev;\n\tstruct channelPath_dsc {\n\t\tu8 flags;\n\t\tu8 lsn;\n\t\tu8 desc;\n\t\tu8 chpid;\n\t\tu8 swla;\n\t\tu8 zeroes;\n\t\tu8 chla;\n\t\tu8 chpp;\n\t} *chp_dsc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"chp_desc\");\n\n\tccwdev = card->data.ccwdev;\n\tchp_dsc = ccw_device_get_chp_desc(ccwdev, 0);\n\tif (!chp_dsc)\n\t\tgoto out;\n\n\tcard->info.func_level = 0x4100 + chp_dsc->desc;\n\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\tgoto out;\n\n\t/* CHPP field bit 6 == 1 -> single queue */\n\tif ((chp_dsc->chpp & 0x02) == 0x02)\n\t\tqeth_set_single_write_queues(card);\n\telse\n\t\tqeth_set_multiple_write_queues(card);\nout:\n\tkfree(chp_dsc);\n\tQETH_DBF_TEXT_(SETUP, 2, \"nr:%x\", card->qdio.no_out_queues);\n\tQETH_DBF_TEXT_(SETUP, 2, \"lvl:%02x\", card->info.func_level);\n}\n\nstatic void qeth_init_qdio_info(struct qeth_card *card)\n{\n\tQETH_DBF_TEXT(SETUP, 4, \"intqdinf\");\n\tatomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\n\t/* inbound */\n\tcard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\n\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\tcard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_HSDEFAULT;\n\telse\n\t\tcard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_DEFAULT;\n\tcard->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;\n\tINIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);\n\tINIT_LIST_HEAD(&card->qdio.init_pool.entry_list);\n}\n\nstatic void qeth_set_intial_options(struct qeth_card *card)\n{\n\tcard->options.route4.type = NO_ROUTER;\n\tcard->options.route6.type = NO_ROUTER;\n\tcard->options.fake_broadcast = 0;\n\tcard->options.add_hhlen = DEFAULT_ADD_HHLEN;\n\tcard->options.performance_stats = 0;\n\tcard->options.rx_sg_cb = QETH_RX_SG_CB;\n\tcard->options.isolation = ISOLATION_MODE_NONE;\n\tcard->options.cq = QETH_CQ_DISABLED;\n}\n\nstatic int qeth_do_start_thread(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tQETH_CARD_TEXT_(card, 4, \"  %02x%02x%02x\",\n\t\t\t(u8) card->thread_start_mask,\n\t\t\t(u8) card->thread_allowed_mask,\n\t\t\t(u8) card->thread_running_mask);\n\trc = (card->thread_start_mask & thread);\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\n\nstatic void qeth_start_kernel_thread(struct work_struct *work)\n{\n\tstruct task_struct *ts;\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\t\t\t\tkernel_thread_starter);\n\tQETH_CARD_TEXT(card , 2, \"strthrd\");\n\n\tif (card->read.state != CH_STATE_UP &&\n\t    card->write.state != CH_STATE_UP)\n\t\treturn;\n\tif (qeth_do_start_thread(card, QETH_RECOVER_THREAD)) {\n\t\tts = kthread_run(card->discipline->recover, (void *)card,\n\t\t\t\t\"qeth_recover\");\n\t\tif (IS_ERR(ts)) {\n\t\t\tqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\n\t\t\tqeth_clear_thread_running_bit(card,\n\t\t\t\tQETH_RECOVER_THREAD);\n\t\t}\n\t}\n}\n\nstatic int qeth_setup_card(struct qeth_card *card)\n{\n\n\tQETH_DBF_TEXT(SETUP, 2, \"setupcrd\");\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\n\tcard->read.state  = CH_STATE_DOWN;\n\tcard->write.state = CH_STATE_DOWN;\n\tcard->data.state  = CH_STATE_DOWN;\n\tcard->state = CARD_STATE_DOWN;\n\tcard->lan_online = 0;\n\tcard->read_or_write_problem = 0;\n\tcard->dev = NULL;\n\tspin_lock_init(&card->vlanlock);\n\tspin_lock_init(&card->mclock);\n\tspin_lock_init(&card->lock);\n\tspin_lock_init(&card->ip_lock);\n\tspin_lock_init(&card->thread_mask_lock);\n\tmutex_init(&card->conf_mutex);\n\tmutex_init(&card->discipline_mutex);\n\tcard->thread_start_mask = 0;\n\tcard->thread_allowed_mask = 0;\n\tcard->thread_running_mask = 0;\n\tINIT_WORK(&card->kernel_thread_starter, qeth_start_kernel_thread);\n\tINIT_LIST_HEAD(&card->ip_list);\n\tINIT_LIST_HEAD(card->ip_tbd_list);\n\tINIT_LIST_HEAD(&card->cmd_waiter_list);\n\tinit_waitqueue_head(&card->wait_q);\n\t/* initial options */\n\tqeth_set_intial_options(card);\n\t/* IP address takeover */\n\tINIT_LIST_HEAD(&card->ipato.entries);\n\tcard->ipato.enabled = 0;\n\tcard->ipato.invert4 = 0;\n\tcard->ipato.invert6 = 0;\n\t/* init QDIO stuff */\n\tqeth_init_qdio_info(card);\n\tINIT_DELAYED_WORK(&card->buffer_reclaim_work, qeth_buffer_reclaim_work);\n\tINIT_WORK(&card->close_dev_work, qeth_close_dev_handler);\n\treturn 0;\n}\n\nstatic void qeth_core_sl_print(struct seq_file *m, struct service_level *slr)\n{\n\tstruct qeth_card *card = container_of(slr, struct qeth_card,\n\t\t\t\t\tqeth_service_level);\n\tif (card->info.mcl_level[0])\n\t\tseq_printf(m, \"qeth: %s firmware level %s\\n\",\n\t\t\tCARD_BUS_ID(card), card->info.mcl_level);\n}\n\nstatic struct qeth_card *qeth_alloc_card(void)\n{\n\tstruct qeth_card *card;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"alloccrd\");\n\tcard = kzalloc(sizeof(struct qeth_card), GFP_DMA|GFP_KERNEL);\n\tif (!card)\n\t\tgoto out;\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\tcard->ip_tbd_list = kzalloc(sizeof(struct list_head), GFP_KERNEL);\n\tif (!card->ip_tbd_list) {\n\t\tQETH_DBF_TEXT(SETUP, 0, \"iptbdnom\");\n\t\tgoto out_card;\n\t}\n\tif (qeth_setup_channel(&card->read))\n\t\tgoto out_ip;\n\tif (qeth_setup_channel(&card->write))\n\t\tgoto out_channel;\n\tcard->options.layer2 = -1;\n\tcard->qeth_service_level.seq_print = qeth_core_sl_print;\n\tregister_service_level(&card->qeth_service_level);\n\treturn card;\n\nout_channel:\n\tqeth_clean_channel(&card->read);\nout_ip:\n\tkfree(card->ip_tbd_list);\nout_card:\n\tkfree(card);\nout:\n\treturn NULL;\n}\n\nstatic int qeth_determine_card_type(struct qeth_card *card)\n{\n\tint i = 0;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"detcdtyp\");\n\n\tcard->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;\n\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\twhile (known_devices[i][QETH_DEV_MODEL_IND]) {\n\t\tif ((CARD_RDEV(card)->id.dev_type ==\n\t\t\t\tknown_devices[i][QETH_DEV_TYPE_IND]) &&\n\t\t    (CARD_RDEV(card)->id.dev_model ==\n\t\t\t\tknown_devices[i][QETH_DEV_MODEL_IND])) {\n\t\t\tcard->info.type = known_devices[i][QETH_DEV_MODEL_IND];\n\t\t\tcard->qdio.no_out_queues =\n\t\t\t\tknown_devices[i][QETH_QUEUE_NO_IND];\n\t\t\tcard->qdio.no_in_queues = 1;\n\t\t\tcard->info.is_multicast_different =\n\t\t\t\tknown_devices[i][QETH_MULTICAST_IND];\n\t\t\tqeth_update_from_chp_desc(card);\n\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t}\n\tcard->info.type = QETH_CARD_TYPE_UNKNOWN;\n\tdev_err(&card->gdev->dev, \"The adapter hardware is of an \"\n\t\t\"unknown type\\n\");\n\treturn -ENOENT;\n}\n\nstatic int qeth_clear_channel(struct qeth_channel *channel)\n{\n\tunsigned long flags;\n\tstruct qeth_card *card;\n\tint rc;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 3, \"clearch\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_clear(channel->ccwdev, QETH_CLEAR_CHANNEL_PARM);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc)\n\t\treturn rc;\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_STOPPED, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_STOPPED)\n\t\treturn -ETIME;\n\tchannel->state = CH_STATE_DOWN;\n\treturn 0;\n}\n\nstatic int qeth_halt_channel(struct qeth_channel *channel)\n{\n\tunsigned long flags;\n\tstruct qeth_card *card;\n\tint rc;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tQETH_CARD_TEXT(card, 3, \"haltch\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_halt(channel->ccwdev, QETH_HALT_CHANNEL_PARM);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc)\n\t\treturn rc;\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_HALTED, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_HALTED)\n\t\treturn -ETIME;\n\treturn 0;\n}\n\nstatic int qeth_halt_channels(struct qeth_card *card)\n{\n\tint rc1 = 0, rc2 = 0, rc3 = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"haltchs\");\n\trc1 = qeth_halt_channel(&card->read);\n\trc2 = qeth_halt_channel(&card->write);\n\trc3 = qeth_halt_channel(&card->data);\n\tif (rc1)\n\t\treturn rc1;\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc3;\n}\n\nstatic int qeth_clear_channels(struct qeth_card *card)\n{\n\tint rc1 = 0, rc2 = 0, rc3 = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"clearchs\");\n\trc1 = qeth_clear_channel(&card->read);\n\trc2 = qeth_clear_channel(&card->write);\n\trc3 = qeth_clear_channel(&card->data);\n\tif (rc1)\n\t\treturn rc1;\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc3;\n}\n\nstatic int qeth_clear_halt_card(struct qeth_card *card, int halt)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"clhacrd\");\n\n\tif (halt)\n\t\trc = qeth_halt_channels(card);\n\tif (rc)\n\t\treturn rc;\n\treturn qeth_clear_channels(card);\n}\n\nint qeth_qdio_clear_card(struct qeth_card *card, int use_halt)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"qdioclr\");\n\tswitch (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ESTABLISHED,\n\t\tQETH_QDIO_CLEANING)) {\n\tcase QETH_QDIO_ESTABLISHED:\n\t\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\t\trc = qdio_shutdown(CARD_DDEV(card),\n\t\t\t\tQDIO_FLAG_CLEANUP_USING_HALT);\n\t\telse\n\t\t\trc = qdio_shutdown(CARD_DDEV(card),\n\t\t\t\tQDIO_FLAG_CLEANUP_USING_CLEAR);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 3, \"1err%d\", rc);\n\t\tqdio_free(CARD_DDEV(card));\n\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\tbreak;\n\tcase QETH_QDIO_CLEANING:\n\t\treturn rc;\n\tdefault:\n\t\tbreak;\n\t}\n\trc = qeth_clear_halt_card(card, use_halt);\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 3, \"2err%d\", rc);\n\tcard->state = CARD_STATE_DOWN;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_clear_card);\n\nstatic int qeth_read_conf_data(struct qeth_card *card, void **buffer,\n\t\t\t       int *length)\n{\n\tstruct ciw *ciw;\n\tchar *rcd_buf;\n\tint ret;\n\tstruct qeth_channel *channel = &card->data;\n\tunsigned long flags;\n\n\t/*\n\t * scan for RCD command in extended SenseID data\n\t */\n\tciw = ccw_device_get_ciw(channel->ccwdev, CIW_TYPE_RCD);\n\tif (!ciw || ciw->cmd == 0)\n\t\treturn -EOPNOTSUPP;\n\trcd_buf = kzalloc(ciw->count, GFP_KERNEL | GFP_DMA);\n\tif (!rcd_buf)\n\t\treturn -ENOMEM;\n\n\tchannel->ccw.cmd_code = ciw->cmd;\n\tchannel->ccw.cda = (__u32) __pa(rcd_buf);\n\tchannel->ccw.count = ciw->count;\n\tchannel->ccw.flags = CCW_FLAG_SLI;\n\tchannel->state = CH_STATE_RCD;\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\tret = ccw_device_start_timeout(channel->ccwdev, &channel->ccw,\n\t\t\t\t       QETH_RCD_PARM, LPM_ANYPATH, 0,\n\t\t\t\t       QETH_RCD_TIMEOUT);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\tif (!ret)\n\t\twait_event(card->wait_q,\n\t\t\t   (channel->state == CH_STATE_RCD_DONE ||\n\t\t\t    channel->state == CH_STATE_DOWN));\n\tif (channel->state == CH_STATE_DOWN)\n\t\tret = -EIO;\n\telse\n\t\tchannel->state = CH_STATE_DOWN;\n\tif (ret) {\n\t\tkfree(rcd_buf);\n\t\t*buffer = NULL;\n\t\t*length = 0;\n\t} else {\n\t\t*length = ciw->count;\n\t\t*buffer = rcd_buf;\n\t}\n\treturn ret;\n}\n\nstatic void qeth_configure_unitaddr(struct qeth_card *card, char *prcd)\n{\n\tQETH_DBF_TEXT(SETUP, 2, \"cfgunit\");\n\tcard->info.chpid = prcd[30];\n\tcard->info.unit_addr2 = prcd[31];\n\tcard->info.cula = prcd[63];\n\tcard->info.guestlan = ((prcd[0x10] == _ascebc['V']) &&\n\t\t\t       (prcd[0x11] == _ascebc['M']));\n}\n\nstatic void qeth_configure_blkt_default(struct qeth_card *card, char *prcd)\n{\n\tQETH_DBF_TEXT(SETUP, 2, \"cfgblkt\");\n\n\tif (prcd[74] == 0xF0 && prcd[75] == 0xF0 &&\n\t    prcd[76] >= 0xF1 && prcd[76] <= 0xF4) {\n\t\tcard->info.blkt.time_total = 0;\n\t\tcard->info.blkt.inter_packet = 0;\n\t\tcard->info.blkt.inter_packet_jumbo = 0;\n\t} else {\n\t\tcard->info.blkt.time_total = 250;\n\t\tcard->info.blkt.inter_packet = 5;\n\t\tcard->info.blkt.inter_packet_jumbo = 15;\n\t}\n}\n\nstatic void qeth_init_tokens(struct qeth_card *card)\n{\n\tcard->token.issuer_rm_w = 0x00010103UL;\n\tcard->token.cm_filter_w = 0x00010108UL;\n\tcard->token.cm_connection_w = 0x0001010aUL;\n\tcard->token.ulp_filter_w = 0x0001010bUL;\n\tcard->token.ulp_connection_w = 0x0001010dUL;\n}\n\nstatic void qeth_init_func_level(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_IQD:\n\t\tcard->info.func_level =\tQETH_IDX_FUNC_LEVEL_IQD;\n\t\tbreak;\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSN:\n\t\tcard->info.func_level = QETH_IDX_FUNC_LEVEL_OSD;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int qeth_idx_activate_get_answer(struct qeth_channel *channel,\n\t\tvoid (*idx_reply_cb)(struct qeth_channel *,\n\t\t\tstruct qeth_cmd_buffer *))\n{\n\tstruct qeth_cmd_buffer *iob;\n\tunsigned long flags;\n\tint rc;\n\tstruct qeth_card *card;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"idxanswr\");\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tiob = qeth_get_buffer(channel);\n\tiob->callback = idx_reply_cb;\n\tmemcpy(&channel->ccw, READ_CCW, sizeof(struct ccw1));\n\tchannel->ccw.count = QETH_BUFSIZE;\n\tchannel->ccw.cda = (__u32) __pa(iob->data);\n\n\twait_event(card->wait_q,\n\t\t   atomic_cmpxchg(&channel->irq_pending, 0, 1) == 0);\n\tQETH_DBF_TEXT(SETUP, 6, \"noirqpnd\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_start(channel->ccwdev,\n\t\t\t      &channel->ccw, (addr_t) iob, 0, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"Error2 in activating channel rc=%d\\n\", rc);\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", rc);\n\t\tatomic_set(&channel->irq_pending, 0);\n\t\twake_up(&card->wait_q);\n\t\treturn rc;\n\t}\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\t channel->state == CH_STATE_UP, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_UP) {\n\t\trc = -ETIME;\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tqeth_clear_cmd_buffers(channel);\n\t} else\n\t\trc = 0;\n\treturn rc;\n}\n\nstatic int qeth_idx_activate_channel(struct qeth_channel *channel,\n\t\tvoid (*idx_reply_cb)(struct qeth_channel *,\n\t\t\tstruct qeth_cmd_buffer *))\n{\n\tstruct qeth_card *card;\n\tstruct qeth_cmd_buffer *iob;\n\tunsigned long flags;\n\t__u16 temp;\n\t__u8 tmp;\n\tint rc;\n\tstruct ccw_dev_id temp_devid;\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\n\tQETH_DBF_TEXT(SETUP, 2, \"idxactch\");\n\n\tiob = qeth_get_buffer(channel);\n\tiob->callback = idx_reply_cb;\n\tmemcpy(&channel->ccw, WRITE_CCW, sizeof(struct ccw1));\n\tchannel->ccw.count = IDX_ACTIVATE_SIZE;\n\tchannel->ccw.cda = (__u32) __pa(iob->data);\n\tif (channel == &card->write) {\n\t\tmemcpy(iob->data, IDX_ACTIVATE_WRITE, IDX_ACTIVATE_SIZE);\n\t\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\n\t\t       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\n\t\tcard->seqno.trans_hdr++;\n\t} else {\n\t\tmemcpy(iob->data, IDX_ACTIVATE_READ, IDX_ACTIVATE_SIZE);\n\t\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\n\t\t       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\n\t}\n\ttmp = ((__u8)card->info.portno) | 0x80;\n\tmemcpy(QETH_IDX_ACT_PNO(iob->data), &tmp, 1);\n\tmemcpy(QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_IDX_ACT_FUNC_LEVEL(iob->data),\n\t       &card->info.func_level, sizeof(__u16));\n\tccw_device_get_id(CARD_DDEV(card), &temp_devid);\n\tmemcpy(QETH_IDX_ACT_QDIO_DEV_CUA(iob->data), &temp_devid.devno, 2);\n\ttemp = (card->info.cula << 8) + card->info.unit_addr2;\n\tmemcpy(QETH_IDX_ACT_QDIO_DEV_REALADDR(iob->data), &temp, 2);\n\n\twait_event(card->wait_q,\n\t\t   atomic_cmpxchg(&channel->irq_pending, 0, 1) == 0);\n\tQETH_DBF_TEXT(SETUP, 6, \"noirqpnd\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_start(channel->ccwdev,\n\t\t\t      &channel->ccw, (addr_t) iob, 0, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"Error1 in activating channel. rc=%d\\n\",\n\t\t\trc);\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\tatomic_set(&channel->irq_pending, 0);\n\t\twake_up(&card->wait_q);\n\t\treturn rc;\n\t}\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_ACTIVATING, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_ACTIVATING) {\n\t\tdev_warn(&channel->ccwdev->dev, \"The qeth device driver\"\n\t\t\t\" failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"%s IDX activate timed out\\n\",\n\t\t\tdev_name(&channel->ccwdev->dev));\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", -ETIME);\n\t\tqeth_clear_cmd_buffers(channel);\n\t\treturn -ETIME;\n\t}\n\treturn qeth_idx_activate_get_answer(channel, idx_reply_cb);\n}\n\nstatic int qeth_peer_func_level(int level)\n{\n\tif ((level & 0xff) == 8)\n\t\treturn (level & 0xff) + 0x400;\n\tif (((level >> 8) & 3) == 1)\n\t\treturn (level & 0xff) + 0x200;\n\treturn level;\n}\n\nstatic void qeth_idx_write_cb(struct qeth_channel *channel,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_card *card;\n\t__u16 temp;\n\n\tQETH_DBF_TEXT(SETUP , 2, \"idxwrcb\");\n\n\tif (channel->state == CH_STATE_DOWN) {\n\t\tchannel->state = CH_STATE_ACTIVATING;\n\t\tgoto out;\n\t}\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\n\tif (!(QETH_IS_IDX_ACT_POS_REPLY(iob->data))) {\n\t\tif (QETH_IDX_ACT_CAUSE_CODE(iob->data) == QETH_IDX_ACT_ERR_EXCL)\n\t\t\tdev_err(&card->write.ccwdev->dev,\n\t\t\t\t\"The adapter is used exclusively by another \"\n\t\t\t\t\"host\\n\");\n\t\telse\n\t\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on write channel:\"\n\t\t\t\t\" negative reply\\n\",\n\t\t\t\tdev_name(&card->write.ccwdev->dev));\n\t\tgoto out;\n\t}\n\tmemcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\n\tif ((temp & ~0x0100) != qeth_peer_func_level(card->info.func_level)) {\n\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on write channel: \"\n\t\t\t\"function level mismatch (sent: 0x%x, received: \"\n\t\t\t\"0x%x)\\n\", dev_name(&card->write.ccwdev->dev),\n\t\t\tcard->info.func_level, temp);\n\t\tgoto out;\n\t}\n\tchannel->state = CH_STATE_UP;\nout:\n\tqeth_release_buffer(channel, iob);\n}\n\nstatic void qeth_idx_read_cb(struct qeth_channel *channel,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tstruct qeth_card *card;\n\t__u16 temp;\n\n\tQETH_DBF_TEXT(SETUP , 2, \"idxrdcb\");\n\tif (channel->state == CH_STATE_DOWN) {\n\t\tchannel->state = CH_STATE_ACTIVATING;\n\t\tgoto out;\n\t}\n\n\tcard = CARD_FROM_CDEV(channel->ccwdev);\n\tif (qeth_check_idx_response(card, iob->data))\n\t\t\tgoto out;\n\n\tif (!(QETH_IS_IDX_ACT_POS_REPLY(iob->data))) {\n\t\tswitch (QETH_IDX_ACT_CAUSE_CODE(iob->data)) {\n\t\tcase QETH_IDX_ACT_ERR_EXCL:\n\t\t\tdev_err(&card->write.ccwdev->dev,\n\t\t\t\t\"The adapter is used exclusively by another \"\n\t\t\t\t\"host\\n\");\n\t\t\tbreak;\n\t\tcase QETH_IDX_ACT_ERR_AUTH:\n\t\tcase QETH_IDX_ACT_ERR_AUTH_USER:\n\t\t\tdev_err(&card->read.ccwdev->dev,\n\t\t\t\t\"Setting the device online failed because of \"\n\t\t\t\t\"insufficient authorization\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on read channel:\"\n\t\t\t\t\" negative reply\\n\",\n\t\t\t\tdev_name(&card->read.ccwdev->dev));\n\t\t}\n\t\tQETH_CARD_TEXT_(card, 2, \"idxread%c\",\n\t\t\tQETH_IDX_ACT_CAUSE_CODE(iob->data));\n\t\tgoto out;\n\t}\n\n/**\n *  * temporary fix for microcode bug\n *   * to revert it,replace OR by AND\n *    */\n\tif ((!QETH_IDX_NO_PORTNAME_REQUIRED(iob->data)) ||\n\t     (card->info.type == QETH_CARD_TYPE_OSD))\n\t\tcard->info.portname_required = 1;\n\n\tmemcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\n\tif (temp != qeth_peer_func_level(card->info.func_level)) {\n\t\tQETH_DBF_MESSAGE(2, \"%s IDX_ACTIVATE on read channel: function \"\n\t\t\t\"level mismatch (sent: 0x%x, received: 0x%x)\\n\",\n\t\t\tdev_name(&card->read.ccwdev->dev),\n\t\t\tcard->info.func_level, temp);\n\t\tgoto out;\n\t}\n\tmemcpy(&card->token.issuer_rm_r,\n\t       QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(&card->info.mcl_level[0],\n\t       QETH_IDX_REPLY_LEVEL(iob->data), QETH_MCL_LENGTH);\n\tchannel->state = CH_STATE_UP;\nout:\n\tqeth_release_buffer(channel, iob);\n}\n\nvoid qeth_prepare_control_data(struct qeth_card *card, int len,\n\t\tstruct qeth_cmd_buffer *iob)\n{\n\tqeth_setup_ccw(&card->write, iob->data, len);\n\tiob->callback = qeth_release_buffer;\n\n\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\n\t       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\n\tcard->seqno.trans_hdr++;\n\tmemcpy(QETH_PDU_HEADER_SEQ_NO(iob->data),\n\t       &card->seqno.pdu_hdr, QETH_SEQ_NO_LENGTH);\n\tcard->seqno.pdu_hdr++;\n\tmemcpy(QETH_PDU_HEADER_ACK_SEQ_NO(iob->data),\n\t       &card->seqno.pdu_hdr_ack, QETH_SEQ_NO_LENGTH);\n\tQETH_DBF_HEX(CTRL, 2, iob->data, QETH_DBF_CTRL_LEN);\n}\nEXPORT_SYMBOL_GPL(qeth_prepare_control_data);\n\nint qeth_send_control_data(struct qeth_card *card, int len,\n\t\tstruct qeth_cmd_buffer *iob,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct qeth_reply *reply = NULL;\n\tunsigned long timeout, event_timeout;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 2, \"sendctl\");\n\n\tif (card->read_or_write_problem) {\n\t\tqeth_release_buffer(iob->channel, iob);\n\t\treturn -EIO;\n\t}\n\treply = qeth_alloc_reply(card);\n\tif (!reply) {\n\t\treturn -ENOMEM;\n\t}\n\treply->callback = reply_cb;\n\treply->param = reply_param;\n\tif (card->state == CARD_STATE_DOWN)\n\t\treply->seqno = QETH_IDX_COMMAND_SEQNO;\n\telse\n\t\treply->seqno = card->seqno.ipa++;\n\tinit_waitqueue_head(&reply->wait_q);\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_add_tail(&reply->list, &card->cmd_waiter_list);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tQETH_DBF_HEX(CTRL, 2, iob->data, QETH_DBF_CTRL_LEN);\n\n\twhile (atomic_cmpxchg(&card->write.irq_pending, 0, 1)) ;\n\tqeth_prepare_control_data(card, len, iob);\n\n\tif (IS_IPA(iob->data))\n\t\tevent_timeout = QETH_IPA_TIMEOUT;\n\telse\n\t\tevent_timeout = QETH_TIMEOUT;\n\ttimeout = jiffies + event_timeout;\n\n\tQETH_CARD_TEXT(card, 6, \"noirqpnd\");\n\tspin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);\n\trc = ccw_device_start(card->write.ccwdev, &card->write.ccw,\n\t\t\t      (addr_t) iob, 0, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"%s qeth_send_control_data: \"\n\t\t\t\"ccw_device_start rc = %i\\n\",\n\t\t\tdev_name(&card->write.ccwdev->dev), rc);\n\t\tQETH_CARD_TEXT_(card, 2, \" err%d\", rc);\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tlist_del_init(&reply->list);\n\t\tqeth_put_reply(reply);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tqeth_release_buffer(iob->channel, iob);\n\t\tatomic_set(&card->write.irq_pending, 0);\n\t\twake_up(&card->wait_q);\n\t\treturn rc;\n\t}\n\n\t/* we have only one long running ipassist, since we can ensure\n\t   process context of this command we can sleep */\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tif ((cmd->hdr.command == IPA_CMD_SETIP) &&\n\t    (cmd->hdr.prot_version == QETH_PROT_IPV4)) {\n\t\tif (!wait_event_timeout(reply->wait_q,\n\t\t    atomic_read(&reply->received), event_timeout))\n\t\t\tgoto time_err;\n\t} else {\n\t\twhile (!atomic_read(&reply->received)) {\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\tgoto time_err;\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\n\tif (reply->rc == -EIO)\n\t\tgoto error;\n\trc = reply->rc;\n\tqeth_put_reply(reply);\n\treturn rc;\n\ntime_err:\n\treply->rc = -ETIME;\n\tspin_lock_irqsave(&reply->card->lock, flags);\n\tlist_del_init(&reply->list);\n\tspin_unlock_irqrestore(&reply->card->lock, flags);\n\tatomic_inc(&reply->received);\nerror:\n\tatomic_set(&card->write.irq_pending, 0);\n\tqeth_release_buffer(iob->channel, iob);\n\tcard->write.buf_no = (card->write.buf_no + 1) % QETH_CMD_BUFFER_NO;\n\trc = reply->rc;\n\tqeth_put_reply(reply);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_control_data);\n\nstatic int qeth_cm_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmenblcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_filter_r,\n\t       QETH_CM_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_cm_enable(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmenable\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, CM_ENABLE, CM_ENABLE_SIZE);\n\tmemcpy(QETH_CM_ENABLE_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);\n\n\trc = qeth_send_control_data(card, CM_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_cm_enable_cb, NULL);\n\treturn rc;\n}\n\nstatic int qeth_cm_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmsetpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_connection_r,\n\t       QETH_CM_SETUP_RESP_DEST_ADDR(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_cm_setup(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmsetup\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, CM_SETUP, CM_SETUP_SIZE);\n\tmemcpy(QETH_CM_SETUP_DEST_ADDR(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_SETUP_CONNECTION_TOKEN(iob->data),\n\t       &card->token.cm_connection_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_SETUP_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_r, QETH_MPC_TOKEN_LENGTH);\n\trc = qeth_send_control_data(card, CM_SETUP_SIZE, iob,\n\t\t\t\t    qeth_cm_setup_cb, NULL);\n\treturn rc;\n\n}\n\nstatic inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\t\treturn 1500;\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn card->info.max_mtu;\n\tcase QETH_CARD_TYPE_OSD:\n\t\tswitch (card->info.link_type) {\n\t\tcase QETH_LINK_TYPE_HSTR:\n\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\treturn 2000;\n\t\tdefault:\n\t\t\treturn card->options.layer2 ? 1500 : 1492;\n\t\t}\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\treturn card->options.layer2 ? 1500 : 1492;\n\tdefault:\n\t\treturn 1500;\n\t}\n}\n\nstatic inline int qeth_get_mtu_outof_framesize(int framesize)\n{\n\tswitch (framesize) {\n\tcase 0x4000:\n\t\treturn 8192;\n\tcase 0x6000:\n\t\treturn 16384;\n\tcase 0xa000:\n\t\treturn 32768;\n\tcase 0xffff:\n\t\treturn 57344;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int qeth_mtu_is_valid(struct qeth_card *card, int mtu)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn ((mtu >= 576) &&\n\t\t\t(mtu <= card->info.max_mtu));\n\tcase QETH_CARD_TYPE_OSN:\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int qeth_ulp_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\n\t__u16 mtu, framesize;\n\t__u16 len;\n\t__u8 link_type;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpenacb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_filter_r,\n\t       QETH_ULP_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (card->info.type == QETH_CARD_TYPE_IQD) {\n\t\tmemcpy(&framesize, QETH_ULP_ENABLE_RESP_MAX_MTU(iob->data), 2);\n\t\tmtu = qeth_get_mtu_outof_framesize(framesize);\n\t\tif (!mtu) {\n\t\t\tiob->rc = -EINVAL;\n\t\t\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\t\t\treturn 0;\n\t\t}\n\t\tif (card->info.initial_mtu && (card->info.initial_mtu != mtu)) {\n\t\t\t/* frame size has changed */\n\t\t\tif (card->dev &&\n\t\t\t    ((card->dev->mtu == card->info.initial_mtu) ||\n\t\t\t     (card->dev->mtu > mtu)))\n\t\t\t\tcard->dev->mtu = mtu;\n\t\t\tqeth_free_qdio_buffers(card);\n\t\t}\n\t\tcard->info.initial_mtu = mtu;\n\t\tcard->info.max_mtu = mtu;\n\t\tcard->qdio.in_buf_size = mtu + 2 * PAGE_SIZE;\n\t} else {\n\t\tcard->info.max_mtu = *(__u16 *)QETH_ULP_ENABLE_RESP_MAX_MTU(\n\t\t\tiob->data);\n\t\tcard->info.initial_mtu = min(card->info.max_mtu,\n\t\t\t\t\tqeth_get_initial_mtu_for_card(card));\n\t\tcard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\n\t}\n\n\tmemcpy(&len, QETH_ULP_ENABLE_RESP_DIFINFO_LEN(iob->data), 2);\n\tif (len >= QETH_MPC_DIFINFO_LEN_INDICATES_LINK_TYPE) {\n\t\tmemcpy(&link_type,\n\t\t       QETH_ULP_ENABLE_RESP_LINK_TYPE(iob->data), 1);\n\t\tcard->info.link_type = link_type;\n\t} else\n\t\tcard->info.link_type = 0;\n\tQETH_DBF_TEXT_(SETUP, 2, \"link%d\", card->info.link_type);\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_ulp_enable(struct qeth_card *card)\n{\n\tint rc;\n\tchar prot_type;\n\tstruct qeth_cmd_buffer *iob;\n\n\t/*FIXME: trace view callbacks*/\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpenabl\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, ULP_ENABLE, ULP_ENABLE_SIZE);\n\n\t*(QETH_ULP_ENABLE_LINKNUM(iob->data)) =\n\t\t(__u8) card->info.portno;\n\tif (card->options.layer2)\n\t\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\t\tprot_type = QETH_PROT_OSN2;\n\t\telse\n\t\t\tprot_type = QETH_PROT_LAYER2;\n\telse\n\t\tprot_type = QETH_PROT_TCPIP;\n\n\tmemcpy(QETH_ULP_ENABLE_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_ULP_ENABLE_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_PORTNAME_AND_LL(iob->data),\n\t       card->info.portname, 9);\n\trc = qeth_send_control_data(card, ULP_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_ulp_enable_cb, NULL);\n\treturn rc;\n\n}\n\nstatic int qeth_ulp_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpstpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_connection_r,\n\t       QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (!strncmp(\"00S\", QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t\t     3)) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"olmlimit\");\n\t\tdev_err(&card->gdev->dev, \"A connection could not be \"\n\t\t\t\"established because of an OLM limit\\n\");\n\t\tiob->rc = -EMLINK;\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n\nstatic int qeth_ulp_setup(struct qeth_card *card)\n{\n\tint rc;\n\t__u16 temp;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct ccw_dev_id dev_id;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpsetup\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, ULP_SETUP, ULP_SETUP_SIZE);\n\n\tmemcpy(QETH_ULP_SETUP_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_SETUP_CONNECTION_TOKEN(iob->data),\n\t       &card->token.ulp_connection_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_SETUP_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_r, QETH_MPC_TOKEN_LENGTH);\n\n\tccw_device_get_id(CARD_DDEV(card), &dev_id);\n\tmemcpy(QETH_ULP_SETUP_CUA(iob->data), &dev_id.devno, 2);\n\ttemp = (card->info.cula << 8) + card->info.unit_addr2;\n\tmemcpy(QETH_ULP_SETUP_REAL_DEVADDR(iob->data), &temp, 2);\n\trc = qeth_send_control_data(card, ULP_SETUP_SIZE, iob,\n\t\t\t\t    qeth_ulp_setup_cb, NULL);\n\treturn rc;\n}\n\nstatic int qeth_init_qdio_out_buf(struct qeth_qdio_out_q *q, int bidx)\n{\n\tint rc;\n\tstruct qeth_qdio_out_buffer *newbuf;\n\n\trc = 0;\n\tnewbuf = kmem_cache_zalloc(qeth_qdio_outbuf_cache, GFP_ATOMIC);\n\tif (!newbuf) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewbuf->buffer = &q->qdio_bufs[bidx];\n\tskb_queue_head_init(&newbuf->skb_list);\n\tlockdep_set_class(&newbuf->skb_list.lock, &qdio_out_skb_queue_key);\n\tnewbuf->q = q;\n\tnewbuf->aob = NULL;\n\tnewbuf->next_pending = q->bufs[bidx];\n\tatomic_set(&newbuf->state, QETH_QDIO_BUF_EMPTY);\n\tq->bufs[bidx] = newbuf;\n\tif (q->bufstates) {\n\t\tq->bufstates[bidx].user = newbuf;\n\t\tQETH_CARD_TEXT_(q->card, 2, \"nbs%d\", bidx);\n\t\tQETH_CARD_TEXT_(q->card, 2, \"%lx\", (long) newbuf);\n\t\tQETH_CARD_TEXT_(q->card, 2, \"%lx\",\n\t\t\t\t(long) newbuf->next_pending);\n\t}\nout:\n\treturn rc;\n}\n\n\nstatic int qeth_alloc_qdio_buffers(struct qeth_card *card)\n{\n\tint i, j;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"allcqdbf\");\n\n\tif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED,\n\t\tQETH_QDIO_ALLOCATED) != QETH_QDIO_UNINITIALIZED)\n\t\treturn 0;\n\n\tcard->qdio.in_q = kzalloc(sizeof(struct qeth_qdio_q),\n\t\t\t\t   GFP_KERNEL);\n\tif (!card->qdio.in_q)\n\t\tgoto out_nomem;\n\tQETH_DBF_TEXT(SETUP, 2, \"inq\");\n\tQETH_DBF_HEX(SETUP, 2, &card->qdio.in_q, sizeof(void *));\n\tmemset(card->qdio.in_q, 0, sizeof(struct qeth_qdio_q));\n\t/* give inbound qeth_qdio_buffers their qdio_buffers */\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\tcard->qdio.in_q->bufs[i].buffer =\n\t\t\t&card->qdio.in_q->qdio_bufs[i];\n\t\tcard->qdio.in_q->bufs[i].rx_skb = NULL;\n\t}\n\t/* inbound buffer pool */\n\tif (qeth_alloc_buffer_pool(card))\n\t\tgoto out_freeinq;\n\n\t/* outbound */\n\tcard->qdio.out_qs =\n\t\tkzalloc(card->qdio.no_out_queues *\n\t\t\tsizeof(struct qeth_qdio_out_q *), GFP_KERNEL);\n\tif (!card->qdio.out_qs)\n\t\tgoto out_freepool;\n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tcard->qdio.out_qs[i] = kzalloc(sizeof(struct qeth_qdio_out_q),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!card->qdio.out_qs[i])\n\t\t\tgoto out_freeoutq;\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"outq %i\", i);\n\t\tQETH_DBF_HEX(SETUP, 2, &card->qdio.out_qs[i], sizeof(void *));\n\t\tcard->qdio.out_qs[i]->queue_no = i;\n\t\t/* give outbound qeth_qdio_buffers their qdio_buffers */\n\t\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\t\tWARN_ON(card->qdio.out_qs[i]->bufs[j] != NULL);\n\t\t\tif (qeth_init_qdio_out_buf(card->qdio.out_qs[i], j))\n\t\t\t\tgoto out_freeoutqbufs;\n\t\t}\n\t}\n\n\t/* completion */\n\tif (qeth_alloc_cq(card))\n\t\tgoto out_freeoutq;\n\n\treturn 0;\n\nout_freeoutqbufs:\n\twhile (j > 0) {\n\t\t--j;\n\t\tkmem_cache_free(qeth_qdio_outbuf_cache,\n\t\t\t\tcard->qdio.out_qs[i]->bufs[j]);\n\t\tcard->qdio.out_qs[i]->bufs[j] = NULL;\n\t}\nout_freeoutq:\n\twhile (i > 0) {\n\t\tkfree(card->qdio.out_qs[--i]);\n\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\n\t}\n\tkfree(card->qdio.out_qs);\n\tcard->qdio.out_qs = NULL;\nout_freepool:\n\tqeth_free_buffer_pool(card);\nout_freeinq:\n\tkfree(card->qdio.in_q);\n\tcard->qdio.in_q = NULL;\nout_nomem:\n\tatomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\n\treturn -ENOMEM;\n}\n\nstatic void qeth_create_qib_param_field(struct qeth_card *card,\n\t\tchar *param_field)\n{\n\n\tparam_field[0] = _ascebc['P'];\n\tparam_field[1] = _ascebc['C'];\n\tparam_field[2] = _ascebc['I'];\n\tparam_field[3] = _ascebc['T'];\n\t*((unsigned int *) (&param_field[4])) = QETH_PCI_THRESHOLD_A(card);\n\t*((unsigned int *) (&param_field[8])) = QETH_PCI_THRESHOLD_B(card);\n\t*((unsigned int *) (&param_field[12])) = QETH_PCI_TIMER_VALUE(card);\n}\n\nstatic void qeth_create_qib_param_field_blkt(struct qeth_card *card,\n\t\tchar *param_field)\n{\n\tparam_field[16] = _ascebc['B'];\n\tparam_field[17] = _ascebc['L'];\n\tparam_field[18] = _ascebc['K'];\n\tparam_field[19] = _ascebc['T'];\n\t*((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;\n\t*((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;\n\t*((unsigned int *) (&param_field[28])) =\n\t\tcard->info.blkt.inter_packet_jumbo;\n}\n\nstatic int qeth_qdio_activate(struct qeth_card *card)\n{\n\tQETH_DBF_TEXT(SETUP, 3, \"qdioact\");\n\treturn qdio_activate(CARD_DDEV(card));\n}\n\nstatic int qeth_dm_act(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"dmact\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, DM_ACT, DM_ACT_SIZE);\n\n\tmemcpy(QETH_DM_ACT_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_DM_ACT_CONNECTION_TOKEN(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n\trc = qeth_send_control_data(card, DM_ACT_SIZE, iob, NULL, NULL);\n\treturn rc;\n}\n\nstatic int qeth_mpc_initialize(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"mpcinit\");\n\n\trc = qeth_issue_next_read(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_cm_enable(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_cm_setup(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_ulp_enable(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"4err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_ulp_setup(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_alloc_qdio_buffers(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_qdio_establish(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"6err%d\", rc);\n\t\tqeth_free_qdio_buffers(card);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_qdio_activate(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"7err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\trc = qeth_dm_act(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"8err%d\", rc);\n\t\tgoto out_qdio;\n\t}\n\n\treturn 0;\nout_qdio:\n\tqeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);\n\treturn rc;\n}\n\nstatic void qeth_print_status_with_portname(struct qeth_card *card)\n{\n\tchar dbf_text[15];\n\tint i;\n\n\tsprintf(dbf_text, \"%s\", card->info.portname + 1);\n\tfor (i = 0; i < 8; i++)\n\t\tdbf_text[i] =\n\t\t\t(char) _ebcasc[(__u8) dbf_text[i]];\n\tdbf_text[8] = 0;\n\tdev_info(&card->gdev->dev, \"Device is a%s card%s%s%s\\n\"\n\t       \"with link type %s (portname: %s)\\n\",\n\t       qeth_get_cardname(card),\n\t       (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t       (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t       (card->info.mcl_level[0]) ? \")\" : \"\",\n\t       qeth_get_cardname_short(card),\n\t       dbf_text);\n\n}\n\nstatic void qeth_print_status_no_portname(struct qeth_card *card)\n{\n\tif (card->info.portname[0])\n\t\tdev_info(&card->gdev->dev, \"Device is a%s \"\n\t\t       \"card%s%s%s\\nwith link type %s \"\n\t\t       \"(no portname needed by interface).\\n\",\n\t\t       qeth_get_cardname(card),\n\t\t       (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t\t       (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t\t       (card->info.mcl_level[0]) ? \")\" : \"\",\n\t\t       qeth_get_cardname_short(card));\n\telse\n\t\tdev_info(&card->gdev->dev, \"Device is a%s \"\n\t\t       \"card%s%s%s\\nwith link type %s.\\n\",\n\t\t       qeth_get_cardname(card),\n\t\t       (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t\t       (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t\t       (card->info.mcl_level[0]) ? \")\" : \"\",\n\t\t       qeth_get_cardname_short(card));\n}\n\nvoid qeth_print_status_message(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\t/* VM will use a non-zero first character\n\t\t * to indicate a HiperSockets like reporting\n\t\t * of the level OSA sets the first character to zero\n\t\t * */\n\t\tif (!card->info.mcl_level[0]) {\n\t\t\tsprintf(card->info.mcl_level, \"%02x%02x\",\n\t\t\t\tcard->info.mcl_level[2],\n\t\t\t\tcard->info.mcl_level[3]);\n\n\t\t\tcard->info.mcl_level[QETH_MCL_LENGTH] = 0;\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tcase QETH_CARD_TYPE_IQD:\n\t\tif ((card->info.guestlan) ||\n\t\t    (card->info.mcl_level[0] & 0x80)) {\n\t\t\tcard->info.mcl_level[0] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[0]];\n\t\t\tcard->info.mcl_level[1] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[1]];\n\t\t\tcard->info.mcl_level[2] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[2]];\n\t\t\tcard->info.mcl_level[3] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[3]];\n\t\t\tcard->info.mcl_level[QETH_MCL_LENGTH] = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmemset(&card->info.mcl_level[0], 0, QETH_MCL_LENGTH + 1);\n\t}\n\tif (card->info.portname_required)\n\t\tqeth_print_status_with_portname(card);\n\telse\n\t\tqeth_print_status_no_portname(card);\n}\nEXPORT_SYMBOL_GPL(qeth_print_status_message);\n\nstatic void qeth_initialize_working_pool_list(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *entry;\n\n\tQETH_CARD_TEXT(card, 5, \"inwrklst\");\n\n\tlist_for_each_entry(entry,\n\t\t\t    &card->qdio.init_pool.entry_list, init_list) {\n\t\tqeth_put_buffer_pool_entry(card, entry);\n\t}\n}\n\nstatic inline struct qeth_buffer_pool_entry *qeth_find_free_buffer_pool_entry(\n\t\tstruct qeth_card *card)\n{\n\tstruct list_head *plh;\n\tstruct qeth_buffer_pool_entry *entry;\n\tint i, free;\n\tstruct page *page;\n\n\tif (list_empty(&card->qdio.in_buf_pool.entry_list))\n\t\treturn NULL;\n\n\tlist_for_each(plh, &card->qdio.in_buf_pool.entry_list) {\n\t\tentry = list_entry(plh, struct qeth_buffer_pool_entry, list);\n\t\tfree = 1;\n\t\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\t\tif (page_count(virt_to_page(entry->elements[i])) > 1) {\n\t\t\t\tfree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (free) {\n\t\t\tlist_del_init(&entry->list);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\t/* no free buffer in pool so take first one and swap pages */\n\tentry = list_entry(card->qdio.in_buf_pool.entry_list.next,\n\t\t\tstruct qeth_buffer_pool_entry, list);\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\tif (page_count(virt_to_page(entry->elements[i])) > 1) {\n\t\t\tpage = alloc_page(GFP_ATOMIC);\n\t\t\tif (!page) {\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tfree_page((unsigned long)entry->elements[i]);\n\t\t\t\tentry->elements[i] = page_address(page);\n\t\t\t\tif (card->options.performance_stats)\n\t\t\t\t\tcard->perf_stats.sg_alloc_page_rx++;\n\t\t\t}\n\t\t}\n\t}\n\tlist_del_init(&entry->list);\n\treturn entry;\n}\n\nstatic int qeth_init_input_buffer(struct qeth_card *card,\n\t\tstruct qeth_qdio_buffer *buf)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry;\n\tint i;\n\n\tif ((card->options.cq == QETH_CQ_ENABLED) && (!buf->rx_skb)) {\n\t\tbuf->rx_skb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\n\t\tif (!buf->rx_skb)\n\t\t\treturn 1;\n\t}\n\n\tpool_entry = qeth_find_free_buffer_pool_entry(card);\n\tif (!pool_entry)\n\t\treturn 1;\n\n\t/*\n\t * since the buffer is accessed only from the input_tasklet\n\t * there shouldn't be a need to synchronize; also, since we use\n\t * the QETH_IN_BUF_REQUEUE_THRESHOLD we should never run  out off\n\t * buffers\n\t */\n\n\tbuf->pool_entry = pool_entry;\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\tbuf->buffer->element[i].length = PAGE_SIZE;\n\t\tbuf->buffer->element[i].addr =  pool_entry->elements[i];\n\t\tif (i == QETH_MAX_BUFFER_ELEMENTS(card) - 1)\n\t\t\tbuf->buffer->element[i].eflags = SBAL_EFLAGS_LAST_ENTRY;\n\t\telse\n\t\t\tbuf->buffer->element[i].eflags = 0;\n\t\tbuf->buffer->element[i].sflags = 0;\n\t}\n\treturn 0;\n}\n\nint qeth_init_qdio_queues(struct qeth_card *card)\n{\n\tint i, j;\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"initqdqs\");\n\n\t/* inbound queue */\n\tmemset(card->qdio.in_q->qdio_bufs, 0,\n\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));\n\tqeth_initialize_working_pool_list(card);\n\t/*give only as many buffers to hardware as we have buffer pool entries*/\n\tfor (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)\n\t\tqeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);\n\tcard->qdio.in_q->next_buf_to_init =\n\t\tcard->qdio.in_buf_pool.buf_count - 1;\n\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,\n\t\t     card->qdio.in_buf_pool.buf_count - 1);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\treturn rc;\n\t}\n\n\t/* completion */\n\trc = qeth_cq_init(card);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* outbound queue */\n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tmemset(card->qdio.out_qs[i]->qdio_bufs, 0,\n\t\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));\n\t\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\t\tqeth_clear_output_buffer(card->qdio.out_qs[i],\n\t\t\t\t\tcard->qdio.out_qs[i]->bufs[j],\n\t\t\t\t\tQETH_QDIO_BUF_EMPTY);\n\t\t}\n\t\tcard->qdio.out_qs[i]->card = card;\n\t\tcard->qdio.out_qs[i]->next_buf_to_fill = 0;\n\t\tcard->qdio.out_qs[i]->do_pack = 0;\n\t\tatomic_set(&card->qdio.out_qs[i]->used_buffers, 0);\n\t\tatomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);\n\t\tatomic_set(&card->qdio.out_qs[i]->state,\n\t\t\t   QETH_OUT_Q_UNLOCKED);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_init_qdio_queues);\n\nstatic inline __u8 qeth_get_ipa_adp_type(enum qeth_link_types link_type)\n{\n\tswitch (link_type) {\n\tcase QETH_LINK_TYPE_HSTR:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void qeth_fill_ipacmd_header(struct qeth_card *card,\n\t\tstruct qeth_ipa_cmd *cmd, __u8 command,\n\t\tenum qeth_prot_versions prot)\n{\n\tmemset(cmd, 0, sizeof(struct qeth_ipa_cmd));\n\tcmd->hdr.command = command;\n\tcmd->hdr.initiator = IPA_CMD_INITIATOR_HOST;\n\tcmd->hdr.seqno = card->seqno.ipa;\n\tcmd->hdr.adapter_type = qeth_get_ipa_adp_type(card->info.link_type);\n\tcmd->hdr.rel_adapter_no = (__u8) card->info.portno;\n\tif (card->options.layer2)\n\t\tcmd->hdr.prim_version_no = 2;\n\telse\n\t\tcmd->hdr.prim_version_no = 1;\n\tcmd->hdr.param_count = 1;\n\tcmd->hdr.prot_version = prot;\n\tcmd->hdr.ipa_supported = 0;\n\tcmd->hdr.ipa_enabled = 0;\n}\n\nstruct qeth_cmd_buffer *qeth_get_ipacmd_buffer(struct qeth_card *card,\n\t\tenum qeth_ipa_cmds ipacmd, enum qeth_prot_versions prot)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tqeth_fill_ipacmd_header(card, cmd, ipacmd, prot);\n\n\treturn iob;\n}\nEXPORT_SYMBOL_GPL(qeth_get_ipacmd_buffer);\n\nvoid qeth_prepare_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\n\t\tchar prot_type)\n{\n\tmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\n\tmemcpy(QETH_IPA_CMD_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n}\nEXPORT_SYMBOL_GPL(qeth_prepare_ipa_cmd);\n\nint qeth_send_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply*,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tint rc;\n\tchar prot_type;\n\n\tQETH_CARD_TEXT(card, 4, \"sendipa\");\n\n\tif (card->options.layer2)\n\t\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\t\tprot_type = QETH_PROT_OSN2;\n\t\telse\n\t\t\tprot_type = QETH_PROT_LAYER2;\n\telse\n\t\tprot_type = QETH_PROT_TCPIP;\n\tqeth_prepare_ipa_cmd(card, iob, prot_type);\n\trc = qeth_send_control_data(card, IPA_CMD_LENGTH,\n\t\t\t\t\t\tiob, reply_cb, reply_param);\n\tif (rc == -ETIME) {\n\t\tqeth_clear_ipacmd_list(card);\n\t\tqeth_schedule_recovery(card);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_ipa_cmd);\n\nint qeth_send_startlan(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"strtlan\");\n\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_STARTLAN, 0);\n\trc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_startlan);\n\nstatic int qeth_default_setadapterparms_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"defadpcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (cmd->hdr.return_code == 0)\n\t\tcmd->hdr.return_code =\n\t\t\tcmd->data.setadapterparms.hdr.return_code;\n\treturn 0;\n}\n\nstatic int qeth_query_setadapterparms_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 3, \"quyadpcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (cmd->data.setadapterparms.data.query_cmds_supp.lan_type & 0x7f) {\n\t\tcard->info.link_type =\n\t\t      cmd->data.setadapterparms.data.query_cmds_supp.lan_type;\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"lnk %d\", card->info.link_type);\n\t}\n\tcard->options.adp.supported_funcs =\n\t\tcmd->data.setadapterparms.data.query_cmds_supp.supported_cmds;\n\treturn qeth_default_setadapterparms_cb(card, reply, (unsigned long)cmd);\n}\n\nstatic struct qeth_cmd_buffer *qeth_get_adapter_cmd(struct qeth_card *card,\n\t\t__u32 command, __u32 cmdlen)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETADAPTERPARMS,\n\t\t\t\t     QETH_PROT_IPV4);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.setadapterparms.hdr.cmdlength = cmdlen;\n\tcmd->data.setadapterparms.hdr.command_code = command;\n\tcmd->data.setadapterparms.hdr.used_total = 1;\n\tcmd->data.setadapterparms.hdr.seq_no = 1;\n\n\treturn iob;\n}\n\nint qeth_query_setadapterparms(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 3, \"queryadp\");\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_COMMANDS_SUPPORTED,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms));\n\trc = qeth_send_ipa_cmd(card, iob, qeth_query_setadapterparms_cb, NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_query_setadapterparms);\n\nstatic int qeth_query_ipassists_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"qipasscb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\n\tswitch (cmd->hdr.return_code) {\n\tcase IPA_RC_NOTSUPP:\n\tcase IPA_RC_L2_UNSUPPORTED_CMD:\n\t\tQETH_DBF_TEXT(SETUP, 2, \"ipaunsup\");\n\t\tcard->options.ipa4.supported_funcs |= IPA_SETADAPTERPARMS;\n\t\tcard->options.ipa6.supported_funcs |= IPA_SETADAPTERPARMS;\n\t\treturn -0;\n\tdefault:\n\t\tif (cmd->hdr.return_code) {\n\t\t\tQETH_DBF_MESSAGE(1, \"%s IPA_CMD_QIPASSIST: Unhandled \"\n\t\t\t\t\t\t\"rc=%d\\n\",\n\t\t\t\t\t\tdev_name(&card->gdev->dev),\n\t\t\t\t\t\tcmd->hdr.return_code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (cmd->hdr.prot_version == QETH_PROT_IPV4) {\n\t\tcard->options.ipa4.supported_funcs = cmd->hdr.ipa_supported;\n\t\tcard->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;\n\t} else if (cmd->hdr.prot_version == QETH_PROT_IPV6) {\n\t\tcard->options.ipa6.supported_funcs = cmd->hdr.ipa_supported;\n\t\tcard->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;\n\t} else\n\t\tQETH_DBF_MESSAGE(1, \"%s IPA_CMD_QIPASSIST: Flawed LIC detected\"\n\t\t\t\t\t\"\\n\", dev_name(&card->gdev->dev));\n\treturn 0;\n}\n\nint qeth_query_ipassists(struct qeth_card *card, enum qeth_prot_versions prot)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"qipassi%i\", prot);\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_QIPASSIST, prot);\n\trc = qeth_send_ipa_cmd(card, iob, qeth_query_ipassists_cb, NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_query_ipassists);\n\nstatic int qeth_query_setdiagass_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\t__u16 rc;\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\trc = cmd->hdr.return_code;\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"diagq:%x\", rc);\n\telse\n\t\tcard->info.diagass_support = cmd->data.diagass.ext;\n\treturn 0;\n}\n\nstatic int qeth_query_setdiagass(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd    *cmd;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"qdiagass\");\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.diagass.subcmd_len = 16;\n\tcmd->data.diagass.subcmd = QETH_DIAGS_CMD_QUERY;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_query_setdiagass_cb, NULL);\n}\n\nstatic void qeth_get_trap_id(struct qeth_card *card, struct qeth_trap_id *tid)\n{\n\tunsigned long info = get_zeroed_page(GFP_KERNEL);\n\tstruct sysinfo_2_2_2 *info222 = (struct sysinfo_2_2_2 *)info;\n\tstruct sysinfo_3_2_2 *info322 = (struct sysinfo_3_2_2 *)info;\n\tstruct ccw_dev_id ccwid;\n\tint level;\n\n\ttid->chpid = card->info.chpid;\n\tccw_device_get_id(CARD_RDEV(card), &ccwid);\n\ttid->ssid = ccwid.ssid;\n\ttid->devno = ccwid.devno;\n\tif (!info)\n\t\treturn;\n\tlevel = stsi(NULL, 0, 0, 0);\n\tif ((level >= 2) && (stsi(info222, 2, 2, 2) == 0))\n\t\ttid->lparnr = info222->lpar_number;\n\tif ((level >= 3) && (stsi(info322, 3, 2, 2) == 0)) {\n\t\tEBCASC(info322->vm[0].name, sizeof(info322->vm[0].name));\n\t\tmemcpy(tid->vmname, info322->vm[0].name, sizeof(tid->vmname));\n\t}\n\tfree_page(info);\n\treturn;\n}\n\nstatic int qeth_hw_trap_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\t__u16 rc;\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\trc = cmd->hdr.return_code;\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"trapc:%x\", rc);\n\treturn 0;\n}\n\nint qeth_hw_trap(struct qeth_card *card, enum qeth_diags_trap_action action)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"diagtrap\");\n\tiob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.diagass.subcmd_len = 80;\n\tcmd->data.diagass.subcmd = QETH_DIAGS_CMD_TRAP;\n\tcmd->data.diagass.type = 1;\n\tcmd->data.diagass.action = action;\n\tswitch (action) {\n\tcase QETH_DIAGS_TRAP_ARM:\n\t\tcmd->data.diagass.options = 0x0003;\n\t\tcmd->data.diagass.ext = 0x00010000 +\n\t\t\tsizeof(struct qeth_trap_id);\n\t\tqeth_get_trap_id(card,\n\t\t\t(struct qeth_trap_id *)cmd->data.diagass.cdata);\n\t\tbreak;\n\tcase QETH_DIAGS_TRAP_DISARM:\n\t\tcmd->data.diagass.options = 0x0001;\n\t\tbreak;\n\tcase QETH_DIAGS_TRAP_CAPTURE:\n\t\tbreak;\n\t}\n\treturn qeth_send_ipa_cmd(card, iob, qeth_hw_trap_cb, NULL);\n}\nEXPORT_SYMBOL_GPL(qeth_hw_trap);\n\nint qeth_check_qdio_errors(struct qeth_card *card, struct qdio_buffer *buf,\n\t\tunsigned int qdio_error, const char *dbftext)\n{\n\tif (qdio_error) {\n\t\tQETH_CARD_TEXT(card, 2, dbftext);\n\t\tQETH_CARD_TEXT_(card, 2, \" F15=%02X\",\n\t\t\t       buf->element[15].sflags);\n\t\tQETH_CARD_TEXT_(card, 2, \" F14=%02X\",\n\t\t\t       buf->element[14].sflags);\n\t\tQETH_CARD_TEXT_(card, 2, \" qerr=%X\", qdio_error);\n\t\tif ((buf->element[15].sflags) == 0x12) {\n\t\t\tcard->stats.rx_dropped++;\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_check_qdio_errors);\n\nvoid qeth_buffer_reclaim_work(struct work_struct *work)\n{\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\tbuffer_reclaim_work.work);\n\n\tQETH_CARD_TEXT_(card, 2, \"brw:%x\", card->reclaim_index);\n\tqeth_queue_input_buffer(card, card->reclaim_index);\n}\n\nvoid qeth_queue_input_buffer(struct qeth_card *card, int index)\n{\n\tstruct qeth_qdio_q *queue = card->qdio.in_q;\n\tstruct list_head *lh;\n\tint count;\n\tint i;\n\tint rc;\n\tint newcount = 0;\n\n\tcount = (index < queue->next_buf_to_init)?\n\t\tcard->qdio.in_buf_pool.buf_count -\n\t\t(queue->next_buf_to_init - index) :\n\t\tcard->qdio.in_buf_pool.buf_count -\n\t\t(queue->next_buf_to_init + QDIO_MAX_BUFFERS_PER_Q - index);\n\t/* only requeue at a certain threshold to avoid SIGAs */\n\tif (count >= QETH_IN_BUF_REQUEUE_THRESHOLD(card)) {\n\t\tfor (i = queue->next_buf_to_init;\n\t\t     i < queue->next_buf_to_init + count; ++i) {\n\t\t\tif (qeth_init_input_buffer(card,\n\t\t\t\t&queue->bufs[i % QDIO_MAX_BUFFERS_PER_Q])) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tnewcount++;\n\t\t\t}\n\t\t}\n\n\t\tif (newcount < count) {\n\t\t\t/* we are in memory shortage so we switch back to\n\t\t\t   traditional skb allocation and drop packages */\n\t\t\tatomic_set(&card->force_alloc_skb, 3);\n\t\t\tcount = newcount;\n\t\t} else {\n\t\t\tatomic_add_unless(&card->force_alloc_skb, -1, 0);\n\t\t}\n\n\t\tif (!count) {\n\t\t\ti = 0;\n\t\t\tlist_for_each(lh, &card->qdio.in_buf_pool.entry_list)\n\t\t\t\ti++;\n\t\t\tif (i == card->qdio.in_buf_pool.buf_count) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"qsarbw\");\n\t\t\t\tcard->reclaim_index = index;\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t&card->buffer_reclaim_work,\n\t\t\t\t\tQETH_RECLAIM_WORK_TIME);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * according to old code it should be avoided to requeue all\n\t\t * 128 buffers in order to benefit from PCI avoidance.\n\t\t * this function keeps at least one buffer (the buffer at\n\t\t * 'index') un-requeued -> this buffer is the first buffer that\n\t\t * will be requeued the next time\n\t\t */\n\t\tif (card->options.performance_stats) {\n\t\t\tcard->perf_stats.inbound_do_qdio_cnt++;\n\t\t\tcard->perf_stats.inbound_do_qdio_start_time =\n\t\t\t\tqeth_get_micros();\n\t\t}\n\t\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0,\n\t\t\t     queue->next_buf_to_init, count);\n\t\tif (card->options.performance_stats)\n\t\t\tcard->perf_stats.inbound_do_qdio_time +=\n\t\t\t\tqeth_get_micros() -\n\t\t\t\tcard->perf_stats.inbound_do_qdio_start_time;\n\t\tif (rc) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"qinberr\");\n\t\t}\n\t\tqueue->next_buf_to_init = (queue->next_buf_to_init + count) %\n\t\t\t\t\t  QDIO_MAX_BUFFERS_PER_Q;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_queue_input_buffer);\n\nstatic int qeth_handle_send_error(struct qeth_card *card,\n\t\tstruct qeth_qdio_out_buffer *buffer, unsigned int qdio_err)\n{\n\tint sbalf15 = buffer->buffer->element[15].sflags;\n\n\tQETH_CARD_TEXT(card, 6, \"hdsnderr\");\n\tif (card->info.type == QETH_CARD_TYPE_IQD) {\n\t\tif (sbalf15 == 0) {\n\t\t\tqdio_err = 0;\n\t\t} else {\n\t\t\tqdio_err = 1;\n\t\t}\n\t}\n\tqeth_check_qdio_errors(card, buffer->buffer, qdio_err, \"qouterr\");\n\n\tif (!qdio_err)\n\t\treturn QETH_SEND_ERROR_NONE;\n\n\tif ((sbalf15 >= 15) && (sbalf15 <= 31))\n\t\treturn QETH_SEND_ERROR_RETRY;\n\n\tQETH_CARD_TEXT(card, 1, \"lnkfail\");\n\tQETH_CARD_TEXT_(card, 1, \"%04x %02x\",\n\t\t       (u16)qdio_err, (u8)sbalf15);\n\treturn QETH_SEND_ERROR_LINK_FAILURE;\n}\n\n/*\n * Switched to packing state if the number of used buffers on a queue\n * reaches a certain limit.\n */\nstatic void qeth_switch_to_packing_if_needed(struct qeth_qdio_out_q *queue)\n{\n\tif (!queue->do_pack) {\n\t\tif (atomic_read(&queue->used_buffers)\n\t\t    >= QETH_HIGH_WATERMARK_PACK){\n\t\t\t/* switch non-PACKING -> PACKING */\n\t\t\tQETH_CARD_TEXT(queue->card, 6, \"np->pack\");\n\t\t\tif (queue->card->options.performance_stats)\n\t\t\t\tqueue->card->perf_stats.sc_dp_p++;\n\t\t\tqueue->do_pack = 1;\n\t\t}\n\t}\n}\n\n/*\n * Switches from packing to non-packing mode. If there is a packing\n * buffer on the queue this buffer will be prepared to be flushed.\n * In that case 1 is returned to inform the caller. If no buffer\n * has to be flushed, zero is returned.\n */\nstatic int qeth_switch_to_nonpacking_if_needed(struct qeth_qdio_out_q *queue)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint flush_count = 0;\n\n\tif (queue->do_pack) {\n\t\tif (atomic_read(&queue->used_buffers)\n\t\t    <= QETH_LOW_WATERMARK_PACK) {\n\t\t\t/* switch PACKING -> non-PACKING */\n\t\t\tQETH_CARD_TEXT(queue->card, 6, \"pack->np\");\n\t\t\tif (queue->card->options.performance_stats)\n\t\t\t\tqueue->card->perf_stats.sc_p_dp++;\n\t\t\tqueue->do_pack = 0;\n\t\t\t/* flush packing buffers */\n\t\t\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t\t\tif ((atomic_read(&buffer->state) ==\n\t\t\t\t\t\tQETH_QDIO_BUF_EMPTY) &&\n\t\t\t    (buffer->next_element_to_fill > 0)) {\n\t\t\t\tatomic_set(&buffer->state,\n\t\t\t\t\t   QETH_QDIO_BUF_PRIMED);\n\t\t\t\tflush_count++;\n\t\t\t\tqueue->next_buf_to_fill =\n\t\t\t\t\t(queue->next_buf_to_fill + 1) %\n\t\t\t\t\tQDIO_MAX_BUFFERS_PER_Q;\n\t\t\t}\n\t\t}\n\t}\n\treturn flush_count;\n}\n\n\n/*\n * Called to flush a packing buffer if no more pci flags are on the queue.\n * Checks if there is a packing buffer and prepares it to be flushed.\n * In that case returns 1, otherwise zero.\n */\nstatic int qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\tif ((atomic_read(&buffer->state) == QETH_QDIO_BUF_EMPTY) &&\n\t   (buffer->next_element_to_fill > 0)) {\n\t\t/* it's a packing buffer */\n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\tqueue->next_buf_to_fill =\n\t\t\t(queue->next_buf_to_fill + 1) % QDIO_MAX_BUFFERS_PER_Q;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_flush_buffers(struct qeth_qdio_out_q *queue, int index,\n\t\t\t       int count)\n{\n\tstruct qeth_qdio_out_buffer *buf;\n\tint rc;\n\tint i;\n\tunsigned int qdio_flags;\n\n\tfor (i = index; i < index + count; ++i) {\n\t\tint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tbuf = queue->bufs[bidx];\n\t\tbuf->buffer->element[buf->next_element_to_fill - 1].eflags |=\n\t\t\t\tSBAL_EFLAGS_LAST_ENTRY;\n\n\t\tif (queue->bufstates)\n\t\t\tqueue->bufstates[bidx].user = buf;\n\n\t\tif (queue->card->info.type == QETH_CARD_TYPE_IQD)\n\t\t\tcontinue;\n\n\t\tif (!queue->do_pack) {\n\t\t\tif ((atomic_read(&queue->used_buffers) >=\n\t\t\t\t(QETH_HIGH_WATERMARK_PACK -\n\t\t\t\t QETH_WATERMARK_PACK_FUZZ)) &&\n\t\t\t    !atomic_read(&queue->set_pci_flags_count)) {\n\t\t\t\t/* it's likely that we'll go to packing\n\t\t\t\t * mode soon */\n\t\t\t\tatomic_inc(&queue->set_pci_flags_count);\n\t\t\t\tbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!atomic_read(&queue->set_pci_flags_count)) {\n\t\t\t\t/*\n\t\t\t\t * there's no outstanding PCI any more, so we\n\t\t\t\t * have to request a PCI to be sure the the PCI\n\t\t\t\t * will wake at some time in the future then we\n\t\t\t\t * can flush packed buffers that might still be\n\t\t\t\t * hanging around, which can happen if no\n\t\t\t\t * further send was requested by the stack\n\t\t\t\t */\n\t\t\t\tatomic_inc(&queue->set_pci_flags_count);\n\t\t\t\tbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue->card->dev->trans_start = jiffies;\n\tif (queue->card->options.performance_stats) {\n\t\tqueue->card->perf_stats.outbound_do_qdio_cnt++;\n\t\tqueue->card->perf_stats.outbound_do_qdio_start_time =\n\t\t\tqeth_get_micros();\n\t}\n\tqdio_flags = QDIO_FLAG_SYNC_OUTPUT;\n\tif (atomic_read(&queue->set_pci_flags_count))\n\t\tqdio_flags |= QDIO_FLAG_PCI_OUT;\n\trc = do_QDIO(CARD_DDEV(queue->card), qdio_flags,\n\t\t     queue->queue_no, index, count);\n\tif (queue->card->options.performance_stats)\n\t\tqueue->card->perf_stats.outbound_do_qdio_time +=\n\t\t\tqeth_get_micros() -\n\t\t\tqueue->card->perf_stats.outbound_do_qdio_start_time;\n\tatomic_add(count, &queue->used_buffers);\n\tif (rc) {\n\t\tqueue->card->stats.tx_errors += count;\n\t\t/* ignore temporary SIGA errors without busy condition */\n\t\tif (rc == -ENOBUFS)\n\t\t\treturn;\n\t\tQETH_CARD_TEXT(queue->card, 2, \"flushbuf\");\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" q%d\", queue->queue_no);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" idx%d\", index);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" c%d\", count);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" err%d\", rc);\n\n\t\t/* this must not happen under normal circumstances. if it\n\t\t * happens something is really wrong -> recover */\n\t\tqeth_schedule_recovery(queue->card);\n\t\treturn;\n\t}\n\tif (queue->card->options.performance_stats)\n\t\tqueue->card->perf_stats.bufs_sent += count;\n}\n\nstatic void qeth_check_outbound_queue(struct qeth_qdio_out_q *queue)\n{\n\tint index;\n\tint flush_cnt = 0;\n\tint q_was_packing = 0;\n\n\t/*\n\t * check if weed have to switch to non-packing mode or if\n\t * we have to get a pci flag out on the queue\n\t */\n\tif ((atomic_read(&queue->used_buffers) <= QETH_LOW_WATERMARK_PACK) ||\n\t    !atomic_read(&queue->set_pci_flags_count)) {\n\t\tif (atomic_xchg(&queue->state, QETH_OUT_Q_LOCKED_FLUSH) ==\n\t\t\t\tQETH_OUT_Q_UNLOCKED) {\n\t\t\t/*\n\t\t\t * If we get in here, there was no action in\n\t\t\t * do_send_packet. So, we check if there is a\n\t\t\t * packing buffer to be flushed here.\n\t\t\t */\n\t\t\tnetif_stop_queue(queue->card->dev);\n\t\t\tindex = queue->next_buf_to_fill;\n\t\t\tq_was_packing = queue->do_pack;\n\t\t\t/* queue->do_pack may change */\n\t\t\tbarrier();\n\t\t\tflush_cnt += qeth_switch_to_nonpacking_if_needed(queue);\n\t\t\tif (!flush_cnt &&\n\t\t\t    !atomic_read(&queue->set_pci_flags_count))\n\t\t\t\tflush_cnt +=\n\t\t\t\t\tqeth_flush_buffers_on_no_pci(queue);\n\t\t\tif (queue->card->options.performance_stats &&\n\t\t\t    q_was_packing)\n\t\t\t\tqueue->card->perf_stats.bufs_sent_pack +=\n\t\t\t\t\tflush_cnt;\n\t\t\tif (flush_cnt)\n\t\t\t\tqeth_flush_buffers(queue, index, flush_cnt);\n\t\t\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\t\t}\n\t}\n}\n\nvoid qeth_qdio_start_poll(struct ccw_device *ccwdev, int queue,\n\t\tunsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tif (card->dev && (card->dev->flags & IFF_UP))\n\t\tnapi_schedule(&card->napi);\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_start_poll);\n\nint qeth_configure_cq(struct qeth_card *card, enum qeth_cq cq)\n{\n\tint rc;\n\n\tif (card->options.cq ==  QETH_CQ_NOTAVAILABLE) {\n\t\trc = -1;\n\t\tgoto out;\n\t} else {\n\t\tif (card->options.cq == cq) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (card->state != CARD_STATE_DOWN &&\n\t\t    card->state != CARD_STATE_RECOVER) {\n\t\t\trc = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tqeth_free_qdio_buffers(card);\n\t\tcard->options.cq = cq;\n\t\trc = 0;\n\t}\nout:\n\treturn rc;\n\n}\nEXPORT_SYMBOL_GPL(qeth_configure_cq);\n\n\nstatic void qeth_qdio_cq_handler(struct qeth_card *card,\n\t\tunsigned int qdio_err,\n\t\tunsigned int queue, int first_element, int count) {\n\tstruct qeth_qdio_q *cq = card->qdio.c_q;\n\tint i;\n\tint rc;\n\n\tif (!qeth_is_cq(card, queue))\n\t\tgoto out;\n\n\tQETH_CARD_TEXT_(card, 5, \"qcqhe%d\", first_element);\n\tQETH_CARD_TEXT_(card, 5, \"qcqhc%d\", count);\n\tQETH_CARD_TEXT_(card, 5, \"qcqherr%d\", qdio_err);\n\n\tif (qdio_err) {\n\t\tnetif_stop_queue(card->dev);\n\t\tqeth_schedule_recovery(card);\n\t\tgoto out;\n\t}\n\n\tif (card->options.performance_stats) {\n\t\tcard->perf_stats.cq_cnt++;\n\t\tcard->perf_stats.cq_start_time = qeth_get_micros();\n\t}\n\n\tfor (i = first_element; i < first_element + count; ++i) {\n\t\tint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tstruct qdio_buffer *buffer = &cq->qdio_bufs[bidx];\n\t\tint e;\n\n\t\te = 0;\n\t\twhile (buffer->element[e].addr) {\n\t\t\tunsigned long phys_aob_addr;\n\n\t\t\tphys_aob_addr = (unsigned long) buffer->element[e].addr;\n\t\t\tqeth_qdio_handle_aob(card, phys_aob_addr);\n\t\t\tbuffer->element[e].addr = NULL;\n\t\t\tbuffer->element[e].eflags = 0;\n\t\t\tbuffer->element[e].sflags = 0;\n\t\t\tbuffer->element[e].length = 0;\n\n\t\t\t++e;\n\t\t}\n\n\t\tbuffer->element[15].eflags = 0;\n\t\tbuffer->element[15].sflags = 0;\n\t}\n\trc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, queue,\n\t\t    card->qdio.c_q->next_buf_to_init,\n\t\t    count);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t\"QDIO reported an error, rc=%i\\n\", rc);\n\t\tQETH_CARD_TEXT(card, 2, \"qcqherr\");\n\t}\n\tcard->qdio.c_q->next_buf_to_init = (card->qdio.c_q->next_buf_to_init\n\t\t\t\t   + count) % QDIO_MAX_BUFFERS_PER_Q;\n\n\tnetif_wake_queue(card->dev);\n\n\tif (card->options.performance_stats) {\n\t\tint delta_t = qeth_get_micros();\n\t\tdelta_t -= card->perf_stats.cq_start_time;\n\t\tcard->perf_stats.cq_time += delta_t;\n\t}\nout:\n\treturn;\n}\n\nvoid qeth_qdio_input_handler(struct ccw_device *ccwdev, unsigned int qdio_err,\n\t\tunsigned int queue, int first_elem, int count,\n\t\tunsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tQETH_CARD_TEXT_(card, 2, \"qihq%d\", queue);\n\tQETH_CARD_TEXT_(card, 2, \"qiec%d\", qdio_err);\n\n\tif (qeth_is_cq(card, queue))\n\t\tqeth_qdio_cq_handler(card, qdio_err, queue, first_elem, count);\n\telse if (qdio_err)\n\t\tqeth_schedule_recovery(card);\n\n\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_input_handler);\n\nvoid qeth_qdio_output_handler(struct ccw_device *ccwdev,\n\t\tunsigned int qdio_error, int __queue, int first_element,\n\t\tint count, unsigned long card_ptr)\n{\n\tstruct qeth_card *card        = (struct qeth_card *) card_ptr;\n\tstruct qeth_qdio_out_q *queue = card->qdio.out_qs[__queue];\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint i;\n\n\tQETH_CARD_TEXT(card, 6, \"qdouhdl\");\n\tif (qdio_error & QDIO_ERROR_FATAL) {\n\t\tQETH_CARD_TEXT(card, 2, \"achkcond\");\n\t\tnetif_stop_queue(card->dev);\n\t\tqeth_schedule_recovery(card);\n\t\treturn;\n\t}\n\tif (card->options.performance_stats) {\n\t\tcard->perf_stats.outbound_handler_cnt++;\n\t\tcard->perf_stats.outbound_handler_start_time =\n\t\t\tqeth_get_micros();\n\t}\n\tfor (i = first_element; i < (first_element + count); ++i) {\n\t\tint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tbuffer = queue->bufs[bidx];\n\t\tqeth_handle_send_error(card, buffer, qdio_error);\n\n\t\tif (queue->bufstates &&\n\t\t    (queue->bufstates[bidx].flags &\n\t\t     QDIO_OUTBUF_STATE_FLAG_PENDING) != 0) {\n\t\t\tWARN_ON_ONCE(card->options.cq != QETH_CQ_ENABLED);\n\n\t\t\tif (atomic_cmpxchg(&buffer->state,\n\t\t\t\t\t   QETH_QDIO_BUF_PRIMED,\n\t\t\t\t\t   QETH_QDIO_BUF_PENDING) ==\n\t\t\t\tQETH_QDIO_BUF_PRIMED) {\n\t\t\t\tqeth_notify_skbs(queue, buffer,\n\t\t\t\t\t\t TX_NOTIFY_PENDING);\n\t\t\t}\n\t\t\tbuffer->aob = queue->bufstates[bidx].aob;\n\t\t\tQETH_CARD_TEXT_(queue->card, 5, \"pel%d\", bidx);\n\t\t\tQETH_CARD_TEXT(queue->card, 5, \"aob\");\n\t\t\tQETH_CARD_TEXT_(queue->card, 5, \"%lx\",\n\t\t\t\t\tvirt_to_phys(buffer->aob));\n\t\t\tif (qeth_init_qdio_out_buf(queue, bidx)) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"outofbuf\");\n\t\t\t\tqeth_schedule_recovery(card);\n\t\t\t}\n\t\t} else {\n\t\t\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\t\t\tenum iucv_tx_notify n;\n\n\t\t\t\tn = qeth_compute_cq_notification(\n\t\t\t\t\tbuffer->buffer->element[15].sflags, 0);\n\t\t\t\tqeth_notify_skbs(queue, buffer, n);\n\t\t\t}\n\n\t\t\tqeth_clear_output_buffer(queue, buffer,\n\t\t\t\t\t\tQETH_QDIO_BUF_EMPTY);\n\t\t}\n\t\tqeth_cleanup_handled_pending(queue, bidx, 0);\n\t}\n\tatomic_sub(count, &queue->used_buffers);\n\t/* check if we need to do something on this outbound queue */\n\tif (card->info.type != QETH_CARD_TYPE_IQD)\n\t\tqeth_check_outbound_queue(queue);\n\n\tnetif_wake_queue(queue->card->dev);\n\tif (card->options.performance_stats)\n\t\tcard->perf_stats.outbound_handler_time += qeth_get_micros() -\n\t\t\tcard->perf_stats.outbound_handler_start_time;\n}\nEXPORT_SYMBOL_GPL(qeth_qdio_output_handler);\n\nint qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb,\n\t\t\tint ipv, int cast_type)\n{\n\tif (!ipv && (card->info.type == QETH_CARD_TYPE_OSD ||\n\t\t     card->info.type == QETH_CARD_TYPE_OSX))\n\t\treturn card->qdio.default_out_queue;\n\tswitch (card->qdio.no_out_queues) {\n\tcase 4:\n\t\tif (cast_type && card->info.is_multicast_different)\n\t\t\treturn card->info.is_multicast_different &\n\t\t\t\t(card->qdio.no_out_queues - 1);\n\t\tif (card->qdio.do_prio_queueing && (ipv == 4)) {\n\t\t\tconst u8 tos = ip_hdr(skb)->tos;\n\n\t\t\tif (card->qdio.do_prio_queueing ==\n\t\t\t\tQETH_PRIO_Q_ING_TOS) {\n\t\t\t\tif (tos & IP_TOS_NOTIMPORTANT)\n\t\t\t\t\treturn 3;\n\t\t\t\tif (tos & IP_TOS_HIGHRELIABILITY)\n\t\t\t\t\treturn 2;\n\t\t\t\tif (tos & IP_TOS_HIGHTHROUGHPUT)\n\t\t\t\t\treturn 1;\n\t\t\t\tif (tos & IP_TOS_LOWDELAY)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (card->qdio.do_prio_queueing ==\n\t\t\t\tQETH_PRIO_Q_ING_PREC)\n\t\t\t\treturn 3 - (tos >> 6);\n\t\t} else if (card->qdio.do_prio_queueing && (ipv == 6)) {\n\t\t\t/* TODO: IPv6!!! */\n\t\t}\n\t\treturn card->qdio.default_out_queue;\n\tcase 1: /* fallthrough for single-out-queue 1920-device */\n\tdefault:\n\t\treturn card->qdio.default_out_queue;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_get_priority_queue);\n\nint qeth_get_elements_for_frags(struct sk_buff *skb)\n{\n\tint cnt, length, e, elements = 0;\n\tstruct skb_frag_struct *frag;\n\tchar *data;\n\n\tfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\n\t\tfrag = &skb_shinfo(skb)->frags[cnt];\n\t\tdata = (char *)page_to_phys(skb_frag_page(frag)) +\n\t\t\tfrag->page_offset;\n\t\tlength = frag->size;\n\t\te = PFN_UP((unsigned long)data + length - 1) -\n\t\t\tPFN_DOWN((unsigned long)data);\n\t\telements += e;\n\t}\n\treturn elements;\n}\nEXPORT_SYMBOL_GPL(qeth_get_elements_for_frags);\n\nint qeth_get_elements_no(struct qeth_card *card,\n\t\t     struct sk_buff *skb, int elems)\n{\n\tint dlen = skb->len - skb->data_len;\n\tint elements_needed = PFN_UP((unsigned long)skb->data + dlen - 1) -\n\t\tPFN_DOWN((unsigned long)skb->data);\n\n\telements_needed += qeth_get_elements_for_frags(skb);\n\n\tif ((elements_needed + elems) > QETH_MAX_BUFFER_ELEMENTS(card)) {\n\t\tQETH_DBF_MESSAGE(2, \"Invalid size of IP packet \"\n\t\t\t\"(Number=%d / Length=%d). Discarded.\\n\",\n\t\t\t(elements_needed+elems), skb->len);\n\t\treturn 0;\n\t}\n\treturn elements_needed;\n}\nEXPORT_SYMBOL_GPL(qeth_get_elements_no);\n\nint qeth_hdr_chk_and_bounce(struct sk_buff *skb, struct qeth_hdr **hdr, int len)\n{\n\tint hroom, inpage, rest;\n\n\tif (((unsigned long)skb->data & PAGE_MASK) !=\n\t    (((unsigned long)skb->data + len - 1) & PAGE_MASK)) {\n\t\throom = skb_headroom(skb);\n\t\tinpage = PAGE_SIZE - ((unsigned long) skb->data % PAGE_SIZE);\n\t\trest = len - inpage;\n\t\tif (rest > hroom)\n\t\t\treturn 1;\n\t\tmemmove(skb->data - rest, skb->data, skb->len - skb->data_len);\n\t\tskb->data -= rest;\n\t\tskb->tail -= rest;\n\t\t*hdr = (struct qeth_hdr *)skb->data;\n\t\tQETH_DBF_MESSAGE(2, \"skb bounce len: %d rest: %d\\n\", len, rest);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_hdr_chk_and_bounce);\n\nstatic inline void __qeth_fill_buffer(struct sk_buff *skb,\n\tstruct qdio_buffer *buffer, int is_tso, int *next_element_to_fill,\n\tint offset)\n{\n\tint length = skb->len - skb->data_len;\n\tint length_here;\n\tint element;\n\tchar *data;\n\tint first_lap, cnt;\n\tstruct skb_frag_struct *frag;\n\n\telement = *next_element_to_fill;\n\tdata = skb->data;\n\tfirst_lap = (is_tso == 0 ? 1 : 0);\n\n\tif (offset >= 0) {\n\t\tdata = skb->data + offset;\n\t\tlength -= offset;\n\t\tfirst_lap = 0;\n\t}\n\n\twhile (length > 0) {\n\t\t/* length_here is the remaining amount of data in this page */\n\t\tlength_here = PAGE_SIZE - ((unsigned long) data % PAGE_SIZE);\n\t\tif (length < length_here)\n\t\t\tlength_here = length;\n\n\t\tbuffer->element[element].addr = data;\n\t\tbuffer->element[element].length = length_here;\n\t\tlength -= length_here;\n\t\tif (!length) {\n\t\t\tif (first_lap)\n\t\t\t\tif (skb_shinfo(skb)->nr_frags)\n\t\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t\t\tSBAL_EFLAGS_FIRST_FRAG;\n\t\t\t\telse\n\t\t\t\t\tbuffer->element[element].eflags = 0;\n\t\t\telse\n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t    SBAL_EFLAGS_MIDDLE_FRAG;\n\t\t} else {\n\t\t\tif (first_lap)\n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t    SBAL_EFLAGS_FIRST_FRAG;\n\t\t\telse\n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t    SBAL_EFLAGS_MIDDLE_FRAG;\n\t\t}\n\t\tdata += length_here;\n\t\telement++;\n\t\tfirst_lap = 0;\n\t}\n\n\tfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\n\t\tfrag = &skb_shinfo(skb)->frags[cnt];\n\t\tdata = (char *)page_to_phys(skb_frag_page(frag)) +\n\t\t\tfrag->page_offset;\n\t\tlength = frag->size;\n\t\twhile (length > 0) {\n\t\t\tlength_here = PAGE_SIZE -\n\t\t\t\t((unsigned long) data % PAGE_SIZE);\n\t\t\tif (length < length_here)\n\t\t\t\tlength_here = length;\n\n\t\t\tbuffer->element[element].addr = data;\n\t\t\tbuffer->element[element].length = length_here;\n\t\t\tbuffer->element[element].eflags =\n\t\t\t\tSBAL_EFLAGS_MIDDLE_FRAG;\n\t\t\tlength -= length_here;\n\t\t\tdata += length_here;\n\t\t\telement++;\n\t\t}\n\t}\n\n\tif (buffer->element[element - 1].eflags)\n\t\tbuffer->element[element - 1].eflags = SBAL_EFLAGS_LAST_FRAG;\n\t*next_element_to_fill = element;\n}\n\nstatic inline int qeth_fill_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf, struct sk_buff *skb,\n\t\tstruct qeth_hdr *hdr, int offset, int hd_len)\n{\n\tstruct qdio_buffer *buffer;\n\tint flush_cnt = 0, hdr_len, large_send = 0;\n\n\tbuffer = buf->buffer;\n\tatomic_inc(&skb->users);\n\tskb_queue_tail(&buf->skb_list, skb);\n\n\t/*check first on TSO ....*/\n\tif (hdr->hdr.l3.id == QETH_HEADER_TYPE_TSO) {\n\t\tint element = buf->next_element_to_fill;\n\n\t\thdr_len = sizeof(struct qeth_hdr_tso) +\n\t\t\t((struct qeth_hdr_tso *)hdr)->ext.dg_hdr_len;\n\t\t/*fill first buffer entry only with header information */\n\t\tbuffer->element[element].addr = skb->data;\n\t\tbuffer->element[element].length = hdr_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->next_element_to_fill++;\n\t\tskb->data += hdr_len;\n\t\tskb->len  -= hdr_len;\n\t\tlarge_send = 1;\n\t}\n\n\tif (offset >= 0) {\n\t\tint element = buf->next_element_to_fill;\n\t\tbuffer->element[element].addr = hdr;\n\t\tbuffer->element[element].length = sizeof(struct qeth_hdr) +\n\t\t\t\t\t\t\thd_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->is_header[element] = 1;\n\t\tbuf->next_element_to_fill++;\n\t}\n\n\t__qeth_fill_buffer(skb, buffer, large_send,\n\t\t(int *)&buf->next_element_to_fill, offset);\n\n\tif (!queue->do_pack) {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfnp\");\n\t\t/* set state to PRIMED -> will be flushed */\n\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\tflush_cnt = 1;\n\t} else {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfpa\");\n\t\tif (queue->card->options.performance_stats)\n\t\t\tqueue->card->perf_stats.skbs_sent_pack++;\n\t\tif (buf->next_element_to_fill >=\n\t\t\t\tQETH_MAX_BUFFER_ELEMENTS(queue->card)) {\n\t\t\t/*\n\t\t\t * packed buffer if full -> set state PRIMED\n\t\t\t * -> will be flushed\n\t\t\t */\n\t\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_cnt = 1;\n\t\t}\n\t}\n\treturn flush_cnt;\n}\n\nint qeth_do_send_packet_fast(struct qeth_card *card,\n\t\tstruct qeth_qdio_out_q *queue, struct sk_buff *skb,\n\t\tstruct qeth_hdr *hdr, int elements_needed,\n\t\tint offset, int hd_len)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint index;\n\n\t/* spin until we get the queue ... */\n\twhile (atomic_cmpxchg(&queue->state, QETH_OUT_Q_UNLOCKED,\n\t\t\t      QETH_OUT_Q_LOCKED) != QETH_OUT_Q_UNLOCKED);\n\t/* ... now we've got the queue */\n\tindex = queue->next_buf_to_fill;\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t/*\n\t * check if buffer is empty to make sure that we do not 'overtake'\n\t * ourselves and try to fill a buffer that is already primed\n\t */\n\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY)\n\t\tgoto out;\n\tqueue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %\n\t\t\t\t\t  QDIO_MAX_BUFFERS_PER_Q;\n\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\tqeth_fill_buffer(queue, buffer, skb, hdr, offset, hd_len);\n\tqeth_flush_buffers(queue, index, 1);\n\treturn 0;\nout:\n\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(qeth_do_send_packet_fast);\n\nint qeth_do_send_packet(struct qeth_card *card, struct qeth_qdio_out_q *queue,\n\t\tstruct sk_buff *skb, struct qeth_hdr *hdr,\n\t\tint elements_needed)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\tint start_index;\n\tint flush_count = 0;\n\tint do_pack = 0;\n\tint tmp;\n\tint rc = 0;\n\n\t/* spin until we get the queue ... */\n\twhile (atomic_cmpxchg(&queue->state, QETH_OUT_Q_UNLOCKED,\n\t\t\t      QETH_OUT_Q_LOCKED) != QETH_OUT_Q_UNLOCKED);\n\tstart_index = queue->next_buf_to_fill;\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t/*\n\t * check if buffer is empty to make sure that we do not 'overtake'\n\t * ourselves and try to fill a buffer that is already primed\n\t */\n\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY) {\n\t\tatomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\n\t\treturn -EBUSY;\n\t}\n\t/* check if we need to switch packing state of this queue */\n\tqeth_switch_to_packing_if_needed(queue);\n\tif (queue->do_pack) {\n\t\tdo_pack = 1;\n\t\t/* does packet fit in current buffer? */\n\t\tif ((QETH_MAX_BUFFER_ELEMENTS(card) -\n\t\t    buffer->next_element_to_fill) < elements_needed) {\n\t\t\t/* ... no -> set state PRIMED */\n\t\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_count++;\n\t\t\tqueue->next_buf_to_fill =\n\t\t\t\t(queue->next_buf_to_fill + 1) %\n\t\t\t\tQDIO_MAX_BUFFERS_PER_Q;\n\t\t\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\t\t\t/* we did a step forward, so check buffer state\n\t\t\t * again */\n\t\t\tif (atomic_read(&buffer->state) !=\n\t\t\t    QETH_QDIO_BUF_EMPTY) {\n\t\t\t\tqeth_flush_buffers(queue, start_index,\n\t\t\t\t\t\t\t   flush_count);\n\t\t\t\tatomic_set(&queue->state,\n\t\t\t\t\t\tQETH_OUT_Q_UNLOCKED);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\ttmp = qeth_fill_buffer(queue, buffer, skb, hdr, -1, 0);\n\tqueue->next_buf_to_fill = (queue->next_buf_to_fill + tmp) %\n\t\t\t\t  QDIO_MAX_BUFFERS_PER_Q;\n\tflush_count += tmp;\n\tif (flush_count)\n\t\tqeth_flush_buffers(queue, start_index, flush_count);\n\telse if (!atomic_read(&queue->set_pci_flags_count))\n\t\tatomic_xchg(&queue->state, QETH_OUT_Q_LOCKED_FLUSH);\n\t/*\n\t * queue->state will go from LOCKED -> UNLOCKED or from\n\t * LOCKED_FLUSH -> LOCKED if output_handler wanted to 'notify' us\n\t * (switch packing state or flush buffer to get another pci flag out).\n\t * In that case we will enter this loop\n\t */\n\twhile (atomic_dec_return(&queue->state)) {\n\t\tflush_count = 0;\n\t\tstart_index = queue->next_buf_to_fill;\n\t\t/* check if we can go back to non-packing state */\n\t\tflush_count += qeth_switch_to_nonpacking_if_needed(queue);\n\t\t/*\n\t\t * check if we need to flush a packing buffer to get a pci\n\t\t * flag out on the queue\n\t\t */\n\t\tif (!flush_count && !atomic_read(&queue->set_pci_flags_count))\n\t\t\tflush_count += qeth_flush_buffers_on_no_pci(queue);\n\t\tif (flush_count)\n\t\t\tqeth_flush_buffers(queue, start_index, flush_count);\n\t}\n\t/* at this point the queue is UNLOCKED again */\n\tif (queue->card->options.performance_stats && do_pack)\n\t\tqueue->card->perf_stats.bufs_sent_pack += flush_count;\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_do_send_packet);\n\nstatic int qeth_setadp_promisc_mode_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_ipacmd_setadpparms *setparms;\n\n\tQETH_CARD_TEXT(card, 4, \"prmadpcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tsetparms = &(cmd->data.setadapterparms);\n\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long)cmd);\n\tif (cmd->hdr.return_code) {\n\t\tQETH_CARD_TEXT_(card, 4, \"prmrc%2.2x\", cmd->hdr.return_code);\n\t\tsetparms->data.mode = SET_PROMISC_MODE_OFF;\n\t}\n\tcard->info.promisc_mode = setparms->data.mode;\n\treturn 0;\n}\n\nvoid qeth_setadp_promisc_mode(struct qeth_card *card)\n{\n\tenum qeth_ipa_promisc_modes mode;\n\tstruct net_device *dev = card->dev;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"setprom\");\n\n\tif (((dev->flags & IFF_PROMISC) &&\n\t     (card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||\n\t    (!(dev->flags & IFF_PROMISC) &&\n\t     (card->info.promisc_mode == SET_PROMISC_MODE_OFF)))\n\t\treturn;\n\tmode = SET_PROMISC_MODE_OFF;\n\tif (dev->flags & IFF_PROMISC)\n\t\tmode = SET_PROMISC_MODE_ON;\n\tQETH_CARD_TEXT_(card, 4, \"mode:%x\", mode);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_PROMISC_MODE,\n\t\t\tsizeof(struct qeth_ipacmd_setadpparms));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data + IPA_PDU_HEADER_SIZE);\n\tcmd->data.setadapterparms.data.mode = mode;\n\tqeth_send_ipa_cmd(card, iob, qeth_setadp_promisc_mode_cb, NULL);\n}\nEXPORT_SYMBOL_GPL(qeth_setadp_promisc_mode);\n\nint qeth_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct qeth_card *card;\n\tchar dbf_text[15];\n\n\tcard = dev->ml_priv;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmtu\");\n\tsprintf(dbf_text, \"%8x\", new_mtu);\n\tQETH_CARD_TEXT(card, 4, dbf_text);\n\n\tif (new_mtu < 64)\n\t\treturn -EINVAL;\n\tif (new_mtu > 65535)\n\t\treturn -EINVAL;\n\tif ((!qeth_is_supported(card, IPA_IP_FRAGMENTATION)) &&\n\t    (!qeth_mtu_is_valid(card, new_mtu)))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_change_mtu);\n\nstruct net_device_stats *qeth_get_stats(struct net_device *dev)\n{\n\tstruct qeth_card *card;\n\n\tcard = dev->ml_priv;\n\n\tQETH_CARD_TEXT(card, 5, \"getstat\");\n\n\treturn &card->stats;\n}\nEXPORT_SYMBOL_GPL(qeth_get_stats);\n\nstatic int qeth_setadpparms_change_macaddr_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmaccb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (!card->options.layer2 ||\n\t    !(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {\n\t\tmemcpy(card->dev->dev_addr,\n\t\t       &cmd->data.setadapterparms.data.change_addr.addr,\n\t\t       OSA_ADDR_LEN);\n\t\tcard->info.mac_bits |= QETH_LAYER2_MAC_READ;\n\t}\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\n\treturn 0;\n}\n\nint qeth_setadpparms_change_macaddr(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmac\");\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_ALTER_MAC_ADDRESS,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tcmd->data.setadapterparms.data.change_addr.cmd = CHANGE_ADDR_READ_MAC;\n\tcmd->data.setadapterparms.data.change_addr.addr_size = OSA_ADDR_LEN;\n\tmemcpy(&cmd->data.setadapterparms.data.change_addr.addr,\n\t       card->dev->dev_addr, OSA_ADDR_LEN);\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_change_macaddr_cb,\n\t\t\t       NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_setadpparms_change_macaddr);\n\nstatic int qeth_setadpparms_set_access_ctrl_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_set_access_ctrl *access_ctrl_req;\n\tint fallback = *(int *)reply->param;\n\n\tQETH_CARD_TEXT(card, 4, \"setaccb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\taccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\n\tQETH_DBF_TEXT_(SETUP, 2, \"setaccb\");\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", card->gdev->dev.kobj.name);\n\tQETH_DBF_TEXT_(SETUP, 2, \"rc=%d\",\n\t\tcmd->data.setadapterparms.hdr.return_code);\n\tif (cmd->data.setadapterparms.hdr.return_code !=\n\t\t\t\t\t\tSET_ACCESS_CTRL_RC_SUCCESS)\n\t\tQETH_DBF_MESSAGE(3, \"ERR:SET_ACCESS_CTRL(%s,%d)==%d\\n\",\n\t\t\t\tcard->gdev->dev.kobj.name,\n\t\t\t\taccess_ctrl_req->subcmd_code,\n\t\t\t\tcmd->data.setadapterparms.hdr.return_code);\n\tswitch (cmd->data.setadapterparms.hdr.return_code) {\n\tcase SET_ACCESS_CTRL_RC_SUCCESS:\n\t\tif (card->options.isolation == ISOLATION_MODE_NONE) {\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t    \"QDIO data connection isolation is deactivated\\n\");\n\t\t} else {\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t    \"QDIO data connection isolation is activated\\n\");\n\t\t}\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_ALREADY_NOT_ISOLATED:\n\t\tQETH_DBF_MESSAGE(2, \"%s QDIO data connection isolation already \"\n\t\t\t\t\"deactivated\\n\", dev_name(&card->gdev->dev));\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_ALREADY_ISOLATED:\n\t\tQETH_DBF_MESSAGE(2, \"%s QDIO data connection isolation already\"\n\t\t\t\t\" activated\\n\", dev_name(&card->gdev->dev));\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_NOT_SUPPORTED:\n\t\tdev_err(&card->gdev->dev, \"Adapter does not \"\n\t\t\t\"support QDIO data connection isolation\\n\");\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_NONE_SHARED_ADAPTER:\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"Adapter is dedicated. \"\n\t\t\t\"QDIO data connection isolation not supported\\n\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_ACTIVE_CHECKSUM_OFF:\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"TSO does not permit QDIO data connection isolation\\n\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_UNSUPPORTED:\n\t\tdev_err(&card->gdev->dev, \"The adjacent switch port does not \"\n\t\t\t\"support reflective relay mode\\n\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_FAILED:\n\t\tdev_err(&card->gdev->dev, \"The reflective relay mode cannot be \"\n\t\t\t\t\t\"enabled at the adjacent switch port\");\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_DEACT_FAILED:\n\t\tdev_warn(&card->gdev->dev, \"Turning off reflective relay mode \"\n\t\t\t\t\t\"at the adjacent switch failed\\n\");\n\t\tbreak;\n\tdefault:\n\t\t/* this should never happen */\n\t\tif (fallback)\n\t\t\tcard->options.isolation = card->options.prev_isolation;\n\t\tbreak;\n\t}\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\n\treturn 0;\n}\n\nstatic int qeth_setadpparms_set_access_ctrl(struct qeth_card *card,\n\t\tenum qeth_ipa_isolation_modes isolation, int fallback)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_set_access_ctrl *access_ctrl_req;\n\n\tQETH_CARD_TEXT(card, 4, \"setacctl\");\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"setacctl\");\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", card->gdev->dev.kobj.name);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_ACCESS_CONTROL,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms_hdr) +\n\t\t\t\t   sizeof(struct qeth_set_access_ctrl));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\taccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\n\taccess_ctrl_req->subcmd_code = isolation;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_set_access_ctrl_cb,\n\t\t\t       &fallback);\n\tQETH_DBF_TEXT_(SETUP, 2, \"rc=%d\", rc);\n\treturn rc;\n}\n\nint qeth_set_access_ctrl_online(struct qeth_card *card, int fallback)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 4, \"setactlo\");\n\n\tif ((card->info.type == QETH_CARD_TYPE_OSD ||\n\t     card->info.type == QETH_CARD_TYPE_OSX) &&\n\t     qeth_adp_supported(card, IPA_SETADP_SET_ACCESS_CONTROL)) {\n\t\trc = qeth_setadpparms_set_access_ctrl(card,\n\t\t\tcard->options.isolation, fallback);\n\t\tif (rc) {\n\t\t\tQETH_DBF_MESSAGE(3,\n\t\t\t\t\"IPA(SET_ACCESS_CTRL,%s,%d) sent failed\\n\",\n\t\t\t\tcard->gdev->dev.kobj.name,\n\t\t\t\trc);\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else if (card->options.isolation != ISOLATION_MODE_NONE) {\n\t\tcard->options.isolation = ISOLATION_MODE_NONE;\n\n\t\tdev_err(&card->gdev->dev, \"Adapter does not \"\n\t\t\t\"support QDIO data connection isolation\\n\");\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_set_access_ctrl_online);\n\nvoid qeth_tx_timeout(struct net_device *dev)\n{\n\tstruct qeth_card *card;\n\n\tcard = dev->ml_priv;\n\tQETH_CARD_TEXT(card, 4, \"txtimeo\");\n\tcard->stats.tx_errors++;\n\tqeth_schedule_recovery(card);\n}\nEXPORT_SYMBOL_GPL(qeth_tx_timeout);\n\nint qeth_mdio_read(struct net_device *dev, int phy_id, int regnum)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc = 0;\n\n\tswitch (regnum) {\n\tcase MII_BMCR: /* Basic mode control register */\n\t\trc = BMCR_FULLDPLX;\n\t\tif ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_OSN) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))\n\t\t\trc |= BMCR_SPEED100;\n\t\tbreak;\n\tcase MII_BMSR: /* Basic mode status register */\n\t\trc = BMSR_ERCAP | BMSR_ANEGCOMPLETE | BMSR_LSTATUS |\n\t\t     BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | BMSR_100FULL |\n\t\t     BMSR_100BASE4;\n\t\tbreak;\n\tcase MII_PHYSID1: /* PHYS ID 1 */\n\t\trc = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 8) |\n\t\t     dev->dev_addr[2];\n\t\trc = (rc >> 5) & 0xFFFF;\n\t\tbreak;\n\tcase MII_PHYSID2: /* PHYS ID 2 */\n\t\trc = (dev->dev_addr[2] << 10) & 0xFFFF;\n\t\tbreak;\n\tcase MII_ADVERTISE: /* Advertisement control reg */\n\t\trc = ADVERTISE_ALL;\n\t\tbreak;\n\tcase MII_LPA: /* Link partner ability reg */\n\t\trc = LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL |\n\t\t     LPA_100BASE4 | LPA_LPACK;\n\t\tbreak;\n\tcase MII_EXPANSION: /* Expansion register */\n\t\tbreak;\n\tcase MII_DCOUNTER: /* disconnect counter */\n\t\tbreak;\n\tcase MII_FCSCOUNTER: /* false carrier counter */\n\t\tbreak;\n\tcase MII_NWAYTEST: /* N-way auto-neg test register */\n\t\tbreak;\n\tcase MII_RERRCOUNTER: /* rx error counter */\n\t\trc = card->stats.rx_errors;\n\t\tbreak;\n\tcase MII_SREVISION: /* silicon revision */\n\t\tbreak;\n\tcase MII_RESV1: /* reserved 1 */\n\t\tbreak;\n\tcase MII_LBRERROR: /* loopback, rx, bypass error */\n\t\tbreak;\n\tcase MII_PHYADDR: /* physical address */\n\t\tbreak;\n\tcase MII_RESV2: /* reserved 2 */\n\t\tbreak;\n\tcase MII_TPISTATUS: /* TPI status for 10mbps */\n\t\tbreak;\n\tcase MII_NCONFIG: /* network interface config */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_mdio_read);\n\nstatic int qeth_send_ipa_snmp_cmd(struct qeth_card *card,\n\t\tstruct qeth_cmd_buffer *iob, int len,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tu16 s1, s2;\n\n\tQETH_CARD_TEXT(card, 4, \"sendsnmp\");\n\n\tmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\n\tmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n\t/* adjust PDU length fields in IPA_PDU_HEADER */\n\ts1 = (u32) IPA_PDU_HEADER_SIZE + len;\n\ts2 = (u32) len;\n\tmemcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);\n\treturn qeth_send_control_data(card, IPA_PDU_HEADER_SIZE + len, iob,\n\t\t\t\t      reply_cb, reply_param);\n}\n\nstatic int qeth_snmp_command_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long sdata)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_arp_query_info *qinfo;\n\tstruct qeth_snmp_cmd *snmp;\n\tunsigned char *data;\n\t__u16 data_len;\n\n\tQETH_CARD_TEXT(card, 3, \"snpcmdcb\");\n\n\tcmd = (struct qeth_ipa_cmd *) sdata;\n\tdata = (unsigned char *)((char *)cmd - reply->offset);\n\tqinfo = (struct qeth_arp_query_info *) reply->param;\n\tsnmp = &cmd->data.setadapterparms.data.snmp;\n\n\tif (cmd->hdr.return_code) {\n\t\tQETH_CARD_TEXT_(card, 4, \"scer1%i\", cmd->hdr.return_code);\n\t\treturn 0;\n\t}\n\tif (cmd->data.setadapterparms.hdr.return_code) {\n\t\tcmd->hdr.return_code =\n\t\t\tcmd->data.setadapterparms.hdr.return_code;\n\t\tQETH_CARD_TEXT_(card, 4, \"scer2%i\", cmd->hdr.return_code);\n\t\treturn 0;\n\t}\n\tdata_len = *((__u16 *)QETH_IPA_PDU_LEN_PDU1(data));\n\tif (cmd->data.setadapterparms.hdr.seq_no == 1)\n\t\tdata_len -= (__u16)((char *)&snmp->data - (char *)cmd);\n\telse\n\t\tdata_len -= (__u16)((char *)&snmp->request - (char *)cmd);\n\n\t/* check if there is enough room in userspace */\n\tif ((qinfo->udata_len - qinfo->udata_offset) < data_len) {\n\t\tQETH_CARD_TEXT_(card, 4, \"scer3%i\", -ENOMEM);\n\t\tcmd->hdr.return_code = IPA_RC_ENOMEM;\n\t\treturn 0;\n\t}\n\tQETH_CARD_TEXT_(card, 4, \"snore%i\",\n\t\t       cmd->data.setadapterparms.hdr.used_total);\n\tQETH_CARD_TEXT_(card, 4, \"sseqn%i\",\n\t\tcmd->data.setadapterparms.hdr.seq_no);\n\t/*copy entries to user buffer*/\n\tif (cmd->data.setadapterparms.hdr.seq_no == 1) {\n\t\tmemcpy(qinfo->udata + qinfo->udata_offset,\n\t\t       (char *)snmp,\n\t\t       data_len + offsetof(struct qeth_snmp_cmd, data));\n\t\tqinfo->udata_offset += offsetof(struct qeth_snmp_cmd, data);\n\t} else {\n\t\tmemcpy(qinfo->udata + qinfo->udata_offset,\n\t\t       (char *)&snmp->request, data_len);\n\t}\n\tqinfo->udata_offset += data_len;\n\t/* check if all replies received ... */\n\t\tQETH_CARD_TEXT_(card, 4, \"srtot%i\",\n\t\t\t       cmd->data.setadapterparms.hdr.used_total);\n\t\tQETH_CARD_TEXT_(card, 4, \"srseq%i\",\n\t\t\t       cmd->data.setadapterparms.hdr.seq_no);\n\tif (cmd->data.setadapterparms.hdr.seq_no <\n\t    cmd->data.setadapterparms.hdr.used_total)\n\t\treturn 1;\n\treturn 0;\n}\n\nint qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tunsigned int req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* skip 4 bytes (data_len struct member) to get req_len */\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tif (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -\n\t\t       sizeof(struct qeth_ipacmd_hdr) -\n\t\t       sizeof(struct qeth_ipacmd_setadpparms_hdr)))\n\t\treturn -EINVAL;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_snmp_command);\n\nstatic int qeth_setadpparms_query_oat_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_qoat_priv *priv;\n\tchar *resdata;\n\tint resdatalen;\n\n\tQETH_CARD_TEXT(card, 3, \"qoatcb\");\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\tpriv = (struct qeth_qoat_priv *)reply->param;\n\tresdatalen = cmd->data.setadapterparms.hdr.cmdlength;\n\tresdata = (char *)data + 28;\n\n\tif (resdatalen > (priv->buffer_len - priv->response_len)) {\n\t\tcmd->hdr.return_code = IPA_RC_FFFF;\n\t\treturn 0;\n\t}\n\n\tmemcpy((priv->buffer + priv->response_len), resdata,\n\t\tresdatalen);\n\tpriv->response_len += resdatalen;\n\n\tif (cmd->data.setadapterparms.hdr.seq_no <\n\t    cmd->data.setadapterparms.hdr.used_total)\n\t\treturn 1;\n\treturn 0;\n}\n\nint qeth_query_oat_command(struct qeth_card *card, char __user *udata)\n{\n\tint rc = 0;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_query_oat *oat_req;\n\tstruct qeth_query_oat_data oat_data;\n\tstruct qeth_qoat_priv priv;\n\tvoid __user *tmp;\n\n\tQETH_CARD_TEXT(card, 3, \"qoatcmd\");\n\n\tif (!qeth_adp_supported(card, IPA_SETADP_QUERY_OAT)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&oat_data, udata,\n\t    sizeof(struct qeth_query_oat_data))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t}\n\n\tpriv.buffer_len = oat_data.buffer_len;\n\tpriv.response_len = 0;\n\tpriv.buffer =  kzalloc(oat_data.buffer_len, GFP_KERNEL);\n\tif (!priv.buffer) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_OAT,\n\t\t\t\t   sizeof(struct qeth_ipacmd_setadpparms_hdr) +\n\t\t\t\t   sizeof(struct qeth_query_oat));\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\toat_req = &cmd->data.setadapterparms.data.query_oat;\n\toat_req->subcmd_code = oat_data.command;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_query_oat_cb,\n\t\t\t       &priv);\n\tif (!rc) {\n\t\tif (is_compat_task())\n\t\t\ttmp = compat_ptr(oat_data.ptr);\n\t\telse\n\t\t\ttmp = (void __user *)(unsigned long)oat_data.ptr;\n\n\t\tif (copy_to_user(tmp, priv.buffer,\n\t\t    priv.response_len)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\toat_data.response_len = priv.response_len;\n\n\t\tif (copy_to_user(udata, &oat_data,\n\t\t    sizeof(struct qeth_query_oat_data)))\n\t\t\trc = -EFAULT;\n\t} else\n\t\tif (rc == IPA_RC_FFFF)\n\t\t\trc = -EFAULT;\n\nout_free:\n\tkfree(priv.buffer);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_query_oat_command);\n\nstatic inline int qeth_get_qdio_q_format(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void qeth_determine_capabilities(struct qeth_card *card)\n{\n\tint rc;\n\tint length;\n\tchar *prcd;\n\tstruct ccw_device *ddev;\n\tint ddev_offline = 0;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"detcapab\");\n\tddev = CARD_DDEV(card);\n\tif (!ddev->online) {\n\t\tddev_offline = 1;\n\t\trc = ccw_device_set_online(ddev);\n\t\tif (rc) {\n\t\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = qeth_read_conf_data(card, (void **) &prcd, &length);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"%s qeth_read_conf_data returned %i\\n\",\n\t\t\tdev_name(&card->gdev->dev), rc);\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out_offline;\n\t}\n\tqeth_configure_unitaddr(card, prcd);\n\tif (ddev_offline)\n\t\tqeth_configure_blkt_default(card, prcd);\n\tkfree(prcd);\n\n\trc = qdio_get_ssqd_desc(ddev, &card->ssqd);\n\tif (rc)\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"6err%d\", rc);\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"qfmt%d\", card->ssqd.qfmt);\n\tQETH_DBF_TEXT_(SETUP, 2, \"%d\", card->ssqd.qdioac1);\n\tQETH_DBF_TEXT_(SETUP, 2, \"%d\", card->ssqd.qdioac3);\n\tQETH_DBF_TEXT_(SETUP, 2, \"icnt%d\", card->ssqd.icnt);\n\tif (!((card->ssqd.qfmt != QDIO_IQDIO_QFMT) ||\n\t    ((card->ssqd.qdioac1 & CHSC_AC1_INITIATE_INPUTQ) == 0) ||\n\t    ((card->ssqd.qdioac3 & CHSC_AC3_FORMAT2_CQ_AVAILABLE) == 0))) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t\"Completion Queueing supported\\n\");\n\t} else {\n\t\tcard->options.cq = QETH_CQ_NOTAVAILABLE;\n\t}\n\n\nout_offline:\n\tif (ddev_offline == 1)\n\t\tccw_device_set_offline(ddev);\nout:\n\treturn;\n}\n\nstatic inline void qeth_qdio_establish_cq(struct qeth_card *card,\n\tstruct qdio_buffer **in_sbal_ptrs,\n\tvoid (**queue_start_poll) (struct ccw_device *, int, unsigned long)) {\n\tint i;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tint offset = QDIO_MAX_BUFFERS_PER_Q *\n\t\t\t     (card->qdio.no_in_queues - 1);\n\t\ti = QDIO_MAX_BUFFERS_PER_Q * (card->qdio.no_in_queues - 1);\n\t\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\t\tin_sbal_ptrs[offset + i] = (struct qdio_buffer *)\n\t\t\t\tvirt_to_phys(card->qdio.c_q->bufs[i].buffer);\n\t\t}\n\n\t\tqueue_start_poll[card->qdio.no_in_queues - 1] = NULL;\n\t}\n}\n\nstatic int qeth_qdio_establish(struct qeth_card *card)\n{\n\tstruct qdio_initialize init_data;\n\tchar *qib_param_field;\n\tstruct qdio_buffer **in_sbal_ptrs;\n\tvoid (**queue_start_poll) (struct ccw_device *, int, unsigned long);\n\tstruct qdio_buffer **out_sbal_ptrs;\n\tint i, j, k;\n\tint rc = 0;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"qdioest\");\n\n\tqib_param_field = kzalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(char),\n\t\t\t      GFP_KERNEL);\n\tif (!qib_param_field) {\n\t\trc =  -ENOMEM;\n\t\tgoto out_free_nothing;\n\t}\n\n\tqeth_create_qib_param_field(card, qib_param_field);\n\tqeth_create_qib_param_field_blkt(card, qib_param_field);\n\n\tin_sbal_ptrs = kzalloc(card->qdio.no_in_queues *\n\t\t\t       QDIO_MAX_BUFFERS_PER_Q * sizeof(void *),\n\t\t\t       GFP_KERNEL);\n\tif (!in_sbal_ptrs) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_qib_param;\n\t}\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\n\t\tin_sbal_ptrs[i] = (struct qdio_buffer *)\n\t\t\tvirt_to_phys(card->qdio.in_q->bufs[i].buffer);\n\t}\n\n\tqueue_start_poll = kzalloc(sizeof(void *) * card->qdio.no_in_queues,\n\t\t\t\t   GFP_KERNEL);\n\tif (!queue_start_poll) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_in_sbals;\n\t}\n\tfor (i = 0; i < card->qdio.no_in_queues; ++i)\n\t\tqueue_start_poll[i] = card->discipline->start_poll;\n\n\tqeth_qdio_establish_cq(card, in_sbal_ptrs, queue_start_poll);\n\n\tout_sbal_ptrs =\n\t\tkzalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q *\n\t\t\tsizeof(void *), GFP_KERNEL);\n\tif (!out_sbal_ptrs) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_queue_start_poll;\n\t}\n\tfor (i = 0, k = 0; i < card->qdio.no_out_queues; ++i)\n\t\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j, ++k) {\n\t\t\tout_sbal_ptrs[k] = (struct qdio_buffer *)virt_to_phys(\n\t\t\t\tcard->qdio.out_qs[i]->bufs[j]->buffer);\n\t\t}\n\n\tmemset(&init_data, 0, sizeof(struct qdio_initialize));\n\tinit_data.cdev                   = CARD_DDEV(card);\n\tinit_data.q_format               = qeth_get_qdio_q_format(card);\n\tinit_data.qib_param_field_format = 0;\n\tinit_data.qib_param_field        = qib_param_field;\n\tinit_data.no_input_qs            = card->qdio.no_in_queues;\n\tinit_data.no_output_qs           = card->qdio.no_out_queues;\n\tinit_data.input_handler \t = card->discipline->input_handler;\n\tinit_data.output_handler\t = card->discipline->output_handler;\n\tinit_data.queue_start_poll_array = queue_start_poll;\n\tinit_data.int_parm               = (unsigned long) card;\n\tinit_data.input_sbal_addr_array  = (void **) in_sbal_ptrs;\n\tinit_data.output_sbal_addr_array = (void **) out_sbal_ptrs;\n\tinit_data.output_sbal_state_array = card->qdio.out_bufstates;\n\tinit_data.scan_threshold =\n\t\t(card->info.type == QETH_CARD_TYPE_IQD) ? 1 : 32;\n\n\tif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ALLOCATED,\n\t\tQETH_QDIO_ESTABLISHED) == QETH_QDIO_ALLOCATED) {\n\t\trc = qdio_allocate(&init_data);\n\t\tif (rc) {\n\t\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\t\tgoto out;\n\t\t}\n\t\trc = qdio_establish(&init_data);\n\t\tif (rc) {\n\t\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\t\tqdio_free(CARD_DDEV(card));\n\t\t}\n\t}\n\n\tswitch (card->options.cq) {\n\tcase QETH_CQ_ENABLED:\n\t\tdev_info(&card->gdev->dev, \"Completion Queue support enabled\");\n\t\tbreak;\n\tcase QETH_CQ_DISABLED:\n\t\tdev_info(&card->gdev->dev, \"Completion Queue support disabled\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\tkfree(out_sbal_ptrs);\nout_free_queue_start_poll:\n\tkfree(queue_start_poll);\nout_free_in_sbals:\n\tkfree(in_sbal_ptrs);\nout_free_qib_param:\n\tkfree(qib_param_field);\nout_free_nothing:\n\treturn rc;\n}\n\nstatic void qeth_core_free_card(struct qeth_card *card)\n{\n\n\tQETH_DBF_TEXT(SETUP, 2, \"freecrd\");\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\tqeth_clean_channel(&card->read);\n\tqeth_clean_channel(&card->write);\n\tif (card->dev)\n\t\tfree_netdev(card->dev);\n\tkfree(card->ip_tbd_list);\n\tqeth_free_qdio_buffers(card);\n\tunregister_service_level(&card->qeth_service_level);\n\tkfree(card);\n}\n\nvoid qeth_trace_features(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"features\");\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa4.supported_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa4.enabled_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa6.supported_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.ipa6.enabled_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.adp.supported_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->options.adp.enabled_funcs);\n\tQETH_CARD_TEXT_(card, 2, \"%x\", card->info.diagass_support);\n}\nEXPORT_SYMBOL_GPL(qeth_trace_features);\n\nstatic struct ccw_device_id qeth_ids[] = {\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x01, 0x1732, 0x01),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSD},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x05, 0x1732, 0x05),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_IQD},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x06, 0x1732, 0x06),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSN},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x02, 0x1732, 0x03),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSM},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x02, 0x1732, 0x02),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSX},\n\t{},\n};\nMODULE_DEVICE_TABLE(ccw, qeth_ids);\n\nstatic struct ccw_driver qeth_ccw_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"qeth\",\n\t},\n\t.ids = qeth_ids,\n\t.probe = ccwgroup_probe_ccwdev,\n\t.remove = ccwgroup_remove_ccwdev,\n};\n\nint qeth_core_hardsetup_card(struct qeth_card *card)\n{\n\tint retries = 3;\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"hrdsetup\");\n\tatomic_set(&card->force_alloc_skb, 0);\n\tqeth_update_from_chp_desc(card);\nretry:\n\tif (retries < 3)\n\t\tQETH_DBF_MESSAGE(2, \"%s Retrying to do IDX activates.\\n\",\n\t\t\tdev_name(&card->gdev->dev));\n\tccw_device_set_offline(CARD_DDEV(card));\n\tccw_device_set_offline(CARD_WDEV(card));\n\tccw_device_set_offline(CARD_RDEV(card));\n\trc = ccw_device_set_online(CARD_RDEV(card));\n\tif (rc)\n\t\tgoto retriable;\n\trc = ccw_device_set_online(CARD_WDEV(card));\n\tif (rc)\n\t\tgoto retriable;\n\trc = ccw_device_set_online(CARD_DDEV(card));\n\tif (rc)\n\t\tgoto retriable;\n\trc = qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);\nretriable:\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"break1\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\tqeth_determine_capabilities(card);\n\tqeth_init_tokens(card);\n\tqeth_init_func_level(card);\n\trc = qeth_idx_activate_channel(&card->read, qeth_idx_read_cb);\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"break2\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\trc = qeth_idx_activate_channel(&card->write, qeth_idx_write_cb);\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"break3\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"4err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\tcard->read_or_write_problem = 0;\n\trc = qeth_mpc_initialize(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"5err%d\", rc);\n\t\tgoto out;\n\t}\n\n\tcard->options.ipa4.supported_funcs = 0;\n\tcard->options.adp.supported_funcs = 0;\n\tcard->info.diagass_support = 0;\n\tqeth_query_ipassists(card, QETH_PROT_IPV4);\n\tif (qeth_is_supported(card, IPA_SETADAPTERPARMS))\n\t\tqeth_query_setadapterparms(card);\n\tif (qeth_adp_supported(card, IPA_SETADP_SET_DIAG_ASSIST))\n\t\tqeth_query_setdiagass(card);\n\treturn 0;\nout:\n\tdev_warn(&card->gdev->dev, \"The qeth device driver failed to recover \"\n\t\t\"an error on the device\\n\");\n\tQETH_DBF_MESSAGE(2, \"%s Initialization in hardsetup failed! rc=%d\\n\",\n\t\tdev_name(&card->gdev->dev), rc);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_core_hardsetup_card);\n\nstatic inline int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,\n\t\tstruct qdio_buffer_element *element,\n\t\tstruct sk_buff **pskb, int offset, int *pfrag, int data_len)\n{\n\tstruct page *page = virt_to_page(element->addr);\n\tif (*pskb == NULL) {\n\t\tif (qethbuffer->rx_skb) {\n\t\t\t/* only if qeth_card.options.cq == QETH_CQ_ENABLED */\n\t\t\t*pskb = qethbuffer->rx_skb;\n\t\t\tqethbuffer->rx_skb = NULL;\n\t\t} else {\n\t\t\t*pskb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\n\t\t\tif (!(*pskb))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_reserve(*pskb, ETH_HLEN);\n\t\tif (data_len <= QETH_RX_PULL_LEN) {\n\t\t\tmemcpy(skb_put(*pskb, data_len), element->addr + offset,\n\t\t\t\tdata_len);\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tmemcpy(skb_put(*pskb, QETH_RX_PULL_LEN),\n\t\t\t       element->addr + offset, QETH_RX_PULL_LEN);\n\t\t\tskb_fill_page_desc(*pskb, *pfrag, page,\n\t\t\t\toffset + QETH_RX_PULL_LEN,\n\t\t\t\tdata_len - QETH_RX_PULL_LEN);\n\t\t\t(*pskb)->data_len += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pskb)->len      += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pskb)->truesize += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pfrag)++;\n\t\t}\n\t} else {\n\t\tget_page(page);\n\t\tskb_fill_page_desc(*pskb, *pfrag, page, offset, data_len);\n\t\t(*pskb)->data_len += data_len;\n\t\t(*pskb)->len      += data_len;\n\t\t(*pskb)->truesize += data_len;\n\t\t(*pfrag)++;\n\t}\n\n\n\treturn 0;\n}\n\nstruct sk_buff *qeth_core_get_next_skb(struct qeth_card *card,\n\t\tstruct qeth_qdio_buffer *qethbuffer,\n\t\tstruct qdio_buffer_element **__element, int *__offset,\n\t\tstruct qeth_hdr **hdr)\n{\n\tstruct qdio_buffer_element *element = *__element;\n\tstruct qdio_buffer *buffer = qethbuffer->buffer;\n\tint offset = *__offset;\n\tstruct sk_buff *skb = NULL;\n\tint skb_len = 0;\n\tvoid *data_ptr;\n\tint data_len;\n\tint headroom = 0;\n\tint use_rx_sg = 0;\n\tint frag = 0;\n\n\t/* qeth_hdr must not cross element boundaries */\n\tif (element->length < offset + sizeof(struct qeth_hdr)) {\n\t\tif (qeth_is_last_sbale(element))\n\t\t\treturn NULL;\n\t\telement++;\n\t\toffset = 0;\n\t\tif (element->length < sizeof(struct qeth_hdr))\n\t\t\treturn NULL;\n\t}\n\t*hdr = element->addr + offset;\n\n\toffset += sizeof(struct qeth_hdr);\n\tswitch ((*hdr)->hdr.l2.id) {\n\tcase QETH_HEADER_TYPE_LAYER2:\n\t\tskb_len = (*hdr)->hdr.l2.pkt_length;\n\t\tbreak;\n\tcase QETH_HEADER_TYPE_LAYER3:\n\t\tskb_len = (*hdr)->hdr.l3.length;\n\t\theadroom = ETH_HLEN;\n\t\tbreak;\n\tcase QETH_HEADER_TYPE_OSN:\n\t\tskb_len = (*hdr)->hdr.osn.pdu_length;\n\t\theadroom = sizeof(struct qeth_hdr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!skb_len)\n\t\treturn NULL;\n\n\tif (((skb_len >= card->options.rx_sg_cb) &&\n\t     (!(card->info.type == QETH_CARD_TYPE_OSN)) &&\n\t     (!atomic_read(&card->force_alloc_skb))) ||\n\t    (card->options.cq == QETH_CQ_ENABLED)) {\n\t\tuse_rx_sg = 1;\n\t} else {\n\t\tskb = dev_alloc_skb(skb_len + headroom);\n\t\tif (!skb)\n\t\t\tgoto no_mem;\n\t\tif (headroom)\n\t\t\tskb_reserve(skb, headroom);\n\t}\n\n\tdata_ptr = element->addr + offset;\n\twhile (skb_len) {\n\t\tdata_len = min(skb_len, (int)(element->length - offset));\n\t\tif (data_len) {\n\t\t\tif (use_rx_sg) {\n\t\t\t\tif (qeth_create_skb_frag(qethbuffer, element,\n\t\t\t\t    &skb, offset, &frag, data_len))\n\t\t\t\t\tgoto no_mem;\n\t\t\t} else {\n\t\t\t\tmemcpy(skb_put(skb, data_len), data_ptr,\n\t\t\t\t\tdata_len);\n\t\t\t}\n\t\t}\n\t\tskb_len -= data_len;\n\t\tif (skb_len) {\n\t\t\tif (qeth_is_last_sbale(element)) {\n\t\t\t\tQETH_CARD_TEXT(card, 4, \"unexeob\");\n\t\t\t\tQETH_CARD_HEX(card, 2, buffer, sizeof(void *));\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tcard->stats.rx_errors++;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telement++;\n\t\t\toffset = 0;\n\t\t\tdata_ptr = element->addr;\n\t\t} else {\n\t\t\toffset += data_len;\n\t\t}\n\t}\n\t*__element = element;\n\t*__offset = offset;\n\tif (use_rx_sg && card->options.performance_stats) {\n\t\tcard->perf_stats.sg_skbs_rx++;\n\t\tcard->perf_stats.sg_frags_rx += skb_shinfo(skb)->nr_frags;\n\t}\n\treturn skb;\nno_mem:\n\tif (net_ratelimit()) {\n\t\tQETH_CARD_TEXT(card, 2, \"noskbmem\");\n\t}\n\tcard->stats.rx_dropped++;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_next_skb);\n\nstatic void qeth_unregister_dbf_views(void)\n{\n\tint x;\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\tdebug_unregister(qeth_dbf[x].id);\n\t\tqeth_dbf[x].id = NULL;\n\t}\n}\n\nvoid qeth_dbf_longtext(debug_info_t *id, int level, char *fmt, ...)\n{\n\tchar dbf_txt_buf[32];\n\tva_list args;\n\n\tif (level > id->level)\n\t\treturn;\n\tva_start(args, fmt);\n\tvsnprintf(dbf_txt_buf, sizeof(dbf_txt_buf), fmt, args);\n\tva_end(args);\n\tdebug_text_event(id, level, dbf_txt_buf);\n}\nEXPORT_SYMBOL_GPL(qeth_dbf_longtext);\n\nstatic int qeth_register_dbf_views(void)\n{\n\tint ret;\n\tint x;\n\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\t/* register the areas */\n\t\tqeth_dbf[x].id = debug_register(qeth_dbf[x].name,\n\t\t\t\t\t\tqeth_dbf[x].pages,\n\t\t\t\t\t\tqeth_dbf[x].areas,\n\t\t\t\t\t\tqeth_dbf[x].len);\n\t\tif (qeth_dbf[x].id == NULL) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* register a view */\n\t\tret = debug_register_view(qeth_dbf[x].id, qeth_dbf[x].view);\n\t\tif (ret) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* set a passing level */\n\t\tdebug_set_level(qeth_dbf[x].id, qeth_dbf[x].level);\n\t}\n\n\treturn 0;\n}\n\nint qeth_core_load_discipline(struct qeth_card *card,\n\t\tenum qeth_discipline_id discipline)\n{\n\tint rc = 0;\n\tmutex_lock(&qeth_mod_mutex);\n\tswitch (discipline) {\n\tcase QETH_DISCIPLINE_LAYER3:\n\t\tcard->discipline = try_then_request_module(\n\t\t\tsymbol_get(qeth_l3_discipline), \"qeth_l3\");\n\t\tbreak;\n\tcase QETH_DISCIPLINE_LAYER2:\n\t\tcard->discipline = try_then_request_module(\n\t\t\tsymbol_get(qeth_l2_discipline), \"qeth_l2\");\n\t\tbreak;\n\t}\n\tif (!card->discipline) {\n\t\tdev_err(&card->gdev->dev, \"There is no kernel module to \"\n\t\t\t\"support discipline %d\\n\", discipline);\n\t\trc = -EINVAL;\n\t}\n\tmutex_unlock(&qeth_mod_mutex);\n\treturn rc;\n}\n\nvoid qeth_core_free_discipline(struct qeth_card *card)\n{\n\tif (card->options.layer2)\n\t\tsymbol_put(qeth_l2_discipline);\n\telse\n\t\tsymbol_put(qeth_l3_discipline);\n\tcard->discipline = NULL;\n}\n\nstatic const struct device_type qeth_generic_devtype = {\n\t.name = \"qeth_generic\",\n\t.groups = qeth_generic_attr_groups,\n};\nstatic const struct device_type qeth_osn_devtype = {\n\t.name = \"qeth_osn\",\n\t.groups = qeth_osn_attr_groups,\n};\n\n#define DBF_NAME_LEN\t20\n\nstruct qeth_dbf_entry {\n\tchar dbf_name[DBF_NAME_LEN];\n\tdebug_info_t *dbf_info;\n\tstruct list_head dbf_list;\n};\n\nstatic LIST_HEAD(qeth_dbf_list);\nstatic DEFINE_MUTEX(qeth_dbf_list_mutex);\n\nstatic debug_info_t *qeth_get_dbf_entry(char *name)\n{\n\tstruct qeth_dbf_entry *entry;\n\tdebug_info_t *rc = NULL;\n\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_for_each_entry(entry, &qeth_dbf_list, dbf_list) {\n\t\tif (strcmp(entry->dbf_name, name) == 0) {\n\t\t\trc = entry->dbf_info;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&qeth_dbf_list_mutex);\n\treturn rc;\n}\n\nstatic int qeth_add_dbf_entry(struct qeth_card *card, char *name)\n{\n\tstruct qeth_dbf_entry *new_entry;\n\n\tcard->debug = debug_register(name, 2, 1, 8);\n\tif (!card->debug) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", \"qcdbf\");\n\t\tgoto err;\n\t}\n\tif (debug_register_view(card->debug, &debug_hex_ascii_view))\n\t\tgoto err_dbg;\n\tnew_entry = kzalloc(sizeof(struct qeth_dbf_entry), GFP_KERNEL);\n\tif (!new_entry)\n\t\tgoto err_dbg;\n\tstrncpy(new_entry->dbf_name, name, DBF_NAME_LEN);\n\tnew_entry->dbf_info = card->debug;\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_add(&new_entry->dbf_list, &qeth_dbf_list);\n\tmutex_unlock(&qeth_dbf_list_mutex);\n\n\treturn 0;\n\nerr_dbg:\n\tdebug_unregister(card->debug);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void qeth_clear_dbf_list(void)\n{\n\tstruct qeth_dbf_entry *entry, *tmp;\n\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_for_each_entry_safe(entry, tmp, &qeth_dbf_list, dbf_list) {\n\t\tlist_del(&entry->dbf_list);\n\t\tdebug_unregister(entry->dbf_info);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&qeth_dbf_list_mutex);\n}\n\nstatic int qeth_core_probe_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card;\n\tstruct device *dev;\n\tint rc;\n\tunsigned long flags;\n\tchar dbf_name[DBF_NAME_LEN];\n\n\tQETH_DBF_TEXT(SETUP, 2, \"probedev\");\n\n\tdev = &gdev->dev;\n\tif (!get_device(dev))\n\t\treturn -ENODEV;\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", dev_name(&gdev->dev));\n\n\tcard = qeth_alloc_card();\n\tif (!card) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", -ENOMEM);\n\t\trc = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\n\tsnprintf(dbf_name, sizeof(dbf_name), \"qeth_card_%s\",\n\t\tdev_name(&gdev->dev));\n\tcard->debug = qeth_get_dbf_entry(dbf_name);\n\tif (!card->debug) {\n\t\trc = qeth_add_dbf_entry(card, dbf_name);\n\t\tif (rc)\n\t\t\tgoto err_card;\n\t}\n\n\tcard->read.ccwdev  = gdev->cdev[0];\n\tcard->write.ccwdev = gdev->cdev[1];\n\tcard->data.ccwdev  = gdev->cdev[2];\n\tdev_set_drvdata(&gdev->dev, card);\n\tcard->gdev = gdev;\n\tgdev->cdev[0]->handler = qeth_irq;\n\tgdev->cdev[1]->handler = qeth_irq;\n\tgdev->cdev[2]->handler = qeth_irq;\n\n\trc = qeth_determine_card_type(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"3err%d\", rc);\n\t\tgoto err_card;\n\t}\n\trc = qeth_setup_card(card);\n\tif (rc) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"2err%d\", rc);\n\t\tgoto err_card;\n\t}\n\n\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\tgdev->dev.type = &qeth_osn_devtype;\n\telse\n\t\tgdev->dev.type = &qeth_generic_devtype;\n\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSN:\n\tcase QETH_CARD_TYPE_OSM:\n\t\trc = qeth_core_load_discipline(card, QETH_DISCIPLINE_LAYER2);\n\t\tif (rc)\n\t\t\tgoto err_card;\n\t\trc = card->discipline->setup(card->gdev);\n\t\tif (rc)\n\t\t\tgoto err_disc;\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSX:\n\tdefault:\n\t\tbreak;\n\t}\n\n\twrite_lock_irqsave(&qeth_core_card_list.rwlock, flags);\n\tlist_add_tail(&card->list, &qeth_core_card_list.list);\n\twrite_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\n\n\tqeth_determine_capabilities(card);\n\treturn 0;\n\nerr_disc:\n\tqeth_core_free_discipline(card);\nerr_card:\n\tqeth_core_free_card(card);\nerr_dev:\n\tput_device(dev);\n\treturn rc;\n}\n\nstatic void qeth_core_remove_device(struct ccwgroup_device *gdev)\n{\n\tunsigned long flags;\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\n\tQETH_DBF_TEXT(SETUP, 2, \"removedv\");\n\n\tif (card->discipline) {\n\t\tcard->discipline->remove(gdev);\n\t\tqeth_core_free_discipline(card);\n\t}\n\n\twrite_lock_irqsave(&qeth_core_card_list.rwlock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\n\tqeth_core_free_card(card);\n\tdev_set_drvdata(&gdev->dev, NULL);\n\tput_device(&gdev->dev);\n\treturn;\n}\n\nstatic int qeth_core_set_online(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tint rc = 0;\n\tint def_discipline;\n\n\tif (!card->discipline) {\n\t\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\t\tdef_discipline = QETH_DISCIPLINE_LAYER3;\n\t\telse\n\t\t\tdef_discipline = QETH_DISCIPLINE_LAYER2;\n\t\trc = qeth_core_load_discipline(card, def_discipline);\n\t\tif (rc)\n\t\t\tgoto err;\n\t\trc = card->discipline->setup(card->gdev);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\trc = card->discipline->set_online(gdev);\nerr:\n\treturn rc;\n}\n\nstatic int qeth_core_set_offline(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\treturn card->discipline->set_offline(gdev);\n}\n\nstatic void qeth_core_shutdown(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->shutdown)\n\t\tcard->discipline->shutdown(gdev);\n}\n\nstatic int qeth_core_prepare(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->prepare)\n\t\treturn card->discipline->prepare(gdev);\n\treturn 0;\n}\n\nstatic void qeth_core_complete(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->complete)\n\t\tcard->discipline->complete(gdev);\n}\n\nstatic int qeth_core_freeze(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->freeze)\n\t\treturn card->discipline->freeze(gdev);\n\treturn 0;\n}\n\nstatic int qeth_core_thaw(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->thaw)\n\t\treturn card->discipline->thaw(gdev);\n\treturn 0;\n}\n\nstatic int qeth_core_restore(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->restore)\n\t\treturn card->discipline->restore(gdev);\n\treturn 0;\n}\n\nstatic struct ccwgroup_driver qeth_core_ccwgroup_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"qeth\",\n\t},\n\t.setup = qeth_core_probe_device,\n\t.remove = qeth_core_remove_device,\n\t.set_online = qeth_core_set_online,\n\t.set_offline = qeth_core_set_offline,\n\t.shutdown = qeth_core_shutdown,\n\t.prepare = qeth_core_prepare,\n\t.complete = qeth_core_complete,\n\t.freeze = qeth_core_freeze,\n\t.thaw = qeth_core_thaw,\n\t.restore = qeth_core_restore,\n};\n\nstatic ssize_t qeth_core_driver_group_store(struct device_driver *ddrv,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tint err;\n\n\terr = ccwgroup_create_dev(qeth_core_root_dev,\n\t\t\t\t  &qeth_core_ccwgroup_driver, 3, buf);\n\n\treturn err ? err : count;\n}\nstatic DRIVER_ATTR(group, 0200, NULL, qeth_core_driver_group_store);\n\nstatic struct attribute *qeth_drv_attrs[] = {\n\t&driver_attr_group.attr,\n\tNULL,\n};\nstatic struct attribute_group qeth_drv_attr_group = {\n\t.attrs = qeth_drv_attrs,\n};\nstatic const struct attribute_group *qeth_drv_attr_groups[] = {\n\t&qeth_drv_attr_group,\n\tNULL,\n};\n\nstatic struct {\n\tconst char str[ETH_GSTRING_LEN];\n} qeth_ethtool_stats_keys[] = {\n/*  0 */{\"rx skbs\"},\n\t{\"rx buffers\"},\n\t{\"tx skbs\"},\n\t{\"tx buffers\"},\n\t{\"tx skbs no packing\"},\n\t{\"tx buffers no packing\"},\n\t{\"tx skbs packing\"},\n\t{\"tx buffers packing\"},\n\t{\"tx sg skbs\"},\n\t{\"tx sg frags\"},\n/* 10 */{\"rx sg skbs\"},\n\t{\"rx sg frags\"},\n\t{\"rx sg page allocs\"},\n\t{\"tx large kbytes\"},\n\t{\"tx large count\"},\n\t{\"tx pk state ch n->p\"},\n\t{\"tx pk state ch p->n\"},\n\t{\"tx pk watermark low\"},\n\t{\"tx pk watermark high\"},\n\t{\"queue 0 buffer usage\"},\n/* 20 */{\"queue 1 buffer usage\"},\n\t{\"queue 2 buffer usage\"},\n\t{\"queue 3 buffer usage\"},\n\t{\"rx poll time\"},\n\t{\"rx poll count\"},\n\t{\"rx do_QDIO time\"},\n\t{\"rx do_QDIO count\"},\n\t{\"tx handler time\"},\n\t{\"tx handler count\"},\n\t{\"tx time\"},\n/* 30 */{\"tx count\"},\n\t{\"tx do_QDIO time\"},\n\t{\"tx do_QDIO count\"},\n\t{\"tx csum\"},\n\t{\"tx lin\"},\n\t{\"cq handler count\"},\n\t{\"cq handler time\"}\n};\n\nint qeth_core_get_sset_count(struct net_device *dev, int stringset)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\treturn (sizeof(qeth_ethtool_stats_keys) / ETH_GSTRING_LEN);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_sset_count);\n\nvoid qeth_core_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tdata[0] = card->stats.rx_packets -\n\t\t\t\tcard->perf_stats.initial_rx_packets;\n\tdata[1] = card->perf_stats.bufs_rec;\n\tdata[2] = card->stats.tx_packets -\n\t\t\t\tcard->perf_stats.initial_tx_packets;\n\tdata[3] = card->perf_stats.bufs_sent;\n\tdata[4] = card->stats.tx_packets - card->perf_stats.initial_tx_packets\n\t\t\t- card->perf_stats.skbs_sent_pack;\n\tdata[5] = card->perf_stats.bufs_sent - card->perf_stats.bufs_sent_pack;\n\tdata[6] = card->perf_stats.skbs_sent_pack;\n\tdata[7] = card->perf_stats.bufs_sent_pack;\n\tdata[8] = card->perf_stats.sg_skbs_sent;\n\tdata[9] = card->perf_stats.sg_frags_sent;\n\tdata[10] = card->perf_stats.sg_skbs_rx;\n\tdata[11] = card->perf_stats.sg_frags_rx;\n\tdata[12] = card->perf_stats.sg_alloc_page_rx;\n\tdata[13] = (card->perf_stats.large_send_bytes >> 10);\n\tdata[14] = card->perf_stats.large_send_cnt;\n\tdata[15] = card->perf_stats.sc_dp_p;\n\tdata[16] = card->perf_stats.sc_p_dp;\n\tdata[17] = QETH_LOW_WATERMARK_PACK;\n\tdata[18] = QETH_HIGH_WATERMARK_PACK;\n\tdata[19] = atomic_read(&card->qdio.out_qs[0]->used_buffers);\n\tdata[20] = (card->qdio.no_out_queues > 1) ?\n\t\t\tatomic_read(&card->qdio.out_qs[1]->used_buffers) : 0;\n\tdata[21] = (card->qdio.no_out_queues > 2) ?\n\t\t\tatomic_read(&card->qdio.out_qs[2]->used_buffers) : 0;\n\tdata[22] = (card->qdio.no_out_queues > 3) ?\n\t\t\tatomic_read(&card->qdio.out_qs[3]->used_buffers) : 0;\n\tdata[23] = card->perf_stats.inbound_time;\n\tdata[24] = card->perf_stats.inbound_cnt;\n\tdata[25] = card->perf_stats.inbound_do_qdio_time;\n\tdata[26] = card->perf_stats.inbound_do_qdio_cnt;\n\tdata[27] = card->perf_stats.outbound_handler_time;\n\tdata[28] = card->perf_stats.outbound_handler_cnt;\n\tdata[29] = card->perf_stats.outbound_time;\n\tdata[30] = card->perf_stats.outbound_cnt;\n\tdata[31] = card->perf_stats.outbound_do_qdio_time;\n\tdata[32] = card->perf_stats.outbound_do_qdio_cnt;\n\tdata[33] = card->perf_stats.tx_csum;\n\tdata[34] = card->perf_stats.tx_lin;\n\tdata[35] = card->perf_stats.cq_cnt;\n\tdata[36] = card->perf_stats.cq_time;\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_ethtool_stats);\n\nvoid qeth_core_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, &qeth_ethtool_stats_keys,\n\t\t\tsizeof(qeth_ethtool_stats_keys));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_strings);\n\nvoid qeth_core_get_drvinfo(struct net_device *dev,\n\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tstrlcpy(info->driver, card->options.layer2 ? \"qeth_l2\" : \"qeth_l3\",\n\t\tsizeof(info->driver));\n\tstrlcpy(info->version, \"1.0\", sizeof(info->version));\n\tstrlcpy(info->fw_version, card->info.mcl_level,\n\t\tsizeof(info->fw_version));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"%s/%s/%s\",\n\t\t CARD_RDEV_ID(card), CARD_WDEV_ID(card), CARD_DDEV_ID(card));\n}\nEXPORT_SYMBOL_GPL(qeth_core_get_drvinfo);\n\nint qeth_core_ethtool_get_settings(struct net_device *netdev,\n\t\t\t\t\tstruct ethtool_cmd *ecmd)\n{\n\tstruct qeth_card *card = netdev->ml_priv;\n\tenum qeth_link_types link_type;\n\n\tif ((card->info.type == QETH_CARD_TYPE_IQD) || (card->info.guestlan))\n\t\tlink_type = QETH_LINK_TYPE_10GBIT_ETH;\n\telse\n\t\tlink_type = card->info.link_type;\n\n\tecmd->transceiver = XCVR_INTERNAL;\n\tecmd->supported = SUPPORTED_Autoneg;\n\tecmd->advertising = ADVERTISED_Autoneg;\n\tecmd->duplex = DUPLEX_FULL;\n\tecmd->autoneg = AUTONEG_ENABLE;\n\n\tswitch (link_type) {\n\tcase QETH_LINK_TYPE_FAST_ETH:\n\tcase QETH_LINK_TYPE_LANE_ETH100:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_100baseT_Half |\n\t\t\t\t\tSUPPORTED_100baseT_Full |\n\t\t\t\t\tSUPPORTED_TP;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_TP;\n\t\tecmd->speed = SPEED_100;\n\t\tecmd->port = PORT_TP;\n\t\tbreak;\n\n\tcase QETH_LINK_TYPE_GBIT_ETH:\n\tcase QETH_LINK_TYPE_LANE_ETH1000:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_100baseT_Half |\n\t\t\t\t\tSUPPORTED_100baseT_Full |\n\t\t\t\t\tSUPPORTED_1000baseT_Half |\n\t\t\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\t\t\tSUPPORTED_FIBRE;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_1000baseT_Half |\n\t\t\t\t\tADVERTISED_1000baseT_Full |\n\t\t\t\t\tADVERTISED_FIBRE;\n\t\tecmd->speed = SPEED_1000;\n\t\tecmd->port = PORT_FIBRE;\n\t\tbreak;\n\n\tcase QETH_LINK_TYPE_10GBIT_ETH:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_100baseT_Half |\n\t\t\t\t\tSUPPORTED_100baseT_Full |\n\t\t\t\t\tSUPPORTED_1000baseT_Half |\n\t\t\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\t\t\tSUPPORTED_10000baseT_Full |\n\t\t\t\t\tSUPPORTED_FIBRE;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_1000baseT_Half |\n\t\t\t\t\tADVERTISED_1000baseT_Full |\n\t\t\t\t\tADVERTISED_10000baseT_Full |\n\t\t\t\t\tADVERTISED_FIBRE;\n\t\tecmd->speed = SPEED_10000;\n\t\tecmd->port = PORT_FIBRE;\n\t\tbreak;\n\n\tdefault:\n\t\tecmd->supported |= SUPPORTED_10baseT_Half |\n\t\t\t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_TP;\n\t\tecmd->advertising |= ADVERTISED_10baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\t\tADVERTISED_TP;\n\t\tecmd->speed = SPEED_10;\n\t\tecmd->port = PORT_TP;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_core_ethtool_get_settings);\n\nstatic int __init qeth_core_init(void)\n{\n\tint rc;\n\n\tpr_info(\"loading core functions\\n\");\n\tINIT_LIST_HEAD(&qeth_core_card_list.list);\n\tINIT_LIST_HEAD(&qeth_dbf_list);\n\trwlock_init(&qeth_core_card_list.rwlock);\n\tmutex_init(&qeth_mod_mutex);\n\n\tqeth_wq = create_singlethread_workqueue(\"qeth_wq\");\n\n\trc = qeth_register_dbf_views();\n\tif (rc)\n\t\tgoto out_err;\n\tqeth_core_root_dev = root_device_register(\"qeth\");\n\trc = PTR_RET(qeth_core_root_dev);\n\tif (rc)\n\t\tgoto register_err;\n\tqeth_core_header_cache = kmem_cache_create(\"qeth_hdr\",\n\t\t\tsizeof(struct qeth_hdr) + ETH_HLEN, 64, 0, NULL);\n\tif (!qeth_core_header_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto slab_err;\n\t}\n\tqeth_qdio_outbuf_cache = kmem_cache_create(\"qeth_buf\",\n\t\t\tsizeof(struct qeth_qdio_out_buffer), 0, 0, NULL);\n\tif (!qeth_qdio_outbuf_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto cqslab_err;\n\t}\n\trc = ccw_driver_register(&qeth_ccw_driver);\n\tif (rc)\n\t\tgoto ccw_err;\n\tqeth_core_ccwgroup_driver.driver.groups = qeth_drv_attr_groups;\n\trc = ccwgroup_driver_register(&qeth_core_ccwgroup_driver);\n\tif (rc)\n\t\tgoto ccwgroup_err;\n\n\treturn 0;\n\nccwgroup_err:\n\tccw_driver_unregister(&qeth_ccw_driver);\nccw_err:\n\tkmem_cache_destroy(qeth_qdio_outbuf_cache);\ncqslab_err:\n\tkmem_cache_destroy(qeth_core_header_cache);\nslab_err:\n\troot_device_unregister(qeth_core_root_dev);\nregister_err:\n\tqeth_unregister_dbf_views();\nout_err:\n\tpr_err(\"Initializing the qeth device driver failed\\n\");\n\treturn rc;\n}\n\nstatic void __exit qeth_core_exit(void)\n{\n\tqeth_clear_dbf_list();\n\tdestroy_workqueue(qeth_wq);\n\tccwgroup_driver_unregister(&qeth_core_ccwgroup_driver);\n\tccw_driver_unregister(&qeth_ccw_driver);\n\tkmem_cache_destroy(qeth_qdio_outbuf_cache);\n\tkmem_cache_destroy(qeth_core_header_cache);\n\troot_device_unregister(qeth_core_root_dev);\n\tqeth_unregister_dbf_views();\n\tpr_info(\"core functions removed\\n\");\n}\n\nmodule_init(qeth_core_init);\nmodule_exit(qeth_core_exit);\nMODULE_AUTHOR(\"Frank Blaschka <frank.blaschka@de.ibm.com>\");\nMODULE_DESCRIPTION(\"qeth core functions\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/s390/net/qeth_core_main.c"], "buggy_code_start_loc": [4454], "buggy_code_end_loc": [4469], "fixing_code_start_loc": [4454], "fixing_code_end_loc": [4474], "type": "CWE-119", "message": "Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size.", "other": {"cve": {"id": "CVE-2013-6381", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-27T04:43:33.200", "lastModified": "2023-02-13T04:49:49.593", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n qeth_snmp_command de drivers/s390/net/qeth_core_main.c en el kernel de Linux hasta la versi\u00f3n 3.12.1 permite a usuarios locales provocar una denegaci\u00f3n de servicio o posiblemente provocar otro impacto sin especificar a trav\u00e9s de una llamada ioctl con un valor largo que es incompatible con el tama\u00f1o del b\u00fafer de comando."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.12.1", "matchCriteriaId": "3E5AFED7-B198-4A43-B496-CD6B399748A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.7:*:*:*:*:*:*:*", "matchCriteriaId": "2422AC23-8410-4524-A733-25E4ABC7515D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B291154A-4B91-4A0E-AAAE-716A8BB7BF99"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0159.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0284.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0285.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/22/5", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/63890", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1033600", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62"}}