{"buggy_code": ["// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage banking\n\nimport (\n\t\"errors\"\n\t\"sync/atomic\"\n\n\t\"code.vegaprotocol.io/vega/core/assets\"\n\t\"code.vegaprotocol.io/vega/core/assets/common\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\tsnapshot \"code.vegaprotocol.io/vega/protos/vega/snapshot/v1\"\n)\n\nvar ErrUnknownAssetAction = errors.New(\"unknown asset action\")\n\ntype assetAction struct {\n\tid    string\n\tstate *atomic.Uint32\n\tasset *assets.Asset\n\n\t// erc20 specifics\n\tblockHeight uint64\n\tlogIndex    uint64\n\ttxHash      string\n\n\t// all deposit related types\n\tbuiltinD *types.BuiltinAssetDeposit\n\terc20D   *types.ERC20Deposit\n\terc20AL  *types.ERC20AssetList\n\n\terc20AssetLimitsUpdated *types.ERC20AssetLimitsUpdated\n\n\terc20BridgeStopped *types.ERC20EventBridgeStopped\n\terc20BridgeResumed *types.ERC20EventBridgeResumed\n\n\tbridgeView ERC20BridgeView\n}\n\nfunc (t *assetAction) GetID() string {\n\treturn t.id\n}\n\nfunc (t *assetAction) GetType() types.NodeVoteType {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn types.NodeVoteTypeFundsDeposited\n\tcase t.IsERC20Deposit():\n\t\treturn types.NodeVoteTypeFundsDeposited\n\tcase t.IsERC20AssetList():\n\t\treturn types.NodeVoteTypeAssetListed\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn types.NodeVoteTypeAssetLimitsUpdated\n\tcase t.IsERC20BridgeStopped():\n\t\treturn types.NodeVoteTypeBridgeStopped\n\tcase t.IsERC20BridgeResumed():\n\t\treturn types.NodeVoteTypeBridgeResumed\n\tdefault:\n\t\treturn types.NodeVoteTypeUnspecified\n\t}\n}\n\nfunc (t *assetAction) IsBuiltinAssetDeposit() bool {\n\treturn t.builtinD != nil\n}\n\nfunc (t *assetAction) IsERC20BridgeStopped() bool {\n\treturn t.erc20BridgeStopped != nil\n}\n\nfunc (t *assetAction) IsERC20BridgeResumed() bool {\n\treturn t.erc20BridgeResumed != nil\n}\n\nfunc (t *assetAction) IsERC20Deposit() bool {\n\treturn t.erc20D != nil\n}\n\nfunc (t *assetAction) IsERC20AssetLimitsUpdated() bool {\n\treturn t.erc20AssetLimitsUpdated != nil\n}\n\nfunc (t *assetAction) IsERC20AssetList() bool {\n\treturn t.erc20AL != nil\n}\n\nfunc (t *assetAction) BuiltinAssetDesposit() *types.BuiltinAssetDeposit {\n\treturn t.builtinD\n}\n\nfunc (t *assetAction) ERC20Deposit() *types.ERC20Deposit {\n\treturn t.erc20D\n}\n\nfunc (t *assetAction) ERC20AssetLimitsUpdated() *types.ERC20AssetLimitsUpdated {\n\treturn t.erc20AssetLimitsUpdated\n}\n\nfunc (t *assetAction) ERC20AssetList() *types.ERC20AssetList {\n\treturn t.erc20AL\n}\n\nfunc (t *assetAction) String() string {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn t.builtinD.String()\n\tcase t.IsERC20Deposit():\n\t\treturn t.erc20D.String()\n\tcase t.IsERC20AssetList():\n\t\treturn t.erc20AL.String()\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn t.erc20AssetLimitsUpdated.String()\n\tcase t.IsERC20BridgeStopped():\n\t\treturn t.erc20BridgeStopped.String()\n\tcase t.IsERC20BridgeResumed():\n\t\treturn t.erc20BridgeResumed.String()\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc (t *assetAction) Check() error {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn t.checkBuiltinAssetDeposit()\n\tcase t.IsERC20Deposit():\n\t\treturn t.checkERC20Deposit()\n\tcase t.IsERC20AssetList():\n\t\treturn t.checkERC20AssetList()\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn t.checkERC20AssetLimitsUpdated()\n\tcase t.IsERC20BridgeStopped():\n\t\treturn t.checkERC20BridgeStopped()\n\tcase t.IsERC20BridgeResumed():\n\t\treturn t.checkERC20BridgeResumed()\n\tdefault:\n\t\treturn ErrUnknownAssetAction\n\t}\n}\n\nfunc (t *assetAction) checkBuiltinAssetDeposit() error {\n\treturn nil\n}\n\nfunc (t *assetAction) checkERC20BridgeStopped() error {\n\treturn t.bridgeView.FindBridgeStopped(\n\t\tt.erc20BridgeStopped, t.blockHeight, t.logIndex)\n}\n\nfunc (t *assetAction) checkERC20BridgeResumed() error {\n\treturn t.bridgeView.FindBridgeResumed(\n\t\tt.erc20BridgeResumed, t.blockHeight, t.logIndex)\n}\n\nfunc (t *assetAction) checkERC20Deposit() error {\n\tasset, _ := t.asset.ERC20()\n\treturn t.bridgeView.FindDeposit(\n\t\tt.erc20D, t.blockHeight, t.logIndex, asset.Address(),\n\t)\n}\n\nfunc (t *assetAction) checkERC20AssetList() error {\n\treturn t.bridgeView.FindAssetList(t.erc20AL, t.blockHeight, t.logIndex)\n}\n\nfunc (t *assetAction) checkERC20AssetLimitsUpdated() error {\n\tasset, _ := t.asset.ERC20()\n\treturn t.bridgeView.FindAssetLimitsUpdated(\n\t\tt.erc20AssetLimitsUpdated, t.blockHeight, t.logIndex, asset.Address(),\n\t)\n}\n\nfunc (t *assetAction) getRef() snapshot.TxRef {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn snapshot.TxRef{Asset: string(common.Builtin), BlockNr: 0, Hash: t.txHash, LogIndex: 0}\n\tcase t.IsERC20Deposit():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20AssetList():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20BridgeStopped():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20BridgeResumed():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tdefault:\n\t\treturn snapshot.TxRef{} // this is basically unreachable\n\t}\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage banking\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"code.vegaprotocol.io/vega/core/assets/erc20\"\n\t\"code.vegaprotocol.io/vega/core/events\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\t\"code.vegaprotocol.io/vega/libs/num\"\n\t\"code.vegaprotocol.io/vega/logging\"\n)\n\nvar (\n\tErrInvalidWithdrawalReferenceNonce       = errors.New(\"invalid withdrawal reference nonce\")\n\tErrWithdrawalAmountUnderMinimalRequired  = errors.New(\"invalid withdrawal, amount under minimum required\")\n\tErrAssetAlreadyBeingListed               = errors.New(\"asset already being listed\")\n\tErrWithdrawalDisabledWhenBridgeIsStopped = errors.New(\"withdrawal issuance is disabled when the erc20 is stopped\")\n)\n\ntype ERC20BridgeView interface {\n\tFindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64) error\n\tFindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64) error\n\tFindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64) error\n\tFindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string) error\n\tFindAssetLimitsUpdated(update *types.ERC20AssetLimitsUpdated, blockNumber uint64, logIndex uint64, ethAssetAddress string) error\n}\n\nfunc (e *Engine) EnableERC20(\n\t_ context.Context,\n\tal *types.ERC20AssetList,\n\tid string,\n\tblockNumber, txIndex uint64,\n\ttxHash string,\n) error {\n\tasset, _ := e.assets.Get(al.VegaAssetID)\n\tif _, ok := e.assetActs[al.VegaAssetID]; ok {\n\t\te.log.Error(\"asset already being listed\", logging.AssetID(al.VegaAssetID))\n\t\treturn ErrAssetAlreadyBeingListed\n\t}\n\n\taa := &assetAction{\n\t\tid:          id,\n\t\tstate:       newPendingState(),\n\t\terc20AL:     al,\n\t\tasset:       asset,\n\t\tblockHeight: blockNumber,\n\t\tlogIndex:    txIndex,\n\t\ttxHash:      txHash,\n\t\tbridgeView:  e.bridgeView,\n\t}\n\te.addAction(aa)\n\treturn e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))\n}\n\nfunc (e *Engine) UpdateERC20(\n\t_ context.Context,\n\tevent *types.ERC20AssetLimitsUpdated,\n\tid string,\n\tblockNumber, txIndex uint64,\n\ttxHash string,\n) error {\n\tasset, err := e.assets.Get(event.VegaAssetID)\n\tif err != nil {\n\t\te.log.Panic(\"couldn't retrieve the ERC20 asset\",\n\t\t\tlogging.AssetID(event.VegaAssetID),\n\t\t)\n\t}\n\taa := &assetAction{\n\t\tid:                      id,\n\t\tstate:                   newPendingState(),\n\t\terc20AssetLimitsUpdated: event,\n\t\tasset:                   asset,\n\t\tblockHeight:             blockNumber,\n\t\tlogIndex:                txIndex,\n\t\ttxHash:                  txHash,\n\t\tbridgeView:              e.bridgeView,\n\t}\n\te.addAction(aa)\n\treturn e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))\n}\n\nfunc (e *Engine) DepositERC20(\n\tctx context.Context,\n\td *types.ERC20Deposit,\n\tid string,\n\tblockNumber, logIndex uint64,\n\ttxHash string,\n) error {\n\tdep := e.newDeposit(id, d.TargetPartyID, d.VegaAssetID, d.Amount, txHash)\n\n\t// check if the asset is correct\n\tasset, err := e.assets.Get(d.VegaAssetID)\n\tif err != nil {\n\t\tdep.Status = types.DepositStatusCancelled\n\t\te.broker.Send(events.NewDepositEvent(ctx, *dep))\n\t\te.log.Error(\"unable to get asset by id\",\n\t\t\tlogging.AssetID(d.VegaAssetID),\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\tif !asset.IsERC20() {\n\t\tdep.Status = types.DepositStatusCancelled\n\t\te.broker.Send(events.NewDepositEvent(ctx, *dep))\n\t\treturn fmt.Errorf(\"%v: %w\", asset.String(), ErrWrongAssetTypeUsedInERC20ChainEvent)\n\t}\n\n\taa := &assetAction{\n\t\tid:          dep.ID,\n\t\tstate:       newPendingState(),\n\t\terc20D:      d,\n\t\tasset:       asset,\n\t\tblockHeight: blockNumber,\n\t\tlogIndex:    logIndex,\n\t\ttxHash:      txHash,\n\t\tbridgeView:  e.bridgeView,\n\t}\n\te.addAction(aa)\n\te.deposits[dep.ID] = dep\n\n\te.broker.Send(events.NewDepositEvent(ctx, *dep))\n\treturn e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))\n}\n\nfunc (e *Engine) ERC20WithdrawalEvent(\n\tctx context.Context, w *types.ERC20Withdrawal,\n\tblockNumber, txIndex uint64,\n\ttxHash string,\n) error {\n\t// check straight away if the withdrawal is signed\n\tnonce, ok := new(big.Int).SetString(w.ReferenceNonce, 10)\n\tif !ok {\n\t\treturn fmt.Errorf(\"%s: %w\", w.ReferenceNonce, ErrInvalidWithdrawalReferenceNonce)\n\t}\n\n\twithd, err := e.getWithdrawalFromRef(nonce)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: %w\", w.ReferenceNonce, err)\n\t}\n\tif withd.Status != types.WithdrawalStatusFinalized {\n\t\treturn fmt.Errorf(\"%s: %w\", withd.ID, ErrInvalidWithdrawalState)\n\t}\n\tif _, ok := e.notary.IsSigned(ctx, withd.ID, types.NodeSignatureKindAssetWithdrawal); !ok {\n\t\treturn ErrWithdrawalNotReady\n\t}\n\n\tif blockNumber > e.lastSeenEthBlock {\n\t\te.lastSeenEthBlock = blockNumber\n\t}\n\twithd.WithdrawalDate = e.timeService.GetTimeNow().UnixNano()\n\twithd.TxHash = txHash\n\te.broker.Send(events.NewWithdrawalEvent(ctx, *withd))\n\n\treturn nil\n}\n\nfunc (e *Engine) WithdrawERC20(\n\tctx context.Context,\n\tid, party, assetID string,\n\tamount *num.Uint,\n\text *types.Erc20WithdrawExt,\n) error {\n\tif e.bridgeState.IsStopped() {\n\t\treturn ErrWithdrawalDisabledWhenBridgeIsStopped\n\t}\n\n\twext := &types.WithdrawExt{\n\t\tExt: &types.WithdrawExtErc20{\n\t\t\tErc20: ext,\n\t\t},\n\t}\n\n\tw, ref := e.newWithdrawal(id, party, assetID, amount, wext)\n\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\te.withdrawals[w.ID] = withdrawalRef{w, ref}\n\n\tasset, err := e.assets.Get(assetID)\n\tif err != nil {\n\t\tw.Status = types.WithdrawalStatusRejected\n\t\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\t\te.log.Debug(\"unable to get asset by id\",\n\t\t\tlogging.AssetID(assetID),\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\t// check for minimal amount reached\n\tquantum := asset.Type().Details.Quantum\n\t// no reason this would produce an error\n\tminAmount, _ := num.UintFromDecimal(quantum.Mul(e.minWithdrawQuantumMultiple))\n\n\t// now verify amount\n\tif amount.LT(minAmount) {\n\t\te.log.Debug(\"cannot withdraw funds, the request is less than minimum withdrawal amount\",\n\t\t\tlogging.BigUint(\"min-amount\", minAmount),\n\t\t\tlogging.BigUint(\"requested-amount\", amount),\n\t\t)\n\t\tw.Status = types.WithdrawalStatusRejected\n\t\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\t\treturn ErrWithdrawalAmountUnderMinimalRequired\n\t}\n\n\tif a, ok := asset.ERC20(); !ok {\n\t\tw.Status = types.WithdrawalStatusRejected\n\t\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\t\treturn ErrWrongAssetUsedForERC20Withdraw\n\t} else if threshold := a.Type().Details.GetERC20().WithdrawThreshold; threshold != nil && threshold.NEQ(num.UintZero()) {\n\t\t// a delay will be applied on this withdrawal\n\t\tif threshold.LT(amount) {\n\t\t\te.log.Debug(\"withdraw threshold breached, delay will be applied\",\n\t\t\t\tlogging.PartyID(party),\n\t\t\t\tlogging.BigUint(\"threshold\", threshold),\n\t\t\t\tlogging.BigUint(\"amount\", amount),\n\t\t\t\tlogging.AssetID(assetID),\n\t\t\t\tlogging.Error(err))\n\t\t}\n\t}\n\n\t// try to withdraw if no error, this'll just abort\n\tif err := e.finalizeWithdraw(ctx, w); err != nil {\n\t\treturn err\n\t}\n\n\t// no check error as we checked earlier we had an erc20 asset.\n\terc20asset, _ := asset.ERC20()\n\n\t// startup aggregating signature for the bundle\n\treturn e.startERC20Signatures(w, erc20asset, ref)\n}\n\nfunc (e *Engine) startERC20Signatures(w *types.Withdrawal, asset *erc20.ERC20, ref *big.Int) error {\n\tvar (\n\t\tsignature []byte\n\t\terr       error\n\t)\n\n\tcreation := time.Unix(0, w.CreationDate)\n\t// if we are a validator, we want to build a signature\n\tif e.top.IsValidator() {\n\t\t_, signature, err = asset.SignWithdrawal(\n\t\t\tw.Amount, w.Ext.GetErc20().GetReceiverAddress(), ref, creation)\n\t\tif err != nil {\n\t\t\t// there's no reason we cannot build the signature here\n\t\t\t// apart if the node isn't configure properly\n\t\t\te.log.Panic(\"unable to sign withdrawal\",\n\t\t\t\tlogging.WithdrawalID(w.ID),\n\t\t\t\tlogging.PartyID(w.PartyID),\n\t\t\t\tlogging.AssetID(w.Asset),\n\t\t\t\tlogging.BigUint(\"amount\", w.Amount),\n\t\t\t\tlogging.Error(err))\n\t\t}\n\t}\n\n\t// we were able to lock the funds, then we can send the vote through the network\n\te.notary.StartAggregate(w.ID, types.NodeSignatureKindAssetWithdrawal, signature)\n\n\treturn nil\n}\n\nfunc (e *Engine) offerERC20NotarySignatures(resource string) []byte {\n\tif !e.top.IsValidator() {\n\t\treturn nil\n\t}\n\n\twref, ok := e.withdrawals[resource]\n\tif !ok {\n\t\t// there's no reason we cannot find the withdrawal here\n\t\t// apart if the node isn't configured properly\n\t\te.log.Panic(\"unable to find withdrawal\",\n\t\t\tlogging.WithdrawalID(resource))\n\t}\n\tw := wref.w\n\n\tasset, err := e.assets.Get(w.Asset)\n\tif err != nil {\n\t\t// there's no reason we cannot build the signature here\n\t\t// apart if the node isn't configure properly\n\t\te.log.Panic(\"unable to get asset when offering signature\",\n\t\t\tlogging.WithdrawalID(w.ID),\n\t\t\tlogging.PartyID(w.PartyID),\n\t\t\tlogging.AssetID(w.Asset),\n\t\t\tlogging.BigUint(\"amount\", w.Amount),\n\t\t\tlogging.Error(err))\n\t}\n\n\tcreation := time.Unix(0, w.CreationDate)\n\terc20asset, _ := asset.ERC20()\n\t_, signature, err := erc20asset.SignWithdrawal(\n\t\tw.Amount, w.Ext.GetErc20().GetReceiverAddress(), wref.ref, creation)\n\tif err != nil {\n\t\t// there's no reason we cannot build the signature here\n\t\t// apart if the node isn't configure properly\n\t\te.log.Panic(\"unable to sign withdrawal\",\n\t\t\tlogging.WithdrawalID(w.ID),\n\t\t\tlogging.PartyID(w.PartyID),\n\t\t\tlogging.AssetID(w.Asset),\n\t\t\tlogging.BigUint(\"amount\", w.Amount),\n\t\t\tlogging.Error(err))\n\t}\n\n\treturn signature\n}\n\nfunc (e *Engine) addAction(aa *assetAction) {\n\te.assetActs[aa.id] = aa\n\tif aa.blockHeight > e.lastSeenEthBlock {\n\t\te.lastSeenEthBlock = aa.blockHeight\n\t}\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: code.vegaprotocol.io/vega/core/banking (interfaces: Assets,Notary,Collateral,Witness,TimeService,EpochService,Topology,MarketActivityTracker,ERC20BridgeView,EthereumEventSource)\n\n// Package mocks is a generated GoMock package.\npackage mocks\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tassets \"code.vegaprotocol.io/vega/core/assets\"\n\ttypes \"code.vegaprotocol.io/vega/core/types\"\n\tvalidators \"code.vegaprotocol.io/vega/core/validators\"\n\tnum \"code.vegaprotocol.io/vega/libs/num\"\n\tvega \"code.vegaprotocol.io/vega/protos/vega\"\n\tv1 \"code.vegaprotocol.io/vega/protos/vega/commands/v1\"\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockAssets is a mock of Assets interface.\ntype MockAssets struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAssetsMockRecorder\n}\n\n// MockAssetsMockRecorder is the mock recorder for MockAssets.\ntype MockAssetsMockRecorder struct {\n\tmock *MockAssets\n}\n\n// NewMockAssets creates a new mock instance.\nfunc NewMockAssets(ctrl *gomock.Controller) *MockAssets {\n\tmock := &MockAssets{ctrl: ctrl}\n\tmock.recorder = &MockAssetsMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockAssets) EXPECT() *MockAssetsMockRecorder {\n\treturn m.recorder\n}\n\n// ApplyAssetUpdate mocks base method.\nfunc (m *MockAssets) ApplyAssetUpdate(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ApplyAssetUpdate\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ApplyAssetUpdate indicates an expected call of ApplyAssetUpdate.\nfunc (mr *MockAssetsMockRecorder) ApplyAssetUpdate(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ApplyAssetUpdate\", reflect.TypeOf((*MockAssets)(nil).ApplyAssetUpdate), arg0, arg1)\n}\n\n// Enable mocks base method.\nfunc (m *MockAssets) Enable(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Enable\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Enable indicates an expected call of Enable.\nfunc (mr *MockAssetsMockRecorder) Enable(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Enable\", reflect.TypeOf((*MockAssets)(nil).Enable), arg0, arg1)\n}\n\n// Get mocks base method.\nfunc (m *MockAssets) Get(arg0 string) (*assets.Asset, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", arg0)\n\tret0, _ := ret[0].(*assets.Asset)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockAssetsMockRecorder) Get(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*MockAssets)(nil).Get), arg0)\n}\n\n// MockNotary is a mock of Notary interface.\ntype MockNotary struct {\n\tctrl     *gomock.Controller\n\trecorder *MockNotaryMockRecorder\n}\n\n// MockNotaryMockRecorder is the mock recorder for MockNotary.\ntype MockNotaryMockRecorder struct {\n\tmock *MockNotary\n}\n\n// NewMockNotary creates a new mock instance.\nfunc NewMockNotary(ctrl *gomock.Controller) *MockNotary {\n\tmock := &MockNotary{ctrl: ctrl}\n\tmock.recorder = &MockNotaryMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockNotary) EXPECT() *MockNotaryMockRecorder {\n\treturn m.recorder\n}\n\n// IsSigned mocks base method.\nfunc (m *MockNotary) IsSigned(arg0 context.Context, arg1 string, arg2 v1.NodeSignatureKind) ([]v1.NodeSignature, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IsSigned\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]v1.NodeSignature)\n\tret1, _ := ret[1].(bool)\n\treturn ret0, ret1\n}\n\n// IsSigned indicates an expected call of IsSigned.\nfunc (mr *MockNotaryMockRecorder) IsSigned(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsSigned\", reflect.TypeOf((*MockNotary)(nil).IsSigned), arg0, arg1, arg2)\n}\n\n// OfferSignatures mocks base method.\nfunc (m *MockNotary) OfferSignatures(arg0 v1.NodeSignatureKind, arg1 func(string) []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"OfferSignatures\", arg0, arg1)\n}\n\n// OfferSignatures indicates an expected call of OfferSignatures.\nfunc (mr *MockNotaryMockRecorder) OfferSignatures(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfferSignatures\", reflect.TypeOf((*MockNotary)(nil).OfferSignatures), arg0, arg1)\n}\n\n// StartAggregate mocks base method.\nfunc (m *MockNotary) StartAggregate(arg0 string, arg1 v1.NodeSignatureKind, arg2 []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"StartAggregate\", arg0, arg1, arg2)\n}\n\n// StartAggregate indicates an expected call of StartAggregate.\nfunc (mr *MockNotaryMockRecorder) StartAggregate(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StartAggregate\", reflect.TypeOf((*MockNotary)(nil).StartAggregate), arg0, arg1, arg2)\n}\n\n// MockCollateral is a mock of Collateral interface.\ntype MockCollateral struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCollateralMockRecorder\n}\n\n// MockCollateralMockRecorder is the mock recorder for MockCollateral.\ntype MockCollateralMockRecorder struct {\n\tmock *MockCollateral\n}\n\n// NewMockCollateral creates a new mock instance.\nfunc NewMockCollateral(ctrl *gomock.Controller) *MockCollateral {\n\tmock := &MockCollateral{ctrl: ctrl}\n\tmock.recorder = &MockCollateralMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockCollateral) EXPECT() *MockCollateralMockRecorder {\n\treturn m.recorder\n}\n\n// Deposit mocks base method.\nfunc (m *MockCollateral) Deposit(arg0 context.Context, arg1, arg2 string, arg3 *num.Uint) (*types.LedgerMovement, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Deposit\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(*types.LedgerMovement)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Deposit indicates an expected call of Deposit.\nfunc (mr *MockCollateralMockRecorder) Deposit(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Deposit\", reflect.TypeOf((*MockCollateral)(nil).Deposit), arg0, arg1, arg2, arg3)\n}\n\n// EnableAsset mocks base method.\nfunc (m *MockCollateral) EnableAsset(arg0 context.Context, arg1 types.Asset) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"EnableAsset\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// EnableAsset indicates an expected call of EnableAsset.\nfunc (mr *MockCollateralMockRecorder) EnableAsset(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"EnableAsset\", reflect.TypeOf((*MockCollateral)(nil).EnableAsset), arg0, arg1)\n}\n\n// GetPartyGeneralAccount mocks base method.\nfunc (m *MockCollateral) GetPartyGeneralAccount(arg0, arg1 string) (*types.Account, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetPartyGeneralAccount\", arg0, arg1)\n\tret0, _ := ret[0].(*types.Account)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetPartyGeneralAccount indicates an expected call of GetPartyGeneralAccount.\nfunc (mr *MockCollateralMockRecorder) GetPartyGeneralAccount(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetPartyGeneralAccount\", reflect.TypeOf((*MockCollateral)(nil).GetPartyGeneralAccount), arg0, arg1)\n}\n\n// PropagateAssetUpdate mocks base method.\nfunc (m *MockCollateral) PropagateAssetUpdate(arg0 context.Context, arg1 types.Asset) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PropagateAssetUpdate\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// PropagateAssetUpdate indicates an expected call of PropagateAssetUpdate.\nfunc (mr *MockCollateralMockRecorder) PropagateAssetUpdate(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PropagateAssetUpdate\", reflect.TypeOf((*MockCollateral)(nil).PropagateAssetUpdate), arg0, arg1)\n}\n\n// TransferFunds mocks base method.\nfunc (m *MockCollateral) TransferFunds(arg0 context.Context, arg1 []*types.Transfer, arg2 []vega.AccountType, arg3 []string, arg4 []*types.Transfer, arg5 []vega.AccountType) ([]*types.LedgerMovement, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"TransferFunds\", arg0, arg1, arg2, arg3, arg4, arg5)\n\tret0, _ := ret[0].([]*types.LedgerMovement)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// TransferFunds indicates an expected call of TransferFunds.\nfunc (mr *MockCollateralMockRecorder) TransferFunds(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"TransferFunds\", reflect.TypeOf((*MockCollateral)(nil).TransferFunds), arg0, arg1, arg2, arg3, arg4, arg5)\n}\n\n// Withdraw mocks base method.\nfunc (m *MockCollateral) Withdraw(arg0 context.Context, arg1, arg2 string, arg3 *num.Uint) (*types.LedgerMovement, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Withdraw\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(*types.LedgerMovement)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Withdraw indicates an expected call of Withdraw.\nfunc (mr *MockCollateralMockRecorder) Withdraw(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Withdraw\", reflect.TypeOf((*MockCollateral)(nil).Withdraw), arg0, arg1, arg2, arg3)\n}\n\n// MockWitness is a mock of Witness interface.\ntype MockWitness struct {\n\tctrl     *gomock.Controller\n\trecorder *MockWitnessMockRecorder\n}\n\n// MockWitnessMockRecorder is the mock recorder for MockWitness.\ntype MockWitnessMockRecorder struct {\n\tmock *MockWitness\n}\n\n// NewMockWitness creates a new mock instance.\nfunc NewMockWitness(ctrl *gomock.Controller) *MockWitness {\n\tmock := &MockWitness{ctrl: ctrl}\n\tmock.recorder = &MockWitnessMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockWitness) EXPECT() *MockWitnessMockRecorder {\n\treturn m.recorder\n}\n\n// RestoreResource mocks base method.\nfunc (m *MockWitness) RestoreResource(arg0 validators.Resource, arg1 func(interface{}, bool)) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RestoreResource\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RestoreResource indicates an expected call of RestoreResource.\nfunc (mr *MockWitnessMockRecorder) RestoreResource(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RestoreResource\", reflect.TypeOf((*MockWitness)(nil).RestoreResource), arg0, arg1)\n}\n\n// StartCheck mocks base method.\nfunc (m *MockWitness) StartCheck(arg0 validators.Resource, arg1 func(interface{}, bool), arg2 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"StartCheck\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// StartCheck indicates an expected call of StartCheck.\nfunc (mr *MockWitnessMockRecorder) StartCheck(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StartCheck\", reflect.TypeOf((*MockWitness)(nil).StartCheck), arg0, arg1, arg2)\n}\n\n// MockTimeService is a mock of TimeService interface.\ntype MockTimeService struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTimeServiceMockRecorder\n}\n\n// MockTimeServiceMockRecorder is the mock recorder for MockTimeService.\ntype MockTimeServiceMockRecorder struct {\n\tmock *MockTimeService\n}\n\n// NewMockTimeService creates a new mock instance.\nfunc NewMockTimeService(ctrl *gomock.Controller) *MockTimeService {\n\tmock := &MockTimeService{ctrl: ctrl}\n\tmock.recorder = &MockTimeServiceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockTimeService) EXPECT() *MockTimeServiceMockRecorder {\n\treturn m.recorder\n}\n\n// GetTimeNow mocks base method.\nfunc (m *MockTimeService) GetTimeNow() time.Time {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetTimeNow\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetTimeNow indicates an expected call of GetTimeNow.\nfunc (mr *MockTimeServiceMockRecorder) GetTimeNow() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetTimeNow\", reflect.TypeOf((*MockTimeService)(nil).GetTimeNow))\n}\n\n// MockEpochService is a mock of EpochService interface.\ntype MockEpochService struct {\n\tctrl     *gomock.Controller\n\trecorder *MockEpochServiceMockRecorder\n}\n\n// MockEpochServiceMockRecorder is the mock recorder for MockEpochService.\ntype MockEpochServiceMockRecorder struct {\n\tmock *MockEpochService\n}\n\n// NewMockEpochService creates a new mock instance.\nfunc NewMockEpochService(ctrl *gomock.Controller) *MockEpochService {\n\tmock := &MockEpochService{ctrl: ctrl}\n\tmock.recorder = &MockEpochServiceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockEpochService) EXPECT() *MockEpochServiceMockRecorder {\n\treturn m.recorder\n}\n\n// NotifyOnEpoch mocks base method.\nfunc (m *MockEpochService) NotifyOnEpoch(arg0, arg1 func(context.Context, types.Epoch)) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"NotifyOnEpoch\", arg0, arg1)\n}\n\n// NotifyOnEpoch indicates an expected call of NotifyOnEpoch.\nfunc (mr *MockEpochServiceMockRecorder) NotifyOnEpoch(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"NotifyOnEpoch\", reflect.TypeOf((*MockEpochService)(nil).NotifyOnEpoch), arg0, arg1)\n}\n\n// MockTopology is a mock of Topology interface.\ntype MockTopology struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTopologyMockRecorder\n}\n\n// MockTopologyMockRecorder is the mock recorder for MockTopology.\ntype MockTopologyMockRecorder struct {\n\tmock *MockTopology\n}\n\n// NewMockTopology creates a new mock instance.\nfunc NewMockTopology(ctrl *gomock.Controller) *MockTopology {\n\tmock := &MockTopology{ctrl: ctrl}\n\tmock.recorder = &MockTopologyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockTopology) EXPECT() *MockTopologyMockRecorder {\n\treturn m.recorder\n}\n\n// IsValidator mocks base method.\nfunc (m *MockTopology) IsValidator() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IsValidator\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// IsValidator indicates an expected call of IsValidator.\nfunc (mr *MockTopologyMockRecorder) IsValidator() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsValidator\", reflect.TypeOf((*MockTopology)(nil).IsValidator))\n}\n\n// MockMarketActivityTracker is a mock of MarketActivityTracker interface.\ntype MockMarketActivityTracker struct {\n\tctrl     *gomock.Controller\n\trecorder *MockMarketActivityTrackerMockRecorder\n}\n\n// MockMarketActivityTrackerMockRecorder is the mock recorder for MockMarketActivityTracker.\ntype MockMarketActivityTrackerMockRecorder struct {\n\tmock *MockMarketActivityTracker\n}\n\n// NewMockMarketActivityTracker creates a new mock instance.\nfunc NewMockMarketActivityTracker(ctrl *gomock.Controller) *MockMarketActivityTracker {\n\tmock := &MockMarketActivityTracker{ctrl: ctrl}\n\tmock.recorder = &MockMarketActivityTrackerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockMarketActivityTracker) EXPECT() *MockMarketActivityTrackerMockRecorder {\n\treturn m.recorder\n}\n\n// GetMarketScores mocks base method.\nfunc (m *MockMarketActivityTracker) GetMarketScores(arg0 string, arg1 []string, arg2 vega.DispatchMetric) []*types.MarketContributionScore {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetMarketScores\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*types.MarketContributionScore)\n\treturn ret0\n}\n\n// GetMarketScores indicates an expected call of GetMarketScores.\nfunc (mr *MockMarketActivityTrackerMockRecorder) GetMarketScores(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetMarketScores\", reflect.TypeOf((*MockMarketActivityTracker)(nil).GetMarketScores), arg0, arg1, arg2)\n}\n\n// GetMarketsWithEligibleProposer mocks base method.\nfunc (m *MockMarketActivityTracker) GetMarketsWithEligibleProposer(arg0 string, arg1 []string, arg2, arg3 string) []*types.MarketContributionScore {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetMarketsWithEligibleProposer\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].([]*types.MarketContributionScore)\n\treturn ret0\n}\n\n// GetMarketsWithEligibleProposer indicates an expected call of GetMarketsWithEligibleProposer.\nfunc (mr *MockMarketActivityTrackerMockRecorder) GetMarketsWithEligibleProposer(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetMarketsWithEligibleProposer\", reflect.TypeOf((*MockMarketActivityTracker)(nil).GetMarketsWithEligibleProposer), arg0, arg1, arg2, arg3)\n}\n\n// MarkPaidProposer mocks base method.\nfunc (m *MockMarketActivityTracker) MarkPaidProposer(arg0, arg1 string, arg2 []string, arg3 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"MarkPaidProposer\", arg0, arg1, arg2, arg3)\n}\n\n// MarkPaidProposer indicates an expected call of MarkPaidProposer.\nfunc (mr *MockMarketActivityTrackerMockRecorder) MarkPaidProposer(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"MarkPaidProposer\", reflect.TypeOf((*MockMarketActivityTracker)(nil).MarkPaidProposer), arg0, arg1, arg2, arg3)\n}\n\n// MockERC20BridgeView is a mock of ERC20BridgeView interface.\ntype MockERC20BridgeView struct {\n\tctrl     *gomock.Controller\n\trecorder *MockERC20BridgeViewMockRecorder\n}\n\n// MockERC20BridgeViewMockRecorder is the mock recorder for MockERC20BridgeView.\ntype MockERC20BridgeViewMockRecorder struct {\n\tmock *MockERC20BridgeView\n}\n\n// NewMockERC20BridgeView creates a new mock instance.\nfunc NewMockERC20BridgeView(ctrl *gomock.Controller) *MockERC20BridgeView {\n\tmock := &MockERC20BridgeView{ctrl: ctrl}\n\tmock.recorder = &MockERC20BridgeViewMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockERC20BridgeView) EXPECT() *MockERC20BridgeViewMockRecorder {\n\treturn m.recorder\n}\n\n// FindAssetLimitsUpdated mocks base method.\nfunc (m *MockERC20BridgeView) FindAssetLimitsUpdated(arg0 *types.ERC20AssetLimitsUpdated, arg1, arg2 uint64, arg3 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindAssetLimitsUpdated\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindAssetLimitsUpdated indicates an expected call of FindAssetLimitsUpdated.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindAssetLimitsUpdated(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetLimitsUpdated\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetLimitsUpdated), arg0, arg1, arg2, arg3)\n}\n\n// FindAssetList mocks base method.\nfunc (m *MockERC20BridgeView) FindAssetList(arg0 *types.ERC20AssetList, arg1, arg2 uint64) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindAssetList\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindAssetList indicates an expected call of FindAssetList.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindAssetList(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetList\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetList), arg0, arg1, arg2)\n}\n\n// FindBridgeResumed mocks base method.\nfunc (m *MockERC20BridgeView) FindBridgeResumed(arg0 *types.ERC20EventBridgeResumed, arg1, arg2 uint64) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBridgeResumed\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindBridgeResumed indicates an expected call of FindBridgeResumed.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindBridgeResumed(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeResumed\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeResumed), arg0, arg1, arg2)\n}\n\n// FindBridgeStopped mocks base method.\nfunc (m *MockERC20BridgeView) FindBridgeStopped(arg0 *types.ERC20EventBridgeStopped, arg1, arg2 uint64) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBridgeStopped\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindBridgeStopped indicates an expected call of FindBridgeStopped.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindBridgeStopped(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeStopped\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeStopped), arg0, arg1, arg2)\n}\n\n// FindDeposit mocks base method.\nfunc (m *MockERC20BridgeView) FindDeposit(arg0 *types.ERC20Deposit, arg1, arg2 uint64, arg3 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindDeposit\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindDeposit indicates an expected call of FindDeposit.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindDeposit(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindDeposit\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindDeposit), arg0, arg1, arg2, arg3)\n}\n\n// MockEthereumEventSource is a mock of EthereumEventSource interface.\ntype MockEthereumEventSource struct {\n\tctrl     *gomock.Controller\n\trecorder *MockEthereumEventSourceMockRecorder\n}\n\n// MockEthereumEventSourceMockRecorder is the mock recorder for MockEthereumEventSource.\ntype MockEthereumEventSourceMockRecorder struct {\n\tmock *MockEthereumEventSource\n}\n\n// NewMockEthereumEventSource creates a new mock instance.\nfunc NewMockEthereumEventSource(ctrl *gomock.Controller) *MockEthereumEventSource {\n\tmock := &MockEthereumEventSource{ctrl: ctrl}\n\tmock.recorder = &MockEthereumEventSourceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockEthereumEventSource) EXPECT() *MockEthereumEventSourceMockRecorder {\n\treturn m.recorder\n}\n\n// UpdateCollateralStartingBlock mocks base method.\nfunc (m *MockEthereumEventSource) UpdateCollateralStartingBlock(arg0 uint64) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"UpdateCollateralStartingBlock\", arg0)\n}\n\n// UpdateCollateralStartingBlock indicates an expected call of UpdateCollateralStartingBlock.\nfunc (mr *MockEthereumEventSourceMockRecorder) UpdateCollateralStartingBlock(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateCollateralStartingBlock\", reflect.TypeOf((*MockEthereumEventSource)(nil).UpdateCollateralStartingBlock), arg0)\n}\n", "package bridges\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\terc20contract \"code.vegaprotocol.io/vega/core/contracts/erc20\"\n\tbridgecontract \"code.vegaprotocol.io/vega/core/contracts/erc20_bridge_logic_restricted\"\n\t\"code.vegaprotocol.io/vega/core/metrics\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\tvgerrors \"code.vegaprotocol.io/vega/libs/errors\"\n\t\"code.vegaprotocol.io/vega/libs/num\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\tethcommon \"github.com/ethereum/go-ethereum/common\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n)\n\nvar (\n\tErrNotAnERC20Asset                     = errors.New(\"not an erc20 asset\")\n\tErrUnableToFindERC20AssetList          = errors.New(\"unable to find erc20 asset list event\")\n\tErrUnableToFindERC20BridgeStopped      = errors.New(\"unable to find erc20 bridge stopped event\")\n\tErrUnableToFindERC20BridgeResumed      = errors.New(\"unable to find erc20 bridge resumed event\")\n\tErrUnableToFindERC20Deposit            = errors.New(\"unable to find erc20 asset deposit\")\n\tErrUnableToFindERC20Withdrawal         = errors.New(\"unabled to find erc20 asset withdrawal\")\n\tErrUnableToFindERC20AssetLimitsUpdated = errors.New(\"unable to find erc20 asset limits update event\")\n)\n\n//go:generate go run github.com/golang/mock/mockgen -destination mocks/eth_client_mock.go -package mocks code.vegaprotocol.io/vega/core/bridges ETHClient\ntype ETHClient interface {\n\tbind.ContractBackend\n\tHeaderByNumber(context.Context, *big.Int) (*ethtypes.Header, error)\n\tCollateralBridgeAddress() ethcommon.Address\n\tCurrentHeight(context.Context) (uint64, error)\n\tConfirmationsRequired() uint64\n}\n\n//go:generate go run github.com/golang/mock/mockgen -destination mocks/eth_confirmations_mock.go -package mocks code.vegaprotocol.io/vega/core/bridges EthConfirmations\ntype EthConfirmations interface {\n\tCheck(uint64) error\n}\n\n// ERC20Logic yea that's a weird name but\n// it just matches the name of the contract.\ntype ERC20LogicView struct {\n\tclt      ETHClient\n\tethConfs EthConfirmations\n}\n\nfunc NewERC20LogicView(\n\tclt ETHClient,\n\tethConfs EthConfirmations,\n) *ERC20LogicView {\n\treturn &ERC20LogicView{\n\t\tclt:      clt,\n\t\tethConfs: ethConfs,\n\t}\n}\n\n// FindAsset will try to find an asset and validate it's details on ethereum.\nfunc (e *ERC20LogicView) FindAsset(\n\tasset *types.AssetDetails,\n) error {\n\tsource := asset.GetERC20()\n\tif source == nil {\n\t\treturn ErrNotAnERC20Asset\n\t}\n\n\tt, err := erc20contract.NewErc20(ethcommon.HexToAddress(source.ContractAddress), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalidationErrs := vgerrors.NewCumulatedErrors()\n\n\tif name, err := t.Name(&bind.CallOpts{}); err != nil {\n\t\tvalidationErrs.Add(fmt.Errorf(\"couldn't get name: %w\", err))\n\t} else if name != asset.Name {\n\t\tvalidationErrs.Add(fmt.Errorf(\"invalid name, expected(%s), got(%s)\", asset.Name, name))\n\t}\n\n\tif symbol, err := t.Symbol(&bind.CallOpts{}); err != nil {\n\t\tvalidationErrs.Add(fmt.Errorf(\"couldn't get symbol: %w\", err))\n\t} else if symbol != asset.Symbol {\n\t\tvalidationErrs.Add(fmt.Errorf(\"invalid symbol, expected(%s), got(%s)\", asset.Symbol, symbol))\n\t}\n\n\tif decimals, err := t.Decimals(&bind.CallOpts{}); err != nil {\n\t\tvalidationErrs.Add(fmt.Errorf(\"couldn't get decimals: %w\", err))\n\t} else if uint64(decimals) != asset.Decimals {\n\t\tvalidationErrs.Add(fmt.Errorf(\"invalid decimals, expected(%d), got(%d)\", asset.Decimals, decimals))\n\t}\n\n\tif validationErrs.HasAny() {\n\t\treturn validationErrs\n\t}\n\n\treturn nil\n}\n\n// FindAssetList will look at the ethereum logs and try to find the\n// given transaction.\nfunc (e *ERC20LogicView) FindAssetList(\n\tal *types.ERC20AssetList,\n\tblockNumber,\n\tlogIndex uint64,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_asset_list\", al.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetListed(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(al.AssetSource)},\n\t\t[][32]byte{},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetListed\n\tassetID := strings.TrimPrefix(al.VegaAssetID, \"0x\")\n\n\tfor iter.Next() {\n\t\tif hex.EncodeToString(iter.Event.VegaAssetId[:]) == assetID &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20AssetList\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// FindBridgeStopped will look at the ethereum logs and try to find the\n// given transaction.\nfunc (e *ERC20LogicView) FindBridgeStopped(\n\tal *types.ERC20EventBridgeStopped,\n\tblockNumber,\n\tlogIndex uint64,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_bridge_stopped\", resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterBridgeStopped(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedBridgeStopped\n\n\tfor iter.Next() {\n\t\tif iter.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20BridgeStopped\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// FindBridgeResumed will look at the ethereum logs and try to find the\n// given transaction.\nfunc (e *ERC20LogicView) FindBridgeResumed(\n\tal *types.ERC20EventBridgeResumed,\n\tblockNumber,\n\tlogIndex uint64,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_bridge_stopped\", resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterBridgeResumed(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedBridgeResumed\n\n\tfor iter.Next() {\n\t\tif iter.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20BridgeStopped\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (e *ERC20LogicView) FindDeposit(\n\td *types.ERC20Deposit,\n\tblockNumber, logIndex uint64,\n\tethAssetAddress string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_deposit\", d.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetDeposited(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t// user_address\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(d.SourceEthereumAddress)},\n\t\t// asset_source\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(ethAssetAddress)})\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tdepamount := d.Amount.BigInt()\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetDeposited\n\ttargetPartyID := strings.TrimPrefix(d.TargetPartyID, \"0x\")\n\n\tfor iter.Next() {\n\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == targetPartyID &&\n\t\t\titer.Event.Amount.Cmp(depamount) == 0 &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n\t\t\tevent = iter.Event\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20Deposit\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (e *ERC20LogicView) FindWithdrawal(\n\tw *types.ERC20Withdrawal,\n\tblockNumber, logIndex uint64,\n\tethAssetAddress string,\n) (*big.Int, string, uint, error) {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn nil, \"\", 0, err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_withdrawal\", w.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetWithdrawn(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t// user_address\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(w.TargetEthereumAddress)},\n\t\t// asset_source\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(ethAssetAddress)})\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn nil, \"\", 0, err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetWithdrawn\n\tnonce := &big.Int{}\n\t_, ok := nonce.SetString(w.ReferenceNonce, 10)\n\tif !ok {\n\t\treturn nil, \"\", 0, fmt.Errorf(\"could not use reference nonce, expected base 10 integer: %v\", w.ReferenceNonce)\n\t}\n\n\tfor iter.Next() {\n\t\tif nonce.Cmp(iter.Event.Nonce) == 0 &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn nil, \"\", 0, ErrUnableToFindERC20Withdrawal\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn nil, \"\", 0, err\n\t}\n\n\treturn nonce, event.Raw.TxHash.Hex(), event.Raw.Index, nil\n}\n\nfunc (e *ERC20LogicView) FindAssetLimitsUpdated(\n\tupdate *types.ERC20AssetLimitsUpdated,\n\tblockNumber uint64, logIndex uint64,\n\tethAssetAddress string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_asset_limits_updated\", update.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetLimitsUpdated(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(ethAssetAddress)},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetLimitsUpdated\n\n\tfor iter.Next() {\n\t\teventLifetimeLimit, _ := num.UintFromBig(iter.Event.LifetimeLimit)\n\t\teventWithdrawThreshold, _ := num.UintFromBig(iter.Event.WithdrawThreshold)\n\t\tif update.LifetimeLimits.EQ(eventLifetimeLimit) &&\n\t\t\tupdate.WithdrawThreshold.EQ(eventWithdrawThreshold) &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n\t\t\tevent = iter.Event\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20AssetLimitsUpdated\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc getMaybeHTTPStatus(err error) string {\n\terrstr := err.Error()\n\tif len(errstr) < 3 {\n\t\treturn \"tooshort\"\n\t}\n\ti, err := strconv.Atoi(errstr[:3])\n\tif err != nil {\n\t\treturn \"nan\"\n\t}\n\tif http.StatusText(i) == \"\" {\n\t\treturn \"unknown\"\n\t}\n\n\treturn errstr[:3]\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage stubs\n\nimport (\n\t\"code.vegaprotocol.io/vega/core/types\"\n)\n\ntype BridgeViewStub struct{}\n\nfunc NewBridgeViewStub() *BridgeViewStub {\n\treturn &BridgeViewStub{}\n}\n\nfunc (*BridgeViewStub) FindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindAssetLimitsUpdated(w *types.ERC20AssetLimitsUpdated, blockNumber, logIndex uint64, ethAssetAddress string) error {\n\treturn nil\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage staking\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"code.vegaprotocol.io/vega/core/types\"\n\t\"code.vegaprotocol.io/vega/logging\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\tethcmn \"github.com/ethereum/go-ethereum/common\"\n)\n\ntype EthereumClient interface {\n\tbind.ContractFilterer\n}\n\ntype OnChainVerifier struct {\n\tlog              *logging.Logger\n\tethClient        EthereumClient\n\tethConfirmations EthConfirmations\n\n\tmu                     sync.RWMutex\n\tstakingBridgeAddresses []ethcmn.Address\n}\n\nfunc NewOnChainVerifier(\n\tcfg Config,\n\tlog *logging.Logger,\n\tethClient EthereumClient,\n\tethConfirmations EthConfirmations,\n) *OnChainVerifier {\n\tlog = log.Named(\"on-chain-verifier\")\n\tlog.SetLevel(cfg.Level.Get())\n\n\treturn &OnChainVerifier{\n\t\tlog:              log,\n\t\tethClient:        ethClient,\n\t\tethConfirmations: ethConfirmations,\n\t}\n}\n\nfunc (o *OnChainVerifier) UpdateStakingBridgeAddresses(stakingBridgeAddresses []ethcmn.Address) {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\n\to.stakingBridgeAddresses = stakingBridgeAddresses\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\tvar addresses []string\n\t\tfor _, v := range o.stakingBridgeAddresses {\n\t\t\taddresses = append(addresses, v.Hex())\n\t\t}\n\t\to.log.Debug(\"staking bridge addresses updated\",\n\t\t\tlogging.Strings(\"addresses\", addresses))\n\t}\n}\n\nfunc (o *OnChainVerifier) CheckStakeDeposited(\n\tevent *types.StakeDeposited,\n) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking stake deposited event on chain\",\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tdecodedPubKeySlice, err := hex.DecodeString(event.VegaPubKey)\n\tif err != nil {\n\t\to.log.Error(\"invalid pubkey in stake deposited event\", logging.Error(err))\n\t\treturn err\n\t}\n\tvar decodedPubKey [32]byte\n\tcopy(decodedPubKey[:], decodedPubKeySlice[0:32])\n\n\tfor _, address := range o.stakingBridgeAddresses {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"checking stake deposited event on chain\",\n\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\tlogging.String(\"event\", event.String()),\n\t\t\t)\n\t\t}\n\t\tfilterer, err := NewStakingFilterer(address, o.ethClient)\n\t\tif err != nil {\n\t\t\to.log.Error(\"could not instantiate staking bridge filterer\",\n\t\t\t\tlogging.String(\"address\", address.Hex()))\n\t\t\tcontinue\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\titer, err := filterer.FilterStakeDeposited(\n\t\t\t&bind.FilterOpts{\n\t\t\t\tStart:   event.BlockNumber,\n\t\t\t\tEnd:     &event.BlockNumber,\n\t\t\t\tContext: ctx,\n\t\t\t},\n\t\t\t// user\n\t\t\t[]ethcmn.Address{ethcmn.HexToAddress(event.EthereumAddress)},\n\t\t\t// vega_public_key\n\t\t\t[][32]byte{decodedPubKey})\n\t\tif err != nil {\n\t\t\to.log.Error(\"Couldn't start filtering on stake deposited event\", logging.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer iter.Close()\n\n\t\tvegaPubKey := strings.TrimPrefix(event.VegaPubKey, \"0x\")\n\t\tamountDeposited := event.Amount.BigInt()\n\n\t\tfor iter.Next() {\n\t\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\t\to.log.Debug(\"found stake deposited event on chain\",\n\t\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\t\tlogging.String(\"amount\", iter.Event.Amount.String()),\n\t\t\t\t\tlogging.String(\"user\", iter.Event.User.Hex()),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == vegaPubKey &&\n\t\t\t\titer.Event.Amount.Cmp(amountDeposited) == 0 &&\n\t\t\t\titer.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex {\n\t\t\t\t// now we know the event is OK,\n\t\t\t\t// just need to check for confirmations\n\t\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ErrNoStakeDepositedEventFound\n}\n\nfunc (o *OnChainVerifier) CheckStakeRemoved(event *types.StakeRemoved) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking stake removed event on chain\",\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tdecodedPubKeySlice, err := hex.DecodeString(event.VegaPubKey)\n\tif err != nil {\n\t\to.log.Error(\"invalid pubkey inn stake deposited event\", logging.Error(err))\n\t\treturn err\n\t}\n\tvar decodedPubKey [32]byte\n\tcopy(decodedPubKey[:], decodedPubKeySlice[0:32])\n\n\tfor _, address := range o.stakingBridgeAddresses {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"checking stake removed event on chain\",\n\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\tlogging.String(\"event\", event.String()),\n\t\t\t)\n\t\t}\n\t\tfilterer, err := NewStakingFilterer(address, o.ethClient)\n\t\tif err != nil {\n\t\t\to.log.Error(\"could not instantiate staking bridge filterer\",\n\t\t\t\tlogging.String(\"address\", address.Hex()))\n\t\t\tcontinue\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\titer, err := filterer.FilterStakeRemoved(\n\t\t\t&bind.FilterOpts{\n\t\t\t\tStart:   event.BlockNumber,\n\t\t\t\tEnd:     &event.BlockNumber,\n\t\t\t\tContext: ctx,\n\t\t\t},\n\t\t\t// user\n\t\t\t[]ethcmn.Address{ethcmn.HexToAddress(event.EthereumAddress)},\n\t\t\t// vega_public_key\n\t\t\t[][32]byte{decodedPubKey})\n\t\tif err != nil {\n\t\t\to.log.Error(\"could not start stake deposited filter\",\n\t\t\t\tlogging.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer iter.Close()\n\n\t\tvegaPubKey := strings.TrimPrefix(event.VegaPubKey, \"0x\")\n\t\tamountDeposited := event.Amount.BigInt()\n\n\t\tfor iter.Next() {\n\t\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\t\to.log.Debug(\"found stake removed event on chain\",\n\t\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\t\tlogging.String(\"amount\", iter.Event.Amount.String()),\n\t\t\t\t\tlogging.String(\"user\", iter.Event.User.Hex()),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == vegaPubKey &&\n\t\t\t\titer.Event.Amount.Cmp(amountDeposited) == 0 &&\n\t\t\t\titer.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex {\n\t\t\t\t// now we know the event is OK,\n\t\t\t\t// just need to check for confirmations\n\t\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ErrNoStakeRemovedEventFound\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage erc20multisig\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"math/big\"\n\t\"sync\"\n\t\"time\"\n\n\tmultisig \"code.vegaprotocol.io/vega/core/contracts/multisig_control\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\t\"code.vegaprotocol.io/vega/logging\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\tethcmn \"github.com/ethereum/go-ethereum/common\"\n)\n\nvar (\n\tErrNoSignerEventFound       = errors.New(\"no signer event found\")\n\tErrNoThresholdSetEventFound = errors.New(\"no threshold set event found\")\n\tErrUnsupportedSignerEvent   = errors.New(\"unsupported signer event\")\n)\n\ntype EthereumClient interface {\n\tbind.ContractFilterer\n}\n\ntype EthConfirmations interface {\n\tCheck(uint64) error\n}\n\ntype OnChainVerifier struct {\n\tconfig           Config\n\tlog              *logging.Logger\n\tethClient        EthereumClient\n\tethConfirmations EthConfirmations\n\n\tmu              sync.RWMutex\n\tmultiSigAddress ethcmn.Address\n}\n\nfunc NewOnChainVerifier(\n\tconfig Config,\n\tlog *logging.Logger,\n\tethClient EthereumClient,\n\tethConfirmations EthConfirmations,\n) *OnChainVerifier {\n\tlog = log.Named(namedLogger + \".on-chain-verifier\")\n\tlog.SetLevel(config.Level.Get())\n\n\treturn &OnChainVerifier{\n\t\tconfig:           config,\n\t\tlog:              log,\n\t\tethClient:        ethClient,\n\t\tethConfirmations: ethConfirmations,\n\t}\n}\n\nfunc (o *OnChainVerifier) UpdateMultiSigAddress(multiSigAddress ethcmn.Address) {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\n\to.multiSigAddress = multiSigAddress\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"multi sig bridge addresses updated\",\n\t\t\tlogging.String(\"addresses\", o.multiSigAddress.Hex()))\n\t}\n}\n\nfunc (o *OnChainVerifier) CheckSignerEvent(event *types.SignerEvent) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking signer event on chain\",\n\t\t\tlogging.String(\"contract-address\", o.multiSigAddress.Hex()),\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tfilterer, err := multisig.NewMultisigControlFilterer(\n\t\to.multiSigAddress,\n\t\to.ethClient,\n\t)\n\tif err != nil {\n\t\to.log.Error(\"could not instantiate multisig control filterer\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tswitch event.Kind {\n\tcase types.SignerEventKindAdded:\n\t\treturn o.filterSignerAdded(ctx, filterer, event)\n\tcase types.SignerEventKindRemoved:\n\t\treturn o.filterSignerRemoved(ctx, filterer, event)\n\tdefault:\n\t\treturn ErrUnsupportedSignerEvent\n\t}\n}\n\nfunc (o *OnChainVerifier) CheckThresholdSetEvent(\n\tevent *types.SignerThresholdSetEvent,\n) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking threshold set event on chain\",\n\t\t\tlogging.String(\"contract-address\", o.multiSigAddress.Hex()),\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tfilterer, err := multisig.NewMultisigControlFilterer(\n\t\to.multiSigAddress,\n\t\to.ethClient,\n\t)\n\tif err != nil {\n\t\to.log.Error(\"could not instantiate multisig control filterer\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\titer, err := filterer.FilterThresholdSet(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   event.BlockNumber,\n\t\t\tEnd:     &event.BlockNumber,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\to.log.Error(\"Couldn't start filtering on signer added event\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tfor iter.Next() {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"found threshold set event on chain\",\n\t\t\t\tlogging.Uint16(\"new-threshold\", iter.Event.NewThreshold),\n\t\t\t)\n\t\t}\n\n\t\tnonce, _ := big.NewInt(0).SetString(event.Nonce, 10)\n\t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\titer.Event.NewThreshold == uint16(event.Threshold) &&\n\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 {\n\t\t\t// now we know the event is OK,\n\t\t\t// just need to check for confirmations\n\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t}\n\t}\n\n\treturn ErrNoThresholdSetEventFound\n}\n\nfunc (o *OnChainVerifier) filterSignerAdded(\n\tctx context.Context,\n\tfilterer *multisig.MultisigControlFilterer,\n\tevent *types.SignerEvent,\n) error {\n\titer, err := filterer.FilterSignerAdded(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   event.BlockNumber,\n\t\t\tEnd:     &event.BlockNumber,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\to.log.Error(\"Couldn't start filtering on signer added event\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tfor iter.Next() {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"found signer added event on chain\",\n\t\t\t\tlogging.String(\"new-signer\", iter.Event.NewSigner.Hex()),\n\t\t\t)\n\t\t}\n\n\t\tnonce, _ := big.NewInt(0).SetString(event.Nonce, 10)\n\t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\titer.Event.NewSigner.Hex() == event.Address &&\n\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 {\n\t\t\t// now we know the event is OK,\n\t\t\t// just need to check for confirmations\n\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t}\n\t}\n\n\treturn ErrNoSignerEventFound\n}\n\nfunc (o *OnChainVerifier) filterSignerRemoved(\n\tctx context.Context,\n\tfilterer *multisig.MultisigControlFilterer,\n\tevent *types.SignerEvent,\n) error {\n\titer, err := filterer.FilterSignerRemoved(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   event.BlockNumber,\n\t\t\tEnd:     &event.BlockNumber,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\to.log.Error(\"Couldn't start filtering on signer removed event\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tfor iter.Next() {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"found signer removed event on chain\",\n\t\t\t\tlogging.String(\"old-signer\", iter.Event.OldSigner.Hex()),\n\t\t\t)\n\t\t}\n\n\t\tnonce, _ := big.NewInt(0).SetString(event.Nonce, 10)\n\t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\titer.Event.OldSigner.Hex() == event.Address &&\n\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 {\n\t\t\t// now we know the event is OK,\n\t\t\t// just need to check for confirmations\n\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t}\n\t}\n\n\treturn ErrNoSignerEventFound\n}\n"], "fixing_code": ["// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage banking\n\nimport (\n\t\"errors\"\n\t\"sync/atomic\"\n\n\t\"code.vegaprotocol.io/vega/core/assets\"\n\t\"code.vegaprotocol.io/vega/core/assets/common\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\tsnapshot \"code.vegaprotocol.io/vega/protos/vega/snapshot/v1\"\n)\n\nvar ErrUnknownAssetAction = errors.New(\"unknown asset action\")\n\ntype assetAction struct {\n\tid    string\n\tstate *atomic.Uint32\n\tasset *assets.Asset\n\n\t// erc20 specifics\n\tblockHeight uint64\n\tlogIndex    uint64\n\ttxHash      string\n\n\t// all deposit related types\n\tbuiltinD *types.BuiltinAssetDeposit\n\terc20D   *types.ERC20Deposit\n\terc20AL  *types.ERC20AssetList\n\n\terc20AssetLimitsUpdated *types.ERC20AssetLimitsUpdated\n\n\terc20BridgeStopped *types.ERC20EventBridgeStopped\n\terc20BridgeResumed *types.ERC20EventBridgeResumed\n\n\tbridgeView ERC20BridgeView\n}\n\nfunc (t *assetAction) GetID() string {\n\treturn t.id\n}\n\nfunc (t *assetAction) GetType() types.NodeVoteType {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn types.NodeVoteTypeFundsDeposited\n\tcase t.IsERC20Deposit():\n\t\treturn types.NodeVoteTypeFundsDeposited\n\tcase t.IsERC20AssetList():\n\t\treturn types.NodeVoteTypeAssetListed\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn types.NodeVoteTypeAssetLimitsUpdated\n\tcase t.IsERC20BridgeStopped():\n\t\treturn types.NodeVoteTypeBridgeStopped\n\tcase t.IsERC20BridgeResumed():\n\t\treturn types.NodeVoteTypeBridgeResumed\n\tdefault:\n\t\treturn types.NodeVoteTypeUnspecified\n\t}\n}\n\nfunc (t *assetAction) IsBuiltinAssetDeposit() bool {\n\treturn t.builtinD != nil\n}\n\nfunc (t *assetAction) IsERC20BridgeStopped() bool {\n\treturn t.erc20BridgeStopped != nil\n}\n\nfunc (t *assetAction) IsERC20BridgeResumed() bool {\n\treturn t.erc20BridgeResumed != nil\n}\n\nfunc (t *assetAction) IsERC20Deposit() bool {\n\treturn t.erc20D != nil\n}\n\nfunc (t *assetAction) IsERC20AssetLimitsUpdated() bool {\n\treturn t.erc20AssetLimitsUpdated != nil\n}\n\nfunc (t *assetAction) IsERC20AssetList() bool {\n\treturn t.erc20AL != nil\n}\n\nfunc (t *assetAction) BuiltinAssetDesposit() *types.BuiltinAssetDeposit {\n\treturn t.builtinD\n}\n\nfunc (t *assetAction) ERC20Deposit() *types.ERC20Deposit {\n\treturn t.erc20D\n}\n\nfunc (t *assetAction) ERC20AssetLimitsUpdated() *types.ERC20AssetLimitsUpdated {\n\treturn t.erc20AssetLimitsUpdated\n}\n\nfunc (t *assetAction) ERC20AssetList() *types.ERC20AssetList {\n\treturn t.erc20AL\n}\n\nfunc (t *assetAction) String() string {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn t.builtinD.String()\n\tcase t.IsERC20Deposit():\n\t\treturn t.erc20D.String()\n\tcase t.IsERC20AssetList():\n\t\treturn t.erc20AL.String()\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn t.erc20AssetLimitsUpdated.String()\n\tcase t.IsERC20BridgeStopped():\n\t\treturn t.erc20BridgeStopped.String()\n\tcase t.IsERC20BridgeResumed():\n\t\treturn t.erc20BridgeResumed.String()\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc (t *assetAction) Check() error {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn t.checkBuiltinAssetDeposit()\n\tcase t.IsERC20Deposit():\n\t\treturn t.checkERC20Deposit()\n\tcase t.IsERC20AssetList():\n\t\treturn t.checkERC20AssetList()\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn t.checkERC20AssetLimitsUpdated()\n\tcase t.IsERC20BridgeStopped():\n\t\treturn t.checkERC20BridgeStopped()\n\tcase t.IsERC20BridgeResumed():\n\t\treturn t.checkERC20BridgeResumed()\n\tdefault:\n\t\treturn ErrUnknownAssetAction\n\t}\n}\n\nfunc (t *assetAction) checkBuiltinAssetDeposit() error {\n\treturn nil\n}\n\nfunc (t *assetAction) checkERC20BridgeStopped() error {\n\treturn t.bridgeView.FindBridgeStopped(\n\t\tt.erc20BridgeStopped, t.blockHeight, t.logIndex, t.txHash)\n}\n\nfunc (t *assetAction) checkERC20BridgeResumed() error {\n\treturn t.bridgeView.FindBridgeResumed(\n\t\tt.erc20BridgeResumed, t.blockHeight, t.logIndex, t.txHash)\n}\n\nfunc (t *assetAction) checkERC20Deposit() error {\n\tasset, _ := t.asset.ERC20()\n\treturn t.bridgeView.FindDeposit(\n\t\tt.erc20D, t.blockHeight, t.logIndex, asset.Address(), t.txHash,\n\t)\n}\n\nfunc (t *assetAction) checkERC20AssetList() error {\n\treturn t.bridgeView.FindAssetList(t.erc20AL, t.blockHeight, t.logIndex, t.txHash)\n}\n\nfunc (t *assetAction) checkERC20AssetLimitsUpdated() error {\n\tasset, _ := t.asset.ERC20()\n\treturn t.bridgeView.FindAssetLimitsUpdated(\n\t\tt.erc20AssetLimitsUpdated, t.blockHeight, t.logIndex, asset.Address(), t.txHash,\n\t)\n}\n\nfunc (t *assetAction) getRef() snapshot.TxRef {\n\tswitch {\n\tcase t.IsBuiltinAssetDeposit():\n\t\treturn snapshot.TxRef{Asset: string(common.Builtin), BlockNr: 0, Hash: t.txHash, LogIndex: 0}\n\tcase t.IsERC20Deposit():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20AssetList():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20AssetLimitsUpdated():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20BridgeStopped():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tcase t.IsERC20BridgeResumed():\n\t\treturn snapshot.TxRef{Asset: string(common.ERC20), BlockNr: t.blockHeight, Hash: t.txHash, LogIndex: t.logIndex}\n\tdefault:\n\t\treturn snapshot.TxRef{} // this is basically unreachable\n\t}\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage banking\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"code.vegaprotocol.io/vega/core/assets/erc20\"\n\t\"code.vegaprotocol.io/vega/core/events\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\t\"code.vegaprotocol.io/vega/libs/num\"\n\t\"code.vegaprotocol.io/vega/logging\"\n)\n\nvar (\n\tErrInvalidWithdrawalReferenceNonce       = errors.New(\"invalid withdrawal reference nonce\")\n\tErrWithdrawalAmountUnderMinimalRequired  = errors.New(\"invalid withdrawal, amount under minimum required\")\n\tErrAssetAlreadyBeingListed               = errors.New(\"asset already being listed\")\n\tErrWithdrawalDisabledWhenBridgeIsStopped = errors.New(\"withdrawal issuance is disabled when the erc20 is stopped\")\n)\n\ntype ERC20BridgeView interface {\n\tFindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64, txHash string) error\n\tFindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64, txHash string) error\n\tFindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64, txHash string) error\n\tFindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error\n\tFindAssetLimitsUpdated(update *types.ERC20AssetLimitsUpdated, blockNumber uint64, logIndex uint64, ethAssetAddress string, txHash string) error\n}\n\nfunc (e *Engine) EnableERC20(\n\t_ context.Context,\n\tal *types.ERC20AssetList,\n\tid string,\n\tblockNumber, txIndex uint64,\n\ttxHash string,\n) error {\n\tasset, _ := e.assets.Get(al.VegaAssetID)\n\tif _, ok := e.assetActs[al.VegaAssetID]; ok {\n\t\te.log.Error(\"asset already being listed\", logging.AssetID(al.VegaAssetID))\n\t\treturn ErrAssetAlreadyBeingListed\n\t}\n\n\taa := &assetAction{\n\t\tid:          id,\n\t\tstate:       newPendingState(),\n\t\terc20AL:     al,\n\t\tasset:       asset,\n\t\tblockHeight: blockNumber,\n\t\tlogIndex:    txIndex,\n\t\ttxHash:      txHash,\n\t\tbridgeView:  e.bridgeView,\n\t}\n\te.addAction(aa)\n\treturn e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))\n}\n\nfunc (e *Engine) UpdateERC20(\n\t_ context.Context,\n\tevent *types.ERC20AssetLimitsUpdated,\n\tid string,\n\tblockNumber, txIndex uint64,\n\ttxHash string,\n) error {\n\tasset, err := e.assets.Get(event.VegaAssetID)\n\tif err != nil {\n\t\te.log.Panic(\"couldn't retrieve the ERC20 asset\",\n\t\t\tlogging.AssetID(event.VegaAssetID),\n\t\t)\n\t}\n\taa := &assetAction{\n\t\tid:                      id,\n\t\tstate:                   newPendingState(),\n\t\terc20AssetLimitsUpdated: event,\n\t\tasset:                   asset,\n\t\tblockHeight:             blockNumber,\n\t\tlogIndex:                txIndex,\n\t\ttxHash:                  txHash,\n\t\tbridgeView:              e.bridgeView,\n\t}\n\te.addAction(aa)\n\treturn e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))\n}\n\nfunc (e *Engine) DepositERC20(\n\tctx context.Context,\n\td *types.ERC20Deposit,\n\tid string,\n\tblockNumber, logIndex uint64,\n\ttxHash string,\n) error {\n\tdep := e.newDeposit(id, d.TargetPartyID, d.VegaAssetID, d.Amount, txHash)\n\n\t// check if the asset is correct\n\tasset, err := e.assets.Get(d.VegaAssetID)\n\tif err != nil {\n\t\tdep.Status = types.DepositStatusCancelled\n\t\te.broker.Send(events.NewDepositEvent(ctx, *dep))\n\t\te.log.Error(\"unable to get asset by id\",\n\t\t\tlogging.AssetID(d.VegaAssetID),\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\tif !asset.IsERC20() {\n\t\tdep.Status = types.DepositStatusCancelled\n\t\te.broker.Send(events.NewDepositEvent(ctx, *dep))\n\t\treturn fmt.Errorf(\"%v: %w\", asset.String(), ErrWrongAssetTypeUsedInERC20ChainEvent)\n\t}\n\n\taa := &assetAction{\n\t\tid:          dep.ID,\n\t\tstate:       newPendingState(),\n\t\terc20D:      d,\n\t\tasset:       asset,\n\t\tblockHeight: blockNumber,\n\t\tlogIndex:    logIndex,\n\t\ttxHash:      txHash,\n\t\tbridgeView:  e.bridgeView,\n\t}\n\te.addAction(aa)\n\te.deposits[dep.ID] = dep\n\n\te.broker.Send(events.NewDepositEvent(ctx, *dep))\n\treturn e.witness.StartCheck(aa, e.onCheckDone, e.timeService.GetTimeNow().Add(defaultValidationDuration))\n}\n\nfunc (e *Engine) ERC20WithdrawalEvent(\n\tctx context.Context, w *types.ERC20Withdrawal,\n\tblockNumber, txIndex uint64,\n\ttxHash string,\n) error {\n\t// check straight away if the withdrawal is signed\n\tnonce, ok := new(big.Int).SetString(w.ReferenceNonce, 10)\n\tif !ok {\n\t\treturn fmt.Errorf(\"%s: %w\", w.ReferenceNonce, ErrInvalidWithdrawalReferenceNonce)\n\t}\n\n\twithd, err := e.getWithdrawalFromRef(nonce)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: %w\", w.ReferenceNonce, err)\n\t}\n\tif withd.Status != types.WithdrawalStatusFinalized {\n\t\treturn fmt.Errorf(\"%s: %w\", withd.ID, ErrInvalidWithdrawalState)\n\t}\n\tif _, ok := e.notary.IsSigned(ctx, withd.ID, types.NodeSignatureKindAssetWithdrawal); !ok {\n\t\treturn ErrWithdrawalNotReady\n\t}\n\n\tif blockNumber > e.lastSeenEthBlock {\n\t\te.lastSeenEthBlock = blockNumber\n\t}\n\twithd.WithdrawalDate = e.timeService.GetTimeNow().UnixNano()\n\twithd.TxHash = txHash\n\te.broker.Send(events.NewWithdrawalEvent(ctx, *withd))\n\n\treturn nil\n}\n\nfunc (e *Engine) WithdrawERC20(\n\tctx context.Context,\n\tid, party, assetID string,\n\tamount *num.Uint,\n\text *types.Erc20WithdrawExt,\n) error {\n\tif e.bridgeState.IsStopped() {\n\t\treturn ErrWithdrawalDisabledWhenBridgeIsStopped\n\t}\n\n\twext := &types.WithdrawExt{\n\t\tExt: &types.WithdrawExtErc20{\n\t\t\tErc20: ext,\n\t\t},\n\t}\n\n\tw, ref := e.newWithdrawal(id, party, assetID, amount, wext)\n\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\te.withdrawals[w.ID] = withdrawalRef{w, ref}\n\n\tasset, err := e.assets.Get(assetID)\n\tif err != nil {\n\t\tw.Status = types.WithdrawalStatusRejected\n\t\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\t\te.log.Debug(\"unable to get asset by id\",\n\t\t\tlogging.AssetID(assetID),\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\t// check for minimal amount reached\n\tquantum := asset.Type().Details.Quantum\n\t// no reason this would produce an error\n\tminAmount, _ := num.UintFromDecimal(quantum.Mul(e.minWithdrawQuantumMultiple))\n\n\t// now verify amount\n\tif amount.LT(minAmount) {\n\t\te.log.Debug(\"cannot withdraw funds, the request is less than minimum withdrawal amount\",\n\t\t\tlogging.BigUint(\"min-amount\", minAmount),\n\t\t\tlogging.BigUint(\"requested-amount\", amount),\n\t\t)\n\t\tw.Status = types.WithdrawalStatusRejected\n\t\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\t\treturn ErrWithdrawalAmountUnderMinimalRequired\n\t}\n\n\tif a, ok := asset.ERC20(); !ok {\n\t\tw.Status = types.WithdrawalStatusRejected\n\t\te.broker.Send(events.NewWithdrawalEvent(ctx, *w))\n\t\treturn ErrWrongAssetUsedForERC20Withdraw\n\t} else if threshold := a.Type().Details.GetERC20().WithdrawThreshold; threshold != nil && threshold.NEQ(num.UintZero()) {\n\t\t// a delay will be applied on this withdrawal\n\t\tif threshold.LT(amount) {\n\t\t\te.log.Debug(\"withdraw threshold breached, delay will be applied\",\n\t\t\t\tlogging.PartyID(party),\n\t\t\t\tlogging.BigUint(\"threshold\", threshold),\n\t\t\t\tlogging.BigUint(\"amount\", amount),\n\t\t\t\tlogging.AssetID(assetID),\n\t\t\t\tlogging.Error(err))\n\t\t}\n\t}\n\n\t// try to withdraw if no error, this'll just abort\n\tif err := e.finalizeWithdraw(ctx, w); err != nil {\n\t\treturn err\n\t}\n\n\t// no check error as we checked earlier we had an erc20 asset.\n\terc20asset, _ := asset.ERC20()\n\n\t// startup aggregating signature for the bundle\n\treturn e.startERC20Signatures(w, erc20asset, ref)\n}\n\nfunc (e *Engine) startERC20Signatures(w *types.Withdrawal, asset *erc20.ERC20, ref *big.Int) error {\n\tvar (\n\t\tsignature []byte\n\t\terr       error\n\t)\n\n\tcreation := time.Unix(0, w.CreationDate)\n\t// if we are a validator, we want to build a signature\n\tif e.top.IsValidator() {\n\t\t_, signature, err = asset.SignWithdrawal(\n\t\t\tw.Amount, w.Ext.GetErc20().GetReceiverAddress(), ref, creation)\n\t\tif err != nil {\n\t\t\t// there's no reason we cannot build the signature here\n\t\t\t// apart if the node isn't configure properly\n\t\t\te.log.Panic(\"unable to sign withdrawal\",\n\t\t\t\tlogging.WithdrawalID(w.ID),\n\t\t\t\tlogging.PartyID(w.PartyID),\n\t\t\t\tlogging.AssetID(w.Asset),\n\t\t\t\tlogging.BigUint(\"amount\", w.Amount),\n\t\t\t\tlogging.Error(err))\n\t\t}\n\t}\n\n\t// we were able to lock the funds, then we can send the vote through the network\n\te.notary.StartAggregate(w.ID, types.NodeSignatureKindAssetWithdrawal, signature)\n\n\treturn nil\n}\n\nfunc (e *Engine) offerERC20NotarySignatures(resource string) []byte {\n\tif !e.top.IsValidator() {\n\t\treturn nil\n\t}\n\n\twref, ok := e.withdrawals[resource]\n\tif !ok {\n\t\t// there's no reason we cannot find the withdrawal here\n\t\t// apart if the node isn't configured properly\n\t\te.log.Panic(\"unable to find withdrawal\",\n\t\t\tlogging.WithdrawalID(resource))\n\t}\n\tw := wref.w\n\n\tasset, err := e.assets.Get(w.Asset)\n\tif err != nil {\n\t\t// there's no reason we cannot build the signature here\n\t\t// apart if the node isn't configure properly\n\t\te.log.Panic(\"unable to get asset when offering signature\",\n\t\t\tlogging.WithdrawalID(w.ID),\n\t\t\tlogging.PartyID(w.PartyID),\n\t\t\tlogging.AssetID(w.Asset),\n\t\t\tlogging.BigUint(\"amount\", w.Amount),\n\t\t\tlogging.Error(err))\n\t}\n\n\tcreation := time.Unix(0, w.CreationDate)\n\terc20asset, _ := asset.ERC20()\n\t_, signature, err := erc20asset.SignWithdrawal(\n\t\tw.Amount, w.Ext.GetErc20().GetReceiverAddress(), wref.ref, creation)\n\tif err != nil {\n\t\t// there's no reason we cannot build the signature here\n\t\t// apart if the node isn't configure properly\n\t\te.log.Panic(\"unable to sign withdrawal\",\n\t\t\tlogging.WithdrawalID(w.ID),\n\t\t\tlogging.PartyID(w.PartyID),\n\t\t\tlogging.AssetID(w.Asset),\n\t\t\tlogging.BigUint(\"amount\", w.Amount),\n\t\t\tlogging.Error(err))\n\t}\n\n\treturn signature\n}\n\nfunc (e *Engine) addAction(aa *assetAction) {\n\te.assetActs[aa.id] = aa\n\tif aa.blockHeight > e.lastSeenEthBlock {\n\t\te.lastSeenEthBlock = aa.blockHeight\n\t}\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: code.vegaprotocol.io/vega/core/banking (interfaces: Assets,Notary,Collateral,Witness,TimeService,EpochService,Topology,MarketActivityTracker,ERC20BridgeView,EthereumEventSource)\n\n// Package mocks is a generated GoMock package.\npackage mocks\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tassets \"code.vegaprotocol.io/vega/core/assets\"\n\ttypes \"code.vegaprotocol.io/vega/core/types\"\n\tvalidators \"code.vegaprotocol.io/vega/core/validators\"\n\tnum \"code.vegaprotocol.io/vega/libs/num\"\n\tvega \"code.vegaprotocol.io/vega/protos/vega\"\n\tv1 \"code.vegaprotocol.io/vega/protos/vega/commands/v1\"\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockAssets is a mock of Assets interface.\ntype MockAssets struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAssetsMockRecorder\n}\n\n// MockAssetsMockRecorder is the mock recorder for MockAssets.\ntype MockAssetsMockRecorder struct {\n\tmock *MockAssets\n}\n\n// NewMockAssets creates a new mock instance.\nfunc NewMockAssets(ctrl *gomock.Controller) *MockAssets {\n\tmock := &MockAssets{ctrl: ctrl}\n\tmock.recorder = &MockAssetsMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockAssets) EXPECT() *MockAssetsMockRecorder {\n\treturn m.recorder\n}\n\n// ApplyAssetUpdate mocks base method.\nfunc (m *MockAssets) ApplyAssetUpdate(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ApplyAssetUpdate\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ApplyAssetUpdate indicates an expected call of ApplyAssetUpdate.\nfunc (mr *MockAssetsMockRecorder) ApplyAssetUpdate(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ApplyAssetUpdate\", reflect.TypeOf((*MockAssets)(nil).ApplyAssetUpdate), arg0, arg1)\n}\n\n// Enable mocks base method.\nfunc (m *MockAssets) Enable(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Enable\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Enable indicates an expected call of Enable.\nfunc (mr *MockAssetsMockRecorder) Enable(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Enable\", reflect.TypeOf((*MockAssets)(nil).Enable), arg0, arg1)\n}\n\n// Get mocks base method.\nfunc (m *MockAssets) Get(arg0 string) (*assets.Asset, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", arg0)\n\tret0, _ := ret[0].(*assets.Asset)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockAssetsMockRecorder) Get(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*MockAssets)(nil).Get), arg0)\n}\n\n// MockNotary is a mock of Notary interface.\ntype MockNotary struct {\n\tctrl     *gomock.Controller\n\trecorder *MockNotaryMockRecorder\n}\n\n// MockNotaryMockRecorder is the mock recorder for MockNotary.\ntype MockNotaryMockRecorder struct {\n\tmock *MockNotary\n}\n\n// NewMockNotary creates a new mock instance.\nfunc NewMockNotary(ctrl *gomock.Controller) *MockNotary {\n\tmock := &MockNotary{ctrl: ctrl}\n\tmock.recorder = &MockNotaryMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockNotary) EXPECT() *MockNotaryMockRecorder {\n\treturn m.recorder\n}\n\n// IsSigned mocks base method.\nfunc (m *MockNotary) IsSigned(arg0 context.Context, arg1 string, arg2 v1.NodeSignatureKind) ([]v1.NodeSignature, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IsSigned\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]v1.NodeSignature)\n\tret1, _ := ret[1].(bool)\n\treturn ret0, ret1\n}\n\n// IsSigned indicates an expected call of IsSigned.\nfunc (mr *MockNotaryMockRecorder) IsSigned(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsSigned\", reflect.TypeOf((*MockNotary)(nil).IsSigned), arg0, arg1, arg2)\n}\n\n// OfferSignatures mocks base method.\nfunc (m *MockNotary) OfferSignatures(arg0 v1.NodeSignatureKind, arg1 func(string) []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"OfferSignatures\", arg0, arg1)\n}\n\n// OfferSignatures indicates an expected call of OfferSignatures.\nfunc (mr *MockNotaryMockRecorder) OfferSignatures(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OfferSignatures\", reflect.TypeOf((*MockNotary)(nil).OfferSignatures), arg0, arg1)\n}\n\n// StartAggregate mocks base method.\nfunc (m *MockNotary) StartAggregate(arg0 string, arg1 v1.NodeSignatureKind, arg2 []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"StartAggregate\", arg0, arg1, arg2)\n}\n\n// StartAggregate indicates an expected call of StartAggregate.\nfunc (mr *MockNotaryMockRecorder) StartAggregate(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StartAggregate\", reflect.TypeOf((*MockNotary)(nil).StartAggregate), arg0, arg1, arg2)\n}\n\n// MockCollateral is a mock of Collateral interface.\ntype MockCollateral struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCollateralMockRecorder\n}\n\n// MockCollateralMockRecorder is the mock recorder for MockCollateral.\ntype MockCollateralMockRecorder struct {\n\tmock *MockCollateral\n}\n\n// NewMockCollateral creates a new mock instance.\nfunc NewMockCollateral(ctrl *gomock.Controller) *MockCollateral {\n\tmock := &MockCollateral{ctrl: ctrl}\n\tmock.recorder = &MockCollateralMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockCollateral) EXPECT() *MockCollateralMockRecorder {\n\treturn m.recorder\n}\n\n// Deposit mocks base method.\nfunc (m *MockCollateral) Deposit(arg0 context.Context, arg1, arg2 string, arg3 *num.Uint) (*types.LedgerMovement, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Deposit\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(*types.LedgerMovement)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Deposit indicates an expected call of Deposit.\nfunc (mr *MockCollateralMockRecorder) Deposit(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Deposit\", reflect.TypeOf((*MockCollateral)(nil).Deposit), arg0, arg1, arg2, arg3)\n}\n\n// EnableAsset mocks base method.\nfunc (m *MockCollateral) EnableAsset(arg0 context.Context, arg1 types.Asset) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"EnableAsset\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// EnableAsset indicates an expected call of EnableAsset.\nfunc (mr *MockCollateralMockRecorder) EnableAsset(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"EnableAsset\", reflect.TypeOf((*MockCollateral)(nil).EnableAsset), arg0, arg1)\n}\n\n// GetPartyGeneralAccount mocks base method.\nfunc (m *MockCollateral) GetPartyGeneralAccount(arg0, arg1 string) (*types.Account, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetPartyGeneralAccount\", arg0, arg1)\n\tret0, _ := ret[0].(*types.Account)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetPartyGeneralAccount indicates an expected call of GetPartyGeneralAccount.\nfunc (mr *MockCollateralMockRecorder) GetPartyGeneralAccount(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetPartyGeneralAccount\", reflect.TypeOf((*MockCollateral)(nil).GetPartyGeneralAccount), arg0, arg1)\n}\n\n// PropagateAssetUpdate mocks base method.\nfunc (m *MockCollateral) PropagateAssetUpdate(arg0 context.Context, arg1 types.Asset) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PropagateAssetUpdate\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// PropagateAssetUpdate indicates an expected call of PropagateAssetUpdate.\nfunc (mr *MockCollateralMockRecorder) PropagateAssetUpdate(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PropagateAssetUpdate\", reflect.TypeOf((*MockCollateral)(nil).PropagateAssetUpdate), arg0, arg1)\n}\n\n// TransferFunds mocks base method.\nfunc (m *MockCollateral) TransferFunds(arg0 context.Context, arg1 []*types.Transfer, arg2 []vega.AccountType, arg3 []string, arg4 []*types.Transfer, arg5 []vega.AccountType) ([]*types.LedgerMovement, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"TransferFunds\", arg0, arg1, arg2, arg3, arg4, arg5)\n\tret0, _ := ret[0].([]*types.LedgerMovement)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// TransferFunds indicates an expected call of TransferFunds.\nfunc (mr *MockCollateralMockRecorder) TransferFunds(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"TransferFunds\", reflect.TypeOf((*MockCollateral)(nil).TransferFunds), arg0, arg1, arg2, arg3, arg4, arg5)\n}\n\n// Withdraw mocks base method.\nfunc (m *MockCollateral) Withdraw(arg0 context.Context, arg1, arg2 string, arg3 *num.Uint) (*types.LedgerMovement, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Withdraw\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(*types.LedgerMovement)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Withdraw indicates an expected call of Withdraw.\nfunc (mr *MockCollateralMockRecorder) Withdraw(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Withdraw\", reflect.TypeOf((*MockCollateral)(nil).Withdraw), arg0, arg1, arg2, arg3)\n}\n\n// MockWitness is a mock of Witness interface.\ntype MockWitness struct {\n\tctrl     *gomock.Controller\n\trecorder *MockWitnessMockRecorder\n}\n\n// MockWitnessMockRecorder is the mock recorder for MockWitness.\ntype MockWitnessMockRecorder struct {\n\tmock *MockWitness\n}\n\n// NewMockWitness creates a new mock instance.\nfunc NewMockWitness(ctrl *gomock.Controller) *MockWitness {\n\tmock := &MockWitness{ctrl: ctrl}\n\tmock.recorder = &MockWitnessMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockWitness) EXPECT() *MockWitnessMockRecorder {\n\treturn m.recorder\n}\n\n// RestoreResource mocks base method.\nfunc (m *MockWitness) RestoreResource(arg0 validators.Resource, arg1 func(interface{}, bool)) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RestoreResource\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RestoreResource indicates an expected call of RestoreResource.\nfunc (mr *MockWitnessMockRecorder) RestoreResource(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RestoreResource\", reflect.TypeOf((*MockWitness)(nil).RestoreResource), arg0, arg1)\n}\n\n// StartCheck mocks base method.\nfunc (m *MockWitness) StartCheck(arg0 validators.Resource, arg1 func(interface{}, bool), arg2 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"StartCheck\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// StartCheck indicates an expected call of StartCheck.\nfunc (mr *MockWitnessMockRecorder) StartCheck(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StartCheck\", reflect.TypeOf((*MockWitness)(nil).StartCheck), arg0, arg1, arg2)\n}\n\n// MockTimeService is a mock of TimeService interface.\ntype MockTimeService struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTimeServiceMockRecorder\n}\n\n// MockTimeServiceMockRecorder is the mock recorder for MockTimeService.\ntype MockTimeServiceMockRecorder struct {\n\tmock *MockTimeService\n}\n\n// NewMockTimeService creates a new mock instance.\nfunc NewMockTimeService(ctrl *gomock.Controller) *MockTimeService {\n\tmock := &MockTimeService{ctrl: ctrl}\n\tmock.recorder = &MockTimeServiceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockTimeService) EXPECT() *MockTimeServiceMockRecorder {\n\treturn m.recorder\n}\n\n// GetTimeNow mocks base method.\nfunc (m *MockTimeService) GetTimeNow() time.Time {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetTimeNow\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetTimeNow indicates an expected call of GetTimeNow.\nfunc (mr *MockTimeServiceMockRecorder) GetTimeNow() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetTimeNow\", reflect.TypeOf((*MockTimeService)(nil).GetTimeNow))\n}\n\n// MockEpochService is a mock of EpochService interface.\ntype MockEpochService struct {\n\tctrl     *gomock.Controller\n\trecorder *MockEpochServiceMockRecorder\n}\n\n// MockEpochServiceMockRecorder is the mock recorder for MockEpochService.\ntype MockEpochServiceMockRecorder struct {\n\tmock *MockEpochService\n}\n\n// NewMockEpochService creates a new mock instance.\nfunc NewMockEpochService(ctrl *gomock.Controller) *MockEpochService {\n\tmock := &MockEpochService{ctrl: ctrl}\n\tmock.recorder = &MockEpochServiceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockEpochService) EXPECT() *MockEpochServiceMockRecorder {\n\treturn m.recorder\n}\n\n// NotifyOnEpoch mocks base method.\nfunc (m *MockEpochService) NotifyOnEpoch(arg0, arg1 func(context.Context, types.Epoch)) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"NotifyOnEpoch\", arg0, arg1)\n}\n\n// NotifyOnEpoch indicates an expected call of NotifyOnEpoch.\nfunc (mr *MockEpochServiceMockRecorder) NotifyOnEpoch(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"NotifyOnEpoch\", reflect.TypeOf((*MockEpochService)(nil).NotifyOnEpoch), arg0, arg1)\n}\n\n// MockTopology is a mock of Topology interface.\ntype MockTopology struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTopologyMockRecorder\n}\n\n// MockTopologyMockRecorder is the mock recorder for MockTopology.\ntype MockTopologyMockRecorder struct {\n\tmock *MockTopology\n}\n\n// NewMockTopology creates a new mock instance.\nfunc NewMockTopology(ctrl *gomock.Controller) *MockTopology {\n\tmock := &MockTopology{ctrl: ctrl}\n\tmock.recorder = &MockTopologyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockTopology) EXPECT() *MockTopologyMockRecorder {\n\treturn m.recorder\n}\n\n// IsValidator mocks base method.\nfunc (m *MockTopology) IsValidator() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IsValidator\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// IsValidator indicates an expected call of IsValidator.\nfunc (mr *MockTopologyMockRecorder) IsValidator() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsValidator\", reflect.TypeOf((*MockTopology)(nil).IsValidator))\n}\n\n// MockMarketActivityTracker is a mock of MarketActivityTracker interface.\ntype MockMarketActivityTracker struct {\n\tctrl     *gomock.Controller\n\trecorder *MockMarketActivityTrackerMockRecorder\n}\n\n// MockMarketActivityTrackerMockRecorder is the mock recorder for MockMarketActivityTracker.\ntype MockMarketActivityTrackerMockRecorder struct {\n\tmock *MockMarketActivityTracker\n}\n\n// NewMockMarketActivityTracker creates a new mock instance.\nfunc NewMockMarketActivityTracker(ctrl *gomock.Controller) *MockMarketActivityTracker {\n\tmock := &MockMarketActivityTracker{ctrl: ctrl}\n\tmock.recorder = &MockMarketActivityTrackerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockMarketActivityTracker) EXPECT() *MockMarketActivityTrackerMockRecorder {\n\treturn m.recorder\n}\n\n// GetMarketScores mocks base method.\nfunc (m *MockMarketActivityTracker) GetMarketScores(arg0 string, arg1 []string, arg2 vega.DispatchMetric) []*types.MarketContributionScore {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetMarketScores\", arg0, arg1, arg2)\n\tret0, _ := ret[0].([]*types.MarketContributionScore)\n\treturn ret0\n}\n\n// GetMarketScores indicates an expected call of GetMarketScores.\nfunc (mr *MockMarketActivityTrackerMockRecorder) GetMarketScores(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetMarketScores\", reflect.TypeOf((*MockMarketActivityTracker)(nil).GetMarketScores), arg0, arg1, arg2)\n}\n\n// GetMarketsWithEligibleProposer mocks base method.\nfunc (m *MockMarketActivityTracker) GetMarketsWithEligibleProposer(arg0 string, arg1 []string, arg2, arg3 string) []*types.MarketContributionScore {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetMarketsWithEligibleProposer\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].([]*types.MarketContributionScore)\n\treturn ret0\n}\n\n// GetMarketsWithEligibleProposer indicates an expected call of GetMarketsWithEligibleProposer.\nfunc (mr *MockMarketActivityTrackerMockRecorder) GetMarketsWithEligibleProposer(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetMarketsWithEligibleProposer\", reflect.TypeOf((*MockMarketActivityTracker)(nil).GetMarketsWithEligibleProposer), arg0, arg1, arg2, arg3)\n}\n\n// MarkPaidProposer mocks base method.\nfunc (m *MockMarketActivityTracker) MarkPaidProposer(arg0, arg1 string, arg2 []string, arg3 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"MarkPaidProposer\", arg0, arg1, arg2, arg3)\n}\n\n// MarkPaidProposer indicates an expected call of MarkPaidProposer.\nfunc (mr *MockMarketActivityTrackerMockRecorder) MarkPaidProposer(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"MarkPaidProposer\", reflect.TypeOf((*MockMarketActivityTracker)(nil).MarkPaidProposer), arg0, arg1, arg2, arg3)\n}\n\n// MockERC20BridgeView is a mock of ERC20BridgeView interface.\ntype MockERC20BridgeView struct {\n\tctrl     *gomock.Controller\n\trecorder *MockERC20BridgeViewMockRecorder\n}\n\n// MockERC20BridgeViewMockRecorder is the mock recorder for MockERC20BridgeView.\ntype MockERC20BridgeViewMockRecorder struct {\n\tmock *MockERC20BridgeView\n}\n\n// NewMockERC20BridgeView creates a new mock instance.\nfunc NewMockERC20BridgeView(ctrl *gomock.Controller) *MockERC20BridgeView {\n\tmock := &MockERC20BridgeView{ctrl: ctrl}\n\tmock.recorder = &MockERC20BridgeViewMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockERC20BridgeView) EXPECT() *MockERC20BridgeViewMockRecorder {\n\treturn m.recorder\n}\n\n// FindAssetLimitsUpdated mocks base method.\nfunc (m *MockERC20BridgeView) FindAssetLimitsUpdated(arg0 *types.ERC20AssetLimitsUpdated, arg1, arg2 uint64, arg3, arg4 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindAssetLimitsUpdated\", arg0, arg1, arg2, arg3, arg4)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindAssetLimitsUpdated indicates an expected call of FindAssetLimitsUpdated.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindAssetLimitsUpdated(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetLimitsUpdated\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetLimitsUpdated), arg0, arg1, arg2, arg3, arg4)\n}\n\n// FindAssetList mocks base method.\nfunc (m *MockERC20BridgeView) FindAssetList(arg0 *types.ERC20AssetList, arg1, arg2 uint64, arg3 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindAssetList\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindAssetList indicates an expected call of FindAssetList.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindAssetList(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetList\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetList), arg0, arg1, arg2, arg3)\n}\n\n// FindBridgeResumed mocks base method.\nfunc (m *MockERC20BridgeView) FindBridgeResumed(arg0 *types.ERC20EventBridgeResumed, arg1, arg2 uint64, arg3 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBridgeResumed\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindBridgeResumed indicates an expected call of FindBridgeResumed.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindBridgeResumed(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeResumed\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeResumed), arg0, arg1, arg2, arg3)\n}\n\n// FindBridgeStopped mocks base method.\nfunc (m *MockERC20BridgeView) FindBridgeStopped(arg0 *types.ERC20EventBridgeStopped, arg1, arg2 uint64, arg3 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindBridgeStopped\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindBridgeStopped indicates an expected call of FindBridgeStopped.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindBridgeStopped(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeStopped\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeStopped), arg0, arg1, arg2, arg3)\n}\n\n// FindDeposit mocks base method.\nfunc (m *MockERC20BridgeView) FindDeposit(arg0 *types.ERC20Deposit, arg1, arg2 uint64, arg3, arg4 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindDeposit\", arg0, arg1, arg2, arg3, arg4)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FindDeposit indicates an expected call of FindDeposit.\nfunc (mr *MockERC20BridgeViewMockRecorder) FindDeposit(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindDeposit\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindDeposit), arg0, arg1, arg2, arg3, arg4)\n}\n\n// MockEthereumEventSource is a mock of EthereumEventSource interface.\ntype MockEthereumEventSource struct {\n\tctrl     *gomock.Controller\n\trecorder *MockEthereumEventSourceMockRecorder\n}\n\n// MockEthereumEventSourceMockRecorder is the mock recorder for MockEthereumEventSource.\ntype MockEthereumEventSourceMockRecorder struct {\n\tmock *MockEthereumEventSource\n}\n\n// NewMockEthereumEventSource creates a new mock instance.\nfunc NewMockEthereumEventSource(ctrl *gomock.Controller) *MockEthereumEventSource {\n\tmock := &MockEthereumEventSource{ctrl: ctrl}\n\tmock.recorder = &MockEthereumEventSourceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockEthereumEventSource) EXPECT() *MockEthereumEventSourceMockRecorder {\n\treturn m.recorder\n}\n\n// UpdateCollateralStartingBlock mocks base method.\nfunc (m *MockEthereumEventSource) UpdateCollateralStartingBlock(arg0 uint64) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"UpdateCollateralStartingBlock\", arg0)\n}\n\n// UpdateCollateralStartingBlock indicates an expected call of UpdateCollateralStartingBlock.\nfunc (mr *MockEthereumEventSourceMockRecorder) UpdateCollateralStartingBlock(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateCollateralStartingBlock\", reflect.TypeOf((*MockEthereumEventSource)(nil).UpdateCollateralStartingBlock), arg0)\n}\n", "package bridges\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\terc20contract \"code.vegaprotocol.io/vega/core/contracts/erc20\"\n\tbridgecontract \"code.vegaprotocol.io/vega/core/contracts/erc20_bridge_logic_restricted\"\n\t\"code.vegaprotocol.io/vega/core/metrics\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\tvgerrors \"code.vegaprotocol.io/vega/libs/errors\"\n\t\"code.vegaprotocol.io/vega/libs/num\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\tethcommon \"github.com/ethereum/go-ethereum/common\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n)\n\nvar (\n\tErrNotAnERC20Asset                     = errors.New(\"not an erc20 asset\")\n\tErrUnableToFindERC20AssetList          = errors.New(\"unable to find erc20 asset list event\")\n\tErrUnableToFindERC20BridgeStopped      = errors.New(\"unable to find erc20 bridge stopped event\")\n\tErrUnableToFindERC20BridgeResumed      = errors.New(\"unable to find erc20 bridge resumed event\")\n\tErrUnableToFindERC20Deposit            = errors.New(\"unable to find erc20 asset deposit\")\n\tErrUnableToFindERC20Withdrawal         = errors.New(\"unabled to find erc20 asset withdrawal\")\n\tErrUnableToFindERC20AssetLimitsUpdated = errors.New(\"unable to find erc20 asset limits update event\")\n)\n\n//go:generate go run github.com/golang/mock/mockgen -destination mocks/eth_client_mock.go -package mocks code.vegaprotocol.io/vega/core/bridges ETHClient\ntype ETHClient interface {\n\tbind.ContractBackend\n\tHeaderByNumber(context.Context, *big.Int) (*ethtypes.Header, error)\n\tCollateralBridgeAddress() ethcommon.Address\n\tCurrentHeight(context.Context) (uint64, error)\n\tConfirmationsRequired() uint64\n}\n\n//go:generate go run github.com/golang/mock/mockgen -destination mocks/eth_confirmations_mock.go -package mocks code.vegaprotocol.io/vega/core/bridges EthConfirmations\ntype EthConfirmations interface {\n\tCheck(uint64) error\n}\n\n// ERC20Logic yea that's a weird name but\n// it just matches the name of the contract.\ntype ERC20LogicView struct {\n\tclt      ETHClient\n\tethConfs EthConfirmations\n}\n\nfunc NewERC20LogicView(\n\tclt ETHClient,\n\tethConfs EthConfirmations,\n) *ERC20LogicView {\n\treturn &ERC20LogicView{\n\t\tclt:      clt,\n\t\tethConfs: ethConfs,\n\t}\n}\n\n// FindAsset will try to find an asset and validate it's details on ethereum.\nfunc (e *ERC20LogicView) FindAsset(\n\tasset *types.AssetDetails,\n) error {\n\tsource := asset.GetERC20()\n\tif source == nil {\n\t\treturn ErrNotAnERC20Asset\n\t}\n\n\tt, err := erc20contract.NewErc20(ethcommon.HexToAddress(source.ContractAddress), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalidationErrs := vgerrors.NewCumulatedErrors()\n\n\tif name, err := t.Name(&bind.CallOpts{}); err != nil {\n\t\tvalidationErrs.Add(fmt.Errorf(\"couldn't get name: %w\", err))\n\t} else if name != asset.Name {\n\t\tvalidationErrs.Add(fmt.Errorf(\"invalid name, expected(%s), got(%s)\", asset.Name, name))\n\t}\n\n\tif symbol, err := t.Symbol(&bind.CallOpts{}); err != nil {\n\t\tvalidationErrs.Add(fmt.Errorf(\"couldn't get symbol: %w\", err))\n\t} else if symbol != asset.Symbol {\n\t\tvalidationErrs.Add(fmt.Errorf(\"invalid symbol, expected(%s), got(%s)\", asset.Symbol, symbol))\n\t}\n\n\tif decimals, err := t.Decimals(&bind.CallOpts{}); err != nil {\n\t\tvalidationErrs.Add(fmt.Errorf(\"couldn't get decimals: %w\", err))\n\t} else if uint64(decimals) != asset.Decimals {\n\t\tvalidationErrs.Add(fmt.Errorf(\"invalid decimals, expected(%d), got(%d)\", asset.Decimals, decimals))\n\t}\n\n\tif validationErrs.HasAny() {\n\t\treturn validationErrs\n\t}\n\n\treturn nil\n}\n\n// FindAssetList will look at the ethereum logs and try to find the\n// given transaction.\nfunc (e *ERC20LogicView) FindAssetList(\n\tal *types.ERC20AssetList,\n\tblockNumber,\n\tlogIndex uint64,\n\ttxHash string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_asset_list\", al.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetListed(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(al.AssetSource)},\n\t\t[][32]byte{},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetListed\n\tassetID := strings.TrimPrefix(al.VegaAssetID, \"0x\")\n\n\tfor iter.Next() {\n\t\tif hex.EncodeToString(iter.Event.VegaAssetId[:]) == assetID &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20AssetList\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// FindBridgeStopped will look at the ethereum logs and try to find the\n// given transaction.\nfunc (e *ERC20LogicView) FindBridgeStopped(\n\tal *types.ERC20EventBridgeStopped,\n\tblockNumber,\n\tlogIndex uint64,\n\ttxHash string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_bridge_stopped\", resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterBridgeStopped(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedBridgeStopped\n\n\tfor iter.Next() {\n\t\tif iter.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20BridgeStopped\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// FindBridgeResumed will look at the ethereum logs and try to find the\n// given transaction.\nfunc (e *ERC20LogicView) FindBridgeResumed(\n\tal *types.ERC20EventBridgeResumed,\n\tblockNumber,\n\tlogIndex uint64,\n\ttxHash string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_bridge_stopped\", resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterBridgeResumed(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedBridgeResumed\n\n\tfor iter.Next() {\n\t\tif iter.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20BridgeStopped\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (e *ERC20LogicView) FindDeposit(\n\td *types.ERC20Deposit,\n\tblockNumber, logIndex uint64,\n\tethAssetAddress string,\n\ttxHash string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_deposit\", d.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetDeposited(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t// user_address\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(d.SourceEthereumAddress)},\n\t\t// asset_source\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(ethAssetAddress)})\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tdepamount := d.Amount.BigInt()\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetDeposited\n\ttargetPartyID := strings.TrimPrefix(d.TargetPartyID, \"0x\")\n\n\tfor iter.Next() {\n\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == targetPartyID &&\n\t\t\titer.Event.Amount.Cmp(depamount) == 0 &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n\t\t\tevent = iter.Event\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20Deposit\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (e *ERC20LogicView) FindWithdrawal(\n\tw *types.ERC20Withdrawal,\n\tblockNumber, logIndex uint64,\n\tethAssetAddress string,\n\ttxHash string,\n) (*big.Int, string, uint, error) {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn nil, \"\", 0, err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_withdrawal\", w.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetWithdrawn(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t// user_address\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(w.TargetEthereumAddress)},\n\t\t// asset_source\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(ethAssetAddress)})\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn nil, \"\", 0, err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetWithdrawn\n\tnonce := &big.Int{}\n\t_, ok := nonce.SetString(w.ReferenceNonce, 10)\n\tif !ok {\n\t\treturn nil, \"\", 0, fmt.Errorf(\"could not use reference nonce, expected base 10 integer: %v\", w.ReferenceNonce)\n\t}\n\n\tfor iter.Next() {\n\t\tif nonce.Cmp(iter.Event.Nonce) == 0 &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n\t\t\tevent = iter.Event\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn nil, \"\", 0, ErrUnableToFindERC20Withdrawal\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn nil, \"\", 0, err\n\t}\n\n\treturn nonce, event.Raw.TxHash.Hex(), event.Raw.Index, nil\n}\n\nfunc (e *ERC20LogicView) FindAssetLimitsUpdated(\n\tupdate *types.ERC20AssetLimitsUpdated,\n\tblockNumber uint64, logIndex uint64,\n\tethAssetAddress string,\n\ttxHash string,\n) error {\n\tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n\t\te.clt.CollateralBridgeAddress(), e.clt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp := \"ok\"\n\tdefer func() {\n\t\tmetrics.EthCallInc(\"find_asset_limits_updated\", update.VegaAssetID, resp)\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\titer, err := bf.FilterAssetLimitsUpdated(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   blockNumber - 1,\n\t\t\tContext: ctx,\n\t\t},\n\t\t[]ethcommon.Address{ethcommon.HexToAddress(ethAssetAddress)},\n\t)\n\tif err != nil {\n\t\tresp = getMaybeHTTPStatus(err)\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tvar event *bridgecontract.Erc20BridgeLogicRestrictedAssetLimitsUpdated\n\n\tfor iter.Next() {\n\t\teventLifetimeLimit, _ := num.UintFromBig(iter.Event.LifetimeLimit)\n\t\teventWithdrawThreshold, _ := num.UintFromBig(iter.Event.WithdrawThreshold)\n\t\tif update.LifetimeLimits.EQ(eventLifetimeLimit) &&\n\t\t\tupdate.WithdrawThreshold.EQ(eventWithdrawThreshold) &&\n\t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n\t\t\tevent = iter.Event\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif event == nil {\n\t\treturn ErrUnableToFindERC20AssetLimitsUpdated\n\t}\n\n\t// now ensure we have enough confirmations\n\tif err := e.ethConfs.Check(event.Raw.BlockNumber); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc getMaybeHTTPStatus(err error) string {\n\terrstr := err.Error()\n\tif len(errstr) < 3 {\n\t\treturn \"tooshort\"\n\t}\n\ti, err := strconv.Atoi(errstr[:3])\n\tif err != nil {\n\t\treturn \"nan\"\n\t}\n\tif http.StatusText(i) == \"\" {\n\t\treturn \"unknown\"\n\t}\n\n\treturn errstr[:3]\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage stubs\n\nimport (\n\t\"code.vegaprotocol.io/vega/core/types\"\n)\n\ntype BridgeViewStub struct{}\n\nfunc NewBridgeViewStub() *BridgeViewStub {\n\treturn &BridgeViewStub{}\n}\n\nfunc (*BridgeViewStub) FindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64, txHash string) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64, txHash string) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64, txHash string) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error {\n\treturn nil\n}\n\nfunc (*BridgeViewStub) FindAssetLimitsUpdated(w *types.ERC20AssetLimitsUpdated, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error {\n\treturn nil\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage staking\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"code.vegaprotocol.io/vega/core/types\"\n\t\"code.vegaprotocol.io/vega/logging\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\tethcmn \"github.com/ethereum/go-ethereum/common\"\n)\n\ntype EthereumClient interface {\n\tbind.ContractFilterer\n}\n\ntype OnChainVerifier struct {\n\tlog              *logging.Logger\n\tethClient        EthereumClient\n\tethConfirmations EthConfirmations\n\n\tmu                     sync.RWMutex\n\tstakingBridgeAddresses []ethcmn.Address\n}\n\nfunc NewOnChainVerifier(\n\tcfg Config,\n\tlog *logging.Logger,\n\tethClient EthereumClient,\n\tethConfirmations EthConfirmations,\n) *OnChainVerifier {\n\tlog = log.Named(\"on-chain-verifier\")\n\tlog.SetLevel(cfg.Level.Get())\n\n\treturn &OnChainVerifier{\n\t\tlog:              log,\n\t\tethClient:        ethClient,\n\t\tethConfirmations: ethConfirmations,\n\t}\n}\n\nfunc (o *OnChainVerifier) UpdateStakingBridgeAddresses(stakingBridgeAddresses []ethcmn.Address) {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\n\to.stakingBridgeAddresses = stakingBridgeAddresses\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\tvar addresses []string\n\t\tfor _, v := range o.stakingBridgeAddresses {\n\t\t\taddresses = append(addresses, v.Hex())\n\t\t}\n\t\to.log.Debug(\"staking bridge addresses updated\",\n\t\t\tlogging.Strings(\"addresses\", addresses))\n\t}\n}\n\nfunc (o *OnChainVerifier) CheckStakeDeposited(\n\tevent *types.StakeDeposited,\n) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking stake deposited event on chain\",\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tdecodedPubKeySlice, err := hex.DecodeString(event.VegaPubKey)\n\tif err != nil {\n\t\to.log.Error(\"invalid pubkey in stake deposited event\", logging.Error(err))\n\t\treturn err\n\t}\n\tvar decodedPubKey [32]byte\n\tcopy(decodedPubKey[:], decodedPubKeySlice[0:32])\n\n\tfor _, address := range o.stakingBridgeAddresses {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"checking stake deposited event on chain\",\n\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\tlogging.String(\"event\", event.String()),\n\t\t\t)\n\t\t}\n\t\tfilterer, err := NewStakingFilterer(address, o.ethClient)\n\t\tif err != nil {\n\t\t\to.log.Error(\"could not instantiate staking bridge filterer\",\n\t\t\t\tlogging.String(\"address\", address.Hex()))\n\t\t\tcontinue\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\titer, err := filterer.FilterStakeDeposited(\n\t\t\t&bind.FilterOpts{\n\t\t\t\tStart:   event.BlockNumber,\n\t\t\t\tEnd:     &event.BlockNumber,\n\t\t\t\tContext: ctx,\n\t\t\t},\n\t\t\t// user\n\t\t\t[]ethcmn.Address{ethcmn.HexToAddress(event.EthereumAddress)},\n\t\t\t// vega_public_key\n\t\t\t[][32]byte{decodedPubKey})\n\t\tif err != nil {\n\t\t\to.log.Error(\"Couldn't start filtering on stake deposited event\", logging.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer iter.Close()\n\n\t\tvegaPubKey := strings.TrimPrefix(event.VegaPubKey, \"0x\")\n\t\tamountDeposited := event.Amount.BigInt()\n\n\t\tfor iter.Next() {\n\t\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\t\to.log.Debug(\"found stake deposited event on chain\",\n\t\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\t\tlogging.String(\"amount\", iter.Event.Amount.String()),\n\t\t\t\t\tlogging.String(\"user\", iter.Event.User.Hex()),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == vegaPubKey &&\n\t\t\t\titer.Event.Amount.Cmp(amountDeposited) == 0 &&\n\t\t\t\titer.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\t\titer.Event.Raw.TxHash.Hex() == event.TxID {\n\t\t\t\t// now we know the event is OK,\n\t\t\t\t// just need to check for confirmations\n\t\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ErrNoStakeDepositedEventFound\n}\n\nfunc (o *OnChainVerifier) CheckStakeRemoved(event *types.StakeRemoved) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking stake removed event on chain\",\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tdecodedPubKeySlice, err := hex.DecodeString(event.VegaPubKey)\n\tif err != nil {\n\t\to.log.Error(\"invalid pubkey inn stake deposited event\", logging.Error(err))\n\t\treturn err\n\t}\n\tvar decodedPubKey [32]byte\n\tcopy(decodedPubKey[:], decodedPubKeySlice[0:32])\n\n\tfor _, address := range o.stakingBridgeAddresses {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"checking stake removed event on chain\",\n\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\tlogging.String(\"event\", event.String()),\n\t\t\t)\n\t\t}\n\t\tfilterer, err := NewStakingFilterer(address, o.ethClient)\n\t\tif err != nil {\n\t\t\to.log.Error(\"could not instantiate staking bridge filterer\",\n\t\t\t\tlogging.String(\"address\", address.Hex()))\n\t\t\tcontinue\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\titer, err := filterer.FilterStakeRemoved(\n\t\t\t&bind.FilterOpts{\n\t\t\t\tStart:   event.BlockNumber,\n\t\t\t\tEnd:     &event.BlockNumber,\n\t\t\t\tContext: ctx,\n\t\t\t},\n\t\t\t// user\n\t\t\t[]ethcmn.Address{ethcmn.HexToAddress(event.EthereumAddress)},\n\t\t\t// vega_public_key\n\t\t\t[][32]byte{decodedPubKey})\n\t\tif err != nil {\n\t\t\to.log.Error(\"could not start stake deposited filter\",\n\t\t\t\tlogging.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer iter.Close()\n\n\t\tvegaPubKey := strings.TrimPrefix(event.VegaPubKey, \"0x\")\n\t\tamountDeposited := event.Amount.BigInt()\n\n\t\tfor iter.Next() {\n\t\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\t\to.log.Debug(\"found stake removed event on chain\",\n\t\t\t\t\tlogging.String(\"bridge-address\", address.Hex()),\n\t\t\t\t\tlogging.String(\"amount\", iter.Event.Amount.String()),\n\t\t\t\t\tlogging.String(\"user\", iter.Event.User.Hex()),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == vegaPubKey &&\n\t\t\t\titer.Event.Amount.Cmp(amountDeposited) == 0 &&\n\t\t\t\titer.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\t\titer.Event.Raw.TxHash.Hex() == event.TxID {\n\t\t\t\t// now we know the event is OK,\n\t\t\t\t// just need to check for confirmations\n\t\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ErrNoStakeRemovedEventFound\n}\n", "// Copyright (c) 2022 Gobalsky Labs Limited\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.\n//\n// Change Date: 18 months from the later of the date of the first publicly\n// available Distribution of this version of the repository, and 25 June 2022.\n//\n// On the date above, in accordance with the Business Source License, use\n// of this software will be governed by version 3 or later of the GNU General\n// Public License.\n\npackage erc20multisig\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"math/big\"\n\t\"sync\"\n\t\"time\"\n\n\tmultisig \"code.vegaprotocol.io/vega/core/contracts/multisig_control\"\n\t\"code.vegaprotocol.io/vega/core/types\"\n\t\"code.vegaprotocol.io/vega/logging\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\tethcmn \"github.com/ethereum/go-ethereum/common\"\n)\n\nvar (\n\tErrNoSignerEventFound       = errors.New(\"no signer event found\")\n\tErrNoThresholdSetEventFound = errors.New(\"no threshold set event found\")\n\tErrUnsupportedSignerEvent   = errors.New(\"unsupported signer event\")\n)\n\ntype EthereumClient interface {\n\tbind.ContractFilterer\n}\n\ntype EthConfirmations interface {\n\tCheck(uint64) error\n}\n\ntype OnChainVerifier struct {\n\tconfig           Config\n\tlog              *logging.Logger\n\tethClient        EthereumClient\n\tethConfirmations EthConfirmations\n\n\tmu              sync.RWMutex\n\tmultiSigAddress ethcmn.Address\n}\n\nfunc NewOnChainVerifier(\n\tconfig Config,\n\tlog *logging.Logger,\n\tethClient EthereumClient,\n\tethConfirmations EthConfirmations,\n) *OnChainVerifier {\n\tlog = log.Named(namedLogger + \".on-chain-verifier\")\n\tlog.SetLevel(config.Level.Get())\n\n\treturn &OnChainVerifier{\n\t\tconfig:           config,\n\t\tlog:              log,\n\t\tethClient:        ethClient,\n\t\tethConfirmations: ethConfirmations,\n\t}\n}\n\nfunc (o *OnChainVerifier) UpdateMultiSigAddress(multiSigAddress ethcmn.Address) {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\n\to.multiSigAddress = multiSigAddress\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"multi sig bridge addresses updated\",\n\t\t\tlogging.String(\"addresses\", o.multiSigAddress.Hex()))\n\t}\n}\n\nfunc (o *OnChainVerifier) CheckSignerEvent(event *types.SignerEvent) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking signer event on chain\",\n\t\t\tlogging.String(\"contract-address\", o.multiSigAddress.Hex()),\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tfilterer, err := multisig.NewMultisigControlFilterer(\n\t\to.multiSigAddress,\n\t\to.ethClient,\n\t)\n\tif err != nil {\n\t\to.log.Error(\"could not instantiate multisig control filterer\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tswitch event.Kind {\n\tcase types.SignerEventKindAdded:\n\t\treturn o.filterSignerAdded(ctx, filterer, event)\n\tcase types.SignerEventKindRemoved:\n\t\treturn o.filterSignerRemoved(ctx, filterer, event)\n\tdefault:\n\t\treturn ErrUnsupportedSignerEvent\n\t}\n}\n\nfunc (o *OnChainVerifier) CheckThresholdSetEvent(\n\tevent *types.SignerThresholdSetEvent,\n) error {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\to.log.Debug(\"checking threshold set event on chain\",\n\t\t\tlogging.String(\"contract-address\", o.multiSigAddress.Hex()),\n\t\t\tlogging.String(\"event\", event.String()),\n\t\t)\n\t}\n\n\tfilterer, err := multisig.NewMultisigControlFilterer(\n\t\to.multiSigAddress,\n\t\to.ethClient,\n\t)\n\tif err != nil {\n\t\to.log.Error(\"could not instantiate multisig control filterer\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\titer, err := filterer.FilterThresholdSet(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   event.BlockNumber,\n\t\t\tEnd:     &event.BlockNumber,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\to.log.Error(\"Couldn't start filtering on signer added event\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tfor iter.Next() {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"found threshold set event on chain\",\n\t\t\t\tlogging.Uint16(\"new-threshold\", iter.Event.NewThreshold),\n\t\t\t)\n\t\t}\n\n\t\tnonce, _ := big.NewInt(0).SetString(event.Nonce, 10)\n\t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\titer.Event.NewThreshold == uint16(event.Threshold) &&\n\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 &&\n\t\t\titer.Event.Raw.TxHash.Hex() == event.TxHash {\n\t\t\t// now we know the event is OK,\n\t\t\t// just need to check for confirmations\n\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t}\n\t}\n\n\treturn ErrNoThresholdSetEventFound\n}\n\nfunc (o *OnChainVerifier) filterSignerAdded(\n\tctx context.Context,\n\tfilterer *multisig.MultisigControlFilterer,\n\tevent *types.SignerEvent,\n) error {\n\titer, err := filterer.FilterSignerAdded(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   event.BlockNumber,\n\t\t\tEnd:     &event.BlockNumber,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\to.log.Error(\"Couldn't start filtering on signer added event\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tfor iter.Next() {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"found signer added event on chain\",\n\t\t\t\tlogging.String(\"new-signer\", iter.Event.NewSigner.Hex()),\n\t\t\t)\n\t\t}\n\n\t\tnonce, _ := big.NewInt(0).SetString(event.Nonce, 10)\n\t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\titer.Event.NewSigner.Hex() == event.Address &&\n\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 &&\n\t\t\titer.Event.Raw.TxHash.Hex() == event.TxHash {\n\t\t\t// now we know the event is OK,\n\t\t\t// just need to check for confirmations\n\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t}\n\t}\n\n\treturn ErrNoSignerEventFound\n}\n\nfunc (o *OnChainVerifier) filterSignerRemoved(\n\tctx context.Context,\n\tfilterer *multisig.MultisigControlFilterer,\n\tevent *types.SignerEvent,\n) error {\n\titer, err := filterer.FilterSignerRemoved(\n\t\t&bind.FilterOpts{\n\t\t\tStart:   event.BlockNumber,\n\t\t\tEnd:     &event.BlockNumber,\n\t\t\tContext: ctx,\n\t\t},\n\t)\n\tif err != nil {\n\t\to.log.Error(\"Couldn't start filtering on signer removed event\",\n\t\t\tlogging.Error(err))\n\t\treturn err\n\t}\n\tdefer iter.Close()\n\n\tfor iter.Next() {\n\t\tif o.log.GetLevel() <= logging.DebugLevel {\n\t\t\to.log.Debug(\"found signer removed event on chain\",\n\t\t\t\tlogging.String(\"old-signer\", iter.Event.OldSigner.Hex()),\n\t\t\t)\n\t\t}\n\n\t\tnonce, _ := big.NewInt(0).SetString(event.Nonce, 10)\n\t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n\t\t\titer.Event.OldSigner.Hex() == event.Address &&\n\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 &&\n\t\t\titer.Event.Raw.TxHash.Hex() == event.TxHash {\n\t\t\t// now we know the event is OK,\n\t\t\t// just need to check for confirmations\n\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n\t\t}\n\t}\n\n\treturn ErrNoSignerEventFound\n}\n"], "filenames": ["core/banking/asset_action.go", "core/banking/erc20.go", "core/banking/mocks/mocks.go", "core/bridges/erc20_logic_view.go", "core/integration/stubs/bridge_view_stub.go", "core/staking/on_chain_verifier.go", "core/validators/erc20multisig/on_chain_verifier.go"], "buggy_code_start_loc": [157, 37, 507, 113, 25, 141, 168], "buggy_code_end_loc": [180, 42, 574, 438, 42, 220, 249], "fixing_code_start_loc": [157, 37, 507, 114, 25, 141, 168], "fixing_code_end_loc": [180, 42, 574, 450, 42, 222, 252], "type": "CWE-20", "message": "Vega is a decentralized trading platform that allows pseudo-anonymous trading of derivatives on a blockchain. Prior to version 0.71.6, a vulnerability exists that allows a malicious validator to trick the Vega network into re-processing past Ethereum events from Vega\u2019s Ethereum bridge. For example, a deposit to the collateral bridge for 100USDT that credits a party\u2019s general account on Vega, can be re-processed 50 times resulting in 5000USDT in that party\u2019s general account. This is without depositing any more than the original 100USDT on the bridge. Despite this exploit requiring access to a validator's Vega key, a validator key can be obtained at the small cost of 3000VEGA, the amount needed to announce a new node onto the network.\n\nA patch is available in version 0.71.6. No known workarounds are available, however there are mitigations in place should this vulnerability be exploited. There are monitoring alerts for `mainnet1` in place to identify any issues of this nature including this vulnerability being exploited. The validators have the ability to stop the bridge thus stopping any withdrawals should this vulnerability be exploited.", "other": {"cve": {"id": "CVE-2023-35163", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-23T21:15:09.473", "lastModified": "2023-08-17T14:29:48.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vega is a decentralized trading platform that allows pseudo-anonymous trading of derivatives on a blockchain. Prior to version 0.71.6, a vulnerability exists that allows a malicious validator to trick the Vega network into re-processing past Ethereum events from Vega\u2019s Ethereum bridge. For example, a deposit to the collateral bridge for 100USDT that credits a party\u2019s general account on Vega, can be re-processed 50 times resulting in 5000USDT in that party\u2019s general account. This is without depositing any more than the original 100USDT on the bridge. Despite this exploit requiring access to a validator's Vega key, a validator key can be obtained at the small cost of 3000VEGA, the amount needed to announce a new node onto the network.\n\nA patch is available in version 0.71.6. No known workarounds are available, however there are mitigations in place should this vulnerability be exploited. There are monitoring alerts for `mainnet1` in place to identify any issues of this nature including this vulnerability being exploited. The validators have the ability to stop the bridge thus stopping any withdrawals should this vulnerability be exploited."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:L", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 5.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:H/UI:R/S:C/C:H/I:L/A:L", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.2, "impactScore": 5.3}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gobalsky:vega:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.71.6", "matchCriteriaId": "D319C59F-98E1-4772-9AF9-E5F381967AAA"}]}]}], "references": [{"url": "https://github.com/vegaprotocol/vega/commit/56b09bf57af8cd9eca5996252d86f469a3e34c68", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vegaprotocol/vega/releases/tag/v0.71.6", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/vegaprotocol/vega/security/advisories/GHSA-8rc9-vxjh-qjf2", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vegaprotocol/vega/commit/56b09bf57af8cd9eca5996252d86f469a3e34c68"}}