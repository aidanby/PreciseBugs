{"buggy_code": ["#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <libssh/libssh.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#ifdef HAVE_CURSES_H\n#include <curses.h>\n#else\n#include <ncurses.h>\n#endif\n#include <term.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <signal.h>\n#include \"tmate.h\"\n\nstatic char *cmdline;\nstatic char *cmdline_end;\n\nstruct tmate_settings _tmate_settings = {\n\t.keys_dir        \t= TMATE_SSH_DEFAULT_KEYS_DIR,\n\t.ssh_port        \t= TMATE_SSH_DEFAULT_PORT,\n\t.ssh_port_advertized    = -1,\n\t.websocket_hostname  \t= NULL,\n\t.bind_addr\t \t= NULL,\n\t.websocket_port      \t= TMATE_DEFAULT_WEBSOCKET_PORT,\n\t.tmate_host      \t= NULL,\n\t.log_level      \t= LOG_INFO,\n\t.use_proxy_protocol\t= false,\n};\n\nstruct tmate_settings *tmate_settings = &_tmate_settings;\n\nextern int server_fd;\nextern void server_send_exit(void);\nvoid request_server_termination(void)\n{\n\tif (server_fd) {\n\t\tserver_send_exit();\n\t} else\n\t\texit(1);\n}\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"usage: tmate-ssh-server [-b ip] [-h hostname] [-k keys_dir] [-p listen_port] [-q ssh_port_advertized] [-w websocket_hostname] [-z websocket_port] [-x] [-v]\\n\");\n}\n\nstatic char* get_full_hostname(void)\n{\n\tstruct addrinfo hints, *info;\n\tchar hostname[1024];\n\tint gai_result;\n\tchar *ret;\n\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\ttmate_fatal(\"cannot get hostname\");\n\thostname[1023] = '\\0';\n\n\tmemset(&hints, 0, sizeof hints);\n\thints.ai_family = AF_UNSPEC; /*either IPV4 or IPV6*/\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_CANONNAME;\n\n\tif ((gai_result = getaddrinfo(hostname, NULL, &hints, &info)) != 0) {\n\t\ttmate_info(\"cannot lookup hostname: %s\", gai_strerror(gai_result));\n\t\treturn xstrdup(hostname);\n\t}\n\n\tret = xstrdup(info->ai_canonname);\n\n\tfreeaddrinfo(info);\n\treturn ret;\n}\n#include <langinfo.h>\n#include <locale.h>\n\nstatic void setup_locale(void)\n{\n\tconst char *s;\n\n\tif (setlocale(LC_CTYPE, \"en_US.UTF-8\") == NULL) {\n\t\tif (setlocale(LC_CTYPE, \"\") == NULL)\n\t\t\ttmate_fatal(\"invalid LC_ALL, LC_CTYPE or LANG\");\n\t\ts = nl_langinfo(CODESET);\n\t\tif (strcasecmp(s, \"UTF-8\") != 0 &&\n\t\t    strcasecmp(s, \"UTF8\") != 0)\n\t\t\ttmate_fatal(\"need UTF-8 locale (LC_CTYPE) but have %s\", s);\n\t}\n\n\tsetlocale(LC_TIME, \"\");\n\ttzset();\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\t/* The websocket server needs to access the /session dir to rename sockets */\n\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}\n\nchar *get_socket_path(const char *_token)\n{\n\tchar *path;\n\tchar *token = xstrdup(_token);\n\n\tfor (char *c = token; *c; c++) {\n\t\tif (*c == '/' || *c == '.')\n\t\t\t*c = '=';\n\t}\n\n\txasprintf(&path, TMATE_WORKDIR \"/sessions/%s\", token);\n\tfree(token);\n\treturn path;\n}\n\nvoid set_session_token(struct tmate_session *session, const char *token)\n{\n\tsession->session_token = xstrdup(token);\n\tsocket_path = get_socket_path(token);\n\n\txasprintf((char **)&session->obfuscated_session_token, \"%.4s...\",\n\t\t  session->session_token);\n\n\tsize_t size = cmdline_end - cmdline;\n\tmemset(cmdline, 0, size);\n\tsnprintf(cmdline, size-1, \"tmate-ssh-server [%s] %s %s\",\n\t\ttmate_session->obfuscated_session_token,\n\t\tsession->ssh_client.role == TMATE_ROLE_DAEMON ? \"(daemon)\" : \"(pty client)\",\n\t\tsession->ssh_client.ip_address);\n\n\tchar *log_prefix;\n\txasprintf(&log_prefix, \"[%s] \", session->obfuscated_session_token);\n\tset_log_prefix(log_prefix);\n\tfree(log_prefix);\n}\n\nvoid close_fds_except(int *fd_to_preserve, int num_fds)\n{\n\tint fd, i, preserve;\n\n\tfor (fd = 0; fd < 1024; fd++) {\n\t\tpreserve = 0;\n\t\tfor (i = 0; i < num_fds; i++)\n\t\t\tif (fd_to_preserve[i] == fd)\n\t\t\t\tpreserve = 1;\n\n\t\tif (!preserve)\n\t\t\tclose(fd);\n\t}\n}\n\nvoid get_in_jail(void)\n{\n\tstruct passwd *pw;\n\tuid_t uid;\n\tgid_t gid;\n\n\tpw = getpwnam(TMATE_JAIL_USER);\n\tif (!pw) {\n\t\ttmate_fatal(\"Cannot get the /etc/passwd entry for %s\",\n\t\t\t    TMATE_JAIL_USER);\n\t}\n\tuid = pw->pw_uid;\n\tgid = pw->pw_gid;\n\n\tif (getuid() != 0)\n\t\ttmate_fatal(\"Need root privileges to create the jail\");\n\n\tif (chroot(TMATE_WORKDIR \"/jail\") < 0)\n\t\ttmate_fatal(\"Cannot chroot()\");\n\n\tif (chdir(\"/\") < 0)\n\t\ttmate_fatal(\"Cannot chdir()\");\n\n#ifdef IS_LINUX\n\tif (unshare(CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWNS | CLONE_NEWNET) < 0)\n\t\ttmate_fatal(\"Cannot create new namespace\");\n#endif\n\n\tif (setgroups(1, (gid_t[]){gid}) < 0)\n\t\ttmate_fatal(\"Cannot setgroups()\");\n\n#if defined(HAVE_SETRESGID)\n\tif (setresgid(gid, gid, gid) < 0)\n\t\ttmate_fatal(\"Cannot setresgid() %d\", gid);\n#elif defined(HAVE_SETREGID)\n\tif (setregid(gid, gid) < 0)\n\t\ttmate_fatal(\"Cannot setregid()\");\n#else\n\tif (setgid(gid) < 0)\n\t\ttmate_fatal(\"Cannot setgid()\");\n#endif\n\n#if defined(HAVE_SETRESUID)\n\tif (setresuid(uid, uid, uid) < 0)\n\t\ttmate_fatal(\"Cannot setresuid()\");\n#elif defined(HAVE_SETREUID)\n\tif (setreuid(uid, uid) < 0)\n\t\ttmate_fatal(\"Cannot setreuid()\");\n#else\n\tif (setuid(uid) < 0)\n\t\ttmate_fatal(\"Cannot setuid()\");\n#endif\n\n\tnice(1);\n\n\ttmate_debug(\"Dropped priviledges to %s (%d,%d), jailed in %s\",\n\t\t    TMATE_JAIL_USER, uid, gid, TMATE_WORKDIR \"/jail\");\n}\n\nvoid setup_ncurse(int fd, const char *name)\n{\n\tint error;\n\tif (setupterm((char *)name, fd, &error) != OK)\n\t\ttmate_fatal(\"Cannot setup terminal\");\n}\n\n"], "fixing_code": ["#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <libssh/libssh.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#ifdef HAVE_CURSES_H\n#include <curses.h>\n#else\n#include <ncurses.h>\n#endif\n#include <term.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <signal.h>\n#include \"tmate.h\"\n\nstatic char *cmdline;\nstatic char *cmdline_end;\n\nstruct tmate_settings _tmate_settings = {\n\t.keys_dir        \t= TMATE_SSH_DEFAULT_KEYS_DIR,\n\t.ssh_port        \t= TMATE_SSH_DEFAULT_PORT,\n\t.ssh_port_advertized    = -1,\n\t.websocket_hostname  \t= NULL,\n\t.bind_addr\t \t= NULL,\n\t.websocket_port      \t= TMATE_DEFAULT_WEBSOCKET_PORT,\n\t.tmate_host      \t= NULL,\n\t.log_level      \t= LOG_INFO,\n\t.use_proxy_protocol\t= false,\n};\n\nstruct tmate_settings *tmate_settings = &_tmate_settings;\n\nextern int server_fd;\nextern void server_send_exit(void);\nvoid request_server_termination(void)\n{\n\tif (server_fd) {\n\t\tserver_send_exit();\n\t} else\n\t\texit(1);\n}\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"usage: tmate-ssh-server [-b ip] [-h hostname] [-k keys_dir] [-p listen_port] [-q ssh_port_advertized] [-w websocket_hostname] [-z websocket_port] [-x] [-v]\\n\");\n}\n\nstatic char* get_full_hostname(void)\n{\n\tstruct addrinfo hints, *info;\n\tchar hostname[1024];\n\tint gai_result;\n\tchar *ret;\n\n\tif (gethostname(hostname, sizeof(hostname)) < 0)\n\t\ttmate_fatal(\"cannot get hostname\");\n\thostname[1023] = '\\0';\n\n\tmemset(&hints, 0, sizeof hints);\n\thints.ai_family = AF_UNSPEC; /*either IPV4 or IPV6*/\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_CANONNAME;\n\n\tif ((gai_result = getaddrinfo(hostname, NULL, &hints, &info)) != 0) {\n\t\ttmate_info(\"cannot lookup hostname: %s\", gai_strerror(gai_result));\n\t\treturn xstrdup(hostname);\n\t}\n\n\tret = xstrdup(info->ai_canonname);\n\n\tfreeaddrinfo(info);\n\treturn ret;\n}\n#include <langinfo.h>\n#include <locale.h>\n\nstatic void setup_locale(void)\n{\n\tconst char *s;\n\n\tif (setlocale(LC_CTYPE, \"en_US.UTF-8\") == NULL) {\n\t\tif (setlocale(LC_CTYPE, \"\") == NULL)\n\t\t\ttmate_fatal(\"invalid LC_ALL, LC_CTYPE or LANG\");\n\t\ts = nl_langinfo(CODESET);\n\t\tif (strcasecmp(s, \"UTF-8\") != 0 &&\n\t\t    strcasecmp(s, \"UTF8\") != 0)\n\t\t\ttmate_fatal(\"need UTF-8 locale (LC_CTYPE) but have %s\", s);\n\t}\n\n\tsetlocale(LC_TIME, \"\");\n\ttzset();\n}\n\nstatic int check_owned_directory_mode(const char *path, mode_t expected_mode)\n{\n\tstruct stat stat;\n\tif (lstat(path, &stat))\n\t\treturn -1;\n\n\tif (!S_ISDIR(stat.st_mode))\n\t\treturn -1;\n\n\tif (stat.st_uid != getuid())\n\t\treturn -1;\n\n\tif ((stat.st_mode & 07777) != expected_mode)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0700)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0700) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\tif ((chmod(TMATE_WORKDIR, 0700)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0700) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\tif (check_owned_directory_mode(TMATE_WORKDIR, 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/sessions\", 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/jail\", 0700))\n\t\ttmate_fatal(TMATE_WORKDIR \" and subdirectories has incorrect ownership/mode. \"\n\t\t\t    \"Try deleting \" TMATE_WORKDIR \" and try again\");\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}\n\nchar *get_socket_path(const char *_token)\n{\n\tchar *path;\n\tchar *token = xstrdup(_token);\n\n\tfor (char *c = token; *c; c++) {\n\t\tif (*c == '/' || *c == '.')\n\t\t\t*c = '=';\n\t}\n\n\txasprintf(&path, TMATE_WORKDIR \"/sessions/%s\", token);\n\tfree(token);\n\treturn path;\n}\n\nvoid set_session_token(struct tmate_session *session, const char *token)\n{\n\tsession->session_token = xstrdup(token);\n\tsocket_path = get_socket_path(token);\n\n\txasprintf((char **)&session->obfuscated_session_token, \"%.4s...\",\n\t\t  session->session_token);\n\n\tsize_t size = cmdline_end - cmdline;\n\tmemset(cmdline, 0, size);\n\tsnprintf(cmdline, size-1, \"tmate-ssh-server [%s] %s %s\",\n\t\ttmate_session->obfuscated_session_token,\n\t\tsession->ssh_client.role == TMATE_ROLE_DAEMON ? \"(daemon)\" : \"(pty client)\",\n\t\tsession->ssh_client.ip_address);\n\n\tchar *log_prefix;\n\txasprintf(&log_prefix, \"[%s] \", session->obfuscated_session_token);\n\tset_log_prefix(log_prefix);\n\tfree(log_prefix);\n}\n\nvoid close_fds_except(int *fd_to_preserve, int num_fds)\n{\n\tint fd, i, preserve;\n\n\tfor (fd = 0; fd < 1024; fd++) {\n\t\tpreserve = 0;\n\t\tfor (i = 0; i < num_fds; i++)\n\t\t\tif (fd_to_preserve[i] == fd)\n\t\t\t\tpreserve = 1;\n\n\t\tif (!preserve)\n\t\t\tclose(fd);\n\t}\n}\n\nvoid get_in_jail(void)\n{\n\tstruct passwd *pw;\n\tuid_t uid;\n\tgid_t gid;\n\n\tpw = getpwnam(TMATE_JAIL_USER);\n\tif (!pw) {\n\t\ttmate_fatal(\"Cannot get the /etc/passwd entry for %s\",\n\t\t\t    TMATE_JAIL_USER);\n\t}\n\tuid = pw->pw_uid;\n\tgid = pw->pw_gid;\n\n\tif (getuid() != 0)\n\t\ttmate_fatal(\"Need root privileges to create the jail\");\n\n\tif (chroot(TMATE_WORKDIR \"/jail\") < 0)\n\t\ttmate_fatal(\"Cannot chroot()\");\n\n\tif (chdir(\"/\") < 0)\n\t\ttmate_fatal(\"Cannot chdir()\");\n\n#ifdef IS_LINUX\n\tif (unshare(CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWNS | CLONE_NEWNET) < 0)\n\t\ttmate_fatal(\"Cannot create new namespace\");\n#endif\n\n\tif (setgroups(1, (gid_t[]){gid}) < 0)\n\t\ttmate_fatal(\"Cannot setgroups()\");\n\n#if defined(HAVE_SETRESGID)\n\tif (setresgid(gid, gid, gid) < 0)\n\t\ttmate_fatal(\"Cannot setresgid() %d\", gid);\n#elif defined(HAVE_SETREGID)\n\tif (setregid(gid, gid) < 0)\n\t\ttmate_fatal(\"Cannot setregid()\");\n#else\n\tif (setgid(gid) < 0)\n\t\ttmate_fatal(\"Cannot setgid()\");\n#endif\n\n#if defined(HAVE_SETRESUID)\n\tif (setresuid(uid, uid, uid) < 0)\n\t\ttmate_fatal(\"Cannot setresuid()\");\n#elif defined(HAVE_SETREUID)\n\tif (setreuid(uid, uid) < 0)\n\t\ttmate_fatal(\"Cannot setreuid()\");\n#else\n\tif (setuid(uid) < 0)\n\t\ttmate_fatal(\"Cannot setuid()\");\n#endif\n\n\tnice(1);\n\n\ttmate_debug(\"Dropped priviledges to %s (%d,%d), jailed in %s\",\n\t\t    TMATE_JAIL_USER, uid, gid, TMATE_WORKDIR \"/jail\");\n}\n\nvoid setup_ncurse(int fd, const char *name)\n{\n\tint error;\n\tif (setupterm((char *)name, fd, &error) != OK)\n\t\ttmate_fatal(\"Cannot setup terminal\");\n}\n\n"], "filenames": ["tmate-main.c"], "buggy_code_start_loc": [100], "buggy_code_end_loc": [163], "fixing_code_start_loc": [101], "fixing_code_end_loc": [187], "type": "CWE-362", "message": "Insecure creation of temporary directories in tmate-ssh-server 2.3.0 allows a local attacker to compromise the integrity of session handling.", "other": {"cve": {"id": "CVE-2021-44513", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-07T03:15:07.207", "lastModified": "2021-12-08T14:27:43.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insecure creation of temporary directories in tmate-ssh-server 2.3.0 allows a local attacker to compromise the integrity of session handling."}, {"lang": "es", "value": "Una creaci\u00f3n no segura de directorios temporales en tmate-ssh-server versi\u00f3n 2.3.0, permite a un atacante local comprometer la integridad del manejo de sesiones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tmate:tmate-ssh-server:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.0", "matchCriteriaId": "49F9B6EA-4B80-44C8-8DDB-C203FB7A854C"}]}]}], "references": [{"url": "https://github.com/tmate-io/tmate-ssh-server/commit/1c020d1f5ca462f5b150b46a027aaa1bbe3c9596", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/12/06/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tmate-io/tmate-ssh-server/commit/1c020d1f5ca462f5b150b46a027aaa1bbe3c9596"}}