{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        M   M  EEEEE  TTTTT   AAA                            %\n%                        MM MM  E        T    A   A                           %\n%                        M M M  EEE      T    AAAAA                           %\n%                        M   M  E        T    A   A                           %\n%                        M   M  EEEEE    T    A   A                           %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Embedded Image Profiles.                      %\n%                                                                             %\n%                              Software Design                                %\n%                             William Radcliffe                               %\n%                                 July 2001                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMETAImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M E T A                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMETA() returns MagickTrue if the image format type, identified by the\n%  magick string, is META.\n%\n%  The format of the IsMETA method is:\n%\n%      MagickBooleanType IsMETA(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\n#ifdef IMPLEMENT_IS_FUNCTION\nstatic MagickBooleanType IsMETA(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"8BIM\",4) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((char *) magick,\"APP1\",4) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((char *) magick,\"\\034\\002\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M E T A I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMETAImage() reads a META image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMETAImage method is:\n%\n%      Image *ReadMETAImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  Decompression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadMETAImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or\n%      if the image cannot be read.\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _html_code\n{\n  const short int\n    len;\n\n  const char\n    *code,\n    val;\n} html_code;\n\nstatic const html_code html_codes[] = {\n#ifdef HANDLE_GT_LT\n  { 4,\"&lt;\",'<' },\n  { 4,\"&gt;\",'>' },\n#endif\n  { 5,\"&amp;\",'&' },\n  { 6,\"&quot;\",'\"' },\n  { 6,\"&apos;\",'\\''}\n};\n\nstatic int stringnicmp(const char *p,const char *q,size_t n)\n{\n  register ssize_t\n    i,\n    j;\n\n  if (p == q)\n    return(0);\n  if (p == (char *) NULL)\n    return(-1);\n  if (q == (char *) NULL)\n    return(1);\n  while ((*p != '\\0') && (*q != '\\0'))\n  {\n    if ((*p == '\\0') || (*q == '\\0'))\n      break;\n    i=(*p);\n    if (islower(i))\n      i=toupper(i);\n    j=(*q);\n    if (islower(j))\n      j=toupper(j);\n    if (i != j)\n      break;\n    n--;\n    if (n == 0)\n      break;\n    p++;\n    q++;\n  }\n  return(toupper((int) *p)-toupper((int) *q));\n}\n\nstatic size_t convertHTMLcodes(char *s, const size_t len)\n{\n  int\n    value;\n\n  if ((len == 0) || (s == (char*) NULL) || (*s=='\\0'))\n    return(0);\n  if ((len > 3) && (s[1] == '#') && (strchr(s,';') != (char *) NULL) &&\n      (sscanf(s,\"&#%d;\",&value) == 1))\n    {\n      size_t o = 3;\n      while (s[o] != ';')\n      {\n        o++;\n        if (o > 5)\n          break;\n      }\n      if (o < 6)\n        (void) memmove(s+1,s+1+o,strlen(s+1+o)+1);\n      *s=value;\n      return(o);\n    }\n  else\n    {\n      int\n        i,\n        codes;\n\n      codes=sizeof(html_codes)/sizeof(html_code);\n      for (i=0; i < codes; i++)\n      {\n        if (html_codes[i].len <= (ssize_t) len)\n          if (stringnicmp(s, html_codes[i].code,(size_t) (html_codes[i].len)) == 0)\n            {\n              (void) memmove(s+1,s+html_codes[i].len,\n                strlen(s+html_codes[i].len)+1);\n              *s=html_codes[i].val;\n              return(html_codes[i].len-1);\n            }\n      }\n    }\n  return(0);\n}\n\nstatic char *super_fgets(char **b, int *blen, Image *file)\n{\n  int\n    c,\n    len;\n\n  unsigned char\n    *p,\n    *q;\n\n  len=*blen;\n  p=(unsigned char *) (*b);\n  for (q=p; ; q++)\n  {\n    c=ReadBlobByte(file);\n    if (c == EOF || c == '\\n')\n      break;\n    if ((q-p+1) >= (int) len)\n      {\n        int\n          tlen;\n\n        tlen=q-p;\n        len<<=1;\n        p=(unsigned char *) ResizeQuantumMemory(p,(size_t) len+2UL,sizeof(*p));\n        *b=(char *) p;\n        if (p == (unsigned char *) NULL)\n          break;\n        q=p+tlen;\n      }\n    *q=(unsigned char) c;\n  }\n  *blen=0;\n  if (p != (unsigned char *) NULL)\n    {\n      int\n        tlen;\n\n      tlen=q-p;\n      if (tlen == 0)\n        return (char *) NULL;\n      p[tlen] = '\\0';\n      *blen=++tlen;\n    }\n  return((char *) p);\n}\n\n#define IPTC_ID 1028\n#define THUMBNAIL_ID 1033\n\nstatic ssize_t parse8BIM(Image *ifile, Image *ofile)\n{\n  char\n    brkused,\n    quoted,\n    *line,\n    *token,\n    *newstr,\n    *name;\n\n  int\n    state,\n    next;\n\n  unsigned char\n    dataset;\n\n  unsigned int\n    recnum;\n\n  int\n    inputlen = MagickPathExtent;\n\n  MagickOffsetType\n    savedpos,\n    currentpos;\n\n  ssize_t\n    savedolen = 0L,\n    outputlen = 0L;\n\n  TokenInfo\n    *token_info;\n\n  dataset = 0;\n  recnum = 0;\n  line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));\n  if (line == (char *) NULL)\n    return(-1);\n  newstr = name = token = (char *) NULL;\n  savedpos = 0;\n  token_info=AcquireTokenInfo();\n  while (super_fgets(&line,&inputlen,ifile)!=NULL)\n  {\n    state=0;\n    next=0;\n\n    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));\n    if (token == (char *) NULL)\n      break;\n    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));\n    if (newstr == (char *) NULL)\n      break;\n    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,\"\",\"=\",\"\\\"\",0,\n           &brkused,&next,&quoted)==0)\n    {\n      if (state == 0)\n        {\n          int\n            state,\n            next;\n\n          char\n            brkused,\n            quoted;\n\n          state=0;\n          next=0;\n          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"#\",\n            \"\", 0,&brkused,&next,&quoted)==0)\n          {\n            switch (state)\n            {\n              case 0:\n                if (strcmp(newstr,\"8BIM\")==0)\n                  dataset = 255;\n                else\n                  dataset = (unsigned char) StringToLong(newstr);\n                break;\n              case 1:\n                recnum = (unsigned int) StringToUnsignedLong(newstr);\n                break;\n              case 2:\n                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,\n                  sizeof(*name));\n                if (name)\n                  (void) strcpy(name,newstr);\n                break;\n            }\n            state++;\n          }\n        }\n      else\n        if (state == 1)\n          {\n            int\n              next;\n\n            ssize_t\n              len;\n\n            char\n              brkused,\n              quoted;\n\n            next=0;\n            len = (ssize_t) strlen(token);\n            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"&\",\n              \"\",0,&brkused,&next,&quoted)==0)\n            {\n              if (brkused && next > 0)\n                {\n                  size_t\n                    codes_length;\n\n                  char\n                    *s = &token[next-1];\n\n                  codes_length=convertHTMLcodes(s, strlen(s));\n                  if ((ssize_t) codes_length > len)\n                    len=0;\n                  else\n                    len-=codes_length;\n                }\n            }\n\n            if (dataset == 255)\n              {\n                unsigned char\n                  nlen = 0;\n\n                int\n                  i;\n\n                if (savedolen > 0)\n                  {\n                    MagickOffsetType\n                      offset;\n\n                    ssize_t diff = outputlen - savedolen;\n                    currentpos = TellBlob(ofile);\n                    if (currentpos < 0)\n                      return(-1);\n                    offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                    offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    savedolen = 0L;\n                  }\n                if (outputlen & 1)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                (void) WriteBlobString(ofile,\"8BIM\");\n                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);\n                outputlen += 6;\n                if (name)\n                  nlen = (unsigned char) strlen(name);\n                (void) WriteBlobByte(ofile,nlen);\n                outputlen++;\n                for (i=0; i<nlen; i++)\n                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);\n                outputlen += nlen;\n                if ((nlen & 0x01) == 0)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                if (recnum != IPTC_ID)\n                  {\n                    (void) WriteBlobMSBLong(ofile, (unsigned int) len);\n                    outputlen += 4;\n\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n\n                    if (outputlen & 1)\n                      {\n                        (void) WriteBlobByte(ofile,0x00);\n                        outputlen++;\n                      }\n                  }\n                else\n                  {\n                    /* patch in a fake length for now and fix it later */\n                    savedpos = TellBlob(ofile);\n                    if (savedpos < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);\n                    outputlen += 4;\n                    savedolen = outputlen;\n                  }\n              }\n            else\n              {\n                if (len <= 0x7FFF)\n                  {\n                    (void) WriteBlobByte(ofile,0x1c);\n                    (void) WriteBlobByte(ofile,(unsigned char) dataset);\n                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));\n                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);\n                    outputlen += 5;\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n                  }\n              }\n          }\n      state++;\n    }\n    if (token != (char *) NULL)\n      token=DestroyString(token);\n    if (newstr != (char *) NULL)\n      newstr=DestroyString(newstr);\n    if (name != (char *) NULL)\n      name=DestroyString(name);\n  }\n  token_info=DestroyTokenInfo(token_info);\n  if (token != (char *) NULL)\n    token=DestroyString(token);\n  if (newstr != (char *) NULL)\n    newstr=DestroyString(newstr);\n  if (name != (char *) NULL)\n    name=DestroyString(name);\n  line=DestroyString(line);\n  if (savedolen > 0)\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t diff = outputlen - savedolen;\n\n      currentpos = TellBlob(ofile);\n      if (currentpos < 0)\n        return(-1);\n      offset=SeekBlob(ofile,savedpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n      offset=SeekBlob(ofile,currentpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      savedolen = 0L;\n    }\n  return outputlen;\n}\n\nstatic char *super_fgets_w(char **b, int *blen, Image *file)\n{\n  int\n    c,\n    len;\n\n  unsigned char\n    *p,\n    *q;\n\n  len=*blen;\n  p=(unsigned char *) (*b);\n  for (q=p; ; q++)\n  {\n    c=ReadBlobLSBSignedShort(file);\n    if ((c == -1) || (c == '\\n'))\n      break;\n   if (EOFBlob(file))\n      break;\n   if ((q-p+1) >= (int) len)\n      {\n        int\n          tlen;\n\n        tlen=q-p;\n        len<<=1;\n        p=(unsigned char *) ResizeQuantumMemory(p,(size_t) (len+2),sizeof(*p));\n        *b=(char *) p;\n        if (p == (unsigned char *) NULL)\n          break;\n        q=p+tlen;\n      }\n    *q=(unsigned char) c;\n  }\n  *blen=0;\n  if ((*b) != (char *) NULL)\n    {\n      int\n        tlen;\n\n      tlen=q-p;\n      if (tlen == 0)\n        return (char *) NULL;\n      p[tlen] = '\\0';\n      *blen=++tlen;\n    }\n  return((char *) p);\n}\n\nstatic ssize_t parse8BIMW(Image *ifile, Image *ofile)\n{\n  char\n    brkused,\n    quoted,\n    *line,\n    *token,\n    *newstr,\n    *name;\n\n  int\n    state,\n    next;\n\n  unsigned char\n    dataset;\n\n  unsigned int\n    recnum;\n\n  int\n    inputlen = MagickPathExtent;\n\n  ssize_t\n    savedolen = 0L,\n    outputlen = 0L;\n\n  MagickOffsetType\n    savedpos,\n    currentpos;\n\n  TokenInfo\n    *token_info;\n\n  dataset = 0;\n  recnum = 0;\n  line=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));\n  if (line == (char *) NULL)\n    return(-1);\n  newstr = name = token = (char *) NULL;\n  savedpos = 0;\n  token_info=AcquireTokenInfo();\n  while (super_fgets_w(&line,&inputlen,ifile) != NULL)\n  {\n    state=0;\n    next=0;\n\n    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));\n    if (token == (char *) NULL)\n      break;\n    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));\n    if (newstr == (char *) NULL)\n      break;\n    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,\"\",\"=\",\"\\\"\",0,\n      &brkused,&next,&quoted)==0)\n    {\n      if (state == 0)\n        {\n          int\n            state,\n            next;\n\n          char\n            brkused,\n            quoted;\n\n          state=0;\n          next=0;\n          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"#\",\n            \"\",0,&brkused,&next,&quoted)==0)\n          {\n            switch (state)\n            {\n              case 0:\n                if (strcmp(newstr,\"8BIM\")==0)\n                  dataset = 255;\n                else\n                  dataset = (unsigned char) StringToLong(newstr);\n                break;\n              case 1:\n                recnum=(unsigned int) StringToUnsignedLong(newstr);\n                break;\n              case 2:\n                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,\n                  sizeof(*name));\n                if (name)\n                  (void) CopyMagickString(name,newstr,strlen(newstr)+MagickPathExtent);\n                break;\n            }\n            state++;\n          }\n        }\n      else\n        if (state == 1)\n          {\n            int\n              next;\n\n            ssize_t\n              len;\n\n            char\n              brkused,\n              quoted;\n\n            next=0;\n            len = (ssize_t) strlen(token);\n            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"&\",\n              \"\",0,&brkused,&next,&quoted)==0)\n            {\n              if (brkused && next > 0)\n                {\n                  size_t\n                    codes_length;\n\n                  char\n                    *s = &token[next-1];\n\n                  codes_length=convertHTMLcodes(s, strlen(s));\n                  if ((ssize_t) codes_length > len)\n                    len=0;\n                  else\n                    len-=codes_length;\n                }\n            }\n\n            if (dataset == 255)\n              {\n                unsigned char\n                  nlen = 0;\n\n                int\n                  i;\n\n                if (savedolen > 0)\n                  {\n                    MagickOffsetType\n                      offset;\n\n                    ssize_t diff = outputlen - savedolen;\n                    currentpos = TellBlob(ofile);\n                    if (currentpos < 0)\n                      return(-1);\n                    offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                    offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    savedolen = 0L;\n                  }\n                if (outputlen & 1)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                (void) WriteBlobString(ofile,\"8BIM\");\n                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);\n                outputlen += 6;\n                if (name)\n                  nlen = (unsigned char) strlen(name);\n                (void) WriteBlobByte(ofile,(unsigned char) nlen);\n                outputlen++;\n                for (i=0; i<nlen; i++)\n                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);\n                outputlen += nlen;\n                if ((nlen & 0x01) == 0)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                if (recnum != IPTC_ID)\n                  {\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) len);\n                    outputlen += 4;\n\n                    next=0;\n                    outputlen += len;\n                    while (len--)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n\n                    if (outputlen & 1)\n                      {\n                        (void) WriteBlobByte(ofile,0x00);\n                        outputlen++;\n                      }\n                  }\n                else\n                  {\n                    /* patch in a fake length for now and fix it later */\n                    savedpos = TellBlob(ofile);\n                    if (savedpos < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);\n                    outputlen += 4;\n                    savedolen = outputlen;\n                  }\n              }\n            else\n              {\n                if (len <= 0x7FFF)\n                  {\n                    (void) WriteBlobByte(ofile,0x1c);\n                    (void) WriteBlobByte(ofile,dataset);\n                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));\n                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);\n                    outputlen += 5;\n                    next=0;\n                    outputlen += len;\n                    while (len--)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n                  }\n              }\n          }\n      state++;\n    }\n    if (token != (char *) NULL)\n      token=DestroyString(token);\n    if (newstr != (char *) NULL)\n      newstr=DestroyString(newstr);\n    if (name != (char *) NULL)\n      name=DestroyString(name);\n  }\n  token_info=DestroyTokenInfo(token_info);\n  if (token != (char *) NULL)\n    token=DestroyString(token);\n  if (newstr != (char *) NULL)\n    newstr=DestroyString(newstr);\n  if (name != (char *) NULL)\n    name=DestroyString(name);\n  line=DestroyString(line);\n  if (savedolen > 0)\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t diff = outputlen - savedolen;\n\n      currentpos = TellBlob(ofile);\n      if (currentpos < 0)\n        return(-1);\n      offset=SeekBlob(ofile,savedpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n      offset=SeekBlob(ofile,currentpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      savedolen = 0L;\n    }\n  return(outputlen);\n}\n\n/* some defines for the different JPEG block types */\n#define M_SOF0  0xC0            /* Start Of Frame N */\n#define M_SOF1  0xC1            /* N indicates which compression process */\n#define M_SOF2  0xC2            /* Only SOF0-SOF2 are now in common use */\n#define M_SOF3  0xC3\n#define M_SOF5  0xC5            /* NB: codes C4 and CC are NOT SOF markers */\n#define M_SOF6  0xC6\n#define M_SOF7  0xC7\n#define M_SOF9  0xC9\n#define M_SOF10 0xCA\n#define M_SOF11 0xCB\n#define M_SOF13 0xCD\n#define M_SOF14 0xCE\n#define M_SOF15 0xCF\n#define M_SOI   0xD8\n#define M_EOI   0xD9            /* End Of Image (end of datastream) */\n#define M_SOS   0xDA            /* Start Of Scan (begins compressed data) */\n#define M_APP0  0xe0\n#define M_APP1  0xe1\n#define M_APP2  0xe2\n#define M_APP3  0xe3\n#define M_APP4  0xe4\n#define M_APP5  0xe5\n#define M_APP6  0xe6\n#define M_APP7  0xe7\n#define M_APP8  0xe8\n#define M_APP9  0xe9\n#define M_APP10 0xea\n#define M_APP11 0xeb\n#define M_APP12 0xec\n#define M_APP13 0xed\n#define M_APP14 0xee\n#define M_APP15 0xef\n\nstatic int jpeg_transfer_1(Image *ifile, Image *ofile)\n{\n  int c;\n\n  c = ReadBlobByte(ifile);\n  if (c == EOF)\n    return EOF;\n  (void) WriteBlobByte(ofile,(unsigned char) c);\n  return c;\n}\n\n#if defined(future)\nstatic int jpeg_skip_1(Image *ifile)\n{\n  int c;\n\n  c = ReadBlobByte(ifile);\n  if (c == EOF)\n    return EOF;\n  return c;\n}\n#endif\n\nstatic int jpeg_read_remaining(Image *ifile, Image *ofile)\n{\n   int c;\n\n  while ((c = jpeg_transfer_1(ifile, ofile)) != EOF)\n    continue;\n  return M_EOI;\n}\n\nstatic int jpeg_skip_variable(Image *ifile, Image *ofile)\n{\n  unsigned int  length;\n  int c1,c2;\n\n  if ((c1 = jpeg_transfer_1(ifile, ofile)) == EOF)\n    return M_EOI;\n  if ((c2 = jpeg_transfer_1(ifile, ofile)) == EOF)\n    return M_EOI;\n\n  length = (((unsigned char) c1) << 8) + ((unsigned char) c2);\n  length -= 2;\n\n  while (length--)\n    if (jpeg_transfer_1(ifile, ofile) == EOF)\n      return M_EOI;\n\n  return 0;\n}\n\nstatic int jpeg_skip_variable2(Image *ifile, Image *ofile)\n{\n  unsigned int  length;\n  int c1,c2;\n\n  (void) ofile;\n  if ((c1 = ReadBlobByte(ifile)) == EOF) return M_EOI;\n  if ((c2 = ReadBlobByte(ifile)) == EOF) return M_EOI;\n\n  length = (((unsigned char) c1) << 8) + ((unsigned char) c2);\n  length -= 2;\n\n  while (length--)\n    if (ReadBlobByte(ifile) == EOF)\n      return M_EOI;\n\n  return 0;\n}\n\nstatic int jpeg_nextmarker(Image *ifile, Image *ofile)\n{\n  int c;\n\n  /* transfer anything until we hit 0xff */\n  do\n  {\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return M_EOI; /* we hit EOF */\n    else\n      if (c != 0xff)\n        (void) WriteBlobByte(ofile,(unsigned char) c);\n  } while (c != 0xff);\n\n  /* get marker byte, swallowing possible padding */\n  do\n  {\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return M_EOI; /* we hit EOF */\n  } while (c == 0xff);\n\n  return c;\n}\n\n#if defined(future)\nstatic int jpeg_skip_till_marker(Image *ifile, int marker)\n{\n  int c, i;\n\n  do\n  {\n    /* skip anything until we hit 0xff */\n    i = 0;\n    do\n    {\n      c = ReadBlobByte(ifile);\n      i++;\n      if (c == EOF)\n        return M_EOI; /* we hit EOF */\n    } while (c != 0xff);\n\n    /* get marker byte, swallowing possible padding */\n    do\n    {\n      c = ReadBlobByte(ifile);\n      if (c == EOF)\n        return M_EOI; /* we hit EOF */\n    } while (c == 0xff);\n  } while (c != marker);\n  return c;\n}\n#endif\n\n/* Embed binary IPTC data into a JPEG image. */\nstatic int jpeg_embed(Image *ifile, Image *ofile, Image *iptc)\n{\n  unsigned int marker;\n  unsigned int done = 0;\n  unsigned int len;\n  int inx;\n\n  if (jpeg_transfer_1(ifile, ofile) != 0xFF)\n    return 0;\n  if (jpeg_transfer_1(ifile, ofile) != M_SOI)\n    return 0;\n\n  while (done == MagickFalse)\n  {\n    marker=(unsigned int) jpeg_nextmarker(ifile, ofile);\n    if (marker == M_EOI)\n      { /* EOF */\n        break;\n      }\n    else\n      {\n        if (marker != M_APP13)\n          {\n            (void) WriteBlobByte(ofile,0xff);\n            (void) WriteBlobByte(ofile,(unsigned char) marker);\n          }\n      }\n\n    switch (marker)\n    {\n      case M_APP13:\n        /* we are going to write a new APP13 marker, so don't output the old one */\n        jpeg_skip_variable2(ifile, ofile);\n        break;\n\n      case M_APP0:\n        /* APP0 is in each and every JPEG, so when we hit APP0 we insert our new APP13! */\n        jpeg_skip_variable(ifile, ofile);\n\n        if (iptc != (Image *) NULL)\n          {\n            char\n              psheader[] = \"\\xFF\\xED\\0\\0Photoshop 3.0\\0\" \"8BIM\\x04\\x04\\0\\0\\0\\0\";\n\n            len=(unsigned int) GetBlobSize(iptc);\n            if (len & 1)\n              len++; /* make the length even */\n            psheader[2]=(char) ((len+16)>>8);\n            psheader[3]=(char) ((len+16)&0xff);\n            for (inx = 0; inx < 18; inx++)\n              (void) WriteBlobByte(ofile,(unsigned char) psheader[inx]);\n            jpeg_read_remaining(iptc, ofile);\n            len=(unsigned int) GetBlobSize(iptc);\n            if (len & 1)\n              (void) WriteBlobByte(ofile,0);\n          }\n        break;\n\n      case M_SOS:\n        /* we hit data, no more marker-inserting can be done! */\n        jpeg_read_remaining(ifile, ofile);\n        done = 1;\n        break;\n\n      default:\n        jpeg_skip_variable(ifile, ofile);\n        break;\n    }\n  }\n  return 1;\n}\n\n/* handle stripping the APP13 data out of a JPEG */\n#if defined(future)\nstatic void jpeg_strip(Image *ifile, Image *ofile)\n{\n  unsigned int marker;\n\n  marker = jpeg_skip_till_marker(ifile, M_SOI);\n  if (marker == M_SOI)\n  {\n    (void) WriteBlobByte(ofile,0xff);\n    (void) WriteBlobByte(ofile,M_SOI);\n    jpeg_read_remaining(ifile, ofile);\n  }\n}\n\n/* Extract any APP13 binary data into a file. */\nstatic int jpeg_extract(Image *ifile, Image *ofile)\n{\n  unsigned int marker;\n  unsigned int done = 0;\n\n  if (jpeg_skip_1(ifile) != 0xff)\n    return 0;\n  if (jpeg_skip_1(ifile) != M_SOI)\n    return 0;\n\n  while (done == MagickFalse)\n  {\n    marker = jpeg_skip_till_marker(ifile, M_APP13);\n    if (marker == M_APP13)\n      {\n        marker = jpeg_nextmarker(ifile, ofile);\n        break;\n      }\n  }\n  return 1;\n}\n#endif\n\nstatic inline void CopyBlob(Image *source,Image *destination)\n{\n  ssize_t\n    i;\n\n  unsigned char\n    *buffer;\n\n  ssize_t\n    count,\n    length;\n\n  buffer=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n    sizeof(*buffer));\n  if (buffer != (unsigned char *) NULL)\n    {\n      i=0;\n      while ((length=ReadBlob(source,MagickMaxBufferExtent,buffer)) != 0)\n      {\n        count=0;\n        for (i=0; i < (ssize_t) length; i+=count)\n        {\n          count=WriteBlob(destination,(size_t) (length-i),buffer+i);\n          if (count <= 0)\n            break;\n        }\n        if (i < (ssize_t) length)\n          break;\n      }\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n    }\n}\n\nstatic Image *ReadMETAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *buff,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  size_t\n    length;\n\n  void\n    *blob;\n\n  /*\n    Open file containing binary metadata\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=1;\n  image->rows=1;\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  length=1;\n  if (LocaleNCompare(image_info->magick,\"8BIM\",4) == 0)\n    {\n      /*\n        Read 8BIM binary metadata.\n      */\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      if (LocaleCompare(image_info->magick,\"8BIMTEXT\") == 0)\n        {\n          length=(size_t) parse8BIM(image, buff);\n          if (length & 1)\n            (void) WriteBlobByte(buff,0x0);\n        }\n      else if (LocaleCompare(image_info->magick,\"8BIMWTEXT\") == 0)\n        {\n          length=(size_t) parse8BIMW(image, buff);\n          if (length & 1)\n            (void) WriteBlobByte(buff,0x0);\n        }\n      else\n        CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (LocaleNCompare(image_info->magick,\"APP1\",4) == 0)\n    {\n      char\n        name[MagickPathExtent];\n\n      (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",1);\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      if (LocaleCompare(image_info->magick,\"APP1JPEG\") == 0)\n        {\n          Image\n            *iptc;\n\n          int\n            result;\n\n          if (image_info->profile == (void *) NULL)\n            {\n              blob=DetachBlob(buff->blob);\n              blob=(unsigned char *) RelinquishMagickMemory(blob);\n              buff=DestroyImage(buff);\n              ThrowReaderException(CoderError,\"NoIPTCProfileAvailable\");\n            }\n          profile=CloneStringInfo((StringInfo *) image_info->profile);\n          iptc=AcquireImage((ImageInfo *) NULL,exception);\n          if (iptc == (Image *) NULL)\n            {\n              blob=DetachBlob(buff->blob);\n              blob=(unsigned char *) RelinquishMagickMemory(blob);\n              buff=DestroyImage(buff);\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          AttachBlob(iptc->blob,GetStringInfoDatum(profile),\n            GetStringInfoLength(profile));\n          result=jpeg_embed(image,buff,iptc);\n          blob=DetachBlob(iptc->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          iptc=DestroyImage(iptc);\n          if (result == 0)\n            {\n              buff=DestroyImage(buff);\n              ThrowReaderException(CoderError,\"JPEGEmbeddingFailed\");\n            }\n        }\n      else\n        CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      status=SetImageProfile(image,name,profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if ((LocaleCompare(image_info->magick,\"ICC\") == 0) ||\n      (LocaleCompare(image_info->magick,\"ICM\") == 0))\n    {\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n    }\n  if (LocaleCompare(image_info->magick,\"IPTC\") == 0)\n    {\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n    }\n  if (LocaleCompare(image_info->magick,\"XMP\") == 0)\n    {\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) SetImageProfile(image,\"xmp\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M E T A I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMETAImage() adds attributes for the META image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMETAImage method is:\n%\n%      size_t RegisterMETAImage(void)\n%\n*/\nModuleExport size_t RegisterMETAImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"META\",\"8BIM\",\"Photoshop resource format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"8BIMTEXT\",\"Photoshop resource text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"8BIMWTEXT\",\n    \"Photoshop resource wide text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"APP1\",\"Raw application information\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"APP1JPEG\",\"Raw JPEG binary data\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"EXIF\",\"Exif digital camera binary data\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"XMP\",\"Adobe XML metadata\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"ICM\",\"ICC Color Profile\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"ICC\",\"ICC Color Profile\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"IPTC\",\"IPTC Newsphoto\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"IPTCTEXT\",\"IPTC Newsphoto text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"IPTCWTEXT\",\"IPTC Newsphoto text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M E T A I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMETAImage() removes format registrations made by the\n%  META module from the list of supported formats.\n%\n%  The format of the UnregisterMETAImage method is:\n%\n%      UnregisterMETAImage(void)\n%\n*/\nModuleExport void UnregisterMETAImage(void)\n{\n  (void) UnregisterMagickInfo(\"8BIM\");\n  (void) UnregisterMagickInfo(\"8BIMTEXT\");\n  (void) UnregisterMagickInfo(\"8BIMWTEXT\");\n  (void) UnregisterMagickInfo(\"EXIF\");\n  (void) UnregisterMagickInfo(\"APP1\");\n  (void) UnregisterMagickInfo(\"APP1JPEG\");\n  (void) UnregisterMagickInfo(\"ICCTEXT\");\n  (void) UnregisterMagickInfo(\"ICM\");\n  (void) UnregisterMagickInfo(\"ICC\");\n  (void) UnregisterMagickInfo(\"IPTC\");\n  (void) UnregisterMagickInfo(\"IPTCTEXT\");\n  (void) UnregisterMagickInfo(\"IPTCWTEXT\");\n  (void) UnregisterMagickInfo(\"XMP\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M E T A I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMETAImage() writes a META image to a file.\n%\n%  The format of the WriteMETAImage method is:\n%\n%      MagickBooleanType WriteMETAImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  Compression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o image: A pointer to a Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t GetIPTCStream(unsigned char **info,size_t length)\n{\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    extent,\n    info_length;\n\n  unsigned int\n    marker;\n\n  size_t\n    tag_length;\n\n  p=(*info);\n  extent=length;\n  if ((*p == 0x1c) && (*(p+1) == 0x02))\n    return(length);\n  /*\n    Extract IPTC from 8BIM resource block.\n  */\n  while (extent >= 12)\n  {\n    if (strncmp((const char *) p,\"8BIM\",4))\n      break;\n    p+=4;\n    extent-=4;\n    marker=(unsigned int) (*p) << 8 | *(p+1);\n    p+=2;\n    extent-=2;\n    c=*p++;\n    extent--;\n    c|=0x01;\n    if ((size_t) c >= extent)\n      break;\n    p+=c;\n    extent-=c;\n    if (extent < 4)\n      break;\n    tag_length=(((size_t) *p) << 24) | (((size_t) *(p+1)) << 16) |\n      (((size_t) *(p+2)) << 8) | ((size_t) *(p+3));\n    p+=4;\n    extent-=4;\n    if (tag_length > extent)\n      break;\n    if (marker == IPTC_ID)\n      {\n        *info=p;\n        return(tag_length);\n      }\n    if ((tag_length & 0x01) != 0)\n      tag_length++;\n    p+=tag_length;\n    extent-=tag_length;\n  }\n  /*\n    Find the beginning of the IPTC info.\n  */\n  p=(*info);\n  tag_length=0;\niptc_find:\n  info_length=0;\n  marker=MagickFalse;\n  while (length != 0)\n  {\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    if (c == 0x1c)\n      {\n        p--;\n        *info=p; /* let the caller know were it is */\n        break;\n      }\n  }\n  /*\n    Determine the length of the IPTC info.\n  */\n  while (length != 0)\n  {\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    if (c == 0x1c)\n      marker=MagickTrue;\n    else\n      if (marker)\n        break;\n      else\n        continue;\n    info_length++;\n    /*\n      Found the 0x1c tag; skip the dataset and record number tags.\n    */\n    c=(*p++); /* should be 2 */\n    length--;\n    if (length == 0)\n      break;\n    if ((info_length == 1) && (c != 2))\n      goto iptc_find;\n    info_length++;\n    c=(*p++); /* should be 0 */\n    length--;\n    if (length == 0)\n      break;\n    if ((info_length == 2) && (c != 0))\n      goto iptc_find;\n    info_length++;\n    /*\n      Decode the length of the block that follows - ssize_t or short format.\n    */\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    info_length++;\n    if ((c & 0x80) != 0)\n      {\n        /*\n          Long format.\n        */\n        tag_length=0;\n        for (i=0; i < 4; i++)\n        {\n          tag_length<<=8;\n          tag_length|=(*p++);\n          length--;\n          if (length == 0)\n            break;\n          info_length++;\n        }\n      }\n    else\n      {\n        /*\n          Short format.\n        */\n        tag_length=((long) c) << 8;\n        c=(*p++);\n        length--;\n        if (length == 0)\n          break;\n        info_length++;\n        tag_length|=(long) c;\n      }\n    if (tag_length > (length+1))\n      break;\n    p+=tag_length;\n    length-=tag_length;\n    if (length == 0)\n      break;\n    info_length+=tag_length;\n  }\n  return(info_length);\n}\n\nstatic void formatString(Image *ofile, const char *s, int len)\n{\n  char\n    temp[MagickPathExtent];\n\n  (void) WriteBlobByte(ofile,'\"');\n  for (; len > 0; len--, s++) {\n    int c = (*s) & 255;\n    switch (c) {\n    case '&':\n      (void) WriteBlobString(ofile,\"&amp;\");\n      break;\n#ifdef HANDLE_GT_LT\n    case '<':\n      (void) WriteBlobString(ofile,\"&lt;\");\n      break;\n    case '>':\n      (void) WriteBlobString(ofile,\"&gt;\");\n      break;\n#endif\n    case '\"':\n      (void) WriteBlobString(ofile,\"&quot;\");\n      break;\n    default:\n      if (isprint(c))\n        (void) WriteBlobByte(ofile,(unsigned char) *s);\n      else\n        {\n          (void) FormatLocaleString(temp,MagickPathExtent,\"&#%d;\", c & 255);\n          (void) WriteBlobString(ofile,temp);\n        }\n      break;\n    }\n  }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  (void) WriteBlobString(ofile,\"\\\"\\r\\n\");\n#else\n#if defined(macintosh)\n  (void) WriteBlobString(ofile,\"\\\"\\r\");\n#else\n  (void) WriteBlobString(ofile,\"\\\"\\n\");\n#endif\n#endif\n}\n\ntypedef struct _tag_spec\n{\n  const short\n    id;\n\n  const char\n    *name;\n} tag_spec;\n\nstatic const tag_spec tags[] = {\n  { 5, \"Image Name\" },\n  { 7, \"Edit Status\" },\n  { 10, \"Priority\" },\n  { 15, \"Category\" },\n  { 20, \"Supplemental Category\" },\n  { 22, \"Fixture Identifier\" },\n  { 25, \"Keyword\" },\n  { 30, \"Release Date\" },\n  { 35, \"Release Time\" },\n  { 40, \"Special Instructions\" },\n  { 45, \"Reference Service\" },\n  { 47, \"Reference Date\" },\n  { 50, \"Reference Number\" },\n  { 55, \"Created Date\" },\n  { 60, \"Created Time\" },\n  { 65, \"Originating Program\" },\n  { 70, \"Program Version\" },\n  { 75, \"Object Cycle\" },\n  { 80, \"Byline\" },\n  { 85, \"Byline Title\" },\n  { 90, \"City\" },\n  { 92, \"Sub-Location\" },\n  { 95, \"Province State\" },\n  { 100, \"Country Code\" },\n  { 101, \"Country\" },\n  { 103, \"Original Transmission Reference\" },\n  { 105, \"Headline\" },\n  { 110, \"Credit\" },\n  { 115, \"Source\" },\n  { 116, \"Copyright String\" },\n  { 120, \"Caption\" },\n  { 121, \"Image Orientation\" },\n  { 122, \"Caption Writer\" },\n  { 131, \"Local Caption\" },\n  { 200, \"Custom Field 1\" },\n  { 201, \"Custom Field 2\" },\n  { 202, \"Custom Field 3\" },\n  { 203, \"Custom Field 4\" },\n  { 204, \"Custom Field 5\" },\n  { 205, \"Custom Field 6\" },\n  { 206, \"Custom Field 7\" },\n  { 207, \"Custom Field 8\" },\n  { 208, \"Custom Field 9\" },\n  { 209, \"Custom Field 10\" },\n  { 210, \"Custom Field 11\" },\n  { 211, \"Custom Field 12\" },\n  { 212, \"Custom Field 13\" },\n  { 213, \"Custom Field 14\" },\n  { 214, \"Custom Field 15\" },\n  { 215, \"Custom Field 16\" },\n  { 216, \"Custom Field 17\" },\n  { 217, \"Custom Field 18\" },\n  { 218, \"Custom Field 19\" },\n  { 219, \"Custom Field 20\" }\n};\n\nstatic int formatIPTC(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return(-1);\n        else\n          {\n            c=0;\n            continue;\n          }\n      }\n\n    /* we found the 0x1c tag and now grab the dataset and record number tags */\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    dataset = (unsigned char) c;\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n    {\n      if (tags[i].id == (short) recnum)\n          break;\n    }\n    if (i < tagcount)\n      readable = (unsigned char *) tags[i].name;\n    else\n      readable = (unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        int\n          c0;\n\n        c0=ReadBlobByte(ifile);\n        if (c0 == EOF)\n          return(-1);\n        taglen = (c << 8) | c0;\n      }\n    if (taglen < 0)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return(0);\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          return(-1);\n        }\n      str[tagindx] = (unsigned char) c;\n    }\n    str[taglen] = 0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset, (unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n\n    c=ReadBlobByte(ifile);\n  }\n  return((int) tagsfound);\n}\n\nstatic int readWordFromBuffer(char **s, ssize_t *len)\n{\n  unsigned char\n    buffer[2];\n\n  int\n    i,\n    c;\n\n  for (i=0; i<2; i++)\n  {\n    c = *(*s)++; (*len)--;\n    if (*len < 0) return -1;\n    buffer[i] = (unsigned char) c;\n  }\n  return (((int) buffer[ 0 ]) <<  8) |\n         (((int) buffer[ 1 ]));\n}\n\nstatic int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    /*\n      We found the 0x1c tag and now grab the dataset and record number tags.\n    */\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      printf(\"MemoryAllocationFailed\");\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        return(-1);\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}\n\nstatic int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        return 0;\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n      }\n    }\n    count=(ssize_t) ReadBlobMSBSignedLong(ifile);\n    if ((count < 0) || (count > GetBlobSize(ifile)))\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return -1;\n      }\n    /* make a buffer to hold the data and snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          PString=(unsigned char *) RelinquishMagickMemory(PString);\n          return -1;\n        }\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}\n\nstatic MagickBooleanType WriteMETAImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=0;\n  if (LocaleCompare(image_info->magick,\"8BIM\") == 0)\n    {\n      /*\n        Write 8BIM image.\n      */\n      profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"iptc\") == 0)\n    {\n      size_t\n        length;\n\n      unsigned char\n        *info;\n\n      profile=GetImageProfile(image,\"iptc\");\n      if (profile == (StringInfo *) NULL)\n        profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      info=GetStringInfoDatum(profile);\n      length=GetStringInfoLength(profile);\n      length=GetIPTCStream(&info,length);\n      if (length == 0)\n        ThrowWriterException(CoderError,\"NoIPTCProfileAvailable\");\n      (void) WriteBlob(image,length,info);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"8BIMTEXT\") == 0)\n    {\n      Image\n        *buff;\n\n      profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      AttachBlob(buff->blob,GetStringInfoDatum(profile),\n        GetStringInfoLength(profile));\n      format8BIM(buff,image);\n      (void) DetachBlob(buff->blob);\n      buff=DestroyImage(buff);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"8BIMWTEXT\") == 0)\n    return(MagickFalse);\n  if (LocaleCompare(image_info->magick,\"IPTCTEXT\") == 0)\n    {\n      Image\n        *buff;\n\n      unsigned char\n        *info;\n\n      profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      info=GetStringInfoDatum(profile);\n      length=GetStringInfoLength(profile);\n      length=GetIPTCStream(&info,length);\n      if (length == 0)\n        ThrowWriterException(CoderError,\"NoIPTCProfileAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      AttachBlob(buff->blob,info,length);\n      formatIPTC(buff,image);\n      (void) DetachBlob(buff->blob);\n      buff=DestroyImage(buff);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"IPTCWTEXT\") == 0)\n    return(MagickFalse);\n  if ((LocaleCompare(image_info->magick,\"APP1\") == 0) ||\n      (LocaleCompare(image_info->magick,\"EXIF\") == 0) ||\n      (LocaleCompare(image_info->magick,\"XMP\") == 0))\n    {\n      /*\n        (void) Write APP1 image.\n      */\n      profile=GetImageProfile(image,image_info->magick);\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"NoAPP1DataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if ((LocaleCompare(image_info->magick,\"ICC\") == 0) ||\n      (LocaleCompare(image_info->magick,\"ICM\") == 0))\n    {\n      /*\n        Write ICM image.\n      */\n      profile=GetImageProfile(image,\"icc\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"NoColorProfileIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        M   M  EEEEE  TTTTT   AAA                            %\n%                        MM MM  E        T    A   A                           %\n%                        M M M  EEE      T    AAAAA                           %\n%                        M   M  E        T    A   A                           %\n%                        M   M  EEEEE    T    A   A                           %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Embedded Image Profiles.                      %\n%                                                                             %\n%                              Software Design                                %\n%                             William Radcliffe                               %\n%                                 July 2001                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMETAImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M E T A                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMETA() returns MagickTrue if the image format type, identified by the\n%  magick string, is META.\n%\n%  The format of the IsMETA method is:\n%\n%      MagickBooleanType IsMETA(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\n#ifdef IMPLEMENT_IS_FUNCTION\nstatic MagickBooleanType IsMETA(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"8BIM\",4) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((char *) magick,\"APP1\",4) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((char *) magick,\"\\034\\002\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M E T A I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMETAImage() reads a META image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMETAImage method is:\n%\n%      Image *ReadMETAImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  Decompression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadMETAImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or\n%      if the image cannot be read.\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _html_code\n{\n  const short int\n    len;\n\n  const char\n    *code,\n    val;\n} html_code;\n\nstatic const html_code html_codes[] = {\n#ifdef HANDLE_GT_LT\n  { 4,\"&lt;\",'<' },\n  { 4,\"&gt;\",'>' },\n#endif\n  { 5,\"&amp;\",'&' },\n  { 6,\"&quot;\",'\"' },\n  { 6,\"&apos;\",'\\''}\n};\n\nstatic int stringnicmp(const char *p,const char *q,size_t n)\n{\n  register ssize_t\n    i,\n    j;\n\n  if (p == q)\n    return(0);\n  if (p == (char *) NULL)\n    return(-1);\n  if (q == (char *) NULL)\n    return(1);\n  while ((*p != '\\0') && (*q != '\\0'))\n  {\n    if ((*p == '\\0') || (*q == '\\0'))\n      break;\n    i=(*p);\n    if (islower(i))\n      i=toupper(i);\n    j=(*q);\n    if (islower(j))\n      j=toupper(j);\n    if (i != j)\n      break;\n    n--;\n    if (n == 0)\n      break;\n    p++;\n    q++;\n  }\n  return(toupper((int) *p)-toupper((int) *q));\n}\n\nstatic size_t convertHTMLcodes(char *s, const size_t len)\n{\n  int\n    value;\n\n  if ((len == 0) || (s == (char*) NULL) || (*s=='\\0'))\n    return(0);\n  if ((len > 3) && (s[1] == '#') && (strchr(s,';') != (char *) NULL) &&\n      (sscanf(s,\"&#%d;\",&value) == 1))\n    {\n      size_t o = 3;\n      while (s[o] != ';')\n      {\n        o++;\n        if (o > 5)\n          break;\n      }\n      if (o < 6)\n        (void) memmove(s+1,s+1+o,strlen(s+1+o)+1);\n      *s=value;\n      return(o);\n    }\n  else\n    {\n      int\n        i,\n        codes;\n\n      codes=sizeof(html_codes)/sizeof(html_code);\n      for (i=0; i < codes; i++)\n      {\n        if (html_codes[i].len <= (ssize_t) len)\n          if (stringnicmp(s, html_codes[i].code,(size_t) (html_codes[i].len)) == 0)\n            {\n              (void) memmove(s+1,s+html_codes[i].len,\n                strlen(s+html_codes[i].len)+1);\n              *s=html_codes[i].val;\n              return(html_codes[i].len-1);\n            }\n      }\n    }\n  return(0);\n}\n\nstatic char *super_fgets(char **b, int *blen, Image *file)\n{\n  int\n    c,\n    len;\n\n  unsigned char\n    *p,\n    *q;\n\n  len=*blen;\n  p=(unsigned char *) (*b);\n  for (q=p; ; q++)\n  {\n    c=ReadBlobByte(file);\n    if (c == EOF || c == '\\n')\n      break;\n    if ((q-p+1) >= (int) len)\n      {\n        int\n          tlen;\n\n        tlen=q-p;\n        len<<=1;\n        p=(unsigned char *) ResizeQuantumMemory(p,(size_t) len+2UL,sizeof(*p));\n        *b=(char *) p;\n        if (p == (unsigned char *) NULL)\n          break;\n        q=p+tlen;\n      }\n    *q=(unsigned char) c;\n  }\n  *blen=0;\n  if (p != (unsigned char *) NULL)\n    {\n      int\n        tlen;\n\n      tlen=q-p;\n      if (tlen == 0)\n        return (char *) NULL;\n      p[tlen] = '\\0';\n      *blen=++tlen;\n    }\n  return((char *) p);\n}\n\n#define IPTC_ID 1028\n#define THUMBNAIL_ID 1033\n\nstatic ssize_t parse8BIM(Image *ifile, Image *ofile)\n{\n  char\n    brkused,\n    quoted,\n    *line,\n    *token,\n    *newstr,\n    *name;\n\n  int\n    state,\n    next;\n\n  unsigned char\n    dataset;\n\n  unsigned int\n    recnum;\n\n  int\n    inputlen = MagickPathExtent;\n\n  MagickOffsetType\n    savedpos,\n    currentpos;\n\n  ssize_t\n    savedolen = 0L,\n    outputlen = 0L;\n\n  TokenInfo\n    *token_info;\n\n  dataset = 0;\n  recnum = 0;\n  line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));\n  if (line == (char *) NULL)\n    return(-1);\n  newstr = name = token = (char *) NULL;\n  savedpos = 0;\n  token_info=AcquireTokenInfo();\n  while (super_fgets(&line,&inputlen,ifile)!=NULL)\n  {\n    state=0;\n    next=0;\n\n    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));\n    if (token == (char *) NULL)\n      break;\n    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));\n    if (newstr == (char *) NULL)\n      break;\n    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,\"\",\"=\",\"\\\"\",0,\n           &brkused,&next,&quoted)==0)\n    {\n      if (state == 0)\n        {\n          int\n            state,\n            next;\n\n          char\n            brkused,\n            quoted;\n\n          state=0;\n          next=0;\n          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"#\",\n            \"\", 0,&brkused,&next,&quoted)==0)\n          {\n            switch (state)\n            {\n              case 0:\n                if (strcmp(newstr,\"8BIM\")==0)\n                  dataset = 255;\n                else\n                  dataset = (unsigned char) StringToLong(newstr);\n                break;\n              case 1:\n                recnum = (unsigned int) StringToUnsignedLong(newstr);\n                break;\n              case 2:\n                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,\n                  sizeof(*name));\n                if (name)\n                  (void) strcpy(name,newstr);\n                break;\n            }\n            state++;\n          }\n        }\n      else\n        if (state == 1)\n          {\n            int\n              next;\n\n            ssize_t\n              len;\n\n            char\n              brkused,\n              quoted;\n\n            next=0;\n            len = (ssize_t) strlen(token);\n            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"&\",\n              \"\",0,&brkused,&next,&quoted)==0)\n            {\n              if (brkused && next > 0)\n                {\n                  size_t\n                    codes_length;\n\n                  char\n                    *s = &token[next-1];\n\n                  codes_length=convertHTMLcodes(s, strlen(s));\n                  if ((ssize_t) codes_length > len)\n                    len=0;\n                  else\n                    len-=codes_length;\n                }\n            }\n\n            if (dataset == 255)\n              {\n                unsigned char\n                  nlen = 0;\n\n                int\n                  i;\n\n                if (savedolen > 0)\n                  {\n                    MagickOffsetType\n                      offset;\n\n                    ssize_t diff = outputlen - savedolen;\n                    currentpos = TellBlob(ofile);\n                    if (currentpos < 0)\n                      return(-1);\n                    offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                    offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    savedolen = 0L;\n                  }\n                if (outputlen & 1)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                (void) WriteBlobString(ofile,\"8BIM\");\n                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);\n                outputlen += 6;\n                if (name)\n                  nlen = (unsigned char) strlen(name);\n                (void) WriteBlobByte(ofile,nlen);\n                outputlen++;\n                for (i=0; i<nlen; i++)\n                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);\n                outputlen += nlen;\n                if ((nlen & 0x01) == 0)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                if (recnum != IPTC_ID)\n                  {\n                    (void) WriteBlobMSBLong(ofile, (unsigned int) len);\n                    outputlen += 4;\n\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n\n                    if (outputlen & 1)\n                      {\n                        (void) WriteBlobByte(ofile,0x00);\n                        outputlen++;\n                      }\n                  }\n                else\n                  {\n                    /* patch in a fake length for now and fix it later */\n                    savedpos = TellBlob(ofile);\n                    if (savedpos < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);\n                    outputlen += 4;\n                    savedolen = outputlen;\n                  }\n              }\n            else\n              {\n                if (len <= 0x7FFF)\n                  {\n                    (void) WriteBlobByte(ofile,0x1c);\n                    (void) WriteBlobByte(ofile,(unsigned char) dataset);\n                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));\n                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);\n                    outputlen += 5;\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n                  }\n              }\n          }\n      state++;\n    }\n    if (token != (char *) NULL)\n      token=DestroyString(token);\n    if (newstr != (char *) NULL)\n      newstr=DestroyString(newstr);\n    if (name != (char *) NULL)\n      name=DestroyString(name);\n  }\n  token_info=DestroyTokenInfo(token_info);\n  if (token != (char *) NULL)\n    token=DestroyString(token);\n  if (newstr != (char *) NULL)\n    newstr=DestroyString(newstr);\n  if (name != (char *) NULL)\n    name=DestroyString(name);\n  line=DestroyString(line);\n  if (savedolen > 0)\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t diff = outputlen - savedolen;\n\n      currentpos = TellBlob(ofile);\n      if (currentpos < 0)\n        return(-1);\n      offset=SeekBlob(ofile,savedpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n      offset=SeekBlob(ofile,currentpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      savedolen = 0L;\n    }\n  return outputlen;\n}\n\nstatic char *super_fgets_w(char **b, int *blen, Image *file)\n{\n  int\n    c,\n    len;\n\n  unsigned char\n    *p,\n    *q;\n\n  len=*blen;\n  p=(unsigned char *) (*b);\n  for (q=p; ; q++)\n  {\n    c=ReadBlobLSBSignedShort(file);\n    if ((c == -1) || (c == '\\n'))\n      break;\n   if (EOFBlob(file))\n      break;\n   if ((q-p+1) >= (int) len)\n      {\n        int\n          tlen;\n\n        tlen=q-p;\n        len<<=1;\n        p=(unsigned char *) ResizeQuantumMemory(p,(size_t) (len+2),sizeof(*p));\n        *b=(char *) p;\n        if (p == (unsigned char *) NULL)\n          break;\n        q=p+tlen;\n      }\n    *q=(unsigned char) c;\n  }\n  *blen=0;\n  if ((*b) != (char *) NULL)\n    {\n      int\n        tlen;\n\n      tlen=q-p;\n      if (tlen == 0)\n        return (char *) NULL;\n      p[tlen] = '\\0';\n      *blen=++tlen;\n    }\n  return((char *) p);\n}\n\nstatic ssize_t parse8BIMW(Image *ifile, Image *ofile)\n{\n  char\n    brkused,\n    quoted,\n    *line,\n    *token,\n    *newstr,\n    *name;\n\n  int\n    state,\n    next;\n\n  unsigned char\n    dataset;\n\n  unsigned int\n    recnum;\n\n  int\n    inputlen = MagickPathExtent;\n\n  ssize_t\n    savedolen = 0L,\n    outputlen = 0L;\n\n  MagickOffsetType\n    savedpos,\n    currentpos;\n\n  TokenInfo\n    *token_info;\n\n  dataset = 0;\n  recnum = 0;\n  line=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));\n  if (line == (char *) NULL)\n    return(-1);\n  newstr = name = token = (char *) NULL;\n  savedpos = 0;\n  token_info=AcquireTokenInfo();\n  while (super_fgets_w(&line,&inputlen,ifile) != NULL)\n  {\n    state=0;\n    next=0;\n\n    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));\n    if (token == (char *) NULL)\n      break;\n    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));\n    if (newstr == (char *) NULL)\n      break;\n    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,\"\",\"=\",\"\\\"\",0,\n      &brkused,&next,&quoted)==0)\n    {\n      if (state == 0)\n        {\n          int\n            state,\n            next;\n\n          char\n            brkused,\n            quoted;\n\n          state=0;\n          next=0;\n          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"#\",\n            \"\",0,&brkused,&next,&quoted)==0)\n          {\n            switch (state)\n            {\n              case 0:\n                if (strcmp(newstr,\"8BIM\")==0)\n                  dataset = 255;\n                else\n                  dataset = (unsigned char) StringToLong(newstr);\n                break;\n              case 1:\n                recnum=(unsigned int) StringToUnsignedLong(newstr);\n                break;\n              case 2:\n                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,\n                  sizeof(*name));\n                if (name)\n                  (void) CopyMagickString(name,newstr,strlen(newstr)+MagickPathExtent);\n                break;\n            }\n            state++;\n          }\n        }\n      else\n        if (state == 1)\n          {\n            int\n              next;\n\n            ssize_t\n              len;\n\n            char\n              brkused,\n              quoted;\n\n            next=0;\n            len = (ssize_t) strlen(token);\n            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"&\",\n              \"\",0,&brkused,&next,&quoted)==0)\n            {\n              if (brkused && next > 0)\n                {\n                  size_t\n                    codes_length;\n\n                  char\n                    *s = &token[next-1];\n\n                  codes_length=convertHTMLcodes(s, strlen(s));\n                  if ((ssize_t) codes_length > len)\n                    len=0;\n                  else\n                    len-=codes_length;\n                }\n            }\n\n            if (dataset == 255)\n              {\n                unsigned char\n                  nlen = 0;\n\n                int\n                  i;\n\n                if (savedolen > 0)\n                  {\n                    MagickOffsetType\n                      offset;\n\n                    ssize_t diff = outputlen - savedolen;\n                    currentpos = TellBlob(ofile);\n                    if (currentpos < 0)\n                      return(-1);\n                    offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                    offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    savedolen = 0L;\n                  }\n                if (outputlen & 1)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                (void) WriteBlobString(ofile,\"8BIM\");\n                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);\n                outputlen += 6;\n                if (name)\n                  nlen = (unsigned char) strlen(name);\n                (void) WriteBlobByte(ofile,(unsigned char) nlen);\n                outputlen++;\n                for (i=0; i<nlen; i++)\n                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);\n                outputlen += nlen;\n                if ((nlen & 0x01) == 0)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                if (recnum != IPTC_ID)\n                  {\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) len);\n                    outputlen += 4;\n\n                    next=0;\n                    outputlen += len;\n                    while (len--)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n\n                    if (outputlen & 1)\n                      {\n                        (void) WriteBlobByte(ofile,0x00);\n                        outputlen++;\n                      }\n                  }\n                else\n                  {\n                    /* patch in a fake length for now and fix it later */\n                    savedpos = TellBlob(ofile);\n                    if (savedpos < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);\n                    outputlen += 4;\n                    savedolen = outputlen;\n                  }\n              }\n            else\n              {\n                if (len <= 0x7FFF)\n                  {\n                    (void) WriteBlobByte(ofile,0x1c);\n                    (void) WriteBlobByte(ofile,dataset);\n                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));\n                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);\n                    outputlen += 5;\n                    next=0;\n                    outputlen += len;\n                    while (len--)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n                  }\n              }\n          }\n      state++;\n    }\n    if (token != (char *) NULL)\n      token=DestroyString(token);\n    if (newstr != (char *) NULL)\n      newstr=DestroyString(newstr);\n    if (name != (char *) NULL)\n      name=DestroyString(name);\n  }\n  token_info=DestroyTokenInfo(token_info);\n  if (token != (char *) NULL)\n    token=DestroyString(token);\n  if (newstr != (char *) NULL)\n    newstr=DestroyString(newstr);\n  if (name != (char *) NULL)\n    name=DestroyString(name);\n  line=DestroyString(line);\n  if (savedolen > 0)\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t diff = outputlen - savedolen;\n\n      currentpos = TellBlob(ofile);\n      if (currentpos < 0)\n        return(-1);\n      offset=SeekBlob(ofile,savedpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n      offset=SeekBlob(ofile,currentpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      savedolen = 0L;\n    }\n  return(outputlen);\n}\n\n/* some defines for the different JPEG block types */\n#define M_SOF0  0xC0            /* Start Of Frame N */\n#define M_SOF1  0xC1            /* N indicates which compression process */\n#define M_SOF2  0xC2            /* Only SOF0-SOF2 are now in common use */\n#define M_SOF3  0xC3\n#define M_SOF5  0xC5            /* NB: codes C4 and CC are NOT SOF markers */\n#define M_SOF6  0xC6\n#define M_SOF7  0xC7\n#define M_SOF9  0xC9\n#define M_SOF10 0xCA\n#define M_SOF11 0xCB\n#define M_SOF13 0xCD\n#define M_SOF14 0xCE\n#define M_SOF15 0xCF\n#define M_SOI   0xD8\n#define M_EOI   0xD9            /* End Of Image (end of datastream) */\n#define M_SOS   0xDA            /* Start Of Scan (begins compressed data) */\n#define M_APP0  0xe0\n#define M_APP1  0xe1\n#define M_APP2  0xe2\n#define M_APP3  0xe3\n#define M_APP4  0xe4\n#define M_APP5  0xe5\n#define M_APP6  0xe6\n#define M_APP7  0xe7\n#define M_APP8  0xe8\n#define M_APP9  0xe9\n#define M_APP10 0xea\n#define M_APP11 0xeb\n#define M_APP12 0xec\n#define M_APP13 0xed\n#define M_APP14 0xee\n#define M_APP15 0xef\n\nstatic int jpeg_transfer_1(Image *ifile, Image *ofile)\n{\n  int c;\n\n  c = ReadBlobByte(ifile);\n  if (c == EOF)\n    return EOF;\n  (void) WriteBlobByte(ofile,(unsigned char) c);\n  return c;\n}\n\n#if defined(future)\nstatic int jpeg_skip_1(Image *ifile)\n{\n  int c;\n\n  c = ReadBlobByte(ifile);\n  if (c == EOF)\n    return EOF;\n  return c;\n}\n#endif\n\nstatic int jpeg_read_remaining(Image *ifile, Image *ofile)\n{\n   int c;\n\n  while ((c = jpeg_transfer_1(ifile, ofile)) != EOF)\n    continue;\n  return M_EOI;\n}\n\nstatic int jpeg_skip_variable(Image *ifile, Image *ofile)\n{\n  unsigned int  length;\n  int c1,c2;\n\n  if ((c1 = jpeg_transfer_1(ifile, ofile)) == EOF)\n    return M_EOI;\n  if ((c2 = jpeg_transfer_1(ifile, ofile)) == EOF)\n    return M_EOI;\n\n  length = (((unsigned char) c1) << 8) + ((unsigned char) c2);\n  length -= 2;\n\n  while (length--)\n    if (jpeg_transfer_1(ifile, ofile) == EOF)\n      return M_EOI;\n\n  return 0;\n}\n\nstatic int jpeg_skip_variable2(Image *ifile, Image *ofile)\n{\n  unsigned int  length;\n  int c1,c2;\n\n  (void) ofile;\n  if ((c1 = ReadBlobByte(ifile)) == EOF) return M_EOI;\n  if ((c2 = ReadBlobByte(ifile)) == EOF) return M_EOI;\n\n  length = (((unsigned char) c1) << 8) + ((unsigned char) c2);\n  length -= 2;\n\n  while (length--)\n    if (ReadBlobByte(ifile) == EOF)\n      return M_EOI;\n\n  return 0;\n}\n\nstatic int jpeg_nextmarker(Image *ifile, Image *ofile)\n{\n  int c;\n\n  /* transfer anything until we hit 0xff */\n  do\n  {\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return M_EOI; /* we hit EOF */\n    else\n      if (c != 0xff)\n        (void) WriteBlobByte(ofile,(unsigned char) c);\n  } while (c != 0xff);\n\n  /* get marker byte, swallowing possible padding */\n  do\n  {\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return M_EOI; /* we hit EOF */\n  } while (c == 0xff);\n\n  return c;\n}\n\n#if defined(future)\nstatic int jpeg_skip_till_marker(Image *ifile, int marker)\n{\n  int c, i;\n\n  do\n  {\n    /* skip anything until we hit 0xff */\n    i = 0;\n    do\n    {\n      c = ReadBlobByte(ifile);\n      i++;\n      if (c == EOF)\n        return M_EOI; /* we hit EOF */\n    } while (c != 0xff);\n\n    /* get marker byte, swallowing possible padding */\n    do\n    {\n      c = ReadBlobByte(ifile);\n      if (c == EOF)\n        return M_EOI; /* we hit EOF */\n    } while (c == 0xff);\n  } while (c != marker);\n  return c;\n}\n#endif\n\n/* Embed binary IPTC data into a JPEG image. */\nstatic int jpeg_embed(Image *ifile, Image *ofile, Image *iptc)\n{\n  unsigned int marker;\n  unsigned int done = 0;\n  unsigned int len;\n  int inx;\n\n  if (jpeg_transfer_1(ifile, ofile) != 0xFF)\n    return 0;\n  if (jpeg_transfer_1(ifile, ofile) != M_SOI)\n    return 0;\n\n  while (done == MagickFalse)\n  {\n    marker=(unsigned int) jpeg_nextmarker(ifile, ofile);\n    if (marker == M_EOI)\n      { /* EOF */\n        break;\n      }\n    else\n      {\n        if (marker != M_APP13)\n          {\n            (void) WriteBlobByte(ofile,0xff);\n            (void) WriteBlobByte(ofile,(unsigned char) marker);\n          }\n      }\n\n    switch (marker)\n    {\n      case M_APP13:\n        /* we are going to write a new APP13 marker, so don't output the old one */\n        jpeg_skip_variable2(ifile, ofile);\n        break;\n\n      case M_APP0:\n        /* APP0 is in each and every JPEG, so when we hit APP0 we insert our new APP13! */\n        jpeg_skip_variable(ifile, ofile);\n\n        if (iptc != (Image *) NULL)\n          {\n            char\n              psheader[] = \"\\xFF\\xED\\0\\0Photoshop 3.0\\0\" \"8BIM\\x04\\x04\\0\\0\\0\\0\";\n\n            len=(unsigned int) GetBlobSize(iptc);\n            if (len & 1)\n              len++; /* make the length even */\n            psheader[2]=(char) ((len+16)>>8);\n            psheader[3]=(char) ((len+16)&0xff);\n            for (inx = 0; inx < 18; inx++)\n              (void) WriteBlobByte(ofile,(unsigned char) psheader[inx]);\n            jpeg_read_remaining(iptc, ofile);\n            len=(unsigned int) GetBlobSize(iptc);\n            if (len & 1)\n              (void) WriteBlobByte(ofile,0);\n          }\n        break;\n\n      case M_SOS:\n        /* we hit data, no more marker-inserting can be done! */\n        jpeg_read_remaining(ifile, ofile);\n        done = 1;\n        break;\n\n      default:\n        jpeg_skip_variable(ifile, ofile);\n        break;\n    }\n  }\n  return 1;\n}\n\n/* handle stripping the APP13 data out of a JPEG */\n#if defined(future)\nstatic void jpeg_strip(Image *ifile, Image *ofile)\n{\n  unsigned int marker;\n\n  marker = jpeg_skip_till_marker(ifile, M_SOI);\n  if (marker == M_SOI)\n  {\n    (void) WriteBlobByte(ofile,0xff);\n    (void) WriteBlobByte(ofile,M_SOI);\n    jpeg_read_remaining(ifile, ofile);\n  }\n}\n\n/* Extract any APP13 binary data into a file. */\nstatic int jpeg_extract(Image *ifile, Image *ofile)\n{\n  unsigned int marker;\n  unsigned int done = 0;\n\n  if (jpeg_skip_1(ifile) != 0xff)\n    return 0;\n  if (jpeg_skip_1(ifile) != M_SOI)\n    return 0;\n\n  while (done == MagickFalse)\n  {\n    marker = jpeg_skip_till_marker(ifile, M_APP13);\n    if (marker == M_APP13)\n      {\n        marker = jpeg_nextmarker(ifile, ofile);\n        break;\n      }\n  }\n  return 1;\n}\n#endif\n\nstatic inline void CopyBlob(Image *source,Image *destination)\n{\n  ssize_t\n    i;\n\n  unsigned char\n    *buffer;\n\n  ssize_t\n    count,\n    length;\n\n  buffer=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n    sizeof(*buffer));\n  if (buffer != (unsigned char *) NULL)\n    {\n      i=0;\n      while ((length=ReadBlob(source,MagickMaxBufferExtent,buffer)) != 0)\n      {\n        count=0;\n        for (i=0; i < (ssize_t) length; i+=count)\n        {\n          count=WriteBlob(destination,(size_t) (length-i),buffer+i);\n          if (count <= 0)\n            break;\n        }\n        if (i < (ssize_t) length)\n          break;\n      }\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n    }\n}\n\nstatic Image *ReadMETAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *buff,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  size_t\n    length;\n\n  void\n    *blob;\n\n  /*\n    Open file containing binary metadata\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=1;\n  image->rows=1;\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  length=1;\n  if (LocaleNCompare(image_info->magick,\"8BIM\",4) == 0)\n    {\n      /*\n        Read 8BIM binary metadata.\n      */\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      if (LocaleCompare(image_info->magick,\"8BIMTEXT\") == 0)\n        {\n          length=(size_t) parse8BIM(image, buff);\n          if (length & 1)\n            (void) WriteBlobByte(buff,0x0);\n        }\n      else if (LocaleCompare(image_info->magick,\"8BIMWTEXT\") == 0)\n        {\n          length=(size_t) parse8BIMW(image, buff);\n          if (length & 1)\n            (void) WriteBlobByte(buff,0x0);\n        }\n      else\n        CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (LocaleNCompare(image_info->magick,\"APP1\",4) == 0)\n    {\n      char\n        name[MagickPathExtent];\n\n      (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",1);\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      if (LocaleCompare(image_info->magick,\"APP1JPEG\") == 0)\n        {\n          Image\n            *iptc;\n\n          int\n            result;\n\n          if (image_info->profile == (void *) NULL)\n            {\n              blob=DetachBlob(buff->blob);\n              blob=(unsigned char *) RelinquishMagickMemory(blob);\n              buff=DestroyImage(buff);\n              ThrowReaderException(CoderError,\"NoIPTCProfileAvailable\");\n            }\n          profile=CloneStringInfo((StringInfo *) image_info->profile);\n          iptc=AcquireImage((ImageInfo *) NULL,exception);\n          if (iptc == (Image *) NULL)\n            {\n              blob=DetachBlob(buff->blob);\n              blob=(unsigned char *) RelinquishMagickMemory(blob);\n              buff=DestroyImage(buff);\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          AttachBlob(iptc->blob,GetStringInfoDatum(profile),\n            GetStringInfoLength(profile));\n          result=jpeg_embed(image,buff,iptc);\n          blob=DetachBlob(iptc->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          iptc=DestroyImage(iptc);\n          if (result == 0)\n            {\n              buff=DestroyImage(buff);\n              ThrowReaderException(CoderError,\"JPEGEmbeddingFailed\");\n            }\n        }\n      else\n        CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      status=SetImageProfile(image,name,profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if ((LocaleCompare(image_info->magick,\"ICC\") == 0) ||\n      (LocaleCompare(image_info->magick,\"ICM\") == 0))\n    {\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n    }\n  if (LocaleCompare(image_info->magick,\"IPTC\") == 0)\n    {\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n    }\n  if (LocaleCompare(image_info->magick,\"XMP\") == 0)\n    {\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      blob=(unsigned char *) AcquireQuantumMemory(length,sizeof(unsigned char));\n      if (blob == (unsigned char *) NULL)\n        {\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      AttachBlob(buff->blob,blob,length);\n      CopyBlob(image,buff);\n      profile=BlobToStringInfo(GetBlobStreamData(buff),(size_t)\n        GetBlobSize(buff));\n      if (profile == (StringInfo *) NULL)\n        {\n          blob=DetachBlob(buff->blob);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          buff=DestroyImage(buff);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) SetImageProfile(image,\"xmp\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      blob=DetachBlob(buff->blob);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      buff=DestroyImage(buff);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M E T A I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMETAImage() adds attributes for the META image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMETAImage method is:\n%\n%      size_t RegisterMETAImage(void)\n%\n*/\nModuleExport size_t RegisterMETAImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"META\",\"8BIM\",\"Photoshop resource format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"8BIMTEXT\",\"Photoshop resource text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"8BIMWTEXT\",\n    \"Photoshop resource wide text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"APP1\",\"Raw application information\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"APP1JPEG\",\"Raw JPEG binary data\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"EXIF\",\"Exif digital camera binary data\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"XMP\",\"Adobe XML metadata\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"ICM\",\"ICC Color Profile\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"ICC\",\"ICC Color Profile\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"IPTC\",\"IPTC Newsphoto\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"IPTCTEXT\",\"IPTC Newsphoto text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"META\",\"IPTCWTEXT\",\"IPTC Newsphoto text format\");\n  entry->decoder=(DecodeImageHandler *) ReadMETAImage;\n  entry->encoder=(EncodeImageHandler *) WriteMETAImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M E T A I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMETAImage() removes format registrations made by the\n%  META module from the list of supported formats.\n%\n%  The format of the UnregisterMETAImage method is:\n%\n%      UnregisterMETAImage(void)\n%\n*/\nModuleExport void UnregisterMETAImage(void)\n{\n  (void) UnregisterMagickInfo(\"8BIM\");\n  (void) UnregisterMagickInfo(\"8BIMTEXT\");\n  (void) UnregisterMagickInfo(\"8BIMWTEXT\");\n  (void) UnregisterMagickInfo(\"EXIF\");\n  (void) UnregisterMagickInfo(\"APP1\");\n  (void) UnregisterMagickInfo(\"APP1JPEG\");\n  (void) UnregisterMagickInfo(\"ICCTEXT\");\n  (void) UnregisterMagickInfo(\"ICM\");\n  (void) UnregisterMagickInfo(\"ICC\");\n  (void) UnregisterMagickInfo(\"IPTC\");\n  (void) UnregisterMagickInfo(\"IPTCTEXT\");\n  (void) UnregisterMagickInfo(\"IPTCWTEXT\");\n  (void) UnregisterMagickInfo(\"XMP\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M E T A I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMETAImage() writes a META image to a file.\n%\n%  The format of the WriteMETAImage method is:\n%\n%      MagickBooleanType WriteMETAImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  Compression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Specifies a pointer to an ImageInfo structure.\n%\n%    o image: A pointer to a Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t GetIPTCStream(unsigned char **info,size_t length)\n{\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    extent,\n    info_length;\n\n  unsigned int\n    marker;\n\n  size_t\n    tag_length;\n\n  p=(*info);\n  extent=length;\n  if ((*p == 0x1c) && (*(p+1) == 0x02))\n    return(length);\n  /*\n    Extract IPTC from 8BIM resource block.\n  */\n  while (extent >= 12)\n  {\n    if (strncmp((const char *) p,\"8BIM\",4))\n      break;\n    p+=4;\n    extent-=4;\n    marker=(unsigned int) (*p) << 8 | *(p+1);\n    p+=2;\n    extent-=2;\n    c=*p++;\n    extent--;\n    c|=0x01;\n    if ((size_t) c >= extent)\n      break;\n    p+=c;\n    extent-=c;\n    if (extent < 4)\n      break;\n    tag_length=(((size_t) *p) << 24) | (((size_t) *(p+1)) << 16) |\n      (((size_t) *(p+2)) << 8) | ((size_t) *(p+3));\n    p+=4;\n    extent-=4;\n    if (tag_length > extent)\n      break;\n    if (marker == IPTC_ID)\n      {\n        *info=p;\n        return(tag_length);\n      }\n    if ((tag_length & 0x01) != 0)\n      tag_length++;\n    p+=tag_length;\n    extent-=tag_length;\n  }\n  /*\n    Find the beginning of the IPTC info.\n  */\n  p=(*info);\n  tag_length=0;\niptc_find:\n  info_length=0;\n  marker=MagickFalse;\n  while (length != 0)\n  {\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    if (c == 0x1c)\n      {\n        p--;\n        *info=p; /* let the caller know were it is */\n        break;\n      }\n  }\n  /*\n    Determine the length of the IPTC info.\n  */\n  while (length != 0)\n  {\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    if (c == 0x1c)\n      marker=MagickTrue;\n    else\n      if (marker)\n        break;\n      else\n        continue;\n    info_length++;\n    /*\n      Found the 0x1c tag; skip the dataset and record number tags.\n    */\n    c=(*p++); /* should be 2 */\n    length--;\n    if (length == 0)\n      break;\n    if ((info_length == 1) && (c != 2))\n      goto iptc_find;\n    info_length++;\n    c=(*p++); /* should be 0 */\n    length--;\n    if (length == 0)\n      break;\n    if ((info_length == 2) && (c != 0))\n      goto iptc_find;\n    info_length++;\n    /*\n      Decode the length of the block that follows - ssize_t or short format.\n    */\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    info_length++;\n    if ((c & 0x80) != 0)\n      {\n        /*\n          Long format.\n        */\n        tag_length=0;\n        for (i=0; i < 4; i++)\n        {\n          tag_length<<=8;\n          tag_length|=(*p++);\n          length--;\n          if (length == 0)\n            break;\n          info_length++;\n        }\n      }\n    else\n      {\n        /*\n          Short format.\n        */\n        tag_length=((long) c) << 8;\n        c=(*p++);\n        length--;\n        if (length == 0)\n          break;\n        info_length++;\n        tag_length|=(long) c;\n      }\n    if (tag_length > (length+1))\n      break;\n    p+=tag_length;\n    length-=tag_length;\n    if (length == 0)\n      break;\n    info_length+=tag_length;\n  }\n  return(info_length);\n}\n\nstatic void formatString(Image *ofile, const char *s, int len)\n{\n  char\n    temp[MagickPathExtent];\n\n  (void) WriteBlobByte(ofile,'\"');\n  for (; len > 0; len--, s++) {\n    int c = (*s) & 255;\n    switch (c) {\n    case '&':\n      (void) WriteBlobString(ofile,\"&amp;\");\n      break;\n#ifdef HANDLE_GT_LT\n    case '<':\n      (void) WriteBlobString(ofile,\"&lt;\");\n      break;\n    case '>':\n      (void) WriteBlobString(ofile,\"&gt;\");\n      break;\n#endif\n    case '\"':\n      (void) WriteBlobString(ofile,\"&quot;\");\n      break;\n    default:\n      if (isprint(c))\n        (void) WriteBlobByte(ofile,(unsigned char) *s);\n      else\n        {\n          (void) FormatLocaleString(temp,MagickPathExtent,\"&#%d;\", c & 255);\n          (void) WriteBlobString(ofile,temp);\n        }\n      break;\n    }\n  }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  (void) WriteBlobString(ofile,\"\\\"\\r\\n\");\n#else\n#if defined(macintosh)\n  (void) WriteBlobString(ofile,\"\\\"\\r\");\n#else\n  (void) WriteBlobString(ofile,\"\\\"\\n\");\n#endif\n#endif\n}\n\ntypedef struct _tag_spec\n{\n  const short\n    id;\n\n  const char\n    *name;\n} tag_spec;\n\nstatic const tag_spec tags[] = {\n  { 5, \"Image Name\" },\n  { 7, \"Edit Status\" },\n  { 10, \"Priority\" },\n  { 15, \"Category\" },\n  { 20, \"Supplemental Category\" },\n  { 22, \"Fixture Identifier\" },\n  { 25, \"Keyword\" },\n  { 30, \"Release Date\" },\n  { 35, \"Release Time\" },\n  { 40, \"Special Instructions\" },\n  { 45, \"Reference Service\" },\n  { 47, \"Reference Date\" },\n  { 50, \"Reference Number\" },\n  { 55, \"Created Date\" },\n  { 60, \"Created Time\" },\n  { 65, \"Originating Program\" },\n  { 70, \"Program Version\" },\n  { 75, \"Object Cycle\" },\n  { 80, \"Byline\" },\n  { 85, \"Byline Title\" },\n  { 90, \"City\" },\n  { 92, \"Sub-Location\" },\n  { 95, \"Province State\" },\n  { 100, \"Country Code\" },\n  { 101, \"Country\" },\n  { 103, \"Original Transmission Reference\" },\n  { 105, \"Headline\" },\n  { 110, \"Credit\" },\n  { 115, \"Source\" },\n  { 116, \"Copyright String\" },\n  { 120, \"Caption\" },\n  { 121, \"Image Orientation\" },\n  { 122, \"Caption Writer\" },\n  { 131, \"Local Caption\" },\n  { 200, \"Custom Field 1\" },\n  { 201, \"Custom Field 2\" },\n  { 202, \"Custom Field 3\" },\n  { 203, \"Custom Field 4\" },\n  { 204, \"Custom Field 5\" },\n  { 205, \"Custom Field 6\" },\n  { 206, \"Custom Field 7\" },\n  { 207, \"Custom Field 8\" },\n  { 208, \"Custom Field 9\" },\n  { 209, \"Custom Field 10\" },\n  { 210, \"Custom Field 11\" },\n  { 211, \"Custom Field 12\" },\n  { 212, \"Custom Field 13\" },\n  { 213, \"Custom Field 14\" },\n  { 214, \"Custom Field 15\" },\n  { 215, \"Custom Field 16\" },\n  { 216, \"Custom Field 17\" },\n  { 217, \"Custom Field 18\" },\n  { 218, \"Custom Field 19\" },\n  { 219, \"Custom Field 20\" }\n};\n\nstatic int formatIPTC(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return(-1);\n        else\n          {\n            c=0;\n            continue;\n          }\n      }\n\n    /* we found the 0x1c tag and now grab the dataset and record number tags */\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    dataset = (unsigned char) c;\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n    {\n      if (tags[i].id == (short) recnum)\n          break;\n    }\n    if (i < tagcount)\n      readable = (unsigned char *) tags[i].name;\n    else\n      readable = (unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        int\n          c0;\n\n        c0=ReadBlobByte(ifile);\n        if (c0 == EOF)\n          return(-1);\n        taglen = (c << 8) | c0;\n      }\n    if (taglen < 0)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return(0);\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          return(-1);\n        }\n      str[tagindx] = (unsigned char) c;\n    }\n    str[taglen] = 0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset, (unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n\n    c=ReadBlobByte(ifile);\n  }\n  return((int) tagsfound);\n}\n\nstatic int readWordFromBuffer(char **s, ssize_t *len)\n{\n  unsigned char\n    buffer[2];\n\n  int\n    i,\n    c;\n\n  for (i=0; i<2; i++)\n  {\n    c = *(*s)++; (*len)--;\n    if (*len < 0) return -1;\n    buffer[i] = (unsigned char) c;\n  }\n  return (((int) buffer[ 0 ]) <<  8) |\n         (((int) buffer[ 1 ]));\n}\n\nstatic int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    /*\n      We found the 0x1c tag and now grab the dataset and record number tags.\n    */\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      printf(\"MemoryAllocationFailed\");\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        return(-1);\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}\n\nstatic int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        return 0;\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n      }\n    }\n    count=(ssize_t) ReadBlobMSBSignedLong(ifile);\n    if ((count < 0) || (count > GetBlobSize(ifile)))\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return -1;\n      }\n    /* make a buffer to hold the data and snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count+1,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          PString=(unsigned char *) RelinquishMagickMemory(PString);\n          return -1;\n        }\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}\n\nstatic MagickBooleanType WriteMETAImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=0;\n  if (LocaleCompare(image_info->magick,\"8BIM\") == 0)\n    {\n      /*\n        Write 8BIM image.\n      */\n      profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"iptc\") == 0)\n    {\n      size_t\n        length;\n\n      unsigned char\n        *info;\n\n      profile=GetImageProfile(image,\"iptc\");\n      if (profile == (StringInfo *) NULL)\n        profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      info=GetStringInfoDatum(profile);\n      length=GetStringInfoLength(profile);\n      length=GetIPTCStream(&info,length);\n      if (length == 0)\n        ThrowWriterException(CoderError,\"NoIPTCProfileAvailable\");\n      (void) WriteBlob(image,length,info);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"8BIMTEXT\") == 0)\n    {\n      Image\n        *buff;\n\n      profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      AttachBlob(buff->blob,GetStringInfoDatum(profile),\n        GetStringInfoLength(profile));\n      format8BIM(buff,image);\n      (void) DetachBlob(buff->blob);\n      buff=DestroyImage(buff);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"8BIMWTEXT\") == 0)\n    return(MagickFalse);\n  if (LocaleCompare(image_info->magick,\"IPTCTEXT\") == 0)\n    {\n      Image\n        *buff;\n\n      unsigned char\n        *info;\n\n      profile=GetImageProfile(image,\"8bim\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"No8BIMDataIsAvailable\");\n      info=GetStringInfoDatum(profile);\n      length=GetStringInfoLength(profile);\n      length=GetIPTCStream(&info,length);\n      if (length == 0)\n        ThrowWriterException(CoderError,\"NoIPTCProfileAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      buff=AcquireImage((ImageInfo *) NULL,exception);\n      if (buff == (Image *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      AttachBlob(buff->blob,info,length);\n      formatIPTC(buff,image);\n      (void) DetachBlob(buff->blob);\n      buff=DestroyImage(buff);\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if (LocaleCompare(image_info->magick,\"IPTCWTEXT\") == 0)\n    return(MagickFalse);\n  if ((LocaleCompare(image_info->magick,\"APP1\") == 0) ||\n      (LocaleCompare(image_info->magick,\"EXIF\") == 0) ||\n      (LocaleCompare(image_info->magick,\"XMP\") == 0))\n    {\n      /*\n        (void) Write APP1 image.\n      */\n      profile=GetImageProfile(image,image_info->magick);\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"NoAPP1DataIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  if ((LocaleCompare(image_info->magick,\"ICC\") == 0) ||\n      (LocaleCompare(image_info->magick,\"ICM\") == 0))\n    {\n      /*\n        Write ICM image.\n      */\n      profile=GetImageProfile(image,\"icc\");\n      if (profile == (StringInfo *) NULL)\n        ThrowWriterException(CoderError,\"NoColorProfileIsAvailable\");\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) CloseBlob(image);\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n"], "filenames": ["coders/meta.c"], "buggy_code_start_loc": [2214], "buggy_code_end_loc": [2215], "fixing_code_start_loc": [2214], "fixing_code_end_loc": [2215], "type": "CWE-193", "message": "An off-by-one read vulnerability was discovered in ImageMagick before version 7.0.7-28 in the formatIPTCfromBuffer function in coders/meta.c. A local attacker may use this flaw to read beyond the end of the buffer or to crash the program.", "other": {"cve": {"id": "CVE-2019-10131", "sourceIdentifier": "secalert@redhat.com", "published": "2019-04-30T19:29:03.717", "lastModified": "2021-10-28T12:20:39.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An off-by-one read vulnerability was discovered in ImageMagick before version 7.0.7-28 in the formatIPTCfromBuffer function in coders/meta.c. A local attacker may use this flaw to read beyond the end of the buffer or to crash the program."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad de lectura off-by-one en ImageMagick anterior a la versi\u00f3n 7.0.7-28 en la funci\u00f3n formatIPTCfromBuffer en coders/meta.c. Un atacante local puede utilizar este fallo para leer m\u00e1s all\u00e1 del final del b\u00fafer o para bloquear el programa."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.9-40", "matchCriteriaId": "B623D9D2-0F81-42C2-AFD7-7B9156CE7E98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.7-28", "matchCriteriaId": "A92DC54D-34C1-432B-9C21-8642822DF65C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "5F65DAB0-3DAD-49FF-BC73-3581CC3D5BF3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00051.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00001.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/108117", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-10131", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/cb1214c124e1bd61f7dd551b94a794864861592e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00030.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/cb1214c124e1bd61f7dd551b94a794864861592e"}}