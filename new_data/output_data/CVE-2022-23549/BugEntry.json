{"buggy_code": ["# frozen_string_literal: true\n\nclass StrippedLengthValidator < ActiveModel::EachValidator\n  def self.validate(record, attribute, value, range)\n    if !value.nil?\n      value = get_sanitized_value(value)\n      record.errors.add attribute, (I18n.t('errors.messages.too_short', count: range.begin)) if value.length < range.begin\n      record.errors.add attribute, (I18n.t('errors.messages.too_long_validation', max: range.end, length: value.length)) if value.length > range.end\n    else\n      record.errors.add attribute, (I18n.t('errors.messages.blank'))\n    end\n  end\n\n  def validate_each(record, attribute, value)\n    # the `in` parameter might be a lambda when the range is dynamic\n    range = options[:in].lambda? ? options[:in].call : options[:in]\n    self.class.validate(record, attribute, value, range)\n  end\n\n  def self.get_sanitized_value(value)\n    value = value.dup\n    value.gsub!(/<!--(.*?)-->/, '') # strip HTML comments\n    value.gsub!(/:\\w+(:\\w+)?:/, \"X\") # replace emojis with a single character\n    value.gsub!(/\\.{2,}/, '\u2026') # replace multiple ... with \u2026\n    value.gsub!(/\\,{2,}/, ',') # replace multiple ,,, with ,\n    value.strip\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.shared_examples 'finding and showing post' do\n  let!(:post) { post_by_user }\n\n  it \"ensures the user can't see the post\" do\n    topic = post.topic\n    topic.convert_to_private_message(Discourse.system_user)\n    topic.remove_allowed_user(Discourse.system_user, user.username)\n    get url\n    expect(response).to be_forbidden\n  end\n\n  it 'succeeds' do\n    get url\n    expect(response.status).to eq(200)\n  end\n\n  it \"returns 404 when post's topic is deleted\" do\n    post.topic.destroy!\n    get url\n    expect(response.status).to eq(404)\n  end\n\n  context \"with deleted post\" do\n    before do\n      post.trash!(user)\n    end\n\n    it \"can't find deleted posts as an anonymous user\" do\n      get url\n      expect(response.status).to eq(404)\n    end\n\n    it \"can't find deleted posts as a regular user\" do\n      sign_in(user)\n      get url\n      expect(response.status).to eq(404)\n    end\n\n    it \"can find posts as a moderator\" do\n      sign_in(moderator)\n      get url\n      expect(response.status).to eq(200)\n    end\n\n    it \"can find posts as a admin\" do\n      sign_in(admin)\n      get url\n      expect(response.status).to eq(200)\n    end\n\n    context \"with category group moderator\" do\n      fab!(:group_user) { Fabricate(:group_user) }\n      let(:user_gm) { group_user.user }\n      let(:group) { group_user.group }\n\n      before do\n        SiteSetting.enable_category_group_moderation = true\n        sign_in(user_gm)\n      end\n\n      it \"can find posts in the allowed category\" do\n        post.topic.category.update!(reviewable_by_group_id: group.id, topic_id: topic.id)\n        get url\n        expect(response.status).to eq(200)\n      end\n\n      it \"can't find posts outside of the allowed category\" do\n        get url\n        expect(response.status).to eq(404)\n      end\n    end\n  end\nend\n\nRSpec.shared_examples 'action requires login' do |method, url, params = {}|\n  it 'raises an exception when not logged in' do\n    self.public_send(method, url, **params)\n    expect(response.status).to eq(403)\n  end\nend\n\nRSpec.describe PostsController do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user_trust_level_0) { Fabricate(:trust_level_0) }\n  fab!(:user_trust_level_1) { Fabricate(:trust_level_1) }\n  fab!(:category) { Fabricate(:category) }\n  fab!(:topic) { Fabricate(:topic) }\n  fab!(:post_by_user) { Fabricate(:post, user: user) }\n  let(:public_post) { Fabricate(:post, user: user, topic: topic) }\n  let(:topicless_post) { Fabricate(:post, user: user, raw: '<p>Car 54, where are you?</p>') }\n\n  let(:private_topic) do\n    Fabricate(:topic, archetype: Archetype.private_message, category_id: nil)\n  end\n\n  let(:private_post) { Fabricate(:post, user: user, topic: private_topic) }\n\n  describe '#show' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}.json\" }\n    end\n\n    it 'gets all the expected fields' do\n      # non fabricated test\n      new_post = create_post\n\n      get \"/posts/#{new_post.id}.json\"\n      parsed = response.parsed_body\n\n      expect(parsed[\"topic_slug\"]).to eq(new_post.topic.slug)\n      expect(parsed[\"moderator\"]).to eq(false)\n      expect(parsed[\"username\"]).to eq(new_post.user.username)\n      expect(parsed[\"cooked\"]).to eq(new_post.cooked)\n    end\n  end\n\n  describe '#by_number' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/by_number/#{post.topic_id}/#{post.post_number}.json\" }\n    end\n  end\n\n  describe '#by_date' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/by-date/#{post.topic_id}/#{post.created_at.strftime(\"%Y-%m-%d\")}.json\" }\n    end\n\n    it 'returns the expected post' do\n      first_post = Fabricate(:post, created_at: 10.days.ago)\n      second_post = Fabricate(:post, topic: first_post.topic, created_at: 4.days.ago)\n      _third_post = Fabricate(:post, topic: first_post.topic, created_at: 3.days.ago)\n\n      get \"/posts/by-date/#{second_post.topic_id}/#{(second_post.created_at - 2.days).strftime(\"%Y-%m-%d\")}.json\"\n      json = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(json[\"id\"]).to eq(second_post.id)\n    end\n\n    it 'returns no post if date is > at last created post' do\n      get \"/posts/by-date/#{post.topic_id}/2245-11-11.json\"\n      _json = response.parsed_body\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe '#reply_history' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}/reply-history.json\" }\n    end\n\n    it \"returns the replies with allowlisted user custom fields\" do\n      parent = Fabricate(:post)\n      child = Fabricate(:post, topic: parent.topic, reply_to_post_number: parent.post_number)\n\n      parent.user.upsert_custom_fields(hello: 'world', hidden: 'dontshow')\n      SiteSetting.public_user_custom_fields = 'hello'\n\n      get \"/posts/#{child.id}/reply-history.json\"\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n      expect(json[0]['id']).to eq(parent.id)\n      expect(json[0]['user_custom_fields']['hello']).to eq('world')\n      expect(json[0]['user_custom_fields']['hidden']).to be_blank\n    end\n  end\n\n  describe '#reply_ids' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}/reply-ids.json\" }\n    end\n\n    it \"returns ids of post's replies\" do\n      post = Fabricate(:post)\n      reply1 = Fabricate(:post, topic: post.topic, reply_to_post_number: post.post_number)\n      reply2 = Fabricate(:post, topic: post.topic, reply_to_post_number: post.post_number)\n      PostReply.create(post_id: post.id, reply_post_id: reply1.id)\n      PostReply.create(post_id: post.id, reply_post_id: reply2.id)\n\n      get \"/posts/#{post.id}/reply-ids.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body).to eq([\n        { \"id\" => reply1.id, \"level\" => 1 },\n        { \"id\" => reply2.id, \"level\" => 1 },\n      ])\n    end\n  end\n\n  describe '#replies' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}/replies.json\" }\n    end\n\n    it 'asks post for replies' do\n      parent = Fabricate(:post)\n      child = Fabricate(:post, topic: parent.topic, reply_to_post_number: parent.post_number)\n      PostReply.create!(post: parent, reply: child)\n\n      child.user.upsert_custom_fields(hello: 'world', hidden: 'dontshow')\n      SiteSetting.public_user_custom_fields = 'hello'\n\n      get \"/posts/#{parent.id}/replies.json\"\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n      expect(json[0]['id']).to eq(child.id)\n      expect(json[0]['user_custom_fields']['hello']).to eq('world')\n      expect(json[0]['user_custom_fields']['hidden']).to be_blank\n    end\n  end\n\n  describe '#destroy' do\n    include_examples 'action requires login', :delete, \"/posts/123.json\"\n\n    describe 'when logged in' do\n      let(:topic) { Fabricate(:topic) }\n\n      it \"raises an error when the user doesn't have permission to see the post\" do\n        pm = Fabricate(:private_message_topic)\n        post = Fabricate(:post, topic: pm, post_number: 3)\n\n        sign_in(user)\n\n        delete \"/posts/#{post.id}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when the self deletions are disabled\" do\n        SiteSetting.max_post_deletions_per_day = 0\n        post = Fabricate(:post, user: user, topic: topic, post_number: 3)\n        sign_in(user)\n\n        delete \"/posts/#{post.id}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"uses a PostDestroyer\" do\n        post = Fabricate(:post, topic_id: topic.id, post_number: 3)\n        sign_in(moderator)\n\n        destroyer = mock\n        PostDestroyer.expects(:new).returns(destroyer)\n        destroyer.expects(:destroy)\n\n        delete \"/posts/#{post.id}.json\"\n      end\n\n      context \"with permanently destroy\" do\n        let!(:post) { Fabricate(:post, topic_id: topic.id, post_number: 3) }\n\n        before do\n          SiteSetting.can_permanently_delete = true\n        end\n\n        it \"does not work for a post that was not deleted yet\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(403)\n        end\n\n        it \"needs some time to pass to permanently delete a topic\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\"\n          expect(response.status).to eq(200)\n          expect(post.reload.deleted_by_id).to eq(admin.id)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(403)\n\n          post.update!(deleted_at: 10.minutes.ago)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(200)\n          expect { post.reload }.to raise_error(ActiveRecord::RecordNotFound)\n        end\n\n        it \"needs two users to permanently delete a topic\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\"\n          expect(response.status).to eq(200)\n          expect(post.reload.deleted_by_id).to eq(admin.id)\n\n          sign_in(Fabricate(:admin))\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(200)\n          expect { post.reload }.to raise_error(ActiveRecord::RecordNotFound)\n        end\n\n        it \"moderators cannot permanently delete topics\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\"\n          expect(response.status).to eq(200)\n          expect(post.reload.deleted_by_id).to eq(admin.id)\n\n          sign_in(moderator)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe '#destroy_many' do\n    include_examples 'action requires login', :delete, \"/posts/destroy_many.json\", params: { post_ids: [123, 345] }\n\n    describe 'when logged in' do\n      fab!(:poster) { Fabricate(:moderator) }\n      fab!(:post1) { Fabricate(:post, user: poster, post_number: 2) }\n      fab!(:post2) { Fabricate(:post, topic: post1.topic, user: poster, post_number: 3, reply_to_post_number: post1.post_number) }\n\n      it \"raises invalid parameters no post_ids\" do\n        sign_in(poster)\n        delete \"/posts/destroy_many.json\"\n        expect(response.status).to eq(400)\n        expect(response.message.downcase).to eq(\"bad request\")\n      end\n\n      it \"raises invalid parameters with missing ids\" do\n        sign_in(poster)\n        delete \"/posts/destroy_many.json\", params: { post_ids: [12345] }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to delete the posts\" do\n        sign_in(user)\n        delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes the post\" do\n        sign_in(poster)\n        PostDestroyer.any_instance.expects(:destroy).twice\n        delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n        expect(response.status).to eq(200)\n      end\n\n      it \"updates the highest read data for the forum\" do\n        sign_in(poster)\n        Topic.expects(:reset_highest).twice\n        delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n      end\n\n      describe \"can delete replies\" do\n        before do\n          PostReply.create(post_id: post1.id, reply_post_id: post2.id)\n        end\n\n        it \"deletes the post and the reply to it\" do\n          sign_in(poster)\n          PostDestroyer.any_instance.expects(:destroy).twice\n          delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id], reply_post_ids: [post1.id] }\n        end\n      end\n\n      context \"when deleting flagged posts\" do\n        before do\n          sign_in(moderator)\n          PostActionCreator.off_topic(moderator, post1)\n          PostActionCreator.off_topic(moderator, post2)\n          Jobs::SendSystemMessage.clear\n        end\n\n        it \"defers the child posts by default\" do\n          expect(ReviewableFlaggedPost.pending.count).to eq(2)\n          delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(ReviewableFlaggedPost.pending.count).to eq(0)\n        end\n\n        it \"can defer all posts based on `agree_with_first_reply_flag` param\" do\n          expect(ReviewableFlaggedPost.pending.count).to eq(2)\n          delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id], agree_with_first_reply_flag: false }\n          PostActionCreator.off_topic(moderator, post1)\n          PostActionCreator.off_topic(moderator, post2)\n          Jobs::SendSystemMessage.clear\n        end\n      end\n    end\n  end\n\n  describe '#recover' do\n    include_examples 'action requires login', :put, \"/posts/123/recover.json\"\n\n    describe 'when logged in' do\n      it \"raises an error when the user doesn't have permission to see the post\" do\n        post = Fabricate(:post, topic: Fabricate(:private_message_topic), post_number: 3)\n        sign_in(user)\n\n        put \"/posts/#{post.id}/recover.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when self deletion/recovery is disabled\" do\n        SiteSetting.max_post_deletions_per_day = 0\n        post = Fabricate(:post, user: user, topic: topic, post_number: 3)\n        sign_in(user)\n\n        put \"/posts/#{post.id}/recover.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"recovers a post correctly\" do\n        topic_id = create_post.topic_id\n        post = create_post(topic_id: topic_id)\n        sign_in(user)\n\n        PostDestroyer.new(user, post).destroy\n        put \"/posts/#{post.id}/recover.json\"\n        post.reload\n        expect(post.trashed?).to be_falsey\n      end\n    end\n  end\n\n  describe '#update' do\n    include_examples 'action requires login', :put, \"/posts/2.json\"\n\n    let!(:post) { post_by_user }\n    let(:update_params) do\n      {\n        post: { raw: 'edited body', edit_reason: 'typo' },\n        image_sizes: { 'http://image.com/image.jpg' => { 'width' => 123, 'height' => 456 } },\n      }\n    end\n\n    describe 'when logged in as a regular user' do\n      before do\n        sign_in(user)\n      end\n\n      it 'does not allow TL0 or TL1 to update when edit time limit expired' do\n        SiteSetting.post_edit_time_limit = 5\n        SiteSetting.tl2_post_edit_time_limit = 30\n\n        post = Fabricate(:post, created_at: 10.minutes.ago, user: user)\n\n        user.update_columns(trust_level: 1)\n\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('too_late_to_edit'))\n      end\n\n      it 'does not allow TL2 to update when edit time limit expired' do\n        SiteSetting.post_edit_time_limit = 12\n        SiteSetting.tl2_post_edit_time_limit = 8\n\n        user.update_columns(trust_level: 2)\n\n        post = Fabricate(:post, created_at: 10.minutes.ago, user: user)\n\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('too_late_to_edit'))\n      end\n\n      it 'passes the image sizes through' do\n        Post.any_instance.expects(:image_sizes=)\n        put \"/posts/#{post.id}.json\", params: update_params\n      end\n\n      it 'passes the edit reason through' do\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(200)\n        post.reload\n        expect(post.edit_reason).to eq(\"typo\")\n        expect(post.raw).to eq(\"edited body\")\n      end\n\n      it 'checks for an edit conflict' do\n        update_params[:post][:raw_old] = 'old body'\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(409)\n      end\n\n      it \"raises an error when the post parameter is missing\" do\n        update_params.delete(:post)\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(400)\n        expect(response.message.downcase).to eq(\"bad request\")\n      end\n\n      it \"raises an error when the user doesn't have permission to see the post\" do\n        post = Fabricate(:private_message_post, post_number: 3)\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response).to be_forbidden\n      end\n\n      it \"updates post's raw attribute\" do\n        put \"/posts/#{post.id}.json\", params: { post: { raw: 'edited body   ' } }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['post']['raw']).to eq('edited body')\n        expect(post.reload.raw).to eq('edited body')\n      end\n\n      it \"extracts links from the new body\" do\n        param = update_params\n        param[:post][:raw] = 'I just visited this https://google.com so many cool links'\n\n        put \"/posts/#{post.id}.json\", params: param\n\n        expect(response.status).to eq(200)\n        expect(TopicLink.count).to eq(1)\n      end\n\n      it \"doesn't allow updating of deleted posts\" do\n        first_post = post.topic.ordered_posts.first\n        PostDestroyer.new(moderator, first_post).destroy\n\n        put \"/posts/#{first_post.id}.json\", params: update_params\n        expect(response).not_to be_successful\n      end\n    end\n\n    describe \"when logged in as staff\" do\n      before do\n        sign_in(moderator)\n      end\n\n      it \"supports updating posts in deleted topics\" do\n        first_post = post.topic.ordered_posts.first\n        PostDestroyer.new(moderator, first_post).destroy\n\n        put \"/posts/#{first_post.id}.json\", params: update_params\n        expect(response.status).to eq(200)\n\n        post.reload\n        expect(post.raw).to eq('edited body')\n      end\n\n      it \"won't update bump date if post is a whisper\" do\n        created_at = freeze_time 1.day.ago\n        post = Fabricate(:post, post_type: Post.types[:whisper], user: user)\n\n        unfreeze_time\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(200)\n        expect(post.topic.reload.bumped_at).to eq_time(created_at)\n      end\n    end\n\n    describe \"when logged in as group moderator\" do\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:post) { Fabricate(:post, user: user, topic: topic) }\n      fab!(:group_user) { Fabricate(:group_user) }\n      let(:user_gm) { group_user.user }\n      let(:group) { group_user.group }\n\n      before do\n        SiteSetting.enable_category_group_moderation = true\n        post.topic.category.update!(reviewable_by_group_id: group.id, topic_id: topic.id)\n        sign_in(user_gm)\n      end\n\n      it \"allows updating the category description\" do\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(200)\n\n        post.reload\n        expect(post.raw).to eq('edited body')\n        expect(UserHistory.where(action: UserHistory.actions[:post_edit]).count).to eq(1)\n      end\n\n      it \"can not update category descriptions in other categories\" do\n        second_category = Fabricate(:category)\n        topic.update!(category: second_category)\n\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(403)\n      end\n\n    end\n\n    it 'can not change category to a disallowed category' do\n      post = create_post\n      sign_in(post.user)\n\n      category = Fabricate(:category)\n      category.set_permissions(staff: :full)\n      category.save!\n\n      put \"/posts/#{post.id}.json\", params: {\n        post: { category_id: category.id, raw: \"this is a test edit to post\" }\n      }\n\n      expect(response.status).not_to eq(200)\n      expect(post.topic.category_id).not_to eq(category.id)\n    end\n\n    it 'can not move to a category that requires topic approval' do\n      post = create_post\n      sign_in(post.user)\n\n      category = Fabricate(:category)\n      category.custom_fields[Category::REQUIRE_TOPIC_APPROVAL] = true\n      category.save!\n\n      put \"/posts/#{post.id}.json\", params: { post: { category_id: category.id, raw: \"this is a test edit to post\" } }\n\n      expect(response.status).to eq(403)\n      expect(post.topic.reload.category_id).not_to eq(category.id)\n    end\n\n    describe \"with Post.plugin_permitted_update_params\" do\n      before do\n        plugin = Plugin::Instance.new\n        plugin.add_permitted_post_update_param(:random_number) do |post, value|\n          post.custom_fields[:random_number] = value\n          post.save\n        end\n      end\n\n      after do\n        DiscoursePluginRegistry.reset!\n      end\n\n      it \"calls blocks passed into `add_permitted_post_update_param`\" do\n        sign_in(post.user)\n        put \"/posts/#{post.id}.json\", params: {\n          post: {\n            raw: \"this is a random post\",\n            raw_old: post.raw,\n            random_number: 244\n          }\n        }\n\n        expect(response.status).to eq(200)\n        expect(post.reload.custom_fields[:random_number]).to eq(\"244\")\n      end\n    end\n  end\n\n  describe \"#destroy_bookmark\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:bookmark) { Fabricate(:bookmark, user: user, bookmarkable: post) }\n\n    before do\n      sign_in(user)\n    end\n\n    it \"deletes the bookmark\" do\n      bookmark_id = bookmark.id\n      delete \"/posts/#{post.id}/bookmark.json\"\n      expect(Bookmark.find_by(id: bookmark_id)).to eq(nil)\n    end\n\n    context \"when the user still has bookmarks in the topic\" do\n      before do\n        Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post, topic: post.topic))\n      end\n      it \"marks topic_bookmarked as true\" do\n        delete \"/posts/#{post.id}/bookmark.json\"\n        expect(response.parsed_body['topic_bookmarked']).to eq(true)\n      end\n    end\n  end\n\n  describe '#wiki' do\n    include_examples \"action requires login\", :put, \"/posts/2/wiki.json\"\n\n    describe \"when logged in\" do\n      before do\n        sign_in(user)\n      end\n\n      let!(:post) { post_by_user }\n\n      it \"returns 400 when wiki parameter is not present\" do\n        sign_in(admin)\n\n        put \"/posts/#{post.id}/wiki.json\", params: {}\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error if the user doesn't have permission to wiki the post\" do\n        put \"/posts/#{post.id}/wiki.json\", params: { wiki: 'true' }\n        expect(response).to be_forbidden\n      end\n\n      it \"toggle wiki status should create a new version\" do\n        sign_in(admin)\n        another_user = Fabricate(:user)\n        another_post = Fabricate(:post, user: another_user)\n\n        expect do\n          put \"/posts/#{another_post.id}/wiki.json\", params: { wiki: 'true' }\n        end.to change { another_post.reload.version }.by(1)\n\n        expect do\n          put \"/posts/#{another_post.id}/wiki.json\", params: { wiki: 'false' }\n        end.to change { another_post.reload.version }.by(-1)\n\n        sign_in(Fabricate(:admin))\n\n        expect do\n          put \"/posts/#{another_post.id}/wiki.json\", params: { wiki: 'true' }\n        end.to change { another_post.reload.version }.by(1)\n      end\n\n      it \"can wiki a post\" do\n        sign_in(admin)\n        put \"/posts/#{post.id}/wiki.json\", params: { wiki: 'true' }\n\n        post.reload\n        expect(post.wiki).to eq(true)\n      end\n\n      it \"can unwiki a post\" do\n        wikied_post = Fabricate(:post, user: user, wiki: true)\n        sign_in(admin)\n\n        put \"/posts/#{wikied_post.id}/wiki.json\", params: { wiki: 'false' }\n\n        wikied_post.reload\n        expect(wikied_post.wiki).to eq(false)\n      end\n    end\n  end\n\n  describe '#post_type' do\n    include_examples \"action requires login\", :put, \"/posts/2/post_type.json\"\n\n    describe \"when logged in\" do\n      before do\n        sign_in(moderator)\n      end\n\n      let!(:post) { post_by_user }\n\n      it \"raises an error if the user doesn't have permission to change the post type\" do\n        sign_in(user)\n\n        put \"/posts/#{post.id}/post_type.json\", params: { post_type: 2 }\n        expect(response).to be_forbidden\n      end\n\n      it \"returns 400 if post_type parameter is not present\" do\n        put \"/posts/#{post.id}/post_type.json\", params: {}\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"returns 400 if post_type parameters is invalid\" do\n        put \"/posts/#{post.id}/post_type.json\", params: { post_type: -1 }\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"can change the post type\" do\n        put \"/posts/#{post.id}/post_type.json\", params: { post_type: 2 }\n\n        post.reload\n        expect(post.post_type).to eq(2)\n      end\n    end\n  end\n\n  describe '#rebake' do\n    include_examples \"action requires login\", :put, \"/posts/2/rebake.json\"\n\n    describe \"when logged in\" do\n      let!(:post) { post_by_user }\n\n      it \"raises an error if the user doesn't have permission to rebake the post\" do\n        sign_in(user)\n        put \"/posts/#{post.id}/rebake.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"can rebake the post\" do\n        sign_in(moderator)\n        put \"/posts/#{post.id}/rebake.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"will invalidate broken images cache\" do\n        sign_in(moderator)\n        PostHotlinkedMedia.create!(url: \"https://example.com/image.jpg\", post: post, status: 'download_failed')\n        put \"/posts/#{post.id}/rebake.json\"\n        post.reload\n        expect(post.post_hotlinked_media).to eq([])\n      end\n    end\n  end\n\n  describe '#create' do\n    include_examples 'action requires login', :post, \"/posts.json\"\n\n    before do\n      SiteSetting.min_first_post_typing_time = 0\n      SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n    end\n\n    context 'with api' do\n      it 'memoizes duplicate requests' do\n        raw = \"this is a test post 123 #{SecureRandom.hash}\"\n        title = \"this is a title #{SecureRandom.hash}\"\n\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { raw: raw, title: title, wpid: 1 },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        original = response.body\n\n        post \"/posts.json\",\n          params: { raw: raw, title: title, wpid: 2 },\n          headers: { HTTP_API_USERNAME: user.username_lower, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(response.body).to eq(original)\n      end\n\n      it 'allows to create posts in import_mode' do\n        Jobs.run_immediately!\n        NotificationEmailer.enable\n        post_1 = Fabricate(:post)\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { raw: 'this is test reply 1', topic_id: post_1.topic.id, reply_to_post_number: 1 },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(post_1.topic.user.notifications.count).to eq(1)\n        post_1.topic.user.notifications.destroy_all\n\n        post \"/posts.json\",\n          params: { raw: 'this is test reply 2', topic_id: post_1.topic.id, reply_to_post_number: 1, import_mode: true },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(post_1.topic.user.notifications.count).to eq(0)\n\n        post \"/posts.json\",\n          params: { raw: 'this is test reply 3', topic_id: post_1.topic.id, reply_to_post_number: 1, import_mode: false },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(post_1.topic.user.notifications.count).to eq(1)\n      end\n\n      it 'allows a topic to be created with an external_id' do\n        master_key = Fabricate(:api_key).key\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: \"this is some post\",\n          external_id: 'external_id'\n        }, headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n\n        new_topic = Topic.last\n\n        expect(new_topic.external_id).to eq('external_id')\n      end\n\n      it 'prevents whispers for regular users' do\n        post_1 = Fabricate(:post)\n        user_key = ApiKey.create!(user: user).key\n\n        post \"/posts.json\",\n          params: { raw: 'this is test whisper', topic_id: post_1.topic.id, reply_to_post_number: 1, whisper: true },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'does not advance draft' do\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test\")\n        user_key = ApiKey.create!(user: user).key\n\n        post \"/posts.json\",\n          params: { title: 'this is a test topic', raw: 'this is test whisper' },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }\n\n        expect(response.status).to eq(200)\n        expect(Draft.get(user, Draft::NEW_TOPIC, 0)).to eq(\"test\")\n      end\n\n      it 'will raise an error if specified category cannot be found' do\n        user = Fabricate(:admin)\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { title: 'this is a test title', raw: 'this is test body', category: 'invalid' },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(400)\n\n        expect(response.parsed_body[\"errors\"]).to include(\n          I18n.t(\"invalid_params\", message: \"category\")\n        )\n      end\n\n      it 'will raise an error if specified embed_url is invalid' do\n        user = Fabricate(:admin)\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { title: 'this is a test title', raw: 'this is test body', embed_url: '/test.txt' },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"creates unlisted topic with admin master key\" do\n        master_key = Fabricate(:api_key).key\n\n        expect do\n          post \"/posts.json\",\n            params: { raw: \"this is a test title\", title: \"this is test body\", unlist_topic: true },\n            headers: { HTTP_API_USERNAME: admin.username, HTTP_API_KEY: master_key }\n        end.to change { Topic.count }.by(1)\n\n        expect(response.status).to eq(200)\n        expect(Topic.find(response.parsed_body[\"topic_id\"]).visible).to eq(false)\n      end\n\n      it \"prevents creation of unlisted topic with non-admin key\" do\n        user_key = ApiKey.create!(user: user).key\n\n        expect do\n          post \"/posts.json\",\n            params: { raw: \"this is a test title\", title: \"this is test body\", unlist_topic: true },\n            headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }\n        end.not_to change { Topic.count }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to include(\n          I18n.t(\"activerecord.errors.models.topic.attributes.base.unable_to_unlist\")\n        )\n      end\n    end\n\n    describe \"when logged in\" do\n      fab!(:user) { Fabricate(:user) }\n\n      before do\n        sign_in(user)\n      end\n\n      context \"when fast typing\" do\n        before do\n          SiteSetting.min_first_post_typing_time = 3000\n          SiteSetting.auto_silence_fast_typers_max_trust_level = 1\n        end\n\n        it 'queues the post if min_first_post_typing_time is not met' do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            composer_open_duration_msecs: 204,\n            typing_duration_msecs: 100,\n            reply_to_post_number: 123\n          }\n\n          expect(response.status).to eq(200)\n          parsed = response.parsed_body\n\n          expect(parsed[\"action\"]).to eq(\"enqueued\")\n\n          user.reload\n          expect(user).to be_silenced\n\n          rp = ReviewableQueuedPost.find_by(created_by: user)\n          expect(rp.payload['typing_duration_msecs']).to eq(100)\n          expect(rp.payload['composer_open_duration_msecs']).to eq(204)\n          expect(rp.payload['reply_to_post_number']).to eq(123)\n          expect(rp.reviewable_scores.first.reason).to eq('fast_typer')\n\n          expect(parsed['pending_post']).to be_present\n          expect(parsed['pending_post']['id']).to eq(rp.id)\n          expect(parsed['pending_post']['raw']).to eq(\"this is the test content\")\n\n          mod = moderator\n          rp.perform(mod, :approve_post)\n\n          user.reload\n          expect(user).not_to be_silenced\n        end\n\n        it \"doesn't enqueue posts when user first creates a topic\" do\n          topic = Fabricate(:post, user: user).topic\n\n          Draft.set(user, \"should_clear\", 0, \"{'a' : 'b'}\")\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            composer_open_duration_msecs: 204,\n            typing_duration_msecs: 100,\n            topic_id: topic.id,\n            draft_key: \"should_clear\"\n          }\n\n          expect(response.status).to eq(200)\n          parsed = response.parsed_body\n\n          expect(parsed[\"action\"]).not_to be_present\n\n          expect {\n            Draft.get(user, \"should_clear\", 0)\n          }.to raise_error(Draft::OutOfSequence)\n        end\n\n        it \"doesn't enqueue replies when the topic is closed\" do\n          topic = Fabricate(:closed_topic)\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            topic_id: topic.id\n          }\n\n          expect(response).not_to be_successful\n          parsed = response.parsed_body\n          expect(parsed[\"action\"]).not_to eq(\"enqueued\")\n        end\n\n        it \"doesn't enqueue replies when the post is too long\" do\n          SiteSetting.max_post_length = 10\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic'\n          }\n\n          expect(response).not_to be_successful\n          parsed = response.parsed_body\n          expect(parsed[\"action\"]).not_to eq(\"enqueued\")\n        end\n      end\n\n      it 'silences correctly based on auto_silence_first_post_regex' do\n        SiteSetting.auto_silence_first_post_regex = \"I love candy|i eat s[1-5]\"\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'when I eat s3 sometimes when not looking'\n        }\n\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body\n\n        expect(parsed[\"action\"]).to eq(\"enqueued\")\n        reviewable = ReviewableQueuedPost.find_by(created_by: user)\n        score = reviewable.reviewable_scores.first\n        expect(score.reason).to eq('auto_silence_regex')\n\n        user.reload\n        expect(user).to be_silenced\n      end\n\n      it 'silences correctly based on silence watched words' do\n        SiteSetting.watched_words_regular_expressions = true\n        WatchedWord.create!(action: WatchedWord.actions[:silence], word: 'I love candy')\n        WatchedWord.create!(action: WatchedWord.actions[:silence], word: 'i eat s[1-5]')\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'when I eat s3 sometimes when not looking'\n        }\n\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body\n\n        expect(parsed[\"action\"]).to eq(\"enqueued\")\n        reviewable = ReviewableQueuedPost.find_by(created_by: user)\n        score = reviewable.reviewable_scores.first\n        expect(score.reason).to eq('auto_silence_regex')\n\n        user.reload\n        expect(user).to be_silenced\n      end\n\n      it \"can send a message to a group\" do\n        Group.refresh_automatic_groups!\n        group = Group.create(name: 'test_group', messageable_level: Group::ALIAS_LEVELS[:nobody])\n        user1 = user\n        group.add(user1)\n\n        post \"/posts.json\", params: {\n          raw: 'I can haz a test',\n          title: 'I loves my test',\n          target_recipients: group.name,\n          archetype: Archetype.private_message\n        }\n\n        expect(response).not_to be_successful\n\n        # allow pm to this group\n        group.update_columns(messageable_level: Group::ALIAS_LEVELS[:everyone])\n\n        post \"/posts.json\", params: {\n          raw: 'I can haz a test',\n          title: 'I loves my test',\n          target_recipients: \"test_Group\",\n          archetype: Archetype.private_message\n        }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n        post = Post.find(parsed['id'])\n\n        expect(post.topic.topic_allowed_users.length).to eq(1)\n        expect(post.topic.topic_allowed_groups.length).to eq(1)\n      end\n\n      it \"can send a message to a group with caps\" do\n        Group.refresh_automatic_groups!\n        group = Group.create(name: 'Test_group', messageable_level: Group::ALIAS_LEVELS[:nobody])\n        user1 = user\n        group.add(user1)\n\n        # allow pm to this group\n        group.update_columns(messageable_level: Group::ALIAS_LEVELS[:everyone])\n\n        post \"/posts.json\", params: {\n          raw: 'I can haz a test',\n          title: 'I loves my test',\n          target_recipients: \"test_Group\",\n          archetype: Archetype.private_message\n        }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n        post = Post.find(parsed['id'])\n\n        expect(post.topic.topic_allowed_users.length).to eq(1)\n        expect(post.topic.topic_allowed_groups.length).to eq(1)\n      end\n\n      it \"returns the nested post with a param\" do\n        post \"/posts.json\", params: {\n          raw: 'this is the test content  ',\n          title: 'this is the test title for the topic',\n          nested_post: true\n        }\n\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body\n        expect(parsed['post']).to be_present\n        expect(parsed['post']['raw']).to eq('this is the test content')\n        expect(parsed['post']['cooked']).to be_present\n      end\n\n      it 'protects against dupes' do\n        raw = \"this is a test post 123 #{SecureRandom.hash}\"\n        title = \"this is a title #{SecureRandom.hash}\"\n\n        expect do\n          post \"/posts.json\", params: { raw: raw, title: title, wpid: 1 }\n        end.to change { Post.count }\n\n        expect(response.status).to eq(200)\n\n        expect do\n          post \"/posts.json\", params: { raw: raw, title: title, wpid: 2 }\n        end.to_not change { Post.count }\n\n        expect(response.status).to eq(422)\n      end\n\n      it 'cannot create a post in a disallowed category' do\n        category.set_permissions(staff: :full)\n        category.save!\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          category: category.id,\n          meta_data: { xyz: 'abc' }\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'cannot create a post with a tag that is restricted' do\n        SiteSetting.tagging_enabled = true\n        tag = Fabricate(:tag)\n        category.allowed_tags = [tag.name]\n        category.save!\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(422)\n        json = response.parsed_body\n        expect(json['errors']).to be_present\n      end\n\n      it 'cannot create a post with a tag when tagging is disabled' do\n        SiteSetting.tagging_enabled = false\n        tag = Fabricate(:tag)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(422)\n        json = response.parsed_body\n        expect(json['errors']).to be_present\n      end\n\n      it 'cannot create a post with a tag without tagging permission' do\n        SiteSetting.tagging_enabled = true\n        SiteSetting.min_trust_level_to_tag_topics = 4\n        tag = Fabricate(:tag)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(422)\n        json = response.parsed_body\n        expect(json['errors']).to be_present\n      end\n\n      it 'can create a post with a tag when tagging is enabled' do\n        SiteSetting.tagging_enabled = true\n        tag = Fabricate(:tag)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(200)\n        expect(Post.last.topic.tags.count).to eq(1)\n      end\n\n      it 'creates the post' do\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          category: category.id,\n          meta_data: { xyz: 'abc' }\n        }\n\n        expect(response.status).to eq(200)\n\n        new_post = Post.last\n        topic = new_post.topic\n\n        expect(new_post.user).to eq(user)\n        expect(new_post.raw).to eq('this is the test content')\n        expect(topic.title).to eq('This is the test title for the topic')\n        expect(topic.category).to eq(category)\n        expect(topic.meta_data).to eq(\"xyz\" => 'abc')\n        expect(topic.visible).to eq(true)\n      end\n\n      it 'can create an uncategorized topic' do\n        title = 'this is the test title for the topic'\n\n        expect do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: title,\n            category: \"\"\n          }\n\n          expect(response.status).to eq(200)\n        end.to change { Topic.count }.by(1)\n\n        topic = Topic.last\n\n        expect(topic.title).to eq(title.capitalize)\n        expect(topic.category_id).to eq(SiteSetting.uncategorized_category_id)\n      end\n\n      it 'can create a reply to a post' do\n        topic = Fabricate(:private_message_post, user: user).topic\n        post_2 = Fabricate(:private_message_post, user: user, topic: topic)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          topic_id: topic.id,\n          reply_to_post_number: post_2.post_number,\n          image_sizes: { width: '100', height: '200' }\n        }\n\n        expect(response.status).to eq(200)\n\n        new_post = Post.last\n        topic = new_post.topic\n\n        expect(new_post.user).to eq(user)\n        expect(new_post.raw).to eq('this is the test content')\n        expect(new_post.reply_to_post_number).to eq(post_2.post_number)\n\n        job_args = Jobs::ProcessPost.jobs.first[\"args\"].first\n\n        expect(job_args[\"image_sizes\"]).to eq(\"width\" => '100', \"height\" => '200')\n      end\n\n      it 'creates a private post' do\n        user_2 = Fabricate(:user)\n        user_3 = Fabricate(:user, username: \"foo_bar\")\n\n        # In certain edge cases, it's possible to end up with a username\n        # containing characters that would normally fail to validate\n        user_4 = Fabricate(:user, username: \"Iyi_Iyi\")\n        user_4.update_attribute(:username, \"\u0130yi_\u0130yi\")\n        user_4.update_attribute(:username_lower, \"\u0130yi_\u0130yi\".downcase)\n        Group.refresh_automatic_groups!\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          archetype: 'private_message',\n          title: \"this is some post\",\n          target_recipients: \"#{user_2.username},Foo_Bar,\u0130yi_\u0130yi\"\n        }\n\n        expect(response.status).to eq(200)\n\n        new_post = Post.last\n        new_topic = Topic.last\n\n        expect(new_post.user).to eq(user)\n        expect(new_topic.private_message?).to eq(true)\n        expect(new_topic.allowed_users).to contain_exactly(user, user_2, user_3, user_4)\n      end\n\n      context \"when target_recipients not provided\" do\n        it \"errors when creating a private post\" do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: \"\"\n          }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to include(\n            I18n.t(\"activerecord.errors.models.topic.attributes.base.no_user_selected\")\n          )\n        end\n      end\n\n      context \"when topic_id is set\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        it \"errors when creating a private post\" do\n          user_2 = Fabricate(:user)\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            topic_id: topic.id\n          }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to include(\n            I18n.t(\"create_pm_on_existing_topic\")\n          )\n        end\n      end\n\n      context \"with errors\" do\n        it \"does not succeed\" do\n          post \"/posts.json\", params: { raw: 'test' }\n          expect(response).not_to be_successful\n          expect(response.status).to eq(422)\n        end\n\n        it \"it triggers flag_linked_posts_as_spam when the post creator returns spam\" do\n          SiteSetting.newuser_spam_host_threshold = 1\n          sign_in(Fabricate(:user, trust_level: 0))\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content http://fakespamwebsite.com http://fakespamwebsite.com/spam http://fakespamwebsite.com/spammy',\n            title: 'this is the test title for the topic',\n            meta_data: { xyz: 'abc' }\n          }\n\n          expect(response.parsed_body[\"errors\"]).to include(I18n.t(:spamming_host))\n        end\n\n        context \"when allow_uncategorized_topics is false\" do\n          before do\n            SiteSetting.allow_uncategorized_topics = false\n          end\n\n          it \"cant create an uncategorized post\" do\n            post \"/posts.json\", params: {\n              raw: \"a new post with no category\",\n              title: \"a new post with no category\"\n            }\n            expect(response).not_to be_successful\n          end\n\n          context \"as staff\" do\n            before do\n              sign_in(admin)\n            end\n\n            it \"cant create an uncategorized post\" do\n              post \"/posts.json\", params: {\n                raw: \"a new post with no category\",\n                title: \"a new post with no category\"\n              }\n              expect(response).not_to be_successful\n            end\n          end\n        end\n      end\n\n      context \"with mentions\" do\n        fab!(:user_to_mention) { Fabricate(:user) }\n\n        it \"returns mentioned users\" do\n          post \"/posts.json\", params: {\n            raw: \"I am mentioning @#{user_to_mention.username}\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"mentioned_users\"].length).to be(1)\n\n          mentioned_user = json[\"mentioned_users\"][0]\n          expect(mentioned_user[\"id\"]).to be(user_to_mention.id)\n          expect(mentioned_user[\"name\"]).to eq(user_to_mention.name)\n          expect(mentioned_user[\"username\"]).to eq(user_to_mention.username)\n        end\n\n        it \"returns an empty list of mentioned users if nobody was mentioned\" do\n          post \"/posts.json\", params: {\n            raw: \"No mentions here\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"mentioned_users\"].length).to be(0)\n        end\n\n        it \"returns an empty list of mentioned users if an nonexistent user was mentioned\" do\n          post \"/posts.json\", params: {\n            raw: \"Mentioning a @stranger\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"mentioned_users\"].length).to be(0)\n        end\n\n        it \"doesn't return user status on mentions by default\" do\n          user_to_mention.set_status!(\"off to dentist\", \"tooth\")\n\n          post \"/posts.json\", params: {\n            raw: \"I am mentioning @#{user_to_mention.username}\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"mentioned_users\"].length).to be(1)\n\n          status = json[\"mentioned_users\"][0][\"status\"]\n          expect(status).to be_nil\n        end\n\n        it \"returns user status on mentions if status is enabled in site settings\" do\n          SiteSetting.enable_user_status = true\n          user_to_mention.set_status!(\"off to dentist\", \"tooth\")\n\n          post \"/posts.json\", params: {\n            raw: \"I am mentioning @#{user_to_mention.username}\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"mentioned_users\"].length).to be(1)\n\n          status = json[\"mentioned_users\"][0][\"status\"]\n          expect(status).to be_present\n          expect(status[\"emoji\"]).to eq(user_to_mention.user_status.emoji)\n          expect(status[\"description\"]).to eq(user_to_mention.user_status.description)\n        end\n      end\n    end\n\n    context \"with topic unlisting\" do\n      context \"when logged in as staff\" do\n        before do\n          sign_in(admin)\n        end\n\n        it \"creates an unlisted topic\" do\n          expect do\n            post \"/posts.json\", params: {\n              raw: \"this is the test content\",\n              title: \"this is the test title for the topic\",\n              unlist_topic: true\n            }\n          end.to change { Topic.count }.by(1)\n\n          expect(response.status).to eq(200)\n          expect(Topic.find(response.parsed_body[\"topic_id\"]).visible).to eq(false)\n        end\n      end\n\n      context \"when logged in as a non-staff user\" do\n        before do\n          sign_in(user)\n        end\n\n        it \"prevents creation of an unlisted topic\" do\n          expect do\n            post \"/posts.json\", params: {\n              raw: \"this is the test content\",\n              title: \"this is the test title for the topic\",\n              unlist_topic: true\n            }\n          end.not_to change { Topic.count }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to include(\n            I18n.t(\"activerecord.errors.models.topic.attributes.base.unable_to_unlist\")\n          )\n        end\n      end\n    end\n\n    describe 'shared draft' do\n      fab!(:destination_category) { Fabricate(:category) }\n\n      it \"will raise an error for regular users\" do\n        post \"/posts.json\", params: {\n          raw: 'this is the shared draft content',\n          title: \"this is the shared draft title\",\n          category: destination_category.id,\n          shared_draft: 'true'\n        }\n        expect(response).not_to be_successful\n      end\n\n      describe \"as a staff user\" do\n        before do\n          sign_in(moderator)\n        end\n\n        it \"will raise an error if there is no shared draft category\" do\n          post \"/posts.json\", params: {\n            raw: 'this is the shared draft content',\n            title: \"this is the shared draft title\",\n            category: destination_category.id,\n            shared_draft: 'true'\n          }\n          expect(response).not_to be_successful\n        end\n\n        context \"with a shared category\" do\n          fab!(:shared_category) { Fabricate(:category) }\n          before do\n            SiteSetting.shared_drafts_category = shared_category.id\n          end\n\n          it \"will work if the shared draft category is present\" do\n            post \"/posts.json\", params: {\n              raw: 'this is the shared draft content',\n              title: \"this is the shared draft title\",\n              category: destination_category.id,\n              shared_draft: 'true'\n            }\n            expect(response.status).to eq(200)\n            result = response.parsed_body\n            topic = Topic.find(result['topic_id'])\n            expect(topic.category_id).to eq(shared_category.id)\n            expect(topic.shared_draft.category_id).to eq(destination_category.id)\n          end\n        end\n      end\n    end\n\n    describe 'warnings' do\n      fab!(:user_2) { Fabricate(:user) }\n\n      before do\n        Group.refresh_automatic_groups!\n      end\n\n      context 'as a staff user' do\n        before do\n          sign_in(admin)\n        end\n\n        it 'should be able to mark a topic as warning' do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            is_warning: true\n          }\n\n          expect(response.status).to eq(200)\n\n          new_topic = Topic.last\n\n          expect(new_topic.title).to eq('This is some post')\n          expect(new_topic.is_official_warning?).to eq(true)\n        end\n\n        it 'should be able to mark a topic as not a warning' do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            is_warning: false\n          }\n\n          expect(response.status).to eq(200)\n\n          new_topic = Topic.last\n\n          expect(new_topic.title).to eq('This is some post')\n          expect(new_topic.is_official_warning?).to eq(false)\n        end\n      end\n\n      context 'as a normal user' do\n        it 'should not be able to mark a topic as warning' do\n          sign_in(user)\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            is_warning: true\n          }\n\n          expect(response.status).to eq(200)\n\n          new_topic = Topic.last\n\n          expect(new_topic.title).to eq('This is some post')\n          expect(new_topic.is_official_warning?).to eq(false)\n        end\n      end\n    end\n\n    context \"with topic bump\" do\n      shared_examples \"it works\" do\n        it \"should be able to skip topic bumping\" do\n          original_bumped_at = 1.day.ago\n          topic = Fabricate(:topic, bumped_at: original_bumped_at)\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            topic_id: topic.id,\n            no_bump: true\n          }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.bumped_at).to eq_time(original_bumped_at)\n        end\n\n        it \"should be able to post with topic bumping\" do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            topic_id: topic.id\n          }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.bumped_at).to eq_time(topic.posts.last.created_at)\n        end\n      end\n\n      context \"with admins\" do\n        before do\n          sign_in(admin)\n        end\n\n        include_examples \"it works\"\n      end\n\n      context \"with moderators\" do\n        before do\n          sign_in(moderator)\n        end\n\n        include_examples \"it works\"\n      end\n\n      context \"with TL4 users\" do\n        fab!(:trust_level_4) { Fabricate(:trust_level_4) }\n\n        before do\n          sign_in(trust_level_4)\n        end\n\n        include_examples \"it works\"\n      end\n\n      context \"with users\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        [:user].each do |user|\n          it \"will raise an error for #{user}\" do\n            sign_in(Fabricate(user))\n            post \"/posts.json\", params: {\n              raw: 'this is the test content',\n              topic_id: topic.id,\n              no_bump: true\n            }\n            expect(response.status).to eq(400)\n          end\n        end\n      end\n    end\n\n    context \"with featured links\" do\n      it \"allows to create topics with featured links\" do\n        sign_in(user_trust_level_1)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\"\n        }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"doesn't allow TL0 users to create topics with featured links\" do\n        sign_in(user_trust_level_0)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to create topics with featured links if featured links are disabled in settings\" do\n        SiteSetting.topic_featured_link_enabled = false\n        sign_in(user_trust_level_1)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to create topics with featured links in the category with forbidden feature links\" do\n        category = Fabricate(:category, topic_featured_link_allowed: false)\n        sign_in(user_trust_level_1)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\",\n          category: category.id\n        }\n\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  describe '#revisions' do\n    fab!(:post) { Fabricate(:post, version: 2) }\n    let(:post_revision) { Fabricate(:post_revision, post: post) }\n\n    it \"throws an exception when revision is < 2\" do\n      get \"/posts/#{post.id}/revisions/1.json\"\n      expect(response.status).to eq(400)\n    end\n\n    context \"when edit history is not visible to the public\" do\n\n      before { SiteSetting.edit_history_visible_to_public = false }\n\n      it \"ensures anonymous cannot see the revisions\" do\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"ensures regular user cannot see the revisions\" do\n        sign_in(user)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"ensures staff can see the revisions\" do\n        sign_in(admin)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"ensures poster can see the revisions\" do\n        user = Fabricate(:active_user)\n        sign_in(user)\n\n        post = Fabricate(:post, user: user, version: 3)\n        pr = Fabricate(:post_revision, user: user, post: post)\n\n        get \"/posts/#{pr.post_id}/revisions/#{pr.number}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"ensures trust level 4 cannot see the revisions\" do\n        sign_in(Fabricate(:user, trust_level: 4))\n        get \"/posts/#{post_revision.post_id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when post is hidden\" do\n      before {\n        post.hidden = true\n        post.save\n      }\n\n      it \"throws an exception for users\" do\n        sign_in(user)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"works for admins\" do\n        sign_in(admin)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"when edit history is visible to everyone\" do\n\n      before { SiteSetting.edit_history_visible_to_public = true }\n\n      it \"ensures anyone can see the revisions\" do\n        get \"/posts/#{post_revision.post_id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with deleted post\" do\n      fab!(:deleted_post) { Fabricate(:post, user: admin, version: 3) }\n      fab!(:deleted_post_revision) { Fabricate(:post_revision, user: admin, post: deleted_post) }\n\n      before { deleted_post.trash!(admin) }\n\n      it \"also work on deleted post\" do\n        sign_in(admin)\n        get \"/posts/#{deleted_post_revision.post_id}/revisions/#{deleted_post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with deleted topic\" do\n      fab!(:deleted_topic) { Fabricate(:topic, user: admin) }\n      fab!(:post) { Fabricate(:post, user: admin, topic: deleted_topic, version: 3) }\n      fab!(:post_revision) { Fabricate(:post_revision, user: admin, post: post) }\n\n      before { deleted_topic.trash!(admin) }\n\n      it \"also work on deleted topic\" do\n        sign_in(admin)\n        get \"/posts/#{post_revision.post_id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with a tagged topic\" do\n      let(:tag) { Fabricate(:tag) }\n      it \"works\" do\n        SiteSetting.tagging_enabled = true\n\n        post_revision.post.topic.update(tags: [tag])\n\n        get \"/posts/#{post_revision.post_id}/revisions/latest.json\"\n        expect(response.status).to eq(200)\n\n        SiteSetting.tagging_enabled = false\n\n        get \"/posts/#{post_revision.post_id}/revisions/latest.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#revert' do\n    include_examples 'action requires login', :put, \"/posts/123/revisions/2/revert.json\"\n\n    fab!(:post) { Fabricate(:post, user: Fabricate(:user), raw: \"Lorem ipsum dolor sit amet, cu nam libris tractatos, ancillae senserit ius ex\") }\n    let(:post_revision) { Fabricate(:post_revision, post: post, modifications: { \"raw\" => [\"this is original post body.\", \"this is edited post body.\"] }) }\n    let(:blank_post_revision) { Fabricate(:post_revision, post: post, modifications: { \"edit_reason\" => [\"edit reason #1\", \"edit reason #2\"] }) }\n    let(:same_post_revision) { Fabricate(:post_revision, post: post, modifications: { \"raw\" => [\"Lorem ipsum dolor sit amet, cu nam libris tractatos, ancillae senserit ius ex\", \"this is edited post body.\"] }) }\n\n    let(:post_id) { post.id }\n    let(:revision_id) { post_revision.number }\n\n    describe 'when logged in as a regular user' do\n      it \"does not work\" do\n        sign_in(user)\n        put \"/posts/#{post_id}/revisions/#{revision_id}/revert.json\"\n        expect(response).to_not be_successful\n      end\n    end\n\n    describe \"when logged in as staff\" do\n      before do\n        sign_in(moderator)\n      end\n\n      it \"fails when revision is < 2\" do\n        put \"/posts/#{post_id}/revisions/1/revert.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"fails when post_revision record is not found\" do\n        put \"/posts/#{post_id}/revisions/#{revision_id + 1}/revert.json\"\n        expect(response).to_not be_successful\n      end\n\n      it \"fails when post record is not found\" do\n        put \"/posts/#{post_id + 1}/revisions/#{revision_id}/revert.json\"\n        expect(response).to_not be_successful\n      end\n\n      it \"fails when revision is blank\" do\n        put \"/posts/#{post_id}/revisions/#{blank_post_revision.number}/revert.json\"\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('revert_version_same'))\n      end\n\n      it \"fails when revised version is same as current version\" do\n        put \"/posts/#{post_id}/revisions/#{same_post_revision.number}/revert.json\"\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('revert_version_same'))\n      end\n\n      it \"works!\" do\n        put \"/posts/#{post_id}/revisions/#{revision_id}/revert.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"supports reverting posts in deleted topics\" do\n        first_post = post.topic.ordered_posts.first\n        PostDestroyer.new(moderator, first_post).destroy\n\n        put \"/posts/#{post_id}/revisions/#{revision_id}/revert.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#expand_embed' do\n    before do\n      sign_in(user)\n    end\n\n    fab!(:post) { Fabricate(:post) }\n\n    it \"raises an error when you can't see the post\" do\n      post = Fabricate(:private_message_post)\n      get \"/posts/#{post.id}/expand-embed.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"retrieves the body when you can see the post\" do\n      TopicEmbed.expects(:expanded_for).with(post).returns(\"full content\")\n      get \"/posts/#{post.id}/expand-embed.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['cooked']).to eq(\"full content\")\n    end\n  end\n\n  describe '#flagged_posts' do\n    include_examples \"action requires login\", :get, \"/posts/system/flagged.json\"\n\n    describe \"when logged in\" do\n      it \"raises an error if the user doesn't have permission to see the flagged posts\" do\n        sign_in(user)\n        get \"/posts/system/flagged.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"can see the flagged posts when authorized\" do\n        sign_in(moderator)\n        get \"/posts/system/flagged.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"only shows agreed and deferred flags\" do\n        post_agreed = create_post(user: user)\n        post_deferred = create_post(user: user)\n        post_disagreed = create_post(user: user)\n\n        r0 = PostActionCreator.spam(moderator, post_agreed).reviewable\n        r1 = PostActionCreator.off_topic(moderator, post_deferred).reviewable\n        r2 = PostActionCreator.inappropriate(moderator, post_disagreed).reviewable\n\n        r0.perform(admin, :agree_and_keep)\n        r1.perform(admin, :ignore)\n        r2.perform(admin, :disagree)\n\n        sign_in(Fabricate(:moderator))\n        get \"/posts/#{user.username}/flagged.json\"\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body.length).to eq(2)\n      end\n    end\n  end\n\n  describe '#deleted_posts' do\n    include_examples \"action requires login\", :get, \"/posts/system/deleted.json\"\n\n    describe \"when logged in\" do\n      before do\n        Group.refresh_automatic_groups!\n      end\n\n      it \"raises an error if the user doesn't have permission to see the deleted posts\" do\n        sign_in(user)\n        get \"/posts/system/deleted.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"can see the deleted posts when authorized\" do\n        sign_in(moderator)\n        get \"/posts/system/deleted.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"does not raise if topic has been permanently deleted\" do\n        post = Fabricate(:post, user: admin)\n        PostDestroyer.new(admin, post).destroy\n        post.update!(topic_id: -1000)\n\n        sign_in(admin)\n        get \"/posts/#{admin.username}/deleted.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"doesn't return secured categories for moderators if they don't have access\" do\n        Fabricate(:moderator)\n\n        group = Fabricate(:group)\n        group.add_owner(user)\n\n        secured_category = Fabricate(:private_category, group: group)\n        secured_post = create_post(user: user, category: secured_category)\n        PostDestroyer.new(admin, secured_post).destroy\n\n        sign_in(moderator)\n        get \"/posts/#{user.username}/deleted.json\"\n        expect(response.status).to eq(200)\n\n        data = response.parsed_body\n        expect(data.length).to eq(0)\n      end\n\n      it \"doesn't return PMs for moderators\" do\n        Fabricate(:moderator)\n\n        pm_post = create_post(user: user, archetype: 'private_message', target_usernames: [admin.username])\n        PostDestroyer.new(admin, pm_post).destroy\n\n        sign_in(moderator)\n        get \"/posts/#{user.username}/deleted.json\"\n        expect(response.status).to eq(200)\n\n        data = response.parsed_body\n        expect(data.length).to eq(0)\n      end\n\n      it \"only shows posts deleted by other users\" do\n        create_post(user: user)\n        post_deleted_by_user = create_post(user: user)\n        post_deleted_by_admin = create_post(user: user)\n\n        PostDestroyer.new(user, post_deleted_by_user).destroy\n        PostDestroyer.new(admin, post_deleted_by_admin).destroy\n\n        sign_in(admin)\n        get \"/posts/#{user.username}/deleted.json\"\n        expect(response.status).to eq(200)\n\n        data = response.parsed_body\n        expect(data.length).to eq(1)\n        expect(data[0][\"id\"]).to eq(post_deleted_by_admin.id)\n        expect(data[0][\"deleted_by\"][\"id\"]).to eq(admin.id)\n      end\n    end\n  end\n\n  describe '#markdown_id' do\n    it \"can be viewed by anonymous\" do\n      post = Fabricate(:post, raw: \"123456789\")\n      get \"/posts/#{post.id}/raw.json\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(\"123456789\")\n    end\n\n    it \"renders a 404 page\" do\n      get \"/posts/0/raw\"\n      expect(response.status).to eq(404)\n      expect(response.body).to include(I18n.t(\"page_not_found.title\"))\n    end\n  end\n\n  describe '#markdown_num' do\n    it \"can be viewed by anonymous\" do\n      topic = Fabricate(:topic)\n      post = Fabricate(:post, topic: topic, post_number: 1, raw: \"123456789\")\n      post.save\n      get \"/raw/#{topic.id}/1.json\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(\"123456789\")\n    end\n\n    it \"can show whole topics\" do\n      topic = Fabricate(:topic)\n      post = Fabricate(:post, topic: topic, post_number: 1, raw: \"123456789\")\n      post_2 = Fabricate(:post, topic: topic, post_number: 2, raw: \"abcdefghij\")\n      post.save\n      get \"/raw/#{topic.id}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to include(\"123456789\", \"abcdefghij\")\n    end\n  end\n\n  describe '#short_link' do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:post) { Fabricate(:post, topic: topic) }\n\n    it \"redirects to the topic\" do\n      get \"/p/#{post.id}.json\"\n      expect(response).to be_redirect\n    end\n\n    it \"returns a 403 when access is denied for JSON format\" do\n      post = Fabricate(:private_message_post)\n      get \"/p/#{post.id}.json\"\n      expect(response).to be_forbidden\n    end\n\n    it \"returns a 403 when access is denied for HTML format\" do\n      post = Fabricate(:private_message_post)\n      get \"/p/#{post.id}\"\n      expect(response).to be_forbidden\n      expect(response.body).to have_tag(\"body.no-ember\")\n    end\n\n    it \"renders a 404 page\" do\n      get \"/p/0\"\n      expect(response.status).to eq(404)\n      expect(response.body).to include(I18n.t(\"page_not_found.title\"))\n    end\n  end\n\n  describe '#user_posts_feed' do\n    it 'returns public posts rss feed' do\n      public_post\n      private_post\n\n      get \"/u/#{user.username}/activity.rss\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to_not include(private_post.url)\n      expect(body).to include(public_post.url)\n    end\n\n    it \"doesn't include posts from hidden topics\" do\n      public_post.topic.update!(visible: false)\n\n      get \"/u/#{user.username}/activity.rss\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n      expect(body).not_to include(public_post.url)\n    end\n\n    it \"excludes small actions\" do\n      small_action = Fabricate(:small_action, user: user)\n\n      get \"/u/#{user.username}/activity.rss\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).not_to include(small_action.canonical_url)\n    end\n\n    it 'returns public posts as JSON' do\n      public_post\n      private_post\n\n      get \"/u/#{user.username}/activity.json\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to_not include(private_post.topic.slug)\n      expect(body).to include(public_post.topic.slug)\n    end\n\n    it \"returns 404 if `hide_profile_and_presence` user option is checked\" do\n      user.user_option.update_columns(hide_profile_and_presence: true)\n\n      get \"/u/#{user.username}/activity.rss\"\n      expect(response.status).to eq(404)\n\n      get \"/u/#{user.username}/activity.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"succeeds when `allow_users_to_hide_profile` is false\" do\n      user.user_option.update_columns(hide_profile_and_presence: true)\n      SiteSetting.allow_users_to_hide_profile = false\n\n      get \"/u/#{user.username}/activity.rss\"\n      expect(response.status).to eq(200)\n\n      get \"/u/#{user.username}/activity.json\"\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe '#latest' do\n    context 'with private posts' do\n      describe 'when not logged in' do\n        it 'should return the right response' do\n          Fabricate(:post)\n\n          get \"/private-posts.rss\"\n\n          expect(response.status).to eq(404)\n\n          expect(response.body).to have_tag(\n            \"input\", with: { value: \"private_posts\" }\n          )\n        end\n      end\n\n      it 'returns private posts rss feed' do\n        sign_in(admin)\n\n        public_post\n        private_post\n        get \"/private-posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        expect(body).to include(private_post.url)\n        expect(body).to_not include(public_post.url)\n      end\n\n      it 'returns private posts for json' do\n        sign_in(admin)\n\n        public_post\n        private_post\n        get \"/private-posts.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        post_ids = json['private_posts'].map { |p| p['id'] }\n\n        expect(post_ids).to include private_post.id\n        expect(post_ids).to_not include public_post.id\n      end\n    end\n\n    context 'with public posts' do\n      it 'returns public posts with topic rss feed' do\n        public_post\n        private_post\n\n        get \"/posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        # we cache in redis, in rare cases this can cause a flaky test\n        PostsHelper.clear_canonical_cache!(public_post)\n\n        expect(body).to include(public_post.canonical_url)\n        expect(body).to_not include(private_post.url)\n      end\n\n      it \"doesn't include posts from hidden topics\" do\n        public_post.topic.update!(visible: false)\n\n        get \"/posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        # we cache in redis, in rare cases this can cause a flaky test\n        PostsHelper.clear_canonical_cache!(public_post)\n\n        expect(body).not_to include(public_post.canonical_url)\n      end\n\n      it \"excludes small actions\" do\n        small_action = Fabricate(:small_action)\n\n        get \"/posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        expect(body).not_to include(small_action.canonical_url)\n      end\n\n      it 'returns public posts with topic for json' do\n        topicless_post.update topic_id: -100\n\n        public_post\n        private_post\n        topicless_post\n\n        get \"/posts.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        post_ids = json['latest_posts'].map { |p| p['id'] }\n\n        expect(post_ids).to include public_post.id\n        expect(post_ids).to_not include private_post.id\n        expect(post_ids).to_not include topicless_post.id\n      end\n    end\n  end\n\n  describe '#cooked' do\n    it 'returns the cooked content' do\n      post = Fabricate(:post, cooked: \"WAt\")\n      get \"/posts/#{post.id}/cooked.json\"\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json).to be_present\n      expect(json['cooked']).to eq('WAt')\n    end\n  end\n\n  describe '#raw_email' do\n    include_examples \"action requires login\", :get, \"/posts/2/raw-email.json\"\n\n    describe \"when logged in\" do\n      let(:post) { Fabricate(:post, deleted_at: 2.hours.ago, user: Fabricate(:user), raw_email: 'email_content') }\n\n      it 'returns 403 when trying to view raw as user that created the post' do\n        sign_in(post.user)\n\n        get \"/posts/#{post.id}/raw-email.json\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns 403 when trying to view raw email as a normal user\" do\n        sign_in(user)\n\n        get \"/posts/#{post.id}/raw-email.json\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"can view raw email\" do\n        sign_in(moderator)\n\n        get \"/posts/#{post.id}/raw-email.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['raw_email']).to eq('email_content')\n      end\n    end\n  end\n\n  describe \"#locked\" do\n    before do\n      sign_in(moderator)\n    end\n\n    it 'can lock and unlock the post' do\n      put \"/posts/#{public_post.id}/locked.json\", params: { locked: \"true\" }\n      expect(response.status).to eq(200)\n      public_post.reload\n      expect(public_post).to be_locked\n\n      put \"/posts/#{public_post.id}/locked.json\", params: { locked: \"false\" }\n      expect(response.status).to eq(200)\n      public_post.reload\n      expect(public_post).not_to be_locked\n    end\n  end\n\n  describe \"#notice\" do\n    it 'can create and remove notices as a moderator' do\n      sign_in(moderator)\n\n      raw_notice = \"Hello *world*!\\n\\nhttps://github.com/discourse/discourse\"\n      put \"/posts/#{public_post.id}/notice.json\", params: { notice: raw_notice }\n\n      expect(response.status).to eq(200)\n      expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:custom], \"raw\" => raw_notice, \"cooked\" => PrettyText.cook(raw_notice, features: { onebox: false }))\n      expect(UserHistory.where(action: UserHistory.actions[:post_staff_note_create]).count).to eq(1)\n\n      put \"/posts/#{public_post.id}/notice.json\", params: { notice: nil }\n\n      expect(response.status).to eq(200)\n      expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(nil)\n      expect(UserHistory.where(action: UserHistory.actions[:post_staff_note_destroy]).count).to eq(1)\n    end\n\n    describe 'group moderators' do\n      fab!(:group_user) { Fabricate(:group_user) }\n      let(:user) { group_user.user }\n      let(:group) { group_user.group }\n\n      before do\n        SiteSetting.enable_category_group_moderation = true\n        topic.category.update!(reviewable_by_group_id: group.id)\n\n        sign_in(user)\n      end\n\n      it 'can create and remove notices as a group moderator' do\n        raw_notice = \"Hello *world*!\\n\\nhttps://github.com/discourse/discourse\"\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: raw_notice }\n\n        expect(response.status).to eq(200)\n        expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:custom], \"raw\" => raw_notice, \"cooked\" => PrettyText.cook(raw_notice, features: { onebox: false }))\n\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: nil }\n\n        expect(response.status).to eq(200)\n        expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(nil)\n      end\n\n      it 'prevents a group moderator from altering notes outside of their category' do\n        moderatable_group = Fabricate(:group)\n        topic.category.update!(reviewable_by_group_id: moderatable_group.id)\n\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: \"Hello\" }\n\n        expect(response.status).to eq(404)\n      end\n\n      it 'prevents a normal user from altering notes' do\n        group_user.destroy!\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: \"Hello\" }\n\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#pending\" do\n    subject(:request) { get \"/posts/#{user.username}/pending.json\" }\n\n    context \"when user is not logged in\" do\n      it_behaves_like \"action requires login\", :get, \"/posts/system/pending.json\"\n    end\n\n    context \"when user is logged in\" do\n      let(:pending_posts) { response.parsed_body[\"pending_posts\"] }\n\n      before { sign_in(current_user) }\n\n      context \"when current user is the same as user\" do\n        let(:current_user) { user }\n\n        context \"when there are existing pending posts\" do\n          let!(:owner_pending_posts) { Fabricate.times(2, :reviewable_queued_post, created_by: user) }\n          let!(:other_pending_post) { Fabricate(:reviewable_queued_post) }\n          let(:expected_keys) do\n            %w[\n          avatar_template\n          category_id\n          created_at\n          created_by_id\n          name\n          raw_text\n          title\n          topic_id\n          topic_url\n          username\n            ]\n          end\n\n          it \"returns user's pending posts\" do\n            request\n            expect(pending_posts).to all include \"id\" => be_in(owner_pending_posts.map(&:id))\n            expect(pending_posts).to all include(*expected_keys)\n          end\n        end\n\n        context \"when there aren't any pending posts\" do\n          it \"returns an empty array\" do\n            request\n            expect(pending_posts).to be_empty\n          end\n        end\n      end\n\n      context \"when current user is a staff member\" do\n        let(:current_user) { moderator }\n\n        context \"when there are existing pending posts\" do\n          let!(:owner_pending_posts) { Fabricate.times(2, :reviewable_queued_post, created_by: user) }\n          let!(:other_pending_post) { Fabricate(:reviewable_queued_post) }\n          let(:expected_keys) do\n            %w[\n          avatar_template\n          category_id\n          created_at\n          created_by_id\n          name\n          raw_text\n          title\n          topic_id\n          topic_url\n          username\n            ]\n          end\n\n          it \"returns user's pending posts\" do\n            request\n            expect(pending_posts).to all include \"id\" => be_in(owner_pending_posts.map(&:id))\n            expect(pending_posts).to all include(*expected_keys)\n          end\n        end\n\n        context \"when there aren't any pending posts\" do\n          it \"returns an empty array\" do\n            request\n            expect(pending_posts).to be_empty\n          end\n        end\n      end\n\n      context \"when current user is another user\" do\n        let(:current_user) { Fabricate(:user) }\n\n        it \"does not allow access\" do\n          request\n          expect(response).to have_http_status :not_found\n        end\n      end\n    end\n  end\n\n  describe Plugin::Instance do\n    describe '#add_permitted_post_create_param' do\n      fab!(:user) { Fabricate(:user) }\n      let(:instance) { Plugin::Instance.new }\n      let(:request) do\n        Proc.new {\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            composer_open_duration_msecs: 204,\n            typing_duration_msecs: 100,\n            reply_to_post_number: 123,\n            string_arg: '123',\n            hash_arg: { key1: 'val' },\n            array_arg: ['1', '2', '3']\n          }\n        }\n      end\n\n      before do\n        sign_in(user)\n        SiteSetting.min_first_post_typing_time = 0\n      end\n\n      it 'allows strings to be added' do\n        request.call\n        expect(@controller.send(:create_params)).not_to include(string_arg: '123')\n\n        instance.add_permitted_post_create_param(:string_arg)\n        request.call\n        expect(@controller.send(:create_params)).to include(string_arg: '123')\n      end\n\n      it 'allows hashes to be added' do\n        instance.add_permitted_post_create_param(:hash_arg)\n        request.call\n        expect(@controller.send(:create_params)).not_to include(hash_arg: { key1: 'val' })\n\n        instance.add_permitted_post_create_param(:hash_arg, :hash)\n        request.call\n        expect(@controller.send(:create_params)).to include(hash_arg: { key1: 'val' })\n      end\n\n      it 'allows strings to be added' do\n        instance.add_permitted_post_create_param(:array_arg)\n        request.call\n        expect(@controller.send(:create_params)).not_to include(array_arg: ['1', '2', '3'])\n\n        instance.add_permitted_post_create_param(:array_arg, :array)\n        request.call\n        expect(@controller.send(:create_params)).to include(array_arg: ['1', '2', '3'])\n      end\n\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass StrippedLengthValidator < ActiveModel::EachValidator\n  def self.validate(record, attribute, value, range)\n    if value.nil?\n      record.errors.add attribute, I18n.t('errors.messages.blank')\n    elsif value.length > range.end\n      record.errors.add attribute, I18n.t('errors.messages.too_long_validation', max: range.end, length: value.length)\n    else\n      value = get_sanitized_value(value)\n\n      if value.length < range.begin\n        record.errors.add attribute, I18n.t('errors.messages.too_short', count: range.begin)\n      end\n    end\n  end\n\n  def validate_each(record, attribute, value)\n    # the `in` parameter might be a lambda when the range is dynamic\n    range = options[:in].lambda? ? options[:in].call : options[:in]\n    self.class.validate(record, attribute, value, range)\n  end\n\n  def self.get_sanitized_value(value)\n    value = value.dup\n    value.gsub!(/<!--(.*?)-->/, '') # strip HTML comments\n    value.gsub!(/:\\w+(:\\w+)?:/, \"X\") # replace emojis with a single character\n    value.gsub!(/\\.{2,}/, '\u2026') # replace multiple ... with \u2026\n    value.gsub!(/\\,{2,}/, ',') # replace multiple ,,, with ,\n    value.strip\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.shared_examples 'finding and showing post' do\n  let!(:post) { post_by_user }\n\n  it \"ensures the user can't see the post\" do\n    topic = post.topic\n    topic.convert_to_private_message(Discourse.system_user)\n    topic.remove_allowed_user(Discourse.system_user, user.username)\n    get url\n    expect(response).to be_forbidden\n  end\n\n  it 'succeeds' do\n    get url\n    expect(response.status).to eq(200)\n  end\n\n  it \"returns 404 when post's topic is deleted\" do\n    post.topic.destroy!\n    get url\n    expect(response.status).to eq(404)\n  end\n\n  context \"with deleted post\" do\n    before do\n      post.trash!(user)\n    end\n\n    it \"can't find deleted posts as an anonymous user\" do\n      get url\n      expect(response.status).to eq(404)\n    end\n\n    it \"can't find deleted posts as a regular user\" do\n      sign_in(user)\n      get url\n      expect(response.status).to eq(404)\n    end\n\n    it \"can find posts as a moderator\" do\n      sign_in(moderator)\n      get url\n      expect(response.status).to eq(200)\n    end\n\n    it \"can find posts as a admin\" do\n      sign_in(admin)\n      get url\n      expect(response.status).to eq(200)\n    end\n\n    context \"with category group moderator\" do\n      fab!(:group_user) { Fabricate(:group_user) }\n      let(:user_gm) { group_user.user }\n      let(:group) { group_user.group }\n\n      before do\n        SiteSetting.enable_category_group_moderation = true\n        sign_in(user_gm)\n      end\n\n      it \"can find posts in the allowed category\" do\n        post.topic.category.update!(reviewable_by_group_id: group.id, topic_id: topic.id)\n        get url\n        expect(response.status).to eq(200)\n      end\n\n      it \"can't find posts outside of the allowed category\" do\n        get url\n        expect(response.status).to eq(404)\n      end\n    end\n  end\nend\n\nRSpec.shared_examples 'action requires login' do |method, url, params = {}|\n  it 'raises an exception when not logged in' do\n    self.public_send(method, url, **params)\n    expect(response.status).to eq(403)\n  end\nend\n\nRSpec.describe PostsController do\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user_trust_level_0) { Fabricate(:trust_level_0) }\n  fab!(:user_trust_level_1) { Fabricate(:trust_level_1) }\n  fab!(:category) { Fabricate(:category) }\n  fab!(:topic) { Fabricate(:topic) }\n  fab!(:post_by_user) { Fabricate(:post, user: user) }\n  let(:public_post) { Fabricate(:post, user: user, topic: topic) }\n  let(:topicless_post) { Fabricate(:post, user: user, raw: '<p>Car 54, where are you?</p>') }\n\n  let(:private_topic) do\n    Fabricate(:topic, archetype: Archetype.private_message, category_id: nil)\n  end\n\n  let(:private_post) { Fabricate(:post, user: user, topic: private_topic) }\n\n  describe '#show' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}.json\" }\n    end\n\n    it 'gets all the expected fields' do\n      # non fabricated test\n      new_post = create_post\n\n      get \"/posts/#{new_post.id}.json\"\n      parsed = response.parsed_body\n\n      expect(parsed[\"topic_slug\"]).to eq(new_post.topic.slug)\n      expect(parsed[\"moderator\"]).to eq(false)\n      expect(parsed[\"username\"]).to eq(new_post.user.username)\n      expect(parsed[\"cooked\"]).to eq(new_post.cooked)\n    end\n  end\n\n  describe '#by_number' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/by_number/#{post.topic_id}/#{post.post_number}.json\" }\n    end\n  end\n\n  describe '#by_date' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/by-date/#{post.topic_id}/#{post.created_at.strftime(\"%Y-%m-%d\")}.json\" }\n    end\n\n    it 'returns the expected post' do\n      first_post = Fabricate(:post, created_at: 10.days.ago)\n      second_post = Fabricate(:post, topic: first_post.topic, created_at: 4.days.ago)\n      _third_post = Fabricate(:post, topic: first_post.topic, created_at: 3.days.ago)\n\n      get \"/posts/by-date/#{second_post.topic_id}/#{(second_post.created_at - 2.days).strftime(\"%Y-%m-%d\")}.json\"\n      json = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(json[\"id\"]).to eq(second_post.id)\n    end\n\n    it 'returns no post if date is > at last created post' do\n      get \"/posts/by-date/#{post.topic_id}/2245-11-11.json\"\n      _json = response.parsed_body\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe '#reply_history' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}/reply-history.json\" }\n    end\n\n    it \"returns the replies with allowlisted user custom fields\" do\n      parent = Fabricate(:post)\n      child = Fabricate(:post, topic: parent.topic, reply_to_post_number: parent.post_number)\n\n      parent.user.upsert_custom_fields(hello: 'world', hidden: 'dontshow')\n      SiteSetting.public_user_custom_fields = 'hello'\n\n      get \"/posts/#{child.id}/reply-history.json\"\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n      expect(json[0]['id']).to eq(parent.id)\n      expect(json[0]['user_custom_fields']['hello']).to eq('world')\n      expect(json[0]['user_custom_fields']['hidden']).to be_blank\n    end\n  end\n\n  describe '#reply_ids' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}/reply-ids.json\" }\n    end\n\n    it \"returns ids of post's replies\" do\n      post = Fabricate(:post)\n      reply1 = Fabricate(:post, topic: post.topic, reply_to_post_number: post.post_number)\n      reply2 = Fabricate(:post, topic: post.topic, reply_to_post_number: post.post_number)\n      PostReply.create(post_id: post.id, reply_post_id: reply1.id)\n      PostReply.create(post_id: post.id, reply_post_id: reply2.id)\n\n      get \"/posts/#{post.id}/reply-ids.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body).to eq([\n        { \"id\" => reply1.id, \"level\" => 1 },\n        { \"id\" => reply2.id, \"level\" => 1 },\n      ])\n    end\n  end\n\n  describe '#replies' do\n    include_examples 'finding and showing post' do\n      let(:url) { \"/posts/#{post.id}/replies.json\" }\n    end\n\n    it 'asks post for replies' do\n      parent = Fabricate(:post)\n      child = Fabricate(:post, topic: parent.topic, reply_to_post_number: parent.post_number)\n      PostReply.create!(post: parent, reply: child)\n\n      child.user.upsert_custom_fields(hello: 'world', hidden: 'dontshow')\n      SiteSetting.public_user_custom_fields = 'hello'\n\n      get \"/posts/#{parent.id}/replies.json\"\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n      expect(json[0]['id']).to eq(child.id)\n      expect(json[0]['user_custom_fields']['hello']).to eq('world')\n      expect(json[0]['user_custom_fields']['hidden']).to be_blank\n    end\n  end\n\n  describe '#destroy' do\n    include_examples 'action requires login', :delete, \"/posts/123.json\"\n\n    describe 'when logged in' do\n      let(:topic) { Fabricate(:topic) }\n\n      it \"raises an error when the user doesn't have permission to see the post\" do\n        pm = Fabricate(:private_message_topic)\n        post = Fabricate(:post, topic: pm, post_number: 3)\n\n        sign_in(user)\n\n        delete \"/posts/#{post.id}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when the self deletions are disabled\" do\n        SiteSetting.max_post_deletions_per_day = 0\n        post = Fabricate(:post, user: user, topic: topic, post_number: 3)\n        sign_in(user)\n\n        delete \"/posts/#{post.id}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"uses a PostDestroyer\" do\n        post = Fabricate(:post, topic_id: topic.id, post_number: 3)\n        sign_in(moderator)\n\n        destroyer = mock\n        PostDestroyer.expects(:new).returns(destroyer)\n        destroyer.expects(:destroy)\n\n        delete \"/posts/#{post.id}.json\"\n      end\n\n      context \"with permanently destroy\" do\n        let!(:post) { Fabricate(:post, topic_id: topic.id, post_number: 3) }\n\n        before do\n          SiteSetting.can_permanently_delete = true\n        end\n\n        it \"does not work for a post that was not deleted yet\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(403)\n        end\n\n        it \"needs some time to pass to permanently delete a topic\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\"\n          expect(response.status).to eq(200)\n          expect(post.reload.deleted_by_id).to eq(admin.id)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(403)\n\n          post.update!(deleted_at: 10.minutes.ago)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(200)\n          expect { post.reload }.to raise_error(ActiveRecord::RecordNotFound)\n        end\n\n        it \"needs two users to permanently delete a topic\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\"\n          expect(response.status).to eq(200)\n          expect(post.reload.deleted_by_id).to eq(admin.id)\n\n          sign_in(Fabricate(:admin))\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(200)\n          expect { post.reload }.to raise_error(ActiveRecord::RecordNotFound)\n        end\n\n        it \"moderators cannot permanently delete topics\" do\n          sign_in(admin)\n\n          delete \"/posts/#{post.id}.json\"\n          expect(response.status).to eq(200)\n          expect(post.reload.deleted_by_id).to eq(admin.id)\n\n          sign_in(moderator)\n\n          delete \"/posts/#{post.id}.json\", params: { force_destroy: true }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe '#destroy_many' do\n    include_examples 'action requires login', :delete, \"/posts/destroy_many.json\", params: { post_ids: [123, 345] }\n\n    describe 'when logged in' do\n      fab!(:poster) { Fabricate(:moderator) }\n      fab!(:post1) { Fabricate(:post, user: poster, post_number: 2) }\n      fab!(:post2) { Fabricate(:post, topic: post1.topic, user: poster, post_number: 3, reply_to_post_number: post1.post_number) }\n\n      it \"raises invalid parameters no post_ids\" do\n        sign_in(poster)\n        delete \"/posts/destroy_many.json\"\n        expect(response.status).to eq(400)\n        expect(response.message.downcase).to eq(\"bad request\")\n      end\n\n      it \"raises invalid parameters with missing ids\" do\n        sign_in(poster)\n        delete \"/posts/destroy_many.json\", params: { post_ids: [12345] }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to delete the posts\" do\n        sign_in(user)\n        delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes the post\" do\n        sign_in(poster)\n        PostDestroyer.any_instance.expects(:destroy).twice\n        delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n        expect(response.status).to eq(200)\n      end\n\n      it \"updates the highest read data for the forum\" do\n        sign_in(poster)\n        Topic.expects(:reset_highest).twice\n        delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n      end\n\n      describe \"can delete replies\" do\n        before do\n          PostReply.create(post_id: post1.id, reply_post_id: post2.id)\n        end\n\n        it \"deletes the post and the reply to it\" do\n          sign_in(poster)\n          PostDestroyer.any_instance.expects(:destroy).twice\n          delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id], reply_post_ids: [post1.id] }\n        end\n      end\n\n      context \"when deleting flagged posts\" do\n        before do\n          sign_in(moderator)\n          PostActionCreator.off_topic(moderator, post1)\n          PostActionCreator.off_topic(moderator, post2)\n          Jobs::SendSystemMessage.clear\n        end\n\n        it \"defers the child posts by default\" do\n          expect(ReviewableFlaggedPost.pending.count).to eq(2)\n          delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id] }\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(ReviewableFlaggedPost.pending.count).to eq(0)\n        end\n\n        it \"can defer all posts based on `agree_with_first_reply_flag` param\" do\n          expect(ReviewableFlaggedPost.pending.count).to eq(2)\n          delete \"/posts/destroy_many.json\", params: { post_ids: [post1.id, post2.id], agree_with_first_reply_flag: false }\n          PostActionCreator.off_topic(moderator, post1)\n          PostActionCreator.off_topic(moderator, post2)\n          Jobs::SendSystemMessage.clear\n        end\n      end\n    end\n  end\n\n  describe '#recover' do\n    include_examples 'action requires login', :put, \"/posts/123/recover.json\"\n\n    describe 'when logged in' do\n      it \"raises an error when the user doesn't have permission to see the post\" do\n        post = Fabricate(:post, topic: Fabricate(:private_message_topic), post_number: 3)\n        sign_in(user)\n\n        put \"/posts/#{post.id}/recover.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when self deletion/recovery is disabled\" do\n        SiteSetting.max_post_deletions_per_day = 0\n        post = Fabricate(:post, user: user, topic: topic, post_number: 3)\n        sign_in(user)\n\n        put \"/posts/#{post.id}/recover.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"recovers a post correctly\" do\n        topic_id = create_post.topic_id\n        post = create_post(topic_id: topic_id)\n        sign_in(user)\n\n        PostDestroyer.new(user, post).destroy\n        put \"/posts/#{post.id}/recover.json\"\n        post.reload\n        expect(post.trashed?).to be_falsey\n      end\n    end\n  end\n\n  describe '#update' do\n    include_examples 'action requires login', :put, \"/posts/2.json\"\n\n    let!(:post) { post_by_user }\n    let(:update_params) do\n      {\n        post: { raw: 'edited body', edit_reason: 'typo' },\n        image_sizes: { 'http://image.com/image.jpg' => { 'width' => 123, 'height' => 456 } },\n      }\n    end\n\n    describe 'when logged in as a regular user' do\n      before do\n        sign_in(user)\n      end\n\n      it 'does not allow TL0 or TL1 to update when edit time limit expired' do\n        SiteSetting.post_edit_time_limit = 5\n        SiteSetting.tl2_post_edit_time_limit = 30\n\n        post = Fabricate(:post, created_at: 10.minutes.ago, user: user)\n\n        user.update_columns(trust_level: 1)\n\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('too_late_to_edit'))\n      end\n\n      it 'does not allow TL2 to update when edit time limit expired' do\n        SiteSetting.post_edit_time_limit = 12\n        SiteSetting.tl2_post_edit_time_limit = 8\n\n        user.update_columns(trust_level: 2)\n\n        post = Fabricate(:post, created_at: 10.minutes.ago, user: user)\n\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('too_late_to_edit'))\n      end\n\n      it 'passes the image sizes through' do\n        Post.any_instance.expects(:image_sizes=)\n        put \"/posts/#{post.id}.json\", params: update_params\n      end\n\n      it 'passes the edit reason through' do\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(200)\n        post.reload\n        expect(post.edit_reason).to eq(\"typo\")\n        expect(post.raw).to eq(\"edited body\")\n      end\n\n      it 'checks for an edit conflict' do\n        update_params[:post][:raw_old] = 'old body'\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(409)\n      end\n\n      it \"raises an error when the post parameter is missing\" do\n        update_params.delete(:post)\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(400)\n        expect(response.message.downcase).to eq(\"bad request\")\n      end\n\n      it \"raises an error when the user doesn't have permission to see the post\" do\n        post = Fabricate(:private_message_post, post_number: 3)\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response).to be_forbidden\n      end\n\n      it \"updates post's raw attribute\" do\n        put \"/posts/#{post.id}.json\", params: { post: { raw: 'edited body   ' } }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['post']['raw']).to eq('edited body')\n        expect(post.reload.raw).to eq('edited body')\n      end\n\n      it \"extracts links from the new body\" do\n        param = update_params\n        param[:post][:raw] = 'I just visited this https://google.com so many cool links'\n\n        put \"/posts/#{post.id}.json\", params: param\n\n        expect(response.status).to eq(200)\n        expect(TopicLink.count).to eq(1)\n      end\n\n      it \"doesn't allow updating of deleted posts\" do\n        first_post = post.topic.ordered_posts.first\n        PostDestroyer.new(moderator, first_post).destroy\n\n        put \"/posts/#{first_post.id}.json\", params: update_params\n        expect(response).not_to be_successful\n      end\n    end\n\n    describe \"when logged in as staff\" do\n      before do\n        sign_in(moderator)\n      end\n\n      it \"supports updating posts in deleted topics\" do\n        first_post = post.topic.ordered_posts.first\n        PostDestroyer.new(moderator, first_post).destroy\n\n        put \"/posts/#{first_post.id}.json\", params: update_params\n        expect(response.status).to eq(200)\n\n        post.reload\n        expect(post.raw).to eq('edited body')\n      end\n\n      it \"won't update bump date if post is a whisper\" do\n        created_at = freeze_time 1.day.ago\n        post = Fabricate(:post, post_type: Post.types[:whisper], user: user)\n\n        unfreeze_time\n        put \"/posts/#{post.id}.json\", params: update_params\n\n        expect(response.status).to eq(200)\n        expect(post.topic.reload.bumped_at).to eq_time(created_at)\n      end\n    end\n\n    describe \"when logged in as group moderator\" do\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:post) { Fabricate(:post, user: user, topic: topic) }\n      fab!(:group_user) { Fabricate(:group_user) }\n      let(:user_gm) { group_user.user }\n      let(:group) { group_user.group }\n\n      before do\n        SiteSetting.enable_category_group_moderation = true\n        post.topic.category.update!(reviewable_by_group_id: group.id, topic_id: topic.id)\n        sign_in(user_gm)\n      end\n\n      it \"allows updating the category description\" do\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(200)\n\n        post.reload\n        expect(post.raw).to eq('edited body')\n        expect(UserHistory.where(action: UserHistory.actions[:post_edit]).count).to eq(1)\n      end\n\n      it \"can not update category descriptions in other categories\" do\n        second_category = Fabricate(:category)\n        topic.update!(category: second_category)\n\n        put \"/posts/#{post.id}.json\", params: update_params\n        expect(response.status).to eq(403)\n      end\n\n    end\n\n    it 'can not change category to a disallowed category' do\n      post = create_post\n      sign_in(post.user)\n\n      category = Fabricate(:category)\n      category.set_permissions(staff: :full)\n      category.save!\n\n      put \"/posts/#{post.id}.json\", params: {\n        post: { category_id: category.id, raw: \"this is a test edit to post\" }\n      }\n\n      expect(response.status).not_to eq(200)\n      expect(post.topic.category_id).not_to eq(category.id)\n    end\n\n    it 'can not move to a category that requires topic approval' do\n      post = create_post\n      sign_in(post.user)\n\n      category = Fabricate(:category)\n      category.custom_fields[Category::REQUIRE_TOPIC_APPROVAL] = true\n      category.save!\n\n      put \"/posts/#{post.id}.json\", params: { post: { category_id: category.id, raw: \"this is a test edit to post\" } }\n\n      expect(response.status).to eq(403)\n      expect(post.topic.reload.category_id).not_to eq(category.id)\n    end\n\n    describe \"with Post.plugin_permitted_update_params\" do\n      before do\n        plugin = Plugin::Instance.new\n        plugin.add_permitted_post_update_param(:random_number) do |post, value|\n          post.custom_fields[:random_number] = value\n          post.save\n        end\n      end\n\n      after do\n        DiscoursePluginRegistry.reset!\n      end\n\n      it \"calls blocks passed into `add_permitted_post_update_param`\" do\n        sign_in(post.user)\n        put \"/posts/#{post.id}.json\", params: {\n          post: {\n            raw: \"this is a random post\",\n            raw_old: post.raw,\n            random_number: 244\n          }\n        }\n\n        expect(response.status).to eq(200)\n        expect(post.reload.custom_fields[:random_number]).to eq(\"244\")\n      end\n    end\n  end\n\n  describe \"#destroy_bookmark\" do\n    fab!(:post) { Fabricate(:post) }\n    fab!(:bookmark) { Fabricate(:bookmark, user: user, bookmarkable: post) }\n\n    before do\n      sign_in(user)\n    end\n\n    it \"deletes the bookmark\" do\n      bookmark_id = bookmark.id\n      delete \"/posts/#{post.id}/bookmark.json\"\n      expect(Bookmark.find_by(id: bookmark_id)).to eq(nil)\n    end\n\n    context \"when the user still has bookmarks in the topic\" do\n      before do\n        Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post, topic: post.topic))\n      end\n      it \"marks topic_bookmarked as true\" do\n        delete \"/posts/#{post.id}/bookmark.json\"\n        expect(response.parsed_body['topic_bookmarked']).to eq(true)\n      end\n    end\n  end\n\n  describe '#wiki' do\n    include_examples \"action requires login\", :put, \"/posts/2/wiki.json\"\n\n    describe \"when logged in\" do\n      before do\n        sign_in(user)\n      end\n\n      let!(:post) { post_by_user }\n\n      it \"returns 400 when wiki parameter is not present\" do\n        sign_in(admin)\n\n        put \"/posts/#{post.id}/wiki.json\", params: {}\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error if the user doesn't have permission to wiki the post\" do\n        put \"/posts/#{post.id}/wiki.json\", params: { wiki: 'true' }\n        expect(response).to be_forbidden\n      end\n\n      it \"toggle wiki status should create a new version\" do\n        sign_in(admin)\n        another_user = Fabricate(:user)\n        another_post = Fabricate(:post, user: another_user)\n\n        expect do\n          put \"/posts/#{another_post.id}/wiki.json\", params: { wiki: 'true' }\n        end.to change { another_post.reload.version }.by(1)\n\n        expect do\n          put \"/posts/#{another_post.id}/wiki.json\", params: { wiki: 'false' }\n        end.to change { another_post.reload.version }.by(-1)\n\n        sign_in(Fabricate(:admin))\n\n        expect do\n          put \"/posts/#{another_post.id}/wiki.json\", params: { wiki: 'true' }\n        end.to change { another_post.reload.version }.by(1)\n      end\n\n      it \"can wiki a post\" do\n        sign_in(admin)\n        put \"/posts/#{post.id}/wiki.json\", params: { wiki: 'true' }\n\n        post.reload\n        expect(post.wiki).to eq(true)\n      end\n\n      it \"can unwiki a post\" do\n        wikied_post = Fabricate(:post, user: user, wiki: true)\n        sign_in(admin)\n\n        put \"/posts/#{wikied_post.id}/wiki.json\", params: { wiki: 'false' }\n\n        wikied_post.reload\n        expect(wikied_post.wiki).to eq(false)\n      end\n    end\n  end\n\n  describe '#post_type' do\n    include_examples \"action requires login\", :put, \"/posts/2/post_type.json\"\n\n    describe \"when logged in\" do\n      before do\n        sign_in(moderator)\n      end\n\n      let!(:post) { post_by_user }\n\n      it \"raises an error if the user doesn't have permission to change the post type\" do\n        sign_in(user)\n\n        put \"/posts/#{post.id}/post_type.json\", params: { post_type: 2 }\n        expect(response).to be_forbidden\n      end\n\n      it \"returns 400 if post_type parameter is not present\" do\n        put \"/posts/#{post.id}/post_type.json\", params: {}\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"returns 400 if post_type parameters is invalid\" do\n        put \"/posts/#{post.id}/post_type.json\", params: { post_type: -1 }\n\n        expect(response.status).to eq(400)\n      end\n\n      it \"can change the post type\" do\n        put \"/posts/#{post.id}/post_type.json\", params: { post_type: 2 }\n\n        post.reload\n        expect(post.post_type).to eq(2)\n      end\n    end\n  end\n\n  describe '#rebake' do\n    include_examples \"action requires login\", :put, \"/posts/2/rebake.json\"\n\n    describe \"when logged in\" do\n      let!(:post) { post_by_user }\n\n      it \"raises an error if the user doesn't have permission to rebake the post\" do\n        sign_in(user)\n        put \"/posts/#{post.id}/rebake.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"can rebake the post\" do\n        sign_in(moderator)\n        put \"/posts/#{post.id}/rebake.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"will invalidate broken images cache\" do\n        sign_in(moderator)\n        PostHotlinkedMedia.create!(url: \"https://example.com/image.jpg\", post: post, status: 'download_failed')\n        put \"/posts/#{post.id}/rebake.json\"\n        post.reload\n        expect(post.post_hotlinked_media).to eq([])\n      end\n    end\n  end\n\n  describe '#create' do\n    include_examples 'action requires login', :post, \"/posts.json\"\n\n    before do\n      SiteSetting.min_first_post_typing_time = 0\n      SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n    end\n\n    context 'with api' do\n      it 'memoizes duplicate requests' do\n        raw = \"this is a test post 123 #{SecureRandom.hash}\"\n        title = \"this is a title #{SecureRandom.hash}\"\n\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { raw: raw, title: title, wpid: 1 },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        original = response.body\n\n        post \"/posts.json\",\n          params: { raw: raw, title: title, wpid: 2 },\n          headers: { HTTP_API_USERNAME: user.username_lower, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(response.body).to eq(original)\n      end\n\n      it 'allows to create posts in import_mode' do\n        Jobs.run_immediately!\n        NotificationEmailer.enable\n        post_1 = Fabricate(:post)\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { raw: 'this is test reply 1', topic_id: post_1.topic.id, reply_to_post_number: 1 },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(post_1.topic.user.notifications.count).to eq(1)\n        post_1.topic.user.notifications.destroy_all\n\n        post \"/posts.json\",\n          params: { raw: 'this is test reply 2', topic_id: post_1.topic.id, reply_to_post_number: 1, import_mode: true },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(post_1.topic.user.notifications.count).to eq(0)\n\n        post \"/posts.json\",\n          params: { raw: 'this is test reply 3', topic_id: post_1.topic.id, reply_to_post_number: 1, import_mode: false },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n        expect(post_1.topic.user.notifications.count).to eq(1)\n      end\n\n      it 'allows a topic to be created with an external_id' do\n        master_key = Fabricate(:api_key).key\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: \"this is some post\",\n          external_id: 'external_id'\n        }, headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(200)\n\n        new_topic = Topic.last\n\n        expect(new_topic.external_id).to eq('external_id')\n      end\n\n      it 'prevents whispers for regular users' do\n        post_1 = Fabricate(:post)\n        user_key = ApiKey.create!(user: user).key\n\n        post \"/posts.json\",\n          params: { raw: 'this is test whisper', topic_id: post_1.topic.id, reply_to_post_number: 1, whisper: true },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'does not advance draft' do\n        Draft.set(user, Draft::NEW_TOPIC, 0, \"test\")\n        user_key = ApiKey.create!(user: user).key\n\n        post \"/posts.json\",\n          params: { title: 'this is a test topic', raw: 'this is test whisper' },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }\n\n        expect(response.status).to eq(200)\n        expect(Draft.get(user, Draft::NEW_TOPIC, 0)).to eq(\"test\")\n      end\n\n      it 'will raise an error if specified category cannot be found' do\n        user = Fabricate(:admin)\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { title: 'this is a test title', raw: 'this is test body', category: 'invalid' },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(400)\n\n        expect(response.parsed_body[\"errors\"]).to include(\n          I18n.t(\"invalid_params\", message: \"category\")\n        )\n      end\n\n      it 'will raise an error if specified embed_url is invalid' do\n        user = Fabricate(:admin)\n        master_key = Fabricate(:api_key).key\n\n        post \"/posts.json\",\n          params: { title: 'this is a test title', raw: 'this is test body', embed_url: '/test.txt' },\n          headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: master_key }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"creates unlisted topic with admin master key\" do\n        master_key = Fabricate(:api_key).key\n\n        expect do\n          post \"/posts.json\",\n            params: { raw: \"this is a test title\", title: \"this is test body\", unlist_topic: true },\n            headers: { HTTP_API_USERNAME: admin.username, HTTP_API_KEY: master_key }\n        end.to change { Topic.count }.by(1)\n\n        expect(response.status).to eq(200)\n        expect(Topic.find(response.parsed_body[\"topic_id\"]).visible).to eq(false)\n      end\n\n      it \"prevents creation of unlisted topic with non-admin key\" do\n        user_key = ApiKey.create!(user: user).key\n\n        expect do\n          post \"/posts.json\",\n            params: { raw: \"this is a test title\", title: \"this is test body\", unlist_topic: true },\n            headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }\n        end.not_to change { Topic.count }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to include(\n          I18n.t(\"activerecord.errors.models.topic.attributes.base.unable_to_unlist\")\n        )\n      end\n    end\n\n    describe \"when logged in\" do\n      fab!(:user) { Fabricate(:user) }\n\n      before do\n        sign_in(user)\n      end\n\n      context \"when fast typing\" do\n        before do\n          SiteSetting.min_first_post_typing_time = 3000\n          SiteSetting.auto_silence_fast_typers_max_trust_level = 1\n        end\n\n        it 'queues the post if min_first_post_typing_time is not met' do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            composer_open_duration_msecs: 204,\n            typing_duration_msecs: 100,\n            reply_to_post_number: 123\n          }\n\n          expect(response.status).to eq(200)\n          parsed = response.parsed_body\n\n          expect(parsed[\"action\"]).to eq(\"enqueued\")\n\n          user.reload\n          expect(user).to be_silenced\n\n          rp = ReviewableQueuedPost.find_by(created_by: user)\n          expect(rp.payload['typing_duration_msecs']).to eq(100)\n          expect(rp.payload['composer_open_duration_msecs']).to eq(204)\n          expect(rp.payload['reply_to_post_number']).to eq(123)\n          expect(rp.reviewable_scores.first.reason).to eq('fast_typer')\n\n          expect(parsed['pending_post']).to be_present\n          expect(parsed['pending_post']['id']).to eq(rp.id)\n          expect(parsed['pending_post']['raw']).to eq(\"this is the test content\")\n\n          mod = moderator\n          rp.perform(mod, :approve_post)\n\n          user.reload\n          expect(user).not_to be_silenced\n        end\n\n        it \"doesn't enqueue posts when user first creates a topic\" do\n          topic = Fabricate(:post, user: user).topic\n\n          Draft.set(user, \"should_clear\", 0, \"{'a' : 'b'}\")\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            composer_open_duration_msecs: 204,\n            typing_duration_msecs: 100,\n            topic_id: topic.id,\n            draft_key: \"should_clear\"\n          }\n\n          expect(response.status).to eq(200)\n          parsed = response.parsed_body\n\n          expect(parsed[\"action\"]).not_to be_present\n\n          expect {\n            Draft.get(user, \"should_clear\", 0)\n          }.to raise_error(Draft::OutOfSequence)\n        end\n\n        it \"doesn't enqueue replies when the topic is closed\" do\n          topic = Fabricate(:closed_topic)\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            topic_id: topic.id\n          }\n\n          expect(response).not_to be_successful\n          parsed = response.parsed_body\n          expect(parsed[\"action\"]).not_to eq(\"enqueued\")\n        end\n\n        it \"doesn't enqueue replies when the post is too long\" do\n          SiteSetting.max_post_length = 10\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic'\n          }\n\n          expect(response).not_to be_successful\n          parsed = response.parsed_body\n          expect(parsed[\"action\"]).not_to eq(\"enqueued\")\n        end\n\n        it \"doesn't enqueue replies when the post is too long (including a html comment)\" do\n          SiteSetting.max_post_length = 10\n          raw = \"A post <!-- \" + (\"a\" * 3000) + \"-->\"\n\n          post \"/posts.json\", params: {\n            raw: raw,\n            title: \"this is the test title for the topic\"\n          }\n\n          expect(response).not_to be_successful\n          parsed = response.parsed_body\n          expect(parsed[\"action\"]).not_to eq(\"enqueued\")\n        end\n      end\n\n      it 'silences correctly based on auto_silence_first_post_regex' do\n        SiteSetting.auto_silence_first_post_regex = \"I love candy|i eat s[1-5]\"\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'when I eat s3 sometimes when not looking'\n        }\n\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body\n\n        expect(parsed[\"action\"]).to eq(\"enqueued\")\n        reviewable = ReviewableQueuedPost.find_by(created_by: user)\n        score = reviewable.reviewable_scores.first\n        expect(score.reason).to eq('auto_silence_regex')\n\n        user.reload\n        expect(user).to be_silenced\n      end\n\n      it 'silences correctly based on silence watched words' do\n        SiteSetting.watched_words_regular_expressions = true\n        WatchedWord.create!(action: WatchedWord.actions[:silence], word: 'I love candy')\n        WatchedWord.create!(action: WatchedWord.actions[:silence], word: 'i eat s[1-5]')\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'when I eat s3 sometimes when not looking'\n        }\n\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body\n\n        expect(parsed[\"action\"]).to eq(\"enqueued\")\n        reviewable = ReviewableQueuedPost.find_by(created_by: user)\n        score = reviewable.reviewable_scores.first\n        expect(score.reason).to eq('auto_silence_regex')\n\n        user.reload\n        expect(user).to be_silenced\n      end\n\n      it \"can send a message to a group\" do\n        Group.refresh_automatic_groups!\n        group = Group.create(name: 'test_group', messageable_level: Group::ALIAS_LEVELS[:nobody])\n        user1 = user\n        group.add(user1)\n\n        post \"/posts.json\", params: {\n          raw: 'I can haz a test',\n          title: 'I loves my test',\n          target_recipients: group.name,\n          archetype: Archetype.private_message\n        }\n\n        expect(response).not_to be_successful\n\n        # allow pm to this group\n        group.update_columns(messageable_level: Group::ALIAS_LEVELS[:everyone])\n\n        post \"/posts.json\", params: {\n          raw: 'I can haz a test',\n          title: 'I loves my test',\n          target_recipients: \"test_Group\",\n          archetype: Archetype.private_message\n        }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n        post = Post.find(parsed['id'])\n\n        expect(post.topic.topic_allowed_users.length).to eq(1)\n        expect(post.topic.topic_allowed_groups.length).to eq(1)\n      end\n\n      it \"can send a message to a group with caps\" do\n        Group.refresh_automatic_groups!\n        group = Group.create(name: 'Test_group', messageable_level: Group::ALIAS_LEVELS[:nobody])\n        user1 = user\n        group.add(user1)\n\n        # allow pm to this group\n        group.update_columns(messageable_level: Group::ALIAS_LEVELS[:everyone])\n\n        post \"/posts.json\", params: {\n          raw: 'I can haz a test',\n          title: 'I loves my test',\n          target_recipients: \"test_Group\",\n          archetype: Archetype.private_message\n        }\n\n        expect(response.status).to eq(200)\n\n        parsed = response.parsed_body\n        post = Post.find(parsed['id'])\n\n        expect(post.topic.topic_allowed_users.length).to eq(1)\n        expect(post.topic.topic_allowed_groups.length).to eq(1)\n      end\n\n      it \"returns the nested post with a param\" do\n        post \"/posts.json\", params: {\n          raw: 'this is the test content  ',\n          title: 'this is the test title for the topic',\n          nested_post: true\n        }\n\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body\n        expect(parsed['post']).to be_present\n        expect(parsed['post']['raw']).to eq('this is the test content')\n        expect(parsed['post']['cooked']).to be_present\n      end\n\n      it 'protects against dupes' do\n        raw = \"this is a test post 123 #{SecureRandom.hash}\"\n        title = \"this is a title #{SecureRandom.hash}\"\n\n        expect do\n          post \"/posts.json\", params: { raw: raw, title: title, wpid: 1 }\n        end.to change { Post.count }\n\n        expect(response.status).to eq(200)\n\n        expect do\n          post \"/posts.json\", params: { raw: raw, title: title, wpid: 2 }\n        end.to_not change { Post.count }\n\n        expect(response.status).to eq(422)\n      end\n\n      it 'cannot create a post in a disallowed category' do\n        category.set_permissions(staff: :full)\n        category.save!\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          category: category.id,\n          meta_data: { xyz: 'abc' }\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'cannot create a post with a tag that is restricted' do\n        SiteSetting.tagging_enabled = true\n        tag = Fabricate(:tag)\n        category.allowed_tags = [tag.name]\n        category.save!\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(422)\n        json = response.parsed_body\n        expect(json['errors']).to be_present\n      end\n\n      it 'cannot create a post with a tag when tagging is disabled' do\n        SiteSetting.tagging_enabled = false\n        tag = Fabricate(:tag)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(422)\n        json = response.parsed_body\n        expect(json['errors']).to be_present\n      end\n\n      it 'cannot create a post with a tag without tagging permission' do\n        SiteSetting.tagging_enabled = true\n        SiteSetting.min_trust_level_to_tag_topics = 4\n        tag = Fabricate(:tag)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(422)\n        json = response.parsed_body\n        expect(json['errors']).to be_present\n      end\n\n      it 'can create a post with a tag when tagging is enabled' do\n        SiteSetting.tagging_enabled = true\n        tag = Fabricate(:tag)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          tags: [tag.name],\n        }\n\n        expect(response.status).to eq(200)\n        expect(Post.last.topic.tags.count).to eq(1)\n      end\n\n      it 'creates the post' do\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          title: 'this is the test title for the topic',\n          category: category.id,\n          meta_data: { xyz: 'abc' }\n        }\n\n        expect(response.status).to eq(200)\n\n        new_post = Post.last\n        topic = new_post.topic\n\n        expect(new_post.user).to eq(user)\n        expect(new_post.raw).to eq('this is the test content')\n        expect(topic.title).to eq('This is the test title for the topic')\n        expect(topic.category).to eq(category)\n        expect(topic.meta_data).to eq(\"xyz\" => 'abc')\n        expect(topic.visible).to eq(true)\n      end\n\n      it 'can create an uncategorized topic' do\n        title = 'this is the test title for the topic'\n\n        expect do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: title,\n            category: \"\"\n          }\n\n          expect(response.status).to eq(200)\n        end.to change { Topic.count }.by(1)\n\n        topic = Topic.last\n\n        expect(topic.title).to eq(title.capitalize)\n        expect(topic.category_id).to eq(SiteSetting.uncategorized_category_id)\n      end\n\n      it 'can create a reply to a post' do\n        topic = Fabricate(:private_message_post, user: user).topic\n        post_2 = Fabricate(:private_message_post, user: user, topic: topic)\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          topic_id: topic.id,\n          reply_to_post_number: post_2.post_number,\n          image_sizes: { width: '100', height: '200' }\n        }\n\n        expect(response.status).to eq(200)\n\n        new_post = Post.last\n        topic = new_post.topic\n\n        expect(new_post.user).to eq(user)\n        expect(new_post.raw).to eq('this is the test content')\n        expect(new_post.reply_to_post_number).to eq(post_2.post_number)\n\n        job_args = Jobs::ProcessPost.jobs.first[\"args\"].first\n\n        expect(job_args[\"image_sizes\"]).to eq(\"width\" => '100', \"height\" => '200')\n      end\n\n      it 'creates a private post' do\n        user_2 = Fabricate(:user)\n        user_3 = Fabricate(:user, username: \"foo_bar\")\n\n        # In certain edge cases, it's possible to end up with a username\n        # containing characters that would normally fail to validate\n        user_4 = Fabricate(:user, username: \"Iyi_Iyi\")\n        user_4.update_attribute(:username, \"\u0130yi_\u0130yi\")\n        user_4.update_attribute(:username_lower, \"\u0130yi_\u0130yi\".downcase)\n        Group.refresh_automatic_groups!\n\n        post \"/posts.json\", params: {\n          raw: 'this is the test content',\n          archetype: 'private_message',\n          title: \"this is some post\",\n          target_recipients: \"#{user_2.username},Foo_Bar,\u0130yi_\u0130yi\"\n        }\n\n        expect(response.status).to eq(200)\n\n        new_post = Post.last\n        new_topic = Topic.last\n\n        expect(new_post.user).to eq(user)\n        expect(new_topic.private_message?).to eq(true)\n        expect(new_topic.allowed_users).to contain_exactly(user, user_2, user_3, user_4)\n      end\n\n      context \"when target_recipients not provided\" do\n        it \"errors when creating a private post\" do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: \"\"\n          }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to include(\n            I18n.t(\"activerecord.errors.models.topic.attributes.base.no_user_selected\")\n          )\n        end\n      end\n\n      context \"when topic_id is set\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        it \"errors when creating a private post\" do\n          user_2 = Fabricate(:user)\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            topic_id: topic.id\n          }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to include(\n            I18n.t(\"create_pm_on_existing_topic\")\n          )\n        end\n      end\n\n      context \"with errors\" do\n        it \"does not succeed\" do\n          post \"/posts.json\", params: { raw: 'test' }\n          expect(response).not_to be_successful\n          expect(response.status).to eq(422)\n        end\n\n        it \"it triggers flag_linked_posts_as_spam when the post creator returns spam\" do\n          SiteSetting.newuser_spam_host_threshold = 1\n          sign_in(Fabricate(:user, trust_level: 0))\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content http://fakespamwebsite.com http://fakespamwebsite.com/spam http://fakespamwebsite.com/spammy',\n            title: 'this is the test title for the topic',\n            meta_data: { xyz: 'abc' }\n          }\n\n          expect(response.parsed_body[\"errors\"]).to include(I18n.t(:spamming_host))\n        end\n\n        context \"when allow_uncategorized_topics is false\" do\n          before do\n            SiteSetting.allow_uncategorized_topics = false\n          end\n\n          it \"cant create an uncategorized post\" do\n            post \"/posts.json\", params: {\n              raw: \"a new post with no category\",\n              title: \"a new post with no category\"\n            }\n            expect(response).not_to be_successful\n          end\n\n          context \"as staff\" do\n            before do\n              sign_in(admin)\n            end\n\n            it \"cant create an uncategorized post\" do\n              post \"/posts.json\", params: {\n                raw: \"a new post with no category\",\n                title: \"a new post with no category\"\n              }\n              expect(response).not_to be_successful\n            end\n          end\n        end\n      end\n\n      context \"with mentions\" do\n        fab!(:user_to_mention) { Fabricate(:user) }\n\n        it \"returns mentioned users\" do\n          post \"/posts.json\", params: {\n            raw: \"I am mentioning @#{user_to_mention.username}\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"mentioned_users\"].length).to be(1)\n\n          mentioned_user = json[\"mentioned_users\"][0]\n          expect(mentioned_user[\"id\"]).to be(user_to_mention.id)\n          expect(mentioned_user[\"name\"]).to eq(user_to_mention.name)\n          expect(mentioned_user[\"username\"]).to eq(user_to_mention.username)\n        end\n\n        it \"returns an empty list of mentioned users if nobody was mentioned\" do\n          post \"/posts.json\", params: {\n            raw: \"No mentions here\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"mentioned_users\"].length).to be(0)\n        end\n\n        it \"returns an empty list of mentioned users if an nonexistent user was mentioned\" do\n          post \"/posts.json\", params: {\n            raw: \"Mentioning a @stranger\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"mentioned_users\"].length).to be(0)\n        end\n\n        it \"doesn't return user status on mentions by default\" do\n          user_to_mention.set_status!(\"off to dentist\", \"tooth\")\n\n          post \"/posts.json\", params: {\n            raw: \"I am mentioning @#{user_to_mention.username}\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"mentioned_users\"].length).to be(1)\n\n          status = json[\"mentioned_users\"][0][\"status\"]\n          expect(status).to be_nil\n        end\n\n        it \"returns user status on mentions if status is enabled in site settings\" do\n          SiteSetting.enable_user_status = true\n          user_to_mention.set_status!(\"off to dentist\", \"tooth\")\n\n          post \"/posts.json\", params: {\n            raw: \"I am mentioning @#{user_to_mention.username}\",\n            topic_id: topic.id,\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json[\"mentioned_users\"].length).to be(1)\n\n          status = json[\"mentioned_users\"][0][\"status\"]\n          expect(status).to be_present\n          expect(status[\"emoji\"]).to eq(user_to_mention.user_status.emoji)\n          expect(status[\"description\"]).to eq(user_to_mention.user_status.description)\n        end\n      end\n    end\n\n    context \"with topic unlisting\" do\n      context \"when logged in as staff\" do\n        before do\n          sign_in(admin)\n        end\n\n        it \"creates an unlisted topic\" do\n          expect do\n            post \"/posts.json\", params: {\n              raw: \"this is the test content\",\n              title: \"this is the test title for the topic\",\n              unlist_topic: true\n            }\n          end.to change { Topic.count }.by(1)\n\n          expect(response.status).to eq(200)\n          expect(Topic.find(response.parsed_body[\"topic_id\"]).visible).to eq(false)\n        end\n      end\n\n      context \"when logged in as a non-staff user\" do\n        before do\n          sign_in(user)\n        end\n\n        it \"prevents creation of an unlisted topic\" do\n          expect do\n            post \"/posts.json\", params: {\n              raw: \"this is the test content\",\n              title: \"this is the test title for the topic\",\n              unlist_topic: true\n            }\n          end.not_to change { Topic.count }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to include(\n            I18n.t(\"activerecord.errors.models.topic.attributes.base.unable_to_unlist\")\n          )\n        end\n      end\n    end\n\n    describe 'shared draft' do\n      fab!(:destination_category) { Fabricate(:category) }\n\n      it \"will raise an error for regular users\" do\n        post \"/posts.json\", params: {\n          raw: 'this is the shared draft content',\n          title: \"this is the shared draft title\",\n          category: destination_category.id,\n          shared_draft: 'true'\n        }\n        expect(response).not_to be_successful\n      end\n\n      describe \"as a staff user\" do\n        before do\n          sign_in(moderator)\n        end\n\n        it \"will raise an error if there is no shared draft category\" do\n          post \"/posts.json\", params: {\n            raw: 'this is the shared draft content',\n            title: \"this is the shared draft title\",\n            category: destination_category.id,\n            shared_draft: 'true'\n          }\n          expect(response).not_to be_successful\n        end\n\n        context \"with a shared category\" do\n          fab!(:shared_category) { Fabricate(:category) }\n          before do\n            SiteSetting.shared_drafts_category = shared_category.id\n          end\n\n          it \"will work if the shared draft category is present\" do\n            post \"/posts.json\", params: {\n              raw: 'this is the shared draft content',\n              title: \"this is the shared draft title\",\n              category: destination_category.id,\n              shared_draft: 'true'\n            }\n            expect(response.status).to eq(200)\n            result = response.parsed_body\n            topic = Topic.find(result['topic_id'])\n            expect(topic.category_id).to eq(shared_category.id)\n            expect(topic.shared_draft.category_id).to eq(destination_category.id)\n          end\n        end\n      end\n    end\n\n    describe 'warnings' do\n      fab!(:user_2) { Fabricate(:user) }\n\n      before do\n        Group.refresh_automatic_groups!\n      end\n\n      context 'as a staff user' do\n        before do\n          sign_in(admin)\n        end\n\n        it 'should be able to mark a topic as warning' do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            is_warning: true\n          }\n\n          expect(response.status).to eq(200)\n\n          new_topic = Topic.last\n\n          expect(new_topic.title).to eq('This is some post')\n          expect(new_topic.is_official_warning?).to eq(true)\n        end\n\n        it 'should be able to mark a topic as not a warning' do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            is_warning: false\n          }\n\n          expect(response.status).to eq(200)\n\n          new_topic = Topic.last\n\n          expect(new_topic.title).to eq('This is some post')\n          expect(new_topic.is_official_warning?).to eq(false)\n        end\n      end\n\n      context 'as a normal user' do\n        it 'should not be able to mark a topic as warning' do\n          sign_in(user)\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            archetype: 'private_message',\n            title: \"this is some post\",\n            target_recipients: user_2.username,\n            is_warning: true\n          }\n\n          expect(response.status).to eq(200)\n\n          new_topic = Topic.last\n\n          expect(new_topic.title).to eq('This is some post')\n          expect(new_topic.is_official_warning?).to eq(false)\n        end\n      end\n    end\n\n    context \"with topic bump\" do\n      shared_examples \"it works\" do\n        it \"should be able to skip topic bumping\" do\n          original_bumped_at = 1.day.ago\n          topic = Fabricate(:topic, bumped_at: original_bumped_at)\n\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            topic_id: topic.id,\n            no_bump: true\n          }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.bumped_at).to eq_time(original_bumped_at)\n        end\n\n        it \"should be able to post with topic bumping\" do\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            topic_id: topic.id\n          }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.bumped_at).to eq_time(topic.posts.last.created_at)\n        end\n      end\n\n      context \"with admins\" do\n        before do\n          sign_in(admin)\n        end\n\n        include_examples \"it works\"\n      end\n\n      context \"with moderators\" do\n        before do\n          sign_in(moderator)\n        end\n\n        include_examples \"it works\"\n      end\n\n      context \"with TL4 users\" do\n        fab!(:trust_level_4) { Fabricate(:trust_level_4) }\n\n        before do\n          sign_in(trust_level_4)\n        end\n\n        include_examples \"it works\"\n      end\n\n      context \"with users\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        [:user].each do |user|\n          it \"will raise an error for #{user}\" do\n            sign_in(Fabricate(user))\n            post \"/posts.json\", params: {\n              raw: 'this is the test content',\n              topic_id: topic.id,\n              no_bump: true\n            }\n            expect(response.status).to eq(400)\n          end\n        end\n      end\n    end\n\n    context \"with featured links\" do\n      it \"allows to create topics with featured links\" do\n        sign_in(user_trust_level_1)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\"\n        }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"doesn't allow TL0 users to create topics with featured links\" do\n        sign_in(user_trust_level_0)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to create topics with featured links if featured links are disabled in settings\" do\n        SiteSetting.topic_featured_link_enabled = false\n        sign_in(user_trust_level_1)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to create topics with featured links in the category with forbidden feature links\" do\n        category = Fabricate(:category, topic_featured_link_allowed: false)\n        sign_in(user_trust_level_1)\n\n        post \"/posts.json\", params: {\n          title: \"this is the test title for the topic\",\n          raw: \"this is the test content\",\n          featured_link: \"https://discourse.org\",\n          category: category.id\n        }\n\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  describe '#revisions' do\n    fab!(:post) { Fabricate(:post, version: 2) }\n    let(:post_revision) { Fabricate(:post_revision, post: post) }\n\n    it \"throws an exception when revision is < 2\" do\n      get \"/posts/#{post.id}/revisions/1.json\"\n      expect(response.status).to eq(400)\n    end\n\n    context \"when edit history is not visible to the public\" do\n\n      before { SiteSetting.edit_history_visible_to_public = false }\n\n      it \"ensures anonymous cannot see the revisions\" do\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"ensures regular user cannot see the revisions\" do\n        sign_in(user)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"ensures staff can see the revisions\" do\n        sign_in(admin)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"ensures poster can see the revisions\" do\n        user = Fabricate(:active_user)\n        sign_in(user)\n\n        post = Fabricate(:post, user: user, version: 3)\n        pr = Fabricate(:post_revision, user: user, post: post)\n\n        get \"/posts/#{pr.post_id}/revisions/#{pr.number}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"ensures trust level 4 cannot see the revisions\" do\n        sign_in(Fabricate(:user, trust_level: 4))\n        get \"/posts/#{post_revision.post_id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when post is hidden\" do\n      before {\n        post.hidden = true\n        post.save\n      }\n\n      it \"throws an exception for users\" do\n        sign_in(user)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"works for admins\" do\n        sign_in(admin)\n        get \"/posts/#{post.id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"when edit history is visible to everyone\" do\n\n      before { SiteSetting.edit_history_visible_to_public = true }\n\n      it \"ensures anyone can see the revisions\" do\n        get \"/posts/#{post_revision.post_id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with deleted post\" do\n      fab!(:deleted_post) { Fabricate(:post, user: admin, version: 3) }\n      fab!(:deleted_post_revision) { Fabricate(:post_revision, user: admin, post: deleted_post) }\n\n      before { deleted_post.trash!(admin) }\n\n      it \"also work on deleted post\" do\n        sign_in(admin)\n        get \"/posts/#{deleted_post_revision.post_id}/revisions/#{deleted_post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with deleted topic\" do\n      fab!(:deleted_topic) { Fabricate(:topic, user: admin) }\n      fab!(:post) { Fabricate(:post, user: admin, topic: deleted_topic, version: 3) }\n      fab!(:post_revision) { Fabricate(:post_revision, user: admin, post: post) }\n\n      before { deleted_topic.trash!(admin) }\n\n      it \"also work on deleted topic\" do\n        sign_in(admin)\n        get \"/posts/#{post_revision.post_id}/revisions/#{post_revision.number}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context \"with a tagged topic\" do\n      let(:tag) { Fabricate(:tag) }\n      it \"works\" do\n        SiteSetting.tagging_enabled = true\n\n        post_revision.post.topic.update(tags: [tag])\n\n        get \"/posts/#{post_revision.post_id}/revisions/latest.json\"\n        expect(response.status).to eq(200)\n\n        SiteSetting.tagging_enabled = false\n\n        get \"/posts/#{post_revision.post_id}/revisions/latest.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#revert' do\n    include_examples 'action requires login', :put, \"/posts/123/revisions/2/revert.json\"\n\n    fab!(:post) { Fabricate(:post, user: Fabricate(:user), raw: \"Lorem ipsum dolor sit amet, cu nam libris tractatos, ancillae senserit ius ex\") }\n    let(:post_revision) { Fabricate(:post_revision, post: post, modifications: { \"raw\" => [\"this is original post body.\", \"this is edited post body.\"] }) }\n    let(:blank_post_revision) { Fabricate(:post_revision, post: post, modifications: { \"edit_reason\" => [\"edit reason #1\", \"edit reason #2\"] }) }\n    let(:same_post_revision) { Fabricate(:post_revision, post: post, modifications: { \"raw\" => [\"Lorem ipsum dolor sit amet, cu nam libris tractatos, ancillae senserit ius ex\", \"this is edited post body.\"] }) }\n\n    let(:post_id) { post.id }\n    let(:revision_id) { post_revision.number }\n\n    describe 'when logged in as a regular user' do\n      it \"does not work\" do\n        sign_in(user)\n        put \"/posts/#{post_id}/revisions/#{revision_id}/revert.json\"\n        expect(response).to_not be_successful\n      end\n    end\n\n    describe \"when logged in as staff\" do\n      before do\n        sign_in(moderator)\n      end\n\n      it \"fails when revision is < 2\" do\n        put \"/posts/#{post_id}/revisions/1/revert.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"fails when post_revision record is not found\" do\n        put \"/posts/#{post_id}/revisions/#{revision_id + 1}/revert.json\"\n        expect(response).to_not be_successful\n      end\n\n      it \"fails when post record is not found\" do\n        put \"/posts/#{post_id + 1}/revisions/#{revision_id}/revert.json\"\n        expect(response).to_not be_successful\n      end\n\n      it \"fails when revision is blank\" do\n        put \"/posts/#{post_id}/revisions/#{blank_post_revision.number}/revert.json\"\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('revert_version_same'))\n      end\n\n      it \"fails when revised version is same as current version\" do\n        put \"/posts/#{post_id}/revisions/#{same_post_revision.number}/revert.json\"\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors']).to include(I18n.t('revert_version_same'))\n      end\n\n      it \"works!\" do\n        put \"/posts/#{post_id}/revisions/#{revision_id}/revert.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"supports reverting posts in deleted topics\" do\n        first_post = post.topic.ordered_posts.first\n        PostDestroyer.new(moderator, first_post).destroy\n\n        put \"/posts/#{post_id}/revisions/#{revision_id}/revert.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#expand_embed' do\n    before do\n      sign_in(user)\n    end\n\n    fab!(:post) { Fabricate(:post) }\n\n    it \"raises an error when you can't see the post\" do\n      post = Fabricate(:private_message_post)\n      get \"/posts/#{post.id}/expand-embed.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"retrieves the body when you can see the post\" do\n      TopicEmbed.expects(:expanded_for).with(post).returns(\"full content\")\n      get \"/posts/#{post.id}/expand-embed.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['cooked']).to eq(\"full content\")\n    end\n  end\n\n  describe '#flagged_posts' do\n    include_examples \"action requires login\", :get, \"/posts/system/flagged.json\"\n\n    describe \"when logged in\" do\n      it \"raises an error if the user doesn't have permission to see the flagged posts\" do\n        sign_in(user)\n        get \"/posts/system/flagged.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"can see the flagged posts when authorized\" do\n        sign_in(moderator)\n        get \"/posts/system/flagged.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"only shows agreed and deferred flags\" do\n        post_agreed = create_post(user: user)\n        post_deferred = create_post(user: user)\n        post_disagreed = create_post(user: user)\n\n        r0 = PostActionCreator.spam(moderator, post_agreed).reviewable\n        r1 = PostActionCreator.off_topic(moderator, post_deferred).reviewable\n        r2 = PostActionCreator.inappropriate(moderator, post_disagreed).reviewable\n\n        r0.perform(admin, :agree_and_keep)\n        r1.perform(admin, :ignore)\n        r2.perform(admin, :disagree)\n\n        sign_in(Fabricate(:moderator))\n        get \"/posts/#{user.username}/flagged.json\"\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body.length).to eq(2)\n      end\n    end\n  end\n\n  describe '#deleted_posts' do\n    include_examples \"action requires login\", :get, \"/posts/system/deleted.json\"\n\n    describe \"when logged in\" do\n      before do\n        Group.refresh_automatic_groups!\n      end\n\n      it \"raises an error if the user doesn't have permission to see the deleted posts\" do\n        sign_in(user)\n        get \"/posts/system/deleted.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"can see the deleted posts when authorized\" do\n        sign_in(moderator)\n        get \"/posts/system/deleted.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"does not raise if topic has been permanently deleted\" do\n        post = Fabricate(:post, user: admin)\n        PostDestroyer.new(admin, post).destroy\n        post.update!(topic_id: -1000)\n\n        sign_in(admin)\n        get \"/posts/#{admin.username}/deleted.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"doesn't return secured categories for moderators if they don't have access\" do\n        Fabricate(:moderator)\n\n        group = Fabricate(:group)\n        group.add_owner(user)\n\n        secured_category = Fabricate(:private_category, group: group)\n        secured_post = create_post(user: user, category: secured_category)\n        PostDestroyer.new(admin, secured_post).destroy\n\n        sign_in(moderator)\n        get \"/posts/#{user.username}/deleted.json\"\n        expect(response.status).to eq(200)\n\n        data = response.parsed_body\n        expect(data.length).to eq(0)\n      end\n\n      it \"doesn't return PMs for moderators\" do\n        Fabricate(:moderator)\n\n        pm_post = create_post(user: user, archetype: 'private_message', target_usernames: [admin.username])\n        PostDestroyer.new(admin, pm_post).destroy\n\n        sign_in(moderator)\n        get \"/posts/#{user.username}/deleted.json\"\n        expect(response.status).to eq(200)\n\n        data = response.parsed_body\n        expect(data.length).to eq(0)\n      end\n\n      it \"only shows posts deleted by other users\" do\n        create_post(user: user)\n        post_deleted_by_user = create_post(user: user)\n        post_deleted_by_admin = create_post(user: user)\n\n        PostDestroyer.new(user, post_deleted_by_user).destroy\n        PostDestroyer.new(admin, post_deleted_by_admin).destroy\n\n        sign_in(admin)\n        get \"/posts/#{user.username}/deleted.json\"\n        expect(response.status).to eq(200)\n\n        data = response.parsed_body\n        expect(data.length).to eq(1)\n        expect(data[0][\"id\"]).to eq(post_deleted_by_admin.id)\n        expect(data[0][\"deleted_by\"][\"id\"]).to eq(admin.id)\n      end\n    end\n  end\n\n  describe '#markdown_id' do\n    it \"can be viewed by anonymous\" do\n      post = Fabricate(:post, raw: \"123456789\")\n      get \"/posts/#{post.id}/raw.json\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(\"123456789\")\n    end\n\n    it \"renders a 404 page\" do\n      get \"/posts/0/raw\"\n      expect(response.status).to eq(404)\n      expect(response.body).to include(I18n.t(\"page_not_found.title\"))\n    end\n  end\n\n  describe '#markdown_num' do\n    it \"can be viewed by anonymous\" do\n      topic = Fabricate(:topic)\n      post = Fabricate(:post, topic: topic, post_number: 1, raw: \"123456789\")\n      post.save\n      get \"/raw/#{topic.id}/1.json\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(\"123456789\")\n    end\n\n    it \"can show whole topics\" do\n      topic = Fabricate(:topic)\n      post = Fabricate(:post, topic: topic, post_number: 1, raw: \"123456789\")\n      post_2 = Fabricate(:post, topic: topic, post_number: 2, raw: \"abcdefghij\")\n      post.save\n      get \"/raw/#{topic.id}\"\n      expect(response.status).to eq(200)\n      expect(response.body).to include(\"123456789\", \"abcdefghij\")\n    end\n  end\n\n  describe '#short_link' do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:post) { Fabricate(:post, topic: topic) }\n\n    it \"redirects to the topic\" do\n      get \"/p/#{post.id}.json\"\n      expect(response).to be_redirect\n    end\n\n    it \"returns a 403 when access is denied for JSON format\" do\n      post = Fabricate(:private_message_post)\n      get \"/p/#{post.id}.json\"\n      expect(response).to be_forbidden\n    end\n\n    it \"returns a 403 when access is denied for HTML format\" do\n      post = Fabricate(:private_message_post)\n      get \"/p/#{post.id}\"\n      expect(response).to be_forbidden\n      expect(response.body).to have_tag(\"body.no-ember\")\n    end\n\n    it \"renders a 404 page\" do\n      get \"/p/0\"\n      expect(response.status).to eq(404)\n      expect(response.body).to include(I18n.t(\"page_not_found.title\"))\n    end\n  end\n\n  describe '#user_posts_feed' do\n    it 'returns public posts rss feed' do\n      public_post\n      private_post\n\n      get \"/u/#{user.username}/activity.rss\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to_not include(private_post.url)\n      expect(body).to include(public_post.url)\n    end\n\n    it \"doesn't include posts from hidden topics\" do\n      public_post.topic.update!(visible: false)\n\n      get \"/u/#{user.username}/activity.rss\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n      expect(body).not_to include(public_post.url)\n    end\n\n    it \"excludes small actions\" do\n      small_action = Fabricate(:small_action, user: user)\n\n      get \"/u/#{user.username}/activity.rss\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).not_to include(small_action.canonical_url)\n    end\n\n    it 'returns public posts as JSON' do\n      public_post\n      private_post\n\n      get \"/u/#{user.username}/activity.json\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to_not include(private_post.topic.slug)\n      expect(body).to include(public_post.topic.slug)\n    end\n\n    it \"returns 404 if `hide_profile_and_presence` user option is checked\" do\n      user.user_option.update_columns(hide_profile_and_presence: true)\n\n      get \"/u/#{user.username}/activity.rss\"\n      expect(response.status).to eq(404)\n\n      get \"/u/#{user.username}/activity.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"succeeds when `allow_users_to_hide_profile` is false\" do\n      user.user_option.update_columns(hide_profile_and_presence: true)\n      SiteSetting.allow_users_to_hide_profile = false\n\n      get \"/u/#{user.username}/activity.rss\"\n      expect(response.status).to eq(200)\n\n      get \"/u/#{user.username}/activity.json\"\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe '#latest' do\n    context 'with private posts' do\n      describe 'when not logged in' do\n        it 'should return the right response' do\n          Fabricate(:post)\n\n          get \"/private-posts.rss\"\n\n          expect(response.status).to eq(404)\n\n          expect(response.body).to have_tag(\n            \"input\", with: { value: \"private_posts\" }\n          )\n        end\n      end\n\n      it 'returns private posts rss feed' do\n        sign_in(admin)\n\n        public_post\n        private_post\n        get \"/private-posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        expect(body).to include(private_post.url)\n        expect(body).to_not include(public_post.url)\n      end\n\n      it 'returns private posts for json' do\n        sign_in(admin)\n\n        public_post\n        private_post\n        get \"/private-posts.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        post_ids = json['private_posts'].map { |p| p['id'] }\n\n        expect(post_ids).to include private_post.id\n        expect(post_ids).to_not include public_post.id\n      end\n    end\n\n    context 'with public posts' do\n      it 'returns public posts with topic rss feed' do\n        public_post\n        private_post\n\n        get \"/posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        # we cache in redis, in rare cases this can cause a flaky test\n        PostsHelper.clear_canonical_cache!(public_post)\n\n        expect(body).to include(public_post.canonical_url)\n        expect(body).to_not include(private_post.url)\n      end\n\n      it \"doesn't include posts from hidden topics\" do\n        public_post.topic.update!(visible: false)\n\n        get \"/posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        # we cache in redis, in rare cases this can cause a flaky test\n        PostsHelper.clear_canonical_cache!(public_post)\n\n        expect(body).not_to include(public_post.canonical_url)\n      end\n\n      it \"excludes small actions\" do\n        small_action = Fabricate(:small_action)\n\n        get \"/posts.rss\"\n\n        expect(response.status).to eq(200)\n\n        body = response.body\n\n        expect(body).not_to include(small_action.canonical_url)\n      end\n\n      it 'returns public posts with topic for json' do\n        topicless_post.update topic_id: -100\n\n        public_post\n        private_post\n        topicless_post\n\n        get \"/posts.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        post_ids = json['latest_posts'].map { |p| p['id'] }\n\n        expect(post_ids).to include public_post.id\n        expect(post_ids).to_not include private_post.id\n        expect(post_ids).to_not include topicless_post.id\n      end\n    end\n  end\n\n  describe '#cooked' do\n    it 'returns the cooked content' do\n      post = Fabricate(:post, cooked: \"WAt\")\n      get \"/posts/#{post.id}/cooked.json\"\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json).to be_present\n      expect(json['cooked']).to eq('WAt')\n    end\n  end\n\n  describe '#raw_email' do\n    include_examples \"action requires login\", :get, \"/posts/2/raw-email.json\"\n\n    describe \"when logged in\" do\n      let(:post) { Fabricate(:post, deleted_at: 2.hours.ago, user: Fabricate(:user), raw_email: 'email_content') }\n\n      it 'returns 403 when trying to view raw as user that created the post' do\n        sign_in(post.user)\n\n        get \"/posts/#{post.id}/raw-email.json\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns 403 when trying to view raw email as a normal user\" do\n        sign_in(user)\n\n        get \"/posts/#{post.id}/raw-email.json\"\n        expect(response.status).to eq(403)\n      end\n\n      it \"can view raw email\" do\n        sign_in(moderator)\n\n        get \"/posts/#{post.id}/raw-email.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['raw_email']).to eq('email_content')\n      end\n    end\n  end\n\n  describe \"#locked\" do\n    before do\n      sign_in(moderator)\n    end\n\n    it 'can lock and unlock the post' do\n      put \"/posts/#{public_post.id}/locked.json\", params: { locked: \"true\" }\n      expect(response.status).to eq(200)\n      public_post.reload\n      expect(public_post).to be_locked\n\n      put \"/posts/#{public_post.id}/locked.json\", params: { locked: \"false\" }\n      expect(response.status).to eq(200)\n      public_post.reload\n      expect(public_post).not_to be_locked\n    end\n  end\n\n  describe \"#notice\" do\n    it 'can create and remove notices as a moderator' do\n      sign_in(moderator)\n\n      raw_notice = \"Hello *world*!\\n\\nhttps://github.com/discourse/discourse\"\n      put \"/posts/#{public_post.id}/notice.json\", params: { notice: raw_notice }\n\n      expect(response.status).to eq(200)\n      expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:custom], \"raw\" => raw_notice, \"cooked\" => PrettyText.cook(raw_notice, features: { onebox: false }))\n      expect(UserHistory.where(action: UserHistory.actions[:post_staff_note_create]).count).to eq(1)\n\n      put \"/posts/#{public_post.id}/notice.json\", params: { notice: nil }\n\n      expect(response.status).to eq(200)\n      expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(nil)\n      expect(UserHistory.where(action: UserHistory.actions[:post_staff_note_destroy]).count).to eq(1)\n    end\n\n    describe 'group moderators' do\n      fab!(:group_user) { Fabricate(:group_user) }\n      let(:user) { group_user.user }\n      let(:group) { group_user.group }\n\n      before do\n        SiteSetting.enable_category_group_moderation = true\n        topic.category.update!(reviewable_by_group_id: group.id)\n\n        sign_in(user)\n      end\n\n      it 'can create and remove notices as a group moderator' do\n        raw_notice = \"Hello *world*!\\n\\nhttps://github.com/discourse/discourse\"\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: raw_notice }\n\n        expect(response.status).to eq(200)\n        expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(\"type\" => Post.notices[:custom], \"raw\" => raw_notice, \"cooked\" => PrettyText.cook(raw_notice, features: { onebox: false }))\n\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: nil }\n\n        expect(response.status).to eq(200)\n        expect(public_post.reload.custom_fields[Post::NOTICE]).to eq(nil)\n      end\n\n      it 'prevents a group moderator from altering notes outside of their category' do\n        moderatable_group = Fabricate(:group)\n        topic.category.update!(reviewable_by_group_id: moderatable_group.id)\n\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: \"Hello\" }\n\n        expect(response.status).to eq(404)\n      end\n\n      it 'prevents a normal user from altering notes' do\n        group_user.destroy!\n        put \"/posts/#{public_post.id}/notice.json\", params: { notice: \"Hello\" }\n\n        expect(response.status).to eq(404)\n      end\n    end\n  end\n\n  describe \"#pending\" do\n    subject(:request) { get \"/posts/#{user.username}/pending.json\" }\n\n    context \"when user is not logged in\" do\n      it_behaves_like \"action requires login\", :get, \"/posts/system/pending.json\"\n    end\n\n    context \"when user is logged in\" do\n      let(:pending_posts) { response.parsed_body[\"pending_posts\"] }\n\n      before { sign_in(current_user) }\n\n      context \"when current user is the same as user\" do\n        let(:current_user) { user }\n\n        context \"when there are existing pending posts\" do\n          let!(:owner_pending_posts) { Fabricate.times(2, :reviewable_queued_post, created_by: user) }\n          let!(:other_pending_post) { Fabricate(:reviewable_queued_post) }\n          let(:expected_keys) do\n            %w[\n          avatar_template\n          category_id\n          created_at\n          created_by_id\n          name\n          raw_text\n          title\n          topic_id\n          topic_url\n          username\n            ]\n          end\n\n          it \"returns user's pending posts\" do\n            request\n            expect(pending_posts).to all include \"id\" => be_in(owner_pending_posts.map(&:id))\n            expect(pending_posts).to all include(*expected_keys)\n          end\n        end\n\n        context \"when there aren't any pending posts\" do\n          it \"returns an empty array\" do\n            request\n            expect(pending_posts).to be_empty\n          end\n        end\n      end\n\n      context \"when current user is a staff member\" do\n        let(:current_user) { moderator }\n\n        context \"when there are existing pending posts\" do\n          let!(:owner_pending_posts) { Fabricate.times(2, :reviewable_queued_post, created_by: user) }\n          let!(:other_pending_post) { Fabricate(:reviewable_queued_post) }\n          let(:expected_keys) do\n            %w[\n          avatar_template\n          category_id\n          created_at\n          created_by_id\n          name\n          raw_text\n          title\n          topic_id\n          topic_url\n          username\n            ]\n          end\n\n          it \"returns user's pending posts\" do\n            request\n            expect(pending_posts).to all include \"id\" => be_in(owner_pending_posts.map(&:id))\n            expect(pending_posts).to all include(*expected_keys)\n          end\n        end\n\n        context \"when there aren't any pending posts\" do\n          it \"returns an empty array\" do\n            request\n            expect(pending_posts).to be_empty\n          end\n        end\n      end\n\n      context \"when current user is another user\" do\n        let(:current_user) { Fabricate(:user) }\n\n        it \"does not allow access\" do\n          request\n          expect(response).to have_http_status :not_found\n        end\n      end\n    end\n  end\n\n  describe Plugin::Instance do\n    describe '#add_permitted_post_create_param' do\n      fab!(:user) { Fabricate(:user) }\n      let(:instance) { Plugin::Instance.new }\n      let(:request) do\n        Proc.new {\n          post \"/posts.json\", params: {\n            raw: 'this is the test content',\n            title: 'this is the test title for the topic',\n            composer_open_duration_msecs: 204,\n            typing_duration_msecs: 100,\n            reply_to_post_number: 123,\n            string_arg: '123',\n            hash_arg: { key1: 'val' },\n            array_arg: ['1', '2', '3']\n          }\n        }\n      end\n\n      before do\n        sign_in(user)\n        SiteSetting.min_first_post_typing_time = 0\n      end\n\n      it 'allows strings to be added' do\n        request.call\n        expect(@controller.send(:create_params)).not_to include(string_arg: '123')\n\n        instance.add_permitted_post_create_param(:string_arg)\n        request.call\n        expect(@controller.send(:create_params)).to include(string_arg: '123')\n      end\n\n      it 'allows hashes to be added' do\n        instance.add_permitted_post_create_param(:hash_arg)\n        request.call\n        expect(@controller.send(:create_params)).not_to include(hash_arg: { key1: 'val' })\n\n        instance.add_permitted_post_create_param(:hash_arg, :hash)\n        request.call\n        expect(@controller.send(:create_params)).to include(hash_arg: { key1: 'val' })\n      end\n\n      it 'allows strings to be added' do\n        instance.add_permitted_post_create_param(:array_arg)\n        request.call\n        expect(@controller.send(:create_params)).not_to include(array_arg: ['1', '2', '3'])\n\n        instance.add_permitted_post_create_param(:array_arg, :array)\n        request.call\n        expect(@controller.send(:create_params)).to include(array_arg: ['1', '2', '3'])\n      end\n\n    end\n  end\nend\n"], "filenames": ["lib/validators/stripped_length_validator.rb", "spec/requests/posts_controller_spec.rb"], "buggy_code_start_loc": [5, 1046], "buggy_code_end_loc": [11, 1046], "fixing_code_start_loc": [5, 1047], "fixing_code_end_loc": [15, 1061], "type": "NVD-CWE-Other", "message": "Discourse is an option source discussion platform. Prior to version 2.8.14 on the `stable` branch and version 2.9.0.beta16 on the `beta` and `tests-passed` branches, users can create posts with raw body longer than the `max_length` site setting by including html comments that are not counted toward the character limit. This issue is patched in versions 2.8.14 and 2.9.0.beta16. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-23549", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-05T19:15:09.500", "lastModified": "2023-01-12T20:33:47.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an option source discussion platform. Prior to version 2.8.14 on the `stable` branch and version 2.9.0.beta16 on the `beta` and `tests-passed` branches, users can create posts with raw body longer than the `max_length` site setting by including html comments that are not counted toward the character limit. This issue is patched in versions 2.8.14 and 2.9.0.beta16. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.14", "matchCriteriaId": "9C13BCBA-EF34-4F4B-9F4A-33392EB45196"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "35BAC488-3622-4B0B-B8EA-879E8C68E8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "406A23B4-B971-4DC8-A132-EE9854FE8546"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "1DD3C47F-E49F-4E19-9EA7-A322C4CFD541"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:*:*:*:*", "matchCriteriaId": "E924AC08-6978-4DFF-B616-9E3E9D6FBE1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta14:*:*:*:*:*:*", "matchCriteriaId": "B5A3C7FB-B3B6-45F0-AD7D-062A50490AD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "0086484D-0164-449C-8AAE-BE7479CB9706"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "F9D1B031-96C7-44C0-A0A0-F67ABE55C93C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "750D2AD9-35E7-4AC7-9C22-AA90DAA34F3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "B68E308A-BDAB-4614-A563-4460F7996CBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta15:*:*:*:*:*:*", "matchCriteriaId": "F62275F8-11E9-4D94-8F2E-F83905F65031"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/bf6b08670a927cc80bb090b7a2e710b4b554e6a8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-p47g-v5wr-p4xp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/bf6b08670a927cc80bb090b7a2e710b4b554e6a8"}}