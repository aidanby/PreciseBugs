{"buggy_code": ["/*\n *  Copyright 2004-2005 Paul Querna\n *  Copyright 2008 Nikos Mavrogiannopoulos\n *  Copyright 2011 Dash Shendy\n *  Copyright 2015-2020 Fiona Klute\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include \"mod_gnutls.h\"\n#include \"gnutls_io.h\"\n#include \"gnutls_proxy.h\"\n\n#ifdef APLOG_USE_MODULE\nAPLOG_USE_MODULE(gnutls);\n#endif\n\n#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)\n#include <inttypes.h>\n#endif\n\n/**\n * @file\n * Describe how the GnuTLS Filter system works here\n *  - Basicly the same as what mod_ssl does with OpenSSL.\n *\n */\n\n#define IS_PROXY_STR(c) \\\n    ((c->is_proxy == GNUTLS_ENABLED_TRUE) ? \"proxy \" : \"\")\n\n/**\n * Convert `APR_EINTR` or `APR_EAGAIN` to the matching errno. Needed\n * to pass the status on to GnuTLS from the pull and push functions.\n */\n#define EAI_APR_TO_RAW(s) (APR_STATUS_IS_EAGAIN(s) ? EAGAIN : EINTR)\n\n\n\n/**\n * Helper function, used mostly for error conditions: Insert an EOS (end\n * of stream) bucket into the bucket brigade.\n */\nstatic inline void gnutls_io_filter_eos(ap_filter_t *f,\n                                        apr_bucket_brigade *bb)\n{\n    apr_bucket *bucket = apr_bucket_eos_create(f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, bucket);\n}\n\n\n\nstatic int char_buffer_read(mgs_char_buffer_t * buffer, char *in, int inl) {\n    if (!buffer->length) {\n        return 0;\n    }\n\n    if (buffer->length > inl) {\n        /* we have have enough to fill the caller's buffer */\n        memmove(in, buffer->value, inl);\n        buffer->value += inl;\n        buffer->length -= inl;\n    } else {\n        /* swallow remainder of the buffer */\n        memmove(in, buffer->value, buffer->length);\n        inl = buffer->length;\n        buffer->value = NULL;\n        buffer->length = 0;\n    }\n\n    return inl;\n}\n\nstatic int char_buffer_write(mgs_char_buffer_t * buffer, char *in, int inl) {\n    buffer->value = in;\n    buffer->length = inl;\n    return inl;\n}\n\n/**\n * From mod_ssl / ssl_engine_io.c\n * This function will read from a brigade and discard the read buckets as it\n * proceeds.  It will read at most *len bytes.\n */\nstatic apr_status_t brigade_consume(apr_bucket_brigade * bb,\n        apr_read_type_e block,\n        char *c, apr_size_t * len) {\n    apr_size_t actual = 0;\n    apr_status_t status = APR_SUCCESS;\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *b = APR_BRIGADE_FIRST(bb);\n        const char *str;\n        apr_size_t str_len;\n\n        /* Justin points out this is an http-ism that might\n         * not fit if brigade_consume is added to APR.  Perhaps\n         * apr_bucket_read(eos_bucket) should return APR_EOF?\n         * Then this becomes mainline instead of a one-off.\n         */\n        if (APR_BUCKET_IS_EOS(b)) {\n            status = APR_EOF;\n            break;\n        }\n\n        /* The reason I'm not offering brigade_consume yet\n         * across to apr-util is that the following call\n         * illustrates how borked that API really is.  For\n         * this sort of case (caller provided buffer) it\n         * would be much more trivial for apr_bucket_consume\n         * to do all the work that follows, based on the\n         * particular characteristics of the bucket we are\n         * consuming here.\n         */\n        status = apr_bucket_read(b, &str, &str_len, block);\n\n        if (status != APR_SUCCESS) {\n            if (APR_STATUS_IS_EOF(status)) {\n                /* This stream bucket was consumed */\n                apr_bucket_delete(b);\n                continue;\n            }\n            break;\n        }\n\n        if (str_len > 0) {\n            /* Do not block once some data has been consumed */\n            block = APR_NONBLOCK_READ;\n\n            /* Assure we don't overflow. */\n            apr_size_t consume =\n                (str_len + actual > *len) ? *len - actual : str_len;\n\n            memcpy(c, str, consume);\n\n            c += consume;\n            actual += consume;\n\n            if (consume >= b->length) {\n                /* This physical bucket was consumed */\n                apr_bucket_delete(b);\n            } else {\n                /* Only part of this physical bucket was consumed */\n                b->start += consume;\n                b->length -= consume;\n            }\n        } else if (b->length == 0) {\n            apr_bucket_delete(b);\n        }\n\n        /* This could probably be actual == *len, but be safe from stray\n         * photons. */\n        if (actual >= *len) {\n            break;\n        }\n    }\n\n    *len = actual;\n    return status;\n}\n\nstatic apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}\n\nstatic apr_status_t gnutls_io_input_getline(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len) {\n    const char *pos = NULL;\n    apr_size_t tmplen = *len, buflen = *len, offset = 0;\n\n    *len = 0;\n\n    while (tmplen > 0)\n    {\n        apr_status_t status =\n            gnutls_io_input_read(ctxt, buf + offset, &tmplen);\n\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n\n        *len += tmplen;\n\n        if ((pos = memchr(buf, APR_ASCII_LF, *len))) {\n            break;\n        }\n\n        offset += tmplen;\n        tmplen = buflen - offset;\n    }\n\n    if (pos) {\n        char *value;\n        int length;\n        apr_size_t bytes = pos - buf;\n\n        bytes += 1;\n        value = buf + bytes;\n        length = *len - bytes;\n\n        char_buffer_write(&ctxt->input_cbuf, value, length);\n\n        *len = bytes;\n    }\n\n    return APR_SUCCESS;\n}\n\n#define HANDSHAKE_MAX_TRIES 1024\n\nstatic int gnutls_do_handshake(mgs_handle_t * ctxt) {\n    int ret;\n    int errcode;\n    int maxtries = HANDSHAKE_MAX_TRIES;\n\n    if (ctxt->status != 0 || ctxt->session == NULL) {\n        return -1;\n    }\n\n    /* Enable SNI and ALPN for proxy connections, and load cached\n     * session if any. */\n    if (ctxt->is_proxy == GNUTLS_ENABLED_TRUE)\n        mgs_set_proxy_handshake_ext(ctxt);\n\ntryagain:\n    do {\n        ret = gnutls_handshake(ctxt->session);\n        maxtries--;\n    } while ((ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN)\n            && maxtries > 0);\n\n    if (maxtries < 1) {\n        ctxt->status = -1;\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, ctxt->c,\n                \"GnuTLS: Handshake Failed. Hit Maximum Attempts\");\n        if (ctxt->session) {\n            gnutls_alert_send(ctxt->session, GNUTLS_AL_FATAL,\n                    gnutls_error_to_alert\n                    (GNUTLS_E_INTERNAL_ERROR, NULL));\n            gnutls_deinit(ctxt->session);\n        }\n        ctxt->session = NULL;\n        return -1;\n    }\n\n    if (ret < 0) {\n        if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED\n                || ret == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n            errcode = gnutls_alert_get(ctxt->session);\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                          \"GnuTLS: Handshake Alert (%d) '%s'.\",\n                          errcode, gnutls_alert_get_name(errcode));\n        }\n\n        if (!gnutls_error_is_fatal(ret)) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                          \"GnuTLS: Non-Fatal Handshake Error: (%d) '%s'\",\n                          ret, gnutls_strerror(ret));\n            goto tryagain;\n        }\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                \"GnuTLS: Handshake Failed (%d) '%s'\", ret,\n                gnutls_strerror(ret));\n        ctxt->status = -1;\n        if (ctxt->session) {\n            gnutls_alert_send(ctxt->session, GNUTLS_AL_FATAL,\n                    gnutls_error_to_alert(ret,\n                    NULL));\n            gnutls_deinit(ctxt->session);\n        }\n        ctxt->session = NULL;\n        return ret;\n    } else {\n        /* all done with the handshake */\n        ctxt->status = 1;\n        if (gnutls_session_is_resumed(ctxt->session))\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ctxt->c,\n                          \"%s: TLS session resumed.\", __func__);\n        }\n        return GNUTLS_E_SUCCESS;\n    }\n}\n\n\n\nint mgs_reauth(mgs_handle_t *ctxt, request_rec *r)\n{\n    if (ctxt->session == NULL)\n        return GNUTLS_E_INVALID_REQUEST;\n\n    /* Initialize to error to avoid false-good return value. */\n    int rv = GNUTLS_E_INTERNAL_ERROR;\n    int tries = 0;\n\n    do\n    {\n        rv = gnutls_reauth(ctxt->session, 0);\n        tries++;\n\n        /* GNUTLS_E_GOT_APPLICATION_DATA can (randomly, depending on\n         * timing) happen with a request containing a body. According to\n         * https://tools.ietf.org/html/rfc8446#appendix-E.1.2\n         * post-handshake authentication proves that the authenticated\n         * party is the one that did the handshake, so caching the data\n         * is appropriate. */\n        if (rv == GNUTLS_E_GOT_APPLICATION_DATA)\n        {\n            /* Fill connection input buffer using a speculative read. */\n            apr_size_t len = sizeof(ctxt->input_buffer);\n            ctxt->input_mode = AP_MODE_SPECULATIVE;\n            apr_status_t status =\n                gnutls_io_input_read(ctxt, ctxt->input_buffer, &len);\n            if (status == APR_SUCCESS)\n            {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,\n                              \"%s: cached %\" APR_SIZE_T_FMT \" bytes.\",\n                              __func__, len);\n                /* If the cache was too small to accept all pending data\n                 * we'll get GNUTLS_E_GOT_APPLICATION_DATA again, and the\n                 * authz hook will return HTTP_REQUEST_ENTITY_TOO_LARGE to\n                 * the client. */\n                rv = gnutls_reauth(ctxt->session, 0);\n            }\n            else\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r,\n                              \"%s: buffering request data failed!\",\n                              __func__);\n        }\n        /* Retry on GNUTLS_E_INTERRUPTED or GNUTLS_E_AGAIN, whether\n         * from initial gnutls_reauth() call or after buffering. */\n    } while (tries < HANDSHAKE_MAX_TRIES\n             && (rv == GNUTLS_E_INTERRUPTED || rv == GNUTLS_E_AGAIN));\n\n    if (rv != GNUTLS_E_SUCCESS)\n    {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"%s: post-handshake authentication failed: %s (%d)\",\n                      __func__, gnutls_strerror(rv), rv);\n        return rv;\n    }\n\n    return GNUTLS_E_SUCCESS;\n}\n\n\n\n/**\n * Close the TLS session associated with the given connection\n * structure and free its resources\n *\n * @param ctxt the mod_gnutls session context\n *\n * @return a GnuTLS status code, hopefully `GNUTLS_E_SUCCESS`\n */\nstatic int mgs_bye(mgs_handle_t* ctxt)\n{\n    int ret = GNUTLS_E_SUCCESS;\n    /* End Of Connection */\n    if (ctxt->session != NULL)\n    {\n        /* Try A Clean Shutdown */\n        do {\n            ret = gnutls_bye(ctxt->session, GNUTLS_SHUT_WR);\n        } while (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN);\n        if (ret != GNUTLS_E_SUCCESS)\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_EGENERAL, ctxt->c,\n                          \"%s: Error while closing TLS %sconnection: \"\n                          \"'%s' (%d)\",\n                          __func__, IS_PROXY_STR(ctxt),\n                          gnutls_strerror(ret), (int) ret);\n        else\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ctxt->c,\n                          \"%s: TLS %sconnection closed.\",\n                          __func__, IS_PROXY_STR(ctxt));\n        /* De-Initialize Session */\n        gnutls_deinit(ctxt->session);\n        ctxt->session = NULL;\n    }\n    return ret;\n}\n\n\n\napr_status_t mgs_filter_input(ap_filter_t * f,\n        apr_bucket_brigade * bb,\n        ap_input_mode_t mode,\n        apr_read_type_e block, apr_off_t readbytes)\n{\n    apr_status_t status = APR_SUCCESS;\n    mgs_handle_t *ctxt = (mgs_handle_t *) f->ctx;\n    apr_size_t len = sizeof (ctxt->input_buffer);\n\n    if (f->c->aborted) {\n        gnutls_io_filter_eos(f, bb);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,\n                      \"%s: %sconnection aborted\",\n                      __func__, IS_PROXY_STR(ctxt));\n        return APR_ECONNABORTED;\n    }\n\n    if (ctxt->status == 0) {\n        int ret = gnutls_do_handshake(ctxt);\n        if (ret == GNUTLS_E_SUCCESS)\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,\n                          \"%s: TLS %sconnection opened.\",\n                          __func__, IS_PROXY_STR(ctxt));\n    }\n\n    if (ctxt->status < 0)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, ctxt->c,\n                      \"%s: %sconnection failed, cannot provide data!\",\n                      __func__, IS_PROXY_STR(ctxt));\n        gnutls_io_filter_eos(f, bb);\n        return APR_ECONNABORTED;\n    }\n\n    /* XXX: we don't currently support anything other than these modes. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE &&\n            mode != AP_MODE_SPECULATIVE && mode != AP_MODE_INIT) {\n        return APR_ENOTIMPL;\n    }\n\n    ctxt->input_mode = mode;\n    ctxt->input_block = block;\n\n    if (ctxt->input_mode == AP_MODE_READBYTES ||\n            ctxt->input_mode == AP_MODE_SPECULATIVE) {\n        if (readbytes < 0) {\n            /* you're asking us to speculatively read a negative number of bytes! */\n            return APR_ENOTIMPL;\n        }\n        /* 'readbytes' and 'len' are of different integer types, which\n         * might have different lengths. Read sizes should be too\n         * small for 32 or 64 bit to matter, but we have to make\n         * sure. */\n#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)\n        if ((apr_size_t) readbytes < len)\n        {\n            /* If readbytes is negative the function fails in the\n             * check above, but the compiler doesn't get that. */\n            if (__builtin_expect(imaxabs(readbytes) > SIZE_MAX, 0))\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_CRIT, APR_EINVAL, ctxt->c,\n                              \"%s: prevented buffer length overflow\",\n                              __func__);\n                return APR_EINVAL;\n            }\n            len = (apr_size_t) readbytes;\n        }\n#else\n        if ((apr_size_t) readbytes < len\n            && __builtin_add_overflow(readbytes, 0, &len))\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_CRIT, APR_EINVAL, ctxt->c,\n                          \"%s: prevented buffer length overflow\",\n                          __func__);\n            return APR_EINVAL;\n        }\n#endif\n        status =\n                gnutls_io_input_read(ctxt, ctxt->input_buffer, &len);\n    } else if (ctxt->input_mode == AP_MODE_GETLINE) {\n        status =\n                gnutls_io_input_getline(ctxt, ctxt->input_buffer,\n                &len);\n    } else {\n        /* We have no idea what you are talking about, so return an error. */\n        return APR_ENOTIMPL;\n    }\n\n    if (status != APR_SUCCESS)\n    {\n        /* no data for nonblocking read, return APR_EAGAIN */\n        if ((block == APR_NONBLOCK_READ) && APR_STATUS_IS_EINTR(status))\n            return APR_EAGAIN;\n\n        /* Close TLS session and free resources on EOF,\n         * gnutls_io_filter_eos will add an EOS bucket */\n        if (APR_STATUS_IS_EOF(status))\n            mgs_bye(ctxt);\n\n        gnutls_io_filter_eos(f, bb);\n        return status;\n    }\n\n    /* Create a transient bucket out of the decrypted data. */\n    if (len > 0) {\n        apr_bucket *bucket =\n                apr_bucket_transient_create(ctxt->input_buffer, len,\n                f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, bucket);\n    }\n\n    return status;\n}\n\n/**\n * Try to flush the output bucket brigade.\n *\n * @param ctxt the mod_gnutls session context\n *\n * @return `1` on success, `-1` on failure.\n */\nstatic ssize_t write_flush(mgs_handle_t * ctxt) {\n    apr_bucket *e;\n\n    if (!(ctxt->output_blen || ctxt->output_length)) {\n        ctxt->output_rc = APR_SUCCESS;\n        return 1;\n    }\n\n    if (ctxt->output_blen) {\n        e = apr_bucket_transient_create(ctxt->output_buffer,\n                ctxt->output_blen,\n                ctxt->output_bb->\n                bucket_alloc);\n        /* we filled this buffer first so add it to the\n         * \t\t * head of the brigade\n         * \t\t \t\t */\n        APR_BRIGADE_INSERT_HEAD(ctxt->output_bb, e);\n        ctxt->output_blen = 0;\n    }\n\n    ctxt->output_length = 0;\n    e = apr_bucket_flush_create(ctxt->output_bb->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(ctxt->output_bb, e);\n\n    ctxt->output_rc = ap_pass_brigade(ctxt->output_filter->next,\n            ctxt->output_bb);\n    /* clear the brigade to be ready for next time */\n    apr_brigade_cleanup(ctxt->output_bb);\n\n    return (ctxt->output_rc == APR_SUCCESS) ? 1 : -1;\n}\n\napr_status_t mgs_filter_output(ap_filter_t * f, apr_bucket_brigade * bb) {\n    int ret;\n    mgs_handle_t *ctxt = (mgs_handle_t *) f->ctx;\n    apr_status_t status = APR_SUCCESS;\n    apr_read_type_e rblock = APR_NONBLOCK_READ;\n\n    if (f->c->aborted) {\n        apr_brigade_cleanup(bb);\n        return APR_ECONNABORTED;\n    }\n\n    if (ctxt->status == 0) {\n        ret = gnutls_do_handshake(ctxt);\n        if (ret == GNUTLS_E_SUCCESS)\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,\n                          \"%s: TLS %sconnection opened.\",\n                          __func__, IS_PROXY_STR(ctxt));\n        else if (ctxt->is_proxy)\n        {\n            /* If mod_proxy receives an error while trying to send its\n             * request it sends an \"invalid request\" error to the\n             * client. By pretending we could send the request\n             * mod_proxy continues its processing and sends a proper\n             * \"proxy error\" message when there's no response to read. */\n            gnutls_io_filter_eos(f, bb);\n            return APR_SUCCESS;\n        }\n        /* No final else here, the \"ctxt->status < 0\" check below will\n         * catch that. */\n    }\n\n    if (ctxt->status < 0)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, ctxt->c,\n                      \"%s: %sconnection failed, refusing to send.\",\n                      __func__, IS_PROXY_STR(ctxt));\n        return APR_ECONNABORTED;\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *bucket = APR_BRIGADE_FIRST(bb);\n\n        if (APR_BUCKET_IS_EOS(bucket)) {\n            return ap_pass_brigade(f->next, bb);\n        } else if (APR_BUCKET_IS_FLUSH(bucket)) {\n            /* Try Flush */\n            if (write_flush(ctxt) < 0) {\n                /* Flush Error */\n                return ctxt->output_rc;\n            }\n            /* cleanup! */\n            apr_bucket_delete(bucket);\n        } else if (AP_BUCKET_IS_EOC(bucket)) {\n            /* End Of Connection, close TLS session and free\n             * resources */\n            mgs_bye(ctxt);\n            /* cleanup! */\n            apr_bucket_delete(bucket);\n            /* Pass next brigade! */\n            return ap_pass_brigade(f->next, bb);\n        } else {\n            /* filter output */\n            const char *data;\n            apr_size_t len;\n\n            status = apr_bucket_read(bucket, &data, &len, rblock);\n\n            if (APR_STATUS_IS_EAGAIN(status)) {\n                /* No data available so Flush! */\n                if (write_flush(ctxt) < 0) {\n                    return ctxt->output_rc;\n                }\n                /* Try again with a blocking read. */\n                rblock = APR_BLOCK_READ;\n                continue;\n            }\n\n            rblock = APR_NONBLOCK_READ;\n\n            if (!APR_STATUS_IS_EOF(status)\n                    && (status != APR_SUCCESS)) {\n                return status;\n            }\n\n            if (len > 0) {\n\n                if (ctxt->session == NULL) {\n                    ret = GNUTLS_E_INVALID_REQUEST;\n                } else {\n                    do {\n                        ret =\n                                gnutls_record_send\n                                (ctxt->session, data,\n                                len);\n                    } while (ret == GNUTLS_E_INTERRUPTED\n                            || ret == GNUTLS_E_AGAIN);\n                }\n\n                if (ret < 0) {\n                    /* error sending output */\n                    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, ctxt->output_rc,\n                                  ctxt->c,\n                                  \"GnuTLS: Error writing data. (%d) '%s'\",\n                                  ret, gnutls_strerror(ret));\n                    if (ctxt->output_rc == APR_SUCCESS) {\n                        ctxt->output_rc =\n                                APR_EGENERAL;\n                        return ctxt->output_rc;\n                    }\n                } else if ((apr_size_t)(ret) != len) {\n                    /* we know the above cast is OK because len > 0 and ret >= 0 */\n                    /* Not able to send the entire bucket,\n                       split it and send it again. */\n                    apr_bucket_split(bucket, ret);\n                }\n            }\n\n            apr_bucket_delete(bucket);\n        }\n    }\n\n    return status;\n}\n\nint mgs_transport_read_ready(gnutls_transport_ptr_t ptr,\n                             unsigned int ms)\n{\n    mgs_handle_t *ctxt = ptr;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, APR_SUCCESS, ctxt->c,\n                  \"%s: called with %u ms wait\", __func__, ms);\n\n    apr_pool_t *tmp = NULL;\n    apr_status_t rv = apr_pool_create(&tmp, ctxt->c->pool);\n    if (rv != APR_SUCCESS)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_ENOMEM, ctxt->c,\n                      \"could not create temporary pool for %s\",\n                     __func__);\n        return -1;\n    }\n\n    apr_bucket_brigade *bb = apr_brigade_create(tmp, ctxt->c->bucket_alloc);\n\n    /* one byte non-blocking speculative read to see if there's data\n     * in the filter chain */\n    rv = ap_get_brigade(ctxt->input_filter->next, bb, AP_MODE_SPECULATIVE,\n                        APR_NONBLOCK_READ, 1);\n\n    int result;\n    if (rv == APR_SUCCESS && !APR_BRIGADE_EMPTY(bb))\n        result = 1;\n    else\n        result = 0;\n\n    apr_brigade_destroy(bb);\n\n    /* If GnuTLS doesn't want to wait or we already have data,\n     * return. */\n    if (ms == 0 || result == 1)\n    {\n        apr_pool_destroy(tmp);\n        return result;\n    }\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, APR_SUCCESS, ctxt->c,\n                  \"%s: waiting for data\", __func__);\n\n    /* No data yet, and we're supposed to wait, so wait for data on\n     * the socket. */\n    apr_socket_t *sock = ap_get_conn_socket(ctxt->c);\n    apr_interval_time_t timeout = -1;\n    apr_interval_time_t original_timeout;\n    rv = apr_socket_timeout_get(sock, &original_timeout);\n    if (rv != APR_SUCCESS)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, ctxt->c,\n                      \"%s: could not get socket timeout\",\n                      __func__);\n        apr_pool_destroy(tmp);\n        return -1;\n    }\n\n    /* If GnuTLS requests an \"indefinite\" wait we do not want to mess\n     * with whatever Apache does by default. Otherwise temporarily\n     * adjust the socket timeout. */\n    if (ms != GNUTLS_INDEFINITE_TIMEOUT)\n    {\n        /* apr_interval_time_t is in microseconds */\n        if (__builtin_mul_overflow(ms, 1000, &timeout))\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_ENOMEM, ctxt->c,\n                          \"%s: overflow while calculating timeout!\",\n                          __func__);\n            apr_pool_destroy(tmp);\n            return -1;\n        }\n        rv = apr_socket_timeout_set(sock, timeout);\n        if (rv != APR_SUCCESS)\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, ctxt->c,\n                          \"%s: could not set socket timeout\",\n                          __func__);\n            apr_pool_destroy(tmp);\n            return -1;\n        }\n    }\n\n#if APR_MAJOR_VERSION < 2\n    apr_pollfd_t pollset;\n    apr_int32_t nsds;\n    pollset.p = tmp;\n    pollset.desc_type = APR_POLL_SOCKET;\n    pollset.reqevents = APR_POLLIN | APR_POLLHUP;\n    pollset.desc.s = sock;\n    rv = apr_poll(&pollset, 1, &nsds, timeout);\n#else\n    rv = apr_socket_wait(sock, APR_WAIT_READ);\n#endif\n    apr_pool_destroy(tmp);\n\n    if (ms != GNUTLS_INDEFINITE_TIMEOUT)\n    {\n        /* We still need \"rv\" below, so new variable. */\n        apr_status_t rc = apr_socket_timeout_set(sock, original_timeout);\n        if (rc != APR_SUCCESS)\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_CRIT, rc, ctxt->c,\n                          \"%s: could not restore socket timeout\",\n                          __func__);\n            return -1;\n        }\n    }\n\n    if (rv == APR_SUCCESS)\n        return 1;\n    else if (APR_STATUS_IS_TIMEUP(rv))\n        return 0;\n    else\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, ctxt->c,\n                      \"%s: waiting for data on connection socket failed\",\n                      __func__);\n        return -1;\n    }\n}\n\n/**\n * Pull function for GnuTLS\n *\n * Generic errnos used for `gnutls_transport_set_errno()`:\n * * `EAGAIN`: no data available at the moment, try again (maybe later)\n * * `EINTR`: read was interrupted, try again\n * * `EIO`: Unknown I/O error\n * * `ECONNABORTED`: Input BB does not exist (`NULL`)\n *\n * The reason we are not using `APR_TO_OS_ERROR` to map `apr_status_t`\n * to errnos is this warning [in the APR documentation][apr-warn]:\n *\n * > If the statcode was not created by apr_get_os_error or\n * > APR_FROM_OS_ERROR, the results are undefined.\n *\n * We cannot know if this applies to any error we might encounter.\n *\n * @param ptr GnuTLS session data pointer (the mod_gnutls context\n * structure)\n *\n * @param buffer buffer for the read data\n *\n * @param len maximum number of bytes to read (must fit into the\n * buffer)\n *\n * @return The number of bytes read (may be zero on EOF), or `-1` on\n * error. Note that some errors may warrant another try (see above).\n *\n * [apr-warn]: https://apr.apache.org/docs/apr/1.4/group__apr__errno.html#ga2385cae04b04afbdcb65f1a45c4d8506 \"Apache Portable Runtime: Error Codes\"\n */\nssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n                           void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n    apr_size_t in = len;\n    apr_read_type_e block = ctxt->input_block;\n\n    ctxt->input_rc = APR_SUCCESS;\n\n    /* If Len = 0, we don't do anything. */\n    if (!len || buffer == NULL)\n    {\n        return 0;\n    }\n    /* Input bucket brigade is missing, EOF */\n    if (!ctxt->input_bb)\n    {\n        ctxt->input_rc = APR_EOF;\n        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(ctxt->input_bb))\n    {\n        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,\n                                         ctxt->input_bb, AP_MODE_READBYTES,\n                                         ctxt->input_block, in);\n\n        /* Not a problem, there was simply no data ready yet.\n         */\n        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)\n            || (rc == APR_SUCCESS\n                && APR_BRIGADE_EMPTY(ctxt->input_bb)))\n        {\n            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but\n             * it's the best matching error code for \"didn't get data,\n             * but read didn't permanently fail either.\" */\n            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        /* Blocking ap_get_brigade() can return a timeout status,\n         * sometimes after a very short time. \"Don't give up, just\n         * return the timeout\" is what mod_ssl does. */\n        if (ctxt->input_block == APR_BLOCK_READ\n            && APR_STATUS_IS_TIMEUP(rc)\n            && APR_BRIGADE_EMPTY(ctxt->input_bb))\n        {\n            ctxt->input_rc = rc;\n            gnutls_transport_set_errno(ctxt->session, EAGAIN);\n            return -1;\n        }\n\n        if (rc != APR_SUCCESS)\n        {\n            /* Unexpected errors discard the brigade */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,\n                          \"%s: Unexpected error!\", __func__);\n            apr_brigade_cleanup(ctxt->input_bb);\n            ctxt->input_bb = NULL;\n            gnutls_transport_set_errno(ctxt->session, EIO);\n            return -1;\n        }\n    }\n\n    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);\n\n    if (ctxt->input_rc == APR_SUCCESS)\n    {\n        return (ssize_t) len;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)\n        || APR_STATUS_IS_EINTR(ctxt->input_rc))\n    {\n        if (len == 0)\n        {\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) len;\n    }\n\n    /* Unexpected errors and APR_EOF clean out the brigade.\n     * Subsequent calls will return APR_EOF. */\n    apr_brigade_cleanup(ctxt->input_bb);\n    ctxt->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)\n    {\n        /* Some data has been received before EOF, return it. */\n        return (ssize_t) len;\n    }\n\n    gnutls_transport_set_errno(ctxt->session, EIO);\n    return -1;\n}\n\n/**\n * Push function for GnuTLS\n *\n * `gnutls_transport_set_errno()` will be called with `EAGAIN` or\n * `EINTR` on recoverable errors, or `EIO` in case of unexpected\n * errors. See the description of mgs_transport_read() for details on\n * possible error codes.\n *\n * @param ptr GnuTLS session data pointer (the mod_gnutls context\n * structure)\n *\n * @param buffer buffer containing the data to send\n *\n * @param len length of the data\n * buffer)\n *\n * @return The number of written bytes, or `-1` on error. Note that\n * some errors may warrant another try (see above).\n */\nssize_t mgs_transport_write(gnutls_transport_ptr_t ptr,\n                            const void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n\n    /* pass along the encrypted data\n     * need to flush since we're using SSL's malloc-ed buffer\n     * which will be overwritten once we leave here\n     */\n    apr_bucket *bucket = apr_bucket_transient_create(buffer, len,\n            ctxt->output_bb->\n            bucket_alloc);\n    ctxt->output_length += len;\n    APR_BRIGADE_INSERT_TAIL(ctxt->output_bb, bucket);\n\n    if (write_flush(ctxt) < 0)\n    {\n        /* We encountered an error. APR_EINTR or APR_EAGAIN can be\n         * handled, treat everything else as a generic I/O error. */\n        int err = EIO;\n        if (APR_STATUS_IS_EAGAIN(ctxt->output_rc)\n            || APR_STATUS_IS_EINTR(ctxt->output_rc))\n            err = EAI_APR_TO_RAW(ctxt->output_rc);\n\n        gnutls_transport_set_errno(ctxt->session, err);\n        return -1;\n    }\n    return len;\n}\n"], "fixing_code": ["/*\n *  Copyright 2004-2005 Paul Querna\n *  Copyright 2008 Nikos Mavrogiannopoulos\n *  Copyright 2011 Dash Shendy\n *  Copyright 2015-2022 Fiona Klute\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include \"mod_gnutls.h\"\n#include \"gnutls_io.h\"\n#include \"gnutls_proxy.h\"\n\n#ifdef APLOG_USE_MODULE\nAPLOG_USE_MODULE(gnutls);\n#endif\n\n#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)\n#include <inttypes.h>\n#endif\n\n/**\n * @file\n * Describe how the GnuTLS Filter system works here\n *  - Basicly the same as what mod_ssl does with OpenSSL.\n *\n */\n\n#define IS_PROXY_STR(c) \\\n    ((c->is_proxy == GNUTLS_ENABLED_TRUE) ? \"proxy \" : \"\")\n\n/**\n * Convert `APR_EINTR` or `APR_EAGAIN` to the matching errno. Needed\n * to pass the status on to GnuTLS from the pull and push functions.\n */\n#define EAI_APR_TO_RAW(s) (APR_STATUS_IS_EAGAIN(s) ? EAGAIN : EINTR)\n\n\n\n/**\n * Helper function, used mostly for error conditions: Insert an EOS (end\n * of stream) bucket into the bucket brigade.\n */\nstatic inline void gnutls_io_filter_eos(ap_filter_t *f,\n                                        apr_bucket_brigade *bb)\n{\n    apr_bucket *bucket = apr_bucket_eos_create(f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, bucket);\n}\n\n\n\nstatic int char_buffer_read(mgs_char_buffer_t * buffer, char *in, int inl) {\n    if (!buffer->length) {\n        return 0;\n    }\n\n    if (buffer->length > inl) {\n        /* we have have enough to fill the caller's buffer */\n        memmove(in, buffer->value, inl);\n        buffer->value += inl;\n        buffer->length -= inl;\n    } else {\n        /* swallow remainder of the buffer */\n        memmove(in, buffer->value, buffer->length);\n        inl = buffer->length;\n        buffer->value = NULL;\n        buffer->length = 0;\n    }\n\n    return inl;\n}\n\nstatic int char_buffer_write(mgs_char_buffer_t * buffer, char *in, int inl) {\n    buffer->value = in;\n    buffer->length = inl;\n    return inl;\n}\n\n/**\n * From mod_ssl / ssl_engine_io.c\n * This function will read from a brigade and discard the read buckets as it\n * proceeds.  It will read at most *len bytes.\n */\nstatic apr_status_t brigade_consume(apr_bucket_brigade * bb,\n        apr_read_type_e block,\n        char *c, apr_size_t * len) {\n    apr_size_t actual = 0;\n    apr_status_t status = APR_SUCCESS;\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *b = APR_BRIGADE_FIRST(bb);\n        const char *str;\n        apr_size_t str_len;\n\n        /* Justin points out this is an http-ism that might\n         * not fit if brigade_consume is added to APR.  Perhaps\n         * apr_bucket_read(eos_bucket) should return APR_EOF?\n         * Then this becomes mainline instead of a one-off.\n         */\n        if (APR_BUCKET_IS_EOS(b)) {\n            status = APR_EOF;\n            break;\n        }\n\n        /* The reason I'm not offering brigade_consume yet\n         * across to apr-util is that the following call\n         * illustrates how borked that API really is.  For\n         * this sort of case (caller provided buffer) it\n         * would be much more trivial for apr_bucket_consume\n         * to do all the work that follows, based on the\n         * particular characteristics of the bucket we are\n         * consuming here.\n         */\n        status = apr_bucket_read(b, &str, &str_len, block);\n\n        if (status != APR_SUCCESS) {\n            if (APR_STATUS_IS_EOF(status)) {\n                /* This stream bucket was consumed */\n                apr_bucket_delete(b);\n                continue;\n            }\n            break;\n        }\n\n        if (str_len > 0) {\n            /* Do not block once some data has been consumed */\n            block = APR_NONBLOCK_READ;\n\n            /* Assure we don't overflow. */\n            apr_size_t consume =\n                (str_len + actual > *len) ? *len - actual : str_len;\n\n            memcpy(c, str, consume);\n\n            c += consume;\n            actual += consume;\n\n            if (consume >= b->length) {\n                /* This physical bucket was consumed */\n                apr_bucket_delete(b);\n            } else {\n                /* Only part of this physical bucket was consumed */\n                b->start += consume;\n                b->length -= consume;\n            }\n        } else if (b->length == 0) {\n            apr_bucket_delete(b);\n        }\n\n        /* This could probably be actual == *len, but be safe from stray\n         * photons. */\n        if (actual >= *len) {\n            break;\n        }\n    }\n\n    *len = actual;\n    return status;\n}\n\nstatic apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else if (rc == GNUTLS_E_PULL_ERROR\n                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n                ap_log_cerror(\n                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                    \"%s: transport read timed out\", __func__);\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}\n\nstatic apr_status_t gnutls_io_input_getline(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len) {\n    const char *pos = NULL;\n    apr_size_t tmplen = *len, buflen = *len, offset = 0;\n\n    *len = 0;\n\n    while (tmplen > 0)\n    {\n        apr_status_t status =\n            gnutls_io_input_read(ctxt, buf + offset, &tmplen);\n\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n\n        *len += tmplen;\n\n        if ((pos = memchr(buf, APR_ASCII_LF, *len))) {\n            break;\n        }\n\n        offset += tmplen;\n        tmplen = buflen - offset;\n    }\n\n    if (pos) {\n        char *value;\n        int length;\n        apr_size_t bytes = pos - buf;\n\n        bytes += 1;\n        value = buf + bytes;\n        length = *len - bytes;\n\n        char_buffer_write(&ctxt->input_cbuf, value, length);\n\n        *len = bytes;\n    }\n\n    return APR_SUCCESS;\n}\n\n#define HANDSHAKE_MAX_TRIES 1024\n\nstatic int gnutls_do_handshake(mgs_handle_t * ctxt) {\n    int ret;\n    int errcode;\n    int maxtries = HANDSHAKE_MAX_TRIES;\n\n    if (ctxt->status != 0 || ctxt->session == NULL) {\n        return -1;\n    }\n\n    /* Enable SNI and ALPN for proxy connections, and load cached\n     * session if any. */\n    if (ctxt->is_proxy == GNUTLS_ENABLED_TRUE)\n        mgs_set_proxy_handshake_ext(ctxt);\n\ntryagain:\n    do {\n        ret = gnutls_handshake(ctxt->session);\n        maxtries--;\n    } while ((ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN)\n            && maxtries > 0);\n\n    if (maxtries < 1) {\n        ctxt->status = -1;\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, ctxt->c,\n                \"GnuTLS: Handshake Failed. Hit Maximum Attempts\");\n        if (ctxt->session) {\n            gnutls_alert_send(ctxt->session, GNUTLS_AL_FATAL,\n                    gnutls_error_to_alert\n                    (GNUTLS_E_INTERNAL_ERROR, NULL));\n            gnutls_deinit(ctxt->session);\n        }\n        ctxt->session = NULL;\n        return -1;\n    }\n\n    if (ret < 0) {\n        if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED\n                || ret == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n            errcode = gnutls_alert_get(ctxt->session);\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                          \"GnuTLS: Handshake Alert (%d) '%s'.\",\n                          errcode, gnutls_alert_get_name(errcode));\n        }\n\n        if (!gnutls_error_is_fatal(ret)) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                          \"GnuTLS: Non-Fatal Handshake Error: (%d) '%s'\",\n                          ret, gnutls_strerror(ret));\n            goto tryagain;\n        }\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                \"GnuTLS: Handshake Failed (%d) '%s'\", ret,\n                gnutls_strerror(ret));\n        ctxt->status = -1;\n        if (ctxt->session) {\n            gnutls_alert_send(ctxt->session, GNUTLS_AL_FATAL,\n                    gnutls_error_to_alert(ret,\n                    NULL));\n            gnutls_deinit(ctxt->session);\n        }\n        ctxt->session = NULL;\n        return ret;\n    } else {\n        /* all done with the handshake */\n        ctxt->status = 1;\n        if (gnutls_session_is_resumed(ctxt->session))\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ctxt->c,\n                          \"%s: TLS session resumed.\", __func__);\n        }\n        return GNUTLS_E_SUCCESS;\n    }\n}\n\n\n\nint mgs_reauth(mgs_handle_t *ctxt, request_rec *r)\n{\n    if (ctxt->session == NULL)\n        return GNUTLS_E_INVALID_REQUEST;\n\n    /* Initialize to error to avoid false-good return value. */\n    int rv = GNUTLS_E_INTERNAL_ERROR;\n    int tries = 0;\n\n    do\n    {\n        rv = gnutls_reauth(ctxt->session, 0);\n        tries++;\n\n        /* GNUTLS_E_GOT_APPLICATION_DATA can (randomly, depending on\n         * timing) happen with a request containing a body. According to\n         * https://tools.ietf.org/html/rfc8446#appendix-E.1.2\n         * post-handshake authentication proves that the authenticated\n         * party is the one that did the handshake, so caching the data\n         * is appropriate. */\n        if (rv == GNUTLS_E_GOT_APPLICATION_DATA)\n        {\n            /* Fill connection input buffer using a speculative read. */\n            apr_size_t len = sizeof(ctxt->input_buffer);\n            ctxt->input_mode = AP_MODE_SPECULATIVE;\n            apr_status_t status =\n                gnutls_io_input_read(ctxt, ctxt->input_buffer, &len);\n            if (status == APR_SUCCESS)\n            {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,\n                              \"%s: cached %\" APR_SIZE_T_FMT \" bytes.\",\n                              __func__, len);\n                /* If the cache was too small to accept all pending data\n                 * we'll get GNUTLS_E_GOT_APPLICATION_DATA again, and the\n                 * authz hook will return HTTP_REQUEST_ENTITY_TOO_LARGE to\n                 * the client. */\n                rv = gnutls_reauth(ctxt->session, 0);\n            }\n            else\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r,\n                              \"%s: buffering request data failed!\",\n                              __func__);\n        }\n        /* Retry on GNUTLS_E_INTERRUPTED or GNUTLS_E_AGAIN, whether\n         * from initial gnutls_reauth() call or after buffering. */\n    } while (tries < HANDSHAKE_MAX_TRIES\n             && (rv == GNUTLS_E_INTERRUPTED || rv == GNUTLS_E_AGAIN));\n\n    if (rv != GNUTLS_E_SUCCESS)\n    {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"%s: post-handshake authentication failed: %s (%d)\",\n                      __func__, gnutls_strerror(rv), rv);\n        return rv;\n    }\n\n    return GNUTLS_E_SUCCESS;\n}\n\n\n\n/**\n * Close the TLS session associated with the given connection\n * structure and free its resources\n *\n * @param ctxt the mod_gnutls session context\n *\n * @return a GnuTLS status code, hopefully `GNUTLS_E_SUCCESS`\n */\nstatic int mgs_bye(mgs_handle_t* ctxt)\n{\n    int ret = GNUTLS_E_SUCCESS;\n    /* End Of Connection */\n    if (ctxt->session != NULL)\n    {\n        /* Try A Clean Shutdown */\n        do {\n            ret = gnutls_bye(ctxt->session, GNUTLS_SHUT_WR);\n        } while (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN);\n        if (ret != GNUTLS_E_SUCCESS)\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_EGENERAL, ctxt->c,\n                          \"%s: Error while closing TLS %sconnection: \"\n                          \"'%s' (%d)\",\n                          __func__, IS_PROXY_STR(ctxt),\n                          gnutls_strerror(ret), (int) ret);\n        else\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ctxt->c,\n                          \"%s: TLS %sconnection closed.\",\n                          __func__, IS_PROXY_STR(ctxt));\n        /* De-Initialize Session */\n        gnutls_deinit(ctxt->session);\n        ctxt->session = NULL;\n    }\n    return ret;\n}\n\n\n\napr_status_t mgs_filter_input(ap_filter_t * f,\n        apr_bucket_brigade * bb,\n        ap_input_mode_t mode,\n        apr_read_type_e block, apr_off_t readbytes)\n{\n    apr_status_t status = APR_SUCCESS;\n    mgs_handle_t *ctxt = (mgs_handle_t *) f->ctx;\n    apr_size_t len = sizeof (ctxt->input_buffer);\n\n    if (f->c->aborted) {\n        gnutls_io_filter_eos(f, bb);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,\n                      \"%s: %sconnection aborted\",\n                      __func__, IS_PROXY_STR(ctxt));\n        return APR_ECONNABORTED;\n    }\n\n    if (ctxt->status == 0) {\n        int ret = gnutls_do_handshake(ctxt);\n        if (ret == GNUTLS_E_SUCCESS)\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,\n                          \"%s: TLS %sconnection opened.\",\n                          __func__, IS_PROXY_STR(ctxt));\n    }\n\n    if (ctxt->status < 0)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, ctxt->c,\n                      \"%s: %sconnection failed, cannot provide data!\",\n                      __func__, IS_PROXY_STR(ctxt));\n        gnutls_io_filter_eos(f, bb);\n        return APR_ECONNABORTED;\n    }\n\n    /* XXX: we don't currently support anything other than these modes. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE &&\n            mode != AP_MODE_SPECULATIVE && mode != AP_MODE_INIT) {\n        return APR_ENOTIMPL;\n    }\n\n    ctxt->input_mode = mode;\n    ctxt->input_block = block;\n\n    if (ctxt->input_mode == AP_MODE_READBYTES ||\n            ctxt->input_mode == AP_MODE_SPECULATIVE) {\n        if (readbytes < 0) {\n            /* you're asking us to speculatively read a negative number of bytes! */\n            return APR_ENOTIMPL;\n        }\n        /* 'readbytes' and 'len' are of different integer types, which\n         * might have different lengths. Read sizes should be too\n         * small for 32 or 64 bit to matter, but we have to make\n         * sure. */\n#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)\n        if ((apr_size_t) readbytes < len)\n        {\n            /* If readbytes is negative the function fails in the\n             * check above, but the compiler doesn't get that. */\n            if (__builtin_expect(imaxabs(readbytes) > SIZE_MAX, 0))\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_CRIT, APR_EINVAL, ctxt->c,\n                              \"%s: prevented buffer length overflow\",\n                              __func__);\n                return APR_EINVAL;\n            }\n            len = (apr_size_t) readbytes;\n        }\n#else\n        if ((apr_size_t) readbytes < len\n            && __builtin_add_overflow(readbytes, 0, &len))\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_CRIT, APR_EINVAL, ctxt->c,\n                          \"%s: prevented buffer length overflow\",\n                          __func__);\n            return APR_EINVAL;\n        }\n#endif\n        status =\n                gnutls_io_input_read(ctxt, ctxt->input_buffer, &len);\n    } else if (ctxt->input_mode == AP_MODE_GETLINE) {\n        status =\n                gnutls_io_input_getline(ctxt, ctxt->input_buffer,\n                &len);\n    } else {\n        /* We have no idea what you are talking about, so return an error. */\n        return APR_ENOTIMPL;\n    }\n\n    if (status != APR_SUCCESS)\n    {\n        /* no data for nonblocking read, return APR_EAGAIN */\n        if ((block == APR_NONBLOCK_READ) && APR_STATUS_IS_EINTR(status))\n            return APR_EAGAIN;\n\n        /* Close TLS session and free resources on EOF,\n         * gnutls_io_filter_eos will add an EOS bucket */\n        if (APR_STATUS_IS_EOF(status))\n            mgs_bye(ctxt);\n\n        gnutls_io_filter_eos(f, bb);\n        return status;\n    }\n\n    /* Create a transient bucket out of the decrypted data. */\n    if (len > 0) {\n        apr_bucket *bucket =\n                apr_bucket_transient_create(ctxt->input_buffer, len,\n                f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, bucket);\n    }\n\n    return status;\n}\n\n/**\n * Try to flush the output bucket brigade.\n *\n * @param ctxt the mod_gnutls session context\n *\n * @return `1` on success, `-1` on failure.\n */\nstatic ssize_t write_flush(mgs_handle_t * ctxt) {\n    apr_bucket *e;\n\n    if (!(ctxt->output_blen || ctxt->output_length)) {\n        ctxt->output_rc = APR_SUCCESS;\n        return 1;\n    }\n\n    if (ctxt->output_blen) {\n        e = apr_bucket_transient_create(ctxt->output_buffer,\n                ctxt->output_blen,\n                ctxt->output_bb->\n                bucket_alloc);\n        /* we filled this buffer first so add it to the\n         * \t\t * head of the brigade\n         * \t\t \t\t */\n        APR_BRIGADE_INSERT_HEAD(ctxt->output_bb, e);\n        ctxt->output_blen = 0;\n    }\n\n    ctxt->output_length = 0;\n    e = apr_bucket_flush_create(ctxt->output_bb->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(ctxt->output_bb, e);\n\n    ctxt->output_rc = ap_pass_brigade(ctxt->output_filter->next,\n            ctxt->output_bb);\n    /* clear the brigade to be ready for next time */\n    apr_brigade_cleanup(ctxt->output_bb);\n\n    return (ctxt->output_rc == APR_SUCCESS) ? 1 : -1;\n}\n\napr_status_t mgs_filter_output(ap_filter_t * f, apr_bucket_brigade * bb) {\n    int ret;\n    mgs_handle_t *ctxt = (mgs_handle_t *) f->ctx;\n    apr_status_t status = APR_SUCCESS;\n    apr_read_type_e rblock = APR_NONBLOCK_READ;\n\n    if (f->c->aborted) {\n        apr_brigade_cleanup(bb);\n        return APR_ECONNABORTED;\n    }\n\n    if (ctxt->status == 0) {\n        ret = gnutls_do_handshake(ctxt);\n        if (ret == GNUTLS_E_SUCCESS)\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,\n                          \"%s: TLS %sconnection opened.\",\n                          __func__, IS_PROXY_STR(ctxt));\n        else if (ctxt->is_proxy)\n        {\n            /* If mod_proxy receives an error while trying to send its\n             * request it sends an \"invalid request\" error to the\n             * client. By pretending we could send the request\n             * mod_proxy continues its processing and sends a proper\n             * \"proxy error\" message when there's no response to read. */\n            gnutls_io_filter_eos(f, bb);\n            return APR_SUCCESS;\n        }\n        /* No final else here, the \"ctxt->status < 0\" check below will\n         * catch that. */\n    }\n\n    if (ctxt->status < 0)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, ctxt->c,\n                      \"%s: %sconnection failed, refusing to send.\",\n                      __func__, IS_PROXY_STR(ctxt));\n        return APR_ECONNABORTED;\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *bucket = APR_BRIGADE_FIRST(bb);\n\n        if (APR_BUCKET_IS_EOS(bucket)) {\n            return ap_pass_brigade(f->next, bb);\n        } else if (APR_BUCKET_IS_FLUSH(bucket)) {\n            /* Try Flush */\n            if (write_flush(ctxt) < 0) {\n                /* Flush Error */\n                return ctxt->output_rc;\n            }\n            /* cleanup! */\n            apr_bucket_delete(bucket);\n        } else if (AP_BUCKET_IS_EOC(bucket)) {\n            /* End Of Connection, close TLS session and free\n             * resources */\n            mgs_bye(ctxt);\n            /* cleanup! */\n            apr_bucket_delete(bucket);\n            /* Pass next brigade! */\n            return ap_pass_brigade(f->next, bb);\n        } else {\n            /* filter output */\n            const char *data;\n            apr_size_t len;\n\n            status = apr_bucket_read(bucket, &data, &len, rblock);\n\n            if (APR_STATUS_IS_EAGAIN(status)) {\n                /* No data available so Flush! */\n                if (write_flush(ctxt) < 0) {\n                    return ctxt->output_rc;\n                }\n                /* Try again with a blocking read. */\n                rblock = APR_BLOCK_READ;\n                continue;\n            }\n\n            rblock = APR_NONBLOCK_READ;\n\n            if (!APR_STATUS_IS_EOF(status)\n                    && (status != APR_SUCCESS)) {\n                return status;\n            }\n\n            if (len > 0) {\n\n                if (ctxt->session == NULL) {\n                    ret = GNUTLS_E_INVALID_REQUEST;\n                } else {\n                    do {\n                        ret =\n                                gnutls_record_send\n                                (ctxt->session, data,\n                                len);\n                    } while (ret == GNUTLS_E_INTERRUPTED\n                            || ret == GNUTLS_E_AGAIN);\n                }\n\n                if (ret < 0) {\n                    /* error sending output */\n                    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, ctxt->output_rc,\n                                  ctxt->c,\n                                  \"GnuTLS: Error writing data. (%d) '%s'\",\n                                  ret, gnutls_strerror(ret));\n                    if (ctxt->output_rc == APR_SUCCESS) {\n                        ctxt->output_rc =\n                                APR_EGENERAL;\n                        return ctxt->output_rc;\n                    }\n                } else if ((apr_size_t)(ret) != len) {\n                    /* we know the above cast is OK because len > 0 and ret >= 0 */\n                    /* Not able to send the entire bucket,\n                       split it and send it again. */\n                    apr_bucket_split(bucket, ret);\n                }\n            }\n\n            apr_bucket_delete(bucket);\n        }\n    }\n\n    return status;\n}\n\nint mgs_transport_read_ready(gnutls_transport_ptr_t ptr,\n                             unsigned int ms)\n{\n    mgs_handle_t *ctxt = ptr;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, APR_SUCCESS, ctxt->c,\n                  \"%s: called with %u ms wait\", __func__, ms);\n\n    apr_pool_t *tmp = NULL;\n    apr_status_t rv = apr_pool_create(&tmp, ctxt->c->pool);\n    if (rv != APR_SUCCESS)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_ENOMEM, ctxt->c,\n                      \"could not create temporary pool for %s\",\n                     __func__);\n        return -1;\n    }\n\n    apr_bucket_brigade *bb = apr_brigade_create(tmp, ctxt->c->bucket_alloc);\n\n    /* one byte non-blocking speculative read to see if there's data\n     * in the filter chain */\n    rv = ap_get_brigade(ctxt->input_filter->next, bb, AP_MODE_SPECULATIVE,\n                        APR_NONBLOCK_READ, 1);\n\n    int result;\n    if (rv == APR_SUCCESS && !APR_BRIGADE_EMPTY(bb))\n        result = 1;\n    else\n        result = 0;\n\n    apr_brigade_destroy(bb);\n\n    /* If GnuTLS doesn't want to wait or we already have data,\n     * return. */\n    if (ms == 0 || result == 1)\n    {\n        apr_pool_destroy(tmp);\n        return result;\n    }\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, APR_SUCCESS, ctxt->c,\n                  \"%s: waiting for data\", __func__);\n\n    /* No data yet, and we're supposed to wait, so wait for data on\n     * the socket. */\n    apr_socket_t *sock = ap_get_conn_socket(ctxt->c);\n    apr_interval_time_t timeout = -1;\n    apr_interval_time_t original_timeout;\n    rv = apr_socket_timeout_get(sock, &original_timeout);\n    if (rv != APR_SUCCESS)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, ctxt->c,\n                      \"%s: could not get socket timeout\",\n                      __func__);\n        apr_pool_destroy(tmp);\n        return -1;\n    }\n\n    /* If GnuTLS requests an \"indefinite\" wait we do not want to mess\n     * with whatever Apache does by default. Otherwise temporarily\n     * adjust the socket timeout. */\n    if (ms != GNUTLS_INDEFINITE_TIMEOUT)\n    {\n        /* apr_interval_time_t is in microseconds */\n        if (__builtin_mul_overflow(ms, 1000, &timeout))\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_ENOMEM, ctxt->c,\n                          \"%s: overflow while calculating timeout!\",\n                          __func__);\n            apr_pool_destroy(tmp);\n            return -1;\n        }\n        rv = apr_socket_timeout_set(sock, timeout);\n        if (rv != APR_SUCCESS)\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, ctxt->c,\n                          \"%s: could not set socket timeout\",\n                          __func__);\n            apr_pool_destroy(tmp);\n            return -1;\n        }\n    }\n\n#if APR_MAJOR_VERSION < 2\n    apr_pollfd_t pollset;\n    apr_int32_t nsds;\n    pollset.p = tmp;\n    pollset.desc_type = APR_POLL_SOCKET;\n    pollset.reqevents = APR_POLLIN | APR_POLLHUP;\n    pollset.desc.s = sock;\n    rv = apr_poll(&pollset, 1, &nsds, timeout);\n#else\n    rv = apr_socket_wait(sock, APR_WAIT_READ);\n#endif\n    apr_pool_destroy(tmp);\n\n    if (ms != GNUTLS_INDEFINITE_TIMEOUT)\n    {\n        /* We still need \"rv\" below, so new variable. */\n        apr_status_t rc = apr_socket_timeout_set(sock, original_timeout);\n        if (rc != APR_SUCCESS)\n        {\n            ap_log_cerror(APLOG_MARK, APLOG_CRIT, rc, ctxt->c,\n                          \"%s: could not restore socket timeout\",\n                          __func__);\n            return -1;\n        }\n    }\n\n    if (rv == APR_SUCCESS)\n        return 1;\n    else if (APR_STATUS_IS_TIMEUP(rv))\n        return 0;\n    else\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, ctxt->c,\n                      \"%s: waiting for data on connection socket failed\",\n                      __func__);\n        return -1;\n    }\n}\n\n/**\n * Pull function for GnuTLS\n *\n * Generic errnos used for `gnutls_transport_set_errno()`:\n * * `EAGAIN`: no data available at the moment, try again (maybe later)\n * * `EINTR`: read was interrupted, try again\n * * `EIO`: Unknown I/O error\n * * `ECONNABORTED`: Input BB does not exist (`NULL`)\n *\n * The reason we are not using `APR_TO_OS_ERROR` to map `apr_status_t`\n * to errnos is this warning [in the APR documentation][apr-warn]:\n *\n * > If the statcode was not created by apr_get_os_error or\n * > APR_FROM_OS_ERROR, the results are undefined.\n *\n * We cannot know if this applies to any error we might encounter.\n *\n * @param ptr GnuTLS session data pointer (the mod_gnutls context\n * structure)\n *\n * @param buffer buffer for the read data\n *\n * @param len maximum number of bytes to read (must fit into the\n * buffer)\n *\n * @return The number of bytes read (may be zero on EOF), or `-1` on\n * error. Note that some errors may warrant another try (see above).\n *\n * [apr-warn]: https://apr.apache.org/docs/apr/1.4/group__apr__errno.html#ga2385cae04b04afbdcb65f1a45c4d8506 \"Apache Portable Runtime: Error Codes\"\n */\nssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n                           void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n    apr_size_t in = len;\n    apr_read_type_e block = ctxt->input_block;\n\n    ctxt->input_rc = APR_SUCCESS;\n\n    /* If Len = 0, we don't do anything. */\n    if (!len || buffer == NULL)\n    {\n        return 0;\n    }\n    /* Input bucket brigade is missing, EOF */\n    if (!ctxt->input_bb)\n    {\n        ctxt->input_rc = APR_EOF;\n        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(ctxt->input_bb))\n    {\n        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,\n                                         ctxt->input_bb, AP_MODE_READBYTES,\n                                         ctxt->input_block, in);\n\n        /* Not a problem, there was simply no data ready yet.\n         */\n        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)\n            || (rc == APR_SUCCESS\n                && APR_BRIGADE_EMPTY(ctxt->input_bb)))\n        {\n            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but\n             * it's the best matching error code for \"didn't get data,\n             * but read didn't permanently fail either.\" */\n            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        /* Blocking ap_get_brigade() can return a timeout status,\n         * sometimes after a very short time. \"Don't give up, just\n         * return the timeout\" is what mod_ssl does. */\n        if (ctxt->input_block == APR_BLOCK_READ\n            && APR_STATUS_IS_TIMEUP(rc)\n            && APR_BRIGADE_EMPTY(ctxt->input_bb))\n        {\n            ctxt->input_rc = rc;\n            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);\n            return -1;\n        }\n\n        if (rc != APR_SUCCESS)\n        {\n            /* Unexpected errors discard the brigade */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,\n                          \"%s: Unexpected error!\", __func__);\n            apr_brigade_cleanup(ctxt->input_bb);\n            ctxt->input_bb = NULL;\n            gnutls_transport_set_errno(ctxt->session, EIO);\n            return -1;\n        }\n    }\n\n    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);\n\n    if (ctxt->input_rc == APR_SUCCESS)\n    {\n        return (ssize_t) len;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)\n        || APR_STATUS_IS_EINTR(ctxt->input_rc))\n    {\n        if (len == 0)\n        {\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) len;\n    }\n\n    /* Unexpected errors and APR_EOF clean out the brigade.\n     * Subsequent calls will return APR_EOF. */\n    apr_brigade_cleanup(ctxt->input_bb);\n    ctxt->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)\n    {\n        /* Some data has been received before EOF, return it. */\n        return (ssize_t) len;\n    }\n\n    gnutls_transport_set_errno(ctxt->session, EIO);\n    return -1;\n}\n\n/**\n * Push function for GnuTLS\n *\n * `gnutls_transport_set_errno()` will be called with `EAGAIN` or\n * `EINTR` on recoverable errors, or `EIO` in case of unexpected\n * errors. See the description of mgs_transport_read() for details on\n * possible error codes.\n *\n * @param ptr GnuTLS session data pointer (the mod_gnutls context\n * structure)\n *\n * @param buffer buffer containing the data to send\n *\n * @param len length of the data\n * buffer)\n *\n * @return The number of written bytes, or `-1` on error. Note that\n * some errors may warrant another try (see above).\n */\nssize_t mgs_transport_write(gnutls_transport_ptr_t ptr,\n                            const void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n\n    /* pass along the encrypted data\n     * need to flush since we're using SSL's malloc-ed buffer\n     * which will be overwritten once we leave here\n     */\n    apr_bucket *bucket = apr_bucket_transient_create(buffer, len,\n            ctxt->output_bb->\n            bucket_alloc);\n    ctxt->output_length += len;\n    APR_BRIGADE_INSERT_TAIL(ctxt->output_bb, bucket);\n\n    if (write_flush(ctxt) < 0)\n    {\n        /* We encountered an error. APR_EINTR or APR_EAGAIN can be\n         * handled, treat everything else as a generic I/O error. */\n        int err = EIO;\n        if (APR_STATUS_IS_EAGAIN(ctxt->output_rc)\n            || APR_STATUS_IS_EINTR(ctxt->output_rc))\n            err = EAI_APR_TO_RAW(ctxt->output_rc);\n\n        gnutls_transport_set_errno(ctxt->session, err);\n        return -1;\n    }\n    return len;\n}\n"], "filenames": ["src/gnutls_io.c"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [1007], "fixing_code_start_loc": [5], "fixing_code_end_loc": [1012], "type": "CWE-835", "message": "Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on TLS connections when the transport hit timeouts. Instead it entered an endless loop retrying the read operation, consuming CPU resources. This could be exploited for denial of service attacks. If trace level logging was enabled, it would also produce an excessive amount of log output during the loop, consuming disk space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec, please update to version 0.12.1. There are no workarounds, users who cannot update should apply the errno fix detailed in the security advisory.", "other": {"cve": {"id": "CVE-2023-25824", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-23T22:15:11.670", "lastModified": "2023-05-16T20:54:11.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on TLS connections when the transport hit timeouts. Instead it entered an endless loop retrying the read operation, consuming CPU resources. This could be exploited for denial of service attacks. If trace level logging was enabled, it would also produce an excessive amount of log output during the loop, consuming disk space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec, please update to version 0.12.1. There are no workarounds, users who cannot update should apply the errno fix detailed in the security advisory."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mod_gnutls_project:mod_gnutls:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.0", "versionEndExcluding": "0.12.1", "matchCriteriaId": "3450A7C9-BABB-46EB-9418-CCBE904DB84C"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Mailing List", "Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/airtower-luna/mod_gnutls/security/advisories/GHSA-6cfv-fvgm-7pc8", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec"}}