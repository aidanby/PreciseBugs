{"buggy_code": ["/*\n *\tLinux NET3:\tIP/IP protocol decoder.\n *\n *\tAuthors:\n *\t\tSam Lantinga (slouken@cs.ucdavis.edu)  02/01/95\n *\n *\tFixes:\n *\t\tAlan Cox\t:\tMerged and made usable non modular (its so tiny its silly as\n *\t\t\t\t\ta module taking up 2 pages).\n *\t\tAlan Cox\t: \tFixed bug with 1.3.18 and IPIP not working (now needs to set skb->h.iph)\n *\t\t\t\t\tto keep ip_forward happy.\n *\t\tAlan Cox\t:\tMore fixes for 1.3.21, and firewall fix. Maybe this will work soon 8).\n *\t\tKai Schulte\t:\tFixed #defines for IP_FIREWALL->FIREWALL\n *              David Woodhouse :       Perform some basic ICMP handling.\n *                                      IPIP Routing without decapsulation.\n *              Carlos Picoto   :       GRE over IP support\n *\t\tAlexey Kuznetsov:\tReworked. Really, now it is truncated version of ipv4/ip_gre.c.\n *\t\t\t\t\tI do not want to merge them together.\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n */\n\n/* tunnel.c: an IP tunnel driver\n\n\tThe purpose of this driver is to provide an IP tunnel through\n\twhich you can tunnel network traffic transparently across subnets.\n\n\tThis was written by looking at Nick Holloway's dummy driver\n\tThanks for the great code!\n\n\t\t-Sam Lantinga\t(slouken@cs.ucdavis.edu)  02/01/95\n\n\tMinor tweaks:\n\t\tCleaned up the code a little and added some pre-1.3.0 tweaks.\n\t\tdev->hard_header/hard_header_len changed to use no headers.\n\t\tComments/bracketing tweaked.\n\t\tMade the tunnels use dev->name not tunnel: when error reporting.\n\t\tAdded tx_dropped stat\n\n\t\t-Alan Cox\t(alan@lxorguk.ukuu.org.uk) 21 March 95\n\n\tReworked:\n\t\tChanged to tunnel to destination gateway in addition to the\n\t\t\ttunnel's pointopoint address\n\t\tAlmost completely rewritten\n\t\tNote:  There is currently no firewall or ICMP handling done.\n\n\t\t-Sam Lantinga\t(slouken@cs.ucdavis.edu) 02/13/96\n\n*/\n\n/* Things I wish I had known when writing the tunnel driver:\n\n\tWhen the tunnel_xmit() function is called, the skb contains the\n\tpacket to be sent (plus a great deal of extra info), and dev\n\tcontains the tunnel device that _we_ are.\n\n\tWhen we are passed a packet, we are expected to fill in the\n\tsource address with our source IP address.\n\n\tWhat is the proper way to allocate, copy and free a buffer?\n\tAfter you allocate it, it is a \"0 length\" chunk of memory\n\tstarting at zero.  If you want to add headers to the buffer\n\tlater, you'll have to call \"skb_reserve(skb, amount)\" with\n\tthe amount of memory you want reserved.  Then, you call\n\t\"skb_put(skb, amount)\" with the amount of space you want in\n\tthe buffer.  skb_put() returns a pointer to the top (#0) of\n\tthat buffer.  skb->len is set to the amount of space you have\n\t\"allocated\" with skb_put().  You can then write up to skb->len\n\tbytes to that buffer.  If you need more, you can call skb_put()\n\tagain with the additional amount of space you need.  You can\n\tfind out how much more space you can allocate by calling\n\t\"skb_tailroom(skb)\".\n\tNow, to add header space, call \"skb_push(skb, header_len)\".\n\tThis creates space at the beginning of the buffer and returns\n\ta pointer to this new space.  If later you need to strip a\n\theader from a buffer, call \"skb_pull(skb, header_len)\".\n\tskb_headroom() will return how much space is left at the top\n\tof the buffer (before the main data).  Remember, this headroom\n\tspace must be reserved before the skb_put() function is called.\n\t*/\n\n/*\n   This version of net/ipv4/ipip.c is cloned of net/ipv4/ip_gre.c\n\n   For comments look at net/ipv4/ip_gre.c --ANK\n */\n\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <asm/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/mroute.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/ipip.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#define HASH_SIZE  16\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\nstatic int ipip_net_id __read_mostly;\nstruct ipip_net {\n\tstruct ip_tunnel *tunnels_r_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_r[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_wc[1];\n\tstruct ip_tunnel **tunnels[4];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\nstatic void ipip_tunnel_init(struct net_device *dev);\nstatic void ipip_tunnel_setup(struct net_device *dev);\n\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ipip_lock);\n\n#define for_each_ip_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\nstatic struct ip_tunnel * ipip_tunnel_lookup(struct net *net,\n\t\t__be32 remote, __be32 local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_r_l[h0 ^ h1])\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_r[h0])\n\t\tif (remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_l[h1])\n\t\tif (local == t->parms.iph.saddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tt = rcu_dereference(ipn->tunnels_wc[0]);\n\tif (t && (t->dev->flags&IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}\n\nstatic struct ip_tunnel **__ipip_bucket(struct ipip_net *ipn,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (remote) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\tif (local) {\n\t\tprio |= 1;\n\t\th ^= HASH(local);\n\t}\n\treturn &ipn->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel **ipip_bucket(struct ipip_net *ipn,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipip_bucket(ipn, &t->parms);\n}\n\nstatic void ipip_tunnel_unlink(struct ipip_net *ipn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp;\n\n\tfor (tp = ipip_bucket(ipn, t); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ipip_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ipip_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ipip_tunnel_link(struct ipip_net *ipn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp = ipip_bucket(ipn, t);\n\n\tspin_lock_bh(&ipip_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ipip_lock);\n}\n\nstatic struct ip_tunnel * ipip_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tstruct ip_tunnel *t, **tp, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tfor (tp = __ipip_bucket(ipn, parms); (t = *tp) != NULL; tp = &t->next) {\n\t\tif (local == t->parms.iph.saddr && remote == t->parms.iph.daddr)\n\t\t\treturn t;\n\t}\n\tif (!create)\n\t\treturn NULL;\n\n\tif (parms->name[0])\n\t\tstrlcpy(name, parms->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"tunl%%d\");\n\n\tdev = alloc_netdev(sizeof(*t), name, ipip_tunnel_setup);\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tnt = netdev_priv(dev);\n\tnt->parms = *parms;\n\n\tipip_tunnel_init(dev);\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\tipip_tunnel_link(ipn, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstatic void ipip_tunnel_uninit(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tif (dev == ipn->fb_tunnel_dev) {\n\t\tspin_lock_bh(&ipip_lock);\n\t\tipn->tunnels_wc[0] = NULL;\n\t\tspin_unlock_bh(&ipip_lock);\n\t} else\n\t\tipip_tunnel_unlink(ipn, netdev_priv(dev));\n\tdev_put(dev);\n}\n\nstatic int ipip_err(struct sk_buff *skb, u32 info)\n{\n\n/* All the routers (except for Linux) return only\n   8 bytes of packet payload. It means, that precise relaying of\n   ICMP in the real Internet is absolutely infeasible.\n */\n\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t/* Impossible event. */\n\t\t\treturn 0;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t/* Soft state for pmtu is maintained by IP core. */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\terr = -ENOENT;\n\n\trcu_read_lock();\n\tt = ipip_tunnel_lookup(dev_net(skb->dev), iph->daddr, iph->saddr);\n\tif (t == NULL || t->parms.iph.daddr == 0)\n\t\tgoto out;\n\n\terr = 0;\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic inline void ipip_ecn_decapsulate(const struct iphdr *outer_iph,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct iphdr *inner_iph = ip_hdr(skb);\n\n\tif (INET_ECN_is_ce(outer_iph->tos))\n\t\tIP_ECN_set_ce(inner_iph);\n}\n\nstatic int ipip_rcv(struct sk_buff *skb)\n{\n\tstruct ip_tunnel *tunnel;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\n\trcu_read_lock();\n\tif ((tunnel = ipip_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tsecpath_reset(skb);\n\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\ttunnel->dev->stats.rx_packets++;\n\t\ttunnel->dev->stats.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\t\tipip_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn -1;\n}\n\n/*\n *\tThis function assumes it is being called from dev_queue_xmit()\n *\tand that skb is filled properly by that function.\n */\n\nstatic netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\tstruct iphdr  *tiph = &tunnel->parms.iph;\n\tu8     tos = tunnel->parms.iph.tos;\n\t__be16 df = tiph->frag_off;\n\tstruct rtable *rt;     \t\t\t/* Route to the other host */\n\tstruct net_device *tdev;\t\t\t/* Device to other host */\n\tstruct iphdr  *old_iph = ip_hdr(skb);\n\tstruct iphdr  *iph;\t\t\t/* Our new IP header */\n\tunsigned int max_headroom;\t\t/* The extra header space needed */\n\t__be32 dst = tiph->daddr;\n\tint    mtu;\n\n\tif (skb->protocol != htons(ETH_P_IP))\n\t\tgoto tx_error;\n\n\tif (tos&1)\n\t\ttos = old_iph->tos;\n\n\tif (!dst) {\n\t\t/* NBMA tunnel */\n\t\tif ((rt = skb_rtable(skb)) == NULL) {\n\t\t\tstats->tx_fifo_errors++;\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif ((dst = rt->rt_gateway) == 0)\n\t\t\tgoto tx_error_icmp;\n\t}\n\n\t{\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = dst,\n\t\t\t\t\t\t.saddr = tiph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(tos) } },\n\t\t\t\t    .proto = IPPROTO_IPIP };\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\tstats->tx_carrier_errors++;\n\t\t\tgoto tx_error_icmp;\n\t\t}\n\t}\n\ttdev = rt->u.dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tstats->collisions++;\n\t\tgoto tx_error;\n\t}\n\n\tdf |= old_iph->frag_off & htons(IP_DF);\n\n\tif (df) {\n\t\tmtu = dst_mtu(&rt->u.dst) - sizeof(struct iphdr);\n\n\t\tif (mtu < 68) {\n\t\t\tstats->collisions++;\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (skb_dst(skb))\n\t\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\n\t\tif ((old_iph->frag_off & htons(IP_DF)) &&\n\t\t    mtu < ntohs(old_iph->tot_len)) {\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t  htonl(mtu));\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\t/*\n\t * Okay, now see if we can stuff it in the buffer as-is.\n\t */\n\tmax_headroom = (LL_RESERVED_SPACE(tdev)+sizeof(struct iphdr));\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\ttxq->tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\told_iph = ip_hdr(skb);\n\t}\n\n\tskb->transport_header = skb->network_header;\n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\n\t\t\t      IPSKB_REROUTED);\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->u.dst);\n\n\t/*\n\t *\tPush down and install the IPIP header.\n\t */\n\n\tiph \t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr)>>2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tIPPROTO_IPIP;\n\tiph->tos\t\t=\tINET_ECN_encapsulate(tos, old_iph->tos);\n\tiph->daddr\t\t=\trt->rt_dst;\n\tiph->saddr\t\t=\trt->rt_src;\n\n\tif ((iph->ttl = tiph->ttl) == 0)\n\t\tiph->ttl\t=\told_iph->ttl;\n\n\tnf_reset(skb);\n\n\tIPTUNNEL_XMIT();\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\ntx_error:\n\tstats->tx_errors++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipip_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\tif (iph->daddr) {\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = iph->daddr,\n\t\t\t\t\t\t.saddr = iph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(iph->tos) } },\n\t\t\t\t    .proto = IPPROTO_IPIP };\n\t\tstruct rtable *rt;\n\t\tif (!ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\ttdev = rt->u.dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\n\n\tif (tdev) {\n\t\tdev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);\n\t\tdev->mtu = tdev->mtu - sizeof(struct iphdr);\n\t}\n\tdev->iflink = tunnel->parms.link;\n}\n\nstatic int\nipip_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel *t;\n\tstruct net *net = dev_net(dev);\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tt = NULL;\n\t\tif (dev == ipn->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ipip_tunnel_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\t\tmemcpy(&p, &t->parms, sizeof(p));\n\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPIP ||\n\t\t    p.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\n\t\t\tgoto done;\n\t\tif (p.iph.ttl)\n\t\t\tp.iph.frag_off |= htons(IP_DF);\n\n\t\tt = ipip_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != ipn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||\n\t\t\t\t    (!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt = netdev_priv(dev);\n\t\t\t\tipip_tunnel_unlink(ipn, t);\n\t\t\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\t\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t\t\tipip_tunnel_link(ipn, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\t\tt->parms.iph.ttl = p.iph.ttl;\n\t\t\t\tt->parms.iph.tos = p.iph.tos;\n\t\t\t\tt->parms.iph.frag_off = p.iph.frag_off;\n\t\t\t\tif (t->parms.link != p.link) {\n\t\t\t\t\tt->parms.link = p.link;\n\t\t\t\t\tipip_tunnel_bind_dev(dev);\n\t\t\t\t\tnetdev_state_change(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == ipn->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ipip_tunnel_locate(net, &p, 0)) == NULL)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t->dev == ipn->fb_tunnel_dev)\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ipip_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < 68 || new_mtu > 0xFFF8 - sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops ipip_netdev_ops = {\n\t.ndo_uninit\t= ipip_tunnel_uninit,\n\t.ndo_start_xmit\t= ipip_tunnel_xmit,\n\t.ndo_do_ioctl\t= ipip_tunnel_ioctl,\n\t.ndo_change_mtu\t= ipip_tunnel_change_mtu,\n\n};\n\nstatic void ipip_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipip_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\n\tdev->type\t\t= ARPHRD_TUNNEL;\n\tdev->hard_header_len \t= LL_MAX_HEADER + sizeof(struct iphdr);\n\tdev->mtu\t\t= ETH_DATA_LEN - sizeof(struct iphdr);\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->iflink\t\t= 0;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n}\n\nstatic void ipip_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\tipip_tunnel_bind_dev(dev);\n}\n\nstatic void __net_init ipip_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct ipip_net *ipn = net_generic(dev_net(dev), ipip_net_id);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_IPIP;\n\tiph->ihl\t\t= 5;\n\n\tdev_hold(dev);\n\tipn->tunnels_wc[0]\t= tunnel;\n}\n\nstatic struct xfrm_tunnel ipip_handler = {\n\t.handler\t=\tipip_rcv,\n\t.err_handler\t=\tipip_err,\n\t.priority\t=\t1,\n};\n\nstatic const char banner[] __initconst =\n\tKERN_INFO \"IPv4 over IPv4 tunneling driver\\n\";\n\nstatic void ipip_destroy_tunnels(struct ipip_net *ipn, struct list_head *head)\n{\n\tint prio;\n\n\tfor (prio = 1; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\t\tstruct ip_tunnel *t = ipn->tunnels[prio][h];\n\n\t\t\twhile (t != NULL) {\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t\t\t\tt = t->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init ipip_init_net(struct net *net)\n{\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\tint err;\n\n\tipn->tunnels[0] = ipn->tunnels_wc;\n\tipn->tunnels[1] = ipn->tunnels_l;\n\tipn->tunnels[2] = ipn->tunnels_r;\n\tipn->tunnels[3] = ipn->tunnels_r_l;\n\n\tipn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel),\n\t\t\t\t\t   \"tunl0\",\n\t\t\t\t\t   ipip_tunnel_setup);\n\tif (!ipn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(ipn->fb_tunnel_dev, net);\n\n\tipip_fb_tunnel_init(ipn->fb_tunnel_dev);\n\n\tif ((err = register_netdev(ipn->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tfree_netdev(ipn->fb_tunnel_dev);\nerr_alloc_dev:\n\t/* nothing */\n\treturn err;\n}\n\nstatic void __net_exit ipip_exit_net(struct net *net)\n{\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tipip_destroy_tunnels(ipn, &list);\n\tunregister_netdevice_queue(ipn->fb_tunnel_dev, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ipip_net_ops = {\n\t.init = ipip_init_net,\n\t.exit = ipip_exit_net,\n\t.id   = &ipip_net_id,\n\t.size = sizeof(struct ipip_net),\n};\n\nstatic int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\n\treturn err;\n}\n\nstatic void __exit ipip_fini(void)\n{\n\tif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\n\t\tprintk(KERN_INFO \"ipip close: can't deregister tunnel\\n\");\n\n\tunregister_pernet_device(&ipip_net_ops);\n}\n\nmodule_init(ipip_init);\nmodule_exit(ipip_fini);\nMODULE_LICENSE(\"GPL\");\n", "/*\n *\tIPv6 tunneling device\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tVille Nuorvala\t\t<vnuorval@tcs.hut.fi>\n *\tYasuyuki Kozakai\t<kozakai@linux-ipv6.org>\n *\n *      Based on:\n *      linux/net/ipv6/sit.c and linux/net/ipv4/ipip.c\n *\n *      RFC 2473\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/sockios.h>\n#include <linux/icmp.h>\n#include <linux/if.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/if_tunnel.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/route.h>\n#include <linux/rtnetlink.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <asm/uaccess.h>\n#include <asm/atomic.h>\n\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ip6_tunnel.h>\n#include <net/xfrm.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\nMODULE_AUTHOR(\"Ville Nuorvala\");\nMODULE_DESCRIPTION(\"IPv6 tunneling device\");\nMODULE_LICENSE(\"GPL\");\n\n#define IPV6_TLV_TEL_DST_SIZE 8\n\n#ifdef IP6_TNL_DEBUG\n#define IP6_TNL_TRACE(x...) printk(KERN_DEBUG \"%s:\" x \"\\n\", __func__)\n#else\n#define IP6_TNL_TRACE(x...) do {;} while(0)\n#endif\n\n#define IPV6_TCLASS_MASK (IPV6_FLOWINFO_MASK & ~IPV6_FLOWLABEL_MASK)\n#define IPV6_TCLASS_SHIFT 20\n\n#define HASH_SIZE  32\n\n#define HASH(addr) ((__force u32)((addr)->s6_addr32[0] ^ (addr)->s6_addr32[1] ^ \\\n\t\t     (addr)->s6_addr32[2] ^ (addr)->s6_addr32[3]) & \\\n\t\t    (HASH_SIZE - 1))\n\nstatic void ip6_tnl_dev_init(struct net_device *dev);\nstatic void ip6_tnl_dev_setup(struct net_device *dev);\n\nstatic int ip6_tnl_net_id __read_mostly;\nstruct ip6_tnl_net {\n\t/* the IPv6 tunnel fallback device */\n\tstruct net_device *fb_tnl_dev;\n\t/* lists for storing tunnels in use */\n\tstruct ip6_tnl *tnls_r_l[HASH_SIZE];\n\tstruct ip6_tnl *tnls_wc[1];\n\tstruct ip6_tnl **tnls[2];\n};\n\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ip6_tnl_lock);\n\nstatic inline struct dst_entry *ip6_tnl_dst_check(struct ip6_tnl *t)\n{\n\tstruct dst_entry *dst = t->dst_cache;\n\n\tif (dst && dst->obsolete &&\n\t    dst->ops->check(dst, t->dst_cookie) == NULL) {\n\t\tt->dst_cache = NULL;\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\treturn dst;\n}\n\nstatic inline void ip6_tnl_dst_reset(struct ip6_tnl *t)\n{\n\tdst_release(t->dst_cache);\n\tt->dst_cache = NULL;\n}\n\nstatic inline void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) dst;\n\tt->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;\n\tdst_release(t->dst_cache);\n\tt->dst_cache = dst;\n}\n\n/**\n * ip6_tnl_lookup - fetch tunnel matching the end-point addresses\n *   @remote: the address of the tunnel exit-point\n *   @local: the address of the tunnel entry-point\n *\n * Return:\n *   tunnel matching given end-points if found,\n *   else fallback tunnel if its device is up,\n *   else %NULL\n **/\n\n#define for_each_ip6_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\nstatic struct ip6_tnl *\nip6_tnl_lookup(struct net *net, struct in6_addr *remote, struct in6_addr *local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip6_tnl *t;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tfor_each_ip6_tunnel_rcu(ip6n->tnls_r_l[h0 ^ h1]) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tt = rcu_dereference(ip6n->tnls_wc[0]);\n\tif (t && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\n\treturn NULL;\n}\n\n/**\n * ip6_tnl_bucket - get head of list matching given tunnel parameters\n *   @p: parameters containing tunnel end-points\n *\n * Description:\n *   ip6_tnl_bucket() returns the head of the list matching the\n *   &struct in6_addr entries laddr and raddr in @p.\n *\n * Return: head of IPv6 tunnel list\n **/\n\nstatic struct ip6_tnl **\nip6_tnl_bucket(struct ip6_tnl_net *ip6n, struct ip6_tnl_parm *p)\n{\n\tstruct in6_addr *remote = &p->raddr;\n\tstruct in6_addr *local = &p->laddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\n\t\tprio = 1;\n\t\th = HASH(remote) ^ HASH(local);\n\t}\n\treturn &ip6n->tnls[prio][h];\n}\n\n/**\n * ip6_tnl_link - add tunnel to hash table\n *   @t: tunnel to be added\n **/\n\nstatic void\nip6_tnl_link(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl **tp = ip6_tnl_bucket(ip6n, &t->parms);\n\n\tspin_lock_bh(&ip6_tnl_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ip6_tnl_lock);\n}\n\n/**\n * ip6_tnl_unlink - remove tunnel from hash table\n *   @t: tunnel to be removed\n **/\n\nstatic void\nip6_tnl_unlink(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl **tp;\n\n\tfor (tp = ip6_tnl_bucket(ip6n, &t->parms); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ip6_tnl_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ip6_tnl_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * ip6_tnl_create() - create a new tunnel\n *   @p: tunnel parameters\n *   @pt: pointer to new tunnel\n *\n * Description:\n *   Create tunnel matching given parameters.\n *\n * Return:\n *   created tunnel or NULL\n **/\n\nstatic struct ip6_tnl *ip6_tnl_create(struct net *net, struct ip6_tnl_parm *p)\n{\n\tstruct net_device *dev;\n\tstruct ip6_tnl *t;\n\tchar name[IFNAMSIZ];\n\tint err;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tif (p->name[0])\n\t\tstrlcpy(name, p->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"ip6tnl%%d\");\n\n\tdev = alloc_netdev(sizeof (*t), name, ip6_tnl_dev_setup);\n\tif (dev == NULL)\n\t\tgoto failed;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tt = netdev_priv(dev);\n\tt->parms = *p;\n\tip6_tnl_dev_init(dev);\n\n\tif ((err = register_netdevice(dev)) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\tip6_tnl_link(ip6n, t);\n\treturn t;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\n\n/**\n * ip6_tnl_locate - find or create tunnel matching given parameters\n *   @p: tunnel parameters\n *   @create: != 0 if allowed to create new tunnel if no match found\n *\n * Description:\n *   ip6_tnl_locate() first tries to locate an existing tunnel\n *   based on @parms. If this is unsuccessful, but @create is set a new\n *   tunnel device is created and registered for use.\n *\n * Return:\n *   matching tunnel or NULL\n **/\n\nstatic struct ip6_tnl *ip6_tnl_locate(struct net *net,\n\t\tstruct ip6_tnl_parm *p, int create)\n{\n\tstruct in6_addr *remote = &p->raddr;\n\tstruct in6_addr *local = &p->laddr;\n\tstruct ip6_tnl *t;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tfor (t = *ip6_tnl_bucket(ip6n, p); t; t = t->next) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr))\n\t\t\treturn t;\n\t}\n\tif (!create)\n\t\treturn NULL;\n\treturn ip6_tnl_create(net, p);\n}\n\n/**\n * ip6_tnl_dev_uninit - tunnel device uninitializer\n *   @dev: the device to be destroyed\n *\n * Description:\n *   ip6_tnl_dev_uninit() removes tunnel from its list\n **/\n\nstatic void\nip6_tnl_dev_uninit(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tif (dev == ip6n->fb_tnl_dev) {\n\t\tspin_lock_bh(&ip6_tnl_lock);\n\t\tip6n->tnls_wc[0] = NULL;\n\t\tspin_unlock_bh(&ip6_tnl_lock);\n\t} else {\n\t\tip6_tnl_unlink(ip6n, t);\n\t}\n\tip6_tnl_dst_reset(t);\n\tdev_put(dev);\n}\n\n/**\n * parse_tvl_tnl_enc_lim - handle encapsulation limit option\n *   @skb: received socket buffer\n *\n * Return:\n *   0 if none was found,\n *   else index to encapsulation limit\n **/\n\nstatic __u16\nparse_tlv_tnl_enc_lim(struct sk_buff *skb, __u8 * raw)\n{\n\tstruct ipv6hdr *ipv6h = (struct ipv6hdr *) raw;\n\t__u8 nexthdr = ipv6h->nexthdr;\n\t__u16 off = sizeof (*ipv6h);\n\n\twhile (ipv6_ext_hdr(nexthdr) && nexthdr != NEXTHDR_NONE) {\n\t\t__u16 optlen = 0;\n\t\tstruct ipv6_opt_hdr *hdr;\n\t\tif (raw + off + sizeof (*hdr) > skb->data &&\n\t\t    !pskb_may_pull(skb, raw - skb->data + off + sizeof (*hdr)))\n\t\t\tbreak;\n\n\t\thdr = (struct ipv6_opt_hdr *) (raw + off);\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\tstruct frag_hdr *frag_hdr = (struct frag_hdr *) hdr;\n\t\t\tif (frag_hdr->frag_off)\n\t\t\t\tbreak;\n\t\t\toptlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH) {\n\t\t\toptlen = (hdr->hdrlen + 2) << 2;\n\t\t} else {\n\t\t\toptlen = ipv6_optlen(hdr);\n\t\t}\n\t\tif (nexthdr == NEXTHDR_DEST) {\n\t\t\t__u16 i = off + 2;\n\t\t\twhile (1) {\n\t\t\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\n\t\t\t\t/* No more room for encapsulation limit */\n\t\t\t\tif (i + sizeof (*tel) > off + optlen)\n\t\t\t\t\tbreak;\n\n\t\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &raw[i];\n\t\t\t\t/* return index of option if found and valid */\n\t\t\t\tif (tel->type == IPV6_TLV_TNL_ENCAP_LIMIT &&\n\t\t\t\t    tel->length == 1)\n\t\t\t\t\treturn i;\n\t\t\t\t/* else jump to next option */\n\t\t\t\tif (tel->type)\n\t\t\t\t\ti += tel->length + 2;\n\t\t\t\telse\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tnexthdr = hdr->nexthdr;\n\t\toff += optlen;\n\t}\n\treturn 0;\n}\n\n/**\n * ip6_tnl_err - tunnel error handler\n *\n * Description:\n *   ip6_tnl_err() should handle errors in the tunnel according\n *   to the specifications in RFC 2473.\n **/\n\nstatic int\nip6_tnl_err(struct sk_buff *skb, __u8 ipproto, struct inet6_skb_parm *opt,\n\t    u8 *type, u8 *code, int *msg, __u32 *info, int offset)\n{\n\tstruct ipv6hdr *ipv6h = (struct ipv6hdr *) skb->data;\n\tstruct ip6_tnl *t;\n\tint rel_msg = 0;\n\tu8 rel_type = ICMPV6_DEST_UNREACH;\n\tu8 rel_code = ICMPV6_ADDR_UNREACH;\n\t__u32 rel_info = 0;\n\t__u16 len;\n\tint err = -ENOENT;\n\n\t/* If the packet doesn't contain the original IPv6 header we are\n\t   in trouble since we might need the source address for further\n\t   processing of the error. */\n\n\trcu_read_lock();\n\tif ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->daddr,\n\t\t\t\t\t&ipv6h->saddr)) == NULL)\n\t\tgoto out;\n\n\tif (t->parms.proto != ipproto && t->parms.proto != 0)\n\t\tgoto out;\n\n\terr = 0;\n\n\tswitch (*type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Path to destination invalid \"\n\t\t\t       \"or inactive!\\n\", t->parms.name);\n\t\trel_msg = 1;\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif ((*code) == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"%s: Too small hop limit or \"\n\t\t\t\t       \"routing loop in tunnel!\\n\",\n\t\t\t\t       t->parms.name);\n\t\t\trel_msg = 1;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif ((*code) == ICMPV6_HDR_FIELD)\n\t\t\tteli = parse_tlv_tnl_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == *info - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"%s: Too small encapsulation \"\n\t\t\t\t\t       \"limit or routing loop in \"\n\t\t\t\t\t       \"tunnel!\\n\", t->parms.name);\n\t\t\t\trel_msg = 1;\n\t\t\t}\n\t\t} else if (net_ratelimit()) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Recipient unable to parse tunneled \"\n\t\t\t       \"packet!\\n \", t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = *info - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\n\t\tif ((len = sizeof (*ipv6h) + ntohs(ipv6h->payload_len)) > mtu) {\n\t\t\trel_type = ICMPV6_PKT_TOOBIG;\n\t\t\trel_code = 0;\n\t\t\trel_info = mtu;\n\t\t\trel_msg = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\t*type = rel_type;\n\t*code = rel_code;\n\t*info = rel_info;\n\t*msg = rel_msg;\n\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int\nip4ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t   u8 type, u8 code, int offset, __be32 info)\n{\n\tint rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\t__u32 rel_info = ntohl(info);\n\tint err;\n\tstruct sk_buff *skb2;\n\tstruct iphdr *eiph;\n\tstruct flowi fl;\n\tstruct rtable *rt;\n\n\terr = ip6_tnl_err(skb, IPPROTO_IPIP, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rel_msg == 0)\n\t\treturn 0;\n\n\tswitch (rel_type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tif (rel_code != ICMPV6_ADDR_UNREACH)\n\t\t\treturn 0;\n\t\trel_type = ICMP_DEST_UNREACH;\n\t\trel_code = ICMP_HOST_UNREACH;\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tif (rel_code != 0)\n\t\t\treturn 0;\n\t\trel_type = ICMP_DEST_UNREACH;\n\t\trel_code = ICMP_FRAG_NEEDED;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + sizeof(struct iphdr)))\n\t\treturn 0;\n\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn 0;\n\n\tskb_dst_drop(skb2);\n\n\tskb_pull(skb2, offset);\n\tskb_reset_network_header(skb2);\n\teiph = ip_hdr(skb2);\n\n\t/* Try to guess incoming interface */\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.fl4_dst = eiph->saddr;\n\tfl.fl4_tos = RT_TOS(eiph->tos);\n\tfl.proto = IPPROTO_IPIP;\n\tif (ip_route_output_key(dev_net(skb->dev), &rt, &fl))\n\t\tgoto out;\n\n\tskb2->dev = rt->u.dst.dev;\n\n\t/* route \"incoming\" packet */\n\tif (rt->rt_flags & RTCF_LOCAL) {\n\t\tip_rt_put(rt);\n\t\trt = NULL;\n\t\tfl.fl4_dst = eiph->daddr;\n\t\tfl.fl4_src = eiph->saddr;\n\t\tfl.fl4_tos = eiph->tos;\n\t\tif (ip_route_output_key(dev_net(skb->dev), &rt, &fl) ||\n\t\t    rt->u.dst.dev->type != ARPHRD_TUNNEL) {\n\t\t\tip_rt_put(rt);\n\t\t\tgoto out;\n\t\t}\n\t\tskb_dst_set(skb2, (struct dst_entry *)rt);\n\t} else {\n\t\tip_rt_put(rt);\n\t\tif (ip_route_input(skb2, eiph->daddr, eiph->saddr, eiph->tos,\n\t\t\t\t   skb2->dev) ||\n\t\t    skb_dst(skb2)->dev->type != ARPHRD_TUNNEL)\n\t\t\tgoto out;\n\t}\n\n\t/* change mtu on this route */\n\tif (rel_type == ICMP_DEST_UNREACH && rel_code == ICMP_FRAG_NEEDED) {\n\t\tif (rel_info > dst_mtu(skb_dst(skb2)))\n\t\t\tgoto out;\n\n\t\tskb_dst(skb2)->ops->update_pmtu(skb_dst(skb2), rel_info);\n\t}\n\n\ticmp_send(skb2, rel_type, rel_code, htonl(rel_info));\n\nout:\n\tkfree_skb(skb2);\n\treturn 0;\n}\n\nstatic int\nip6ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t   u8 type, u8 code, int offset, __be32 info)\n{\n\tint rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\t__u32 rel_info = ntohl(info);\n\tint err;\n\n\terr = ip6_tnl_err(skb, IPPROTO_IPV6, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rel_msg && pskb_may_pull(skb, offset + sizeof(struct ipv6hdr))) {\n\t\tstruct rt6_info *rt;\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\tif (!skb2)\n\t\t\treturn 0;\n\n\t\tskb_dst_drop(skb2);\n\t\tskb_pull(skb2, offset);\n\t\tskb_reset_network_header(skb2);\n\n\t\t/* Try to guess incoming interface */\n\t\trt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr,\n\t\t\t\tNULL, 0, 0);\n\n\t\tif (rt && rt->rt6i_dev)\n\t\t\tskb2->dev = rt->rt6i_dev;\n\n\t\ticmpv6_send(skb2, rel_type, rel_code, rel_info, skb2->dev);\n\n\t\tif (rt)\n\t\t\tdst_release(&rt->u.dst);\n\n\t\tkfree_skb(skb2);\n\t}\n\n\treturn 0;\n}\n\nstatic void ip4ip6_dscp_ecn_decapsulate(struct ip6_tnl *t,\n\t\t\t\t\tstruct ipv6hdr *ipv6h,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\t__u8 dsfield = ipv6_get_dsfield(ipv6h) & ~INET_ECN_MASK;\n\n\tif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n\t\tipv4_change_dsfield(ip_hdr(skb), INET_ECN_MASK, dsfield);\n\n\tif (INET_ECN_is_ce(dsfield))\n\t\tIP_ECN_set_ce(ip_hdr(skb));\n}\n\nstatic void ip6ip6_dscp_ecn_decapsulate(struct ip6_tnl *t,\n\t\t\t\t\tstruct ipv6hdr *ipv6h,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n\t\tipv6_copy_dscp(ipv6_get_dsfield(ipv6h), ipv6_hdr(skb));\n\n\tif (INET_ECN_is_ce(ipv6_get_dsfield(ipv6h)))\n\t\tIP6_ECN_set_ce(ipv6_hdr(skb));\n}\n\n/* called with rcu_read_lock() */\nstatic inline int ip6_tnl_rcv_ctl(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ret = 0;\n\tstruct net *net = dev_net(t->dev);\n\n\tif (p->flags & IP6_TNL_F_CAP_RCV) {\n\t\tstruct net_device *ldev = NULL;\n\n\t\tif (p->link)\n\t\t\tldev = dev_get_by_index_rcu(net, p->link);\n\n\t\tif ((ipv6_addr_is_multicast(&p->laddr) ||\n\t\t     likely(ipv6_chk_addr(net, &p->laddr, ldev, 0))) &&\n\t\t    likely(!ipv6_chk_addr(net, &p->raddr, NULL, 0)))\n\t\t\tret = 1;\n\n\t}\n\treturn ret;\n}\n\n/**\n * ip6_tnl_rcv - decapsulate IPv6 packet and retransmit it locally\n *   @skb: received socket buffer\n *   @protocol: ethernet protocol ID\n *   @dscp_ecn_decapsulate: the function to decapsulate DSCP code and ECN\n *\n * Return: 0\n **/\n\nstatic int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,\n\t\t       __u8 ipproto,\n\t\t       void (*dscp_ecn_decapsulate)(struct ip6_tnl *t,\n\t\t\t\t\t\t    struct ipv6hdr *ipv6h,\n\t\t\t\t\t\t    struct sk_buff *skb))\n{\n\tstruct ip6_tnl *t;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\n\trcu_read_lock();\n\n\tif ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,\n\t\t\t\t\t&ipv6h->daddr)) != NULL) {\n\t\tif (t->parms.proto != ipproto && t->parms.proto != 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!ip6_tnl_rcv_ctl(t)) {\n\t\t\tt->dev->stats.rx_dropped++;\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = htons(protocol);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tmemset(skb->cb, 0, sizeof(struct inet6_skb_parm));\n\t\tskb->dev = t->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\n\t\tdscp_ecn_decapsulate(t, ipv6h, skb);\n\n\t\tt->dev->stats.rx_packets++;\n\t\tt->dev->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\treturn 1;\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ip4ip6_rcv(struct sk_buff *skb)\n{\n\treturn ip6_tnl_rcv(skb, ETH_P_IP, IPPROTO_IPIP,\n\t\t\t   ip4ip6_dscp_ecn_decapsulate);\n}\n\nstatic int ip6ip6_rcv(struct sk_buff *skb)\n{\n\treturn ip6_tnl_rcv(skb, ETH_P_IPV6, IPPROTO_IPV6,\n\t\t\t   ip6ip6_dscp_ecn_decapsulate);\n}\n\nstruct ipv6_tel_txoption {\n\tstruct ipv6_txoptions ops;\n\t__u8 dst_opt[8];\n};\n\nstatic void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)\n{\n\tmemset(opt, 0, sizeof(struct ipv6_tel_txoption));\n\n\topt->dst_opt[2] = IPV6_TLV_TNL_ENCAP_LIMIT;\n\topt->dst_opt[3] = 1;\n\topt->dst_opt[4] = encap_limit;\n\topt->dst_opt[5] = IPV6_TLV_PADN;\n\topt->dst_opt[6] = 1;\n\n\topt->ops.dst0opt = (struct ipv6_opt_hdr *) opt->dst_opt;\n\topt->ops.opt_nflen = 8;\n}\n\n/**\n * ip6_tnl_addr_conflict - compare packet addresses to tunnel's own\n *   @t: the outgoing tunnel device\n *   @hdr: IPv6 header from the incoming packet\n *\n * Description:\n *   Avoid trivial tunneling loop by checking that tunnel exit-point\n *   doesn't match source of incoming packet.\n *\n * Return:\n *   1 if conflict,\n *   0 else\n **/\n\nstatic inline int\nip6_tnl_addr_conflict(struct ip6_tnl *t, struct ipv6hdr *hdr)\n{\n\treturn ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);\n}\n\nstatic inline int ip6_tnl_xmit_ctl(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ret = 0;\n\tstruct net *net = dev_net(t->dev);\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tstruct net_device *ldev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (p->link)\n\t\t\tldev = dev_get_by_index_rcu(net, p->link);\n\n\t\tif (unlikely(!ipv6_chk_addr(net, &p->laddr, ldev, 0)))\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s xmit: Local address not yet configured!\\n\",\n\t\t\t       p->name);\n\t\telse if (!ipv6_addr_is_multicast(&p->raddr) &&\n\t\t\t unlikely(ipv6_chk_addr(net, &p->raddr, NULL, 0)))\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s xmit: Routing loop! \"\n\t\t\t       \"Remote address found on this node!\\n\",\n\t\t\t       p->name);\n\t\telse\n\t\t\tret = 1;\n\t\trcu_read_unlock();\n\t}\n\treturn ret;\n}\n/**\n * ip6_tnl_xmit2 - encapsulate packet and send\n *   @skb: the outgoing socket buffer\n *   @dev: the outgoing tunnel device\n *   @dsfield: dscp code for outer header\n *   @fl: flow of tunneled packet\n *   @encap_limit: encapsulation limit\n *   @pmtu: Path MTU is stored if packet is too big\n *\n * Description:\n *   Build new header and do some sanity checks on the packet before sending\n *   it.\n *\n * Return:\n *   0 on success\n *   -1 fail\n *   %-EMSGSIZE message too big. return mtu in this case.\n **/\n\nstatic int ip6_tnl_xmit2(struct sk_buff *skb,\n\t\t\t struct net_device *dev,\n\t\t\t __u8 dsfield,\n\t\t\t struct flowi *fl,\n\t\t\t int encap_limit,\n\t\t\t __u32 *pmtu)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net_device_stats *stats = &t->dev->stats;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tstruct ipv6_tel_txoption opt;\n\tstruct dst_entry *dst;\n\tstruct net_device *tdev;\n\tint mtu;\n\tunsigned int max_headroom = sizeof(struct ipv6hdr);\n\tu8 proto;\n\tint err = -1;\n\tint pkt_len;\n\n\tif ((dst = ip6_tnl_dst_check(t)) != NULL)\n\t\tdst_hold(dst);\n\telse {\n\t\tdst = ip6_route_output(net, NULL, fl);\n\n\t\tif (dst->error || xfrm_lookup(net, &dst, fl, NULL, 0) < 0)\n\t\t\tgoto tx_err_link_failure;\n\t}\n\n\ttdev = dst->dev;\n\n\tif (tdev == dev) {\n\t\tstats->collisions++;\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Local routing loop detected!\\n\",\n\t\t\t       t->parms.name);\n\t\tgoto tx_err_dst_release;\n\t}\n\tmtu = dst_mtu(dst) - sizeof (*ipv6h);\n\tif (encap_limit >= 0) {\n\t\tmax_headroom += 8;\n\t\tmtu -= 8;\n\t}\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\tif (skb_dst(skb))\n\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\tif (skb->len > mtu) {\n\t\t*pmtu = mtu;\n\t\terr = -EMSGSIZE;\n\t\tgoto tx_err_dst_release;\n\t}\n\n\t/*\n\t * Okay, now see if we can stuff it in the buffer as-is.\n\t */\n\tmax_headroom += LL_RESERVED_SPACE(tdev);\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb;\n\n\t\tif (!(new_skb = skb_realloc_headroom(skb, max_headroom)))\n\t\t\tgoto tx_err_dst_release;\n\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t}\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst_clone(dst));\n\n\tskb->transport_header = skb->network_header;\n\n\tproto = fl->proto;\n\tif (encap_limit >= 0) {\n\t\tinit_tel_txopt(&opt, encap_limit);\n\t\tipv6_push_nfrag_opts(skb, &opt.ops, &proto, NULL);\n\t}\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tipv6h = ipv6_hdr(skb);\n\t*(__be32*)ipv6h = fl->fl6_flowlabel | htonl(0x60000000);\n\tdsfield = INET_ECN_encapsulate(0, dsfield);\n\tipv6_change_dsfield(ipv6h, ~INET_ECN_MASK, dsfield);\n\tipv6h->hop_limit = t->parms.hop_limit;\n\tipv6h->nexthdr = proto;\n\tipv6_addr_copy(&ipv6h->saddr, &fl->fl6_src);\n\tipv6_addr_copy(&ipv6h->daddr, &fl->fl6_dst);\n\tnf_reset(skb);\n\tpkt_len = skb->len;\n\terr = ip6_local_out(skb);\n\n\tif (net_xmit_eval(err) == 0) {\n\t\tstats->tx_bytes += pkt_len;\n\t\tstats->tx_packets++;\n\t} else {\n\t\tstats->tx_errors++;\n\t\tstats->tx_aborted_errors++;\n\t}\n\tip6_tnl_dst_store(t, dst);\n\treturn 0;\ntx_err_link_failure:\n\tstats->tx_carrier_errors++;\n\tdst_link_failure(skb);\ntx_err_dst_release:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic inline int\nip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct iphdr  *iph = ip_hdr(skb);\n\tint encap_limit = -1;\n\tstruct flowi fl;\n\t__u8 dsfield;\n\t__u32 mtu;\n\tint err;\n\n\tif ((t->parms.proto != IPPROTO_IPIP && t->parms.proto != 0) ||\n\t    !ip6_tnl_xmit_ctl(t))\n\t\treturn -1;\n\n\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tencap_limit = t->parms.encap_limit;\n\n\tmemcpy(&fl, &t->fl, sizeof (fl));\n\tfl.proto = IPPROTO_IPIP;\n\n\tdsfield = ipv4_get_dsfield(iph);\n\n\tif ((t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl.fl6_flowlabel |= htonl((__u32)iph->tos << IPV6_TCLASS_SHIFT)\n\t\t\t\t\t  & IPV6_TCLASS_MASK;\n\n\terr = ip6_tnl_xmit2(skb, dev, dsfield, &fl, encap_limit, &mtu);\n\tif (err != 0) {\n\t\t/* XXX: send ICMP error even if DF is not set. */\n\t\tif (err == -EMSGSIZE)\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t  htonl(mtu));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int\nip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tint encap_limit = -1;\n\t__u16 offset;\n\tstruct flowi fl;\n\t__u8 dsfield;\n\t__u32 mtu;\n\tint err;\n\n\tif ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||\n\t    !ip6_tnl_xmit_ctl(t) || ip6_tnl_addr_conflict(t, ipv6h))\n\t\treturn -1;\n\n\toffset = parse_tlv_tnl_enc_lim(skb, skb_network_header(skb));\n\tif (offset > 0) {\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\ttel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];\n\t\tif (tel->encap_limit == 0) {\n\t\t\ticmpv6_send(skb, ICMPV6_PARAMPROB,\n\t\t\t\t    ICMPV6_HDR_FIELD, offset + 2, skb->dev);\n\t\t\treturn -1;\n\t\t}\n\t\tencap_limit = tel->encap_limit - 1;\n\t} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tencap_limit = t->parms.encap_limit;\n\n\tmemcpy(&fl, &t->fl, sizeof (fl));\n\tfl.proto = IPPROTO_IPV6;\n\n\tdsfield = ipv6_get_dsfield(ipv6h);\n\tif ((t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl.fl6_flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);\n\tif ((t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl.fl6_flowlabel |= (*(__be32 *) ipv6h & IPV6_FLOWLABEL_MASK);\n\n\terr = ip6_tnl_xmit2(skb, dev, dsfield, &fl, encap_limit, &mtu);\n\tif (err != 0) {\n\t\tif (err == -EMSGSIZE)\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net_device_stats *stats = &t->dev->stats;\n\tint ret;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tret = ip4ip6_tnl_xmit(skb, dev);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tret = ip6ip6_tnl_xmit(skb, dev);\n\t\tbreak;\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\tif (ret < 0)\n\t\tgoto tx_err;\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tstats->tx_errors++;\n\tstats->tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ip6_tnl_set_cap(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ltype = ipv6_addr_type(&p->laddr);\n\tint rtype = ipv6_addr_type(&p->raddr);\n\n\tp->flags &= ~(IP6_TNL_F_CAP_XMIT|IP6_TNL_F_CAP_RCV);\n\n\tif (ltype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t    rtype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t    !((ltype|rtype) & IPV6_ADDR_LOOPBACK) &&\n\t    (!((ltype|rtype) & IPV6_ADDR_LINKLOCAL) || p->link)) {\n\t\tif (ltype&IPV6_ADDR_UNICAST)\n\t\t\tp->flags |= IP6_TNL_F_CAP_XMIT;\n\t\tif (rtype&IPV6_ADDR_UNICAST)\n\t\t\tp->flags |= IP6_TNL_F_CAP_RCV;\n\t}\n}\n\nstatic void ip6_tnl_link_config(struct ip6_tnl *t)\n{\n\tstruct net_device *dev = t->dev;\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tstruct flowi *fl = &t->fl;\n\n\tmemcpy(dev->dev_addr, &p->laddr, sizeof(struct in6_addr));\n\tmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\n\n\t/* Set up flowi template */\n\tipv6_addr_copy(&fl->fl6_src, &p->laddr);\n\tipv6_addr_copy(&fl->fl6_dst, &p->raddr);\n\tfl->oif = p->link;\n\tfl->fl6_flowlabel = 0;\n\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl->fl6_flowlabel |= IPV6_TCLASS_MASK & p->flowinfo;\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl->fl6_flowlabel |= IPV6_FLOWLABEL_MASK & p->flowinfo;\n\n\tip6_tnl_set_cap(t);\n\n\tif (p->flags&IP6_TNL_F_CAP_XMIT && p->flags&IP6_TNL_F_CAP_RCV)\n\t\tdev->flags |= IFF_POINTOPOINT;\n\telse\n\t\tdev->flags &= ~IFF_POINTOPOINT;\n\n\tdev->iflink = p->link;\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tint strict = (ipv6_addr_type(&p->raddr) &\n\t\t\t      (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL));\n\n\t\tstruct rt6_info *rt = rt6_lookup(dev_net(dev),\n\t\t\t\t\t\t &p->raddr, &p->laddr,\n\t\t\t\t\t\t p->link, strict);\n\n\t\tif (rt == NULL)\n\t\t\treturn;\n\n\t\tif (rt->rt6i_dev) {\n\t\t\tdev->hard_header_len = rt->rt6i_dev->hard_header_len +\n\t\t\t\tsizeof (struct ipv6hdr);\n\n\t\t\tdev->mtu = rt->rt6i_dev->mtu - sizeof (struct ipv6hdr);\n\n\t\t\tif (dev->mtu < IPV6_MIN_MTU)\n\t\t\t\tdev->mtu = IPV6_MIN_MTU;\n\t\t}\n\t\tdst_release(&rt->u.dst);\n\t}\n}\n\n/**\n * ip6_tnl_change - update the tunnel parameters\n *   @t: tunnel to be changed\n *   @p: tunnel configuration parameters\n *\n * Description:\n *   ip6_tnl_change() updates the tunnel parameters\n **/\n\nstatic int\nip6_tnl_change(struct ip6_tnl *t, struct ip6_tnl_parm *p)\n{\n\tipv6_addr_copy(&t->parms.laddr, &p->laddr);\n\tipv6_addr_copy(&t->parms.raddr, &p->raddr);\n\tt->parms.flags = p->flags;\n\tt->parms.hop_limit = p->hop_limit;\n\tt->parms.encap_limit = p->encap_limit;\n\tt->parms.flowinfo = p->flowinfo;\n\tt->parms.link = p->link;\n\tt->parms.proto = p->proto;\n\tip6_tnl_dst_reset(t);\n\tip6_tnl_link_config(t);\n\treturn 0;\n}\n\n/**\n * ip6_tnl_ioctl - configure ipv6 tunnels from userspace\n *   @dev: virtual device associated with tunnel\n *   @ifr: parameters passed from userspace\n *   @cmd: command to be performed\n *\n * Description:\n *   ip6_tnl_ioctl() is used for managing IPv6 tunnels\n *   from userspace.\n *\n *   The possible commands are the following:\n *     %SIOCGETTUNNEL: get tunnel parameters for device\n *     %SIOCADDTUNNEL: add tunnel matching given tunnel parameters\n *     %SIOCCHGTUNNEL: change tunnel parameters to those given\n *     %SIOCDELTUNNEL: delete tunnel\n *\n *   The fallback device \"ip6tnl0\", created during module\n *   initialization, can be used for creating other tunnel devices.\n *\n * Return:\n *   0 on success,\n *   %-EFAULT if unable to copy data to or from userspace,\n *   %-EPERM if current process hasn't %CAP_NET_ADMIN set\n *   %-EINVAL if passed tunnel parameters are invalid,\n *   %-EEXIST if changing a tunnel's parameters would cause a conflict\n *   %-ENODEV if attempting to change or delete a nonexisting device\n **/\n\nstatic int\nip6_tnl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip6_tnl_parm p;\n\tstruct ip6_tnl *t = NULL;\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ip6_tnl_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\t\tmemcpy(&p, &t->parms, sizeof (p));\n\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof (p))) {\n\t\t\terr = -EFAULT;\n\t\t}\n\t\tbreak;\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p)))\n\t\t\tbreak;\n\t\terr = -EINVAL;\n\t\tif (p.proto != IPPROTO_IPV6 && p.proto != IPPROTO_IPIP &&\n\t\t    p.proto != 0)\n\t\t\tbreak;\n\t\tt = ip6_tnl_locate(net, &p, cmd == SIOCADDTUNNEL);\n\t\tif (dev != ip6n->fb_tnl_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tt = netdev_priv(dev);\n\n\t\t\tip6_tnl_unlink(ip6n, t);\n\t\t\terr = ip6_tnl_change(t, &p);\n\t\t\tip6_tnl_link(ip6n, t);\n\t\t\tnetdev_state_change(dev);\n\t\t}\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof (p)))\n\t\t\t\terr = -EFAULT;\n\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p)))\n\t\t\t\tbreak;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ip6_tnl_locate(net, &p, 0)) == NULL)\n\t\t\t\tbreak;\n\t\t\terr = -EPERM;\n\t\t\tif (t->dev == ip6n->fb_tnl_dev)\n\t\t\t\tbreak;\n\t\t\tdev = t->dev;\n\t\t}\n\t\terr = 0;\n\t\tunregister_netdevice(dev);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\n/**\n * ip6_tnl_change_mtu - change mtu manually for tunnel device\n *   @dev: virtual device associated with tunnel\n *   @new_mtu: the new mtu\n *\n * Return:\n *   0 on success,\n *   %-EINVAL if mtu too small\n **/\n\nstatic int\nip6_tnl_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < IPV6_MIN_MTU) {\n\t\treturn -EINVAL;\n\t}\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n\nstatic const struct net_device_ops ip6_tnl_netdev_ops = {\n\t.ndo_uninit = ip6_tnl_dev_uninit,\n\t.ndo_start_xmit = ip6_tnl_xmit,\n\t.ndo_do_ioctl = ip6_tnl_ioctl,\n\t.ndo_change_mtu = ip6_tnl_change_mtu,\n};\n\n/**\n * ip6_tnl_dev_setup - setup virtual tunnel device\n *   @dev: virtual device associated with tunnel\n *\n * Description:\n *   Initialize function pointers and device parameters\n **/\n\nstatic void ip6_tnl_dev_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ip6_tnl_netdev_ops;\n\tdev->destructor = free_netdev;\n\n\tdev->type = ARPHRD_TUNNEL6;\n\tdev->hard_header_len = LL_MAX_HEADER + sizeof (struct ipv6hdr);\n\tdev->mtu = ETH_DATA_LEN - sizeof (struct ipv6hdr);\n\tdev->flags |= IFF_NOARP;\n\tdev->addr_len = sizeof(struct in6_addr);\n\tdev->features |= NETIF_F_NETNS_LOCAL;\n}\n\n\n/**\n * ip6_tnl_dev_init_gen - general initializer for all tunnel devices\n *   @dev: virtual device associated with tunnel\n **/\n\nstatic inline void\nip6_tnl_dev_init_gen(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tt->dev = dev;\n\tstrcpy(t->parms.name, dev->name);\n}\n\n/**\n * ip6_tnl_dev_init - initializer for all non fallback tunnel devices\n *   @dev: virtual device associated with tunnel\n **/\n\nstatic void ip6_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tip6_tnl_dev_init_gen(dev);\n\tip6_tnl_link_config(t);\n}\n\n/**\n * ip6_fb_tnl_dev_init - initializer for fallback tunnel device\n *   @dev: fallback device\n *\n * Return: 0\n **/\n\nstatic void __net_init ip6_fb_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tip6_tnl_dev_init_gen(dev);\n\tt->parms.proto = IPPROTO_IPV6;\n\tdev_hold(dev);\n\tip6n->tnls_wc[0] = t;\n}\n\nstatic struct xfrm6_tunnel ip4ip6_handler = {\n\t.handler\t= ip4ip6_rcv,\n\t.err_handler\t= ip4ip6_err,\n\t.priority\t=\t1,\n};\n\nstatic struct xfrm6_tunnel ip6ip6_handler = {\n\t.handler\t= ip6ip6_rcv,\n\t.err_handler\t= ip6ip6_err,\n\t.priority\t=\t1,\n};\n\nstatic void __net_exit ip6_tnl_destroy_tunnels(struct ip6_tnl_net *ip6n)\n{\n\tint h;\n\tstruct ip6_tnl *t;\n\tLIST_HEAD(list);\n\n\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\tt = ip6n->tnls_r_l[h];\n\t\twhile (t != NULL) {\n\t\t\tunregister_netdevice_queue(t->dev, &list);\n\t\t\tt = t->next;\n\t\t}\n\t}\n\n\tt = ip6n->tnls_wc[0];\n\tunregister_netdevice_queue(t->dev, &list);\n\tunregister_netdevice_many(&list);\n}\n\nstatic int __net_init ip6_tnl_init_net(struct net *net)\n{\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tint err;\n\n\tip6n->tnls[0] = ip6n->tnls_wc;\n\tip6n->tnls[1] = ip6n->tnls_r_l;\n\n\terr = -ENOMEM;\n\tip6n->fb_tnl_dev = alloc_netdev(sizeof(struct ip6_tnl), \"ip6tnl0\",\n\t\t\t\t      ip6_tnl_dev_setup);\n\n\tif (!ip6n->fb_tnl_dev)\n\t\tgoto err_alloc_dev;\n\tdev_net_set(ip6n->fb_tnl_dev, net);\n\n\tip6_fb_tnl_dev_init(ip6n->fb_tnl_dev);\n\n\terr = register_netdev(ip6n->fb_tnl_dev);\n\tif (err < 0)\n\t\tgoto err_register;\n\treturn 0;\n\nerr_register:\n\tfree_netdev(ip6n->fb_tnl_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit ip6_tnl_exit_net(struct net *net)\n{\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\trtnl_lock();\n\tip6_tnl_destroy_tunnels(ip6n);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ip6_tnl_net_ops = {\n\t.init = ip6_tnl_init_net,\n\t.exit = ip6_tnl_exit_net,\n\t.id   = &ip6_tnl_net_id,\n\t.size = sizeof(struct ip6_tnl_net),\n};\n\n/**\n * ip6_tunnel_init - register protocol and reserve needed resources\n *\n * Return: 0 on success\n **/\n\nstatic int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}\n\n/**\n * ip6_tunnel_cleanup - free resources and unregister protocol\n **/\n\nstatic void __exit ip6_tunnel_cleanup(void)\n{\n\tif (xfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET))\n\t\tprintk(KERN_INFO \"ip6_tunnel close: can't deregister ip4ip6\\n\");\n\n\tif (xfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6))\n\t\tprintk(KERN_INFO \"ip6_tunnel close: can't deregister ip6ip6\\n\");\n\n\tunregister_pernet_device(&ip6_tnl_net_ops);\n}\n\nmodule_init(ip6_tunnel_init);\nmodule_exit(ip6_tunnel_cleanup);\n", "/*\n *\tIPv6 over IPv4 tunnel device - Simple Internet Transition (SIT)\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\tAlexey Kuznetsov\t<kuznet@ms2.inr.ac.ru>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tChanges:\n * Roger Venning <r.venning@telstra.com>:\t6to4 support\n * Nate Thompson <nate@thebog.net>:\t\t6to4 support\n * Fred Templin <fred.l.templin@boeing.com>:\tisatap support\n */\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmp.h>\n#include <asm/uaccess.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <net/ipip.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/dsfield.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n/*\n   This version of net/ipv6/sit.c is cloned of net/ipv4/ip_gre.c\n\n   For comments look at net/ipv4/ip_gre.c --ANK\n */\n\n#define HASH_SIZE  16\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\nstatic void ipip6_tunnel_init(struct net_device *dev);\nstatic void ipip6_tunnel_setup(struct net_device *dev);\n\nstatic int sit_net_id __read_mostly;\nstruct sit_net {\n\tstruct ip_tunnel *tunnels_r_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_r[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_wc[1];\n\tstruct ip_tunnel **tunnels[4];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ipip6_lock);\n\n#define for_each_ip_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\n/*\n * Must be invoked with rcu_read_lock\n */\nstatic struct ip_tunnel * ipip6_tunnel_lookup(struct net *net,\n\t\tstruct net_device *dev, __be32 remote, __be32 local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tfor_each_ip_tunnel_rcu(sitn->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || dev->iflink == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(sitn->tunnels_r[h0]) {\n\t\tif (remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || dev->iflink == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(sitn->tunnels_l[h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    (!dev || !t->parms.link || dev->iflink == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tt = rcu_dereference(sitn->tunnels_wc[0]);\n\tif ((t != NULL) && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}\n\nstatic struct ip_tunnel **__ipip6_bucket(struct sit_net *sitn,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (remote) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\tif (local) {\n\t\tprio |= 1;\n\t\th ^= HASH(local);\n\t}\n\treturn &sitn->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel **ipip6_bucket(struct sit_net *sitn,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipip6_bucket(sitn, &t->parms);\n}\n\nstatic void ipip6_tunnel_unlink(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp;\n\n\tfor (tp = ipip6_bucket(sitn, t); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ipip6_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ipip6_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ipip6_tunnel_link(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp = ipip6_bucket(sitn, t);\n\n\tspin_lock_bh(&ipip6_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ipip6_lock);\n}\n\nstatic void ipip6_tunnel_clone_6rd(struct net_device *dev, struct sit_net *sitn)\n{\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (t->dev == sitn->fb_tunnel_dev) {\n\t\tipv6_addr_set(&t->ip6rd.prefix, htonl(0x20020000), 0, 0, 0);\n\t\tt->ip6rd.relay_prefix = 0;\n\t\tt->ip6rd.prefixlen = 16;\n\t\tt->ip6rd.relay_prefixlen = 0;\n\t} else {\n\t\tstruct ip_tunnel *t0 = netdev_priv(sitn->fb_tunnel_dev);\n\t\tmemcpy(&t->ip6rd, &t0->ip6rd, sizeof(t->ip6rd));\n\t}\n#endif\n}\n\nstatic struct ip_tunnel * ipip6_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tstruct ip_tunnel *t, **tp, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tfor (tp = __ipip6_bucket(sitn, parms); (t = *tp) != NULL; tp = &t->next) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    parms->link == t->parms.link) {\n\t\t\tif (create)\n\t\t\t\treturn NULL;\n\t\t\telse\n\t\t\t\treturn t;\n\t\t}\n\t}\n\tif (!create)\n\t\tgoto failed;\n\n\tif (parms->name[0])\n\t\tstrlcpy(name, parms->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"sit%%d\");\n\n\tdev = alloc_netdev(sizeof(*t), name, ipip6_tunnel_setup);\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tnt = netdev_priv(dev);\n\n\tnt->parms = *parms;\n\tipip6_tunnel_init(dev);\n\tipip6_tunnel_clone_6rd(dev, sitn);\n\n\tif (parms->i_flags & SIT_ISATAP)\n\t\tdev->priv_flags |= IFF_ISATAP;\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\n\tipip6_tunnel_link(sitn, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\n\nstatic DEFINE_SPINLOCK(ipip6_prl_lock);\n\n#define for_each_prl_rcu(start)\t\t\t\\\n\tfor (prl = rcu_dereference(start);\t\\\n\t     prl;\t\t\t\t\\\n\t     prl = rcu_dereference(prl->next))\n\nstatic struct ip_tunnel_prl_entry *\n__ipip6_tunnel_locate_prl(struct ip_tunnel *t, __be32 addr)\n{\n\tstruct ip_tunnel_prl_entry *prl;\n\n\tfor_each_prl_rcu(t->prl)\n\t\tif (prl->addr == addr)\n\t\t\tbreak;\n\treturn prl;\n\n}\n\nstatic int ipip6_tunnel_get_prl(struct ip_tunnel *t,\n\t\t\t\tstruct ip_tunnel_prl __user *a)\n{\n\tstruct ip_tunnel_prl kprl, *kp;\n\tstruct ip_tunnel_prl_entry *prl;\n\tunsigned int cmax, c = 0, ca, len;\n\tint ret = 0;\n\n\tif (copy_from_user(&kprl, a, sizeof(kprl)))\n\t\treturn -EFAULT;\n\tcmax = kprl.datalen / sizeof(kprl);\n\tif (cmax > 1 && kprl.addr != htonl(INADDR_ANY))\n\t\tcmax = 1;\n\n\t/* For simple GET or for root users,\n\t * we try harder to allocate.\n\t */\n\tkp = (cmax <= 1 || capable(CAP_NET_ADMIN)) ?\n\t\tkcalloc(cmax, sizeof(*kp), GFP_KERNEL) :\n\t\tNULL;\n\n\trcu_read_lock();\n\n\tca = t->prl_count < cmax ? t->prl_count : cmax;\n\n\tif (!kp) {\n\t\t/* We don't try hard to allocate much memory for\n\t\t * non-root users.\n\t\t * For root users, retry allocating enough memory for\n\t\t * the answer.\n\t\t */\n\t\tkp = kcalloc(ca, sizeof(*kp), GFP_ATOMIC);\n\t\tif (!kp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc = 0;\n\tfor_each_prl_rcu(t->prl) {\n\t\tif (c >= cmax)\n\t\t\tbreak;\n\t\tif (kprl.addr != htonl(INADDR_ANY) && prl->addr != kprl.addr)\n\t\t\tcontinue;\n\t\tkp[c].addr = prl->addr;\n\t\tkp[c].flags = prl->flags;\n\t\tc++;\n\t\tif (kprl.addr != htonl(INADDR_ANY))\n\t\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\n\tlen = sizeof(*kp) * c;\n\tret = 0;\n\tif ((len && copy_to_user(a + 1, kp, len)) || put_user(len, &a->datalen))\n\t\tret = -EFAULT;\n\n\tkfree(kp);\n\n\treturn ret;\n}\n\nstatic int\nipip6_tunnel_add_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a, int chg)\n{\n\tstruct ip_tunnel_prl_entry *p;\n\tint err = 0;\n\n\tif (a->addr == htonl(INADDR_ANY))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ipip6_prl_lock);\n\n\tfor (p = t->prl; p; p = p->next) {\n\t\tif (p->addr == a->addr) {\n\t\t\tif (chg) {\n\t\t\t\tp->flags = a->flags;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (chg) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tp = kzalloc(sizeof(struct ip_tunnel_prl_entry), GFP_KERNEL);\n\tif (!p) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tINIT_RCU_HEAD(&p->rcu_head);\n\tp->next = t->prl;\n\tp->addr = a->addr;\n\tp->flags = a->flags;\n\tt->prl_count++;\n\trcu_assign_pointer(t->prl, p);\nout:\n\tspin_unlock(&ipip6_prl_lock);\n\treturn err;\n}\n\nstatic void prl_entry_destroy_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_tunnel_prl_entry, rcu_head));\n}\n\nstatic void prl_list_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_tunnel_prl_entry *p, *n;\n\n\tp = container_of(head, struct ip_tunnel_prl_entry, rcu_head);\n\tdo {\n\t\tn = p->next;\n\t\tkfree(p);\n\t\tp = n;\n\t} while (p);\n}\n\nstatic int\nipip6_tunnel_del_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a)\n{\n\tstruct ip_tunnel_prl_entry *x, **p;\n\tint err = 0;\n\n\tspin_lock(&ipip6_prl_lock);\n\n\tif (a && a->addr != htonl(INADDR_ANY)) {\n\t\tfor (p = &t->prl; *p; p = &(*p)->next) {\n\t\t\tif ((*p)->addr == a->addr) {\n\t\t\t\tx = *p;\n\t\t\t\t*p = x->next;\n\t\t\t\tcall_rcu(&x->rcu_head, prl_entry_destroy_rcu);\n\t\t\t\tt->prl_count--;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = -ENXIO;\n\t} else {\n\t\tif (t->prl) {\n\t\t\tt->prl_count = 0;\n\t\t\tx = t->prl;\n\t\t\tcall_rcu(&x->rcu_head, prl_list_destroy_rcu);\n\t\t\tt->prl = NULL;\n\t\t}\n\t}\nout:\n\tspin_unlock(&ipip6_prl_lock);\n\treturn err;\n}\n\nstatic int\nisatap_chksrc(struct sk_buff *skb, struct iphdr *iph, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel_prl_entry *p;\n\tint ok = 1;\n\n\trcu_read_lock();\n\tp = __ipip6_tunnel_locate_prl(t, iph->saddr);\n\tif (p) {\n\t\tif (p->flags & PRL_DEFAULT)\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_DEFAULT;\n\t\telse\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_NODEFAULT;\n\t} else {\n\t\tstruct in6_addr *addr6 = &ipv6_hdr(skb)->saddr;\n\t\tif (ipv6_addr_is_isatap(addr6) &&\n\t\t    (addr6->s6_addr32[3] == iph->saddr) &&\n\t\t    ipv6_chk_prefix(addr6, t->dev))\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_HOST;\n\t\telse\n\t\t\tok = 0;\n\t}\n\trcu_read_unlock();\n\treturn ok;\n}\n\nstatic void ipip6_tunnel_uninit(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tif (dev == sitn->fb_tunnel_dev) {\n\t\tspin_lock_bh(&ipip6_lock);\n\t\tsitn->tunnels_wc[0] = NULL;\n\t\tspin_unlock_bh(&ipip6_lock);\n\t\tdev_put(dev);\n\t} else {\n\t\tipip6_tunnel_unlink(sitn, netdev_priv(dev));\n\t\tipip6_tunnel_del_prl(netdev_priv(dev), NULL);\n\t\tdev_put(dev);\n\t}\n}\n\n\nstatic int ipip6_err(struct sk_buff *skb, u32 info)\n{\n\n/* All the routers (except for Linux) return only\n   8 bytes of packet payload. It means, that precise relaying of\n   ICMP in the real Internet is absolutely infeasible.\n */\n\tstruct iphdr *iph = (struct iphdr*)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t/* Impossible event. */\n\t\t\treturn 0;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t/* Soft state for pmtu is maintained by IP core. */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\terr = -ENOENT;\n\n\trcu_read_lock();\n\tt = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\tskb->dev,\n\t\t\t\tiph->daddr,\n\t\t\t\tiph->saddr);\n\tif (t == NULL || t->parms.iph.daddr == 0)\n\t\tgoto out;\n\n\terr = 0;\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic inline void ipip6_ecn_decapsulate(struct iphdr *iph, struct sk_buff *skb)\n{\n\tif (INET_ECN_is_ce(iph->tos))\n\t\tIP6_ECN_set_ce(ipv6_hdr(skb));\n}\n\nstatic int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\n\trcu_read_lock();\n\ttunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\t     iph->saddr, iph->daddr);\n\tif (tunnel != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->dev->stats.rx_errors++;\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->dev->stats.rx_packets++;\n\t\ttunnel->dev->stats.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\trcu_read_unlock();\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/*\n * Returns the embedded IPv4 address if the IPv6 address\n * comes from 6rd / 6to4 (RFC 3056) addr space.\n */\nstatic inline\n__be32 try_6rd(struct in6_addr *v6dst, struct ip_tunnel *tunnel)\n{\n\t__be32 dst = 0;\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tif (ipv6_prefix_equal(v6dst, &tunnel->ip6rd.prefix,\n\t\t\t      tunnel->ip6rd.prefixlen)) {\n\t\tunsigned pbw0, pbi0;\n\t\tint pbi1;\n\t\tu32 d;\n\n\t\tpbw0 = tunnel->ip6rd.prefixlen >> 5;\n\t\tpbi0 = tunnel->ip6rd.prefixlen & 0x1f;\n\n\t\td = (ntohl(v6dst->s6_addr32[pbw0]) << pbi0) >>\n\t\t    tunnel->ip6rd.relay_prefixlen;\n\n\t\tpbi1 = pbi0 - tunnel->ip6rd.relay_prefixlen;\n\t\tif (pbi1 > 0)\n\t\t\td |= ntohl(v6dst->s6_addr32[pbw0 + 1]) >>\n\t\t\t     (32 - pbi1);\n\n\t\tdst = tunnel->ip6rd.relay_prefix | htonl(d);\n\t}\n#else\n\tif (v6dst->s6_addr16[0] == htons(0x2002)) {\n\t\t/* 6to4 v6 addr has 16 bits prefix, 32 v4addr, 16 SLA, ... */\n\t\tmemcpy(&dst, &v6dst->s6_addr16[1], 4);\n\t}\n#endif\n\treturn dst;\n}\n\n/*\n *\tThis function assumes it is being called from dev_queue_xmit()\n *\tand that skb is filled properly by that function.\n */\n\nstatic netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\tstruct iphdr  *tiph = &tunnel->parms.iph;\n\tstruct ipv6hdr *iph6 = ipv6_hdr(skb);\n\tu8     tos = tunnel->parms.iph.tos;\n\t__be16 df = tiph->frag_off;\n\tstruct rtable *rt;     \t\t\t/* Route to the other host */\n\tstruct net_device *tdev;\t\t\t/* Device to other host */\n\tstruct iphdr  *iph;\t\t\t/* Our new IP header */\n\tunsigned int max_headroom;\t\t/* The extra header space needed */\n\t__be32 dst = tiph->daddr;\n\tint    mtu;\n\tstruct in6_addr *addr6;\n\tint addr_type;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\tgoto tx_error;\n\n\t/* ISATAP (RFC4214) - must come before 6to4 */\n\tif (dev->priv_flags & IFF_ISATAP) {\n\t\tstruct neighbour *neigh = NULL;\n\n\t\tif (skb_dst(skb))\n\t\t\tneigh = skb_dst(skb)->neighbour;\n\n\t\tif (neigh == NULL) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_DEBUG \"sit: nexthop == NULL\\n\");\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\taddr6 = (struct in6_addr*)&neigh->primary_key;\n\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\tif ((addr_type & IPV6_ADDR_UNICAST) &&\n\t\t     ipv6_addr_is_isatap(addr6))\n\t\t\tdst = addr6->s6_addr32[3];\n\t\telse\n\t\t\tgoto tx_error;\n\t}\n\n\tif (!dst)\n\t\tdst = try_6rd(&iph6->daddr, tunnel);\n\n\tif (!dst) {\n\t\tstruct neighbour *neigh = NULL;\n\n\t\tif (skb_dst(skb))\n\t\t\tneigh = skb_dst(skb)->neighbour;\n\n\t\tif (neigh == NULL) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_DEBUG \"sit: nexthop == NULL\\n\");\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\taddr6 = (struct in6_addr*)&neigh->primary_key;\n\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t}\n\n\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\tgoto tx_error_icmp;\n\n\t\tdst = addr6->s6_addr32[3];\n\t}\n\n\t{\n\t\tstruct flowi fl = { .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = dst,\n\t\t\t\t\t\t.saddr = tiph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(tos) } },\n\t\t\t\t    .oif = tunnel->parms.link,\n\t\t\t\t    .proto = IPPROTO_IPV6 };\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\tstats->tx_carrier_errors++;\n\t\t\tgoto tx_error_icmp;\n\t\t}\n\t}\n\tif (rt->rt_type != RTN_UNICAST) {\n\t\tip_rt_put(rt);\n\t\tstats->tx_carrier_errors++;\n\t\tgoto tx_error_icmp;\n\t}\n\ttdev = rt->u.dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tstats->collisions++;\n\t\tgoto tx_error;\n\t}\n\n\tif (df) {\n\t\tmtu = dst_mtu(&rt->u.dst) - sizeof(struct iphdr);\n\n\t\tif (mtu < 68) {\n\t\t\tstats->collisions++;\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tdf = 0;\n\t\t}\n\n\t\tif (tunnel->parms.iph.daddr && skb_dst(skb))\n\t\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\n\t\tif (skb->len > mtu) {\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\t/*\n\t * Okay, now see if we can stuff it in the buffer as-is.\n\t */\n\tmax_headroom = LL_RESERVED_SPACE(tdev)+sizeof(struct iphdr);\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\ttxq->tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\tiph6 = ipv6_hdr(skb);\n\t}\n\n\tskb->transport_header = skb->network_header;\n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags = 0;\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->u.dst);\n\n\t/*\n\t *\tPush down and install the IPIP header.\n\t */\n\n\tiph \t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr)>>2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tIPPROTO_IPV6;\n\tiph->tos\t\t=\tINET_ECN_encapsulate(tos, ipv6_get_dsfield(iph6));\n\tiph->daddr\t\t=\trt->rt_dst;\n\tiph->saddr\t\t=\trt->rt_src;\n\n\tif ((iph->ttl = tiph->ttl) == 0)\n\t\tiph->ttl\t=\tiph6->hop_limit;\n\n\tnf_reset(skb);\n\n\tIPTUNNEL_XMIT();\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\ntx_error:\n\tstats->tx_errors++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipip6_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\tif (iph->daddr) {\n\t\tstruct flowi fl = { .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = iph->daddr,\n\t\t\t\t\t\t.saddr = iph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(iph->tos) } },\n\t\t\t\t    .oif = tunnel->parms.link,\n\t\t\t\t    .proto = IPPROTO_IPV6 };\n\t\tstruct rtable *rt;\n\t\tif (!ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\ttdev = rt->u.dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\n\n\tif (tdev) {\n\t\tdev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);\n\t\tdev->mtu = tdev->mtu - sizeof(struct iphdr);\n\t\tif (dev->mtu < IPV6_MIN_MTU)\n\t\t\tdev->mtu = IPV6_MIN_MTU;\n\t}\n\tdev->iflink = tunnel->parms.link;\n}\n\nstatic int\nipip6_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel_prl prl;\n\tstruct ip_tunnel *t;\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel_6rd ip6rd;\n#endif\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n#ifdef CONFIG_IPV6_SIT_6RD\n\tcase SIOCGET6RD:\n#endif\n\t\tt = NULL;\n\t\tif (dev == sitn->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ipip6_tunnel_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\n\t\terr = -EFAULT;\n\t\tif (cmd == SIOCGETTUNNEL) {\n\t\t\tmemcpy(&p, &t->parms, sizeof(p));\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p,\n\t\t\t\t\t sizeof(p)))\n\t\t\t\tgoto done;\n#ifdef CONFIG_IPV6_SIT_6RD\n\t\t} else {\n\t\t\tipv6_addr_copy(&ip6rd.prefix, &t->ip6rd.prefix);\n\t\t\tip6rd.relay_prefix = t->ip6rd.relay_prefix;\n\t\t\tip6rd.prefixlen = t->ip6rd.prefixlen;\n\t\t\tip6rd.relay_prefixlen = t->ip6rd.relay_prefixlen;\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &ip6rd,\n\t\t\t\t\t sizeof(ip6rd)))\n\t\t\t\tgoto done;\n#endif\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPV6 ||\n\t\t    p.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\n\t\t\tgoto done;\n\t\tif (p.iph.ttl)\n\t\t\tp.iph.frag_off |= htons(IP_DF);\n\n\t\tt = ipip6_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != sitn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||\n\t\t\t\t    (!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt = netdev_priv(dev);\n\t\t\t\tipip6_tunnel_unlink(sitn, t);\n\t\t\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\t\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t\t\tipip6_tunnel_link(sitn, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\t\tt->parms.iph.ttl = p.iph.ttl;\n\t\t\t\tt->parms.iph.tos = p.iph.tos;\n\t\t\t\tif (t->parms.link != p.link) {\n\t\t\t\t\tt->parms.link = p.link;\n\t\t\t\t\tipip6_tunnel_bind_dev(dev);\n\t\t\t\t\tnetdev_state_change(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == sitn->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ipip6_tunnel_locate(net, &p, 0)) == NULL)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t == netdev_priv(sitn->fb_tunnel_dev))\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCGETPRL:\n\t\terr = -EINVAL;\n\t\tif (dev == sitn->fb_tunnel_dev)\n\t\t\tgoto done;\n\t\terr = -ENOENT;\n\t\tif (!(t = netdev_priv(dev)))\n\t\t\tgoto done;\n\t\terr = ipip6_tunnel_get_prl(t, ifr->ifr_ifru.ifru_data);\n\t\tbreak;\n\n\tcase SIOCADDPRL:\n\tcase SIOCDELPRL:\n\tcase SIOCCHGPRL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\t\terr = -EINVAL;\n\t\tif (dev == sitn->fb_tunnel_dev)\n\t\t\tgoto done;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&prl, ifr->ifr_ifru.ifru_data, sizeof(prl)))\n\t\t\tgoto done;\n\t\terr = -ENOENT;\n\t\tif (!(t = netdev_priv(dev)))\n\t\t\tgoto done;\n\n\t\tswitch (cmd) {\n\t\tcase SIOCDELPRL:\n\t\t\terr = ipip6_tunnel_del_prl(t, &prl);\n\t\t\tbreak;\n\t\tcase SIOCADDPRL:\n\t\tcase SIOCCHGPRL:\n\t\t\terr = ipip6_tunnel_add_prl(t, &prl, cmd == SIOCCHGPRL);\n\t\t\tbreak;\n\t\t}\n\t\tnetdev_state_change(dev);\n\t\tbreak;\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tcase SIOCADD6RD:\n\tcase SIOCCHG6RD:\n\tcase SIOCDEL6RD:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&ip6rd, ifr->ifr_ifru.ifru_data,\n\t\t\t\t   sizeof(ip6rd)))\n\t\t\tgoto done;\n\n\t\tt = netdev_priv(dev);\n\n\t\tif (cmd != SIOCDEL6RD) {\n\t\t\tstruct in6_addr prefix;\n\t\t\t__be32 relay_prefix;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (ip6rd.relay_prefixlen > 32 ||\n\t\t\t    ip6rd.prefixlen + (32 - ip6rd.relay_prefixlen) > 64)\n\t\t\t\tgoto done;\n\n\t\t\tipv6_addr_prefix(&prefix, &ip6rd.prefix,\n\t\t\t\t\t ip6rd.prefixlen);\n\t\t\tif (!ipv6_addr_equal(&prefix, &ip6rd.prefix))\n\t\t\t\tgoto done;\n\t\t\tif (ip6rd.relay_prefixlen)\n\t\t\t\trelay_prefix = ip6rd.relay_prefix &\n\t\t\t\t\t       htonl(0xffffffffUL <<\n\t\t\t\t\t\t     (32 - ip6rd.relay_prefixlen));\n\t\t\telse\n\t\t\t\trelay_prefix = 0;\n\t\t\tif (relay_prefix != ip6rd.relay_prefix)\n\t\t\t\tgoto done;\n\n\t\t\tipv6_addr_copy(&t->ip6rd.prefix, &prefix);\n\t\t\tt->ip6rd.relay_prefix = relay_prefix;\n\t\t\tt->ip6rd.prefixlen = ip6rd.prefixlen;\n\t\t\tt->ip6rd.relay_prefixlen = ip6rd.relay_prefixlen;\n\t\t} else\n\t\t\tipip6_tunnel_clone_6rd(dev, sitn);\n\n\t\terr = 0;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ipip6_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < IPV6_MIN_MTU || new_mtu > 0xFFF8 - sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops ipip6_netdev_ops = {\n\t.ndo_uninit\t= ipip6_tunnel_uninit,\n\t.ndo_start_xmit\t= ipip6_tunnel_xmit,\n\t.ndo_do_ioctl\t= ipip6_tunnel_ioctl,\n\t.ndo_change_mtu\t= ipip6_tunnel_change_mtu,\n};\n\nstatic void ipip6_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipip6_netdev_ops;\n\tdev->destructor \t= free_netdev;\n\n\tdev->type\t\t= ARPHRD_SIT;\n\tdev->hard_header_len \t= LL_MAX_HEADER + sizeof(struct iphdr);\n\tdev->mtu\t\t= ETH_DATA_LEN - sizeof(struct iphdr);\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->iflink\t\t= 0;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic void ipip6_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\tipip6_tunnel_bind_dev(dev);\n}\n\nstatic void __net_init ipip6_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_IPV6;\n\tiph->ihl\t\t= 5;\n\tiph->ttl\t\t= 64;\n\n\tdev_hold(dev);\n\tsitn->tunnels_wc[0]\t= tunnel;\n}\n\nstatic struct xfrm_tunnel sit_handler = {\n\t.handler\t=\tipip6_rcv,\n\t.err_handler\t=\tipip6_err,\n\t.priority\t=\t1,\n};\n\nstatic void __net_exit sit_destroy_tunnels(struct sit_net *sitn, struct list_head *head)\n{\n\tint prio;\n\n\tfor (prio = 1; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\t\tstruct ip_tunnel *t = sitn->tunnels[prio][h];\n\n\t\t\twhile (t != NULL) {\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t\t\t\tt = t->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tint err;\n\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\n\tif ((err = register_netdev(sitn->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tdev_put(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit sit_exit_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tsit_destroy_tunnels(sitn, &list);\n\tunregister_netdevice_queue(sitn->fb_tunnel_dev, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations sit_net_ops = {\n\t.init = sit_init_net,\n\t.exit = sit_exit_net,\n\t.id   = &sit_net_id,\n\t.size = sizeof(struct sit_net),\n};\n\nstatic void __exit sit_cleanup(void)\n{\n\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\tunregister_pernet_device(&sit_net_ops);\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n}\n\nstatic int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}\n\nmodule_init(sit_init);\nmodule_exit(sit_cleanup);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"sit0\");\n", "/*\n * Copyright (C)2003,2004 USAGI/WIDE Project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors\tMitsuru KANDA  <mk@linux-ipv6.org>\n * \t\tYOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\n *\n * Based on net/ipv4/xfrm4_tunnel.c\n *\n */\n#include <linux/module.h>\n#include <linux/xfrm.h>\n#include <linux/rculist.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/mutex.h>\n#include <net/netns/generic.h>\n\n#define XFRM6_TUNNEL_SPI_BYADDR_HSIZE 256\n#define XFRM6_TUNNEL_SPI_BYSPI_HSIZE 256\n\n#define XFRM6_TUNNEL_SPI_MIN\t1\n#define XFRM6_TUNNEL_SPI_MAX\t0xffffffff\n\nstruct xfrm6_tunnel_net {\n\tstruct hlist_head spi_byaddr[XFRM6_TUNNEL_SPI_BYADDR_HSIZE];\n\tstruct hlist_head spi_byspi[XFRM6_TUNNEL_SPI_BYSPI_HSIZE];\n\tu32 spi;\n};\n\nstatic int xfrm6_tunnel_net_id __read_mostly;\nstatic inline struct xfrm6_tunnel_net *xfrm6_tunnel_pernet(struct net *net)\n{\n\treturn net_generic(net, xfrm6_tunnel_net_id);\n}\n\n/*\n * xfrm_tunnel_spi things are for allocating unique id (\"spi\")\n * per xfrm_address_t.\n */\nstruct xfrm6_tunnel_spi {\n\tstruct hlist_node\tlist_byaddr;\n\tstruct hlist_node\tlist_byspi;\n\txfrm_address_t\t\taddr;\n\tu32\t\t\tspi;\n\tatomic_t\t\trefcnt;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstatic DEFINE_SPINLOCK(xfrm6_tunnel_spi_lock);\n\nstatic struct kmem_cache *xfrm6_tunnel_spi_kmem __read_mostly;\n\nstatic inline unsigned xfrm6_tunnel_spi_hash_byaddr(xfrm_address_t *addr)\n{\n\tunsigned h;\n\n\th = (__force u32)(addr->a6[0] ^ addr->a6[1] ^ addr->a6[2] ^ addr->a6[3]);\n\th ^= h >> 16;\n\th ^= h >> 8;\n\th &= XFRM6_TUNNEL_SPI_BYADDR_HSIZE - 1;\n\n\treturn h;\n}\n\nstatic inline unsigned xfrm6_tunnel_spi_hash_byspi(u32 spi)\n{\n\treturn spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;\n}\n\n\nstatic int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}\n\nstatic struct xfrm6_tunnel_spi *__xfrm6_tunnel_spi_lookup(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tstruct hlist_node *pos;\n\n\thlist_for_each_entry_rcu(x6spi, pos,\n\t\t\t     &xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\n\t\t\t     list_byaddr) {\n\t\tif (memcmp(&x6spi->addr, saddr, sizeof(x6spi->addr)) == 0)\n\t\t\treturn x6spi;\n\t}\n\n\treturn NULL;\n}\n\n__be32 xfrm6_tunnel_spi_lookup(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tu32 spi;\n\n\trcu_read_lock_bh();\n\tx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\n\tspi = x6spi ? x6spi->spi : 0;\n\trcu_read_unlock_bh();\n\treturn htonl(spi);\n}\n\nEXPORT_SYMBOL(xfrm6_tunnel_spi_lookup);\n\nstatic int __xfrm6_tunnel_spi_check(struct net *net, u32 spi)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tint index = xfrm6_tunnel_spi_hash_byspi(spi);\n\tstruct hlist_node *pos;\n\n\thlist_for_each_entry(x6spi, pos,\n\t\t\t     &xfrm6_tn->spi_byspi[index],\n\t\t\t     list_byspi) {\n\t\tif (x6spi->spi == spi)\n\t\t\treturn -1;\n\t}\n\treturn index;\n}\n\nstatic u32 __xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tu32 spi;\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tint index;\n\n\tif (xfrm6_tn->spi < XFRM6_TUNNEL_SPI_MIN ||\n\t    xfrm6_tn->spi >= XFRM6_TUNNEL_SPI_MAX)\n\t\txfrm6_tn->spi = XFRM6_TUNNEL_SPI_MIN;\n\telse\n\t\txfrm6_tn->spi++;\n\n\tfor (spi = xfrm6_tn->spi; spi <= XFRM6_TUNNEL_SPI_MAX; spi++) {\n\t\tindex = __xfrm6_tunnel_spi_check(net, spi);\n\t\tif (index >= 0)\n\t\t\tgoto alloc_spi;\n\t}\n\tfor (spi = XFRM6_TUNNEL_SPI_MIN; spi < xfrm6_tn->spi; spi++) {\n\t\tindex = __xfrm6_tunnel_spi_check(net, spi);\n\t\tif (index >= 0)\n\t\t\tgoto alloc_spi;\n\t}\n\tspi = 0;\n\tgoto out;\nalloc_spi:\n\txfrm6_tn->spi = spi;\n\tx6spi = kmem_cache_alloc(xfrm6_tunnel_spi_kmem, GFP_ATOMIC);\n\tif (!x6spi)\n\t\tgoto out;\n\n\tINIT_RCU_HEAD(&x6spi->rcu_head);\n\tmemcpy(&x6spi->addr, saddr, sizeof(x6spi->addr));\n\tx6spi->spi = spi;\n\tatomic_set(&x6spi->refcnt, 1);\n\n\thlist_add_head_rcu(&x6spi->list_byspi, &xfrm6_tn->spi_byspi[index]);\n\n\tindex = xfrm6_tunnel_spi_hash_byaddr(saddr);\n\thlist_add_head_rcu(&x6spi->list_byaddr, &xfrm6_tn->spi_byaddr[index]);\nout:\n\treturn spi;\n}\n\n__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tu32 spi;\n\n\tspin_lock_bh(&xfrm6_tunnel_spi_lock);\n\tx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\n\tif (x6spi) {\n\t\tatomic_inc(&x6spi->refcnt);\n\t\tspi = x6spi->spi;\n\t} else\n\t\tspi = __xfrm6_tunnel_alloc_spi(net, saddr);\n\tspin_unlock_bh(&xfrm6_tunnel_spi_lock);\n\n\treturn htonl(spi);\n}\n\nEXPORT_SYMBOL(xfrm6_tunnel_alloc_spi);\n\nstatic void x6spi_destroy_rcu(struct rcu_head *head)\n{\n\tkmem_cache_free(xfrm6_tunnel_spi_kmem,\n\t\t\tcontainer_of(head, struct xfrm6_tunnel_spi, rcu_head));\n}\n\nvoid xfrm6_tunnel_free_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tstruct hlist_node *pos, *n;\n\n\tspin_lock_bh(&xfrm6_tunnel_spi_lock);\n\n\thlist_for_each_entry_safe(x6spi, pos, n,\n\t\t\t\t  &xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\n\t\t\t\t  list_byaddr)\n\t{\n\t\tif (memcmp(&x6spi->addr, saddr, sizeof(x6spi->addr)) == 0) {\n\t\t\tif (atomic_dec_and_test(&x6spi->refcnt)) {\n\t\t\t\thlist_del_rcu(&x6spi->list_byaddr);\n\t\t\t\thlist_del_rcu(&x6spi->list_byspi);\n\t\t\t\tcall_rcu(&x6spi->rcu_head, x6spi_destroy_rcu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&xfrm6_tunnel_spi_lock);\n}\n\nEXPORT_SYMBOL(xfrm6_tunnel_free_spi);\n\nstatic int xfrm6_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tskb_push(skb, -skb_network_offset(skb));\n\treturn 0;\n}\n\nstatic int xfrm6_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\treturn skb_network_header(skb)[IP6CB(skb)->nhoff];\n}\n\nstatic int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup(net, (xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi) > 0 ? : 0;\n}\n\nstatic int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t/* xfrm6_tunnel native err handling */\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMPV6_NOROUTE:\n\t\tcase ICMPV6_ADM_PROHIBITED:\n\t\tcase ICMPV6_NOT_NEIGHBOUR:\n\t\tcase ICMPV6_ADDR_UNREACH:\n\t\tcase ICMPV6_PORT_UNREACH:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tswitch (code) {\n\t\tcase ICMPV6_EXC_HOPLIMIT:\n\t\t\tbreak;\n\t\tcase ICMPV6_EXC_FRAGTIME:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tswitch (code) {\n\t\tcase ICMPV6_HDR_FIELD: break;\n\t\tcase ICMPV6_UNK_NEXTHDR: break;\n\t\tcase ICMPV6_UNK_OPTION: break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm6_tunnel_init_state(struct xfrm_state *x)\n{\n\tif (x->props.mode != XFRM_MODE_TUNNEL)\n\t\treturn -EINVAL;\n\n\tif (x->encap)\n\t\treturn -EINVAL;\n\n\tx->props.header_len = sizeof(struct ipv6hdr);\n\n\treturn 0;\n}\n\nstatic void xfrm6_tunnel_destroy(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\n\txfrm6_tunnel_free_spi(net, (xfrm_address_t *)&x->props.saddr);\n}\n\nstatic const struct xfrm_type xfrm6_tunnel_type = {\n\t.description\t= \"IP6IP6\",\n\t.owner          = THIS_MODULE,\n\t.proto\t\t= IPPROTO_IPV6,\n\t.init_state\t= xfrm6_tunnel_init_state,\n\t.destructor\t= xfrm6_tunnel_destroy,\n\t.input\t\t= xfrm6_tunnel_input,\n\t.output\t\t= xfrm6_tunnel_output,\n};\n\nstatic struct xfrm6_tunnel xfrm6_tunnel_handler = {\n\t.handler\t= xfrm6_tunnel_rcv,\n\t.err_handler\t= xfrm6_tunnel_err,\n\t.priority\t= 2,\n};\n\nstatic struct xfrm6_tunnel xfrm46_tunnel_handler = {\n\t.handler\t= xfrm6_tunnel_rcv,\n\t.err_handler\t= xfrm6_tunnel_err,\n\t.priority\t= 2,\n};\n\nstatic int __net_init xfrm6_tunnel_net_init(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tn->spi_byaddr[i]);\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tn->spi_byspi[i]);\n\txfrm6_tn->spi = 0;\n\n\treturn 0;\n}\n\nstatic void __net_exit xfrm6_tunnel_net_exit(struct net *net)\n{\n}\n\nstatic struct pernet_operations xfrm6_tunnel_net_ops = {\n\t.init\t= xfrm6_tunnel_net_init,\n\t.exit\t= xfrm6_tunnel_net_exit,\n\t.id\t= &xfrm6_tunnel_net_id,\n\t.size\t= sizeof(struct xfrm6_tunnel_net),\n};\n\nstatic int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}\n\nstatic void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}\n\nmodule_init(xfrm6_tunnel_init);\nmodule_exit(xfrm6_tunnel_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_IPV6);\n"], "fixing_code": ["/*\n *\tLinux NET3:\tIP/IP protocol decoder.\n *\n *\tAuthors:\n *\t\tSam Lantinga (slouken@cs.ucdavis.edu)  02/01/95\n *\n *\tFixes:\n *\t\tAlan Cox\t:\tMerged and made usable non modular (its so tiny its silly as\n *\t\t\t\t\ta module taking up 2 pages).\n *\t\tAlan Cox\t: \tFixed bug with 1.3.18 and IPIP not working (now needs to set skb->h.iph)\n *\t\t\t\t\tto keep ip_forward happy.\n *\t\tAlan Cox\t:\tMore fixes for 1.3.21, and firewall fix. Maybe this will work soon 8).\n *\t\tKai Schulte\t:\tFixed #defines for IP_FIREWALL->FIREWALL\n *              David Woodhouse :       Perform some basic ICMP handling.\n *                                      IPIP Routing without decapsulation.\n *              Carlos Picoto   :       GRE over IP support\n *\t\tAlexey Kuznetsov:\tReworked. Really, now it is truncated version of ipv4/ip_gre.c.\n *\t\t\t\t\tI do not want to merge them together.\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n */\n\n/* tunnel.c: an IP tunnel driver\n\n\tThe purpose of this driver is to provide an IP tunnel through\n\twhich you can tunnel network traffic transparently across subnets.\n\n\tThis was written by looking at Nick Holloway's dummy driver\n\tThanks for the great code!\n\n\t\t-Sam Lantinga\t(slouken@cs.ucdavis.edu)  02/01/95\n\n\tMinor tweaks:\n\t\tCleaned up the code a little and added some pre-1.3.0 tweaks.\n\t\tdev->hard_header/hard_header_len changed to use no headers.\n\t\tComments/bracketing tweaked.\n\t\tMade the tunnels use dev->name not tunnel: when error reporting.\n\t\tAdded tx_dropped stat\n\n\t\t-Alan Cox\t(alan@lxorguk.ukuu.org.uk) 21 March 95\n\n\tReworked:\n\t\tChanged to tunnel to destination gateway in addition to the\n\t\t\ttunnel's pointopoint address\n\t\tAlmost completely rewritten\n\t\tNote:  There is currently no firewall or ICMP handling done.\n\n\t\t-Sam Lantinga\t(slouken@cs.ucdavis.edu) 02/13/96\n\n*/\n\n/* Things I wish I had known when writing the tunnel driver:\n\n\tWhen the tunnel_xmit() function is called, the skb contains the\n\tpacket to be sent (plus a great deal of extra info), and dev\n\tcontains the tunnel device that _we_ are.\n\n\tWhen we are passed a packet, we are expected to fill in the\n\tsource address with our source IP address.\n\n\tWhat is the proper way to allocate, copy and free a buffer?\n\tAfter you allocate it, it is a \"0 length\" chunk of memory\n\tstarting at zero.  If you want to add headers to the buffer\n\tlater, you'll have to call \"skb_reserve(skb, amount)\" with\n\tthe amount of memory you want reserved.  Then, you call\n\t\"skb_put(skb, amount)\" with the amount of space you want in\n\tthe buffer.  skb_put() returns a pointer to the top (#0) of\n\tthat buffer.  skb->len is set to the amount of space you have\n\t\"allocated\" with skb_put().  You can then write up to skb->len\n\tbytes to that buffer.  If you need more, you can call skb_put()\n\tagain with the additional amount of space you need.  You can\n\tfind out how much more space you can allocate by calling\n\t\"skb_tailroom(skb)\".\n\tNow, to add header space, call \"skb_push(skb, header_len)\".\n\tThis creates space at the beginning of the buffer and returns\n\ta pointer to this new space.  If later you need to strip a\n\theader from a buffer, call \"skb_pull(skb, header_len)\".\n\tskb_headroom() will return how much space is left at the top\n\tof the buffer (before the main data).  Remember, this headroom\n\tspace must be reserved before the skb_put() function is called.\n\t*/\n\n/*\n   This version of net/ipv4/ipip.c is cloned of net/ipv4/ip_gre.c\n\n   For comments look at net/ipv4/ip_gre.c --ANK\n */\n\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <asm/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/mroute.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/ipip.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#define HASH_SIZE  16\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\nstatic int ipip_net_id __read_mostly;\nstruct ipip_net {\n\tstruct ip_tunnel *tunnels_r_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_r[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_wc[1];\n\tstruct ip_tunnel **tunnels[4];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\nstatic void ipip_tunnel_init(struct net_device *dev);\nstatic void ipip_tunnel_setup(struct net_device *dev);\n\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ipip_lock);\n\n#define for_each_ip_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\nstatic struct ip_tunnel * ipip_tunnel_lookup(struct net *net,\n\t\t__be32 remote, __be32 local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_r_l[h0 ^ h1])\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_r[h0])\n\t\tif (remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_l[h1])\n\t\tif (local == t->parms.iph.saddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tt = rcu_dereference(ipn->tunnels_wc[0]);\n\tif (t && (t->dev->flags&IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}\n\nstatic struct ip_tunnel **__ipip_bucket(struct ipip_net *ipn,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (remote) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\tif (local) {\n\t\tprio |= 1;\n\t\th ^= HASH(local);\n\t}\n\treturn &ipn->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel **ipip_bucket(struct ipip_net *ipn,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipip_bucket(ipn, &t->parms);\n}\n\nstatic void ipip_tunnel_unlink(struct ipip_net *ipn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp;\n\n\tfor (tp = ipip_bucket(ipn, t); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ipip_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ipip_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ipip_tunnel_link(struct ipip_net *ipn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp = ipip_bucket(ipn, t);\n\n\tspin_lock_bh(&ipip_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ipip_lock);\n}\n\nstatic struct ip_tunnel * ipip_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tstruct ip_tunnel *t, **tp, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tfor (tp = __ipip_bucket(ipn, parms); (t = *tp) != NULL; tp = &t->next) {\n\t\tif (local == t->parms.iph.saddr && remote == t->parms.iph.daddr)\n\t\t\treturn t;\n\t}\n\tif (!create)\n\t\treturn NULL;\n\n\tif (parms->name[0])\n\t\tstrlcpy(name, parms->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"tunl%%d\");\n\n\tdev = alloc_netdev(sizeof(*t), name, ipip_tunnel_setup);\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tnt = netdev_priv(dev);\n\tnt->parms = *parms;\n\n\tipip_tunnel_init(dev);\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\tipip_tunnel_link(ipn, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstatic void ipip_tunnel_uninit(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tif (dev == ipn->fb_tunnel_dev) {\n\t\tspin_lock_bh(&ipip_lock);\n\t\tipn->tunnels_wc[0] = NULL;\n\t\tspin_unlock_bh(&ipip_lock);\n\t} else\n\t\tipip_tunnel_unlink(ipn, netdev_priv(dev));\n\tdev_put(dev);\n}\n\nstatic int ipip_err(struct sk_buff *skb, u32 info)\n{\n\n/* All the routers (except for Linux) return only\n   8 bytes of packet payload. It means, that precise relaying of\n   ICMP in the real Internet is absolutely infeasible.\n */\n\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t/* Impossible event. */\n\t\t\treturn 0;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t/* Soft state for pmtu is maintained by IP core. */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\terr = -ENOENT;\n\n\trcu_read_lock();\n\tt = ipip_tunnel_lookup(dev_net(skb->dev), iph->daddr, iph->saddr);\n\tif (t == NULL || t->parms.iph.daddr == 0)\n\t\tgoto out;\n\n\terr = 0;\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic inline void ipip_ecn_decapsulate(const struct iphdr *outer_iph,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct iphdr *inner_iph = ip_hdr(skb);\n\n\tif (INET_ECN_is_ce(outer_iph->tos))\n\t\tIP_ECN_set_ce(inner_iph);\n}\n\nstatic int ipip_rcv(struct sk_buff *skb)\n{\n\tstruct ip_tunnel *tunnel;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\n\trcu_read_lock();\n\tif ((tunnel = ipip_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tsecpath_reset(skb);\n\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\ttunnel->dev->stats.rx_packets++;\n\t\ttunnel->dev->stats.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\t\tipip_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn -1;\n}\n\n/*\n *\tThis function assumes it is being called from dev_queue_xmit()\n *\tand that skb is filled properly by that function.\n */\n\nstatic netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\tstruct iphdr  *tiph = &tunnel->parms.iph;\n\tu8     tos = tunnel->parms.iph.tos;\n\t__be16 df = tiph->frag_off;\n\tstruct rtable *rt;     \t\t\t/* Route to the other host */\n\tstruct net_device *tdev;\t\t\t/* Device to other host */\n\tstruct iphdr  *old_iph = ip_hdr(skb);\n\tstruct iphdr  *iph;\t\t\t/* Our new IP header */\n\tunsigned int max_headroom;\t\t/* The extra header space needed */\n\t__be32 dst = tiph->daddr;\n\tint    mtu;\n\n\tif (skb->protocol != htons(ETH_P_IP))\n\t\tgoto tx_error;\n\n\tif (tos&1)\n\t\ttos = old_iph->tos;\n\n\tif (!dst) {\n\t\t/* NBMA tunnel */\n\t\tif ((rt = skb_rtable(skb)) == NULL) {\n\t\t\tstats->tx_fifo_errors++;\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif ((dst = rt->rt_gateway) == 0)\n\t\t\tgoto tx_error_icmp;\n\t}\n\n\t{\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = dst,\n\t\t\t\t\t\t.saddr = tiph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(tos) } },\n\t\t\t\t    .proto = IPPROTO_IPIP };\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\tstats->tx_carrier_errors++;\n\t\t\tgoto tx_error_icmp;\n\t\t}\n\t}\n\ttdev = rt->u.dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tstats->collisions++;\n\t\tgoto tx_error;\n\t}\n\n\tdf |= old_iph->frag_off & htons(IP_DF);\n\n\tif (df) {\n\t\tmtu = dst_mtu(&rt->u.dst) - sizeof(struct iphdr);\n\n\t\tif (mtu < 68) {\n\t\t\tstats->collisions++;\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (skb_dst(skb))\n\t\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\n\t\tif ((old_iph->frag_off & htons(IP_DF)) &&\n\t\t    mtu < ntohs(old_iph->tot_len)) {\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t  htonl(mtu));\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\t/*\n\t * Okay, now see if we can stuff it in the buffer as-is.\n\t */\n\tmax_headroom = (LL_RESERVED_SPACE(tdev)+sizeof(struct iphdr));\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\ttxq->tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\told_iph = ip_hdr(skb);\n\t}\n\n\tskb->transport_header = skb->network_header;\n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\n\t\t\t      IPSKB_REROUTED);\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->u.dst);\n\n\t/*\n\t *\tPush down and install the IPIP header.\n\t */\n\n\tiph \t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr)>>2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tIPPROTO_IPIP;\n\tiph->tos\t\t=\tINET_ECN_encapsulate(tos, old_iph->tos);\n\tiph->daddr\t\t=\trt->rt_dst;\n\tiph->saddr\t\t=\trt->rt_src;\n\n\tif ((iph->ttl = tiph->ttl) == 0)\n\t\tiph->ttl\t=\told_iph->ttl;\n\n\tnf_reset(skb);\n\n\tIPTUNNEL_XMIT();\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\ntx_error:\n\tstats->tx_errors++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipip_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\tif (iph->daddr) {\n\t\tstruct flowi fl = { .oif = tunnel->parms.link,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = iph->daddr,\n\t\t\t\t\t\t.saddr = iph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(iph->tos) } },\n\t\t\t\t    .proto = IPPROTO_IPIP };\n\t\tstruct rtable *rt;\n\t\tif (!ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\ttdev = rt->u.dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\n\n\tif (tdev) {\n\t\tdev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);\n\t\tdev->mtu = tdev->mtu - sizeof(struct iphdr);\n\t}\n\tdev->iflink = tunnel->parms.link;\n}\n\nstatic int\nipip_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel *t;\n\tstruct net *net = dev_net(dev);\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tt = NULL;\n\t\tif (dev == ipn->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ipip_tunnel_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\t\tmemcpy(&p, &t->parms, sizeof(p));\n\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPIP ||\n\t\t    p.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\n\t\t\tgoto done;\n\t\tif (p.iph.ttl)\n\t\t\tp.iph.frag_off |= htons(IP_DF);\n\n\t\tt = ipip_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != ipn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||\n\t\t\t\t    (!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt = netdev_priv(dev);\n\t\t\t\tipip_tunnel_unlink(ipn, t);\n\t\t\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\t\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t\t\tipip_tunnel_link(ipn, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\t\tt->parms.iph.ttl = p.iph.ttl;\n\t\t\t\tt->parms.iph.tos = p.iph.tos;\n\t\t\t\tt->parms.iph.frag_off = p.iph.frag_off;\n\t\t\t\tif (t->parms.link != p.link) {\n\t\t\t\t\tt->parms.link = p.link;\n\t\t\t\t\tipip_tunnel_bind_dev(dev);\n\t\t\t\t\tnetdev_state_change(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == ipn->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ipip_tunnel_locate(net, &p, 0)) == NULL)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t->dev == ipn->fb_tunnel_dev)\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ipip_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < 68 || new_mtu > 0xFFF8 - sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops ipip_netdev_ops = {\n\t.ndo_uninit\t= ipip_tunnel_uninit,\n\t.ndo_start_xmit\t= ipip_tunnel_xmit,\n\t.ndo_do_ioctl\t= ipip_tunnel_ioctl,\n\t.ndo_change_mtu\t= ipip_tunnel_change_mtu,\n\n};\n\nstatic void ipip_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipip_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\n\tdev->type\t\t= ARPHRD_TUNNEL;\n\tdev->hard_header_len \t= LL_MAX_HEADER + sizeof(struct iphdr);\n\tdev->mtu\t\t= ETH_DATA_LEN - sizeof(struct iphdr);\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->iflink\t\t= 0;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n}\n\nstatic void ipip_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\tipip_tunnel_bind_dev(dev);\n}\n\nstatic void __net_init ipip_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct ipip_net *ipn = net_generic(dev_net(dev), ipip_net_id);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_IPIP;\n\tiph->ihl\t\t= 5;\n\n\tdev_hold(dev);\n\tipn->tunnels_wc[0]\t= tunnel;\n}\n\nstatic struct xfrm_tunnel ipip_handler = {\n\t.handler\t=\tipip_rcv,\n\t.err_handler\t=\tipip_err,\n\t.priority\t=\t1,\n};\n\nstatic const char banner[] __initconst =\n\tKERN_INFO \"IPv4 over IPv4 tunneling driver\\n\";\n\nstatic void ipip_destroy_tunnels(struct ipip_net *ipn, struct list_head *head)\n{\n\tint prio;\n\n\tfor (prio = 1; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\t\tstruct ip_tunnel *t = ipn->tunnels[prio][h];\n\n\t\t\twhile (t != NULL) {\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t\t\t\tt = t->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init ipip_init_net(struct net *net)\n{\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\tint err;\n\n\tipn->tunnels[0] = ipn->tunnels_wc;\n\tipn->tunnels[1] = ipn->tunnels_l;\n\tipn->tunnels[2] = ipn->tunnels_r;\n\tipn->tunnels[3] = ipn->tunnels_r_l;\n\n\tipn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel),\n\t\t\t\t\t   \"tunl0\",\n\t\t\t\t\t   ipip_tunnel_setup);\n\tif (!ipn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(ipn->fb_tunnel_dev, net);\n\n\tipip_fb_tunnel_init(ipn->fb_tunnel_dev);\n\n\tif ((err = register_netdev(ipn->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tfree_netdev(ipn->fb_tunnel_dev);\nerr_alloc_dev:\n\t/* nothing */\n\treturn err;\n}\n\nstatic void __net_exit ipip_exit_net(struct net *net)\n{\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tipip_destroy_tunnels(ipn, &list);\n\tunregister_netdevice_queue(ipn->fb_tunnel_dev, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ipip_net_ops = {\n\t.init = ipip_init_net,\n\t.exit = ipip_exit_net,\n\t.id   = &ipip_net_id,\n\t.size = sizeof(struct ipip_net),\n};\n\nstatic int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\n\tif (err < 0) {\n\t\tunregister_pernet_device(&ipip_net_ops);\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t}\n\treturn err;\n}\n\nstatic void __exit ipip_fini(void)\n{\n\tif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\n\t\tprintk(KERN_INFO \"ipip close: can't deregister tunnel\\n\");\n\n\tunregister_pernet_device(&ipip_net_ops);\n}\n\nmodule_init(ipip_init);\nmodule_exit(ipip_fini);\nMODULE_LICENSE(\"GPL\");\n", "/*\n *\tIPv6 tunneling device\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tVille Nuorvala\t\t<vnuorval@tcs.hut.fi>\n *\tYasuyuki Kozakai\t<kozakai@linux-ipv6.org>\n *\n *      Based on:\n *      linux/net/ipv6/sit.c and linux/net/ipv4/ipip.c\n *\n *      RFC 2473\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/sockios.h>\n#include <linux/icmp.h>\n#include <linux/if.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/if_tunnel.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/route.h>\n#include <linux/rtnetlink.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <asm/uaccess.h>\n#include <asm/atomic.h>\n\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ip6_tunnel.h>\n#include <net/xfrm.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\nMODULE_AUTHOR(\"Ville Nuorvala\");\nMODULE_DESCRIPTION(\"IPv6 tunneling device\");\nMODULE_LICENSE(\"GPL\");\n\n#define IPV6_TLV_TEL_DST_SIZE 8\n\n#ifdef IP6_TNL_DEBUG\n#define IP6_TNL_TRACE(x...) printk(KERN_DEBUG \"%s:\" x \"\\n\", __func__)\n#else\n#define IP6_TNL_TRACE(x...) do {;} while(0)\n#endif\n\n#define IPV6_TCLASS_MASK (IPV6_FLOWINFO_MASK & ~IPV6_FLOWLABEL_MASK)\n#define IPV6_TCLASS_SHIFT 20\n\n#define HASH_SIZE  32\n\n#define HASH(addr) ((__force u32)((addr)->s6_addr32[0] ^ (addr)->s6_addr32[1] ^ \\\n\t\t     (addr)->s6_addr32[2] ^ (addr)->s6_addr32[3]) & \\\n\t\t    (HASH_SIZE - 1))\n\nstatic void ip6_tnl_dev_init(struct net_device *dev);\nstatic void ip6_tnl_dev_setup(struct net_device *dev);\n\nstatic int ip6_tnl_net_id __read_mostly;\nstruct ip6_tnl_net {\n\t/* the IPv6 tunnel fallback device */\n\tstruct net_device *fb_tnl_dev;\n\t/* lists for storing tunnels in use */\n\tstruct ip6_tnl *tnls_r_l[HASH_SIZE];\n\tstruct ip6_tnl *tnls_wc[1];\n\tstruct ip6_tnl **tnls[2];\n};\n\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ip6_tnl_lock);\n\nstatic inline struct dst_entry *ip6_tnl_dst_check(struct ip6_tnl *t)\n{\n\tstruct dst_entry *dst = t->dst_cache;\n\n\tif (dst && dst->obsolete &&\n\t    dst->ops->check(dst, t->dst_cookie) == NULL) {\n\t\tt->dst_cache = NULL;\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\treturn dst;\n}\n\nstatic inline void ip6_tnl_dst_reset(struct ip6_tnl *t)\n{\n\tdst_release(t->dst_cache);\n\tt->dst_cache = NULL;\n}\n\nstatic inline void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) dst;\n\tt->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;\n\tdst_release(t->dst_cache);\n\tt->dst_cache = dst;\n}\n\n/**\n * ip6_tnl_lookup - fetch tunnel matching the end-point addresses\n *   @remote: the address of the tunnel exit-point\n *   @local: the address of the tunnel entry-point\n *\n * Return:\n *   tunnel matching given end-points if found,\n *   else fallback tunnel if its device is up,\n *   else %NULL\n **/\n\n#define for_each_ip6_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\nstatic struct ip6_tnl *\nip6_tnl_lookup(struct net *net, struct in6_addr *remote, struct in6_addr *local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip6_tnl *t;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tfor_each_ip6_tunnel_rcu(ip6n->tnls_r_l[h0 ^ h1]) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tt = rcu_dereference(ip6n->tnls_wc[0]);\n\tif (t && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\n\treturn NULL;\n}\n\n/**\n * ip6_tnl_bucket - get head of list matching given tunnel parameters\n *   @p: parameters containing tunnel end-points\n *\n * Description:\n *   ip6_tnl_bucket() returns the head of the list matching the\n *   &struct in6_addr entries laddr and raddr in @p.\n *\n * Return: head of IPv6 tunnel list\n **/\n\nstatic struct ip6_tnl **\nip6_tnl_bucket(struct ip6_tnl_net *ip6n, struct ip6_tnl_parm *p)\n{\n\tstruct in6_addr *remote = &p->raddr;\n\tstruct in6_addr *local = &p->laddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\n\t\tprio = 1;\n\t\th = HASH(remote) ^ HASH(local);\n\t}\n\treturn &ip6n->tnls[prio][h];\n}\n\n/**\n * ip6_tnl_link - add tunnel to hash table\n *   @t: tunnel to be added\n **/\n\nstatic void\nip6_tnl_link(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl **tp = ip6_tnl_bucket(ip6n, &t->parms);\n\n\tspin_lock_bh(&ip6_tnl_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ip6_tnl_lock);\n}\n\n/**\n * ip6_tnl_unlink - remove tunnel from hash table\n *   @t: tunnel to be removed\n **/\n\nstatic void\nip6_tnl_unlink(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl **tp;\n\n\tfor (tp = ip6_tnl_bucket(ip6n, &t->parms); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ip6_tnl_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ip6_tnl_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * ip6_tnl_create() - create a new tunnel\n *   @p: tunnel parameters\n *   @pt: pointer to new tunnel\n *\n * Description:\n *   Create tunnel matching given parameters.\n *\n * Return:\n *   created tunnel or NULL\n **/\n\nstatic struct ip6_tnl *ip6_tnl_create(struct net *net, struct ip6_tnl_parm *p)\n{\n\tstruct net_device *dev;\n\tstruct ip6_tnl *t;\n\tchar name[IFNAMSIZ];\n\tint err;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tif (p->name[0])\n\t\tstrlcpy(name, p->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"ip6tnl%%d\");\n\n\tdev = alloc_netdev(sizeof (*t), name, ip6_tnl_dev_setup);\n\tif (dev == NULL)\n\t\tgoto failed;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tt = netdev_priv(dev);\n\tt->parms = *p;\n\tip6_tnl_dev_init(dev);\n\n\tif ((err = register_netdevice(dev)) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\tip6_tnl_link(ip6n, t);\n\treturn t;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\n\n/**\n * ip6_tnl_locate - find or create tunnel matching given parameters\n *   @p: tunnel parameters\n *   @create: != 0 if allowed to create new tunnel if no match found\n *\n * Description:\n *   ip6_tnl_locate() first tries to locate an existing tunnel\n *   based on @parms. If this is unsuccessful, but @create is set a new\n *   tunnel device is created and registered for use.\n *\n * Return:\n *   matching tunnel or NULL\n **/\n\nstatic struct ip6_tnl *ip6_tnl_locate(struct net *net,\n\t\tstruct ip6_tnl_parm *p, int create)\n{\n\tstruct in6_addr *remote = &p->raddr;\n\tstruct in6_addr *local = &p->laddr;\n\tstruct ip6_tnl *t;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tfor (t = *ip6_tnl_bucket(ip6n, p); t; t = t->next) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr))\n\t\t\treturn t;\n\t}\n\tif (!create)\n\t\treturn NULL;\n\treturn ip6_tnl_create(net, p);\n}\n\n/**\n * ip6_tnl_dev_uninit - tunnel device uninitializer\n *   @dev: the device to be destroyed\n *\n * Description:\n *   ip6_tnl_dev_uninit() removes tunnel from its list\n **/\n\nstatic void\nip6_tnl_dev_uninit(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tif (dev == ip6n->fb_tnl_dev) {\n\t\tspin_lock_bh(&ip6_tnl_lock);\n\t\tip6n->tnls_wc[0] = NULL;\n\t\tspin_unlock_bh(&ip6_tnl_lock);\n\t} else {\n\t\tip6_tnl_unlink(ip6n, t);\n\t}\n\tip6_tnl_dst_reset(t);\n\tdev_put(dev);\n}\n\n/**\n * parse_tvl_tnl_enc_lim - handle encapsulation limit option\n *   @skb: received socket buffer\n *\n * Return:\n *   0 if none was found,\n *   else index to encapsulation limit\n **/\n\nstatic __u16\nparse_tlv_tnl_enc_lim(struct sk_buff *skb, __u8 * raw)\n{\n\tstruct ipv6hdr *ipv6h = (struct ipv6hdr *) raw;\n\t__u8 nexthdr = ipv6h->nexthdr;\n\t__u16 off = sizeof (*ipv6h);\n\n\twhile (ipv6_ext_hdr(nexthdr) && nexthdr != NEXTHDR_NONE) {\n\t\t__u16 optlen = 0;\n\t\tstruct ipv6_opt_hdr *hdr;\n\t\tif (raw + off + sizeof (*hdr) > skb->data &&\n\t\t    !pskb_may_pull(skb, raw - skb->data + off + sizeof (*hdr)))\n\t\t\tbreak;\n\n\t\thdr = (struct ipv6_opt_hdr *) (raw + off);\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\tstruct frag_hdr *frag_hdr = (struct frag_hdr *) hdr;\n\t\t\tif (frag_hdr->frag_off)\n\t\t\t\tbreak;\n\t\t\toptlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH) {\n\t\t\toptlen = (hdr->hdrlen + 2) << 2;\n\t\t} else {\n\t\t\toptlen = ipv6_optlen(hdr);\n\t\t}\n\t\tif (nexthdr == NEXTHDR_DEST) {\n\t\t\t__u16 i = off + 2;\n\t\t\twhile (1) {\n\t\t\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\n\t\t\t\t/* No more room for encapsulation limit */\n\t\t\t\tif (i + sizeof (*tel) > off + optlen)\n\t\t\t\t\tbreak;\n\n\t\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &raw[i];\n\t\t\t\t/* return index of option if found and valid */\n\t\t\t\tif (tel->type == IPV6_TLV_TNL_ENCAP_LIMIT &&\n\t\t\t\t    tel->length == 1)\n\t\t\t\t\treturn i;\n\t\t\t\t/* else jump to next option */\n\t\t\t\tif (tel->type)\n\t\t\t\t\ti += tel->length + 2;\n\t\t\t\telse\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tnexthdr = hdr->nexthdr;\n\t\toff += optlen;\n\t}\n\treturn 0;\n}\n\n/**\n * ip6_tnl_err - tunnel error handler\n *\n * Description:\n *   ip6_tnl_err() should handle errors in the tunnel according\n *   to the specifications in RFC 2473.\n **/\n\nstatic int\nip6_tnl_err(struct sk_buff *skb, __u8 ipproto, struct inet6_skb_parm *opt,\n\t    u8 *type, u8 *code, int *msg, __u32 *info, int offset)\n{\n\tstruct ipv6hdr *ipv6h = (struct ipv6hdr *) skb->data;\n\tstruct ip6_tnl *t;\n\tint rel_msg = 0;\n\tu8 rel_type = ICMPV6_DEST_UNREACH;\n\tu8 rel_code = ICMPV6_ADDR_UNREACH;\n\t__u32 rel_info = 0;\n\t__u16 len;\n\tint err = -ENOENT;\n\n\t/* If the packet doesn't contain the original IPv6 header we are\n\t   in trouble since we might need the source address for further\n\t   processing of the error. */\n\n\trcu_read_lock();\n\tif ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->daddr,\n\t\t\t\t\t&ipv6h->saddr)) == NULL)\n\t\tgoto out;\n\n\tif (t->parms.proto != ipproto && t->parms.proto != 0)\n\t\tgoto out;\n\n\terr = 0;\n\n\tswitch (*type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Path to destination invalid \"\n\t\t\t       \"or inactive!\\n\", t->parms.name);\n\t\trel_msg = 1;\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif ((*code) == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"%s: Too small hop limit or \"\n\t\t\t\t       \"routing loop in tunnel!\\n\",\n\t\t\t\t       t->parms.name);\n\t\t\trel_msg = 1;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif ((*code) == ICMPV6_HDR_FIELD)\n\t\t\tteli = parse_tlv_tnl_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == *info - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"%s: Too small encapsulation \"\n\t\t\t\t\t       \"limit or routing loop in \"\n\t\t\t\t\t       \"tunnel!\\n\", t->parms.name);\n\t\t\t\trel_msg = 1;\n\t\t\t}\n\t\t} else if (net_ratelimit()) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Recipient unable to parse tunneled \"\n\t\t\t       \"packet!\\n \", t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = *info - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\n\t\tif ((len = sizeof (*ipv6h) + ntohs(ipv6h->payload_len)) > mtu) {\n\t\t\trel_type = ICMPV6_PKT_TOOBIG;\n\t\t\trel_code = 0;\n\t\t\trel_info = mtu;\n\t\t\trel_msg = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\t*type = rel_type;\n\t*code = rel_code;\n\t*info = rel_info;\n\t*msg = rel_msg;\n\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int\nip4ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t   u8 type, u8 code, int offset, __be32 info)\n{\n\tint rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\t__u32 rel_info = ntohl(info);\n\tint err;\n\tstruct sk_buff *skb2;\n\tstruct iphdr *eiph;\n\tstruct flowi fl;\n\tstruct rtable *rt;\n\n\terr = ip6_tnl_err(skb, IPPROTO_IPIP, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rel_msg == 0)\n\t\treturn 0;\n\n\tswitch (rel_type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tif (rel_code != ICMPV6_ADDR_UNREACH)\n\t\t\treturn 0;\n\t\trel_type = ICMP_DEST_UNREACH;\n\t\trel_code = ICMP_HOST_UNREACH;\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tif (rel_code != 0)\n\t\t\treturn 0;\n\t\trel_type = ICMP_DEST_UNREACH;\n\t\trel_code = ICMP_FRAG_NEEDED;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + sizeof(struct iphdr)))\n\t\treturn 0;\n\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn 0;\n\n\tskb_dst_drop(skb2);\n\n\tskb_pull(skb2, offset);\n\tskb_reset_network_header(skb2);\n\teiph = ip_hdr(skb2);\n\n\t/* Try to guess incoming interface */\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.fl4_dst = eiph->saddr;\n\tfl.fl4_tos = RT_TOS(eiph->tos);\n\tfl.proto = IPPROTO_IPIP;\n\tif (ip_route_output_key(dev_net(skb->dev), &rt, &fl))\n\t\tgoto out;\n\n\tskb2->dev = rt->u.dst.dev;\n\n\t/* route \"incoming\" packet */\n\tif (rt->rt_flags & RTCF_LOCAL) {\n\t\tip_rt_put(rt);\n\t\trt = NULL;\n\t\tfl.fl4_dst = eiph->daddr;\n\t\tfl.fl4_src = eiph->saddr;\n\t\tfl.fl4_tos = eiph->tos;\n\t\tif (ip_route_output_key(dev_net(skb->dev), &rt, &fl) ||\n\t\t    rt->u.dst.dev->type != ARPHRD_TUNNEL) {\n\t\t\tip_rt_put(rt);\n\t\t\tgoto out;\n\t\t}\n\t\tskb_dst_set(skb2, (struct dst_entry *)rt);\n\t} else {\n\t\tip_rt_put(rt);\n\t\tif (ip_route_input(skb2, eiph->daddr, eiph->saddr, eiph->tos,\n\t\t\t\t   skb2->dev) ||\n\t\t    skb_dst(skb2)->dev->type != ARPHRD_TUNNEL)\n\t\t\tgoto out;\n\t}\n\n\t/* change mtu on this route */\n\tif (rel_type == ICMP_DEST_UNREACH && rel_code == ICMP_FRAG_NEEDED) {\n\t\tif (rel_info > dst_mtu(skb_dst(skb2)))\n\t\t\tgoto out;\n\n\t\tskb_dst(skb2)->ops->update_pmtu(skb_dst(skb2), rel_info);\n\t}\n\n\ticmp_send(skb2, rel_type, rel_code, htonl(rel_info));\n\nout:\n\tkfree_skb(skb2);\n\treturn 0;\n}\n\nstatic int\nip6ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t   u8 type, u8 code, int offset, __be32 info)\n{\n\tint rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\t__u32 rel_info = ntohl(info);\n\tint err;\n\n\terr = ip6_tnl_err(skb, IPPROTO_IPV6, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rel_msg && pskb_may_pull(skb, offset + sizeof(struct ipv6hdr))) {\n\t\tstruct rt6_info *rt;\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\tif (!skb2)\n\t\t\treturn 0;\n\n\t\tskb_dst_drop(skb2);\n\t\tskb_pull(skb2, offset);\n\t\tskb_reset_network_header(skb2);\n\n\t\t/* Try to guess incoming interface */\n\t\trt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr,\n\t\t\t\tNULL, 0, 0);\n\n\t\tif (rt && rt->rt6i_dev)\n\t\t\tskb2->dev = rt->rt6i_dev;\n\n\t\ticmpv6_send(skb2, rel_type, rel_code, rel_info, skb2->dev);\n\n\t\tif (rt)\n\t\t\tdst_release(&rt->u.dst);\n\n\t\tkfree_skb(skb2);\n\t}\n\n\treturn 0;\n}\n\nstatic void ip4ip6_dscp_ecn_decapsulate(struct ip6_tnl *t,\n\t\t\t\t\tstruct ipv6hdr *ipv6h,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\t__u8 dsfield = ipv6_get_dsfield(ipv6h) & ~INET_ECN_MASK;\n\n\tif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n\t\tipv4_change_dsfield(ip_hdr(skb), INET_ECN_MASK, dsfield);\n\n\tif (INET_ECN_is_ce(dsfield))\n\t\tIP_ECN_set_ce(ip_hdr(skb));\n}\n\nstatic void ip6ip6_dscp_ecn_decapsulate(struct ip6_tnl *t,\n\t\t\t\t\tstruct ipv6hdr *ipv6h,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n\t\tipv6_copy_dscp(ipv6_get_dsfield(ipv6h), ipv6_hdr(skb));\n\n\tif (INET_ECN_is_ce(ipv6_get_dsfield(ipv6h)))\n\t\tIP6_ECN_set_ce(ipv6_hdr(skb));\n}\n\n/* called with rcu_read_lock() */\nstatic inline int ip6_tnl_rcv_ctl(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ret = 0;\n\tstruct net *net = dev_net(t->dev);\n\n\tif (p->flags & IP6_TNL_F_CAP_RCV) {\n\t\tstruct net_device *ldev = NULL;\n\n\t\tif (p->link)\n\t\t\tldev = dev_get_by_index_rcu(net, p->link);\n\n\t\tif ((ipv6_addr_is_multicast(&p->laddr) ||\n\t\t     likely(ipv6_chk_addr(net, &p->laddr, ldev, 0))) &&\n\t\t    likely(!ipv6_chk_addr(net, &p->raddr, NULL, 0)))\n\t\t\tret = 1;\n\n\t}\n\treturn ret;\n}\n\n/**\n * ip6_tnl_rcv - decapsulate IPv6 packet and retransmit it locally\n *   @skb: received socket buffer\n *   @protocol: ethernet protocol ID\n *   @dscp_ecn_decapsulate: the function to decapsulate DSCP code and ECN\n *\n * Return: 0\n **/\n\nstatic int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,\n\t\t       __u8 ipproto,\n\t\t       void (*dscp_ecn_decapsulate)(struct ip6_tnl *t,\n\t\t\t\t\t\t    struct ipv6hdr *ipv6h,\n\t\t\t\t\t\t    struct sk_buff *skb))\n{\n\tstruct ip6_tnl *t;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\n\trcu_read_lock();\n\n\tif ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,\n\t\t\t\t\t&ipv6h->daddr)) != NULL) {\n\t\tif (t->parms.proto != ipproto && t->parms.proto != 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!ip6_tnl_rcv_ctl(t)) {\n\t\t\tt->dev->stats.rx_dropped++;\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = htons(protocol);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tmemset(skb->cb, 0, sizeof(struct inet6_skb_parm));\n\t\tskb->dev = t->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\n\t\tdscp_ecn_decapsulate(t, ipv6h, skb);\n\n\t\tt->dev->stats.rx_packets++;\n\t\tt->dev->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\treturn 1;\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ip4ip6_rcv(struct sk_buff *skb)\n{\n\treturn ip6_tnl_rcv(skb, ETH_P_IP, IPPROTO_IPIP,\n\t\t\t   ip4ip6_dscp_ecn_decapsulate);\n}\n\nstatic int ip6ip6_rcv(struct sk_buff *skb)\n{\n\treturn ip6_tnl_rcv(skb, ETH_P_IPV6, IPPROTO_IPV6,\n\t\t\t   ip6ip6_dscp_ecn_decapsulate);\n}\n\nstruct ipv6_tel_txoption {\n\tstruct ipv6_txoptions ops;\n\t__u8 dst_opt[8];\n};\n\nstatic void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)\n{\n\tmemset(opt, 0, sizeof(struct ipv6_tel_txoption));\n\n\topt->dst_opt[2] = IPV6_TLV_TNL_ENCAP_LIMIT;\n\topt->dst_opt[3] = 1;\n\topt->dst_opt[4] = encap_limit;\n\topt->dst_opt[5] = IPV6_TLV_PADN;\n\topt->dst_opt[6] = 1;\n\n\topt->ops.dst0opt = (struct ipv6_opt_hdr *) opt->dst_opt;\n\topt->ops.opt_nflen = 8;\n}\n\n/**\n * ip6_tnl_addr_conflict - compare packet addresses to tunnel's own\n *   @t: the outgoing tunnel device\n *   @hdr: IPv6 header from the incoming packet\n *\n * Description:\n *   Avoid trivial tunneling loop by checking that tunnel exit-point\n *   doesn't match source of incoming packet.\n *\n * Return:\n *   1 if conflict,\n *   0 else\n **/\n\nstatic inline int\nip6_tnl_addr_conflict(struct ip6_tnl *t, struct ipv6hdr *hdr)\n{\n\treturn ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);\n}\n\nstatic inline int ip6_tnl_xmit_ctl(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ret = 0;\n\tstruct net *net = dev_net(t->dev);\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tstruct net_device *ldev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (p->link)\n\t\t\tldev = dev_get_by_index_rcu(net, p->link);\n\n\t\tif (unlikely(!ipv6_chk_addr(net, &p->laddr, ldev, 0)))\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s xmit: Local address not yet configured!\\n\",\n\t\t\t       p->name);\n\t\telse if (!ipv6_addr_is_multicast(&p->raddr) &&\n\t\t\t unlikely(ipv6_chk_addr(net, &p->raddr, NULL, 0)))\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s xmit: Routing loop! \"\n\t\t\t       \"Remote address found on this node!\\n\",\n\t\t\t       p->name);\n\t\telse\n\t\t\tret = 1;\n\t\trcu_read_unlock();\n\t}\n\treturn ret;\n}\n/**\n * ip6_tnl_xmit2 - encapsulate packet and send\n *   @skb: the outgoing socket buffer\n *   @dev: the outgoing tunnel device\n *   @dsfield: dscp code for outer header\n *   @fl: flow of tunneled packet\n *   @encap_limit: encapsulation limit\n *   @pmtu: Path MTU is stored if packet is too big\n *\n * Description:\n *   Build new header and do some sanity checks on the packet before sending\n *   it.\n *\n * Return:\n *   0 on success\n *   -1 fail\n *   %-EMSGSIZE message too big. return mtu in this case.\n **/\n\nstatic int ip6_tnl_xmit2(struct sk_buff *skb,\n\t\t\t struct net_device *dev,\n\t\t\t __u8 dsfield,\n\t\t\t struct flowi *fl,\n\t\t\t int encap_limit,\n\t\t\t __u32 *pmtu)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net_device_stats *stats = &t->dev->stats;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tstruct ipv6_tel_txoption opt;\n\tstruct dst_entry *dst;\n\tstruct net_device *tdev;\n\tint mtu;\n\tunsigned int max_headroom = sizeof(struct ipv6hdr);\n\tu8 proto;\n\tint err = -1;\n\tint pkt_len;\n\n\tif ((dst = ip6_tnl_dst_check(t)) != NULL)\n\t\tdst_hold(dst);\n\telse {\n\t\tdst = ip6_route_output(net, NULL, fl);\n\n\t\tif (dst->error || xfrm_lookup(net, &dst, fl, NULL, 0) < 0)\n\t\t\tgoto tx_err_link_failure;\n\t}\n\n\ttdev = dst->dev;\n\n\tif (tdev == dev) {\n\t\tstats->collisions++;\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Local routing loop detected!\\n\",\n\t\t\t       t->parms.name);\n\t\tgoto tx_err_dst_release;\n\t}\n\tmtu = dst_mtu(dst) - sizeof (*ipv6h);\n\tif (encap_limit >= 0) {\n\t\tmax_headroom += 8;\n\t\tmtu -= 8;\n\t}\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\tif (skb_dst(skb))\n\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\tif (skb->len > mtu) {\n\t\t*pmtu = mtu;\n\t\terr = -EMSGSIZE;\n\t\tgoto tx_err_dst_release;\n\t}\n\n\t/*\n\t * Okay, now see if we can stuff it in the buffer as-is.\n\t */\n\tmax_headroom += LL_RESERVED_SPACE(tdev);\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb;\n\n\t\tif (!(new_skb = skb_realloc_headroom(skb, max_headroom)))\n\t\t\tgoto tx_err_dst_release;\n\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t}\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst_clone(dst));\n\n\tskb->transport_header = skb->network_header;\n\n\tproto = fl->proto;\n\tif (encap_limit >= 0) {\n\t\tinit_tel_txopt(&opt, encap_limit);\n\t\tipv6_push_nfrag_opts(skb, &opt.ops, &proto, NULL);\n\t}\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tipv6h = ipv6_hdr(skb);\n\t*(__be32*)ipv6h = fl->fl6_flowlabel | htonl(0x60000000);\n\tdsfield = INET_ECN_encapsulate(0, dsfield);\n\tipv6_change_dsfield(ipv6h, ~INET_ECN_MASK, dsfield);\n\tipv6h->hop_limit = t->parms.hop_limit;\n\tipv6h->nexthdr = proto;\n\tipv6_addr_copy(&ipv6h->saddr, &fl->fl6_src);\n\tipv6_addr_copy(&ipv6h->daddr, &fl->fl6_dst);\n\tnf_reset(skb);\n\tpkt_len = skb->len;\n\terr = ip6_local_out(skb);\n\n\tif (net_xmit_eval(err) == 0) {\n\t\tstats->tx_bytes += pkt_len;\n\t\tstats->tx_packets++;\n\t} else {\n\t\tstats->tx_errors++;\n\t\tstats->tx_aborted_errors++;\n\t}\n\tip6_tnl_dst_store(t, dst);\n\treturn 0;\ntx_err_link_failure:\n\tstats->tx_carrier_errors++;\n\tdst_link_failure(skb);\ntx_err_dst_release:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic inline int\nip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct iphdr  *iph = ip_hdr(skb);\n\tint encap_limit = -1;\n\tstruct flowi fl;\n\t__u8 dsfield;\n\t__u32 mtu;\n\tint err;\n\n\tif ((t->parms.proto != IPPROTO_IPIP && t->parms.proto != 0) ||\n\t    !ip6_tnl_xmit_ctl(t))\n\t\treturn -1;\n\n\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tencap_limit = t->parms.encap_limit;\n\n\tmemcpy(&fl, &t->fl, sizeof (fl));\n\tfl.proto = IPPROTO_IPIP;\n\n\tdsfield = ipv4_get_dsfield(iph);\n\n\tif ((t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl.fl6_flowlabel |= htonl((__u32)iph->tos << IPV6_TCLASS_SHIFT)\n\t\t\t\t\t  & IPV6_TCLASS_MASK;\n\n\terr = ip6_tnl_xmit2(skb, dev, dsfield, &fl, encap_limit, &mtu);\n\tif (err != 0) {\n\t\t/* XXX: send ICMP error even if DF is not set. */\n\t\tif (err == -EMSGSIZE)\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t  htonl(mtu));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int\nip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tint encap_limit = -1;\n\t__u16 offset;\n\tstruct flowi fl;\n\t__u8 dsfield;\n\t__u32 mtu;\n\tint err;\n\n\tif ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||\n\t    !ip6_tnl_xmit_ctl(t) || ip6_tnl_addr_conflict(t, ipv6h))\n\t\treturn -1;\n\n\toffset = parse_tlv_tnl_enc_lim(skb, skb_network_header(skb));\n\tif (offset > 0) {\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\ttel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];\n\t\tif (tel->encap_limit == 0) {\n\t\t\ticmpv6_send(skb, ICMPV6_PARAMPROB,\n\t\t\t\t    ICMPV6_HDR_FIELD, offset + 2, skb->dev);\n\t\t\treturn -1;\n\t\t}\n\t\tencap_limit = tel->encap_limit - 1;\n\t} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tencap_limit = t->parms.encap_limit;\n\n\tmemcpy(&fl, &t->fl, sizeof (fl));\n\tfl.proto = IPPROTO_IPV6;\n\n\tdsfield = ipv6_get_dsfield(ipv6h);\n\tif ((t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl.fl6_flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);\n\tif ((t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl.fl6_flowlabel |= (*(__be32 *) ipv6h & IPV6_FLOWLABEL_MASK);\n\n\terr = ip6_tnl_xmit2(skb, dev, dsfield, &fl, encap_limit, &mtu);\n\tif (err != 0) {\n\t\tif (err == -EMSGSIZE)\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net_device_stats *stats = &t->dev->stats;\n\tint ret;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tret = ip4ip6_tnl_xmit(skb, dev);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tret = ip6ip6_tnl_xmit(skb, dev);\n\t\tbreak;\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\tif (ret < 0)\n\t\tgoto tx_err;\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tstats->tx_errors++;\n\tstats->tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ip6_tnl_set_cap(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ltype = ipv6_addr_type(&p->laddr);\n\tint rtype = ipv6_addr_type(&p->raddr);\n\n\tp->flags &= ~(IP6_TNL_F_CAP_XMIT|IP6_TNL_F_CAP_RCV);\n\n\tif (ltype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t    rtype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t    !((ltype|rtype) & IPV6_ADDR_LOOPBACK) &&\n\t    (!((ltype|rtype) & IPV6_ADDR_LINKLOCAL) || p->link)) {\n\t\tif (ltype&IPV6_ADDR_UNICAST)\n\t\t\tp->flags |= IP6_TNL_F_CAP_XMIT;\n\t\tif (rtype&IPV6_ADDR_UNICAST)\n\t\t\tp->flags |= IP6_TNL_F_CAP_RCV;\n\t}\n}\n\nstatic void ip6_tnl_link_config(struct ip6_tnl *t)\n{\n\tstruct net_device *dev = t->dev;\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tstruct flowi *fl = &t->fl;\n\n\tmemcpy(dev->dev_addr, &p->laddr, sizeof(struct in6_addr));\n\tmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\n\n\t/* Set up flowi template */\n\tipv6_addr_copy(&fl->fl6_src, &p->laddr);\n\tipv6_addr_copy(&fl->fl6_dst, &p->raddr);\n\tfl->oif = p->link;\n\tfl->fl6_flowlabel = 0;\n\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl->fl6_flowlabel |= IPV6_TCLASS_MASK & p->flowinfo;\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl->fl6_flowlabel |= IPV6_FLOWLABEL_MASK & p->flowinfo;\n\n\tip6_tnl_set_cap(t);\n\n\tif (p->flags&IP6_TNL_F_CAP_XMIT && p->flags&IP6_TNL_F_CAP_RCV)\n\t\tdev->flags |= IFF_POINTOPOINT;\n\telse\n\t\tdev->flags &= ~IFF_POINTOPOINT;\n\n\tdev->iflink = p->link;\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tint strict = (ipv6_addr_type(&p->raddr) &\n\t\t\t      (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL));\n\n\t\tstruct rt6_info *rt = rt6_lookup(dev_net(dev),\n\t\t\t\t\t\t &p->raddr, &p->laddr,\n\t\t\t\t\t\t p->link, strict);\n\n\t\tif (rt == NULL)\n\t\t\treturn;\n\n\t\tif (rt->rt6i_dev) {\n\t\t\tdev->hard_header_len = rt->rt6i_dev->hard_header_len +\n\t\t\t\tsizeof (struct ipv6hdr);\n\n\t\t\tdev->mtu = rt->rt6i_dev->mtu - sizeof (struct ipv6hdr);\n\n\t\t\tif (dev->mtu < IPV6_MIN_MTU)\n\t\t\t\tdev->mtu = IPV6_MIN_MTU;\n\t\t}\n\t\tdst_release(&rt->u.dst);\n\t}\n}\n\n/**\n * ip6_tnl_change - update the tunnel parameters\n *   @t: tunnel to be changed\n *   @p: tunnel configuration parameters\n *\n * Description:\n *   ip6_tnl_change() updates the tunnel parameters\n **/\n\nstatic int\nip6_tnl_change(struct ip6_tnl *t, struct ip6_tnl_parm *p)\n{\n\tipv6_addr_copy(&t->parms.laddr, &p->laddr);\n\tipv6_addr_copy(&t->parms.raddr, &p->raddr);\n\tt->parms.flags = p->flags;\n\tt->parms.hop_limit = p->hop_limit;\n\tt->parms.encap_limit = p->encap_limit;\n\tt->parms.flowinfo = p->flowinfo;\n\tt->parms.link = p->link;\n\tt->parms.proto = p->proto;\n\tip6_tnl_dst_reset(t);\n\tip6_tnl_link_config(t);\n\treturn 0;\n}\n\n/**\n * ip6_tnl_ioctl - configure ipv6 tunnels from userspace\n *   @dev: virtual device associated with tunnel\n *   @ifr: parameters passed from userspace\n *   @cmd: command to be performed\n *\n * Description:\n *   ip6_tnl_ioctl() is used for managing IPv6 tunnels\n *   from userspace.\n *\n *   The possible commands are the following:\n *     %SIOCGETTUNNEL: get tunnel parameters for device\n *     %SIOCADDTUNNEL: add tunnel matching given tunnel parameters\n *     %SIOCCHGTUNNEL: change tunnel parameters to those given\n *     %SIOCDELTUNNEL: delete tunnel\n *\n *   The fallback device \"ip6tnl0\", created during module\n *   initialization, can be used for creating other tunnel devices.\n *\n * Return:\n *   0 on success,\n *   %-EFAULT if unable to copy data to or from userspace,\n *   %-EPERM if current process hasn't %CAP_NET_ADMIN set\n *   %-EINVAL if passed tunnel parameters are invalid,\n *   %-EEXIST if changing a tunnel's parameters would cause a conflict\n *   %-ENODEV if attempting to change or delete a nonexisting device\n **/\n\nstatic int\nip6_tnl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip6_tnl_parm p;\n\tstruct ip6_tnl *t = NULL;\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ip6_tnl_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\t\tmemcpy(&p, &t->parms, sizeof (p));\n\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof (p))) {\n\t\t\terr = -EFAULT;\n\t\t}\n\t\tbreak;\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p)))\n\t\t\tbreak;\n\t\terr = -EINVAL;\n\t\tif (p.proto != IPPROTO_IPV6 && p.proto != IPPROTO_IPIP &&\n\t\t    p.proto != 0)\n\t\t\tbreak;\n\t\tt = ip6_tnl_locate(net, &p, cmd == SIOCADDTUNNEL);\n\t\tif (dev != ip6n->fb_tnl_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tt = netdev_priv(dev);\n\n\t\t\tip6_tnl_unlink(ip6n, t);\n\t\t\terr = ip6_tnl_change(t, &p);\n\t\t\tip6_tnl_link(ip6n, t);\n\t\t\tnetdev_state_change(dev);\n\t\t}\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof (p)))\n\t\t\t\terr = -EFAULT;\n\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p)))\n\t\t\t\tbreak;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ip6_tnl_locate(net, &p, 0)) == NULL)\n\t\t\t\tbreak;\n\t\t\terr = -EPERM;\n\t\t\tif (t->dev == ip6n->fb_tnl_dev)\n\t\t\t\tbreak;\n\t\t\tdev = t->dev;\n\t\t}\n\t\terr = 0;\n\t\tunregister_netdevice(dev);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\n/**\n * ip6_tnl_change_mtu - change mtu manually for tunnel device\n *   @dev: virtual device associated with tunnel\n *   @new_mtu: the new mtu\n *\n * Return:\n *   0 on success,\n *   %-EINVAL if mtu too small\n **/\n\nstatic int\nip6_tnl_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < IPV6_MIN_MTU) {\n\t\treturn -EINVAL;\n\t}\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n\nstatic const struct net_device_ops ip6_tnl_netdev_ops = {\n\t.ndo_uninit = ip6_tnl_dev_uninit,\n\t.ndo_start_xmit = ip6_tnl_xmit,\n\t.ndo_do_ioctl = ip6_tnl_ioctl,\n\t.ndo_change_mtu = ip6_tnl_change_mtu,\n};\n\n/**\n * ip6_tnl_dev_setup - setup virtual tunnel device\n *   @dev: virtual device associated with tunnel\n *\n * Description:\n *   Initialize function pointers and device parameters\n **/\n\nstatic void ip6_tnl_dev_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ip6_tnl_netdev_ops;\n\tdev->destructor = free_netdev;\n\n\tdev->type = ARPHRD_TUNNEL6;\n\tdev->hard_header_len = LL_MAX_HEADER + sizeof (struct ipv6hdr);\n\tdev->mtu = ETH_DATA_LEN - sizeof (struct ipv6hdr);\n\tdev->flags |= IFF_NOARP;\n\tdev->addr_len = sizeof(struct in6_addr);\n\tdev->features |= NETIF_F_NETNS_LOCAL;\n}\n\n\n/**\n * ip6_tnl_dev_init_gen - general initializer for all tunnel devices\n *   @dev: virtual device associated with tunnel\n **/\n\nstatic inline void\nip6_tnl_dev_init_gen(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tt->dev = dev;\n\tstrcpy(t->parms.name, dev->name);\n}\n\n/**\n * ip6_tnl_dev_init - initializer for all non fallback tunnel devices\n *   @dev: virtual device associated with tunnel\n **/\n\nstatic void ip6_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tip6_tnl_dev_init_gen(dev);\n\tip6_tnl_link_config(t);\n}\n\n/**\n * ip6_fb_tnl_dev_init - initializer for fallback tunnel device\n *   @dev: fallback device\n *\n * Return: 0\n **/\n\nstatic void __net_init ip6_fb_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tip6_tnl_dev_init_gen(dev);\n\tt->parms.proto = IPPROTO_IPV6;\n\tdev_hold(dev);\n\tip6n->tnls_wc[0] = t;\n}\n\nstatic struct xfrm6_tunnel ip4ip6_handler = {\n\t.handler\t= ip4ip6_rcv,\n\t.err_handler\t= ip4ip6_err,\n\t.priority\t=\t1,\n};\n\nstatic struct xfrm6_tunnel ip6ip6_handler = {\n\t.handler\t= ip6ip6_rcv,\n\t.err_handler\t= ip6ip6_err,\n\t.priority\t=\t1,\n};\n\nstatic void __net_exit ip6_tnl_destroy_tunnels(struct ip6_tnl_net *ip6n)\n{\n\tint h;\n\tstruct ip6_tnl *t;\n\tLIST_HEAD(list);\n\n\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\tt = ip6n->tnls_r_l[h];\n\t\twhile (t != NULL) {\n\t\t\tunregister_netdevice_queue(t->dev, &list);\n\t\t\tt = t->next;\n\t\t}\n\t}\n\n\tt = ip6n->tnls_wc[0];\n\tunregister_netdevice_queue(t->dev, &list);\n\tunregister_netdevice_many(&list);\n}\n\nstatic int __net_init ip6_tnl_init_net(struct net *net)\n{\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tint err;\n\n\tip6n->tnls[0] = ip6n->tnls_wc;\n\tip6n->tnls[1] = ip6n->tnls_r_l;\n\n\terr = -ENOMEM;\n\tip6n->fb_tnl_dev = alloc_netdev(sizeof(struct ip6_tnl), \"ip6tnl0\",\n\t\t\t\t      ip6_tnl_dev_setup);\n\n\tif (!ip6n->fb_tnl_dev)\n\t\tgoto err_alloc_dev;\n\tdev_net_set(ip6n->fb_tnl_dev, net);\n\n\tip6_fb_tnl_dev_init(ip6n->fb_tnl_dev);\n\n\terr = register_netdev(ip6n->fb_tnl_dev);\n\tif (err < 0)\n\t\tgoto err_register;\n\treturn 0;\n\nerr_register:\n\tfree_netdev(ip6n->fb_tnl_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit ip6_tnl_exit_net(struct net *net)\n{\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\trtnl_lock();\n\tip6_tnl_destroy_tunnels(ip6n);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ip6_tnl_net_ops = {\n\t.init = ip6_tnl_init_net,\n\t.exit = ip6_tnl_exit_net,\n\t.id   = &ip6_tnl_net_id,\n\t.size = sizeof(struct ip6_tnl_net),\n};\n\n/**\n * ip6_tunnel_init - register protocol and reserve needed resources\n *\n * Return: 0 on success\n **/\n\nstatic int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto out_pernet;\n\n\terr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\tgoto out_ip4ip6;\n\t}\n\n\terr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\tgoto out_ip6ip6;\n\t}\n\n\treturn 0;\n\nout_ip6ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout_ip4ip6:\n\tunregister_pernet_device(&ip6_tnl_net_ops);\nout_pernet:\n\treturn err;\n}\n\n/**\n * ip6_tunnel_cleanup - free resources and unregister protocol\n **/\n\nstatic void __exit ip6_tunnel_cleanup(void)\n{\n\tif (xfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET))\n\t\tprintk(KERN_INFO \"ip6_tunnel close: can't deregister ip4ip6\\n\");\n\n\tif (xfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6))\n\t\tprintk(KERN_INFO \"ip6_tunnel close: can't deregister ip6ip6\\n\");\n\n\tunregister_pernet_device(&ip6_tnl_net_ops);\n}\n\nmodule_init(ip6_tunnel_init);\nmodule_exit(ip6_tunnel_cleanup);\n", "/*\n *\tIPv6 over IPv4 tunnel device - Simple Internet Transition (SIT)\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\tAlexey Kuznetsov\t<kuznet@ms2.inr.ac.ru>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tChanges:\n * Roger Venning <r.venning@telstra.com>:\t6to4 support\n * Nate Thompson <nate@thebog.net>:\t\t6to4 support\n * Fred Templin <fred.l.templin@boeing.com>:\tisatap support\n */\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmp.h>\n#include <asm/uaccess.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <net/ipip.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/dsfield.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n/*\n   This version of net/ipv6/sit.c is cloned of net/ipv4/ip_gre.c\n\n   For comments look at net/ipv4/ip_gre.c --ANK\n */\n\n#define HASH_SIZE  16\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\nstatic void ipip6_tunnel_init(struct net_device *dev);\nstatic void ipip6_tunnel_setup(struct net_device *dev);\n\nstatic int sit_net_id __read_mostly;\nstruct sit_net {\n\tstruct ip_tunnel *tunnels_r_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_r[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_l[HASH_SIZE];\n\tstruct ip_tunnel *tunnels_wc[1];\n\tstruct ip_tunnel **tunnels[4];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\n/*\n * Locking : hash tables are protected by RCU and a spinlock\n */\nstatic DEFINE_SPINLOCK(ipip6_lock);\n\n#define for_each_ip_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\n/*\n * Must be invoked with rcu_read_lock\n */\nstatic struct ip_tunnel * ipip6_tunnel_lookup(struct net *net,\n\t\tstruct net_device *dev, __be32 remote, __be32 local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tfor_each_ip_tunnel_rcu(sitn->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || dev->iflink == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(sitn->tunnels_r[h0]) {\n\t\tif (remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || dev->iflink == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(sitn->tunnels_l[h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    (!dev || !t->parms.link || dev->iflink == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tt = rcu_dereference(sitn->tunnels_wc[0]);\n\tif ((t != NULL) && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}\n\nstatic struct ip_tunnel **__ipip6_bucket(struct sit_net *sitn,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (remote) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\tif (local) {\n\t\tprio |= 1;\n\t\th ^= HASH(local);\n\t}\n\treturn &sitn->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel **ipip6_bucket(struct sit_net *sitn,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipip6_bucket(sitn, &t->parms);\n}\n\nstatic void ipip6_tunnel_unlink(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp;\n\n\tfor (tp = ipip6_bucket(sitn, t); *tp; tp = &(*tp)->next) {\n\t\tif (t == *tp) {\n\t\t\tspin_lock_bh(&ipip6_lock);\n\t\t\t*tp = t->next;\n\t\t\tspin_unlock_bh(&ipip6_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ipip6_tunnel_link(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel **tp = ipip6_bucket(sitn, t);\n\n\tspin_lock_bh(&ipip6_lock);\n\tt->next = *tp;\n\trcu_assign_pointer(*tp, t);\n\tspin_unlock_bh(&ipip6_lock);\n}\n\nstatic void ipip6_tunnel_clone_6rd(struct net_device *dev, struct sit_net *sitn)\n{\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (t->dev == sitn->fb_tunnel_dev) {\n\t\tipv6_addr_set(&t->ip6rd.prefix, htonl(0x20020000), 0, 0, 0);\n\t\tt->ip6rd.relay_prefix = 0;\n\t\tt->ip6rd.prefixlen = 16;\n\t\tt->ip6rd.relay_prefixlen = 0;\n\t} else {\n\t\tstruct ip_tunnel *t0 = netdev_priv(sitn->fb_tunnel_dev);\n\t\tmemcpy(&t->ip6rd, &t0->ip6rd, sizeof(t->ip6rd));\n\t}\n#endif\n}\n\nstatic struct ip_tunnel * ipip6_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tstruct ip_tunnel *t, **tp, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tfor (tp = __ipip6_bucket(sitn, parms); (t = *tp) != NULL; tp = &t->next) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    parms->link == t->parms.link) {\n\t\t\tif (create)\n\t\t\t\treturn NULL;\n\t\t\telse\n\t\t\t\treturn t;\n\t\t}\n\t}\n\tif (!create)\n\t\tgoto failed;\n\n\tif (parms->name[0])\n\t\tstrlcpy(name, parms->name, IFNAMSIZ);\n\telse\n\t\tsprintf(name, \"sit%%d\");\n\n\tdev = alloc_netdev(sizeof(*t), name, ipip6_tunnel_setup);\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (strchr(name, '%')) {\n\t\tif (dev_alloc_name(dev, name) < 0)\n\t\t\tgoto failed_free;\n\t}\n\n\tnt = netdev_priv(dev);\n\n\tnt->parms = *parms;\n\tipip6_tunnel_init(dev);\n\tipip6_tunnel_clone_6rd(dev, sitn);\n\n\tif (parms->i_flags & SIT_ISATAP)\n\t\tdev->priv_flags |= IFF_ISATAP;\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tdev_hold(dev);\n\n\tipip6_tunnel_link(sitn, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\n\nstatic DEFINE_SPINLOCK(ipip6_prl_lock);\n\n#define for_each_prl_rcu(start)\t\t\t\\\n\tfor (prl = rcu_dereference(start);\t\\\n\t     prl;\t\t\t\t\\\n\t     prl = rcu_dereference(prl->next))\n\nstatic struct ip_tunnel_prl_entry *\n__ipip6_tunnel_locate_prl(struct ip_tunnel *t, __be32 addr)\n{\n\tstruct ip_tunnel_prl_entry *prl;\n\n\tfor_each_prl_rcu(t->prl)\n\t\tif (prl->addr == addr)\n\t\t\tbreak;\n\treturn prl;\n\n}\n\nstatic int ipip6_tunnel_get_prl(struct ip_tunnel *t,\n\t\t\t\tstruct ip_tunnel_prl __user *a)\n{\n\tstruct ip_tunnel_prl kprl, *kp;\n\tstruct ip_tunnel_prl_entry *prl;\n\tunsigned int cmax, c = 0, ca, len;\n\tint ret = 0;\n\n\tif (copy_from_user(&kprl, a, sizeof(kprl)))\n\t\treturn -EFAULT;\n\tcmax = kprl.datalen / sizeof(kprl);\n\tif (cmax > 1 && kprl.addr != htonl(INADDR_ANY))\n\t\tcmax = 1;\n\n\t/* For simple GET or for root users,\n\t * we try harder to allocate.\n\t */\n\tkp = (cmax <= 1 || capable(CAP_NET_ADMIN)) ?\n\t\tkcalloc(cmax, sizeof(*kp), GFP_KERNEL) :\n\t\tNULL;\n\n\trcu_read_lock();\n\n\tca = t->prl_count < cmax ? t->prl_count : cmax;\n\n\tif (!kp) {\n\t\t/* We don't try hard to allocate much memory for\n\t\t * non-root users.\n\t\t * For root users, retry allocating enough memory for\n\t\t * the answer.\n\t\t */\n\t\tkp = kcalloc(ca, sizeof(*kp), GFP_ATOMIC);\n\t\tif (!kp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tc = 0;\n\tfor_each_prl_rcu(t->prl) {\n\t\tif (c >= cmax)\n\t\t\tbreak;\n\t\tif (kprl.addr != htonl(INADDR_ANY) && prl->addr != kprl.addr)\n\t\t\tcontinue;\n\t\tkp[c].addr = prl->addr;\n\t\tkp[c].flags = prl->flags;\n\t\tc++;\n\t\tif (kprl.addr != htonl(INADDR_ANY))\n\t\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\n\tlen = sizeof(*kp) * c;\n\tret = 0;\n\tif ((len && copy_to_user(a + 1, kp, len)) || put_user(len, &a->datalen))\n\t\tret = -EFAULT;\n\n\tkfree(kp);\n\n\treturn ret;\n}\n\nstatic int\nipip6_tunnel_add_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a, int chg)\n{\n\tstruct ip_tunnel_prl_entry *p;\n\tint err = 0;\n\n\tif (a->addr == htonl(INADDR_ANY))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ipip6_prl_lock);\n\n\tfor (p = t->prl; p; p = p->next) {\n\t\tif (p->addr == a->addr) {\n\t\t\tif (chg) {\n\t\t\t\tp->flags = a->flags;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (chg) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tp = kzalloc(sizeof(struct ip_tunnel_prl_entry), GFP_KERNEL);\n\tif (!p) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tINIT_RCU_HEAD(&p->rcu_head);\n\tp->next = t->prl;\n\tp->addr = a->addr;\n\tp->flags = a->flags;\n\tt->prl_count++;\n\trcu_assign_pointer(t->prl, p);\nout:\n\tspin_unlock(&ipip6_prl_lock);\n\treturn err;\n}\n\nstatic void prl_entry_destroy_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_tunnel_prl_entry, rcu_head));\n}\n\nstatic void prl_list_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_tunnel_prl_entry *p, *n;\n\n\tp = container_of(head, struct ip_tunnel_prl_entry, rcu_head);\n\tdo {\n\t\tn = p->next;\n\t\tkfree(p);\n\t\tp = n;\n\t} while (p);\n}\n\nstatic int\nipip6_tunnel_del_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a)\n{\n\tstruct ip_tunnel_prl_entry *x, **p;\n\tint err = 0;\n\n\tspin_lock(&ipip6_prl_lock);\n\n\tif (a && a->addr != htonl(INADDR_ANY)) {\n\t\tfor (p = &t->prl; *p; p = &(*p)->next) {\n\t\t\tif ((*p)->addr == a->addr) {\n\t\t\t\tx = *p;\n\t\t\t\t*p = x->next;\n\t\t\t\tcall_rcu(&x->rcu_head, prl_entry_destroy_rcu);\n\t\t\t\tt->prl_count--;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = -ENXIO;\n\t} else {\n\t\tif (t->prl) {\n\t\t\tt->prl_count = 0;\n\t\t\tx = t->prl;\n\t\t\tcall_rcu(&x->rcu_head, prl_list_destroy_rcu);\n\t\t\tt->prl = NULL;\n\t\t}\n\t}\nout:\n\tspin_unlock(&ipip6_prl_lock);\n\treturn err;\n}\n\nstatic int\nisatap_chksrc(struct sk_buff *skb, struct iphdr *iph, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel_prl_entry *p;\n\tint ok = 1;\n\n\trcu_read_lock();\n\tp = __ipip6_tunnel_locate_prl(t, iph->saddr);\n\tif (p) {\n\t\tif (p->flags & PRL_DEFAULT)\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_DEFAULT;\n\t\telse\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_NODEFAULT;\n\t} else {\n\t\tstruct in6_addr *addr6 = &ipv6_hdr(skb)->saddr;\n\t\tif (ipv6_addr_is_isatap(addr6) &&\n\t\t    (addr6->s6_addr32[3] == iph->saddr) &&\n\t\t    ipv6_chk_prefix(addr6, t->dev))\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_HOST;\n\t\telse\n\t\t\tok = 0;\n\t}\n\trcu_read_unlock();\n\treturn ok;\n}\n\nstatic void ipip6_tunnel_uninit(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tif (dev == sitn->fb_tunnel_dev) {\n\t\tspin_lock_bh(&ipip6_lock);\n\t\tsitn->tunnels_wc[0] = NULL;\n\t\tspin_unlock_bh(&ipip6_lock);\n\t\tdev_put(dev);\n\t} else {\n\t\tipip6_tunnel_unlink(sitn, netdev_priv(dev));\n\t\tipip6_tunnel_del_prl(netdev_priv(dev), NULL);\n\t\tdev_put(dev);\n\t}\n}\n\n\nstatic int ipip6_err(struct sk_buff *skb, u32 info)\n{\n\n/* All the routers (except for Linux) return only\n   8 bytes of packet payload. It means, that precise relaying of\n   ICMP in the real Internet is absolutely infeasible.\n */\n\tstruct iphdr *iph = (struct iphdr*)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t/* Impossible event. */\n\t\t\treturn 0;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t/* Soft state for pmtu is maintained by IP core. */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\terr = -ENOENT;\n\n\trcu_read_lock();\n\tt = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\tskb->dev,\n\t\t\t\tiph->daddr,\n\t\t\t\tiph->saddr);\n\tif (t == NULL || t->parms.iph.daddr == 0)\n\t\tgoto out;\n\n\terr = 0;\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic inline void ipip6_ecn_decapsulate(struct iphdr *iph, struct sk_buff *skb)\n{\n\tif (INET_ECN_is_ce(iph->tos))\n\t\tIP6_ECN_set_ce(ipv6_hdr(skb));\n}\n\nstatic int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\n\trcu_read_lock();\n\ttunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\t     iph->saddr, iph->daddr);\n\tif (tunnel != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->dev->stats.rx_errors++;\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->dev->stats.rx_packets++;\n\t\ttunnel->dev->stats.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\trcu_read_unlock();\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/*\n * Returns the embedded IPv4 address if the IPv6 address\n * comes from 6rd / 6to4 (RFC 3056) addr space.\n */\nstatic inline\n__be32 try_6rd(struct in6_addr *v6dst, struct ip_tunnel *tunnel)\n{\n\t__be32 dst = 0;\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tif (ipv6_prefix_equal(v6dst, &tunnel->ip6rd.prefix,\n\t\t\t      tunnel->ip6rd.prefixlen)) {\n\t\tunsigned pbw0, pbi0;\n\t\tint pbi1;\n\t\tu32 d;\n\n\t\tpbw0 = tunnel->ip6rd.prefixlen >> 5;\n\t\tpbi0 = tunnel->ip6rd.prefixlen & 0x1f;\n\n\t\td = (ntohl(v6dst->s6_addr32[pbw0]) << pbi0) >>\n\t\t    tunnel->ip6rd.relay_prefixlen;\n\n\t\tpbi1 = pbi0 - tunnel->ip6rd.relay_prefixlen;\n\t\tif (pbi1 > 0)\n\t\t\td |= ntohl(v6dst->s6_addr32[pbw0 + 1]) >>\n\t\t\t     (32 - pbi1);\n\n\t\tdst = tunnel->ip6rd.relay_prefix | htonl(d);\n\t}\n#else\n\tif (v6dst->s6_addr16[0] == htons(0x2002)) {\n\t\t/* 6to4 v6 addr has 16 bits prefix, 32 v4addr, 16 SLA, ... */\n\t\tmemcpy(&dst, &v6dst->s6_addr16[1], 4);\n\t}\n#endif\n\treturn dst;\n}\n\n/*\n *\tThis function assumes it is being called from dev_queue_xmit()\n *\tand that skb is filled properly by that function.\n */\n\nstatic netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\tstruct iphdr  *tiph = &tunnel->parms.iph;\n\tstruct ipv6hdr *iph6 = ipv6_hdr(skb);\n\tu8     tos = tunnel->parms.iph.tos;\n\t__be16 df = tiph->frag_off;\n\tstruct rtable *rt;     \t\t\t/* Route to the other host */\n\tstruct net_device *tdev;\t\t\t/* Device to other host */\n\tstruct iphdr  *iph;\t\t\t/* Our new IP header */\n\tunsigned int max_headroom;\t\t/* The extra header space needed */\n\t__be32 dst = tiph->daddr;\n\tint    mtu;\n\tstruct in6_addr *addr6;\n\tint addr_type;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\tgoto tx_error;\n\n\t/* ISATAP (RFC4214) - must come before 6to4 */\n\tif (dev->priv_flags & IFF_ISATAP) {\n\t\tstruct neighbour *neigh = NULL;\n\n\t\tif (skb_dst(skb))\n\t\t\tneigh = skb_dst(skb)->neighbour;\n\n\t\tif (neigh == NULL) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_DEBUG \"sit: nexthop == NULL\\n\");\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\taddr6 = (struct in6_addr*)&neigh->primary_key;\n\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\tif ((addr_type & IPV6_ADDR_UNICAST) &&\n\t\t     ipv6_addr_is_isatap(addr6))\n\t\t\tdst = addr6->s6_addr32[3];\n\t\telse\n\t\t\tgoto tx_error;\n\t}\n\n\tif (!dst)\n\t\tdst = try_6rd(&iph6->daddr, tunnel);\n\n\tif (!dst) {\n\t\tstruct neighbour *neigh = NULL;\n\n\t\tif (skb_dst(skb))\n\t\t\tneigh = skb_dst(skb)->neighbour;\n\n\t\tif (neigh == NULL) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_DEBUG \"sit: nexthop == NULL\\n\");\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\taddr6 = (struct in6_addr*)&neigh->primary_key;\n\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t}\n\n\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\tgoto tx_error_icmp;\n\n\t\tdst = addr6->s6_addr32[3];\n\t}\n\n\t{\n\t\tstruct flowi fl = { .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = dst,\n\t\t\t\t\t\t.saddr = tiph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(tos) } },\n\t\t\t\t    .oif = tunnel->parms.link,\n\t\t\t\t    .proto = IPPROTO_IPV6 };\n\t\tif (ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\tstats->tx_carrier_errors++;\n\t\t\tgoto tx_error_icmp;\n\t\t}\n\t}\n\tif (rt->rt_type != RTN_UNICAST) {\n\t\tip_rt_put(rt);\n\t\tstats->tx_carrier_errors++;\n\t\tgoto tx_error_icmp;\n\t}\n\ttdev = rt->u.dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tstats->collisions++;\n\t\tgoto tx_error;\n\t}\n\n\tif (df) {\n\t\tmtu = dst_mtu(&rt->u.dst) - sizeof(struct iphdr);\n\n\t\tif (mtu < 68) {\n\t\t\tstats->collisions++;\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tdf = 0;\n\t\t}\n\n\t\tif (tunnel->parms.iph.daddr && skb_dst(skb))\n\t\t\tskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\n\n\t\tif (skb->len > mtu) {\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, dev);\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\t/*\n\t * Okay, now see if we can stuff it in the buffer as-is.\n\t */\n\tmax_headroom = LL_RESERVED_SPACE(tdev)+sizeof(struct iphdr);\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\ttxq->tx_dropped++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\tiph6 = ipv6_hdr(skb);\n\t}\n\n\tskb->transport_header = skb->network_header;\n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags = 0;\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->u.dst);\n\n\t/*\n\t *\tPush down and install the IPIP header.\n\t */\n\n\tiph \t\t\t=\tip_hdr(skb);\n\tiph->version\t\t=\t4;\n\tiph->ihl\t\t=\tsizeof(struct iphdr)>>2;\n\tiph->frag_off\t\t=\tdf;\n\tiph->protocol\t\t=\tIPPROTO_IPV6;\n\tiph->tos\t\t=\tINET_ECN_encapsulate(tos, ipv6_get_dsfield(iph6));\n\tiph->daddr\t\t=\trt->rt_dst;\n\tiph->saddr\t\t=\trt->rt_src;\n\n\tif ((iph->ttl = tiph->ttl) == 0)\n\t\tiph->ttl\t=\tiph6->hop_limit;\n\n\tnf_reset(skb);\n\n\tIPTUNNEL_XMIT();\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\ntx_error:\n\tstats->tx_errors++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipip6_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel;\n\tstruct iphdr *iph;\n\n\ttunnel = netdev_priv(dev);\n\tiph = &tunnel->parms.iph;\n\n\tif (iph->daddr) {\n\t\tstruct flowi fl = { .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = iph->daddr,\n\t\t\t\t\t\t.saddr = iph->saddr,\n\t\t\t\t\t\t.tos = RT_TOS(iph->tos) } },\n\t\t\t\t    .oif = tunnel->parms.link,\n\t\t\t\t    .proto = IPPROTO_IPV6 };\n\t\tstruct rtable *rt;\n\t\tif (!ip_route_output_key(dev_net(dev), &rt, &fl)) {\n\t\t\ttdev = rt->u.dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\n\n\tif (tdev) {\n\t\tdev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);\n\t\tdev->mtu = tdev->mtu - sizeof(struct iphdr);\n\t\tif (dev->mtu < IPV6_MIN_MTU)\n\t\t\tdev->mtu = IPV6_MIN_MTU;\n\t}\n\tdev->iflink = tunnel->parms.link;\n}\n\nstatic int\nipip6_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel_prl prl;\n\tstruct ip_tunnel *t;\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel_6rd ip6rd;\n#endif\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n#ifdef CONFIG_IPV6_SIT_6RD\n\tcase SIOCGET6RD:\n#endif\n\t\tt = NULL;\n\t\tif (dev == sitn->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = ipip6_tunnel_locate(net, &p, 0);\n\t\t}\n\t\tif (t == NULL)\n\t\t\tt = netdev_priv(dev);\n\n\t\terr = -EFAULT;\n\t\tif (cmd == SIOCGETTUNNEL) {\n\t\t\tmemcpy(&p, &t->parms, sizeof(p));\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &p,\n\t\t\t\t\t sizeof(p)))\n\t\t\t\tgoto done;\n#ifdef CONFIG_IPV6_SIT_6RD\n\t\t} else {\n\t\t\tipv6_addr_copy(&ip6rd.prefix, &t->ip6rd.prefix);\n\t\t\tip6rd.relay_prefix = t->ip6rd.relay_prefix;\n\t\t\tip6rd.prefixlen = t->ip6rd.prefixlen;\n\t\t\tip6rd.relay_prefixlen = t->ip6rd.relay_prefixlen;\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &ip6rd,\n\t\t\t\t\t sizeof(ip6rd)))\n\t\t\t\tgoto done;\n#endif\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPV6 ||\n\t\t    p.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\n\t\t\tgoto done;\n\t\tif (p.iph.ttl)\n\t\t\tp.iph.frag_off |= htons(IP_DF);\n\n\t\tt = ipip6_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != sitn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t != NULL) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||\n\t\t\t\t    (!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt = netdev_priv(dev);\n\t\t\t\tipip6_tunnel_unlink(sitn, t);\n\t\t\t\tt->parms.iph.saddr = p.iph.saddr;\n\t\t\t\tt->parms.iph.daddr = p.iph.daddr;\n\t\t\t\tmemcpy(dev->dev_addr, &p.iph.saddr, 4);\n\t\t\t\tmemcpy(dev->broadcast, &p.iph.daddr, 4);\n\t\t\t\tipip6_tunnel_link(sitn, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\t\tt->parms.iph.ttl = p.iph.ttl;\n\t\t\t\tt->parms.iph.tos = p.iph.tos;\n\t\t\t\tif (t->parms.link != p.link) {\n\t\t\t\t\tt->parms.link = p.link;\n\t\t\t\t\tipip6_tunnel_bind_dev(dev);\n\t\t\t\t\tnetdev_state_change(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == sitn->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tif ((t = ipip6_tunnel_locate(net, &p, 0)) == NULL)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t == netdev_priv(sitn->fb_tunnel_dev))\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCGETPRL:\n\t\terr = -EINVAL;\n\t\tif (dev == sitn->fb_tunnel_dev)\n\t\t\tgoto done;\n\t\terr = -ENOENT;\n\t\tif (!(t = netdev_priv(dev)))\n\t\t\tgoto done;\n\t\terr = ipip6_tunnel_get_prl(t, ifr->ifr_ifru.ifru_data);\n\t\tbreak;\n\n\tcase SIOCADDPRL:\n\tcase SIOCDELPRL:\n\tcase SIOCCHGPRL:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\t\terr = -EINVAL;\n\t\tif (dev == sitn->fb_tunnel_dev)\n\t\t\tgoto done;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&prl, ifr->ifr_ifru.ifru_data, sizeof(prl)))\n\t\t\tgoto done;\n\t\terr = -ENOENT;\n\t\tif (!(t = netdev_priv(dev)))\n\t\t\tgoto done;\n\n\t\tswitch (cmd) {\n\t\tcase SIOCDELPRL:\n\t\t\terr = ipip6_tunnel_del_prl(t, &prl);\n\t\t\tbreak;\n\t\tcase SIOCADDPRL:\n\t\tcase SIOCCHGPRL:\n\t\t\terr = ipip6_tunnel_add_prl(t, &prl, cmd == SIOCCHGPRL);\n\t\t\tbreak;\n\t\t}\n\t\tnetdev_state_change(dev);\n\t\tbreak;\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tcase SIOCADD6RD:\n\tcase SIOCCHG6RD:\n\tcase SIOCDEL6RD:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&ip6rd, ifr->ifr_ifru.ifru_data,\n\t\t\t\t   sizeof(ip6rd)))\n\t\t\tgoto done;\n\n\t\tt = netdev_priv(dev);\n\n\t\tif (cmd != SIOCDEL6RD) {\n\t\t\tstruct in6_addr prefix;\n\t\t\t__be32 relay_prefix;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (ip6rd.relay_prefixlen > 32 ||\n\t\t\t    ip6rd.prefixlen + (32 - ip6rd.relay_prefixlen) > 64)\n\t\t\t\tgoto done;\n\n\t\t\tipv6_addr_prefix(&prefix, &ip6rd.prefix,\n\t\t\t\t\t ip6rd.prefixlen);\n\t\t\tif (!ipv6_addr_equal(&prefix, &ip6rd.prefix))\n\t\t\t\tgoto done;\n\t\t\tif (ip6rd.relay_prefixlen)\n\t\t\t\trelay_prefix = ip6rd.relay_prefix &\n\t\t\t\t\t       htonl(0xffffffffUL <<\n\t\t\t\t\t\t     (32 - ip6rd.relay_prefixlen));\n\t\t\telse\n\t\t\t\trelay_prefix = 0;\n\t\t\tif (relay_prefix != ip6rd.relay_prefix)\n\t\t\t\tgoto done;\n\n\t\t\tipv6_addr_copy(&t->ip6rd.prefix, &prefix);\n\t\t\tt->ip6rd.relay_prefix = relay_prefix;\n\t\t\tt->ip6rd.prefixlen = ip6rd.prefixlen;\n\t\t\tt->ip6rd.relay_prefixlen = ip6rd.relay_prefixlen;\n\t\t} else\n\t\t\tipip6_tunnel_clone_6rd(dev, sitn);\n\n\t\terr = 0;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ipip6_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < IPV6_MIN_MTU || new_mtu > 0xFFF8 - sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops ipip6_netdev_ops = {\n\t.ndo_uninit\t= ipip6_tunnel_uninit,\n\t.ndo_start_xmit\t= ipip6_tunnel_xmit,\n\t.ndo_do_ioctl\t= ipip6_tunnel_ioctl,\n\t.ndo_change_mtu\t= ipip6_tunnel_change_mtu,\n};\n\nstatic void ipip6_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipip6_netdev_ops;\n\tdev->destructor \t= free_netdev;\n\n\tdev->type\t\t= ARPHRD_SIT;\n\tdev->hard_header_len \t= LL_MAX_HEADER + sizeof(struct iphdr);\n\tdev->mtu\t\t= ETH_DATA_LEN - sizeof(struct iphdr);\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->iflink\t\t= 0;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic void ipip6_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\tipip6_tunnel_bind_dev(dev);\n}\n\nstatic void __net_init ipip6_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\ttunnel->dev = dev;\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_IPV6;\n\tiph->ihl\t\t= 5;\n\tiph->ttl\t\t= 64;\n\n\tdev_hold(dev);\n\tsitn->tunnels_wc[0]\t= tunnel;\n}\n\nstatic struct xfrm_tunnel sit_handler = {\n\t.handler\t=\tipip6_rcv,\n\t.err_handler\t=\tipip6_err,\n\t.priority\t=\t1,\n};\n\nstatic void __net_exit sit_destroy_tunnels(struct sit_net *sitn, struct list_head *head)\n{\n\tint prio;\n\n\tfor (prio = 1; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < HASH_SIZE; h++) {\n\t\t\tstruct ip_tunnel *t = sitn->tunnels[prio][h];\n\n\t\t\twhile (t != NULL) {\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t\t\t\tt = t->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tint err;\n\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\n\tif ((err = register_netdev(sitn->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tdev_put(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit sit_exit_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tsit_destroy_tunnels(sitn, &list);\n\tunregister_netdevice_queue(sitn->fb_tunnel_dev, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations sit_net_ops = {\n\t.init = sit_init_net,\n\t.exit = sit_exit_net,\n\t.id   = &sit_net_id,\n\t.size = sizeof(struct sit_net),\n};\n\nstatic void __exit sit_cleanup(void)\n{\n\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\tunregister_pernet_device(&sit_net_ops);\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n}\n\nstatic int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&sit_handler, AF_INET6);\n\tif (err < 0) {\n\t\tunregister_pernet_device(&sit_net_ops);\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t}\n\treturn err;\n}\n\nmodule_init(sit_init);\nmodule_exit(sit_cleanup);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"sit0\");\n", "/*\n * Copyright (C)2003,2004 USAGI/WIDE Project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors\tMitsuru KANDA  <mk@linux-ipv6.org>\n * \t\tYOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\n *\n * Based on net/ipv4/xfrm4_tunnel.c\n *\n */\n#include <linux/module.h>\n#include <linux/xfrm.h>\n#include <linux/rculist.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/mutex.h>\n#include <net/netns/generic.h>\n\n#define XFRM6_TUNNEL_SPI_BYADDR_HSIZE 256\n#define XFRM6_TUNNEL_SPI_BYSPI_HSIZE 256\n\n#define XFRM6_TUNNEL_SPI_MIN\t1\n#define XFRM6_TUNNEL_SPI_MAX\t0xffffffff\n\nstruct xfrm6_tunnel_net {\n\tstruct hlist_head spi_byaddr[XFRM6_TUNNEL_SPI_BYADDR_HSIZE];\n\tstruct hlist_head spi_byspi[XFRM6_TUNNEL_SPI_BYSPI_HSIZE];\n\tu32 spi;\n};\n\nstatic int xfrm6_tunnel_net_id __read_mostly;\nstatic inline struct xfrm6_tunnel_net *xfrm6_tunnel_pernet(struct net *net)\n{\n\treturn net_generic(net, xfrm6_tunnel_net_id);\n}\n\n/*\n * xfrm_tunnel_spi things are for allocating unique id (\"spi\")\n * per xfrm_address_t.\n */\nstruct xfrm6_tunnel_spi {\n\tstruct hlist_node\tlist_byaddr;\n\tstruct hlist_node\tlist_byspi;\n\txfrm_address_t\t\taddr;\n\tu32\t\t\tspi;\n\tatomic_t\t\trefcnt;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstatic DEFINE_SPINLOCK(xfrm6_tunnel_spi_lock);\n\nstatic struct kmem_cache *xfrm6_tunnel_spi_kmem __read_mostly;\n\nstatic inline unsigned xfrm6_tunnel_spi_hash_byaddr(xfrm_address_t *addr)\n{\n\tunsigned h;\n\n\th = (__force u32)(addr->a6[0] ^ addr->a6[1] ^ addr->a6[2] ^ addr->a6[3]);\n\th ^= h >> 16;\n\th ^= h >> 8;\n\th &= XFRM6_TUNNEL_SPI_BYADDR_HSIZE - 1;\n\n\treturn h;\n}\n\nstatic inline unsigned xfrm6_tunnel_spi_hash_byspi(u32 spi)\n{\n\treturn spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;\n}\n\nstatic struct xfrm6_tunnel_spi *__xfrm6_tunnel_spi_lookup(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tstruct hlist_node *pos;\n\n\thlist_for_each_entry_rcu(x6spi, pos,\n\t\t\t     &xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\n\t\t\t     list_byaddr) {\n\t\tif (memcmp(&x6spi->addr, saddr, sizeof(x6spi->addr)) == 0)\n\t\t\treturn x6spi;\n\t}\n\n\treturn NULL;\n}\n\n__be32 xfrm6_tunnel_spi_lookup(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tu32 spi;\n\n\trcu_read_lock_bh();\n\tx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\n\tspi = x6spi ? x6spi->spi : 0;\n\trcu_read_unlock_bh();\n\treturn htonl(spi);\n}\n\nEXPORT_SYMBOL(xfrm6_tunnel_spi_lookup);\n\nstatic int __xfrm6_tunnel_spi_check(struct net *net, u32 spi)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tint index = xfrm6_tunnel_spi_hash_byspi(spi);\n\tstruct hlist_node *pos;\n\n\thlist_for_each_entry(x6spi, pos,\n\t\t\t     &xfrm6_tn->spi_byspi[index],\n\t\t\t     list_byspi) {\n\t\tif (x6spi->spi == spi)\n\t\t\treturn -1;\n\t}\n\treturn index;\n}\n\nstatic u32 __xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tu32 spi;\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tint index;\n\n\tif (xfrm6_tn->spi < XFRM6_TUNNEL_SPI_MIN ||\n\t    xfrm6_tn->spi >= XFRM6_TUNNEL_SPI_MAX)\n\t\txfrm6_tn->spi = XFRM6_TUNNEL_SPI_MIN;\n\telse\n\t\txfrm6_tn->spi++;\n\n\tfor (spi = xfrm6_tn->spi; spi <= XFRM6_TUNNEL_SPI_MAX; spi++) {\n\t\tindex = __xfrm6_tunnel_spi_check(net, spi);\n\t\tif (index >= 0)\n\t\t\tgoto alloc_spi;\n\t}\n\tfor (spi = XFRM6_TUNNEL_SPI_MIN; spi < xfrm6_tn->spi; spi++) {\n\t\tindex = __xfrm6_tunnel_spi_check(net, spi);\n\t\tif (index >= 0)\n\t\t\tgoto alloc_spi;\n\t}\n\tspi = 0;\n\tgoto out;\nalloc_spi:\n\txfrm6_tn->spi = spi;\n\tx6spi = kmem_cache_alloc(xfrm6_tunnel_spi_kmem, GFP_ATOMIC);\n\tif (!x6spi)\n\t\tgoto out;\n\n\tINIT_RCU_HEAD(&x6spi->rcu_head);\n\tmemcpy(&x6spi->addr, saddr, sizeof(x6spi->addr));\n\tx6spi->spi = spi;\n\tatomic_set(&x6spi->refcnt, 1);\n\n\thlist_add_head_rcu(&x6spi->list_byspi, &xfrm6_tn->spi_byspi[index]);\n\n\tindex = xfrm6_tunnel_spi_hash_byaddr(saddr);\n\thlist_add_head_rcu(&x6spi->list_byaddr, &xfrm6_tn->spi_byaddr[index]);\nout:\n\treturn spi;\n}\n\n__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tu32 spi;\n\n\tspin_lock_bh(&xfrm6_tunnel_spi_lock);\n\tx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\n\tif (x6spi) {\n\t\tatomic_inc(&x6spi->refcnt);\n\t\tspi = x6spi->spi;\n\t} else\n\t\tspi = __xfrm6_tunnel_alloc_spi(net, saddr);\n\tspin_unlock_bh(&xfrm6_tunnel_spi_lock);\n\n\treturn htonl(spi);\n}\n\nEXPORT_SYMBOL(xfrm6_tunnel_alloc_spi);\n\nstatic void x6spi_destroy_rcu(struct rcu_head *head)\n{\n\tkmem_cache_free(xfrm6_tunnel_spi_kmem,\n\t\t\tcontainer_of(head, struct xfrm6_tunnel_spi, rcu_head));\n}\n\nvoid xfrm6_tunnel_free_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tstruct hlist_node *pos, *n;\n\n\tspin_lock_bh(&xfrm6_tunnel_spi_lock);\n\n\thlist_for_each_entry_safe(x6spi, pos, n,\n\t\t\t\t  &xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\n\t\t\t\t  list_byaddr)\n\t{\n\t\tif (memcmp(&x6spi->addr, saddr, sizeof(x6spi->addr)) == 0) {\n\t\t\tif (atomic_dec_and_test(&x6spi->refcnt)) {\n\t\t\t\thlist_del_rcu(&x6spi->list_byaddr);\n\t\t\t\thlist_del_rcu(&x6spi->list_byspi);\n\t\t\t\tcall_rcu(&x6spi->rcu_head, x6spi_destroy_rcu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&xfrm6_tunnel_spi_lock);\n}\n\nEXPORT_SYMBOL(xfrm6_tunnel_free_spi);\n\nstatic int xfrm6_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tskb_push(skb, -skb_network_offset(skb));\n\treturn 0;\n}\n\nstatic int xfrm6_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\treturn skb_network_header(skb)[IP6CB(skb)->nhoff];\n}\n\nstatic int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup(net, (xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi) > 0 ? : 0;\n}\n\nstatic int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t/* xfrm6_tunnel native err handling */\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMPV6_NOROUTE:\n\t\tcase ICMPV6_ADM_PROHIBITED:\n\t\tcase ICMPV6_NOT_NEIGHBOUR:\n\t\tcase ICMPV6_ADDR_UNREACH:\n\t\tcase ICMPV6_PORT_UNREACH:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tswitch (code) {\n\t\tcase ICMPV6_EXC_HOPLIMIT:\n\t\t\tbreak;\n\t\tcase ICMPV6_EXC_FRAGTIME:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tswitch (code) {\n\t\tcase ICMPV6_HDR_FIELD: break;\n\t\tcase ICMPV6_UNK_NEXTHDR: break;\n\t\tcase ICMPV6_UNK_OPTION: break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm6_tunnel_init_state(struct xfrm_state *x)\n{\n\tif (x->props.mode != XFRM_MODE_TUNNEL)\n\t\treturn -EINVAL;\n\n\tif (x->encap)\n\t\treturn -EINVAL;\n\n\tx->props.header_len = sizeof(struct ipv6hdr);\n\n\treturn 0;\n}\n\nstatic void xfrm6_tunnel_destroy(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\n\txfrm6_tunnel_free_spi(net, (xfrm_address_t *)&x->props.saddr);\n}\n\nstatic const struct xfrm_type xfrm6_tunnel_type = {\n\t.description\t= \"IP6IP6\",\n\t.owner          = THIS_MODULE,\n\t.proto\t\t= IPPROTO_IPV6,\n\t.init_state\t= xfrm6_tunnel_init_state,\n\t.destructor\t= xfrm6_tunnel_destroy,\n\t.input\t\t= xfrm6_tunnel_input,\n\t.output\t\t= xfrm6_tunnel_output,\n};\n\nstatic struct xfrm6_tunnel xfrm6_tunnel_handler = {\n\t.handler\t= xfrm6_tunnel_rcv,\n\t.err_handler\t= xfrm6_tunnel_err,\n\t.priority\t= 2,\n};\n\nstatic struct xfrm6_tunnel xfrm46_tunnel_handler = {\n\t.handler\t= xfrm6_tunnel_rcv,\n\t.err_handler\t= xfrm6_tunnel_err,\n\t.priority\t= 2,\n};\n\nstatic int __net_init xfrm6_tunnel_net_init(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tn->spi_byaddr[i]);\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tn->spi_byspi[i]);\n\txfrm6_tn->spi = 0;\n\n\treturn 0;\n}\n\nstatic void __net_exit xfrm6_tunnel_net_exit(struct net *net)\n{\n}\n\nstatic struct pernet_operations xfrm6_tunnel_net_ops = {\n\t.init\t= xfrm6_tunnel_net_init,\n\t.exit\t= xfrm6_tunnel_net_exit,\n\t.id\t= &xfrm6_tunnel_net_id,\n\t.size\t= sizeof(struct xfrm6_tunnel_net),\n};\n\nstatic int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto out_pernet;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto out_type;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto out_xfrm6;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto out_xfrm46;\n\treturn 0;\n\nout_xfrm46:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nout_xfrm6:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nout_type:\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\nout_pernet:\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n\treturn rv;\n}\n\nstatic void __exit xfrm6_tunnel_fini(void)\n{\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}\n\nmodule_init(xfrm6_tunnel_init);\nmodule_exit(xfrm6_tunnel_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_IPV6);\n"], "filenames": ["net/ipv4/ipip.c", "net/ipv6/ip6_tunnel.c", "net/ipv6/sit.c", "net/ipv6/xfrm6_tunnel.c"], "buggy_code_start_loc": [833, 1464, 1230, 85], "buggy_code_end_loc": [842, 1485, 1239, 413], "fixing_code_start_loc": [833, 1463, 1229, 84], "fixing_code_end_loc": [841, 1487, 1238, 399], "type": "CWE-362", "message": "The tunnels implementation in the Linux kernel before 2.6.34, when tunnel functionality is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading.", "other": {"cve": {"id": "CVE-2011-1768", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:54.297", "lastModified": "2023-02-13T04:30:51.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tunnels implementation in the Linux kernel before 2.6.34, when tunnel functionality is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."}, {"lang": "es", "value": "La implementaci\u00f3n de t\u00faneles (\"tunnels\") del kernel de Linux en versiones anteriores a la 2.6.34, si la funcionalidad de t\u00faneles est\u00e1 configurada como m\u00f3dulo, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (OOPS) enviando un paquete durante la carga del m\u00f3dulo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 5.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.33.20", "matchCriteriaId": "B8187F7E-B31E-4C1C-8EB3-384193B7D7EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:*:*:*:*:*:*:*", "matchCriteriaId": "D81C2911-5781-46A4-AD27-F946BD44EAEC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.1:*:*:*:*:*:*:*", "matchCriteriaId": "17721A7D-E955-407B-AACB-97F859CE79C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.2:*:*:*:*:*:*:*", "matchCriteriaId": "7B04F515-29A7-4D6A-AFC5-3A115F8A5918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.3:*:*:*:*:*:*:*", "matchCriteriaId": "7514928F-8992-4B8A-8AF4-E89F1CB6EFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.4:*:*:*:*:*:*:*", "matchCriteriaId": "BD6324B7-1329-4C6B-8DDB-D489250E07C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.5:*:*:*:*:*:*:*", "matchCriteriaId": "A7910FE5-E02C-4B20-9F27-F488E76BDE93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.6:*:*:*:*:*:*:*", "matchCriteriaId": "96F85BC2-54C4-4450-B3BA-A2A8EB78A81C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.7:*:*:*:*:*:*:*", "matchCriteriaId": "25E5B510-1096-42E8-8BD1-E9198D588050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.8:*:*:*:*:*:*:*", "matchCriteriaId": "29787617-FFDD-4BDE-97EB-330675B99614"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.9:*:*:*:*:*:*:*", "matchCriteriaId": "7B28D3CE-E432-4F10-BF25-D03B0D89388A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.10:*:*:*:*:*:*:*", "matchCriteriaId": "E587FF24-AA5D-454B-8928-9C3CE03C419C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.11:*:*:*:*:*:*:*", "matchCriteriaId": "9DDBAAA5-240F-4DE5-BAA1-89508BD2CD8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.12:*:*:*:*:*:*:*", "matchCriteriaId": "F5D61706-2974-4C96-8196-9F3F56F1791F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.13:*:*:*:*:*:*:*", "matchCriteriaId": "46C5D7F1-152C-435F-8694-A66D0008289B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.14:*:*:*:*:*:*:*", "matchCriteriaId": "BEA2A352-7F4F-449D-AE23-24D39BFE0DB3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.15:*:*:*:*:*:*:*", "matchCriteriaId": "D9763287-12D3-485D-9DB4-0EBBEB2858C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.16:*:*:*:*:*:*:*", "matchCriteriaId": "9CDB80CE-2F1D-47EE-AE64-EA07B0AA3C20"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.17:*:*:*:*:*:*:*", "matchCriteriaId": "E70E77F5-12EF-4E12-8D34-9C56D23CAB22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.18:*:*:*:*:*:*:*", "matchCriteriaId": "B0139175-7049-4A2D-878E-EC43325DB5B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.19:*:*:*:*:*:*:*", "matchCriteriaId": "18483901-EC47-45AD-A9EB-30591AA1247E"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.34", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=d5aa407f59f5b83d2c50ec88f5bf56d40f1f8978", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/05/05/6", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=702303", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/d5aa407f59f5b83d2c50ec88f5bf56d40f1f8978", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d5aa407f59f5b83d2c50ec88f5bf56d40f1f8978"}}