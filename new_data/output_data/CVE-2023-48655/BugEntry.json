{"buggy_code": ["<?php\n\n/**\n * Get filter parameters from index searches\n */\n\nclass IndexFilterComponent extends Component\n{\n    /** @var Controller */\n    public $Controller;\n    public $isRest = null;\n\n    // Used for isApiFunction(), a check that returns true if the controller & action combo matches an action that is a non-xml and non-json automation method\n    // This is used to allow authentication via headers for methods not covered by _isRest() - as that only checks for JSON and XML formats\n    const AUTOMATION_ARRAY = array(\n        'events' => array('csv', 'nids', 'hids', 'xml', 'restSearch', 'stix', 'updateGraph', 'downloadOpenIOCEvent'),\n        'attributes' => array('text', 'downloadAttachment', 'returnAttributes', 'restSearch', 'rpz', 'bro'),\n        'objects' => array('restSearch'),\n    );\n\n    public function initialize(Controller $controller)\n    {\n        $this->Controller = $controller;\n    }\n\n    // generic function to standardise on the collection of parameters. Accepts posted request objects, url params, named url params\n    public function harvestParameters($paramArray, &$exception = [])\n    {\n        $request = $this->Controller->request;\n        $data = [];\n        if ($request->is('post')) {\n            if (empty($request->data)) {\n                $exception = $this->Controller->RestResponse->throwException(\n                    400,\n                    __('Either specify the search terms in the url, or POST a json with the filter parameters.'),\n                    '/' . $request->params['controller'] . '/' . $this->Controller->action\n                );\n                return false;\n            } else {\n                if (isset($request->data['request'])) {\n                    $data = $request->data['request'];\n                } else {\n                    $data = $request->data;\n                }\n            }\n        }\n\n        $data = $this->__massageData($data, $request, $paramArray);\n\n        $this->Controller->set('passedArgs', json_encode($this->Controller->passedArgs));\n        return $data;\n    }\n\n    private function __massageData($data, $request, $paramArray)\n    {\n        $data = array_filter($data, function($paramName) use ($paramArray) {\n            return in_array($paramName, $paramArray);\n        }, ARRAY_FILTER_USE_KEY);\n\n        if (!empty($paramArray)) {\n            foreach ($paramArray as $p) {\n                if (isset($request->params['named'][$p])) {\n                    $data[$p] = str_replace(';', ':', $request->params['named'][$p]);\n                }\n            }\n        }\n        foreach ($data as &$v) {\n            if (is_string($v)) {\n                $v = trim($v);\n                if (strpos($v, '||')) {\n                    $v = explode('||', $v);\n                }\n            }\n        }\n        unset($v);\n        return $data;\n\n    }\n\n    public function isRest()\n    {\n        // This method is surprisingly slow and called many times for one request, so it make sense to cache the result.\n        if ($this->isRest !== null) {\n            return $this->isRest;\n        }\n        $api = $this->isApiFunction($this->Controller->request->params['controller'], $this->Controller->request->params['action']);\n        if (isset($this->Controller->RequestHandler) && ($api || $this->isJson() || $this->Controller->RequestHandler->isXml() || $this->isCsv())) {\n            $this->isRest = true;\n            return true;\n        } else {\n            $this->isRest = false;\n            return false;\n        }\n    }\n\n    public function isJson()\n    {\n        return $this->Controller->request->header('Accept') === 'application/json' || $this->Controller->RequestHandler->prefers() === 'json';\n    }\n\n    public function isCsv()\n    {\n        return $this->Controller->request->header('Accept') === 'text/csv' || $this->Controller->RequestHandler->prefers() === 'csv';\n    }\n\n    public function isXml()\n    {\n\n    }\n\n    /**\n     * @param string $controller\n     * @param string $action\n     * @return bool\n     */\n    public function isApiFunction($controller, $action)\n    {\n        return isset(self::AUTOMATION_ARRAY[$controller]) && in_array($action, self::AUTOMATION_ARRAY[$controller], true);\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Get filter parameters from index searches\n */\n\nclass IndexFilterComponent extends Component\n{\n    /** @var Controller */\n    public $Controller;\n    public $isRest = null;\n\n    // Used for isApiFunction(), a check that returns true if the controller & action combo matches an action that is a non-xml and non-json automation method\n    // This is used to allow authentication via headers for methods not covered by _isRest() - as that only checks for JSON and XML formats\n    const AUTOMATION_ARRAY = array(\n        'events' => array('csv', 'nids', 'hids', 'xml', 'restSearch', 'stix', 'updateGraph', 'downloadOpenIOCEvent'),\n        'attributes' => array('text', 'downloadAttachment', 'returnAttributes', 'restSearch', 'rpz', 'bro'),\n        'objects' => array('restSearch'),\n    );\n\n    public function initialize(Controller $controller)\n    {\n        $this->Controller = $controller;\n    }\n\n    // generic function to standardise on the collection of parameters. Accepts posted request objects, url params, named url params\n    public function harvestParameters($paramArray, &$exception = [])\n    {\n        $request = $this->Controller->request;\n        $data = [];\n        if ($request->is('post')) {\n            if (empty($request->data)) {\n                $exception = $this->Controller->RestResponse->throwException(\n                    400,\n                    __('Either specify the search terms in the url, or POST a json with the filter parameters.'),\n                    '/' . $request->params['controller'] . '/' . $this->Controller->action\n                );\n                return false;\n            } else {\n                if (isset($request->data['request'])) {\n                    $data = $request->data['request'];\n                } else {\n                    $data = $request->data;\n                }\n            }\n        }\n\n        $data = $this->__massageData($data, $request, $paramArray);\n\n        $this->Controller->set('passedArgs', json_encode($this->Controller->passedArgs));\n        return $data;\n    }\n\n    private function __massageData($data, $request, $paramArray)\n    {\n        $data = array_filter($data, function($paramName) use ($paramArray) {\n            return in_array($paramName, $paramArray, true);\n        }, ARRAY_FILTER_USE_KEY);\n\n        if (!empty($paramArray)) {\n            foreach ($paramArray as $p) {\n                if (isset($request->params['named'][$p])) {\n                    $data[$p] = str_replace(';', ':', $request->params['named'][$p]);\n                }\n            }\n        }\n        foreach ($data as &$v) {\n            if (is_string($v)) {\n                $v = trim($v);\n                if (strpos($v, '||')) {\n                    $v = explode('||', $v);\n                }\n            }\n        }\n        unset($v);\n        return $data;\n\n    }\n\n    public function isRest()\n    {\n        // This method is surprisingly slow and called many times for one request, so it make sense to cache the result.\n        if ($this->isRest !== null) {\n            return $this->isRest;\n        }\n        $api = $this->isApiFunction($this->Controller->request->params['controller'], $this->Controller->request->params['action']);\n        if (isset($this->Controller->RequestHandler) && ($api || $this->isJson() || $this->Controller->RequestHandler->isXml() || $this->isCsv())) {\n            $this->isRest = true;\n            return true;\n        } else {\n            $this->isRest = false;\n            return false;\n        }\n    }\n\n    public function isJson()\n    {\n        return $this->Controller->request->header('Accept') === 'application/json' || $this->Controller->RequestHandler->prefers() === 'json';\n    }\n\n    public function isCsv()\n    {\n        return $this->Controller->request->header('Accept') === 'text/csv' || $this->Controller->RequestHandler->prefers() === 'csv';\n    }\n\n    public function isXml()\n    {\n\n    }\n\n    /**\n     * @param string $controller\n     * @param string $action\n     * @return bool\n     */\n    public function isApiFunction($controller, $action)\n    {\n        return isset(self::AUTOMATION_ARRAY[$controller]) && in_array($action, self::AUTOMATION_ARRAY[$controller], true);\n    }\n}\n"], "filenames": ["app/Controller/Component/IndexFilterComponent.php"], "buggy_code_start_loc": [57], "buggy_code_end_loc": [58], "fixing_code_start_loc": [57], "fixing_code_end_loc": [58], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in MISP before 2.4.176. app/Controller/Component/IndexFilterComponent.php does not properly filter out query parameters.", "other": {"cve": {"id": "CVE-2023-48655", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-17T05:15:12.640", "lastModified": "2024-01-10T00:15:45.530", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in MISP before 2.4.176. app/Controller/Component/IndexFilterComponent.php does not properly filter out query parameters."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en MISP antes de la versi\u00f3n 2.4.176. app/Controller/Component/IndexFilterComponent.php no filtra correctamente los par\u00e1metros de consulta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp-project:malware_information_sharing_platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.176", "matchCriteriaId": "2BBA7CBC-4331-4A5C-A738-3AC216AFC03A"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/158c8b2f788b75e0d26e9249a75e1be291e59d4b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/MISP/MISP/compare/v2.4.175...v2.4.176", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://zigrin.com/advisories/misp-blind-sql-injection-in-array-input-parameters/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/158c8b2f788b75e0d26e9249a75e1be291e59d4b"}}