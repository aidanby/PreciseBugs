{"buggy_code": ["/*\t$OpenBSD: smtp_session.c,v 1.421 2020/01/08 00:05:38 gilles Exp $\t*/\n\n/*\n * Copyright (c) 2008 Gilles Chehade <gilles@poolp.org>\n * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@openbsd.org>\n * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@dobremiasto.net>\n * Copyright (c) 2012 Eric Faurot <eric@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n\n#include <netinet/in.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <event.h>\n#include <imsg.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <openssl/ssl.h>\n#include <resolv.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <vis.h>\n\n#include \"smtpd.h\"\n#include \"log.h\"\n#include \"ssl.h\"\n#include \"rfc5322.h\"\n\n#define\tSMTP_LINE_MAX\t\t\t65535\n#define\tDATA_HIWAT\t\t\t65535\n#define\tAPPEND_DOMAIN_BUFFER_SIZE\tSMTP_LINE_MAX\n\nenum smtp_state {\n\tSTATE_NEW = 0,\n\tSTATE_CONNECTED,\n\tSTATE_TLS,\n\tSTATE_HELO,\n\tSTATE_AUTH_INIT,\n\tSTATE_AUTH_USERNAME,\n\tSTATE_AUTH_PASSWORD,\n\tSTATE_AUTH_FINALIZE,\n\tSTATE_BODY,\n\tSTATE_QUIT,\n};\n\nenum session_flags {\n\tSF_EHLO\t\t\t= 0x0001,\n\tSF_8BITMIME\t\t= 0x0002,\n\tSF_SECURE\t\t= 0x0004,\n\tSF_AUTHENTICATED\t= 0x0008,\n\tSF_BOUNCE\t\t= 0x0010,\n\tSF_VERIFIED\t\t= 0x0020,\n\tSF_BADINPUT\t\t= 0x0080,\n};\n\nenum {\n\tTX_OK = 0,\n\tTX_ERROR_ENVELOPE,\n\tTX_ERROR_SIZE,\n\tTX_ERROR_IO,\n\tTX_ERROR_LOOP,\n\tTX_ERROR_MALFORMED,\n\tTX_ERROR_RESOURCES,\n\tTX_ERROR_INTERNAL,\n};\n\nenum smtp_command {\n\tCMD_HELO = 0,\n\tCMD_EHLO,\n\tCMD_STARTTLS,\n\tCMD_AUTH,\n\tCMD_MAIL_FROM,\n\tCMD_RCPT_TO,\n\tCMD_DATA,\n\tCMD_RSET,\n\tCMD_QUIT,\n\tCMD_HELP,\n\tCMD_WIZ,\n\tCMD_NOOP,\n\tCMD_COMMIT,\n};\n\nstruct smtp_rcpt {\n\tTAILQ_ENTRY(smtp_rcpt)\t entry;\n\tuint64_t\t\t evpid;\n \tstruct mailaddr\t\t maddr;\n\tsize_t\t\t\t destcount;\n};\n\nstruct smtp_tx {\n\tstruct smtp_session\t*session;\n\tuint32_t\t\t msgid;\n\n\tstruct envelope\t\t evp;\n\tsize_t\t\t\t rcptcount;\n\tsize_t\t\t\t destcount;\n\tTAILQ_HEAD(, smtp_rcpt)\t rcpts;\n\n\ttime_t\t\t\t time;\n\tint\t\t\t error;\n\tsize_t\t\t\t datain;\n\tsize_t\t\t\t odatalen;\n\tFILE\t\t\t*ofile;\n\tstruct io\t\t*filter;\n\tstruct rfc5322_parser\t*parser;\n\tint\t\t\t rcvcount;\n\tint\t\t\t has_date;\n\tint\t\t\t has_message_id;\n\n\tuint8_t\t\t\t junk;\n};\n\nstruct smtp_session {\n\tuint64_t\t\t id;\n\tstruct io\t\t*io;\n\tstruct listener\t\t*listener;\n\tvoid\t\t\t*ssl_ctx;\n\tstruct sockaddr_storage\t ss;\n\tchar\t\t\t rdns[HOST_NAME_MAX+1];\n\tchar\t\t\t smtpname[HOST_NAME_MAX+1];\n\tint\t\t\t fcrdns;\n\n\tint\t\t\t flags;\n\tenum smtp_state\t\t state;\n\n\tuint8_t\t\t\t banner_sent;\n\tchar\t\t\t helo[LINE_MAX];\n\tchar\t\t\t cmd[LINE_MAX];\n\tchar\t\t\t username[SMTPD_MAXMAILADDRSIZE];\n\n\tsize_t\t\t\t mailcount;\n\tstruct event\t\t pause;\n\n\tstruct smtp_tx\t\t*tx;\n\n\tenum smtp_command\t last_cmd;\n\tenum filter_phase\t filter_phase;\n\tconst char\t\t*filter_param;\n\n\tuint8_t\t\t\t junk;\n};\n\n#define ADVERTISE_TLS(s) \\\n\t((s)->listener->flags & F_STARTTLS && !((s)->flags & SF_SECURE))\n\n#define ADVERTISE_AUTH(s) \\\n\t((s)->listener->flags & F_AUTH && (s)->flags & SF_SECURE && \\\n\t !((s)->flags & SF_AUTHENTICATED))\n\n#define ADVERTISE_EXT_DSN(s) \\\n\t((s)->listener->flags & F_EXT_DSN)\n\n#define\tSESSION_FILTERED(s) \\\n\t((s)->listener->flags & F_FILTERED)\n\n#define\tSESSION_DATA_FILTERED(s) \\\n\t((s)->listener->flags & F_FILTERED)\n\n\nstatic int smtp_mailaddr(struct mailaddr *, char *, int, char **, const char *);\nstatic void smtp_session_init(void);\nstatic void smtp_lookup_servername(struct smtp_session *);\nstatic void smtp_getnameinfo_cb(void *, int, const char *, const char *);\nstatic void smtp_getaddrinfo_cb(void *, int, struct addrinfo *);\nstatic void smtp_connected(struct smtp_session *);\nstatic void smtp_send_banner(struct smtp_session *);\nstatic void smtp_tls_verified(struct smtp_session *);\nstatic void smtp_io(struct io *, int, void *);\nstatic void smtp_enter_state(struct smtp_session *, int);\nstatic void smtp_reply(struct smtp_session *, char *, ...);\nstatic void smtp_command(struct smtp_session *, char *);\nstatic void smtp_rfc4954_auth_plain(struct smtp_session *, char *);\nstatic void smtp_rfc4954_auth_login(struct smtp_session *, char *);\nstatic void smtp_free(struct smtp_session *, const char *);\nstatic const char *smtp_strstate(int);\nstatic void smtp_cert_init(struct smtp_session *);\nstatic void smtp_cert_init_cb(void *, int, const char *, const void *, size_t);\nstatic void smtp_cert_verify(struct smtp_session *);\nstatic void smtp_cert_verify_cb(void *, int);\nstatic void smtp_auth_failure_pause(struct smtp_session *);\nstatic void smtp_auth_failure_resume(int, short, void *);\n\nstatic int  smtp_tx(struct smtp_session *);\nstatic void smtp_tx_free(struct smtp_tx *);\nstatic void smtp_tx_create_message(struct smtp_tx *);\nstatic void smtp_tx_mail_from(struct smtp_tx *, const char *);\nstatic void smtp_tx_rcpt_to(struct smtp_tx *, const char *);\nstatic void smtp_tx_open_message(struct smtp_tx *);\nstatic void smtp_tx_commit(struct smtp_tx *);\nstatic void smtp_tx_rollback(struct smtp_tx *);\nstatic int  smtp_tx_dataline(struct smtp_tx *, const char *);\nstatic int  smtp_tx_filtered_dataline(struct smtp_tx *, const char *);\nstatic void smtp_tx_eom(struct smtp_tx *);\nstatic void smtp_filter_fd(struct smtp_tx *, int);\nstatic int  smtp_message_fd(struct smtp_tx *, int);\nstatic void smtp_message_begin(struct smtp_tx *);\nstatic void smtp_message_end(struct smtp_tx *);\nstatic int  smtp_filter_printf(struct smtp_tx *, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nstatic int  smtp_message_printf(struct smtp_tx *, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\n\nstatic int  smtp_check_rset(struct smtp_session *, const char *);\nstatic int  smtp_check_helo(struct smtp_session *, const char *);\nstatic int  smtp_check_ehlo(struct smtp_session *, const char *);\nstatic int  smtp_check_auth(struct smtp_session *s, const char *);\nstatic int  smtp_check_starttls(struct smtp_session *, const char *);\nstatic int  smtp_check_mail_from(struct smtp_session *, const char *);\nstatic int  smtp_check_rcpt_to(struct smtp_session *, const char *);\nstatic int  smtp_check_data(struct smtp_session *, const char *);\nstatic int  smtp_check_noparam(struct smtp_session *, const char *);\n\nstatic void smtp_filter_phase(enum filter_phase, struct smtp_session *, const char *);\n\nstatic void smtp_proceed_connected(struct smtp_session *);\nstatic void smtp_proceed_rset(struct smtp_session *, const char *);\nstatic void smtp_proceed_helo(struct smtp_session *, const char *);\nstatic void smtp_proceed_ehlo(struct smtp_session *, const char *);\nstatic void smtp_proceed_auth(struct smtp_session *, const char *);\nstatic void smtp_proceed_starttls(struct smtp_session *, const char *);\nstatic void smtp_proceed_mail_from(struct smtp_session *, const char *);\nstatic void smtp_proceed_rcpt_to(struct smtp_session *, const char *);\nstatic void smtp_proceed_data(struct smtp_session *, const char *);\nstatic void smtp_proceed_noop(struct smtp_session *, const char *);\nstatic void smtp_proceed_help(struct smtp_session *, const char *);\nstatic void smtp_proceed_wiz(struct smtp_session *, const char *);\nstatic void smtp_proceed_quit(struct smtp_session *, const char *);\nstatic void smtp_proceed_commit(struct smtp_session *, const char *);\nstatic void smtp_proceed_rollback(struct smtp_session *, const char *);\n\nstatic void smtp_filter_begin(struct smtp_session *);\nstatic void smtp_filter_end(struct smtp_session *);\nstatic void smtp_filter_data_begin(struct smtp_session *);\nstatic void smtp_filter_data_end(struct smtp_session *);\n\nstatic void smtp_report_link_connect(struct smtp_session *, const char *, int,\n    const struct sockaddr_storage *,\n    const struct sockaddr_storage *);\nstatic void smtp_report_link_greeting(struct smtp_session *, const char *);\nstatic void smtp_report_link_identify(struct smtp_session *, const char *, const char *);\nstatic void smtp_report_link_tls(struct smtp_session *, const char *);\nstatic void smtp_report_link_disconnect(struct smtp_session *);\nstatic void smtp_report_link_auth(struct smtp_session *, const char *, const char *);\nstatic void smtp_report_tx_reset(struct smtp_session *, uint32_t);\nstatic void smtp_report_tx_begin(struct smtp_session *, uint32_t);\nstatic void smtp_report_tx_mail(struct smtp_session *, uint32_t, const char *, int);\nstatic void smtp_report_tx_rcpt(struct smtp_session *, uint32_t, const char *, int);\nstatic void smtp_report_tx_envelope(struct smtp_session *, uint32_t, uint64_t);\nstatic void smtp_report_tx_data(struct smtp_session *, uint32_t, int);\nstatic void smtp_report_tx_commit(struct smtp_session *, uint32_t, size_t);\nstatic void smtp_report_tx_rollback(struct smtp_session *, uint32_t);\nstatic void smtp_report_protocol_client(struct smtp_session *, const char *);\nstatic void smtp_report_protocol_server(struct smtp_session *, const char *);\nstatic void smtp_report_filter_response(struct smtp_session *, int, int, const char *);\nstatic void smtp_report_timeout(struct smtp_session *);\n\n\nstatic struct {\n\tint code;\n\tenum filter_phase filter_phase;\n\tconst char *cmd;\n\n\tint (*check)(struct smtp_session *, const char *);\n\tvoid (*proceed)(struct smtp_session *, const char *);\n} commands[] = {\n\t{ CMD_HELO,             FILTER_HELO,            \"HELO\",         smtp_check_helo,        smtp_proceed_helo },\n\t{ CMD_EHLO,             FILTER_EHLO,            \"EHLO\",         smtp_check_ehlo,        smtp_proceed_ehlo },\n\t{ CMD_STARTTLS,         FILTER_STARTTLS,        \"STARTTLS\",     smtp_check_starttls,    smtp_proceed_starttls },\n\t{ CMD_AUTH,             FILTER_AUTH,            \"AUTH\",         smtp_check_auth,        smtp_proceed_auth },\n\t{ CMD_MAIL_FROM,        FILTER_MAIL_FROM,       \"MAIL FROM\",    smtp_check_mail_from,   smtp_proceed_mail_from },\n\t{ CMD_RCPT_TO,          FILTER_RCPT_TO,         \"RCPT TO\",      smtp_check_rcpt_to,     smtp_proceed_rcpt_to },\n\t{ CMD_DATA,             FILTER_DATA,            \"DATA\",         smtp_check_data,        smtp_proceed_data },\n\t{ CMD_RSET,             FILTER_RSET,            \"RSET\",         smtp_check_rset,        smtp_proceed_rset },\n\t{ CMD_QUIT,             FILTER_QUIT,            \"QUIT\",         smtp_check_noparam,     smtp_proceed_quit },\n\t{ CMD_NOOP,             FILTER_NOOP,            \"NOOP\",         smtp_check_noparam,     smtp_proceed_noop },\n\t{ CMD_HELP,             FILTER_HELP,            \"HELP\",         smtp_check_noparam,     smtp_proceed_help },\n\t{ CMD_WIZ,              FILTER_WIZ,             \"WIZ\",          smtp_check_noparam,     smtp_proceed_wiz },\n\t{ CMD_COMMIT,  \t\tFILTER_COMMIT,\t\t\".\",\t\tsmtp_check_noparam,\tsmtp_proceed_commit },\n\t{ -1,                   0,                      NULL,           NULL },\n};\n\nstatic struct tree wait_lka_helo;\nstatic struct tree wait_lka_mail;\nstatic struct tree wait_lka_rcpt;\nstatic struct tree wait_parent_auth;\nstatic struct tree wait_queue_msg;\nstatic struct tree wait_queue_fd;\nstatic struct tree wait_queue_commit;\nstatic struct tree wait_ssl_init;\nstatic struct tree wait_ssl_verify;\nstatic struct tree wait_filters;\nstatic struct tree wait_filter_fd;\n\nstatic void\nheader_append_domain_buffer(char *buffer, char *domain, size_t len)\n{\n\tsize_t\ti;\n\tint\tescape, quote, comment, bracket;\n\tint\thas_domain, has_bracket, has_group;\n\tint\tpos_bracket, pos_component, pos_insert;\n\tchar\tcopy[APPEND_DOMAIN_BUFFER_SIZE];\n\n\tescape = quote = comment = bracket = 0;\n\thas_domain = has_bracket = has_group = 0;\n\tpos_bracket = pos_insert = pos_component = 0;\n\tfor (i = 0; buffer[i]; ++i) {\n\t\tif (buffer[i] == '(' && !escape && !quote)\n\t\t\tcomment++;\n\t\tif (buffer[i] == '\"' && !escape && !comment)\n\t\t\tquote = !quote;\n\t\tif (buffer[i] == ')' && !escape && !quote && comment)\n\t\t\tcomment--;\n\t\tif (buffer[i] == '\\\\' && !escape && !comment && !quote)\n\t\t\tescape = 1;\n\t\telse\n\t\t\tescape = 0;\n\t\tif (buffer[i] == '<' && !escape && !comment && !quote && !bracket) {\n\t\t\tbracket++;\n\t\t\thas_bracket = 1;\n\t\t}\n\t\tif (buffer[i] == '>' && !escape && !comment && !quote && bracket) {\n\t\t\tbracket--;\n\t\t\tpos_bracket = i;\n\t\t}\n\t\tif (buffer[i] == '@' && !escape && !comment && !quote)\n\t\t\thas_domain = 1;\n\t\tif (buffer[i] == ':' && !escape && !comment && !quote)\n\t\t\thas_group = 1;\n\n\t\t/* update insert point if not in comment and not on a whitespace */\n\t\tif (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))\n\t\t\tpos_component = i;\n\t}\n\n\t/* parse error, do not attempt to modify */\n\tif (escape || quote || comment || bracket)\n\t\treturn;\n\n\t/* domain already present, no need to modify */\n\tif (has_domain)\n\t\treturn;\n\n\t/* address is group, skip */\n\tif (has_group)\n\t\treturn;\n\n\t/* there's an address between brackets, just append domain */\n\tif (has_bracket) {\n\t\tpos_bracket--;\n\t\twhile (isspace((unsigned char)buffer[pos_bracket]))\n\t\t\tpos_bracket--;\n\t\tif (buffer[pos_bracket] == '<')\n\t\t\treturn;\n\t\tpos_insert = pos_bracket + 1;\n\t}\n\telse {\n\t\t/* otherwise append address to last component */\n\t\tpos_insert = pos_component + 1;\n\n\t\t/* empty address */\n                if (buffer[pos_component] == '\\0' ||\n\t\t    isspace((unsigned char)buffer[pos_component]))\n                        return;\n\t}\n\n\tif (snprintf(copy, sizeof copy, \"%.*s@%s%s\",\n\t\t(int)pos_insert, buffer,\n\t\tdomain,\n\t\tbuffer+pos_insert) >= (int)sizeof copy)\n\t\treturn;\n\n\tmemcpy(buffer, copy, len);\n}\n\nstatic void\nheader_address_rewrite_buffer(char *buffer, const char *address, size_t len)\n{\n\tsize_t\ti;\n\tint\taddress_len;\n\tint\tescape, quote, comment, bracket;\n\tint\thas_bracket, has_group;\n\tint\tpos_bracket_beg, pos_bracket_end, pos_component_beg, pos_component_end;\n\tint\tinsert_beg, insert_end;\n\tchar\tcopy[APPEND_DOMAIN_BUFFER_SIZE];\n\n\tescape = quote = comment = bracket = 0;\n\thas_bracket = has_group = 0;\n\tpos_bracket_beg = pos_bracket_end = pos_component_beg = pos_component_end = 0;\n\tfor (i = 0; buffer[i]; ++i) {\n\t\tif (buffer[i] == '(' && !escape && !quote)\n\t\t\tcomment++;\n\t\tif (buffer[i] == '\"' && !escape && !comment)\n\t\t\tquote = !quote;\n\t\tif (buffer[i] == ')' && !escape && !quote && comment)\n\t\t\tcomment--;\n\t\tif (buffer[i] == '\\\\' && !escape && !comment && !quote)\n\t\t\tescape = 1;\n\t\telse\n\t\t\tescape = 0;\n\t\tif (buffer[i] == '<' && !escape && !comment && !quote && !bracket) {\n\t\t\tbracket++;\n\t\t\thas_bracket = 1;\n\t\t\tpos_bracket_beg = i+1;\n\t\t}\n\t\tif (buffer[i] == '>' && !escape && !comment && !quote && bracket) {\n\t\t\tbracket--;\n\t\t\tpos_bracket_end = i;\n\t\t}\n\t\tif (buffer[i] == ':' && !escape && !comment && !quote)\n\t\t\thas_group = 1;\n\n\t\t/* update insert point if not in comment and not on a whitespace */\n\t\tif (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))\n\t\t\tpos_component_end = i;\n\t}\n\n\t/* parse error, do not attempt to modify */\n\tif (escape || quote || comment || bracket)\n\t\treturn;\n\n\t/* address is group, skip */\n\tif (has_group)\n\t\treturn;\n\n\t/* there's an address between brackets, just replace everything brackets */\n\tif (has_bracket) {\n\t\tinsert_beg = pos_bracket_beg;\n\t\tinsert_end = pos_bracket_end;\n\t}\n\telse {\n\t\tif (pos_component_end == 0)\n\t\t\tpos_component_beg = 0;\n\t\telse {\n\t\t\tfor (pos_component_beg = pos_component_end; pos_component_beg >= 0; --pos_component_beg)\n\t\t\t\tif (buffer[pos_component_beg] == ')' || isspace(buffer[pos_component_beg]))\n\t\t\t\t\tbreak;\n\t\t\tpos_component_beg += 1;\n\t\t\tpos_component_end += 1;\n\t\t}\n\t\tinsert_beg = pos_component_beg;\n\t\tinsert_end = pos_component_end;\n\t}\n\n\t/* check that masquerade won' t overflow */\n\taddress_len = strlen(address);\n\tif (strlen(buffer) - (insert_end - insert_beg) + address_len >= len)\n\t\treturn;\n\n\t(void)strlcpy(copy, buffer, sizeof copy);\n\t(void)strlcpy(copy+insert_beg, address, sizeof (copy) - insert_beg);\n\t(void)strlcat(copy, buffer+insert_end, sizeof (copy));\n\tmemcpy(buffer, copy, len);\n}\n\nstatic void\nheader_domain_append_callback(struct smtp_tx *tx, const char *hdr,\n    const char *val)\n{\n\tsize_t\t\t\ti, j, linelen;\n\tint\t\t\tescape, quote, comment, skip;\n\tchar\t\t\tbuffer[APPEND_DOMAIN_BUFFER_SIZE];\n\tconst char *line, *end;\n\n\tif (smtp_message_printf(tx, \"%s:\", hdr) == -1)\n\t\treturn;\n\n\tj = 0;\n\tescape = quote = comment = skip = 0;\n\tmemset(buffer, 0, sizeof buffer);\n\n\tfor (line = val; line; line = end) {\n\t\tend = strchr(line, '\\n');\n\t\tif (end) {\n\t\t\tlinelen = end - line;\n\t\t\tend++;\n\t\t}\n\t\telse\n\t\t\tlinelen = strlen(line);\n\n\t\tfor (i = 0; i < linelen; ++i) {\n\t\t\tif (line[i] == '(' && !escape && !quote)\n\t\t\t\tcomment++;\n\t\t\tif (line[i] == '\"' && !escape && !comment)\n\t\t\t\tquote = !quote;\n\t\t\tif (line[i] == ')' && !escape && !quote && comment)\n\t\t\t\tcomment--;\n\t\t\tif (line[i] == '\\\\' && !escape && !comment && !quote)\n\t\t\t\tescape = 1;\n\t\t\telse\n\t\t\t\tescape = 0;\n\n\t\t\t/* found a separator, buffer contains a full address */\n\t\t\tif (line[i] == ',' && !escape && !quote && !comment) {\n\t\t\t\tif (!skip && j + strlen(tx->session->listener->hostname) + 1 < sizeof buffer) {\n\t\t\t\t\theader_append_domain_buffer(buffer, tx->session->listener->hostname, sizeof buffer);\n\t\t\t\t\tif (tx->session->flags & SF_AUTHENTICATED &&\n\t\t\t\t\t    tx->session->listener->sendertable[0] &&\n\t\t\t\t\t    tx->session->listener->flags & F_MASQUERADE &&\n\t\t\t\t\t    !(strcasecmp(hdr, \"From\")))\n\t\t\t\t\t\theader_address_rewrite_buffer(buffer, mailaddr_to_text(&tx->evp.sender),\n\t\t\t\t\t\t    sizeof buffer);\n\t\t\t\t}\n\t\t\t\tif (smtp_message_printf(tx, \"%s,\", buffer) == -1)\n\t\t\t\t\treturn;\n\t\t\t\tj = 0;\n\t\t\t\tskip = 0;\n\t\t\t\tmemset(buffer, 0, sizeof buffer);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (skip) {\n\t\t\t\t\tif (smtp_message_printf(tx, \"%c\", line[i]) == -1)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer[j++] = line[i];\n\t\t\t\t\tif (j == sizeof (buffer) - 1) {\n\t\t\t\t\t\tif (smtp_message_printf(tx, \"%s\", buffer) == -1)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tskip = 1;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tmemset(buffer, 0, sizeof buffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (skip) {\n\t\t\tif (smtp_message_printf(tx, \"\\n\") == -1)\n\t\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tbuffer[j++] = '\\n';\n\t\t\tif (j == sizeof (buffer) - 1) {\n\t\t\t\tif (smtp_message_printf(tx, \"%s\", buffer) == -1)\n\t\t\t\t\treturn;\n\t\t\t\tskip = 1;\n\t\t\t\tj = 0;\n\t\t\t\tmemset(buffer, 0, sizeof buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* end of header, if buffer is not empty we'll process it */\n\tif (buffer[0]) {\n\t\tif (j + strlen(tx->session->listener->hostname) + 1 < sizeof buffer) {\n\t\t\theader_append_domain_buffer(buffer, tx->session->listener->hostname, sizeof buffer);\n\t\t\tif (tx->session->flags & SF_AUTHENTICATED &&\n\t\t\t    tx->session->listener->sendertable[0] &&\n\t\t\t    tx->session->listener->flags & F_MASQUERADE &&\n\t\t\t    !(strcasecmp(hdr, \"From\")))\n\t\t\t\theader_address_rewrite_buffer(buffer, mailaddr_to_text(&tx->evp.sender),\n\t\t\t\t    sizeof buffer);\n\t\t}\n\t\tsmtp_message_printf(tx, \"%s\", buffer);\n\t}\n}\n\nstatic void\nsmtp_session_init(void)\n{\n\tstatic int\tinit = 0;\n\n\tif (!init) {\n\t\ttree_init(&wait_lka_helo);\n\t\ttree_init(&wait_lka_mail);\n\t\ttree_init(&wait_lka_rcpt);\n\t\ttree_init(&wait_parent_auth);\n\t\ttree_init(&wait_queue_msg);\n\t\ttree_init(&wait_queue_fd);\n\t\ttree_init(&wait_queue_commit);\n\t\ttree_init(&wait_ssl_init);\n\t\ttree_init(&wait_ssl_verify);\n\t\ttree_init(&wait_filters);\n\t\ttree_init(&wait_filter_fd);\n\t\tinit = 1;\n\t}\n}\n\nint\nsmtp_session(struct listener *listener, int sock,\n    const struct sockaddr_storage *ss, const char *hostname, struct io *io)\n{\n\tstruct smtp_session\t*s;\n\n\tsmtp_session_init();\n\n\tif ((s = calloc(1, sizeof(*s))) == NULL)\n\t\treturn (-1);\n\n\ts->id = generate_uid();\n\ts->listener = listener;\n\tmemmove(&s->ss, ss, sizeof(*ss));\n\n\tif (io != NULL)\n\t\ts->io = io;\n\telse\n\t\ts->io = io_new();\n\n\tio_set_callback(s->io, smtp_io, s);\n\tio_set_fd(s->io, sock);\n\tio_set_timeout(s->io, SMTPD_SESSION_TIMEOUT * 1000);\n\tio_set_write(s->io);\n\ts->state = STATE_NEW;\n\n\t(void)strlcpy(s->smtpname, listener->hostname, sizeof(s->smtpname));\n\n\tlog_trace(TRACE_SMTP, \"smtp: %p: connected to listener %p \"\n\t    \"[hostname=%s, port=%d, tag=%s]\", s, listener,\n\t    listener->hostname, ntohs(listener->port), listener->tag);\n\n\t/* For local enqueueing, the hostname is already set */\n\tif (hostname) {\n\t\ts->flags |= SF_AUTHENTICATED;\n\t\t/* A bit of a hack */\n\t\tif (!strcmp(hostname, \"localhost\"))\n\t\t\ts->flags |= SF_BOUNCE;\n\t\t(void)strlcpy(s->rdns, hostname, sizeof(s->rdns));\n\t\ts->fcrdns = 1;\n\t\tsmtp_lookup_servername(s);\n\t} else {\n\t\tresolver_getnameinfo((struct sockaddr *)&s->ss, NI_NAMEREQD,\n\t\t    smtp_getnameinfo_cb, s);\n\t}\n\n\t/* session may have been freed by now */\n\n\treturn (0);\n}\n\nstatic void\nsmtp_getnameinfo_cb(void *arg, int gaierrno, const char *host, const char *serv)\n{\n\tstruct smtp_session *s = arg;\n\tstruct addrinfo hints;\n\n\tif (gaierrno) {\n\t\t(void)strlcpy(s->rdns, \"<unknown>\", sizeof(s->rdns));\n\n\t\tif (gaierrno == EAI_NODATA || gaierrno == EAI_NONAME)\n\t\t\ts->fcrdns = 0;\n\t\telse {\n\t\t\tlog_warnx(\"getnameinfo: %s: %s\", ss_to_text(&s->ss),\n\t\t\t    gai_strerror(gaierrno));\n\t\t\ts->fcrdns = -1;\n\t\t}\n\n\t\tsmtp_lookup_servername(s);\n\t\treturn;\n\t}\n\n\t(void)strlcpy(s->rdns, host, sizeof(s->rdns));\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = s->ss.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tresolver_getaddrinfo(s->rdns, NULL, &hints, smtp_getaddrinfo_cb, s);\n}\n\nstatic void\nsmtp_getaddrinfo_cb(void *arg, int gaierrno, struct addrinfo *ai0)\n{\n\tstruct smtp_session *s = arg;\n\tstruct addrinfo *ai;\n\tchar fwd[64], rev[64];\n\n\tif (gaierrno) {\n\t\tif (gaierrno == EAI_NODATA || gaierrno == EAI_NONAME)\n\t\t\ts->fcrdns = 0;\n\t\telse {\n\t\t\tlog_warnx(\"getaddrinfo: %s: %s\", s->rdns,\n\t\t\t    gai_strerror(gaierrno));\n\t\t\ts->fcrdns = -1;\n\t\t}\n\t}\n\telse {\n\t\tstrlcpy(rev, ss_to_text(&s->ss), sizeof(rev));\n\t\tfor (ai = ai0; ai; ai = ai->ai_next) {\n\t\t\tstrlcpy(fwd, sa_to_text(ai->ai_addr), sizeof(fwd));\n\t\t\tif (!strcmp(fwd, rev)) {\n\t\t\t\ts->fcrdns = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(ai0);\n\t}\n\n\tsmtp_lookup_servername(s);\n}\n\nvoid\nsmtp_session_imsg(struct mproc *p, struct imsg *imsg)\n{\n\tstruct smtp_session\t\t*s;\n\tstruct smtp_rcpt\t\t*rcpt;\n\tchar\t\t\t\t user[SMTPD_MAXMAILADDRSIZE];\n\tchar\t\t\t\t tmp[SMTP_LINE_MAX];\n\tstruct msg\t\t\t m;\n\tconst char\t\t\t*line, *helo;\n\tuint64_t\t\t\t reqid, evpid;\n\tuint32_t\t\t\t msgid;\n\tint\t\t\t\t status, success;\n\tint                              filter_response;\n\tconst char                      *filter_param;\n\tuint8_t                          i;\n\n\tswitch (imsg->hdr.type) {\n\n\tcase IMSG_SMTP_CHECK_SENDER:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &status);\n\t\tm_end(&m);\n\t\ts = tree_xpop(&wait_lka_mail, reqid);\n\t\tswitch (status) {\n\t\tcase LKA_OK:\n\t\t\tsmtp_tx_create_message(s->tx);\n\t\t\tbreak;\n\n\t\tcase LKA_PERMFAIL:\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_reply(s, \"%d %s\", 530, \"Sender rejected\");\n\t\t\tbreak;\n\t\tcase LKA_TEMPFAIL:\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\n\tcase IMSG_SMTP_EXPAND_RCPT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &status);\n\t\tm_get_string(&m, &line);\n\t\tm_end(&m);\n\t\ts = tree_xpop(&wait_lka_rcpt, reqid);\n\n\t\ttmp[0] = '\\0';\n\t\tif (s->tx->evp.rcpt.user[0]) {\n\t\t\t(void)strlcpy(tmp, s->tx->evp.rcpt.user, sizeof tmp);\n\t\t\tif (s->tx->evp.rcpt.domain[0]) {\n\t\t\t\t(void)strlcat(tmp, \"@\", sizeof tmp);\n\t\t\t\t(void)strlcat(tmp, s->tx->evp.rcpt.domain,\n\t\t\t\t    sizeof tmp);\n\t\t\t}\n\t\t}\n\n\t\tswitch (status) {\n\t\tcase LKA_OK:\n\t\t\tfatalx(\"unexpected ok\");\n\t\tcase LKA_PERMFAIL:\n\t\t\tsmtp_reply(s, \"%s: <%s>\", line, tmp);\n\t\t\tbreak;\n\t\tcase LKA_TEMPFAIL:\n\t\t\tsmtp_reply(s, \"%s: <%s>\", line, tmp);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\n\tcase IMSG_SMTP_LOOKUP_HELO:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\ts = tree_xpop(&wait_lka_helo, reqid);\n\t\tm_get_int(&m, &status);\n\t\tif (status == LKA_OK) {\n\t\t\tm_get_string(&m, &helo);\n\t\t\t(void)strlcpy(s->smtpname, helo, sizeof(s->smtpname));\n\t\t}\n\t\tm_end(&m);\n\t\tsmtp_connected(s);\n\t\treturn;\n\n\tcase IMSG_SMTP_MESSAGE_CREATE:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\ts = tree_xpop(&wait_queue_msg, reqid);\n\t\tif (success) {\n\t\t\tm_get_msgid(&m, &msgid);\n\t\t\ts->tx->msgid = msgid;\n\t\t\ts->tx->evp.id = msgid_to_evpid(msgid);\n\t\t\ts->tx->rcptcount = 0;\n\t\t\tsmtp_reply(s, \"250 %s Ok\",\n\t\t\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\t\t} else {\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t}\n\t\tm_end(&m);\n\t\treturn;\n\n\tcase IMSG_SMTP_MESSAGE_OPEN:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_queue_fd, reqid);\n\t\tif (!success || imsg->fd == -1) {\n\t\t\tif (imsg->fd != -1)\n\t\t\t\tclose(imsg->fd);\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(\"smtp: %p: fd %d from queue\", s, imsg->fd);\n\n\t\tif (smtp_message_fd(s->tx, imsg->fd)) {\n\t\t\tif (!SESSION_DATA_FILTERED(s))\n\t\t\t\tsmtp_message_begin(s->tx);\n\t\t\telse\n\t\t\t\tsmtp_filter_data_begin(s);\n\t\t}\n\t\treturn;\n\n\tcase IMSG_FILTER_SMTP_DATA_BEGIN:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_filter_fd, reqid);\n\t\tif (!success || imsg->fd == -1) {\n\t\t\tif (imsg->fd != -1)\n\t\t\t\tclose(imsg->fd);\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(\"smtp: %p: fd %d from lka\", s, imsg->fd);\n\n\t\tsmtp_filter_fd(s->tx, imsg->fd);\n\t\tsmtp_message_begin(s->tx);\n\t\treturn;\n\n\tcase IMSG_QUEUE_ENVELOPE_SUBMIT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\ts = tree_xget(&wait_lka_rcpt, reqid);\n\t\tif (success) {\n\t\t\tm_get_evpid(&m, &evpid);\n\t\t\ts->tx->evp.id = evpid;\n\t\t\ts->tx->destcount++;\n\t\t\tsmtp_report_tx_envelope(s, s->tx->msgid, evpid);\n\t\t}\n\t\telse\n\t\t\ts->tx->error = TX_ERROR_ENVELOPE;\n\t\tm_end(&m);\n\t\treturn;\n\n\tcase IMSG_QUEUE_ENVELOPE_COMMIT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\t\tif (!success)\n\t\t\tfatalx(\"commit evp failed: not supposed to happen\");\n\t\ts = tree_xpop(&wait_lka_rcpt, reqid);\n\t\tif (s->tx->error) {\n\t\t\t/*\n\t\t\t * If an envelope failed, we can't cancel the last\n\t\t\t * RCPT only so we must cancel the whole transaction\n\t\t\t * and close the connection.\n\t\t\t */\n\t\t\tsmtp_reply(s, \"421 %s Temporary failure\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t}\n\t\telse {\n\t\t\trcpt = xcalloc(1, sizeof(*rcpt));\n\t\t\trcpt->evpid = s->tx->evp.id;\n\t\t\trcpt->destcount = s->tx->destcount;\n\t\t\trcpt->maddr = s->tx->evp.rcpt;\n\t\t\tTAILQ_INSERT_TAIL(&s->tx->rcpts, rcpt, entry);\n\n\t\t\ts->tx->destcount = 0;\n\t\t\ts->tx->rcptcount++;\n\t\t\tsmtp_reply(s, \"250 %s %s: Recipient ok\",\n\t\t\t    esc_code(ESC_STATUS_OK, ESC_DESTINATION_ADDRESS_VALID),\n\t\t\t    esc_description(ESC_DESTINATION_ADDRESS_VALID));\n\t\t}\n\t\treturn;\n\n\tcase IMSG_SMTP_MESSAGE_COMMIT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\t\ts = tree_xpop(&wait_queue_commit, reqid);\n\t\tif (!success) {\n\t\t\tsmtp_reply(s, \"421 %s Temporary failure\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\treturn;\n\t\t}\n\n\t\tsmtp_reply(s, \"250 %s %08x Message accepted for delivery\",\n\t\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS),\n\t\t    s->tx->msgid);\n\t\tsmtp_report_tx_commit(s, s->tx->msgid, s->tx->odatalen);\n\t\tsmtp_report_tx_reset(s, s->tx->msgid);\n\n\t\tlog_info(\"%016\"PRIx64\" smtp message \"\n\t\t    \"msgid=%08x size=%zu nrcpt=%zu proto=%s\",\n\t\t    s->id,\n\t\t    s->tx->msgid,\n\t\t    s->tx->odatalen,\n\t\t    s->tx->rcptcount,\n\t\t    s->flags & SF_EHLO ? \"ESMTP\" : \"SMTP\");\n\t\tTAILQ_FOREACH(rcpt, &s->tx->rcpts, entry) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp envelope \"\n\t\t\t    \"evpid=%016\"PRIx64\" from=<%s%s%s> to=<%s%s%s>\",\n\t\t\t    s->id,\n\t\t\t    rcpt->evpid,\n\t\t\t    s->tx->evp.sender.user,\n\t\t\t    s->tx->evp.sender.user[0] == '\\0' ? \"\" : \"@\",\n\t\t\t    s->tx->evp.sender.domain,\n\t\t\t    rcpt->maddr.user,\n\t\t\t    rcpt->maddr.user[0] == '\\0' ? \"\" : \"@\",\n\t\t\t    rcpt->maddr.domain);\n\t\t}\n\t\tsmtp_tx_free(s->tx);\n\t\ts->mailcount++;\n\t\tsmtp_enter_state(s, STATE_HELO);\n\t\treturn;\n\n\tcase IMSG_SMTP_AUTHENTICATE:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_parent_auth, reqid);\n\t\tstrnvis(user, s->username, sizeof user, VIS_WHITE | VIS_SAFE);\n\t\tif (success == LKA_OK) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"authentication user=%s \"\n\t\t\t    \"result=ok\",\n\t\t\t    s->id, user);\n\t\t\ts->flags |= SF_AUTHENTICATED;\n\t\t\tsmtp_report_link_auth(s, user, \"pass\");\n\t\t\tsmtp_reply(s, \"235 %s Authentication succeeded\",\n\t\t\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\t\t}\n\t\telse if (success == LKA_PERMFAIL) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"authentication user=%s \"\n\t\t\t    \"result=permfail\",\n\t\t\t    s->id, user);\n\t\t\tsmtp_report_link_auth(s, user, \"fail\");\n\t\t\tsmtp_auth_failure_pause(s);\n\t\t\treturn;\n\t\t}\n\t\telse if (success == LKA_TEMPFAIL) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"authentication user=%s \"\n\t\t\t    \"result=tempfail\",\n\t\t\t    s->id, user);\n\t\t\tsmtp_report_link_auth(s, user, \"error\");\n\t\t\tsmtp_reply(s, \"421 %s Temporary failure\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t}\n\t\telse\n\t\t\tfatalx(\"bad lka response\");\n\n\t\tsmtp_enter_state(s, STATE_HELO);\n\t\treturn;\n\n\tcase IMSG_FILTER_SMTP_PROTOCOL:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &filter_response);\n\t\tif (filter_response != FILTER_PROCEED &&\n\t\t    filter_response != FILTER_JUNK)\n\t\t\tm_get_string(&m, &filter_param);\n\t\telse\n\t\t\tfilter_param = NULL;\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_filters, reqid);\n\n\t\tswitch (filter_response) {\n\t\tcase FILTER_REJECT:\n\t\tcase FILTER_DISCONNECT:\n\t\t\tif (!valid_smtp_response(filter_param) ||\n\t\t\t    (filter_param[0] != '4' && filter_param[0] != '5'))\n\t\t\t\tfilter_param = \"421 Internal server error\";\n\t\t\tif (!strncmp(filter_param, \"421\", 3))\n\t\t\t\tfilter_response = FILTER_DISCONNECT;\n\n\t\t\tsmtp_report_filter_response(s, s->filter_phase,\n\t\t\t    filter_response, filter_param);\n\n\t\t\tsmtp_reply(s, \"%s\", filter_param);\n\n\t\t\tif (filter_response == FILTER_DISCONNECT)\n\t\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\telse if (s->filter_phase == FILTER_COMMIT)\n\t\t\t\tsmtp_proceed_rollback(s, NULL);\n\t\t\tbreak;\n\n\n\t\tcase FILTER_JUNK:\n\t\t\tif (s->tx)\n\t\t\t\ts->tx->junk = 1;\n\t\t\telse\n\t\t\t\ts->junk = 1;\n\t\t\t/* fallthrough */\n\n\t\tcase FILTER_PROCEED:\n\t\t\tfilter_param = s->filter_param;\n\t\t\t/* fallthrough */\n\n\t\tcase FILTER_REWRITE:\n\t\t\tsmtp_report_filter_response(s, s->filter_phase,\n\t\t\t    filter_response,\n\t\t\t    filter_param == s->filter_param ? NULL : filter_param);\n\t\t\tif (s->filter_phase == FILTER_CONNECT) {\n\t\t\t\tsmtp_proceed_connected(s);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (i = 0; i < nitems(commands); ++i)\n\t\t\t\tif (commands[i].filter_phase == s->filter_phase) {\n\t\t\t\t\tif (filter_response == FILTER_REWRITE)\n\t\t\t\t\t\tif (!commands[i].check(s, filter_param))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcommands[i].proceed(s, filter_param);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tlog_warnx(\"smtp_session_imsg: unexpected %s imsg\",\n\t    imsg_to_str(imsg->hdr.type));\n\tfatalx(NULL);\n}\n\nstatic void\nsmtp_tls_verified(struct smtp_session *s)\n{\n\tX509 *x;\n\n\tx = SSL_get_peer_certificate(io_tls(s->io));\n\tif (x) {\n\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t    \"client-cert-check result=\\\"%s\\\"\",\n\t\t    s->id,\n\t\t    (s->flags & SF_VERIFIED) ? \"success\" : \"failure\");\n\t\tX509_free(x);\n\t}\n\n\tif (s->listener->flags & F_SMTPS) {\n\t\tstat_increment(\"smtp.smtps\", 1);\n\t\tio_set_write(s->io);\n\t\tsmtp_send_banner(s);\n\t}\n\telse {\n\t\tstat_increment(\"smtp.tls\", 1);\n\t\tsmtp_enter_state(s, STATE_HELO);\n\t}\n}\n\nstatic void\nsmtp_io(struct io *io, int evt, void *arg)\n{\n\tstruct smtp_session    *s = arg;\n\tchar\t\t       *line;\n\tsize_t\t\t\tlen;\n\tint\t\t\teom;\n\n\tlog_trace(TRACE_IO, \"smtp: %p: %s %s\", s, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\n\tcase IO_TLSREADY:\n\t\tlog_info(\"%016\"PRIx64\" smtp tls ciphers=%s\",\n\t\t    s->id, ssl_to_text(io_tls(s->io)));\n\n\t\tsmtp_report_link_tls(s, ssl_to_text(io_tls(s->io)));\n\n\t\ts->flags |= SF_SECURE;\n\t\ts->helo[0] = '\\0';\n\n\t\tsmtp_cert_verify(s);\n\t\tbreak;\n\n\tcase IO_DATAIN:\n\t    nextline:\n\t\tline = io_getline(s->io, &len);\n\t\tif ((line == NULL && io_datalen(s->io) >= SMTP_LINE_MAX) ||\n\t\t    (line && len >= SMTP_LINE_MAX)) {\n\t\t\ts->flags |= SF_BADINPUT;\n\t\t\tsmtp_reply(s, \"500 %s Line too long\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\tio_set_write(io);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\t/* Message body */\n\t\teom = 0;\n\t\tif (s->state == STATE_BODY) {\n\t\t\tif (strcmp(line, \".\")) {\n\t\t\t\ts->tx->datain += strlen(line) + 1;\n\t\t\t\tif (s->tx->datain > env->sc_maxsize)\n\t\t\t\t\ts->tx->error = TX_ERROR_SIZE;\n\t\t\t}\n\t\t\teom = (s->tx->filter == NULL) ?\n\t\t\t    smtp_tx_dataline(s->tx, line) :\n\t\t\t    smtp_tx_filtered_dataline(s->tx, line);\n\t\t\tif (eom == 0)\n\t\t\t\tgoto nextline;\n\t\t}\n\n\t\t/* Pipelining not supported */\n\t\tif (io_datalen(s->io)) {\n\t\t\ts->flags |= SF_BADINPUT;\n\t\t\tsmtp_reply(s, \"500 %s %s: Pipelining not supported\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\tio_set_write(io);\n\t\t\treturn;\n\t\t}\n\n\t\tif (eom) {\n\t\t\tio_set_write(io);\n\t\t\tif (s->tx->filter == NULL)\n\t\t\t\tsmtp_tx_eom(s->tx);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Must be a command */\n\t\tif (strlcpy(s->cmd, line, sizeof(s->cmd)) >= sizeof(s->cmd)) {\n\t\t\ts->flags |= SF_BADINPUT;\n\t\t\tsmtp_reply(s, \"500 %s Command line too long\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\tio_set_write(io);\n\t\t\treturn;\n\t\t}\n\t\tio_set_write(io);\n\t\tsmtp_command(s, line);\n\t\tbreak;\n\n\tcase IO_LOWAT:\n\t\tif (s->state == STATE_QUIT) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t\t    \"reason=quit\",\n\t\t\t    s->id);\n\t\t\tsmtp_free(s, \"done\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Wait for the client to start tls */\n\t\tif (s->state == STATE_TLS) {\n\t\t\tsmtp_cert_init(s);\n\t\t\tbreak;\n\t\t}\n\n\t\tio_set_read(io);\n\t\tbreak;\n\n\tcase IO_TIMEOUT:\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=timeout\",\n\t\t    s->id);\n\t\tsmtp_report_timeout(s);\n\t\tsmtp_free(s, \"timeout\");\n\t\tbreak;\n\n\tcase IO_DISCONNECTED:\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=disconnect\",\n\t\t    s->id);\n\t\tsmtp_free(s, \"disconnected\");\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=\\\"io-error: %s\\\"\",\n\t\t    s->id, io_error(io));\n\t\tsmtp_free(s, \"IO error\");\n\t\tbreak;\n\n\tdefault:\n\t\tfatalx(\"smtp_io()\");\n\t}\n}\n\nstatic void\nsmtp_command(struct smtp_session *s, char *line)\n{\n\tchar\t\t\t       *args;\n\tint\t\t\t\tcmd, i;\n\n\tlog_trace(TRACE_SMTP, \"smtp: %p: <<< %s\", s, line);\n\n\t/*\n\t * These states are special.\n\t */\n\tif (s->state == STATE_AUTH_INIT) {\n\t\tsmtp_report_protocol_client(s, \"********\");\n\t\tsmtp_rfc4954_auth_plain(s, line);\n\t\treturn;\n\t}\n\tif (s->state == STATE_AUTH_USERNAME || s->state == STATE_AUTH_PASSWORD) {\n\t\tsmtp_report_protocol_client(s, \"********\");\n\t\tsmtp_rfc4954_auth_login(s, line);\n\t\treturn;\n\t}\n\n\tif (s->state == STATE_HELO && strncasecmp(line, \"AUTH PLAIN \", 11) == 0)\n\t\tsmtp_report_protocol_client(s, \"AUTH PLAIN ********\");\n\telse\n\t\tsmtp_report_protocol_client(s, line);\n\n\n\t/*\n\t * Unlike other commands, \"mail from\" and \"rcpt to\" contain a\n\t * space in the command name.\n\t */\n\tif (strncasecmp(\"mail from:\", line, 10) == 0 ||\n\t    strncasecmp(\"rcpt to:\", line, 8) == 0)\n\t\targs = strchr(line, ':');\n\telse\n\t\targs = strchr(line, ' ');\n\n\tif (args) {\n\t\t*args++ = '\\0';\n\t\twhile (isspace((unsigned char)*args))\n\t\t\targs++;\n\t}\n\n\tcmd = -1;\n\tfor (i = 0; commands[i].code != -1; i++)\n\t\tif (!strcasecmp(line, commands[i].cmd)) {\n\t\t\tcmd = commands[i].code;\n\t\t\tbreak;\n\t\t}\n\n\ts->last_cmd = cmd;\n\tswitch (cmd) {\n\t/*\n\t * INIT\n\t */\n\tcase CMD_HELO:\n\t\tif (!smtp_check_helo(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_HELO, s, args);\n\t\tbreak;\n\n\tcase CMD_EHLO:\n\t\tif (!smtp_check_ehlo(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_EHLO, s, args);\n\t\tbreak;\n\n\t/*\n\t * SETUP\n\t */\n\tcase CMD_STARTTLS:\n\t\tif (!smtp_check_starttls(s, args))\n\t\t\tbreak;\n\n\t\tsmtp_filter_phase(FILTER_STARTTLS, s, NULL);\n\t\tbreak;\n\n\tcase CMD_AUTH:\n\t\tif (!smtp_check_auth(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_AUTH, s, args);\n\t\tbreak;\n\n\tcase CMD_MAIL_FROM:\n\t\tif (!smtp_check_mail_from(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_MAIL_FROM, s, args);\n\t\tbreak;\n\n\t/*\n\t * TRANSACTION\n\t */\n\tcase CMD_RCPT_TO:\n\t\tif (!smtp_check_rcpt_to(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_RCPT_TO, s, args);\n\t\tbreak;\n\n\tcase CMD_RSET:\n\t\tif (!smtp_check_rset(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_RSET, s, NULL);\n\t\tbreak;\n\n\tcase CMD_DATA:\n\t\tif (!smtp_check_data(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_DATA, s, NULL);\n\t\tbreak;\n\n\t/*\n\t * ANY\n\t */\n\tcase CMD_QUIT:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_filter_phase(FILTER_QUIT, s, NULL);\n\t\tbreak;\n\n\tcase CMD_NOOP:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_filter_phase(FILTER_NOOP, s, NULL);\n\t\tbreak;\n\n\tcase CMD_HELP:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_proceed_help(s, NULL);\n\t\tbreak;\n\n\tcase CMD_WIZ:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_proceed_wiz(s, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tsmtp_reply(s, \"500 %s %s: Command unrecognized\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\tbreak;\n\t}\n}\n\nstatic int\nsmtp_check_rset(struct smtp_session *s, const char *args)\n{\n\tif (!smtp_check_noparam(s, args))\n\t\treturn 0;\n\n\tif (s->helo[0] == '\\0') {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\nsmtp_check_helo(struct smtp_session *s, const char *args)\n{\n\tif (!s->banner_sent) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->helo[0]) {\n\t\tsmtp_reply(s, \"503 %s %s: Already identified\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args == NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: HELO requires domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!valid_domainpart(args)) {\n\t\tsmtp_reply(s, \"501 %s %s: Invalid domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_ehlo(struct smtp_session *s, const char *args)\n{\n\tif (!s->banner_sent) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->helo[0]) {\n\t\tsmtp_reply(s, \"503 %s %s: Already identified\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args == NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: EHLO requires domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!valid_domainpart(args)) {\n\t\tsmtp_reply(s, \"501 %s %s: Invalid domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_auth(struct smtp_session *s, const char *args)\n{\n\tif (s->helo[0] == '\\0' || s->tx) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->flags & SF_AUTHENTICATED) {\n\t\tsmtp_reply(s, \"503 %s %s: Already authenticated\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!ADVERTISE_AUTH(s)) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not supported\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args == NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: No parameters given\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_starttls(struct smtp_session *s, const char *args)\n{\n\tif (s->helo[0] == '\\0' || s->tx) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!(s->listener->flags & F_STARTTLS)) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not supported\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->flags & SF_SECURE) {\n\t\tsmtp_reply(s, \"503 %s %s: Channel already secured\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args != NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: No parameters allowed\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_mail_from(struct smtp_session *s, const char *args)\n{\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\tstruct mailaddr\tsender;\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\tcopy = tmp;  \n\n\tif (s->helo[0] == '\\0' || s->tx) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->listener->flags & F_STARTTLS_REQUIRE &&\n\t    !(s->flags & SF_SECURE)) {\n\t\tsmtp_reply(s,\n\t\t    \"530 %s %s: Must issue a STARTTLS command first\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->listener->flags & F_AUTH_REQUIRE &&\n\t    !(s->flags & SF_AUTHENTICATED)) {\n\t\tsmtp_reply(s,\n\t\t    \"530 %s %s: Must issue an AUTH command first\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->mailcount >= env->sc_session_max_mails) {\n\t\t/* we can pretend we had too many recipients */\n\t\tsmtp_reply(s, \"452 %s %s: Too many messages sent\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),\n\t\t    esc_description(ESC_TOO_MANY_RECIPIENTS));\n\t\treturn 0;\n\t}\n\n\tif (smtp_mailaddr(&sender, copy, 1, &copy,\n\t\ts->smtpname) == 0) {\n\t\tsmtp_reply(s, \"553 %s Sender address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_rcpt_to(struct smtp_session *s, const char *args)\n{\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\tcopy = tmp; \n\n\tif (s->tx == NULL) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->tx->rcptcount >= env->sc_session_max_rcpt) {\n\t\tsmtp_reply(s->tx->session, \"451 %s %s: Too many recipients\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),\n\t\t    esc_description(ESC_TOO_MANY_RECIPIENTS));\n\t\treturn 0;\n\t}\n\n\tif (smtp_mailaddr(&s->tx->evp.rcpt, copy, 0, &copy,\n\t\ts->tx->session->smtpname) == 0) {\n\t\tsmtp_reply(s->tx->session,\n\t\t    \"501 %s Recipient address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL,\n\t\t        ESC_BAD_DESTINATION_MAILBOX_ADDRESS_SYNTAX));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_data(struct smtp_session *s, const char *args)\n{\n\tif (!smtp_check_noparam(s, args))\n\t\treturn 0;\n\n\tif (s->tx == NULL) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->tx->rcptcount == 0) {\n\t\tsmtp_reply(s, \"503 %s %s: No recipient specified\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_noparam(struct smtp_session *s, const char *args)\n{\n\tif (args != NULL) {\n\t\tsmtp_reply(s, \"500 %s %s: command does not accept arguments.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nsmtp_query_filters(enum filter_phase phase, struct smtp_session *s, const char *args)\n{\n\tm_create(p_lka, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_add_int(p_lka, phase);\n\tm_add_string(p_lka, args);\n\tm_close(p_lka);\n\ttree_xset(&wait_filters, s->id, s);\n}\n\nstatic void\nsmtp_filter_begin(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_BEGIN, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_add_string(p_lka, s->listener->filter_name);\n\tm_close(p_lka);\n}\n\nstatic void\nsmtp_filter_end(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_END, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_close(p_lka);\n}\n\nstatic void\nsmtp_filter_data_begin(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_DATA_BEGIN, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_close(p_lka);\n\ttree_xset(&wait_filter_fd, s->id, s);\n}\n\nstatic void\nsmtp_filter_data_end(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tif (s->tx->filter == NULL)\n\t\treturn;\n\n\tio_free(s->tx->filter);\n\ts->tx->filter = NULL;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_DATA_END, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_close(p_lka);\n}\n\nstatic void\nsmtp_filter_phase(enum filter_phase phase, struct smtp_session *s, const char *param)\n{\n\tuint8_t i;\n\n\ts->filter_phase = phase;\n\ts->filter_param = param;\n\n\tif (SESSION_FILTERED(s)) {\n\t\tsmtp_query_filters(phase, s, param ? param : \"\");\n\t\treturn;\n\t}\n\n\tif (s->filter_phase == FILTER_CONNECT) {\n\t\tsmtp_proceed_connected(s);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nitems(commands); ++i)\n\t\tif (commands[i].filter_phase == s->filter_phase) {\n\t\t\tcommands[i].proceed(s, param);\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void\nsmtp_proceed_rset(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"250 %s Reset state\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\n\tif (s->tx) {\n\t\tif (s->tx->msgid)\n\t\t\tsmtp_tx_rollback(s->tx);\n\t\tsmtp_tx_free(s->tx);\n\t}\n}\n\nstatic void\nsmtp_proceed_helo(struct smtp_session *s, const char *args)\n{\n\t(void)strlcpy(s->helo, args, sizeof(s->helo));\n\ts->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED;\n\n\tsmtp_report_link_identify(s, \"HELO\", s->helo);\n\n\tsmtp_enter_state(s, STATE_HELO);\n\n\tsmtp_reply(s, \"250 %s Hello %s %s%s%s, pleased to meet you\",\n\t    s->smtpname,\n\t    s->helo,\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"[\",\n\t    ss_to_text(&s->ss),\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"]\");\n}\n\nstatic void\nsmtp_proceed_ehlo(struct smtp_session *s, const char *args)\n{\n\t(void)strlcpy(s->helo, args, sizeof(s->helo));\n\ts->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED;\n\ts->flags |= SF_EHLO;\n\ts->flags |= SF_8BITMIME;\n\n\tsmtp_report_link_identify(s, \"EHLO\", s->helo);\n\n\tsmtp_enter_state(s, STATE_HELO);\n\tsmtp_reply(s, \"250-%s Hello %s %s%s%s, pleased to meet you\",\n\t    s->smtpname,\n\t    s->helo,\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"[\",\n\t    ss_to_text(&s->ss),\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"]\");\n\n\tsmtp_reply(s, \"250-8BITMIME\");\n\tsmtp_reply(s, \"250-ENHANCEDSTATUSCODES\");\n\tsmtp_reply(s, \"250-SIZE %zu\", env->sc_maxsize);\n\tif (ADVERTISE_EXT_DSN(s))\n\t\tsmtp_reply(s, \"250-DSN\");\n\tif (ADVERTISE_TLS(s))\n\t\tsmtp_reply(s, \"250-STARTTLS\");\n\tif (ADVERTISE_AUTH(s))\n\t\tsmtp_reply(s, \"250-AUTH PLAIN LOGIN\");\n\tsmtp_reply(s, \"250 HELP\");\n}\n\nstatic void\nsmtp_proceed_auth(struct smtp_session *s, const char *args)\n{\n\tchar tmp[SMTP_LINE_MAX];\n\tchar *eom, *method;\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\n\tmethod = tmp;\n\teom = strchr(tmp, ' ');\n\tif (eom == NULL)\n\t\teom = strchr(tmp, '\\t');\n\tif (eom != NULL)\n\t\t*eom++ = '\\0';\n\tif (strcasecmp(method, \"PLAIN\") == 0)\n\t\tsmtp_rfc4954_auth_plain(s, eom);\n\telse if (strcasecmp(method, \"LOGIN\") == 0)\n\t\tsmtp_rfc4954_auth_login(s, eom);\n\telse\n\t\tsmtp_reply(s, \"504 %s %s: AUTH method \\\"%s\\\" not supported\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_SECURITY_FEATURES_NOT_SUPPORTED),\n\t\t    esc_description(ESC_SECURITY_FEATURES_NOT_SUPPORTED),\n\t\t    method);\n}\n\nstatic void\nsmtp_proceed_starttls(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"220 %s Ready to start TLS\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\tsmtp_enter_state(s, STATE_TLS);\n}\n\nstatic void\nsmtp_proceed_mail_from(struct smtp_session *s, const char *args)\n{\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\tcopy = tmp;  \n\n       \tif (!smtp_tx(s)) {\n\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\treturn;\n\t}\n\n\tif (smtp_mailaddr(&s->tx->evp.sender, copy, 1, &copy,\n\t\ts->smtpname) == 0) {\n\t\tsmtp_reply(s, \"553 %s Sender address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));\n\t\tsmtp_tx_free(s->tx);\n\t\treturn;\n\t}\n\n\tsmtp_tx_mail_from(s->tx, args);\n}\n\nstatic void\nsmtp_proceed_rcpt_to(struct smtp_session *s, const char *args)\n{\n\tsmtp_tx_rcpt_to(s->tx, args);\n}\n\nstatic void\nsmtp_proceed_data(struct smtp_session *s, const char *args)\n{\n\tsmtp_tx_open_message(s->tx);\n}\n\nstatic void\nsmtp_proceed_quit(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"221 %s Bye\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\tsmtp_enter_state(s, STATE_QUIT);\n}\n\nstatic void\nsmtp_proceed_noop(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"250 %s Ok\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n}\n\nstatic void\nsmtp_proceed_help(struct smtp_session *s, const char *args)\n{\n\tconst char *code = esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS);\n\n\tsmtp_reply(s, \"214-%s This is \" SMTPD_NAME, code);\n\tsmtp_reply(s, \"214-%s To report bugs in the implementation, \"\n\t    \"please contact bugs@openbsd.org\", code);\n\tsmtp_reply(s, \"214-%s with full details\", code);\n\tsmtp_reply(s, \"214 %s End of HELP info\", code);\n}\n\nstatic void\nsmtp_proceed_wiz(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"500 %s %s: this feature is not supported yet ;-)\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t    esc_description(ESC_INVALID_COMMAND));\n}\n\nstatic void\nsmtp_proceed_commit(struct smtp_session *s, const char *args)\n{\n\tsmtp_message_end(s->tx);\n}\n\nstatic void\nsmtp_proceed_rollback(struct smtp_session *s, const char *args)\n{\n\tstruct smtp_tx *tx;\n\n\ttx = s->tx;\n\n\tfclose(tx->ofile);\n\ttx->ofile = NULL;\n\n\tsmtp_tx_rollback(tx);\n\tsmtp_tx_free(tx);\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_rfc4954_auth_plain(struct smtp_session *s, char *arg)\n{\n\tchar\t\t buf[1024], *user, *pass;\n\tint\t\t len;\n\n\tswitch (s->state) {\n\tcase STATE_HELO:\n\t\tif (arg == NULL) {\n\t\t\tsmtp_enter_state(s, STATE_AUTH_INIT);\n\t\t\tsmtp_reply(s, \"334 \");\n\t\t\treturn;\n\t\t}\n\t\tsmtp_enter_state(s, STATE_AUTH_INIT);\n\t\t/* FALLTHROUGH */\n\n\tcase STATE_AUTH_INIT:\n\t\t/* String is not NUL terminated, leave room. */\n\t\tif ((len = base64_decode(arg, (unsigned char *)buf,\n\t\t\t    sizeof(buf) - 1)) == -1)\n\t\t\tgoto abort;\n\t\t/* buf is a byte string, NUL terminate. */\n\t\tbuf[len] = '\\0';\n\n\t\t/*\n\t\t * Skip \"foo\" in \"foo\\0user\\0pass\", if present.\n\t\t */\n\t\tuser = memchr(buf, '\\0', len);\n\t\tif (user == NULL || user >= buf + len - 2)\n\t\t\tgoto abort;\n\t\tuser++; /* skip NUL */\n\t\tif (strlcpy(s->username, user, sizeof(s->username))\n\t\t    >= sizeof(s->username))\n\t\t\tgoto abort;\n\n\t\tpass = memchr(user, '\\0', len - (user - buf));\n\t\tif (pass == NULL || pass >= buf + len - 2)\n\t\t\tgoto abort;\n\t\tpass++; /* skip NUL */\n\n\t\tm_create(p_lka,  IMSG_SMTP_AUTHENTICATE, 0, 0, -1);\n\t\tm_add_id(p_lka, s->id);\n\t\tm_add_string(p_lka, s->listener->authtable);\n\t\tm_add_string(p_lka, user);\n\t\tm_add_string(p_lka, pass);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_parent_auth, s->id, s);\n\t\treturn;\n\n\tdefault:\n\t\tfatal(\"smtp_rfc4954_auth_plain: unknown state\");\n\t}\n\nabort:\n\tsmtp_reply(s, \"501 %s %s: Syntax error\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_SYNTAX_ERROR),\n\t    esc_description(ESC_SYNTAX_ERROR));\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_rfc4954_auth_login(struct smtp_session *s, char *arg)\n{\n\tchar\t\tbuf[LINE_MAX];\n\n\tswitch (s->state) {\n\tcase STATE_HELO:\n\t\tsmtp_enter_state(s, STATE_AUTH_USERNAME);\n\t\tif (arg != NULL && *arg != '\\0') {\n\t\t\tsmtp_rfc4954_auth_login(s, arg);\n\t\t\treturn;\n\t\t}\n\t\tsmtp_reply(s, \"334 VXNlcm5hbWU6\");\n\t\treturn;\n\n\tcase STATE_AUTH_USERNAME:\n\t\tmemset(s->username, 0, sizeof(s->username));\n\t\tif (base64_decode(arg, (unsigned char *)s->username,\n\t\t\t\t  sizeof(s->username) - 1) == -1)\n\t\t\tgoto abort;\n\n\t\tsmtp_enter_state(s, STATE_AUTH_PASSWORD);\n\t\tsmtp_reply(s, \"334 UGFzc3dvcmQ6\");\n\t\treturn;\n\n\tcase STATE_AUTH_PASSWORD:\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (base64_decode(arg, (unsigned char *)buf,\n\t\t\t\t  sizeof(buf)-1) == -1)\n\t\t\tgoto abort;\n\n\t\tm_create(p_lka,  IMSG_SMTP_AUTHENTICATE, 0, 0, -1);\n\t\tm_add_id(p_lka, s->id);\n\t\tm_add_string(p_lka, s->listener->authtable);\n\t\tm_add_string(p_lka, s->username);\n\t\tm_add_string(p_lka, buf);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_parent_auth, s->id, s);\n\t\treturn;\n\n\tdefault:\n\t\tfatal(\"smtp_rfc4954_auth_login: unknown state\");\n\t}\n\nabort:\n\tsmtp_reply(s, \"501 %s %s: Syntax error\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_SYNTAX_ERROR),\n\t    esc_description(ESC_SYNTAX_ERROR));\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_lookup_servername(struct smtp_session *s)\n{\n\tif (s->listener->hostnametable[0]) {\n\t\tm_create(p_lka, IMSG_SMTP_LOOKUP_HELO, 0, 0, -1);\n\t\tm_add_id(p_lka, s->id);\n\t\tm_add_string(p_lka, s->listener->hostnametable);\n\t\tm_add_sockaddr(p_lka, (struct sockaddr*)&s->listener->ss);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_lka_helo, s->id, s);\n\t\treturn;\n\t}\n\n\tsmtp_connected(s);\n}\n\nstatic void\nsmtp_connected(struct smtp_session *s)\n{\n\tsmtp_enter_state(s, STATE_CONNECTED);\n\n\tlog_info(\"%016\"PRIx64\" smtp connected address=%s host=%s\",\n\t    s->id, ss_to_text(&s->ss), s->rdns);\n\n\tsmtp_filter_begin(s);\n\n\tsmtp_report_link_connect(s, s->rdns, s->fcrdns, &s->ss,\n\t    &s->listener->ss);\n\n\tsmtp_filter_phase(FILTER_CONNECT, s, ss_to_text(&s->ss));\n}\n\nstatic void\nsmtp_proceed_connected(struct smtp_session *s)\n{\n\tif (s->listener->flags & F_SMTPS)\n\t\tsmtp_cert_init(s);\n\telse\n\t\tsmtp_send_banner(s);\n}\n\nstatic void\nsmtp_send_banner(struct smtp_session *s)\n{\n\tsmtp_reply(s, \"220 %s ESMTP %s\", s->smtpname, SMTPD_NAME);\n\ts->banner_sent = 1;\n\tsmtp_report_link_greeting(s, s->smtpname);\n}\n\nvoid\nsmtp_enter_state(struct smtp_session *s, int newstate)\n{\n\tlog_trace(TRACE_SMTP, \"smtp: %p: %s -> %s\", s,\n\t    smtp_strstate(s->state),\n\t    smtp_strstate(newstate));\n\n\ts->state = newstate;\n}\n\nstatic void\nsmtp_reply(struct smtp_session *s, char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t n;\n\tchar\t buf[LINE_MAX*2], tmp[LINE_MAX*2];\n\n\tva_start(ap, fmt);\n\tn = vsnprintf(buf, sizeof buf, fmt, ap);\n\tva_end(ap);\n\tif (n < 0)\n\t\tfatalx(\"smtp_reply: response format error\");\n\tif (n < 4)\n\t\tfatalx(\"smtp_reply: response too short\");\n\tif (n >= (int)sizeof buf) {\n\t\t/* only first three bytes are used by SMTP logic,\n\t\t * so if _our_ reply does not fit entirely in the\n\t\t * buffer, it's ok to truncate.\n\t\t */\n\t}\n\n\tlog_trace(TRACE_SMTP, \"smtp: %p: >>> %s\", s, buf);\n\tsmtp_report_protocol_server(s, buf);\n\n\tswitch (buf[0]) {\n\tcase '2':\n\t\tif (s->tx) {\n\t\t\tif (s->last_cmd == CMD_MAIL_FROM) {\n\t\t\t\tsmtp_report_tx_begin(s, s->tx->msgid);\n\t\t\t\tsmtp_report_tx_mail(s, s->tx->msgid, s->cmd + 10, 1);\n\t\t\t}\n\t\t\telse if (s->last_cmd == CMD_RCPT_TO)\n\t\t\t\tsmtp_report_tx_rcpt(s, s->tx->msgid, s->cmd + 8, 1);\n\t\t}\n\t\tbreak;\n\tcase '3':\n\t\tif (s->tx) {\n\t\t\tif (s->last_cmd == CMD_DATA)\n\t\t\t\tsmtp_report_tx_data(s, s->tx->msgid, 1);\n\t\t}\n\t\tbreak;\n\tcase '5':\n\tcase '4':\n\t\t/* do not report smtp_tx_mail/smtp_tx_rcpt errors\n\t\t * if they happened outside of a transaction.\n\t\t */\n\t\tif (s->tx) {\n\t\t\tif (s->last_cmd == CMD_MAIL_FROM)\n\t\t\t\tsmtp_report_tx_mail(s, s->tx->msgid,\n\t\t\t\t    s->cmd + 10, buf[0] == '4' ? -1 : 0);\n\t\t\telse if (s->last_cmd == CMD_RCPT_TO)\n\t\t\t\tsmtp_report_tx_rcpt(s,\n\t\t\t\t    s->tx->msgid, s->cmd + 8, buf[0] == '4' ? -1 : 0);\n\t\t\telse if (s->last_cmd == CMD_DATA && s->tx->rcptcount)\n\t\t\t\tsmtp_report_tx_data(s, s->tx->msgid,\n\t\t\t\t    buf[0] == '4' ? -1 : 0);\n\t\t}\n\n\t\tif (s->flags & SF_BADINPUT) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"bad-input result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse if (s->state == STATE_AUTH_INIT) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command \"\n\t\t\t    \"command=\\\"AUTH PLAIN (...)\\\" result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse if (s->state == STATE_AUTH_USERNAME) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command \"\n\t\t\t    \"command=\\\"AUTH LOGIN (username)\\\" result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse if (s->state == STATE_AUTH_PASSWORD) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command \"\n\t\t\t    \"command=\\\"AUTH LOGIN (password)\\\" result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse {\n\t\t\tstrnvis(tmp, s->cmd, sizeof tmp, VIS_SAFE | VIS_CSTYLE);\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command command=\\\"%s\\\" \"\n\t\t\t    \"result=\\\"%.*s\\\"\",\n\t\t\t    s->id, tmp, n, buf);\n\t\t}\n\t\tbreak;\n\t}\n\n\tio_xprintf(s->io, \"%s\\r\\n\", buf);\n}\n\nstatic void\nsmtp_free(struct smtp_session *s, const char * reason)\n{\n\tif (s->tx) {\n\t\tif (s->tx->msgid)\n\t\t\tsmtp_tx_rollback(s->tx);\n\t\tsmtp_tx_free(s->tx);\n\t}\n\n\tsmtp_report_link_disconnect(s);\n\tsmtp_filter_end(s);\n\n\tif (s->flags & SF_SECURE && s->listener->flags & F_SMTPS)\n\t\tstat_decrement(\"smtp.smtps\", 1);\n\tif (s->flags & SF_SECURE && s->listener->flags & F_STARTTLS)\n\t\tstat_decrement(\"smtp.tls\", 1);\n\n\tio_free(s->io);\n\tfree(s);\n\n\tsmtp_collect();\n}\n\nstatic int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t/* no user-part, reject */\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t/* no domain, local user */\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}\n\nstatic void\nsmtp_cert_init(struct smtp_session *s)\n{\n\tconst char *name;\n\tint fallback;\n\n\tif (s->listener->pki_name[0]) {\n\t\tname = s->listener->pki_name;\n\t\tfallback = 0;\n\t}\n\telse {\n\t\tname = s->smtpname;\n\t\tfallback = 1;\n\t}\n\n\tif (cert_init(name, fallback, smtp_cert_init_cb, s))\n\t\ttree_xset(&wait_ssl_init, s->id, s);\n}\n\nstatic void\nsmtp_cert_init_cb(void *arg, int status, const char *name, const void *cert,\n    size_t cert_len)\n{\n\tstruct smtp_session *s = arg;\n\tvoid *ssl, *ssl_ctx;\n\n\ttree_pop(&wait_ssl_init, s->id);\n\n\tif (status == CA_FAIL) {\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=ca-failure\",\n\t\t    s->id);\n\t\tsmtp_free(s, \"CA failure\");\n\t\treturn;\n\t}\n\n\tssl_ctx = dict_get(env->sc_ssl_dict, name);\n\tssl = ssl_smtp_init(ssl_ctx, s->listener->flags & F_TLS_VERIFY);\n\tio_set_read(s->io);\n\tio_start_tls(s->io, ssl);\n}\n\nstatic void\nsmtp_cert_verify(struct smtp_session *s)\n{\n\tconst char *name;\n\tint fallback;\n\n\tif (s->listener->ca_name[0]) {\n\t\tname = s->listener->ca_name;\n\t\tfallback = 0;\n\t}\n\telse {\n\t\tname = s->smtpname;\n\t\tfallback = 1;\n\t}\n\n\tif (cert_verify(io_tls(s->io), name, fallback, smtp_cert_verify_cb, s)) {\n\t\ttree_xset(&wait_ssl_verify, s->id, s);\n\t\tio_pause(s->io, IO_IN);\n\t}\n}\n\nstatic void\nsmtp_cert_verify_cb(void *arg, int status)\n{\n\tstruct smtp_session *s = arg;\n\tconst char *reason = NULL;\n\tint resume;\n\n\tresume = tree_pop(&wait_ssl_verify, s->id) != NULL;\n\n\tswitch (status) {\n\tcase CERT_OK:\n\t\treason = \"cert-ok\";\n\t\ts->flags |= SF_VERIFIED;\n\t\tbreak;\n\tcase CERT_NOCA:\n\t\treason = \"no-ca\";\n\t\tbreak;\n\tcase CERT_NOCERT:\n\t\treason = \"no-client-cert\";\n\t\tbreak;\n\tcase CERT_INVALID:\n\t\treason = \"cert-invalid\";\n\t\tbreak;\n\tdefault:\n\t\treason = \"cert-check-failed\";\n\t\tbreak;\n\t}\n\n\tlog_debug(\"smtp: %p: smtp_cert_verify_cb: %s\", s, reason);\n\n\tif (!(s->flags & SF_VERIFIED) && (s->listener->flags & F_TLS_VERIFY)) {\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \" reason=%s\", s->id,\n\t\t    reason);\n\t\tsmtp_free(s, \"SSL certificate check failed\");\n\t\treturn;\n\t}\n\n\tsmtp_tls_verified(s);\n\tif (resume)\n\t\tio_resume(s->io, IO_IN);\n}\n\nstatic void\nsmtp_auth_failure_resume(int fd, short event, void *p)\n{\n\tstruct smtp_session *s = p;\n\n\tsmtp_reply(s, \"535 Authentication failed\");\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_auth_failure_pause(struct smtp_session *s)\n{\n\tstruct timeval\ttv;\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = arc4random_uniform(1000000);\n\tlog_trace(TRACE_SMTP, \"smtp: timing-attack protection triggered, \"\n\t    \"will defer answer for %lu microseconds\", tv.tv_usec);\n\tevtimer_set(&s->pause, smtp_auth_failure_resume, s);\n\tevtimer_add(&s->pause, &tv);\n}\n\nstatic int\nsmtp_tx(struct smtp_session *s)\n{\n\tstruct smtp_tx *tx;\n\n\ttx = calloc(1, sizeof(*tx));\n\tif (tx == NULL)\n\t\treturn 0;\n\n\tTAILQ_INIT(&tx->rcpts);\n\n\ts->tx = tx;\n\ttx->session = s;\n\n\t/* setup the envelope */\n\ttx->evp.ss = s->ss;\n\t(void)strlcpy(tx->evp.tag, s->listener->tag, sizeof(tx->evp.tag));\n\t(void)strlcpy(tx->evp.smtpname, s->smtpname, sizeof(tx->evp.smtpname));\n\t(void)strlcpy(tx->evp.hostname, s->rdns, sizeof tx->evp.hostname);\n\t(void)strlcpy(tx->evp.helo, s->helo, sizeof(tx->evp.helo));\n\t(void)strlcpy(tx->evp.username, s->username, sizeof(tx->evp.username));\n\n\tif (s->flags & SF_BOUNCE)\n\t\ttx->evp.flags |= EF_BOUNCE;\n\tif (s->flags & SF_AUTHENTICATED)\n\t\ttx->evp.flags |= EF_AUTHENTICATED;\n\n\tif ((tx->parser = rfc5322_parser_new()) == NULL) {\n\t\tfree(tx);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nsmtp_tx_free(struct smtp_tx *tx)\n{\n\tstruct smtp_rcpt *rcpt;\n\n\trfc5322_free(tx->parser);\n\n\twhile ((rcpt = TAILQ_FIRST(&tx->rcpts))) {\n\t\tTAILQ_REMOVE(&tx->rcpts, rcpt, entry);\n\t\tfree(rcpt);\n\t}\n\n\tif (tx->ofile)\n\t\tfclose(tx->ofile);\n\n\ttx->session->tx = NULL;\n\n\tfree(tx);\n}\n\nstatic void\nsmtp_tx_mail_from(struct smtp_tx *tx, const char *line)\n{\n\tchar *opt;\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, line, sizeof tmp);\n\tcopy = tmp;  \n\n\tif (smtp_mailaddr(&tx->evp.sender, copy, 1, &copy,\n\t\ttx->session->smtpname) == 0) {\n\t\tsmtp_reply(tx->session, \"553 %s Sender address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));\n\t\tsmtp_tx_free(tx);\n\t\treturn;\n\t}\n\n\twhile ((opt = strsep(&copy, \" \"))) {\n\t\tif (*opt == '\\0')\n\t\t\tcontinue;\n\n\t\tif (strncasecmp(opt, \"AUTH=\", 5) == 0)\n\t\t\tlog_debug(\"debug: smtp: AUTH in MAIL FROM command\");\n\t\telse if (strncasecmp(opt, \"SIZE=\", 5) == 0)\n\t\t\tlog_debug(\"debug: smtp: SIZE in MAIL FROM command\");\n\t\telse if (strcasecmp(opt, \"BODY=7BIT\") == 0)\n\t\t\t/* XXX only for this transaction */\n\t\t\ttx->session->flags &= ~SF_8BITMIME;\n\t\telse if (strcasecmp(opt, \"BODY=8BITMIME\") == 0)\n\t\t\t;\n\t\telse if (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"RET=\", 4) == 0) {\n\t\t\topt += 4;\n\t\t\tif (strcasecmp(opt, \"HDRS\") == 0)\n\t\t\t\ttx->evp.dsn_ret = DSN_RETHDRS;\n\t\t\telse if (strcasecmp(opt, \"FULL\") == 0)\n\t\t\t\ttx->evp.dsn_ret = DSN_RETFULL;\n\t\t} else if (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"ENVID=\", 6) == 0) {\n\t\t\topt += 6;\n\t\t\tif (strlcpy(tx->evp.dsn_envid, opt, sizeof(tx->evp.dsn_envid))\n\t\t\t    >= sizeof(tx->evp.dsn_envid)) {\n\t\t\t\tsmtp_reply(tx->session,\n\t\t\t\t    \"503 %s %s: option too large, truncated: %s\",\n\t\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), opt);\n\t\t\t\tsmtp_tx_free(tx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tsmtp_reply(tx->session, \"503 %s %s: Unsupported option %s\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), opt);\n\t\t\tsmtp_tx_free(tx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* only check sendertable if defined and user has authenticated */\n\tif (tx->session->flags & SF_AUTHENTICATED &&\n\t    tx->session->listener->sendertable[0]) {\n\t\tm_create(p_lka, IMSG_SMTP_CHECK_SENDER, 0, 0, -1);\n\t\tm_add_id(p_lka, tx->session->id);\n\t\tm_add_string(p_lka, tx->session->listener->sendertable);\n\t\tm_add_string(p_lka, tx->session->username);\n\t\tm_add_mailaddr(p_lka, &tx->evp.sender);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_lka_mail, tx->session->id, tx->session);\n\t}\n\telse\n\t\tsmtp_tx_create_message(tx);\n}\n\nstatic void\nsmtp_tx_create_message(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_CREATE, 0, 0, -1);\n\tm_add_id(p_queue, tx->session->id);\n\tm_close(p_queue);\n\ttree_xset(&wait_queue_msg, tx->session->id, tx->session);\n}\n\nstatic void\nsmtp_tx_rcpt_to(struct smtp_tx *tx, const char *line)\n{\n\tchar *opt, *p;\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, line, sizeof tmp);\n\tcopy = tmp; \n\n\tif (tx->rcptcount >= env->sc_session_max_rcpt) {\n\t\tsmtp_reply(tx->session, \"451 %s %s: Too many recipients\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),\n\t\t    esc_description(ESC_TOO_MANY_RECIPIENTS));\n\t\treturn;\n\t}\n\n\tif (smtp_mailaddr(&tx->evp.rcpt, copy, 0, &copy,\n\t    tx->session->smtpname) == 0) {\n\t\tsmtp_reply(tx->session,\n\t\t    \"501 %s Recipient address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL,\n\t\t        ESC_BAD_DESTINATION_MAILBOX_ADDRESS_SYNTAX));\n\t\treturn;\n\t}\n\n\twhile ((opt = strsep(&copy, \" \"))) {\n\t\tif (*opt == '\\0')\n\t\t\tcontinue;\n\n\t\tif (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"NOTIFY=\", 7) == 0) {\n\t\t\topt += 7;\n\t\t\twhile ((p = strsep(&opt, \",\"))) {\n\t\t\t\tif (strcasecmp(p, \"SUCCESS\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_SUCCESS;\n\t\t\t\telse if (strcasecmp(p, \"FAILURE\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_FAILURE;\n\t\t\t\telse if (strcasecmp(p, \"DELAY\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_DELAY;\n\t\t\t\telse if (strcasecmp(p, \"NEVER\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_NEVER;\n\t\t\t}\n\n\t\t\tif (tx->evp.dsn_notify & DSN_NEVER &&\n\t\t\t    tx->evp.dsn_notify & (DSN_SUCCESS | DSN_FAILURE |\n\t\t\t    DSN_DELAY)) {\n\t\t\t\tsmtp_reply(tx->session,\n\t\t\t\t    \"553 NOTIFY option NEVER cannot be\"\n\t\t\t\t    \" combined with other options\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"ORCPT=\", 6) == 0) {\n\t\t\topt += 6;\n\t\t\tif (!text_to_mailaddr(&tx->evp.dsn_orcpt, opt)) {\n\t\t\t\tsmtp_reply(tx->session,\n\t\t\t\t    \"553 ORCPT address syntax error\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tsmtp_reply(tx->session, \"503 Unsupported option %s\", opt);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tm_create(p_lka, IMSG_SMTP_EXPAND_RCPT, 0, 0, -1);\n\tm_add_id(p_lka, tx->session->id);\n\tm_add_envelope(p_lka, &tx->evp);\n\tm_close(p_lka);\n\ttree_xset(&wait_lka_rcpt, tx->session->id, tx->session);\n}\n\nstatic void\nsmtp_tx_open_message(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_OPEN, 0, 0, -1);\n\tm_add_id(p_queue, tx->session->id);\n\tm_add_msgid(p_queue, tx->msgid);\n\tm_close(p_queue);\n\ttree_xset(&wait_queue_fd, tx->session->id, tx->session);\n}\n\nstatic void\nsmtp_tx_commit(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_COMMIT, 0, 0, -1);\n\tm_add_id(p_queue, tx->session->id);\n\tm_add_msgid(p_queue, tx->msgid);\n\tm_close(p_queue);\n\ttree_xset(&wait_queue_commit, tx->session->id, tx->session);\n\tsmtp_filter_data_end(tx->session);\n}\n\nstatic void\nsmtp_tx_rollback(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);\n\tm_add_msgid(p_queue, tx->msgid);\n\tm_close(p_queue);\n\tsmtp_report_tx_rollback(tx->session, tx->msgid);\n\tsmtp_report_tx_reset(tx->session, tx->msgid);\n\tsmtp_filter_data_end(tx->session);\n}\n\nstatic int\nsmtp_tx_dataline(struct smtp_tx *tx, const char *line)\n{\n\tstruct rfc5322_result res;\n\tint r;\n\n\tlog_trace(TRACE_SMTP, \"<<< [MSG] %s\", line);\n\n\tif (!strcmp(line, \".\")) {\n\t\tsmtp_report_protocol_client(tx->session, \".\");\n\t\tlog_trace(TRACE_SMTP, \"<<< [EOM]\");\n\t\tif (tx->error)\n\t\t\treturn 1;\n\t\tline = NULL;\n\t}\n\telse {\n\t\t/* ignore data line if an error is set */\n\t\tif (tx->error)\n\t\t\treturn 0;\n\n\t\t/* escape lines starting with a '.' */\n\t\tif (line[0] == '.')\n\t\t\tline += 1;\n\t}\n\n\tif (rfc5322_push(tx->parser, line) == -1) {\n\t\tlog_warnx(\"failed to push dataline\");\n\t\ttx->error = TX_ERROR_INTERNAL;\n\t\treturn 0;\n\t}\n\n\tfor(;;) {\n\t\tr = rfc5322_next(tx->parser, &res);\n\t\tswitch (r) {\n\t\tcase -1:\n\t\t\tif (errno == ENOMEM)\n\t\t\t\ttx->error = TX_ERROR_INTERNAL;\n\t\t\telse\n\t\t\t\ttx->error = TX_ERROR_MALFORMED;\n\t\t\treturn 0;\n\n\t\tcase RFC5322_NONE:\n\t\t\t/* Need more data */\n\t\t\treturn 0;\n\n\t\tcase RFC5322_HEADER_START:\n\t\t\t/* ignore bcc */\n\t\t\tif (!strcasecmp(\"Bcc\", res.hdr))\n\t\t\t\tcontinue;\n\n\t\t\tif (!strcasecmp(\"To\", res.hdr) ||\n\t\t\t    !strcasecmp(\"Cc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"From\", res.hdr)) {\n\t\t\t\trfc5322_unfold_header(tx->parser);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcasecmp(\"Received\", res.hdr)) {\n\t\t\t\tif (++tx->rcvcount >= MAX_HOPS_COUNT) {\n\t\t\t\t\tlog_warnx(\"warn: loop detected\");\n\t\t\t\t\ttx->error = TX_ERROR_LOOP;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!tx->has_date && !strcasecmp(\"Date\", res.hdr))\n\t\t\t\ttx->has_date = 1;\n\t\t\telse if (!tx->has_message_id &&\n\t\t\t    !strcasecmp(\"Message-Id\", res.hdr))\n\t\t\t\ttx->has_message_id = 1;\n\n\t\t\tsmtp_message_printf(tx, \"%s:%s\\n\", res.hdr, res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_HEADER_CONT:\n\n\t\t\tif (!strcasecmp(\"Bcc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"To\", res.hdr) ||\n\t\t\t    !strcasecmp(\"Cc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"From\", res.hdr))\n\t\t\t\tcontinue;\n\n\t\t\tsmtp_message_printf(tx, \"%s\\n\", res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_HEADER_END:\n\t\t\tif (!strcasecmp(\"To\", res.hdr) ||\n\t\t\t    !strcasecmp(\"Cc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"From\", res.hdr))\n\t\t\t\theader_domain_append_callback(tx, res.hdr,\n\t\t\t\t    res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_END_OF_HEADERS:\n\t\t\tif (tx->session->listener->local ||\n\t\t\t    tx->session->listener->port == 587) {\n\n\t\t\t\tif (!tx->has_date) {\n\t\t\t\t\tlog_debug(\"debug: %p: adding Date\", tx);\n\t\t\t\t\tsmtp_message_printf(tx, \"Date: %s\\n\",\n\t\t\t\t\t    time_to_text(tx->time));\n\t\t\t\t}\n\n\t\t\t\tif (!tx->has_message_id) {\n\t\t\t\t\tlog_debug(\"debug: %p: adding Message-ID\", tx);\n\t\t\t\t\tsmtp_message_printf(tx,\n\t\t\t\t\t    \"Message-ID: <%016\"PRIx64\"@%s>\\n\",\n\t\t\t\t\t    generate_uid(),\n\t\t\t\t\t    tx->session->listener->hostname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RFC5322_BODY_START:\n\t\tcase RFC5322_BODY:\n\t\t\tsmtp_message_printf(tx, \"%s\\n\", res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_END_OF_MESSAGE:\n\t\t\treturn 1;\n\n\t\tdefault:\n\t\t\tfatalx(\"%s\", __func__);\n\t\t}\n\t}\n}\n\nstatic int\nsmtp_tx_filtered_dataline(struct smtp_tx *tx, const char *line)\n{\n\tif (!strcmp(line, \".\"))\n\t\tline = NULL;\n\telse {\n\t\t/* ignore data line if an error is set */\n\t\tif (tx->error)\n\t\t\treturn 0;\n\t}\n\tio_printf(tx->filter, \"%s\\n\", line ? line : \".\");\n\treturn line ? 0 : 1;\n}\n\nstatic void\nsmtp_tx_eom(struct smtp_tx *tx)\n{\n\tsmtp_filter_phase(FILTER_COMMIT, tx->session, NULL);\n}\n\nstatic int\nsmtp_message_fd(struct smtp_tx *tx, int fd)\n{\n\tstruct smtp_session *s;\n\n\ts = tx->session;\n\n\tlog_debug(\"smtp: %p: message fd %d\", s, fd);\n\n\tif ((tx->ofile = fdopen(fd, \"w\")) == NULL) {\n\t\tclose(fd);\n\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nfilter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct smtp_tx*tx = arg;\n\tchar*line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session io (smtp): %p: %s %s\", tx, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(tx->filter, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tif (smtp_tx_dataline(tx, line)) {\n\t\t\tsmtp_tx_eom(tx);\n\t\t\treturn;\n\t\t}\n\n\t\tgoto nextline;\n\t}\n}\n\nstatic void\nsmtp_filter_fd(struct smtp_tx *tx, int fd)\n{\n\tstruct smtp_session *s;\n\n\ts = tx->session;\n\n\tlog_debug(\"smtp: %p: filter fd %d\", s, fd);\n\n\ttx->filter = io_new();\n\tio_set_fd(tx->filter, fd);\n\tio_set_callback(tx->filter, filter_session_io, tx);\n}\n\nstatic void\nsmtp_message_begin(struct smtp_tx *tx)\n{\n\tstruct smtp_session *s;\n\tX509 *x;\n\tint\t(*m_printf)(struct smtp_tx *, const char *, ...);\n\n\tm_printf = smtp_message_printf;\n\tif (tx->filter)\n\t\tm_printf = smtp_filter_printf;\n\n\ts = tx->session;\n\n\tlog_debug(\"smtp: %p: message begin\", s);\n\n\tsmtp_reply(s, \"354 Enter mail, end with \\\".\\\"\"\n\t    \" on a line by itself\");\t\n\t\n\tif (s->junk || (s->tx && s->tx->junk))\n\t\tm_printf(tx, \"X-Spam: Yes\\n\");\n\n\tm_printf(tx, \"Received: \");\n\tif (!(s->listener->flags & F_MASK_SOURCE)) {\n\t\tm_printf(tx, \"from %s (%s %s%s%s)\",\n\t\t    s->helo,\n\t\t    s->rdns,\n\t\t    s->ss.ss_family == AF_INET6 ? \"\" : \"[\",\n\t\t    ss_to_text(&s->ss),\n\t\t    s->ss.ss_family == AF_INET6 ? \"\" : \"]\");\n\t}\n\tm_printf(tx, \"\\n\\tby %s (%s) with %sSMTP%s%s id %08x\",\n\t    s->smtpname,\n\t    SMTPD_NAME,\n\t    s->flags & SF_EHLO ? \"E\" : \"\",\n\t    s->flags & SF_SECURE ? \"S\" : \"\",\n\t    s->flags & SF_AUTHENTICATED ? \"A\" : \"\",\n\t    tx->msgid);\n\n\tif (s->flags & SF_SECURE) {\n\t\tx = SSL_get_peer_certificate(io_tls(s->io));\n\t\tm_printf(tx, \" (%s:%s:%d:%s)\",\n\t\t    SSL_get_version(io_tls(s->io)),\n\t\t    SSL_get_cipher_name(io_tls(s->io)),\n\t\t    SSL_get_cipher_bits(io_tls(s->io), NULL),\n\t\t    (s->flags & SF_VERIFIED) ? \"YES\" : (x ? \"FAIL\" : \"NO\"));\n\t\tX509_free(x);\n\n\t\tif (s->listener->flags & F_RECEIVEDAUTH) {\n\t\t\tm_printf(tx, \" auth=%s\",\n\t\t\t    s->username[0] ? \"yes\" : \"no\");\n\t\t\tif (s->username[0])\n\t\t\t\tm_printf(tx, \" user=%s\", s->username);\n\t\t}\n\t}\n\n\tif (tx->rcptcount == 1) {\n\t\tm_printf(tx, \"\\n\\tfor <%s@%s>\",\n\t\t    tx->evp.rcpt.user,\n\t\t    tx->evp.rcpt.domain);\n\t}\n\n\tm_printf(tx, \";\\n\\t%s\\n\", time_to_text(time(&tx->time)));\n\n\tsmtp_enter_state(s, STATE_BODY);\n}\n\nstatic void\nsmtp_message_end(struct smtp_tx *tx)\n{\n\tstruct smtp_session *s;\n\n\ts = tx->session;\n\n\tlog_debug(\"debug: %p: end of message, error=%d\", s, tx->error);\n\n\tfclose(tx->ofile);\n\ttx->ofile = NULL;\n\n\tswitch(tx->error) {\n\tcase TX_OK:\n\t\tsmtp_tx_commit(tx);\n\t\treturn;\t\t\n\n\tcase TX_ERROR_SIZE:\n\t\tsmtp_reply(s, \"554 %s %s: Transaction failed, message too big\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_MESSAGE_TOO_BIG_FOR_SYSTEM),\n\t\t    esc_description(ESC_MESSAGE_TOO_BIG_FOR_SYSTEM));\n\t\tbreak;\n\n\tcase TX_ERROR_LOOP:\n\t\tsmtp_reply(s, \"500 %s %s: Loop detected\",\n\t\t   esc_code(ESC_STATUS_PERMFAIL, ESC_ROUTING_LOOP_DETECTED),\n\t\t   esc_description(ESC_ROUTING_LOOP_DETECTED));\n\t\tbreak;\n\n\tcase TX_ERROR_MALFORMED:\n\t\tsmtp_reply(s, \"550 %s %s: Message is not RFC 2822 compliant\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED),\n\t\t    esc_description(ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED));\n\t\tbreak;\n\n\tcase TX_ERROR_IO:\n\tcase TX_ERROR_RESOURCES:\n\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\tbreak;\n\n\tdefault:\n\t\t/* fatal? */\n\t\tsmtp_reply(s, \"421 Internal server error\");\n\t}\n\n\tsmtp_tx_rollback(tx);\n\tsmtp_tx_free(tx);\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic int\nsmtp_filter_printf(struct smtp_tx *tx, const char *fmt, ...)\n{\n\tva_list\tap;\n\tint\tlen;\n\n\tif (tx->error)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tlen = io_vprintf(tx->filter, fmt, ap);\n\tva_end(ap);\n\n\tif (len < 0) {\n\t\tlog_warn(\"smtp-in: session %016\"PRIx64\": vfprintf\", tx->session->id);\n\t\ttx->error = TX_ERROR_IO;\n\t}\n\telse\n\t\ttx->odatalen += len;\n\n\treturn len;\n}\n\nstatic int\nsmtp_message_printf(struct smtp_tx *tx, const char *fmt, ...)\n{\n\tva_list\tap;\n\tint\tlen;\n\n\tif (tx->error)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tlen = vfprintf(tx->ofile, fmt, ap);\n\tva_end(ap);\n\n\tif (len == -1) {\n\t\tlog_warn(\"smtp-in: session %016\"PRIx64\": vfprintf\", tx->session->id);\n\t\ttx->error = TX_ERROR_IO;\n\t}\n\telse\n\t\ttx->odatalen += len;\n\n\treturn len;\n}\n\n#define CASE(x) case x : return #x\n\nconst char *\nsmtp_strstate(int state)\n{\n\tstatic char\tbuf[32];\n\n\tswitch (state) {\n\tCASE(STATE_NEW);\n\tCASE(STATE_CONNECTED);\n\tCASE(STATE_TLS);\n\tCASE(STATE_HELO);\n\tCASE(STATE_AUTH_INIT);\n\tCASE(STATE_AUTH_USERNAME);\n\tCASE(STATE_AUTH_PASSWORD);\n\tCASE(STATE_AUTH_FINALIZE);\n\tCASE(STATE_BODY);\n\tCASE(STATE_QUIT);\n\tdefault:\n\t\t(void)snprintf(buf, sizeof(buf), \"STATE_??? (%d)\", state);\n\t\treturn (buf);\n\t}\n}\n\n\nstatic void\nsmtp_report_link_connect(struct smtp_session *s, const char *rdns, int fcrdns,\n    const struct sockaddr_storage *ss_src,\n    const struct sockaddr_storage *ss_dest)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_connect(\"smtp-in\", s->id, rdns, fcrdns, ss_src, ss_dest);\n}\n\nstatic void\nsmtp_report_link_greeting(struct smtp_session *s,\n    const char *domain)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_greeting(\"smtp-in\", s->id, domain);\n}\n\nstatic void\nsmtp_report_link_identify(struct smtp_session *s, const char *method, const char *identity)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_identify(\"smtp-in\", s->id, method, identity);\n}\n\nstatic void\nsmtp_report_link_tls(struct smtp_session *s, const char *ssl)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_tls(\"smtp-in\", s->id, ssl);\n}\n\nstatic void\nsmtp_report_link_disconnect(struct smtp_session *s)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_disconnect(\"smtp-in\", s->id);\n}\n\nstatic void\nsmtp_report_link_auth(struct smtp_session *s, const char *user, const char *result)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_auth(\"smtp-in\", s->id, user, result);\n}\n\nstatic void\nsmtp_report_tx_reset(struct smtp_session *s, uint32_t msgid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_reset(\"smtp-in\", s->id, msgid);\n}\n\nstatic void\nsmtp_report_tx_begin(struct smtp_session *s, uint32_t msgid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_begin(\"smtp-in\", s->id, msgid);\n}\n\nstatic void\nsmtp_report_tx_mail(struct smtp_session *s, uint32_t msgid, const char *address, int ok)\n{\n\tchar\tmailaddr[SMTPD_MAXMAILADDRSIZE];\n\tchar    *p;\n\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\tif ((p = strchr(address, '<')) == NULL)\n\t\treturn;\n\t(void)strlcpy(mailaddr, p + 1, sizeof mailaddr);\n\tif ((p = strchr(mailaddr, '>')) == NULL)\n\t\treturn;\n\t*p = '\\0';\n\n\treport_smtp_tx_mail(\"smtp-in\", s->id, msgid, mailaddr, ok);\n}\n\nstatic void\nsmtp_report_tx_rcpt(struct smtp_session *s, uint32_t msgid, const char *address, int ok)\n{\n\tchar\tmailaddr[SMTPD_MAXMAILADDRSIZE];\n\tchar    *p;\n\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\tif ((p = strchr(address, '<')) == NULL)\n\t\treturn;\n\t(void)strlcpy(mailaddr, p + 1, sizeof mailaddr);\n\tif ((p = strchr(mailaddr, '>')) == NULL)\n\t\treturn;\n\t*p = '\\0';\n\n\treport_smtp_tx_rcpt(\"smtp-in\", s->id, msgid, mailaddr, ok);\n}\n\nstatic void\nsmtp_report_tx_envelope(struct smtp_session *s, uint32_t msgid, uint64_t evpid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_envelope(\"smtp-in\", s->id, msgid, evpid);\n}\n\nstatic void\nsmtp_report_tx_data(struct smtp_session *s, uint32_t msgid, int ok)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_data(\"smtp-in\", s->id, msgid, ok);\n}\n\nstatic void\nsmtp_report_tx_commit(struct smtp_session *s, uint32_t msgid, size_t msgsz)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_commit(\"smtp-in\", s->id, msgid, msgsz);\n}\n\nstatic void\nsmtp_report_tx_rollback(struct smtp_session *s, uint32_t msgid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_rollback(\"smtp-in\", s->id, msgid);\n}\n\nstatic void\nsmtp_report_protocol_client(struct smtp_session *s, const char *command)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_protocol_client(\"smtp-in\", s->id, command);\n}\n\nstatic void\nsmtp_report_protocol_server(struct smtp_session *s, const char *response)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_protocol_server(\"smtp-in\", s->id, response);\n}\n\nstatic void\nsmtp_report_filter_response(struct smtp_session *s, int phase, int response, const char *param)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_filter_response(\"smtp-in\", s->id, phase, response, param);\n}\n\nstatic void\nsmtp_report_timeout(struct smtp_session *s)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_timeout(\"smtp-in\", s->id);\n}\n"], "fixing_code": ["/*\t$OpenBSD: smtp_session.c,v 1.422 2020/01/28 21:35:00 gilles Exp $\t*/\n\n/*\n * Copyright (c) 2008 Gilles Chehade <gilles@poolp.org>\n * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@openbsd.org>\n * Copyright (c) 2008-2009 Jacek Masiulaniec <jacekm@dobremiasto.net>\n * Copyright (c) 2012 Eric Faurot <eric@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n\n#include <netinet/in.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <event.h>\n#include <imsg.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <openssl/ssl.h>\n#include <resolv.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <vis.h>\n\n#include \"smtpd.h\"\n#include \"log.h\"\n#include \"ssl.h\"\n#include \"rfc5322.h\"\n\n#define\tSMTP_LINE_MAX\t\t\t65535\n#define\tDATA_HIWAT\t\t\t65535\n#define\tAPPEND_DOMAIN_BUFFER_SIZE\tSMTP_LINE_MAX\n\nenum smtp_state {\n\tSTATE_NEW = 0,\n\tSTATE_CONNECTED,\n\tSTATE_TLS,\n\tSTATE_HELO,\n\tSTATE_AUTH_INIT,\n\tSTATE_AUTH_USERNAME,\n\tSTATE_AUTH_PASSWORD,\n\tSTATE_AUTH_FINALIZE,\n\tSTATE_BODY,\n\tSTATE_QUIT,\n};\n\nenum session_flags {\n\tSF_EHLO\t\t\t= 0x0001,\n\tSF_8BITMIME\t\t= 0x0002,\n\tSF_SECURE\t\t= 0x0004,\n\tSF_AUTHENTICATED\t= 0x0008,\n\tSF_BOUNCE\t\t= 0x0010,\n\tSF_VERIFIED\t\t= 0x0020,\n\tSF_BADINPUT\t\t= 0x0080,\n};\n\nenum {\n\tTX_OK = 0,\n\tTX_ERROR_ENVELOPE,\n\tTX_ERROR_SIZE,\n\tTX_ERROR_IO,\n\tTX_ERROR_LOOP,\n\tTX_ERROR_MALFORMED,\n\tTX_ERROR_RESOURCES,\n\tTX_ERROR_INTERNAL,\n};\n\nenum smtp_command {\n\tCMD_HELO = 0,\n\tCMD_EHLO,\n\tCMD_STARTTLS,\n\tCMD_AUTH,\n\tCMD_MAIL_FROM,\n\tCMD_RCPT_TO,\n\tCMD_DATA,\n\tCMD_RSET,\n\tCMD_QUIT,\n\tCMD_HELP,\n\tCMD_WIZ,\n\tCMD_NOOP,\n\tCMD_COMMIT,\n};\n\nstruct smtp_rcpt {\n\tTAILQ_ENTRY(smtp_rcpt)\t entry;\n\tuint64_t\t\t evpid;\n \tstruct mailaddr\t\t maddr;\n\tsize_t\t\t\t destcount;\n};\n\nstruct smtp_tx {\n\tstruct smtp_session\t*session;\n\tuint32_t\t\t msgid;\n\n\tstruct envelope\t\t evp;\n\tsize_t\t\t\t rcptcount;\n\tsize_t\t\t\t destcount;\n\tTAILQ_HEAD(, smtp_rcpt)\t rcpts;\n\n\ttime_t\t\t\t time;\n\tint\t\t\t error;\n\tsize_t\t\t\t datain;\n\tsize_t\t\t\t odatalen;\n\tFILE\t\t\t*ofile;\n\tstruct io\t\t*filter;\n\tstruct rfc5322_parser\t*parser;\n\tint\t\t\t rcvcount;\n\tint\t\t\t has_date;\n\tint\t\t\t has_message_id;\n\n\tuint8_t\t\t\t junk;\n};\n\nstruct smtp_session {\n\tuint64_t\t\t id;\n\tstruct io\t\t*io;\n\tstruct listener\t\t*listener;\n\tvoid\t\t\t*ssl_ctx;\n\tstruct sockaddr_storage\t ss;\n\tchar\t\t\t rdns[HOST_NAME_MAX+1];\n\tchar\t\t\t smtpname[HOST_NAME_MAX+1];\n\tint\t\t\t fcrdns;\n\n\tint\t\t\t flags;\n\tenum smtp_state\t\t state;\n\n\tuint8_t\t\t\t banner_sent;\n\tchar\t\t\t helo[LINE_MAX];\n\tchar\t\t\t cmd[LINE_MAX];\n\tchar\t\t\t username[SMTPD_MAXMAILADDRSIZE];\n\n\tsize_t\t\t\t mailcount;\n\tstruct event\t\t pause;\n\n\tstruct smtp_tx\t\t*tx;\n\n\tenum smtp_command\t last_cmd;\n\tenum filter_phase\t filter_phase;\n\tconst char\t\t*filter_param;\n\n\tuint8_t\t\t\t junk;\n};\n\n#define ADVERTISE_TLS(s) \\\n\t((s)->listener->flags & F_STARTTLS && !((s)->flags & SF_SECURE))\n\n#define ADVERTISE_AUTH(s) \\\n\t((s)->listener->flags & F_AUTH && (s)->flags & SF_SECURE && \\\n\t !((s)->flags & SF_AUTHENTICATED))\n\n#define ADVERTISE_EXT_DSN(s) \\\n\t((s)->listener->flags & F_EXT_DSN)\n\n#define\tSESSION_FILTERED(s) \\\n\t((s)->listener->flags & F_FILTERED)\n\n#define\tSESSION_DATA_FILTERED(s) \\\n\t((s)->listener->flags & F_FILTERED)\n\n\nstatic int smtp_mailaddr(struct mailaddr *, char *, int, char **, const char *);\nstatic void smtp_session_init(void);\nstatic void smtp_lookup_servername(struct smtp_session *);\nstatic void smtp_getnameinfo_cb(void *, int, const char *, const char *);\nstatic void smtp_getaddrinfo_cb(void *, int, struct addrinfo *);\nstatic void smtp_connected(struct smtp_session *);\nstatic void smtp_send_banner(struct smtp_session *);\nstatic void smtp_tls_verified(struct smtp_session *);\nstatic void smtp_io(struct io *, int, void *);\nstatic void smtp_enter_state(struct smtp_session *, int);\nstatic void smtp_reply(struct smtp_session *, char *, ...);\nstatic void smtp_command(struct smtp_session *, char *);\nstatic void smtp_rfc4954_auth_plain(struct smtp_session *, char *);\nstatic void smtp_rfc4954_auth_login(struct smtp_session *, char *);\nstatic void smtp_free(struct smtp_session *, const char *);\nstatic const char *smtp_strstate(int);\nstatic void smtp_cert_init(struct smtp_session *);\nstatic void smtp_cert_init_cb(void *, int, const char *, const void *, size_t);\nstatic void smtp_cert_verify(struct smtp_session *);\nstatic void smtp_cert_verify_cb(void *, int);\nstatic void smtp_auth_failure_pause(struct smtp_session *);\nstatic void smtp_auth_failure_resume(int, short, void *);\n\nstatic int  smtp_tx(struct smtp_session *);\nstatic void smtp_tx_free(struct smtp_tx *);\nstatic void smtp_tx_create_message(struct smtp_tx *);\nstatic void smtp_tx_mail_from(struct smtp_tx *, const char *);\nstatic void smtp_tx_rcpt_to(struct smtp_tx *, const char *);\nstatic void smtp_tx_open_message(struct smtp_tx *);\nstatic void smtp_tx_commit(struct smtp_tx *);\nstatic void smtp_tx_rollback(struct smtp_tx *);\nstatic int  smtp_tx_dataline(struct smtp_tx *, const char *);\nstatic int  smtp_tx_filtered_dataline(struct smtp_tx *, const char *);\nstatic void smtp_tx_eom(struct smtp_tx *);\nstatic void smtp_filter_fd(struct smtp_tx *, int);\nstatic int  smtp_message_fd(struct smtp_tx *, int);\nstatic void smtp_message_begin(struct smtp_tx *);\nstatic void smtp_message_end(struct smtp_tx *);\nstatic int  smtp_filter_printf(struct smtp_tx *, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nstatic int  smtp_message_printf(struct smtp_tx *, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\n\nstatic int  smtp_check_rset(struct smtp_session *, const char *);\nstatic int  smtp_check_helo(struct smtp_session *, const char *);\nstatic int  smtp_check_ehlo(struct smtp_session *, const char *);\nstatic int  smtp_check_auth(struct smtp_session *s, const char *);\nstatic int  smtp_check_starttls(struct smtp_session *, const char *);\nstatic int  smtp_check_mail_from(struct smtp_session *, const char *);\nstatic int  smtp_check_rcpt_to(struct smtp_session *, const char *);\nstatic int  smtp_check_data(struct smtp_session *, const char *);\nstatic int  smtp_check_noparam(struct smtp_session *, const char *);\n\nstatic void smtp_filter_phase(enum filter_phase, struct smtp_session *, const char *);\n\nstatic void smtp_proceed_connected(struct smtp_session *);\nstatic void smtp_proceed_rset(struct smtp_session *, const char *);\nstatic void smtp_proceed_helo(struct smtp_session *, const char *);\nstatic void smtp_proceed_ehlo(struct smtp_session *, const char *);\nstatic void smtp_proceed_auth(struct smtp_session *, const char *);\nstatic void smtp_proceed_starttls(struct smtp_session *, const char *);\nstatic void smtp_proceed_mail_from(struct smtp_session *, const char *);\nstatic void smtp_proceed_rcpt_to(struct smtp_session *, const char *);\nstatic void smtp_proceed_data(struct smtp_session *, const char *);\nstatic void smtp_proceed_noop(struct smtp_session *, const char *);\nstatic void smtp_proceed_help(struct smtp_session *, const char *);\nstatic void smtp_proceed_wiz(struct smtp_session *, const char *);\nstatic void smtp_proceed_quit(struct smtp_session *, const char *);\nstatic void smtp_proceed_commit(struct smtp_session *, const char *);\nstatic void smtp_proceed_rollback(struct smtp_session *, const char *);\n\nstatic void smtp_filter_begin(struct smtp_session *);\nstatic void smtp_filter_end(struct smtp_session *);\nstatic void smtp_filter_data_begin(struct smtp_session *);\nstatic void smtp_filter_data_end(struct smtp_session *);\n\nstatic void smtp_report_link_connect(struct smtp_session *, const char *, int,\n    const struct sockaddr_storage *,\n    const struct sockaddr_storage *);\nstatic void smtp_report_link_greeting(struct smtp_session *, const char *);\nstatic void smtp_report_link_identify(struct smtp_session *, const char *, const char *);\nstatic void smtp_report_link_tls(struct smtp_session *, const char *);\nstatic void smtp_report_link_disconnect(struct smtp_session *);\nstatic void smtp_report_link_auth(struct smtp_session *, const char *, const char *);\nstatic void smtp_report_tx_reset(struct smtp_session *, uint32_t);\nstatic void smtp_report_tx_begin(struct smtp_session *, uint32_t);\nstatic void smtp_report_tx_mail(struct smtp_session *, uint32_t, const char *, int);\nstatic void smtp_report_tx_rcpt(struct smtp_session *, uint32_t, const char *, int);\nstatic void smtp_report_tx_envelope(struct smtp_session *, uint32_t, uint64_t);\nstatic void smtp_report_tx_data(struct smtp_session *, uint32_t, int);\nstatic void smtp_report_tx_commit(struct smtp_session *, uint32_t, size_t);\nstatic void smtp_report_tx_rollback(struct smtp_session *, uint32_t);\nstatic void smtp_report_protocol_client(struct smtp_session *, const char *);\nstatic void smtp_report_protocol_server(struct smtp_session *, const char *);\nstatic void smtp_report_filter_response(struct smtp_session *, int, int, const char *);\nstatic void smtp_report_timeout(struct smtp_session *);\n\n\nstatic struct {\n\tint code;\n\tenum filter_phase filter_phase;\n\tconst char *cmd;\n\n\tint (*check)(struct smtp_session *, const char *);\n\tvoid (*proceed)(struct smtp_session *, const char *);\n} commands[] = {\n\t{ CMD_HELO,             FILTER_HELO,            \"HELO\",         smtp_check_helo,        smtp_proceed_helo },\n\t{ CMD_EHLO,             FILTER_EHLO,            \"EHLO\",         smtp_check_ehlo,        smtp_proceed_ehlo },\n\t{ CMD_STARTTLS,         FILTER_STARTTLS,        \"STARTTLS\",     smtp_check_starttls,    smtp_proceed_starttls },\n\t{ CMD_AUTH,             FILTER_AUTH,            \"AUTH\",         smtp_check_auth,        smtp_proceed_auth },\n\t{ CMD_MAIL_FROM,        FILTER_MAIL_FROM,       \"MAIL FROM\",    smtp_check_mail_from,   smtp_proceed_mail_from },\n\t{ CMD_RCPT_TO,          FILTER_RCPT_TO,         \"RCPT TO\",      smtp_check_rcpt_to,     smtp_proceed_rcpt_to },\n\t{ CMD_DATA,             FILTER_DATA,            \"DATA\",         smtp_check_data,        smtp_proceed_data },\n\t{ CMD_RSET,             FILTER_RSET,            \"RSET\",         smtp_check_rset,        smtp_proceed_rset },\n\t{ CMD_QUIT,             FILTER_QUIT,            \"QUIT\",         smtp_check_noparam,     smtp_proceed_quit },\n\t{ CMD_NOOP,             FILTER_NOOP,            \"NOOP\",         smtp_check_noparam,     smtp_proceed_noop },\n\t{ CMD_HELP,             FILTER_HELP,            \"HELP\",         smtp_check_noparam,     smtp_proceed_help },\n\t{ CMD_WIZ,              FILTER_WIZ,             \"WIZ\",          smtp_check_noparam,     smtp_proceed_wiz },\n\t{ CMD_COMMIT,  \t\tFILTER_COMMIT,\t\t\".\",\t\tsmtp_check_noparam,\tsmtp_proceed_commit },\n\t{ -1,                   0,                      NULL,           NULL },\n};\n\nstatic struct tree wait_lka_helo;\nstatic struct tree wait_lka_mail;\nstatic struct tree wait_lka_rcpt;\nstatic struct tree wait_parent_auth;\nstatic struct tree wait_queue_msg;\nstatic struct tree wait_queue_fd;\nstatic struct tree wait_queue_commit;\nstatic struct tree wait_ssl_init;\nstatic struct tree wait_ssl_verify;\nstatic struct tree wait_filters;\nstatic struct tree wait_filter_fd;\n\nstatic void\nheader_append_domain_buffer(char *buffer, char *domain, size_t len)\n{\n\tsize_t\ti;\n\tint\tescape, quote, comment, bracket;\n\tint\thas_domain, has_bracket, has_group;\n\tint\tpos_bracket, pos_component, pos_insert;\n\tchar\tcopy[APPEND_DOMAIN_BUFFER_SIZE];\n\n\tescape = quote = comment = bracket = 0;\n\thas_domain = has_bracket = has_group = 0;\n\tpos_bracket = pos_insert = pos_component = 0;\n\tfor (i = 0; buffer[i]; ++i) {\n\t\tif (buffer[i] == '(' && !escape && !quote)\n\t\t\tcomment++;\n\t\tif (buffer[i] == '\"' && !escape && !comment)\n\t\t\tquote = !quote;\n\t\tif (buffer[i] == ')' && !escape && !quote && comment)\n\t\t\tcomment--;\n\t\tif (buffer[i] == '\\\\' && !escape && !comment && !quote)\n\t\t\tescape = 1;\n\t\telse\n\t\t\tescape = 0;\n\t\tif (buffer[i] == '<' && !escape && !comment && !quote && !bracket) {\n\t\t\tbracket++;\n\t\t\thas_bracket = 1;\n\t\t}\n\t\tif (buffer[i] == '>' && !escape && !comment && !quote && bracket) {\n\t\t\tbracket--;\n\t\t\tpos_bracket = i;\n\t\t}\n\t\tif (buffer[i] == '@' && !escape && !comment && !quote)\n\t\t\thas_domain = 1;\n\t\tif (buffer[i] == ':' && !escape && !comment && !quote)\n\t\t\thas_group = 1;\n\n\t\t/* update insert point if not in comment and not on a whitespace */\n\t\tif (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))\n\t\t\tpos_component = i;\n\t}\n\n\t/* parse error, do not attempt to modify */\n\tif (escape || quote || comment || bracket)\n\t\treturn;\n\n\t/* domain already present, no need to modify */\n\tif (has_domain)\n\t\treturn;\n\n\t/* address is group, skip */\n\tif (has_group)\n\t\treturn;\n\n\t/* there's an address between brackets, just append domain */\n\tif (has_bracket) {\n\t\tpos_bracket--;\n\t\twhile (isspace((unsigned char)buffer[pos_bracket]))\n\t\t\tpos_bracket--;\n\t\tif (buffer[pos_bracket] == '<')\n\t\t\treturn;\n\t\tpos_insert = pos_bracket + 1;\n\t}\n\telse {\n\t\t/* otherwise append address to last component */\n\t\tpos_insert = pos_component + 1;\n\n\t\t/* empty address */\n                if (buffer[pos_component] == '\\0' ||\n\t\t    isspace((unsigned char)buffer[pos_component]))\n                        return;\n\t}\n\n\tif (snprintf(copy, sizeof copy, \"%.*s@%s%s\",\n\t\t(int)pos_insert, buffer,\n\t\tdomain,\n\t\tbuffer+pos_insert) >= (int)sizeof copy)\n\t\treturn;\n\n\tmemcpy(buffer, copy, len);\n}\n\nstatic void\nheader_address_rewrite_buffer(char *buffer, const char *address, size_t len)\n{\n\tsize_t\ti;\n\tint\taddress_len;\n\tint\tescape, quote, comment, bracket;\n\tint\thas_bracket, has_group;\n\tint\tpos_bracket_beg, pos_bracket_end, pos_component_beg, pos_component_end;\n\tint\tinsert_beg, insert_end;\n\tchar\tcopy[APPEND_DOMAIN_BUFFER_SIZE];\n\n\tescape = quote = comment = bracket = 0;\n\thas_bracket = has_group = 0;\n\tpos_bracket_beg = pos_bracket_end = pos_component_beg = pos_component_end = 0;\n\tfor (i = 0; buffer[i]; ++i) {\n\t\tif (buffer[i] == '(' && !escape && !quote)\n\t\t\tcomment++;\n\t\tif (buffer[i] == '\"' && !escape && !comment)\n\t\t\tquote = !quote;\n\t\tif (buffer[i] == ')' && !escape && !quote && comment)\n\t\t\tcomment--;\n\t\tif (buffer[i] == '\\\\' && !escape && !comment && !quote)\n\t\t\tescape = 1;\n\t\telse\n\t\t\tescape = 0;\n\t\tif (buffer[i] == '<' && !escape && !comment && !quote && !bracket) {\n\t\t\tbracket++;\n\t\t\thas_bracket = 1;\n\t\t\tpos_bracket_beg = i+1;\n\t\t}\n\t\tif (buffer[i] == '>' && !escape && !comment && !quote && bracket) {\n\t\t\tbracket--;\n\t\t\tpos_bracket_end = i;\n\t\t}\n\t\tif (buffer[i] == ':' && !escape && !comment && !quote)\n\t\t\thas_group = 1;\n\n\t\t/* update insert point if not in comment and not on a whitespace */\n\t\tif (!comment && buffer[i] != ')' && !isspace((unsigned char)buffer[i]))\n\t\t\tpos_component_end = i;\n\t}\n\n\t/* parse error, do not attempt to modify */\n\tif (escape || quote || comment || bracket)\n\t\treturn;\n\n\t/* address is group, skip */\n\tif (has_group)\n\t\treturn;\n\n\t/* there's an address between brackets, just replace everything brackets */\n\tif (has_bracket) {\n\t\tinsert_beg = pos_bracket_beg;\n\t\tinsert_end = pos_bracket_end;\n\t}\n\telse {\n\t\tif (pos_component_end == 0)\n\t\t\tpos_component_beg = 0;\n\t\telse {\n\t\t\tfor (pos_component_beg = pos_component_end; pos_component_beg >= 0; --pos_component_beg)\n\t\t\t\tif (buffer[pos_component_beg] == ')' || isspace(buffer[pos_component_beg]))\n\t\t\t\t\tbreak;\n\t\t\tpos_component_beg += 1;\n\t\t\tpos_component_end += 1;\n\t\t}\n\t\tinsert_beg = pos_component_beg;\n\t\tinsert_end = pos_component_end;\n\t}\n\n\t/* check that masquerade won' t overflow */\n\taddress_len = strlen(address);\n\tif (strlen(buffer) - (insert_end - insert_beg) + address_len >= len)\n\t\treturn;\n\n\t(void)strlcpy(copy, buffer, sizeof copy);\n\t(void)strlcpy(copy+insert_beg, address, sizeof (copy) - insert_beg);\n\t(void)strlcat(copy, buffer+insert_end, sizeof (copy));\n\tmemcpy(buffer, copy, len);\n}\n\nstatic void\nheader_domain_append_callback(struct smtp_tx *tx, const char *hdr,\n    const char *val)\n{\n\tsize_t\t\t\ti, j, linelen;\n\tint\t\t\tescape, quote, comment, skip;\n\tchar\t\t\tbuffer[APPEND_DOMAIN_BUFFER_SIZE];\n\tconst char *line, *end;\n\n\tif (smtp_message_printf(tx, \"%s:\", hdr) == -1)\n\t\treturn;\n\n\tj = 0;\n\tescape = quote = comment = skip = 0;\n\tmemset(buffer, 0, sizeof buffer);\n\n\tfor (line = val; line; line = end) {\n\t\tend = strchr(line, '\\n');\n\t\tif (end) {\n\t\t\tlinelen = end - line;\n\t\t\tend++;\n\t\t}\n\t\telse\n\t\t\tlinelen = strlen(line);\n\n\t\tfor (i = 0; i < linelen; ++i) {\n\t\t\tif (line[i] == '(' && !escape && !quote)\n\t\t\t\tcomment++;\n\t\t\tif (line[i] == '\"' && !escape && !comment)\n\t\t\t\tquote = !quote;\n\t\t\tif (line[i] == ')' && !escape && !quote && comment)\n\t\t\t\tcomment--;\n\t\t\tif (line[i] == '\\\\' && !escape && !comment && !quote)\n\t\t\t\tescape = 1;\n\t\t\telse\n\t\t\t\tescape = 0;\n\n\t\t\t/* found a separator, buffer contains a full address */\n\t\t\tif (line[i] == ',' && !escape && !quote && !comment) {\n\t\t\t\tif (!skip && j + strlen(tx->session->listener->hostname) + 1 < sizeof buffer) {\n\t\t\t\t\theader_append_domain_buffer(buffer, tx->session->listener->hostname, sizeof buffer);\n\t\t\t\t\tif (tx->session->flags & SF_AUTHENTICATED &&\n\t\t\t\t\t    tx->session->listener->sendertable[0] &&\n\t\t\t\t\t    tx->session->listener->flags & F_MASQUERADE &&\n\t\t\t\t\t    !(strcasecmp(hdr, \"From\")))\n\t\t\t\t\t\theader_address_rewrite_buffer(buffer, mailaddr_to_text(&tx->evp.sender),\n\t\t\t\t\t\t    sizeof buffer);\n\t\t\t\t}\n\t\t\t\tif (smtp_message_printf(tx, \"%s,\", buffer) == -1)\n\t\t\t\t\treturn;\n\t\t\t\tj = 0;\n\t\t\t\tskip = 0;\n\t\t\t\tmemset(buffer, 0, sizeof buffer);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (skip) {\n\t\t\t\t\tif (smtp_message_printf(tx, \"%c\", line[i]) == -1)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer[j++] = line[i];\n\t\t\t\t\tif (j == sizeof (buffer) - 1) {\n\t\t\t\t\t\tif (smtp_message_printf(tx, \"%s\", buffer) == -1)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tskip = 1;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tmemset(buffer, 0, sizeof buffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (skip) {\n\t\t\tif (smtp_message_printf(tx, \"\\n\") == -1)\n\t\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tbuffer[j++] = '\\n';\n\t\t\tif (j == sizeof (buffer) - 1) {\n\t\t\t\tif (smtp_message_printf(tx, \"%s\", buffer) == -1)\n\t\t\t\t\treturn;\n\t\t\t\tskip = 1;\n\t\t\t\tj = 0;\n\t\t\t\tmemset(buffer, 0, sizeof buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* end of header, if buffer is not empty we'll process it */\n\tif (buffer[0]) {\n\t\tif (j + strlen(tx->session->listener->hostname) + 1 < sizeof buffer) {\n\t\t\theader_append_domain_buffer(buffer, tx->session->listener->hostname, sizeof buffer);\n\t\t\tif (tx->session->flags & SF_AUTHENTICATED &&\n\t\t\t    tx->session->listener->sendertable[0] &&\n\t\t\t    tx->session->listener->flags & F_MASQUERADE &&\n\t\t\t    !(strcasecmp(hdr, \"From\")))\n\t\t\t\theader_address_rewrite_buffer(buffer, mailaddr_to_text(&tx->evp.sender),\n\t\t\t\t    sizeof buffer);\n\t\t}\n\t\tsmtp_message_printf(tx, \"%s\", buffer);\n\t}\n}\n\nstatic void\nsmtp_session_init(void)\n{\n\tstatic int\tinit = 0;\n\n\tif (!init) {\n\t\ttree_init(&wait_lka_helo);\n\t\ttree_init(&wait_lka_mail);\n\t\ttree_init(&wait_lka_rcpt);\n\t\ttree_init(&wait_parent_auth);\n\t\ttree_init(&wait_queue_msg);\n\t\ttree_init(&wait_queue_fd);\n\t\ttree_init(&wait_queue_commit);\n\t\ttree_init(&wait_ssl_init);\n\t\ttree_init(&wait_ssl_verify);\n\t\ttree_init(&wait_filters);\n\t\ttree_init(&wait_filter_fd);\n\t\tinit = 1;\n\t}\n}\n\nint\nsmtp_session(struct listener *listener, int sock,\n    const struct sockaddr_storage *ss, const char *hostname, struct io *io)\n{\n\tstruct smtp_session\t*s;\n\n\tsmtp_session_init();\n\n\tif ((s = calloc(1, sizeof(*s))) == NULL)\n\t\treturn (-1);\n\n\ts->id = generate_uid();\n\ts->listener = listener;\n\tmemmove(&s->ss, ss, sizeof(*ss));\n\n\tif (io != NULL)\n\t\ts->io = io;\n\telse\n\t\ts->io = io_new();\n\n\tio_set_callback(s->io, smtp_io, s);\n\tio_set_fd(s->io, sock);\n\tio_set_timeout(s->io, SMTPD_SESSION_TIMEOUT * 1000);\n\tio_set_write(s->io);\n\ts->state = STATE_NEW;\n\n\t(void)strlcpy(s->smtpname, listener->hostname, sizeof(s->smtpname));\n\n\tlog_trace(TRACE_SMTP, \"smtp: %p: connected to listener %p \"\n\t    \"[hostname=%s, port=%d, tag=%s]\", s, listener,\n\t    listener->hostname, ntohs(listener->port), listener->tag);\n\n\t/* For local enqueueing, the hostname is already set */\n\tif (hostname) {\n\t\ts->flags |= SF_AUTHENTICATED;\n\t\t/* A bit of a hack */\n\t\tif (!strcmp(hostname, \"localhost\"))\n\t\t\ts->flags |= SF_BOUNCE;\n\t\t(void)strlcpy(s->rdns, hostname, sizeof(s->rdns));\n\t\ts->fcrdns = 1;\n\t\tsmtp_lookup_servername(s);\n\t} else {\n\t\tresolver_getnameinfo((struct sockaddr *)&s->ss, NI_NAMEREQD,\n\t\t    smtp_getnameinfo_cb, s);\n\t}\n\n\t/* session may have been freed by now */\n\n\treturn (0);\n}\n\nstatic void\nsmtp_getnameinfo_cb(void *arg, int gaierrno, const char *host, const char *serv)\n{\n\tstruct smtp_session *s = arg;\n\tstruct addrinfo hints;\n\n\tif (gaierrno) {\n\t\t(void)strlcpy(s->rdns, \"<unknown>\", sizeof(s->rdns));\n\n\t\tif (gaierrno == EAI_NODATA || gaierrno == EAI_NONAME)\n\t\t\ts->fcrdns = 0;\n\t\telse {\n\t\t\tlog_warnx(\"getnameinfo: %s: %s\", ss_to_text(&s->ss),\n\t\t\t    gai_strerror(gaierrno));\n\t\t\ts->fcrdns = -1;\n\t\t}\n\n\t\tsmtp_lookup_servername(s);\n\t\treturn;\n\t}\n\n\t(void)strlcpy(s->rdns, host, sizeof(s->rdns));\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = s->ss.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tresolver_getaddrinfo(s->rdns, NULL, &hints, smtp_getaddrinfo_cb, s);\n}\n\nstatic void\nsmtp_getaddrinfo_cb(void *arg, int gaierrno, struct addrinfo *ai0)\n{\n\tstruct smtp_session *s = arg;\n\tstruct addrinfo *ai;\n\tchar fwd[64], rev[64];\n\n\tif (gaierrno) {\n\t\tif (gaierrno == EAI_NODATA || gaierrno == EAI_NONAME)\n\t\t\ts->fcrdns = 0;\n\t\telse {\n\t\t\tlog_warnx(\"getaddrinfo: %s: %s\", s->rdns,\n\t\t\t    gai_strerror(gaierrno));\n\t\t\ts->fcrdns = -1;\n\t\t}\n\t}\n\telse {\n\t\tstrlcpy(rev, ss_to_text(&s->ss), sizeof(rev));\n\t\tfor (ai = ai0; ai; ai = ai->ai_next) {\n\t\t\tstrlcpy(fwd, sa_to_text(ai->ai_addr), sizeof(fwd));\n\t\t\tif (!strcmp(fwd, rev)) {\n\t\t\t\ts->fcrdns = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(ai0);\n\t}\n\n\tsmtp_lookup_servername(s);\n}\n\nvoid\nsmtp_session_imsg(struct mproc *p, struct imsg *imsg)\n{\n\tstruct smtp_session\t\t*s;\n\tstruct smtp_rcpt\t\t*rcpt;\n\tchar\t\t\t\t user[SMTPD_MAXMAILADDRSIZE];\n\tchar\t\t\t\t tmp[SMTP_LINE_MAX];\n\tstruct msg\t\t\t m;\n\tconst char\t\t\t*line, *helo;\n\tuint64_t\t\t\t reqid, evpid;\n\tuint32_t\t\t\t msgid;\n\tint\t\t\t\t status, success;\n\tint                              filter_response;\n\tconst char                      *filter_param;\n\tuint8_t                          i;\n\n\tswitch (imsg->hdr.type) {\n\n\tcase IMSG_SMTP_CHECK_SENDER:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &status);\n\t\tm_end(&m);\n\t\ts = tree_xpop(&wait_lka_mail, reqid);\n\t\tswitch (status) {\n\t\tcase LKA_OK:\n\t\t\tsmtp_tx_create_message(s->tx);\n\t\t\tbreak;\n\n\t\tcase LKA_PERMFAIL:\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_reply(s, \"%d %s\", 530, \"Sender rejected\");\n\t\t\tbreak;\n\t\tcase LKA_TEMPFAIL:\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\n\tcase IMSG_SMTP_EXPAND_RCPT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &status);\n\t\tm_get_string(&m, &line);\n\t\tm_end(&m);\n\t\ts = tree_xpop(&wait_lka_rcpt, reqid);\n\n\t\ttmp[0] = '\\0';\n\t\tif (s->tx->evp.rcpt.user[0]) {\n\t\t\t(void)strlcpy(tmp, s->tx->evp.rcpt.user, sizeof tmp);\n\t\t\tif (s->tx->evp.rcpt.domain[0]) {\n\t\t\t\t(void)strlcat(tmp, \"@\", sizeof tmp);\n\t\t\t\t(void)strlcat(tmp, s->tx->evp.rcpt.domain,\n\t\t\t\t    sizeof tmp);\n\t\t\t}\n\t\t}\n\n\t\tswitch (status) {\n\t\tcase LKA_OK:\n\t\t\tfatalx(\"unexpected ok\");\n\t\tcase LKA_PERMFAIL:\n\t\t\tsmtp_reply(s, \"%s: <%s>\", line, tmp);\n\t\t\tbreak;\n\t\tcase LKA_TEMPFAIL:\n\t\t\tsmtp_reply(s, \"%s: <%s>\", line, tmp);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\n\tcase IMSG_SMTP_LOOKUP_HELO:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\ts = tree_xpop(&wait_lka_helo, reqid);\n\t\tm_get_int(&m, &status);\n\t\tif (status == LKA_OK) {\n\t\t\tm_get_string(&m, &helo);\n\t\t\t(void)strlcpy(s->smtpname, helo, sizeof(s->smtpname));\n\t\t}\n\t\tm_end(&m);\n\t\tsmtp_connected(s);\n\t\treturn;\n\n\tcase IMSG_SMTP_MESSAGE_CREATE:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\ts = tree_xpop(&wait_queue_msg, reqid);\n\t\tif (success) {\n\t\t\tm_get_msgid(&m, &msgid);\n\t\t\ts->tx->msgid = msgid;\n\t\t\ts->tx->evp.id = msgid_to_evpid(msgid);\n\t\t\ts->tx->rcptcount = 0;\n\t\t\tsmtp_reply(s, \"250 %s Ok\",\n\t\t\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\t\t} else {\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t}\n\t\tm_end(&m);\n\t\treturn;\n\n\tcase IMSG_SMTP_MESSAGE_OPEN:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_queue_fd, reqid);\n\t\tif (!success || imsg->fd == -1) {\n\t\t\tif (imsg->fd != -1)\n\t\t\t\tclose(imsg->fd);\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(\"smtp: %p: fd %d from queue\", s, imsg->fd);\n\n\t\tif (smtp_message_fd(s->tx, imsg->fd)) {\n\t\t\tif (!SESSION_DATA_FILTERED(s))\n\t\t\t\tsmtp_message_begin(s->tx);\n\t\t\telse\n\t\t\t\tsmtp_filter_data_begin(s);\n\t\t}\n\t\treturn;\n\n\tcase IMSG_FILTER_SMTP_DATA_BEGIN:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_filter_fd, reqid);\n\t\tif (!success || imsg->fd == -1) {\n\t\t\tif (imsg->fd != -1)\n\t\t\t\tclose(imsg->fd);\n\t\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\treturn;\n\t\t}\n\n\t\tlog_debug(\"smtp: %p: fd %d from lka\", s, imsg->fd);\n\n\t\tsmtp_filter_fd(s->tx, imsg->fd);\n\t\tsmtp_message_begin(s->tx);\n\t\treturn;\n\n\tcase IMSG_QUEUE_ENVELOPE_SUBMIT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\ts = tree_xget(&wait_lka_rcpt, reqid);\n\t\tif (success) {\n\t\t\tm_get_evpid(&m, &evpid);\n\t\t\ts->tx->evp.id = evpid;\n\t\t\ts->tx->destcount++;\n\t\t\tsmtp_report_tx_envelope(s, s->tx->msgid, evpid);\n\t\t}\n\t\telse\n\t\t\ts->tx->error = TX_ERROR_ENVELOPE;\n\t\tm_end(&m);\n\t\treturn;\n\n\tcase IMSG_QUEUE_ENVELOPE_COMMIT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\t\tif (!success)\n\t\t\tfatalx(\"commit evp failed: not supposed to happen\");\n\t\ts = tree_xpop(&wait_lka_rcpt, reqid);\n\t\tif (s->tx->error) {\n\t\t\t/*\n\t\t\t * If an envelope failed, we can't cancel the last\n\t\t\t * RCPT only so we must cancel the whole transaction\n\t\t\t * and close the connection.\n\t\t\t */\n\t\t\tsmtp_reply(s, \"421 %s Temporary failure\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t}\n\t\telse {\n\t\t\trcpt = xcalloc(1, sizeof(*rcpt));\n\t\t\trcpt->evpid = s->tx->evp.id;\n\t\t\trcpt->destcount = s->tx->destcount;\n\t\t\trcpt->maddr = s->tx->evp.rcpt;\n\t\t\tTAILQ_INSERT_TAIL(&s->tx->rcpts, rcpt, entry);\n\n\t\t\ts->tx->destcount = 0;\n\t\t\ts->tx->rcptcount++;\n\t\t\tsmtp_reply(s, \"250 %s %s: Recipient ok\",\n\t\t\t    esc_code(ESC_STATUS_OK, ESC_DESTINATION_ADDRESS_VALID),\n\t\t\t    esc_description(ESC_DESTINATION_ADDRESS_VALID));\n\t\t}\n\t\treturn;\n\n\tcase IMSG_SMTP_MESSAGE_COMMIT:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\t\ts = tree_xpop(&wait_queue_commit, reqid);\n\t\tif (!success) {\n\t\t\tsmtp_reply(s, \"421 %s Temporary failure\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t\tsmtp_tx_free(s->tx);\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\treturn;\n\t\t}\n\n\t\tsmtp_reply(s, \"250 %s %08x Message accepted for delivery\",\n\t\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS),\n\t\t    s->tx->msgid);\n\t\tsmtp_report_tx_commit(s, s->tx->msgid, s->tx->odatalen);\n\t\tsmtp_report_tx_reset(s, s->tx->msgid);\n\n\t\tlog_info(\"%016\"PRIx64\" smtp message \"\n\t\t    \"msgid=%08x size=%zu nrcpt=%zu proto=%s\",\n\t\t    s->id,\n\t\t    s->tx->msgid,\n\t\t    s->tx->odatalen,\n\t\t    s->tx->rcptcount,\n\t\t    s->flags & SF_EHLO ? \"ESMTP\" : \"SMTP\");\n\t\tTAILQ_FOREACH(rcpt, &s->tx->rcpts, entry) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp envelope \"\n\t\t\t    \"evpid=%016\"PRIx64\" from=<%s%s%s> to=<%s%s%s>\",\n\t\t\t    s->id,\n\t\t\t    rcpt->evpid,\n\t\t\t    s->tx->evp.sender.user,\n\t\t\t    s->tx->evp.sender.user[0] == '\\0' ? \"\" : \"@\",\n\t\t\t    s->tx->evp.sender.domain,\n\t\t\t    rcpt->maddr.user,\n\t\t\t    rcpt->maddr.user[0] == '\\0' ? \"\" : \"@\",\n\t\t\t    rcpt->maddr.domain);\n\t\t}\n\t\tsmtp_tx_free(s->tx);\n\t\ts->mailcount++;\n\t\tsmtp_enter_state(s, STATE_HELO);\n\t\treturn;\n\n\tcase IMSG_SMTP_AUTHENTICATE:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &success);\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_parent_auth, reqid);\n\t\tstrnvis(user, s->username, sizeof user, VIS_WHITE | VIS_SAFE);\n\t\tif (success == LKA_OK) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"authentication user=%s \"\n\t\t\t    \"result=ok\",\n\t\t\t    s->id, user);\n\t\t\ts->flags |= SF_AUTHENTICATED;\n\t\t\tsmtp_report_link_auth(s, user, \"pass\");\n\t\t\tsmtp_reply(s, \"235 %s Authentication succeeded\",\n\t\t\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\t\t}\n\t\telse if (success == LKA_PERMFAIL) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"authentication user=%s \"\n\t\t\t    \"result=permfail\",\n\t\t\t    s->id, user);\n\t\t\tsmtp_report_link_auth(s, user, \"fail\");\n\t\t\tsmtp_auth_failure_pause(s);\n\t\t\treturn;\n\t\t}\n\t\telse if (success == LKA_TEMPFAIL) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"authentication user=%s \"\n\t\t\t    \"result=tempfail\",\n\t\t\t    s->id, user);\n\t\t\tsmtp_report_link_auth(s, user, \"error\");\n\t\t\tsmtp_reply(s, \"421 %s Temporary failure\",\n\t\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\t}\n\t\telse\n\t\t\tfatalx(\"bad lka response\");\n\n\t\tsmtp_enter_state(s, STATE_HELO);\n\t\treturn;\n\n\tcase IMSG_FILTER_SMTP_PROTOCOL:\n\t\tm_msg(&m, imsg);\n\t\tm_get_id(&m, &reqid);\n\t\tm_get_int(&m, &filter_response);\n\t\tif (filter_response != FILTER_PROCEED &&\n\t\t    filter_response != FILTER_JUNK)\n\t\t\tm_get_string(&m, &filter_param);\n\t\telse\n\t\t\tfilter_param = NULL;\n\t\tm_end(&m);\n\n\t\ts = tree_xpop(&wait_filters, reqid);\n\n\t\tswitch (filter_response) {\n\t\tcase FILTER_REJECT:\n\t\tcase FILTER_DISCONNECT:\n\t\t\tif (!valid_smtp_response(filter_param) ||\n\t\t\t    (filter_param[0] != '4' && filter_param[0] != '5'))\n\t\t\t\tfilter_param = \"421 Internal server error\";\n\t\t\tif (!strncmp(filter_param, \"421\", 3))\n\t\t\t\tfilter_response = FILTER_DISCONNECT;\n\n\t\t\tsmtp_report_filter_response(s, s->filter_phase,\n\t\t\t    filter_response, filter_param);\n\n\t\t\tsmtp_reply(s, \"%s\", filter_param);\n\n\t\t\tif (filter_response == FILTER_DISCONNECT)\n\t\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\telse if (s->filter_phase == FILTER_COMMIT)\n\t\t\t\tsmtp_proceed_rollback(s, NULL);\n\t\t\tbreak;\n\n\n\t\tcase FILTER_JUNK:\n\t\t\tif (s->tx)\n\t\t\t\ts->tx->junk = 1;\n\t\t\telse\n\t\t\t\ts->junk = 1;\n\t\t\t/* fallthrough */\n\n\t\tcase FILTER_PROCEED:\n\t\t\tfilter_param = s->filter_param;\n\t\t\t/* fallthrough */\n\n\t\tcase FILTER_REWRITE:\n\t\t\tsmtp_report_filter_response(s, s->filter_phase,\n\t\t\t    filter_response,\n\t\t\t    filter_param == s->filter_param ? NULL : filter_param);\n\t\t\tif (s->filter_phase == FILTER_CONNECT) {\n\t\t\t\tsmtp_proceed_connected(s);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (i = 0; i < nitems(commands); ++i)\n\t\t\t\tif (commands[i].filter_phase == s->filter_phase) {\n\t\t\t\t\tif (filter_response == FILTER_REWRITE)\n\t\t\t\t\t\tif (!commands[i].check(s, filter_param))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcommands[i].proceed(s, filter_param);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tlog_warnx(\"smtp_session_imsg: unexpected %s imsg\",\n\t    imsg_to_str(imsg->hdr.type));\n\tfatalx(NULL);\n}\n\nstatic void\nsmtp_tls_verified(struct smtp_session *s)\n{\n\tX509 *x;\n\n\tx = SSL_get_peer_certificate(io_tls(s->io));\n\tif (x) {\n\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t    \"client-cert-check result=\\\"%s\\\"\",\n\t\t    s->id,\n\t\t    (s->flags & SF_VERIFIED) ? \"success\" : \"failure\");\n\t\tX509_free(x);\n\t}\n\n\tif (s->listener->flags & F_SMTPS) {\n\t\tstat_increment(\"smtp.smtps\", 1);\n\t\tio_set_write(s->io);\n\t\tsmtp_send_banner(s);\n\t}\n\telse {\n\t\tstat_increment(\"smtp.tls\", 1);\n\t\tsmtp_enter_state(s, STATE_HELO);\n\t}\n}\n\nstatic void\nsmtp_io(struct io *io, int evt, void *arg)\n{\n\tstruct smtp_session    *s = arg;\n\tchar\t\t       *line;\n\tsize_t\t\t\tlen;\n\tint\t\t\teom;\n\n\tlog_trace(TRACE_IO, \"smtp: %p: %s %s\", s, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\n\tcase IO_TLSREADY:\n\t\tlog_info(\"%016\"PRIx64\" smtp tls ciphers=%s\",\n\t\t    s->id, ssl_to_text(io_tls(s->io)));\n\n\t\tsmtp_report_link_tls(s, ssl_to_text(io_tls(s->io)));\n\n\t\ts->flags |= SF_SECURE;\n\t\ts->helo[0] = '\\0';\n\n\t\tsmtp_cert_verify(s);\n\t\tbreak;\n\n\tcase IO_DATAIN:\n\t    nextline:\n\t\tline = io_getline(s->io, &len);\n\t\tif ((line == NULL && io_datalen(s->io) >= SMTP_LINE_MAX) ||\n\t\t    (line && len >= SMTP_LINE_MAX)) {\n\t\t\ts->flags |= SF_BADINPUT;\n\t\t\tsmtp_reply(s, \"500 %s Line too long\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\tio_set_write(io);\n\t\t\treturn;\n\t\t}\n\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\t/* Message body */\n\t\teom = 0;\n\t\tif (s->state == STATE_BODY) {\n\t\t\tif (strcmp(line, \".\")) {\n\t\t\t\ts->tx->datain += strlen(line) + 1;\n\t\t\t\tif (s->tx->datain > env->sc_maxsize)\n\t\t\t\t\ts->tx->error = TX_ERROR_SIZE;\n\t\t\t}\n\t\t\teom = (s->tx->filter == NULL) ?\n\t\t\t    smtp_tx_dataline(s->tx, line) :\n\t\t\t    smtp_tx_filtered_dataline(s->tx, line);\n\t\t\tif (eom == 0)\n\t\t\t\tgoto nextline;\n\t\t}\n\n\t\t/* Pipelining not supported */\n\t\tif (io_datalen(s->io)) {\n\t\t\ts->flags |= SF_BADINPUT;\n\t\t\tsmtp_reply(s, \"500 %s %s: Pipelining not supported\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\tio_set_write(io);\n\t\t\treturn;\n\t\t}\n\n\t\tif (eom) {\n\t\t\tio_set_write(io);\n\t\t\tif (s->tx->filter == NULL)\n\t\t\t\tsmtp_tx_eom(s->tx);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Must be a command */\n\t\tif (strlcpy(s->cmd, line, sizeof(s->cmd)) >= sizeof(s->cmd)) {\n\t\t\ts->flags |= SF_BADINPUT;\n\t\t\tsmtp_reply(s, \"500 %s Command line too long\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_STATUS));\n\t\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\t\tio_set_write(io);\n\t\t\treturn;\n\t\t}\n\t\tio_set_write(io);\n\t\tsmtp_command(s, line);\n\t\tbreak;\n\n\tcase IO_LOWAT:\n\t\tif (s->state == STATE_QUIT) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t\t    \"reason=quit\",\n\t\t\t    s->id);\n\t\t\tsmtp_free(s, \"done\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Wait for the client to start tls */\n\t\tif (s->state == STATE_TLS) {\n\t\t\tsmtp_cert_init(s);\n\t\t\tbreak;\n\t\t}\n\n\t\tio_set_read(io);\n\t\tbreak;\n\n\tcase IO_TIMEOUT:\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=timeout\",\n\t\t    s->id);\n\t\tsmtp_report_timeout(s);\n\t\tsmtp_free(s, \"timeout\");\n\t\tbreak;\n\n\tcase IO_DISCONNECTED:\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=disconnect\",\n\t\t    s->id);\n\t\tsmtp_free(s, \"disconnected\");\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=\\\"io-error: %s\\\"\",\n\t\t    s->id, io_error(io));\n\t\tsmtp_free(s, \"IO error\");\n\t\tbreak;\n\n\tdefault:\n\t\tfatalx(\"smtp_io()\");\n\t}\n}\n\nstatic void\nsmtp_command(struct smtp_session *s, char *line)\n{\n\tchar\t\t\t       *args;\n\tint\t\t\t\tcmd, i;\n\n\tlog_trace(TRACE_SMTP, \"smtp: %p: <<< %s\", s, line);\n\n\t/*\n\t * These states are special.\n\t */\n\tif (s->state == STATE_AUTH_INIT) {\n\t\tsmtp_report_protocol_client(s, \"********\");\n\t\tsmtp_rfc4954_auth_plain(s, line);\n\t\treturn;\n\t}\n\tif (s->state == STATE_AUTH_USERNAME || s->state == STATE_AUTH_PASSWORD) {\n\t\tsmtp_report_protocol_client(s, \"********\");\n\t\tsmtp_rfc4954_auth_login(s, line);\n\t\treturn;\n\t}\n\n\tif (s->state == STATE_HELO && strncasecmp(line, \"AUTH PLAIN \", 11) == 0)\n\t\tsmtp_report_protocol_client(s, \"AUTH PLAIN ********\");\n\telse\n\t\tsmtp_report_protocol_client(s, line);\n\n\n\t/*\n\t * Unlike other commands, \"mail from\" and \"rcpt to\" contain a\n\t * space in the command name.\n\t */\n\tif (strncasecmp(\"mail from:\", line, 10) == 0 ||\n\t    strncasecmp(\"rcpt to:\", line, 8) == 0)\n\t\targs = strchr(line, ':');\n\telse\n\t\targs = strchr(line, ' ');\n\n\tif (args) {\n\t\t*args++ = '\\0';\n\t\twhile (isspace((unsigned char)*args))\n\t\t\targs++;\n\t}\n\n\tcmd = -1;\n\tfor (i = 0; commands[i].code != -1; i++)\n\t\tif (!strcasecmp(line, commands[i].cmd)) {\n\t\t\tcmd = commands[i].code;\n\t\t\tbreak;\n\t\t}\n\n\ts->last_cmd = cmd;\n\tswitch (cmd) {\n\t/*\n\t * INIT\n\t */\n\tcase CMD_HELO:\n\t\tif (!smtp_check_helo(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_HELO, s, args);\n\t\tbreak;\n\n\tcase CMD_EHLO:\n\t\tif (!smtp_check_ehlo(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_EHLO, s, args);\n\t\tbreak;\n\n\t/*\n\t * SETUP\n\t */\n\tcase CMD_STARTTLS:\n\t\tif (!smtp_check_starttls(s, args))\n\t\t\tbreak;\n\n\t\tsmtp_filter_phase(FILTER_STARTTLS, s, NULL);\n\t\tbreak;\n\n\tcase CMD_AUTH:\n\t\tif (!smtp_check_auth(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_AUTH, s, args);\n\t\tbreak;\n\n\tcase CMD_MAIL_FROM:\n\t\tif (!smtp_check_mail_from(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_MAIL_FROM, s, args);\n\t\tbreak;\n\n\t/*\n\t * TRANSACTION\n\t */\n\tcase CMD_RCPT_TO:\n\t\tif (!smtp_check_rcpt_to(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_RCPT_TO, s, args);\n\t\tbreak;\n\n\tcase CMD_RSET:\n\t\tif (!smtp_check_rset(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_RSET, s, NULL);\n\t\tbreak;\n\n\tcase CMD_DATA:\n\t\tif (!smtp_check_data(s, args))\n\t\t\tbreak;\n\t\tsmtp_filter_phase(FILTER_DATA, s, NULL);\n\t\tbreak;\n\n\t/*\n\t * ANY\n\t */\n\tcase CMD_QUIT:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_filter_phase(FILTER_QUIT, s, NULL);\n\t\tbreak;\n\n\tcase CMD_NOOP:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_filter_phase(FILTER_NOOP, s, NULL);\n\t\tbreak;\n\n\tcase CMD_HELP:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_proceed_help(s, NULL);\n\t\tbreak;\n\n\tcase CMD_WIZ:\n\t\tif (!smtp_check_noparam(s, args))\n\t\t\tbreak;\t\t\n\t\tsmtp_proceed_wiz(s, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tsmtp_reply(s, \"500 %s %s: Command unrecognized\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\tbreak;\n\t}\n}\n\nstatic int\nsmtp_check_rset(struct smtp_session *s, const char *args)\n{\n\tif (!smtp_check_noparam(s, args))\n\t\treturn 0;\n\n\tif (s->helo[0] == '\\0') {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\nsmtp_check_helo(struct smtp_session *s, const char *args)\n{\n\tif (!s->banner_sent) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->helo[0]) {\n\t\tsmtp_reply(s, \"503 %s %s: Already identified\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args == NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: HELO requires domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!valid_domainpart(args)) {\n\t\tsmtp_reply(s, \"501 %s %s: Invalid domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_ehlo(struct smtp_session *s, const char *args)\n{\n\tif (!s->banner_sent) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->helo[0]) {\n\t\tsmtp_reply(s, \"503 %s %s: Already identified\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args == NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: EHLO requires domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!valid_domainpart(args)) {\n\t\tsmtp_reply(s, \"501 %s %s: Invalid domain name\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_auth(struct smtp_session *s, const char *args)\n{\n\tif (s->helo[0] == '\\0' || s->tx) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->flags & SF_AUTHENTICATED) {\n\t\tsmtp_reply(s, \"503 %s %s: Already authenticated\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!ADVERTISE_AUTH(s)) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not supported\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args == NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: No parameters given\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_starttls(struct smtp_session *s, const char *args)\n{\n\tif (s->helo[0] == '\\0' || s->tx) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (!(s->listener->flags & F_STARTTLS)) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not supported\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->flags & SF_SECURE) {\n\t\tsmtp_reply(s, \"503 %s %s: Channel already secured\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (args != NULL) {\n\t\tsmtp_reply(s, \"501 %s %s: No parameters allowed\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_mail_from(struct smtp_session *s, const char *args)\n{\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\tstruct mailaddr\tsender;\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\tcopy = tmp;  \n\n\tif (s->helo[0] == '\\0' || s->tx) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->listener->flags & F_STARTTLS_REQUIRE &&\n\t    !(s->flags & SF_SECURE)) {\n\t\tsmtp_reply(s,\n\t\t    \"530 %s %s: Must issue a STARTTLS command first\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->listener->flags & F_AUTH_REQUIRE &&\n\t    !(s->flags & SF_AUTHENTICATED)) {\n\t\tsmtp_reply(s,\n\t\t    \"530 %s %s: Must issue an AUTH command first\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->mailcount >= env->sc_session_max_mails) {\n\t\t/* we can pretend we had too many recipients */\n\t\tsmtp_reply(s, \"452 %s %s: Too many messages sent\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),\n\t\t    esc_description(ESC_TOO_MANY_RECIPIENTS));\n\t\treturn 0;\n\t}\n\n\tif (smtp_mailaddr(&sender, copy, 1, &copy,\n\t\ts->smtpname) == 0) {\n\t\tsmtp_reply(s, \"553 %s Sender address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_rcpt_to(struct smtp_session *s, const char *args)\n{\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\tcopy = tmp; \n\n\tif (s->tx == NULL) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->tx->rcptcount >= env->sc_session_max_rcpt) {\n\t\tsmtp_reply(s->tx->session, \"451 %s %s: Too many recipients\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),\n\t\t    esc_description(ESC_TOO_MANY_RECIPIENTS));\n\t\treturn 0;\n\t}\n\n\tif (smtp_mailaddr(&s->tx->evp.rcpt, copy, 0, &copy,\n\t\ts->tx->session->smtpname) == 0) {\n\t\tsmtp_reply(s->tx->session,\n\t\t    \"501 %s Recipient address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL,\n\t\t        ESC_BAD_DESTINATION_MAILBOX_ADDRESS_SYNTAX));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_data(struct smtp_session *s, const char *args)\n{\n\tif (!smtp_check_noparam(s, args))\n\t\treturn 0;\n\n\tif (s->tx == NULL) {\n\t\tsmtp_reply(s, \"503 %s %s: Command not allowed at this point.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t\t    esc_description(ESC_INVALID_COMMAND));\n\t\treturn 0;\n\t}\n\n\tif (s->tx->rcptcount == 0) {\n\t\tsmtp_reply(s, \"503 %s %s: No recipient specified\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nsmtp_check_noparam(struct smtp_session *s, const char *args)\n{\n\tif (args != NULL) {\n\t\tsmtp_reply(s, \"500 %s %s: command does not accept arguments.\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nsmtp_query_filters(enum filter_phase phase, struct smtp_session *s, const char *args)\n{\n\tm_create(p_lka, IMSG_FILTER_SMTP_PROTOCOL, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_add_int(p_lka, phase);\n\tm_add_string(p_lka, args);\n\tm_close(p_lka);\n\ttree_xset(&wait_filters, s->id, s);\n}\n\nstatic void\nsmtp_filter_begin(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_BEGIN, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_add_string(p_lka, s->listener->filter_name);\n\tm_close(p_lka);\n}\n\nstatic void\nsmtp_filter_end(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_END, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_close(p_lka);\n}\n\nstatic void\nsmtp_filter_data_begin(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_DATA_BEGIN, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_close(p_lka);\n\ttree_xset(&wait_filter_fd, s->id, s);\n}\n\nstatic void\nsmtp_filter_data_end(struct smtp_session *s)\n{\n\tif (!SESSION_FILTERED(s))\n\t\treturn;\n\n\tif (s->tx->filter == NULL)\n\t\treturn;\n\n\tio_free(s->tx->filter);\n\ts->tx->filter = NULL;\n\n\tm_create(p_lka, IMSG_FILTER_SMTP_DATA_END, 0, 0, -1);\n\tm_add_id(p_lka, s->id);\n\tm_close(p_lka);\n}\n\nstatic void\nsmtp_filter_phase(enum filter_phase phase, struct smtp_session *s, const char *param)\n{\n\tuint8_t i;\n\n\ts->filter_phase = phase;\n\ts->filter_param = param;\n\n\tif (SESSION_FILTERED(s)) {\n\t\tsmtp_query_filters(phase, s, param ? param : \"\");\n\t\treturn;\n\t}\n\n\tif (s->filter_phase == FILTER_CONNECT) {\n\t\tsmtp_proceed_connected(s);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nitems(commands); ++i)\n\t\tif (commands[i].filter_phase == s->filter_phase) {\n\t\t\tcommands[i].proceed(s, param);\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void\nsmtp_proceed_rset(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"250 %s Reset state\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\n\tif (s->tx) {\n\t\tif (s->tx->msgid)\n\t\t\tsmtp_tx_rollback(s->tx);\n\t\tsmtp_tx_free(s->tx);\n\t}\n}\n\nstatic void\nsmtp_proceed_helo(struct smtp_session *s, const char *args)\n{\n\t(void)strlcpy(s->helo, args, sizeof(s->helo));\n\ts->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED;\n\n\tsmtp_report_link_identify(s, \"HELO\", s->helo);\n\n\tsmtp_enter_state(s, STATE_HELO);\n\n\tsmtp_reply(s, \"250 %s Hello %s %s%s%s, pleased to meet you\",\n\t    s->smtpname,\n\t    s->helo,\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"[\",\n\t    ss_to_text(&s->ss),\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"]\");\n}\n\nstatic void\nsmtp_proceed_ehlo(struct smtp_session *s, const char *args)\n{\n\t(void)strlcpy(s->helo, args, sizeof(s->helo));\n\ts->flags &= SF_SECURE | SF_AUTHENTICATED | SF_VERIFIED;\n\ts->flags |= SF_EHLO;\n\ts->flags |= SF_8BITMIME;\n\n\tsmtp_report_link_identify(s, \"EHLO\", s->helo);\n\n\tsmtp_enter_state(s, STATE_HELO);\n\tsmtp_reply(s, \"250-%s Hello %s %s%s%s, pleased to meet you\",\n\t    s->smtpname,\n\t    s->helo,\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"[\",\n\t    ss_to_text(&s->ss),\n\t    s->ss.ss_family == AF_INET6 ? \"\" : \"]\");\n\n\tsmtp_reply(s, \"250-8BITMIME\");\n\tsmtp_reply(s, \"250-ENHANCEDSTATUSCODES\");\n\tsmtp_reply(s, \"250-SIZE %zu\", env->sc_maxsize);\n\tif (ADVERTISE_EXT_DSN(s))\n\t\tsmtp_reply(s, \"250-DSN\");\n\tif (ADVERTISE_TLS(s))\n\t\tsmtp_reply(s, \"250-STARTTLS\");\n\tif (ADVERTISE_AUTH(s))\n\t\tsmtp_reply(s, \"250-AUTH PLAIN LOGIN\");\n\tsmtp_reply(s, \"250 HELP\");\n}\n\nstatic void\nsmtp_proceed_auth(struct smtp_session *s, const char *args)\n{\n\tchar tmp[SMTP_LINE_MAX];\n\tchar *eom, *method;\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\n\tmethod = tmp;\n\teom = strchr(tmp, ' ');\n\tif (eom == NULL)\n\t\teom = strchr(tmp, '\\t');\n\tif (eom != NULL)\n\t\t*eom++ = '\\0';\n\tif (strcasecmp(method, \"PLAIN\") == 0)\n\t\tsmtp_rfc4954_auth_plain(s, eom);\n\telse if (strcasecmp(method, \"LOGIN\") == 0)\n\t\tsmtp_rfc4954_auth_login(s, eom);\n\telse\n\t\tsmtp_reply(s, \"504 %s %s: AUTH method \\\"%s\\\" not supported\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_SECURITY_FEATURES_NOT_SUPPORTED),\n\t\t    esc_description(ESC_SECURITY_FEATURES_NOT_SUPPORTED),\n\t\t    method);\n}\n\nstatic void\nsmtp_proceed_starttls(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"220 %s Ready to start TLS\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\tsmtp_enter_state(s, STATE_TLS);\n}\n\nstatic void\nsmtp_proceed_mail_from(struct smtp_session *s, const char *args)\n{\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, args, sizeof tmp);\n\tcopy = tmp;  \n\n       \tif (!smtp_tx(s)) {\n\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\treturn;\n\t}\n\n\tif (smtp_mailaddr(&s->tx->evp.sender, copy, 1, &copy,\n\t\ts->smtpname) == 0) {\n\t\tsmtp_reply(s, \"553 %s Sender address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));\n\t\tsmtp_tx_free(s->tx);\n\t\treturn;\n\t}\n\n\tsmtp_tx_mail_from(s->tx, args);\n}\n\nstatic void\nsmtp_proceed_rcpt_to(struct smtp_session *s, const char *args)\n{\n\tsmtp_tx_rcpt_to(s->tx, args);\n}\n\nstatic void\nsmtp_proceed_data(struct smtp_session *s, const char *args)\n{\n\tsmtp_tx_open_message(s->tx);\n}\n\nstatic void\nsmtp_proceed_quit(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"221 %s Bye\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\tsmtp_enter_state(s, STATE_QUIT);\n}\n\nstatic void\nsmtp_proceed_noop(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"250 %s Ok\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n}\n\nstatic void\nsmtp_proceed_help(struct smtp_session *s, const char *args)\n{\n\tconst char *code = esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS);\n\n\tsmtp_reply(s, \"214-%s This is \" SMTPD_NAME, code);\n\tsmtp_reply(s, \"214-%s To report bugs in the implementation, \"\n\t    \"please contact bugs@openbsd.org\", code);\n\tsmtp_reply(s, \"214-%s with full details\", code);\n\tsmtp_reply(s, \"214 %s End of HELP info\", code);\n}\n\nstatic void\nsmtp_proceed_wiz(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"500 %s %s: this feature is not supported yet ;-)\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND),\n\t    esc_description(ESC_INVALID_COMMAND));\n}\n\nstatic void\nsmtp_proceed_commit(struct smtp_session *s, const char *args)\n{\n\tsmtp_message_end(s->tx);\n}\n\nstatic void\nsmtp_proceed_rollback(struct smtp_session *s, const char *args)\n{\n\tstruct smtp_tx *tx;\n\n\ttx = s->tx;\n\n\tfclose(tx->ofile);\n\ttx->ofile = NULL;\n\n\tsmtp_tx_rollback(tx);\n\tsmtp_tx_free(tx);\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_rfc4954_auth_plain(struct smtp_session *s, char *arg)\n{\n\tchar\t\t buf[1024], *user, *pass;\n\tint\t\t len;\n\n\tswitch (s->state) {\n\tcase STATE_HELO:\n\t\tif (arg == NULL) {\n\t\t\tsmtp_enter_state(s, STATE_AUTH_INIT);\n\t\t\tsmtp_reply(s, \"334 \");\n\t\t\treturn;\n\t\t}\n\t\tsmtp_enter_state(s, STATE_AUTH_INIT);\n\t\t/* FALLTHROUGH */\n\n\tcase STATE_AUTH_INIT:\n\t\t/* String is not NUL terminated, leave room. */\n\t\tif ((len = base64_decode(arg, (unsigned char *)buf,\n\t\t\t    sizeof(buf) - 1)) == -1)\n\t\t\tgoto abort;\n\t\t/* buf is a byte string, NUL terminate. */\n\t\tbuf[len] = '\\0';\n\n\t\t/*\n\t\t * Skip \"foo\" in \"foo\\0user\\0pass\", if present.\n\t\t */\n\t\tuser = memchr(buf, '\\0', len);\n\t\tif (user == NULL || user >= buf + len - 2)\n\t\t\tgoto abort;\n\t\tuser++; /* skip NUL */\n\t\tif (strlcpy(s->username, user, sizeof(s->username))\n\t\t    >= sizeof(s->username))\n\t\t\tgoto abort;\n\n\t\tpass = memchr(user, '\\0', len - (user - buf));\n\t\tif (pass == NULL || pass >= buf + len - 2)\n\t\t\tgoto abort;\n\t\tpass++; /* skip NUL */\n\n\t\tm_create(p_lka,  IMSG_SMTP_AUTHENTICATE, 0, 0, -1);\n\t\tm_add_id(p_lka, s->id);\n\t\tm_add_string(p_lka, s->listener->authtable);\n\t\tm_add_string(p_lka, user);\n\t\tm_add_string(p_lka, pass);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_parent_auth, s->id, s);\n\t\treturn;\n\n\tdefault:\n\t\tfatal(\"smtp_rfc4954_auth_plain: unknown state\");\n\t}\n\nabort:\n\tsmtp_reply(s, \"501 %s %s: Syntax error\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_SYNTAX_ERROR),\n\t    esc_description(ESC_SYNTAX_ERROR));\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_rfc4954_auth_login(struct smtp_session *s, char *arg)\n{\n\tchar\t\tbuf[LINE_MAX];\n\n\tswitch (s->state) {\n\tcase STATE_HELO:\n\t\tsmtp_enter_state(s, STATE_AUTH_USERNAME);\n\t\tif (arg != NULL && *arg != '\\0') {\n\t\t\tsmtp_rfc4954_auth_login(s, arg);\n\t\t\treturn;\n\t\t}\n\t\tsmtp_reply(s, \"334 VXNlcm5hbWU6\");\n\t\treturn;\n\n\tcase STATE_AUTH_USERNAME:\n\t\tmemset(s->username, 0, sizeof(s->username));\n\t\tif (base64_decode(arg, (unsigned char *)s->username,\n\t\t\t\t  sizeof(s->username) - 1) == -1)\n\t\t\tgoto abort;\n\n\t\tsmtp_enter_state(s, STATE_AUTH_PASSWORD);\n\t\tsmtp_reply(s, \"334 UGFzc3dvcmQ6\");\n\t\treturn;\n\n\tcase STATE_AUTH_PASSWORD:\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (base64_decode(arg, (unsigned char *)buf,\n\t\t\t\t  sizeof(buf)-1) == -1)\n\t\t\tgoto abort;\n\n\t\tm_create(p_lka,  IMSG_SMTP_AUTHENTICATE, 0, 0, -1);\n\t\tm_add_id(p_lka, s->id);\n\t\tm_add_string(p_lka, s->listener->authtable);\n\t\tm_add_string(p_lka, s->username);\n\t\tm_add_string(p_lka, buf);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_parent_auth, s->id, s);\n\t\treturn;\n\n\tdefault:\n\t\tfatal(\"smtp_rfc4954_auth_login: unknown state\");\n\t}\n\nabort:\n\tsmtp_reply(s, \"501 %s %s: Syntax error\",\n\t    esc_code(ESC_STATUS_PERMFAIL, ESC_SYNTAX_ERROR),\n\t    esc_description(ESC_SYNTAX_ERROR));\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_lookup_servername(struct smtp_session *s)\n{\n\tif (s->listener->hostnametable[0]) {\n\t\tm_create(p_lka, IMSG_SMTP_LOOKUP_HELO, 0, 0, -1);\n\t\tm_add_id(p_lka, s->id);\n\t\tm_add_string(p_lka, s->listener->hostnametable);\n\t\tm_add_sockaddr(p_lka, (struct sockaddr*)&s->listener->ss);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_lka_helo, s->id, s);\n\t\treturn;\n\t}\n\n\tsmtp_connected(s);\n}\n\nstatic void\nsmtp_connected(struct smtp_session *s)\n{\n\tsmtp_enter_state(s, STATE_CONNECTED);\n\n\tlog_info(\"%016\"PRIx64\" smtp connected address=%s host=%s\",\n\t    s->id, ss_to_text(&s->ss), s->rdns);\n\n\tsmtp_filter_begin(s);\n\n\tsmtp_report_link_connect(s, s->rdns, s->fcrdns, &s->ss,\n\t    &s->listener->ss);\n\n\tsmtp_filter_phase(FILTER_CONNECT, s, ss_to_text(&s->ss));\n}\n\nstatic void\nsmtp_proceed_connected(struct smtp_session *s)\n{\n\tif (s->listener->flags & F_SMTPS)\n\t\tsmtp_cert_init(s);\n\telse\n\t\tsmtp_send_banner(s);\n}\n\nstatic void\nsmtp_send_banner(struct smtp_session *s)\n{\n\tsmtp_reply(s, \"220 %s ESMTP %s\", s->smtpname, SMTPD_NAME);\n\ts->banner_sent = 1;\n\tsmtp_report_link_greeting(s, s->smtpname);\n}\n\nvoid\nsmtp_enter_state(struct smtp_session *s, int newstate)\n{\n\tlog_trace(TRACE_SMTP, \"smtp: %p: %s -> %s\", s,\n\t    smtp_strstate(s->state),\n\t    smtp_strstate(newstate));\n\n\ts->state = newstate;\n}\n\nstatic void\nsmtp_reply(struct smtp_session *s, char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t n;\n\tchar\t buf[LINE_MAX*2], tmp[LINE_MAX*2];\n\n\tva_start(ap, fmt);\n\tn = vsnprintf(buf, sizeof buf, fmt, ap);\n\tva_end(ap);\n\tif (n < 0)\n\t\tfatalx(\"smtp_reply: response format error\");\n\tif (n < 4)\n\t\tfatalx(\"smtp_reply: response too short\");\n\tif (n >= (int)sizeof buf) {\n\t\t/* only first three bytes are used by SMTP logic,\n\t\t * so if _our_ reply does not fit entirely in the\n\t\t * buffer, it's ok to truncate.\n\t\t */\n\t}\n\n\tlog_trace(TRACE_SMTP, \"smtp: %p: >>> %s\", s, buf);\n\tsmtp_report_protocol_server(s, buf);\n\n\tswitch (buf[0]) {\n\tcase '2':\n\t\tif (s->tx) {\n\t\t\tif (s->last_cmd == CMD_MAIL_FROM) {\n\t\t\t\tsmtp_report_tx_begin(s, s->tx->msgid);\n\t\t\t\tsmtp_report_tx_mail(s, s->tx->msgid, s->cmd + 10, 1);\n\t\t\t}\n\t\t\telse if (s->last_cmd == CMD_RCPT_TO)\n\t\t\t\tsmtp_report_tx_rcpt(s, s->tx->msgid, s->cmd + 8, 1);\n\t\t}\n\t\tbreak;\n\tcase '3':\n\t\tif (s->tx) {\n\t\t\tif (s->last_cmd == CMD_DATA)\n\t\t\t\tsmtp_report_tx_data(s, s->tx->msgid, 1);\n\t\t}\n\t\tbreak;\n\tcase '5':\n\tcase '4':\n\t\t/* do not report smtp_tx_mail/smtp_tx_rcpt errors\n\t\t * if they happened outside of a transaction.\n\t\t */\n\t\tif (s->tx) {\n\t\t\tif (s->last_cmd == CMD_MAIL_FROM)\n\t\t\t\tsmtp_report_tx_mail(s, s->tx->msgid,\n\t\t\t\t    s->cmd + 10, buf[0] == '4' ? -1 : 0);\n\t\t\telse if (s->last_cmd == CMD_RCPT_TO)\n\t\t\t\tsmtp_report_tx_rcpt(s,\n\t\t\t\t    s->tx->msgid, s->cmd + 8, buf[0] == '4' ? -1 : 0);\n\t\t\telse if (s->last_cmd == CMD_DATA && s->tx->rcptcount)\n\t\t\t\tsmtp_report_tx_data(s, s->tx->msgid,\n\t\t\t\t    buf[0] == '4' ? -1 : 0);\n\t\t}\n\n\t\tif (s->flags & SF_BADINPUT) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"bad-input result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse if (s->state == STATE_AUTH_INIT) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command \"\n\t\t\t    \"command=\\\"AUTH PLAIN (...)\\\" result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse if (s->state == STATE_AUTH_USERNAME) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command \"\n\t\t\t    \"command=\\\"AUTH LOGIN (username)\\\" result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse if (s->state == STATE_AUTH_PASSWORD) {\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command \"\n\t\t\t    \"command=\\\"AUTH LOGIN (password)\\\" result=\\\"%.*s\\\"\",\n\t\t\t    s->id, n, buf);\n\t\t}\n\t\telse {\n\t\t\tstrnvis(tmp, s->cmd, sizeof tmp, VIS_SAFE | VIS_CSTYLE);\n\t\t\tlog_info(\"%016\"PRIx64\" smtp \"\n\t\t\t    \"failed-command command=\\\"%s\\\" \"\n\t\t\t    \"result=\\\"%.*s\\\"\",\n\t\t\t    s->id, tmp, n, buf);\n\t\t}\n\t\tbreak;\n\t}\n\n\tio_xprintf(s->io, \"%s\\r\\n\", buf);\n}\n\nstatic void\nsmtp_free(struct smtp_session *s, const char * reason)\n{\n\tif (s->tx) {\n\t\tif (s->tx->msgid)\n\t\t\tsmtp_tx_rollback(s->tx);\n\t\tsmtp_tx_free(s->tx);\n\t}\n\n\tsmtp_report_link_disconnect(s);\n\tsmtp_filter_end(s);\n\n\tif (s->flags & SF_SECURE && s->listener->flags & F_SMTPS)\n\t\tstat_decrement(\"smtp.smtps\", 1);\n\tif (s->flags & SF_SECURE && s->listener->flags & F_STARTTLS)\n\t\tstat_decrement(\"smtp.tls\", 1);\n\n\tio_free(s->io);\n\tfree(s);\n\n\tsmtp_collect();\n}\n\nstatic int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t/* accept empty return-path in MAIL FROM, required for bounces */\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t/* no or invalid user-part, reject */\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t/* no domain part, local user */\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}\n\nstatic void\nsmtp_cert_init(struct smtp_session *s)\n{\n\tconst char *name;\n\tint fallback;\n\n\tif (s->listener->pki_name[0]) {\n\t\tname = s->listener->pki_name;\n\t\tfallback = 0;\n\t}\n\telse {\n\t\tname = s->smtpname;\n\t\tfallback = 1;\n\t}\n\n\tif (cert_init(name, fallback, smtp_cert_init_cb, s))\n\t\ttree_xset(&wait_ssl_init, s->id, s);\n}\n\nstatic void\nsmtp_cert_init_cb(void *arg, int status, const char *name, const void *cert,\n    size_t cert_len)\n{\n\tstruct smtp_session *s = arg;\n\tvoid *ssl, *ssl_ctx;\n\n\ttree_pop(&wait_ssl_init, s->id);\n\n\tif (status == CA_FAIL) {\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \"reason=ca-failure\",\n\t\t    s->id);\n\t\tsmtp_free(s, \"CA failure\");\n\t\treturn;\n\t}\n\n\tssl_ctx = dict_get(env->sc_ssl_dict, name);\n\tssl = ssl_smtp_init(ssl_ctx, s->listener->flags & F_TLS_VERIFY);\n\tio_set_read(s->io);\n\tio_start_tls(s->io, ssl);\n}\n\nstatic void\nsmtp_cert_verify(struct smtp_session *s)\n{\n\tconst char *name;\n\tint fallback;\n\n\tif (s->listener->ca_name[0]) {\n\t\tname = s->listener->ca_name;\n\t\tfallback = 0;\n\t}\n\telse {\n\t\tname = s->smtpname;\n\t\tfallback = 1;\n\t}\n\n\tif (cert_verify(io_tls(s->io), name, fallback, smtp_cert_verify_cb, s)) {\n\t\ttree_xset(&wait_ssl_verify, s->id, s);\n\t\tio_pause(s->io, IO_IN);\n\t}\n}\n\nstatic void\nsmtp_cert_verify_cb(void *arg, int status)\n{\n\tstruct smtp_session *s = arg;\n\tconst char *reason = NULL;\n\tint resume;\n\n\tresume = tree_pop(&wait_ssl_verify, s->id) != NULL;\n\n\tswitch (status) {\n\tcase CERT_OK:\n\t\treason = \"cert-ok\";\n\t\ts->flags |= SF_VERIFIED;\n\t\tbreak;\n\tcase CERT_NOCA:\n\t\treason = \"no-ca\";\n\t\tbreak;\n\tcase CERT_NOCERT:\n\t\treason = \"no-client-cert\";\n\t\tbreak;\n\tcase CERT_INVALID:\n\t\treason = \"cert-invalid\";\n\t\tbreak;\n\tdefault:\n\t\treason = \"cert-check-failed\";\n\t\tbreak;\n\t}\n\n\tlog_debug(\"smtp: %p: smtp_cert_verify_cb: %s\", s, reason);\n\n\tif (!(s->flags & SF_VERIFIED) && (s->listener->flags & F_TLS_VERIFY)) {\n\t\tlog_info(\"%016\"PRIx64\" smtp disconnected \"\n\t\t    \" reason=%s\", s->id,\n\t\t    reason);\n\t\tsmtp_free(s, \"SSL certificate check failed\");\n\t\treturn;\n\t}\n\n\tsmtp_tls_verified(s);\n\tif (resume)\n\t\tio_resume(s->io, IO_IN);\n}\n\nstatic void\nsmtp_auth_failure_resume(int fd, short event, void *p)\n{\n\tstruct smtp_session *s = p;\n\n\tsmtp_reply(s, \"535 Authentication failed\");\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic void\nsmtp_auth_failure_pause(struct smtp_session *s)\n{\n\tstruct timeval\ttv;\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = arc4random_uniform(1000000);\n\tlog_trace(TRACE_SMTP, \"smtp: timing-attack protection triggered, \"\n\t    \"will defer answer for %lu microseconds\", tv.tv_usec);\n\tevtimer_set(&s->pause, smtp_auth_failure_resume, s);\n\tevtimer_add(&s->pause, &tv);\n}\n\nstatic int\nsmtp_tx(struct smtp_session *s)\n{\n\tstruct smtp_tx *tx;\n\n\ttx = calloc(1, sizeof(*tx));\n\tif (tx == NULL)\n\t\treturn 0;\n\n\tTAILQ_INIT(&tx->rcpts);\n\n\ts->tx = tx;\n\ttx->session = s;\n\n\t/* setup the envelope */\n\ttx->evp.ss = s->ss;\n\t(void)strlcpy(tx->evp.tag, s->listener->tag, sizeof(tx->evp.tag));\n\t(void)strlcpy(tx->evp.smtpname, s->smtpname, sizeof(tx->evp.smtpname));\n\t(void)strlcpy(tx->evp.hostname, s->rdns, sizeof tx->evp.hostname);\n\t(void)strlcpy(tx->evp.helo, s->helo, sizeof(tx->evp.helo));\n\t(void)strlcpy(tx->evp.username, s->username, sizeof(tx->evp.username));\n\n\tif (s->flags & SF_BOUNCE)\n\t\ttx->evp.flags |= EF_BOUNCE;\n\tif (s->flags & SF_AUTHENTICATED)\n\t\ttx->evp.flags |= EF_AUTHENTICATED;\n\n\tif ((tx->parser = rfc5322_parser_new()) == NULL) {\n\t\tfree(tx);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nsmtp_tx_free(struct smtp_tx *tx)\n{\n\tstruct smtp_rcpt *rcpt;\n\n\trfc5322_free(tx->parser);\n\n\twhile ((rcpt = TAILQ_FIRST(&tx->rcpts))) {\n\t\tTAILQ_REMOVE(&tx->rcpts, rcpt, entry);\n\t\tfree(rcpt);\n\t}\n\n\tif (tx->ofile)\n\t\tfclose(tx->ofile);\n\n\ttx->session->tx = NULL;\n\n\tfree(tx);\n}\n\nstatic void\nsmtp_tx_mail_from(struct smtp_tx *tx, const char *line)\n{\n\tchar *opt;\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, line, sizeof tmp);\n\tcopy = tmp;  \n\n\tif (smtp_mailaddr(&tx->evp.sender, copy, 1, &copy,\n\t\ttx->session->smtpname) == 0) {\n\t\tsmtp_reply(tx->session, \"553 %s Sender address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_OTHER_ADDRESS_STATUS));\n\t\tsmtp_tx_free(tx);\n\t\treturn;\n\t}\n\n\twhile ((opt = strsep(&copy, \" \"))) {\n\t\tif (*opt == '\\0')\n\t\t\tcontinue;\n\n\t\tif (strncasecmp(opt, \"AUTH=\", 5) == 0)\n\t\t\tlog_debug(\"debug: smtp: AUTH in MAIL FROM command\");\n\t\telse if (strncasecmp(opt, \"SIZE=\", 5) == 0)\n\t\t\tlog_debug(\"debug: smtp: SIZE in MAIL FROM command\");\n\t\telse if (strcasecmp(opt, \"BODY=7BIT\") == 0)\n\t\t\t/* XXX only for this transaction */\n\t\t\ttx->session->flags &= ~SF_8BITMIME;\n\t\telse if (strcasecmp(opt, \"BODY=8BITMIME\") == 0)\n\t\t\t;\n\t\telse if (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"RET=\", 4) == 0) {\n\t\t\topt += 4;\n\t\t\tif (strcasecmp(opt, \"HDRS\") == 0)\n\t\t\t\ttx->evp.dsn_ret = DSN_RETHDRS;\n\t\t\telse if (strcasecmp(opt, \"FULL\") == 0)\n\t\t\t\ttx->evp.dsn_ret = DSN_RETFULL;\n\t\t} else if (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"ENVID=\", 6) == 0) {\n\t\t\topt += 6;\n\t\t\tif (strlcpy(tx->evp.dsn_envid, opt, sizeof(tx->evp.dsn_envid))\n\t\t\t    >= sizeof(tx->evp.dsn_envid)) {\n\t\t\t\tsmtp_reply(tx->session,\n\t\t\t\t    \"503 %s %s: option too large, truncated: %s\",\n\t\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), opt);\n\t\t\t\tsmtp_tx_free(tx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tsmtp_reply(tx->session, \"503 %s %s: Unsupported option %s\",\n\t\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_INVALID_COMMAND_ARGUMENTS),\n\t\t\t    esc_description(ESC_INVALID_COMMAND_ARGUMENTS), opt);\n\t\t\tsmtp_tx_free(tx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* only check sendertable if defined and user has authenticated */\n\tif (tx->session->flags & SF_AUTHENTICATED &&\n\t    tx->session->listener->sendertable[0]) {\n\t\tm_create(p_lka, IMSG_SMTP_CHECK_SENDER, 0, 0, -1);\n\t\tm_add_id(p_lka, tx->session->id);\n\t\tm_add_string(p_lka, tx->session->listener->sendertable);\n\t\tm_add_string(p_lka, tx->session->username);\n\t\tm_add_mailaddr(p_lka, &tx->evp.sender);\n\t\tm_close(p_lka);\n\t\ttree_xset(&wait_lka_mail, tx->session->id, tx->session);\n\t}\n\telse\n\t\tsmtp_tx_create_message(tx);\n}\n\nstatic void\nsmtp_tx_create_message(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_CREATE, 0, 0, -1);\n\tm_add_id(p_queue, tx->session->id);\n\tm_close(p_queue);\n\ttree_xset(&wait_queue_msg, tx->session->id, tx->session);\n}\n\nstatic void\nsmtp_tx_rcpt_to(struct smtp_tx *tx, const char *line)\n{\n\tchar *opt, *p;\n\tchar *copy;\n\tchar tmp[SMTP_LINE_MAX];\n\n\t(void)strlcpy(tmp, line, sizeof tmp);\n\tcopy = tmp; \n\n\tif (tx->rcptcount >= env->sc_session_max_rcpt) {\n\t\tsmtp_reply(tx->session, \"451 %s %s: Too many recipients\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_TOO_MANY_RECIPIENTS),\n\t\t    esc_description(ESC_TOO_MANY_RECIPIENTS));\n\t\treturn;\n\t}\n\n\tif (smtp_mailaddr(&tx->evp.rcpt, copy, 0, &copy,\n\t    tx->session->smtpname) == 0) {\n\t\tsmtp_reply(tx->session,\n\t\t    \"501 %s Recipient address syntax error\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL,\n\t\t        ESC_BAD_DESTINATION_MAILBOX_ADDRESS_SYNTAX));\n\t\treturn;\n\t}\n\n\twhile ((opt = strsep(&copy, \" \"))) {\n\t\tif (*opt == '\\0')\n\t\t\tcontinue;\n\n\t\tif (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"NOTIFY=\", 7) == 0) {\n\t\t\topt += 7;\n\t\t\twhile ((p = strsep(&opt, \",\"))) {\n\t\t\t\tif (strcasecmp(p, \"SUCCESS\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_SUCCESS;\n\t\t\t\telse if (strcasecmp(p, \"FAILURE\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_FAILURE;\n\t\t\t\telse if (strcasecmp(p, \"DELAY\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_DELAY;\n\t\t\t\telse if (strcasecmp(p, \"NEVER\") == 0)\n\t\t\t\t\ttx->evp.dsn_notify |= DSN_NEVER;\n\t\t\t}\n\n\t\t\tif (tx->evp.dsn_notify & DSN_NEVER &&\n\t\t\t    tx->evp.dsn_notify & (DSN_SUCCESS | DSN_FAILURE |\n\t\t\t    DSN_DELAY)) {\n\t\t\t\tsmtp_reply(tx->session,\n\t\t\t\t    \"553 NOTIFY option NEVER cannot be\"\n\t\t\t\t    \" combined with other options\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (ADVERTISE_EXT_DSN(tx->session) && strncasecmp(opt, \"ORCPT=\", 6) == 0) {\n\t\t\topt += 6;\n\t\t\tif (!text_to_mailaddr(&tx->evp.dsn_orcpt, opt)) {\n\t\t\t\tsmtp_reply(tx->session,\n\t\t\t\t    \"553 ORCPT address syntax error\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tsmtp_reply(tx->session, \"503 Unsupported option %s\", opt);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tm_create(p_lka, IMSG_SMTP_EXPAND_RCPT, 0, 0, -1);\n\tm_add_id(p_lka, tx->session->id);\n\tm_add_envelope(p_lka, &tx->evp);\n\tm_close(p_lka);\n\ttree_xset(&wait_lka_rcpt, tx->session->id, tx->session);\n}\n\nstatic void\nsmtp_tx_open_message(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_OPEN, 0, 0, -1);\n\tm_add_id(p_queue, tx->session->id);\n\tm_add_msgid(p_queue, tx->msgid);\n\tm_close(p_queue);\n\ttree_xset(&wait_queue_fd, tx->session->id, tx->session);\n}\n\nstatic void\nsmtp_tx_commit(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_COMMIT, 0, 0, -1);\n\tm_add_id(p_queue, tx->session->id);\n\tm_add_msgid(p_queue, tx->msgid);\n\tm_close(p_queue);\n\ttree_xset(&wait_queue_commit, tx->session->id, tx->session);\n\tsmtp_filter_data_end(tx->session);\n}\n\nstatic void\nsmtp_tx_rollback(struct smtp_tx *tx)\n{\n\tm_create(p_queue, IMSG_SMTP_MESSAGE_ROLLBACK, 0, 0, -1);\n\tm_add_msgid(p_queue, tx->msgid);\n\tm_close(p_queue);\n\tsmtp_report_tx_rollback(tx->session, tx->msgid);\n\tsmtp_report_tx_reset(tx->session, tx->msgid);\n\tsmtp_filter_data_end(tx->session);\n}\n\nstatic int\nsmtp_tx_dataline(struct smtp_tx *tx, const char *line)\n{\n\tstruct rfc5322_result res;\n\tint r;\n\n\tlog_trace(TRACE_SMTP, \"<<< [MSG] %s\", line);\n\n\tif (!strcmp(line, \".\")) {\n\t\tsmtp_report_protocol_client(tx->session, \".\");\n\t\tlog_trace(TRACE_SMTP, \"<<< [EOM]\");\n\t\tif (tx->error)\n\t\t\treturn 1;\n\t\tline = NULL;\n\t}\n\telse {\n\t\t/* ignore data line if an error is set */\n\t\tif (tx->error)\n\t\t\treturn 0;\n\n\t\t/* escape lines starting with a '.' */\n\t\tif (line[0] == '.')\n\t\t\tline += 1;\n\t}\n\n\tif (rfc5322_push(tx->parser, line) == -1) {\n\t\tlog_warnx(\"failed to push dataline\");\n\t\ttx->error = TX_ERROR_INTERNAL;\n\t\treturn 0;\n\t}\n\n\tfor(;;) {\n\t\tr = rfc5322_next(tx->parser, &res);\n\t\tswitch (r) {\n\t\tcase -1:\n\t\t\tif (errno == ENOMEM)\n\t\t\t\ttx->error = TX_ERROR_INTERNAL;\n\t\t\telse\n\t\t\t\ttx->error = TX_ERROR_MALFORMED;\n\t\t\treturn 0;\n\n\t\tcase RFC5322_NONE:\n\t\t\t/* Need more data */\n\t\t\treturn 0;\n\n\t\tcase RFC5322_HEADER_START:\n\t\t\t/* ignore bcc */\n\t\t\tif (!strcasecmp(\"Bcc\", res.hdr))\n\t\t\t\tcontinue;\n\n\t\t\tif (!strcasecmp(\"To\", res.hdr) ||\n\t\t\t    !strcasecmp(\"Cc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"From\", res.hdr)) {\n\t\t\t\trfc5322_unfold_header(tx->parser);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcasecmp(\"Received\", res.hdr)) {\n\t\t\t\tif (++tx->rcvcount >= MAX_HOPS_COUNT) {\n\t\t\t\t\tlog_warnx(\"warn: loop detected\");\n\t\t\t\t\ttx->error = TX_ERROR_LOOP;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!tx->has_date && !strcasecmp(\"Date\", res.hdr))\n\t\t\t\ttx->has_date = 1;\n\t\t\telse if (!tx->has_message_id &&\n\t\t\t    !strcasecmp(\"Message-Id\", res.hdr))\n\t\t\t\ttx->has_message_id = 1;\n\n\t\t\tsmtp_message_printf(tx, \"%s:%s\\n\", res.hdr, res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_HEADER_CONT:\n\n\t\t\tif (!strcasecmp(\"Bcc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"To\", res.hdr) ||\n\t\t\t    !strcasecmp(\"Cc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"From\", res.hdr))\n\t\t\t\tcontinue;\n\n\t\t\tsmtp_message_printf(tx, \"%s\\n\", res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_HEADER_END:\n\t\t\tif (!strcasecmp(\"To\", res.hdr) ||\n\t\t\t    !strcasecmp(\"Cc\", res.hdr) ||\n\t\t\t    !strcasecmp(\"From\", res.hdr))\n\t\t\t\theader_domain_append_callback(tx, res.hdr,\n\t\t\t\t    res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_END_OF_HEADERS:\n\t\t\tif (tx->session->listener->local ||\n\t\t\t    tx->session->listener->port == 587) {\n\n\t\t\t\tif (!tx->has_date) {\n\t\t\t\t\tlog_debug(\"debug: %p: adding Date\", tx);\n\t\t\t\t\tsmtp_message_printf(tx, \"Date: %s\\n\",\n\t\t\t\t\t    time_to_text(tx->time));\n\t\t\t\t}\n\n\t\t\t\tif (!tx->has_message_id) {\n\t\t\t\t\tlog_debug(\"debug: %p: adding Message-ID\", tx);\n\t\t\t\t\tsmtp_message_printf(tx,\n\t\t\t\t\t    \"Message-ID: <%016\"PRIx64\"@%s>\\n\",\n\t\t\t\t\t    generate_uid(),\n\t\t\t\t\t    tx->session->listener->hostname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RFC5322_BODY_START:\n\t\tcase RFC5322_BODY:\n\t\t\tsmtp_message_printf(tx, \"%s\\n\", res.value);\n\t\t\tbreak;\n\n\t\tcase RFC5322_END_OF_MESSAGE:\n\t\t\treturn 1;\n\n\t\tdefault:\n\t\t\tfatalx(\"%s\", __func__);\n\t\t}\n\t}\n}\n\nstatic int\nsmtp_tx_filtered_dataline(struct smtp_tx *tx, const char *line)\n{\n\tif (!strcmp(line, \".\"))\n\t\tline = NULL;\n\telse {\n\t\t/* ignore data line if an error is set */\n\t\tif (tx->error)\n\t\t\treturn 0;\n\t}\n\tio_printf(tx->filter, \"%s\\n\", line ? line : \".\");\n\treturn line ? 0 : 1;\n}\n\nstatic void\nsmtp_tx_eom(struct smtp_tx *tx)\n{\n\tsmtp_filter_phase(FILTER_COMMIT, tx->session, NULL);\n}\n\nstatic int\nsmtp_message_fd(struct smtp_tx *tx, int fd)\n{\n\tstruct smtp_session *s;\n\n\ts = tx->session;\n\n\tlog_debug(\"smtp: %p: message fd %d\", s, fd);\n\n\tif ((tx->ofile = fdopen(fd, \"w\")) == NULL) {\n\t\tclose(fd);\n\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\tsmtp_enter_state(s, STATE_QUIT);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nfilter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct smtp_tx*tx = arg;\n\tchar*line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session io (smtp): %p: %s %s\", tx, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(tx->filter, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tif (smtp_tx_dataline(tx, line)) {\n\t\t\tsmtp_tx_eom(tx);\n\t\t\treturn;\n\t\t}\n\n\t\tgoto nextline;\n\t}\n}\n\nstatic void\nsmtp_filter_fd(struct smtp_tx *tx, int fd)\n{\n\tstruct smtp_session *s;\n\n\ts = tx->session;\n\n\tlog_debug(\"smtp: %p: filter fd %d\", s, fd);\n\n\ttx->filter = io_new();\n\tio_set_fd(tx->filter, fd);\n\tio_set_callback(tx->filter, filter_session_io, tx);\n}\n\nstatic void\nsmtp_message_begin(struct smtp_tx *tx)\n{\n\tstruct smtp_session *s;\n\tX509 *x;\n\tint\t(*m_printf)(struct smtp_tx *, const char *, ...);\n\n\tm_printf = smtp_message_printf;\n\tif (tx->filter)\n\t\tm_printf = smtp_filter_printf;\n\n\ts = tx->session;\n\n\tlog_debug(\"smtp: %p: message begin\", s);\n\n\tsmtp_reply(s, \"354 Enter mail, end with \\\".\\\"\"\n\t    \" on a line by itself\");\t\n\t\n\tif (s->junk || (s->tx && s->tx->junk))\n\t\tm_printf(tx, \"X-Spam: Yes\\n\");\n\n\tm_printf(tx, \"Received: \");\n\tif (!(s->listener->flags & F_MASK_SOURCE)) {\n\t\tm_printf(tx, \"from %s (%s %s%s%s)\",\n\t\t    s->helo,\n\t\t    s->rdns,\n\t\t    s->ss.ss_family == AF_INET6 ? \"\" : \"[\",\n\t\t    ss_to_text(&s->ss),\n\t\t    s->ss.ss_family == AF_INET6 ? \"\" : \"]\");\n\t}\n\tm_printf(tx, \"\\n\\tby %s (%s) with %sSMTP%s%s id %08x\",\n\t    s->smtpname,\n\t    SMTPD_NAME,\n\t    s->flags & SF_EHLO ? \"E\" : \"\",\n\t    s->flags & SF_SECURE ? \"S\" : \"\",\n\t    s->flags & SF_AUTHENTICATED ? \"A\" : \"\",\n\t    tx->msgid);\n\n\tif (s->flags & SF_SECURE) {\n\t\tx = SSL_get_peer_certificate(io_tls(s->io));\n\t\tm_printf(tx, \" (%s:%s:%d:%s)\",\n\t\t    SSL_get_version(io_tls(s->io)),\n\t\t    SSL_get_cipher_name(io_tls(s->io)),\n\t\t    SSL_get_cipher_bits(io_tls(s->io), NULL),\n\t\t    (s->flags & SF_VERIFIED) ? \"YES\" : (x ? \"FAIL\" : \"NO\"));\n\t\tX509_free(x);\n\n\t\tif (s->listener->flags & F_RECEIVEDAUTH) {\n\t\t\tm_printf(tx, \" auth=%s\",\n\t\t\t    s->username[0] ? \"yes\" : \"no\");\n\t\t\tif (s->username[0])\n\t\t\t\tm_printf(tx, \" user=%s\", s->username);\n\t\t}\n\t}\n\n\tif (tx->rcptcount == 1) {\n\t\tm_printf(tx, \"\\n\\tfor <%s@%s>\",\n\t\t    tx->evp.rcpt.user,\n\t\t    tx->evp.rcpt.domain);\n\t}\n\n\tm_printf(tx, \";\\n\\t%s\\n\", time_to_text(time(&tx->time)));\n\n\tsmtp_enter_state(s, STATE_BODY);\n}\n\nstatic void\nsmtp_message_end(struct smtp_tx *tx)\n{\n\tstruct smtp_session *s;\n\n\ts = tx->session;\n\n\tlog_debug(\"debug: %p: end of message, error=%d\", s, tx->error);\n\n\tfclose(tx->ofile);\n\ttx->ofile = NULL;\n\n\tswitch(tx->error) {\n\tcase TX_OK:\n\t\tsmtp_tx_commit(tx);\n\t\treturn;\t\t\n\n\tcase TX_ERROR_SIZE:\n\t\tsmtp_reply(s, \"554 %s %s: Transaction failed, message too big\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_MESSAGE_TOO_BIG_FOR_SYSTEM),\n\t\t    esc_description(ESC_MESSAGE_TOO_BIG_FOR_SYSTEM));\n\t\tbreak;\n\n\tcase TX_ERROR_LOOP:\n\t\tsmtp_reply(s, \"500 %s %s: Loop detected\",\n\t\t   esc_code(ESC_STATUS_PERMFAIL, ESC_ROUTING_LOOP_DETECTED),\n\t\t   esc_description(ESC_ROUTING_LOOP_DETECTED));\n\t\tbreak;\n\n\tcase TX_ERROR_MALFORMED:\n\t\tsmtp_reply(s, \"550 %s %s: Message is not RFC 2822 compliant\",\n\t\t    esc_code(ESC_STATUS_PERMFAIL, ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED),\n\t\t    esc_description(ESC_DELIVERY_NOT_AUTHORIZED_MESSAGE_REFUSED));\n\t\tbreak;\n\n\tcase TX_ERROR_IO:\n\tcase TX_ERROR_RESOURCES:\n\t\tsmtp_reply(s, \"421 %s Temporary Error\",\n\t\t    esc_code(ESC_STATUS_TEMPFAIL, ESC_OTHER_MAIL_SYSTEM_STATUS));\n\t\tbreak;\n\n\tdefault:\n\t\t/* fatal? */\n\t\tsmtp_reply(s, \"421 Internal server error\");\n\t}\n\n\tsmtp_tx_rollback(tx);\n\tsmtp_tx_free(tx);\n\tsmtp_enter_state(s, STATE_HELO);\n}\n\nstatic int\nsmtp_filter_printf(struct smtp_tx *tx, const char *fmt, ...)\n{\n\tva_list\tap;\n\tint\tlen;\n\n\tif (tx->error)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tlen = io_vprintf(tx->filter, fmt, ap);\n\tva_end(ap);\n\n\tif (len < 0) {\n\t\tlog_warn(\"smtp-in: session %016\"PRIx64\": vfprintf\", tx->session->id);\n\t\ttx->error = TX_ERROR_IO;\n\t}\n\telse\n\t\ttx->odatalen += len;\n\n\treturn len;\n}\n\nstatic int\nsmtp_message_printf(struct smtp_tx *tx, const char *fmt, ...)\n{\n\tva_list\tap;\n\tint\tlen;\n\n\tif (tx->error)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tlen = vfprintf(tx->ofile, fmt, ap);\n\tva_end(ap);\n\n\tif (len == -1) {\n\t\tlog_warn(\"smtp-in: session %016\"PRIx64\": vfprintf\", tx->session->id);\n\t\ttx->error = TX_ERROR_IO;\n\t}\n\telse\n\t\ttx->odatalen += len;\n\n\treturn len;\n}\n\n#define CASE(x) case x : return #x\n\nconst char *\nsmtp_strstate(int state)\n{\n\tstatic char\tbuf[32];\n\n\tswitch (state) {\n\tCASE(STATE_NEW);\n\tCASE(STATE_CONNECTED);\n\tCASE(STATE_TLS);\n\tCASE(STATE_HELO);\n\tCASE(STATE_AUTH_INIT);\n\tCASE(STATE_AUTH_USERNAME);\n\tCASE(STATE_AUTH_PASSWORD);\n\tCASE(STATE_AUTH_FINALIZE);\n\tCASE(STATE_BODY);\n\tCASE(STATE_QUIT);\n\tdefault:\n\t\t(void)snprintf(buf, sizeof(buf), \"STATE_??? (%d)\", state);\n\t\treturn (buf);\n\t}\n}\n\n\nstatic void\nsmtp_report_link_connect(struct smtp_session *s, const char *rdns, int fcrdns,\n    const struct sockaddr_storage *ss_src,\n    const struct sockaddr_storage *ss_dest)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_connect(\"smtp-in\", s->id, rdns, fcrdns, ss_src, ss_dest);\n}\n\nstatic void\nsmtp_report_link_greeting(struct smtp_session *s,\n    const char *domain)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_greeting(\"smtp-in\", s->id, domain);\n}\n\nstatic void\nsmtp_report_link_identify(struct smtp_session *s, const char *method, const char *identity)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_identify(\"smtp-in\", s->id, method, identity);\n}\n\nstatic void\nsmtp_report_link_tls(struct smtp_session *s, const char *ssl)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_tls(\"smtp-in\", s->id, ssl);\n}\n\nstatic void\nsmtp_report_link_disconnect(struct smtp_session *s)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_disconnect(\"smtp-in\", s->id);\n}\n\nstatic void\nsmtp_report_link_auth(struct smtp_session *s, const char *user, const char *result)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_link_auth(\"smtp-in\", s->id, user, result);\n}\n\nstatic void\nsmtp_report_tx_reset(struct smtp_session *s, uint32_t msgid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_reset(\"smtp-in\", s->id, msgid);\n}\n\nstatic void\nsmtp_report_tx_begin(struct smtp_session *s, uint32_t msgid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_begin(\"smtp-in\", s->id, msgid);\n}\n\nstatic void\nsmtp_report_tx_mail(struct smtp_session *s, uint32_t msgid, const char *address, int ok)\n{\n\tchar\tmailaddr[SMTPD_MAXMAILADDRSIZE];\n\tchar    *p;\n\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\tif ((p = strchr(address, '<')) == NULL)\n\t\treturn;\n\t(void)strlcpy(mailaddr, p + 1, sizeof mailaddr);\n\tif ((p = strchr(mailaddr, '>')) == NULL)\n\t\treturn;\n\t*p = '\\0';\n\n\treport_smtp_tx_mail(\"smtp-in\", s->id, msgid, mailaddr, ok);\n}\n\nstatic void\nsmtp_report_tx_rcpt(struct smtp_session *s, uint32_t msgid, const char *address, int ok)\n{\n\tchar\tmailaddr[SMTPD_MAXMAILADDRSIZE];\n\tchar    *p;\n\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\tif ((p = strchr(address, '<')) == NULL)\n\t\treturn;\n\t(void)strlcpy(mailaddr, p + 1, sizeof mailaddr);\n\tif ((p = strchr(mailaddr, '>')) == NULL)\n\t\treturn;\n\t*p = '\\0';\n\n\treport_smtp_tx_rcpt(\"smtp-in\", s->id, msgid, mailaddr, ok);\n}\n\nstatic void\nsmtp_report_tx_envelope(struct smtp_session *s, uint32_t msgid, uint64_t evpid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_envelope(\"smtp-in\", s->id, msgid, evpid);\n}\n\nstatic void\nsmtp_report_tx_data(struct smtp_session *s, uint32_t msgid, int ok)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_data(\"smtp-in\", s->id, msgid, ok);\n}\n\nstatic void\nsmtp_report_tx_commit(struct smtp_session *s, uint32_t msgid, size_t msgsz)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_commit(\"smtp-in\", s->id, msgid, msgsz);\n}\n\nstatic void\nsmtp_report_tx_rollback(struct smtp_session *s, uint32_t msgid)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_tx_rollback(\"smtp-in\", s->id, msgid);\n}\n\nstatic void\nsmtp_report_protocol_client(struct smtp_session *s, const char *command)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_protocol_client(\"smtp-in\", s->id, command);\n}\n\nstatic void\nsmtp_report_protocol_server(struct smtp_session *s, const char *response)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_protocol_server(\"smtp-in\", s->id, response);\n}\n\nstatic void\nsmtp_report_filter_response(struct smtp_session *s, int phase, int response, const char *param)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_filter_response(\"smtp-in\", s->id, phase, response, param);\n}\n\nstatic void\nsmtp_report_timeout(struct smtp_session *s)\n{\n\tif (! SESSION_FILTERED(s))\n\t\treturn;\n\n\treport_smtp_timeout(\"smtp-in\", s->id);\n}\n"], "filenames": ["usr.sbin/smtpd/smtp_session.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [2257], "fixing_code_start_loc": [1], "fixing_code_end_loc": [2255], "type": "CWE-755", "message": "smtp_mailaddr in smtp_session.c in OpenSMTPD 6.6, as used in OpenBSD 6.6 and other products, allows remote attackers to execute arbitrary commands as root via a crafted SMTP session, as demonstrated by shell metacharacters in a MAIL FROM field. This affects the \"uncommented\" default configuration. The issue exists because of an incorrect return value upon failure of input validation.", "other": {"cve": {"id": "CVE-2020-7247", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-29T16:15:12.897", "lastModified": "2022-04-29T13:24:05.263", "vulnStatus": "Analyzed", "cisaExploitAdd": "2022-03-25", "cisaActionDue": "2022-04-15", "cisaRequiredAction": "Apply updates per vendor instructions.", "cisaVulnerabilityName": "OpenSMTPD Remote Code Execution Vulnerability", "descriptions": [{"lang": "en", "value": "smtp_mailaddr in smtp_session.c in OpenSMTPD 6.6, as used in OpenBSD 6.6 and other products, allows remote attackers to execute arbitrary commands as root via a crafted SMTP session, as demonstrated by shell metacharacters in a MAIL FROM field. This affects the \"uncommented\" default configuration. The issue exists because of an incorrect return value upon failure of input validation."}, {"lang": "es", "value": "La funci\u00f3n smtp_mailaddr en el archivo smtp_session.c en OpenSMTPD versi\u00f3n 6.6, como es usado en OpenBSD versi\u00f3n 6.6 y otros productos, permite a atacantes remotos ejecutar comandos arbitrarios como root por medio de una sesi\u00f3n SMTP dise\u00f1ada, como es demostrado por metacaracteres de shell en un campo MAIL FROM. Esto afecta la configuraci\u00f3n predeterminada \"uncommented\". El problema se presenta debido a un valor de retorno incorrecto tras un fallo en la comprobaci\u00f3n de entrada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}, {"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:opensmtpd:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "E2D1D6E5-21BA-40CC-870F-A940DD814532"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/156137/OpenBSD-OpenSMTPD-Privilege-Escalation-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/156145/OpenSMTPD-6.6.2-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/156249/OpenSMTPD-MAIL-FROM-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/156295/OpenSMTPD-6.6.1-Local-Privilege-Escalation.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/162093/OpenBSD-OpenSMTPD-6.6-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://seclists.org/fulldisclosure/2020/Jan/49", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/01/28/3", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/openbsd/src/commit/9dcfda045474d8903224d175907bfc29761dcb45", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OPH4QU4DNVHA7ACFXMYFCEP5PSXXPN4E/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/51", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4268-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4611", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.kb.cert.org/vuls/id/390745", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "US Government Resource"]}, {"url": "https://www.openbsd.org/security.html", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/9dcfda045474d8903224d175907bfc29761dcb45"}}