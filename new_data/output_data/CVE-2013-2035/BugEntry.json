{"buggy_code": ["/*******************************************************************************\n * Copyright (C) 2009-2011 FuseSource Corp.\n * Copyright (c) 2000, 2009 IBM Corporation and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *******************************************************************************/\npackage org.fusesource.hawtjni.runtime;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\n\n/**\n * Used to optionally extract and load a JNI library.\n * \n * It will search for the library in order at the following locations:\n * <ol>\n * <li> in the custom library path: If the \"library.${name}.path\" System property is set to a directory \n *   <ol>\n *   <li> \"${name}-${version}\" if the version can be determined.\n *   <li> \"${name}\"\n *   </ol>\n * <li> system library path: This is where the JVM looks for JNI libraries by default.\n *   <ol>\n *   <li> \"${name}-${version}\" if the version can be determined.\n *   <li> \"${name}\"\n *   </ol>\n * <li> classpath path: If the JNI library can be found on the classpath, it will get extracted\n * and and then loaded.  This way you can embed your JNI libraries into your packaged JAR files.\n * They are looked up as resources in this order:\n *   <ol>\n *   <li> \"META-INF/native/${platform}/${library}\" : Store your library here if you want to embed more\n *   than one platform JNI library in the jar.\n *   <li> \"META-INF/native/${library}\": Store your library here if your JAR is only going to embedding one\n *   platform library.\n *   </ol>\n * The file extraction is attempted until it succeeds in the following directories.\n *   <ol>\n *   <li> The directory pointed to by the \"library.${name}.path\" System property (if set)\n *   <li> a temporary directory (uses the \"java.io.tmpdir\" System property)\n *   </ol>\n * </ol>\n * \n * where: \n * <ul>\n * <li>\"${name}\" is the name of library\n * <li>\"${version}\" is the value of \"library.${name}.version\" System property if set.\n *       Otherwise it is set to the ImplementationVersion property of the JAR's Manifest</li> \n * <li>\"${os}\" is your operating system, for example \"osx\", \"linux\", or \"windows\"</li> \n * <li>\"${bit-model}\" is \"64\" if the JVM process is a 64 bit process, otherwise it's \"32\" if the \n * JVM is a 32 bit process</li> \n * <li>\"${platform}\" is \"${os}${bit-model}\", for example \"linux32\" or \"osx64\" </li> \n * <li>\"${library}\": is the normal jni library name for the platform.  For example \"${name}.dll\" on\n *     windows, \"lib${name}.jnilib\" on OS X, and \"lib${name}.so\" on linux</li> \n * </ul>\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino</a>\n */\npublic class Library {\n\n    static final String SLASH = System.getProperty(\"file.separator\");\n\n    final private String name;\n    final private String version;\n    final private ClassLoader classLoader;\n    private boolean loaded;\n    \n    public Library(String name) {\n        this(name, null, null);\n    }\n    \n    public Library(String name, Class<?> clazz) {\n        this(name, version(clazz), clazz.getClassLoader());\n    }\n    \n    public Library(String name, String version) {\n        this(name, version, null);\n    }\n    \n    public Library(String name, String version, ClassLoader classLoader) {\n        if( name == null ) {\n            throw new IllegalArgumentException(\"name cannot be null\");\n        }\n        this.name = name;\n        this.version = version;\n        this.classLoader= classLoader;\n    }\n    \n    private static String version(Class<?> clazz) {\n        try {\n            return clazz.getPackage().getImplementationVersion();\n        } catch (Throwable e) {\n        }\n        return null;\n    }\n\n    public static String getOperatingSystem() {\n        String name = System.getProperty(\"os.name\").toLowerCase().trim();\n        if( name.startsWith(\"linux\") ) {\n            return \"linux\";\n        }\n        if( name.startsWith(\"mac os x\") ) {\n            return \"osx\";\n        }\n        if( name.startsWith(\"win\") ) {\n            return \"windows\";\n        }\n        return name.replaceAll(\"\\\\W+\", \"_\");\n        \n    }\n\n    public static String getPlatform() {\n        return getOperatingSystem()+getBitModel();\n    }\n    \n    public static int getBitModel() {\n        String prop = System.getProperty(\"sun.arch.data.model\"); \n        if (prop == null) {\n            prop = System.getProperty(\"com.ibm.vm.bitmode\");\n        }\n        if( prop!=null ) {\n            return Integer.parseInt(prop);\n        }\n        return -1; // we don't know..  \n    }\n\n    /**\n     * \n     */\n    synchronized public void load() {\n        if( loaded ) {\n            return;\n        }\n        doLoad();\n        loaded = true;\n    }\n    \n    private void doLoad() {\n        /* Perhaps a custom version is specified */\n        String version = System.getProperty(\"library.\"+name+\".version\"); \n        if (version == null) {\n            version = this.version; \n        }\n        ArrayList<String> errors = new ArrayList<String>();\n\n        /* Try loading library from a custom library path */\n        String customPath = System.getProperty(\"library.\"+name+\".path\");\n        if (customPath != null) {\n            if( version!=null && load(errors, file(customPath, map(name + \"-\" + version))) ) \n                return;\n            if( load(errors, file(customPath, map(name))) )\n                return;\n        }\n\n        /* Try loading library from java library path */\n        if( version!=null && load(errors, name + getBitModel() + \"-\" + version) ) \n            return;        \n        if( version!=null && load(errors, name + \"-\" + version) ) \n            return;        \n        if( load(errors, name ) )\n            return;\n        \n        \n        /* Try extracting the library from the jar */\n        if( classLoader!=null ) {\n            if( exractAndLoad(errors, version, customPath, getPlatformSpecifcResourcePath()) ) \n                return;\n            if( exractAndLoad(errors, version, customPath, getOperatingSystemSpecifcResourcePath()) ) \n                return;\n            // For the simpler case where only 1 platform lib is getting packed into the jar\n            if( exractAndLoad(errors, version, customPath, getResorucePath()) )\n                return;\n        }\n\n        /* Failed to find the library */\n        throw new UnsatisfiedLinkError(\"Could not load library. Reasons: \" + errors.toString()); \n    }\n\n    final public String getOperatingSystemSpecifcResourcePath() {\n        return getPlatformSpecifcResourcePath(getOperatingSystem());\n    }\n    final public String getPlatformSpecifcResourcePath() {\n        return getPlatformSpecifcResourcePath(getPlatform());\n    }\n    final public String getPlatformSpecifcResourcePath(String platform) {\n        return \"META-INF/native/\"+platform+\"/\"+map(name);\n    }\n\n    final public String getResorucePath() {\n        return \"META-INF/native/\"+map(name);\n    }\n\n    final public String getLibraryFileName() {\n        return map(name);\n    }\n\n    \n    private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n            \n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n            }\n            \n            if( customPath!=null ) {\n                // Try to extract it to the custom path...\n                File target = file(customPath, map(libName));\n                if( extract(errors, resource, target) ) {\n                    if( load(errors, target) ) {\n                        return true;\n                    }\n                }\n            }\n            \n            // Fall back to extracting to the tmp dir\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = file(customPath, map(libName));\n            if( extract(errors, resource, target) ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private File file(String ...paths) {\n        File rc = null ;\n        for (String path : paths) {\n            if( rc == null ) {\n                rc = new File(path);\n            } else {\n                rc = new File(rc, path);\n            }\n        }\n        return rc;\n    }\n    \n    private String map(String libName) {\n        /*\n         * libraries in the Macintosh use the extension .jnilib but the some\n         * VMs map to .dylib.\n         */\n        libName = System.mapLibraryName(libName);\n        String ext = \".dylib\"; \n        if (libName.endsWith(ext)) {\n            libName = libName.substring(0, libName.length() - ext.length()) + \".jnilib\"; \n        }\n        return libName;\n    }\n\n    private boolean extract(ArrayList<String> errors, URL source, File target) {\n        FileOutputStream os = null;\n        InputStream is = null;\n        boolean extracting = false;\n        try {\n            if (!target.exists() || isStale(source, target) ) {\n                is = source.openStream();\n                if (is != null) {\n                    byte[] buffer = new byte[4096];\n                    os = new FileOutputStream(target);\n                    extracting = true;\n                    int read;\n                    while ((read = is.read(buffer)) != -1) {\n                        os.write(buffer, 0, read);\n                    }\n                    os.close();\n                    is.close();\n                    chmod(\"755\", target);\n                }\n            }\n        } catch (Throwable e) {\n            try {\n                if (os != null)\n                    os.close();\n            } catch (IOException e1) {\n            }\n            try {\n                if (is != null)\n                    is.close();\n            } catch (IOException e1) {\n            }\n            if (extracting && target.exists())\n                target.delete();\n            errors.add(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n\n    private boolean isStale(URL source, File target) {\n        \n        if( source.getProtocol().equals(\"jar\") ) {\n            // unwrap the jar protocol...\n            try {\n                String parts[] = source.getFile().split(Pattern.quote(\"!\"));\n                source = new URL(parts[0]);\n            } catch (MalformedURLException e) {\n                return false;\n            }\n        }\n        \n        File sourceFile=null;\n        if( source.getProtocol().equals(\"file\") ) {\n            sourceFile = new File(source.getFile());\n        }\n        if( sourceFile!=null && sourceFile.exists() ) {\n            if( sourceFile.lastModified() > target.lastModified() ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void chmod(String permision, File path) {\n        if (getPlatform().startsWith(\"windows\"))\n            return; \n        try {\n            Runtime.getRuntime().exec(new String[] { \"chmod\", permision, path.getCanonicalPath() }).waitFor(); \n        } catch (Throwable e) {\n        }\n    }\n\n    private boolean load(ArrayList<String> errors, File lib) {\n        try {\n            System.load(lib.getPath());\n            return true;\n        } catch (UnsatisfiedLinkError e) {\n            errors.add(e.getMessage());\n        }\n        return false;\n    }\n    \n    private boolean load(ArrayList<String> errors, String lib) {\n        try {\n            System.loadLibrary(lib);\n            return true;\n        } catch (UnsatisfiedLinkError e) {\n            errors.add(e.getMessage());\n        }\n        return false;\n    }\n\n}\n"], "fixing_code": ["/*******************************************************************************\n * Copyright (C) 2009-2011 FuseSource Corp.\n * Copyright (c) 2000, 2009 IBM Corporation and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *******************************************************************************/\npackage org.fusesource.hawtjni.runtime;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.regex.Pattern;\n\n/**\n * Used to optionally extract and load a JNI library.\n * \n * It will search for the library in order at the following locations:\n * <ol>\n * <li> in the custom library path: If the \"library.${name}.path\" System property is set to a directory \n *   <ol>\n *   <li> \"${name}-${version}\" if the version can be determined.\n *   <li> \"${name}\"\n *   </ol>\n * <li> system library path: This is where the JVM looks for JNI libraries by default.\n *   <ol>\n *   <li> \"${name}-${version}\" if the version can be determined.\n *   <li> \"${name}\"\n *   </ol>\n * <li> classpath path: If the JNI library can be found on the classpath, it will get extracted\n * and and then loaded.  This way you can embed your JNI libraries into your packaged JAR files.\n * They are looked up as resources in this order:\n *   <ol>\n *   <li> \"META-INF/native/${platform}/${library}\" : Store your library here if you want to embed more\n *   than one platform JNI library in the jar.\n *   <li> \"META-INF/native/${library}\": Store your library here if your JAR is only going to embedding one\n *   platform library.\n *   </ol>\n * The file extraction is attempted until it succeeds in the following directories.\n *   <ol>\n *   <li> The directory pointed to by the \"library.${name}.path\" System property (if set)\n *   <li> a temporary directory (uses the \"java.io.tmpdir\" System property)\n *   </ol>\n * </ol>\n * \n * where: \n * <ul>\n * <li>\"${name}\" is the name of library\n * <li>\"${version}\" is the value of \"library.${name}.version\" System property if set.\n *       Otherwise it is set to the ImplementationVersion property of the JAR's Manifest</li> \n * <li>\"${os}\" is your operating system, for example \"osx\", \"linux\", or \"windows\"</li> \n * <li>\"${bit-model}\" is \"64\" if the JVM process is a 64 bit process, otherwise it's \"32\" if the \n * JVM is a 32 bit process</li> \n * <li>\"${platform}\" is \"${os}${bit-model}\", for example \"linux32\" or \"osx64\" </li> \n * <li>\"${library}\": is the normal jni library name for the platform.  For example \"${name}.dll\" on\n *     windows, \"lib${name}.jnilib\" on OS X, and \"lib${name}.so\" on linux</li> \n * </ul>\n * \n * @author <a href=\"http://hiramchirino.com\">Hiram Chirino</a>\n */\npublic class Library {\n\n    static final String SLASH = System.getProperty(\"file.separator\");\n\n    final private String name;\n    final private String version;\n    final private ClassLoader classLoader;\n    private boolean loaded;\n    \n    public Library(String name) {\n        this(name, null, null);\n    }\n    \n    public Library(String name, Class<?> clazz) {\n        this(name, version(clazz), clazz.getClassLoader());\n    }\n    \n    public Library(String name, String version) {\n        this(name, version, null);\n    }\n    \n    public Library(String name, String version, ClassLoader classLoader) {\n        if( name == null ) {\n            throw new IllegalArgumentException(\"name cannot be null\");\n        }\n        this.name = name;\n        this.version = version;\n        this.classLoader= classLoader;\n    }\n    \n    private static String version(Class<?> clazz) {\n        try {\n            return clazz.getPackage().getImplementationVersion();\n        } catch (Throwable e) {\n        }\n        return null;\n    }\n\n    public static String getOperatingSystem() {\n        String name = System.getProperty(\"os.name\").toLowerCase().trim();\n        if( name.startsWith(\"linux\") ) {\n            return \"linux\";\n        }\n        if( name.startsWith(\"mac os x\") ) {\n            return \"osx\";\n        }\n        if( name.startsWith(\"win\") ) {\n            return \"windows\";\n        }\n        return name.replaceAll(\"\\\\W+\", \"_\");\n        \n    }\n\n    public static String getPlatform() {\n        return getOperatingSystem()+getBitModel();\n    }\n    \n    public static int getBitModel() {\n        String prop = System.getProperty(\"sun.arch.data.model\"); \n        if (prop == null) {\n            prop = System.getProperty(\"com.ibm.vm.bitmode\");\n        }\n        if( prop!=null ) {\n            return Integer.parseInt(prop);\n        }\n        return -1; // we don't know..  \n    }\n\n    /**\n     * \n     */\n    synchronized public void load() {\n        if( loaded ) {\n            return;\n        }\n        doLoad();\n        loaded = true;\n    }\n    \n    private void doLoad() {\n        /* Perhaps a custom version is specified */\n        String version = System.getProperty(\"library.\"+name+\".version\"); \n        if (version == null) {\n            version = this.version; \n        }\n        ArrayList<String> errors = new ArrayList<String>();\n\n        /* Try loading library from a custom library path */\n        String customPath = System.getProperty(\"library.\"+name+\".path\");\n        if (customPath != null) {\n            if( version!=null && load(errors, file(customPath, map(name + \"-\" + version))) ) \n                return;\n            if( load(errors, file(customPath, map(name))) )\n                return;\n        }\n\n        /* Try loading library from java library path */\n        if( version!=null && load(errors, name + getBitModel() + \"-\" + version) ) \n            return;        \n        if( version!=null && load(errors, name + \"-\" + version) ) \n            return;        \n        if( load(errors, name ) )\n            return;\n        \n        \n        /* Try extracting the library from the jar */\n        if( classLoader!=null ) {\n            if( exractAndLoad(errors, version, customPath, getPlatformSpecifcResourcePath()) ) \n                return;\n            if( exractAndLoad(errors, version, customPath, getOperatingSystemSpecifcResourcePath()) ) \n                return;\n            // For the simpler case where only 1 platform lib is getting packed into the jar\n            if( exractAndLoad(errors, version, customPath, getResorucePath()) )\n                return;\n        }\n\n        /* Failed to find the library */\n        throw new UnsatisfiedLinkError(\"Could not load library. Reasons: \" + errors.toString()); \n    }\n\n    final public String getOperatingSystemSpecifcResourcePath() {\n        return getPlatformSpecifcResourcePath(getOperatingSystem());\n    }\n    final public String getPlatformSpecifcResourcePath() {\n        return getPlatformSpecifcResourcePath(getPlatform());\n    }\n    final public String getPlatformSpecifcResourcePath(String platform) {\n        return \"META-INF/native/\"+platform+\"/\"+map(name);\n    }\n\n    final public String getResorucePath() {\n        return \"META-INF/native/\"+map(name);\n    }\n\n    final public String getLibraryFileName() {\n        return map(name);\n    }\n\n    \n    private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n\n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n            }\n            String []libNameParts = map(libName).split(\"\\\\.\");\n            String prefix = libNameParts[0]+\"-\";\n            String suffix = \".\"+libNameParts[1];\n\n            if( customPath!=null ) {\n                // Try to extract it to the custom path...\n                File target = extract(errors, resource, prefix, suffix, file(customPath));\n                if( target!=null ) {\n                    if( load(errors, target) ) {\n                        return true;\n                    }\n                }\n            }\n            \n            // Fall back to extracting to the tmp dir\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = extract(errors, resource, prefix, suffix, file(customPath));\n            if( target!=null ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private File file(String ...paths) {\n        File rc = null ;\n        for (String path : paths) {\n            if( rc == null ) {\n                rc = new File(path);\n            } else {\n                rc = new File(rc, path);\n            }\n        }\n        return rc;\n    }\n    \n    private String map(String libName) {\n        /*\n         * libraries in the Macintosh use the extension .jnilib but the some\n         * VMs map to .dylib.\n         */\n        libName = System.mapLibraryName(libName);\n        String ext = \".dylib\"; \n        if (libName.endsWith(ext)) {\n            libName = libName.substring(0, libName.length() - ext.length()) + \".jnilib\"; \n        }\n        return libName;\n    }\n\n    private File extract(ArrayList<String> errors, URL source, String prefix, String suffix, File directory) {\n        File target = null;\n        try {\n            FileOutputStream os = null;\n            InputStream is = null;\n            try {\n                target = File.createTempFile(prefix, suffix, directory);\n                is = source.openStream();\n                if (is != null) {\n                    byte[] buffer = new byte[4096];\n                    os = new FileOutputStream(target);\n                    int read;\n                    while ((read = is.read(buffer)) != -1) {\n                        os.write(buffer, 0, read);\n                    }\n                    chmod(\"755\", target);\n                }\n                target.deleteOnExit();\n                return target;\n            } finally {\n                close(os);\n                close(is);\n            }\n        } catch (Throwable e) {\n            if( target!=null ) {\n                target.delete();\n            }\n            errors.add(e.getMessage());\n        }\n        return null;\n    }\n\n    static private void close(Closeable file) {\n        if(file!=null) {\n            try {\n                file.close();\n            } catch (Exception ignore) {\n            }\n        }\n    }\n\n    private void chmod(String permision, File path) {\n        if (getPlatform().startsWith(\"windows\"))\n            return; \n        try {\n            Runtime.getRuntime().exec(new String[] { \"chmod\", permision, path.getCanonicalPath() }).waitFor(); \n        } catch (Throwable e) {\n        }\n    }\n\n    private boolean load(ArrayList<String> errors, File lib) {\n        try {\n            System.load(lib.getPath());\n            return true;\n        } catch (UnsatisfiedLinkError e) {\n            errors.add(e.getMessage());\n        }\n        return false;\n    }\n    \n    private boolean load(ArrayList<String> errors, String lib) {\n        try {\n            System.loadLibrary(lib);\n            return true;\n        } catch (UnsatisfiedLinkError e) {\n            errors.add(e.getMessage());\n        }\n        return false;\n    }\n\n}\n"], "filenames": ["hawtjni-runtime/src/main/java/org/fusesource/hawtjni/runtime/Library.java"], "buggy_code_start_loc": [12], "buggy_code_end_loc": [323], "fixing_code_start_loc": [12], "fixing_code_end_loc": [302], "type": "CWE-94", "message": "Race condition in hawtjni-runtime/src/main/java/org/fusesource/hawtjni/runtime/Library.java in HawtJNI before 1.8, when a custom library path is not specified, allows local users to execute arbitrary Java code by overwriting a temporary JAR file with a predictable name in /tmp.", "other": {"cve": {"id": "CVE-2013-2035", "sourceIdentifier": "secalert@redhat.com", "published": "2013-08-28T23:55:04.823", "lastModified": "2015-01-18T02:59:16.303", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in hawtjni-runtime/src/main/java/org/fusesource/hawtjni/runtime/Library.java in HawtJNI before 1.8, when a custom library path is not specified, allows local users to execute arbitrary Java code by overwriting a temporary JAR file with a predictable name in /tmp."}, {"lang": "es", "value": "Una condici\u00f3n de carrera en la biblioteca hawtjni-runtime/src/main/ java/org/fusesource/hawtjni/runtime/Library.java en HawtJNI anterior a versi\u00f3n 1.8, cuando una ruta (path) de biblioteca personalizada no se especifica, permite a los usuarios locales ejecutar c\u00f3digo Java arbitrario sobrescribiendo un Archivo JAR temporal con un nombre predecible en /tmp."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7", "matchCriteriaId": "769B44C8-CDCD-4C7D-8973-5C5DDAA9094F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "25DBA7F9-4177-4AF8-AAD5-DC4027F020DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "2E4FD38A-4D4F-4369-B6E2-AD2E50A8F889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "A1966148-E36A-427B-90FF-E7250C3D7645"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "F332821B-AFD7-41B1-AFE5-ECEE08C2D8BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "83996644-8ED7-4678-8CB9-8CA3D4C40025"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "1D8632FC-0843-4C52-BB67-BD5181FF2293"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:hawtjni:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "27A5B63E-1CD9-4D57-A46B-A196683604FD"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2013-1029.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1784.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1785.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1786.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0029.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0245.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0254.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0400.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0034.html", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1029431", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-2035", "source": "secalert@redhat.com"}, {"url": "https://github.com/fusesource/hawtjni/commit/92c266170ce98edc200c656bd034a237098b8aa5", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/jline/jline2/issues/85", "source": "secalert@redhat.com"}, {"url": "https://github.com/jruby/jruby/issues/732", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/fusesource/hawtjni/commit/92c266170ce98edc200c656bd034a237098b8aa5"}}