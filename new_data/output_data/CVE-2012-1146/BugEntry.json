{"buggy_code": ["/* memcontrol.c - Memory Controller\n *\n * Copyright IBM Corporation, 2007\n * Author Balbir Singh <balbir@linux.vnet.ibm.com>\n *\n * Copyright 2007 OpenVZ SWsoft Inc\n * Author: Pavel Emelianov <xemul@openvz.org>\n *\n * Memory thresholds\n * Copyright (C) 2009 Nokia Corporation\n * Author: Kirill A. Shutemov\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include <linux/res_counter.h>\n#include <linux/memcontrol.h>\n#include <linux/cgroup.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/page-flags.h>\n#include <linux/backing-dev.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/limits.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/spinlock.h>\n#include <linux/eventfd.h>\n#include <linux/sort.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/mm_inline.h>\n#include <linux/page_cgroup.h>\n#include <linux/cpu.h>\n#include <linux/oom.h>\n#include \"internal.h\"\n#include <net/sock.h>\n#include <net/tcp_memcontrol.h>\n\n#include <asm/uaccess.h>\n\n#include <trace/events/vmscan.h>\n\nstruct cgroup_subsys mem_cgroup_subsys __read_mostly;\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\nstruct mem_cgroup *root_mem_cgroup __read_mostly;\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\n/* Turned on only when memory cgroup is enabled && really_do_swap_account = 1 */\nint do_swap_account __read_mostly;\n\n/* for remember boot option*/\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP_ENABLED\nstatic int really_do_swap_account __initdata = 1;\n#else\nstatic int really_do_swap_account __initdata = 0;\n#endif\n\n#else\n#define do_swap_account\t\t(0)\n#endif\n\n\n/*\n * Statistics for memory cgroup.\n */\nenum mem_cgroup_stat_index {\n\t/*\n\t * For MEM_CONTAINER_TYPE_ALL, usage = pagecache + rss.\n\t */\n\tMEM_CGROUP_STAT_CACHE, \t   /* # of pages charged as cache */\n\tMEM_CGROUP_STAT_RSS,\t   /* # of pages charged as anon rss */\n\tMEM_CGROUP_STAT_FILE_MAPPED,  /* # of pages charged as file rss */\n\tMEM_CGROUP_STAT_SWAPOUT, /* # of pages, swapped out */\n\tMEM_CGROUP_STAT_DATA, /* end of data requires synchronization */\n\tMEM_CGROUP_ON_MOVE,\t/* someone is moving account between groups */\n\tMEM_CGROUP_STAT_NSTATS,\n};\n\nenum mem_cgroup_events_index {\n\tMEM_CGROUP_EVENTS_PGPGIN,\t/* # of pages paged in */\n\tMEM_CGROUP_EVENTS_PGPGOUT,\t/* # of pages paged out */\n\tMEM_CGROUP_EVENTS_COUNT,\t/* # of pages paged in/out */\n\tMEM_CGROUP_EVENTS_PGFAULT,\t/* # of page-faults */\n\tMEM_CGROUP_EVENTS_PGMAJFAULT,\t/* # of major page-faults */\n\tMEM_CGROUP_EVENTS_NSTATS,\n};\n/*\n * Per memcg event counter is incremented at every pagein/pageout. With THP,\n * it will be incremated by the number of pages. This counter is used for\n * for trigger some periodic events. This is straightforward and better\n * than using jiffies etc. to handle periodic memcg event.\n */\nenum mem_cgroup_events_target {\n\tMEM_CGROUP_TARGET_THRESH,\n\tMEM_CGROUP_TARGET_SOFTLIMIT,\n\tMEM_CGROUP_TARGET_NUMAINFO,\n\tMEM_CGROUP_NTARGETS,\n};\n#define THRESHOLDS_EVENTS_TARGET (128)\n#define SOFTLIMIT_EVENTS_TARGET (1024)\n#define NUMAINFO_EVENTS_TARGET\t(1024)\n\nstruct mem_cgroup_stat_cpu {\n\tlong count[MEM_CGROUP_STAT_NSTATS];\n\tunsigned long events[MEM_CGROUP_EVENTS_NSTATS];\n\tunsigned long targets[MEM_CGROUP_NTARGETS];\n};\n\nstruct mem_cgroup_reclaim_iter {\n\t/* css_id of the last scanned hierarchy member */\n\tint position;\n\t/* scan generation, increased every round-trip */\n\tunsigned int generation;\n};\n\n/*\n * per-zone information in memory controller.\n */\nstruct mem_cgroup_per_zone {\n\tstruct lruvec\t\tlruvec;\n\tunsigned long\t\tcount[NR_LRU_LISTS];\n\n\tstruct mem_cgroup_reclaim_iter reclaim_iter[DEF_PRIORITY + 1];\n\n\tstruct zone_reclaim_stat reclaim_stat;\n\tstruct rb_node\t\ttree_node;\t/* RB tree node */\n\tunsigned long long\tusage_in_excess;/* Set to the value by which */\n\t\t\t\t\t\t/* the soft limit is exceeded*/\n\tbool\t\t\ton_tree;\n\tstruct mem_cgroup\t*mem;\t\t/* Back pointer, we cannot */\n\t\t\t\t\t\t/* use container_of\t   */\n};\n/* Macro for accessing counter */\n#define MEM_CGROUP_ZSTAT(mz, idx)\t((mz)->count[(idx)])\n\nstruct mem_cgroup_per_node {\n\tstruct mem_cgroup_per_zone zoneinfo[MAX_NR_ZONES];\n};\n\nstruct mem_cgroup_lru_info {\n\tstruct mem_cgroup_per_node *nodeinfo[MAX_NUMNODES];\n};\n\n/*\n * Cgroups above their limits are maintained in a RB-Tree, independent of\n * their hierarchy representation\n */\n\nstruct mem_cgroup_tree_per_zone {\n\tstruct rb_root rb_root;\n\tspinlock_t lock;\n};\n\nstruct mem_cgroup_tree_per_node {\n\tstruct mem_cgroup_tree_per_zone rb_tree_per_zone[MAX_NR_ZONES];\n};\n\nstruct mem_cgroup_tree {\n\tstruct mem_cgroup_tree_per_node *rb_tree_per_node[MAX_NUMNODES];\n};\n\nstatic struct mem_cgroup_tree soft_limit_tree __read_mostly;\n\nstruct mem_cgroup_threshold {\n\tstruct eventfd_ctx *eventfd;\n\tu64 threshold;\n};\n\n/* For threshold */\nstruct mem_cgroup_threshold_ary {\n\t/* An array index points to threshold just below usage. */\n\tint current_threshold;\n\t/* Size of entries[] */\n\tunsigned int size;\n\t/* Array of thresholds */\n\tstruct mem_cgroup_threshold entries[0];\n};\n\nstruct mem_cgroup_thresholds {\n\t/* Primary thresholds array */\n\tstruct mem_cgroup_threshold_ary *primary;\n\t/*\n\t * Spare threshold array.\n\t * This is needed to make mem_cgroup_unregister_event() \"never fail\".\n\t * It must be able to store at least primary->size - 1 entries.\n\t */\n\tstruct mem_cgroup_threshold_ary *spare;\n};\n\n/* for OOM */\nstruct mem_cgroup_eventfd_list {\n\tstruct list_head list;\n\tstruct eventfd_ctx *eventfd;\n};\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\n\n/*\n * The memory controller data structure. The memory controller controls both\n * page cache and RSS per cgroup. We would eventually like to provide\n * statistics based on the statistics developed by Rik Van Riel for clock-pro,\n * to help the administrator determine what knobs to tune.\n *\n * TODO: Add a water mark for the memory controller. Reclaim will begin when\n * we hit the water mark. May be even add a low water mark, such that\n * no reclaim occurs from a cgroup at it's low water mark, this is\n * a feature that will be implemented much later in the future.\n */\nstruct mem_cgroup {\n\tstruct cgroup_subsys_state css;\n\t/*\n\t * the counter to account for memory usage\n\t */\n\tstruct res_counter res;\n\t/*\n\t * the counter to account for mem+swap usage.\n\t */\n\tstruct res_counter memsw;\n\t/*\n\t * Per cgroup active and inactive list, similar to the\n\t * per zone LRU lists.\n\t */\n\tstruct mem_cgroup_lru_info info;\n\tint last_scanned_node;\n#if MAX_NUMNODES > 1\n\tnodemask_t\tscan_nodes;\n\tatomic_t\tnumainfo_events;\n\tatomic_t\tnumainfo_updating;\n#endif\n\t/*\n\t * Should the accounting and control be hierarchical, per subtree?\n\t */\n\tbool use_hierarchy;\n\n\tbool\t\toom_lock;\n\tatomic_t\tunder_oom;\n\n\tatomic_t\trefcnt;\n\n\tint\tswappiness;\n\t/* OOM-Killer disable */\n\tint\t\toom_kill_disable;\n\n\t/* set when res.limit == memsw.limit */\n\tbool\t\tmemsw_is_minimum;\n\n\t/* protect arrays of thresholds */\n\tstruct mutex thresholds_lock;\n\n\t/* thresholds for memory usage. RCU-protected */\n\tstruct mem_cgroup_thresholds thresholds;\n\n\t/* thresholds for mem+swap usage. RCU-protected */\n\tstruct mem_cgroup_thresholds memsw_thresholds;\n\n\t/* For oom notifier event fd */\n\tstruct list_head oom_notify;\n\n\t/*\n\t * Should we move charges of a task when a task is moved into this\n\t * mem_cgroup ? And what type of charges should we move ?\n\t */\n\tunsigned long \tmove_charge_at_immigrate;\n\t/*\n\t * percpu counter.\n\t */\n\tstruct mem_cgroup_stat_cpu *stat;\n\t/*\n\t * used when a cpu is offlined or other synchronizations\n\t * See mem_cgroup_read_stat().\n\t */\n\tstruct mem_cgroup_stat_cpu nocpu_base;\n\tspinlock_t pcp_counter_lock;\n\n#ifdef CONFIG_INET\n\tstruct tcp_memcontrol tcp_mem;\n#endif\n};\n\n/* Stuffs for move charges at task migration. */\n/*\n * Types of charges to be moved. \"move_charge_at_immitgrate\" is treated as a\n * left-shifted bitmap of these types.\n */\nenum move_type {\n\tMOVE_CHARGE_TYPE_ANON,\t/* private anonymous page and swap of it */\n\tMOVE_CHARGE_TYPE_FILE,\t/* file page(including tmpfs) and swap of it */\n\tNR_MOVE_TYPE,\n};\n\n/* \"mc\" and its members are protected by cgroup_mutex */\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\n\nstatic bool move_anon(void)\n{\n\treturn test_bit(MOVE_CHARGE_TYPE_ANON,\n\t\t\t\t\t&mc.to->move_charge_at_immigrate);\n}\n\nstatic bool move_file(void)\n{\n\treturn test_bit(MOVE_CHARGE_TYPE_FILE,\n\t\t\t\t\t&mc.to->move_charge_at_immigrate);\n}\n\n/*\n * Maximum loops in mem_cgroup_hierarchical_reclaim(), used for soft\n * limit reclaim to prevent infinite loops, if they ever occur.\n */\n#define\tMEM_CGROUP_MAX_RECLAIM_LOOPS\t\t(100)\n#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t(2)\n\nenum charge_type {\n\tMEM_CGROUP_CHARGE_TYPE_CACHE = 0,\n\tMEM_CGROUP_CHARGE_TYPE_MAPPED,\n\tMEM_CGROUP_CHARGE_TYPE_SHMEM,\t/* used by page migration of shmem */\n\tMEM_CGROUP_CHARGE_TYPE_FORCE,\t/* used by force_empty */\n\tMEM_CGROUP_CHARGE_TYPE_SWAPOUT,\t/* for accounting swapcache */\n\tMEM_CGROUP_CHARGE_TYPE_DROP,\t/* a page was unused swap cache */\n\tNR_CHARGE_TYPE,\n};\n\n/* for encoding cft->private value on file */\n#define _MEM\t\t\t(0)\n#define _MEMSWAP\t\t(1)\n#define _OOM_TYPE\t\t(2)\n#define MEMFILE_PRIVATE(x, val)\t(((x) << 16) | (val))\n#define MEMFILE_TYPE(val)\t(((val) >> 16) & 0xffff)\n#define MEMFILE_ATTR(val)\t((val) & 0xffff)\n/* Used for OOM nofiier */\n#define OOM_CONTROL\t\t(0)\n\n/*\n * Reclaim flags for mem_cgroup_hierarchical_reclaim\n */\n#define MEM_CGROUP_RECLAIM_NOSWAP_BIT\t0x0\n#define MEM_CGROUP_RECLAIM_NOSWAP\t(1 << MEM_CGROUP_RECLAIM_NOSWAP_BIT)\n#define MEM_CGROUP_RECLAIM_SHRINK_BIT\t0x1\n#define MEM_CGROUP_RECLAIM_SHRINK\t(1 << MEM_CGROUP_RECLAIM_SHRINK_BIT)\n\nstatic void mem_cgroup_get(struct mem_cgroup *memcg);\nstatic void mem_cgroup_put(struct mem_cgroup *memcg);\n\n/* Writing them here to avoid exposing memcg's inner layout */\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM\n#include <net/sock.h>\n#include <net/ip.h>\n\nstatic bool mem_cgroup_is_root(struct mem_cgroup *memcg);\nvoid sock_update_memcg(struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled) {\n\t\tstruct mem_cgroup *memcg;\n\n\t\tBUG_ON(!sk->sk_prot->proto_cgroup);\n\n\t\t/* Socket cloning can throw us here with sk_cgrp already\n\t\t * filled. It won't however, necessarily happen from\n\t\t * process context. So the test for root memcg given\n\t\t * the current task's memcg won't help us in this case.\n\t\t *\n\t\t * Respecting the original socket's memcg is a better\n\t\t * decision in this case.\n\t\t */\n\t\tif (sk->sk_cgrp) {\n\t\t\tBUG_ON(mem_cgroup_is_root(sk->sk_cgrp->memcg));\n\t\t\tmem_cgroup_get(sk->sk_cgrp->memcg);\n\t\t\treturn;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tmemcg = mem_cgroup_from_task(current);\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tmem_cgroup_get(memcg);\n\t\t\tsk->sk_cgrp = sk->sk_prot->proto_cgroup(memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL(sock_update_memcg);\n\nvoid sock_release_memcg(struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled && sk->sk_cgrp) {\n\t\tstruct mem_cgroup *memcg;\n\t\tWARN_ON(!sk->sk_cgrp->memcg);\n\t\tmemcg = sk->sk_cgrp->memcg;\n\t\tmem_cgroup_put(memcg);\n\t}\n}\n\n#ifdef CONFIG_INET\nstruct cg_proto *tcp_proto_cgroup(struct mem_cgroup *memcg)\n{\n\tif (!memcg || mem_cgroup_is_root(memcg))\n\t\treturn NULL;\n\n\treturn &memcg->tcp_mem.cg_proto;\n}\nEXPORT_SYMBOL(tcp_proto_cgroup);\n#endif /* CONFIG_INET */\n#endif /* CONFIG_CGROUP_MEM_RES_CTLR_KMEM */\n\nstatic void drain_all_stock_async(struct mem_cgroup *memcg);\n\nstatic struct mem_cgroup_per_zone *\nmem_cgroup_zoneinfo(struct mem_cgroup *memcg, int nid, int zid)\n{\n\treturn &memcg->info.nodeinfo[nid]->zoneinfo[zid];\n}\n\nstruct cgroup_subsys_state *mem_cgroup_css(struct mem_cgroup *memcg)\n{\n\treturn &memcg->css;\n}\n\nstatic struct mem_cgroup_per_zone *\npage_cgroup_zoneinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\n\treturn mem_cgroup_zoneinfo(memcg, nid, zid);\n}\n\nstatic struct mem_cgroup_tree_per_zone *\nsoft_limit_tree_node_zone(int nid, int zid)\n{\n\treturn &soft_limit_tree.rb_tree_per_node[nid]->rb_tree_per_zone[zid];\n}\n\nstatic struct mem_cgroup_tree_per_zone *\nsoft_limit_tree_from_page(struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\n\treturn &soft_limit_tree.rb_tree_per_node[nid]->rb_tree_per_zone[zid];\n}\n\nstatic void\n__mem_cgroup_insert_exceeded(struct mem_cgroup *memcg,\n\t\t\t\tstruct mem_cgroup_per_zone *mz,\n\t\t\t\tstruct mem_cgroup_tree_per_zone *mctz,\n\t\t\t\tunsigned long long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_zone *mz_node;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_zone,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_left;\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}\n\nstatic void\n__mem_cgroup_remove_exceeded(struct mem_cgroup *memcg,\n\t\t\t\tstruct mem_cgroup_per_zone *mz,\n\t\t\t\tstruct mem_cgroup_tree_per_zone *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}\n\nstatic void\nmem_cgroup_remove_exceeded(struct mem_cgroup *memcg,\n\t\t\t\tstruct mem_cgroup_per_zone *mz,\n\t\t\t\tstruct mem_cgroup_tree_per_zone *mctz)\n{\n\tspin_lock(&mctz->lock);\n\t__mem_cgroup_remove_exceeded(memcg, mz, mctz);\n\tspin_unlock(&mctz->lock);\n}\n\n\nstatic void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long long excess;\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\tmctz = soft_limit_tree_from_page(page);\n\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\t\texcess = res_counter_soft_limit_excess(&memcg->res);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tspin_lock(&mctz->lock);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(memcg, mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(memcg, mz, mctz, excess);\n\t\t\tspin_unlock(&mctz->lock);\n\t\t}\n\t}\n}\n\nstatic void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)\n{\n\tint node, zone;\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\n\tfor_each_node(node) {\n\t\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\t\tmz = mem_cgroup_zoneinfo(memcg, node, zone);\n\t\t\tmctz = soft_limit_tree_node_zone(node, zone);\n\t\t\tmem_cgroup_remove_exceeded(memcg, mz, mctz);\n\t\t}\n\t}\n}\n\nstatic struct mem_cgroup_per_zone *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)\n{\n\tstruct rb_node *rightmost = NULL;\n\tstruct mem_cgroup_per_zone *mz;\n\nretry:\n\tmz = NULL;\n\trightmost = rb_last(&mctz->rb_root);\n\tif (!rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(rightmost, struct mem_cgroup_per_zone, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz->mem, mz, mctz);\n\tif (!res_counter_soft_limit_excess(&mz->mem->res) ||\n\t\t!css_tryget(&mz->mem->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}\n\nstatic struct mem_cgroup_per_zone *\nmem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\n\tspin_lock(&mctz->lock);\n\tmz = __mem_cgroup_largest_soft_limit_node(mctz);\n\tspin_unlock(&mctz->lock);\n\treturn mz;\n}\n\n/*\n * Implementation Note: reading percpu statistics for memcg.\n *\n * Both of vmstat[] and percpu_counter has threshold and do periodic\n * synchronization to implement \"quick\" read. There are trade-off between\n * reading cost and precision of value. Then, we may have a chance to implement\n * a periodic synchronizion of counter in memcg's counter.\n *\n * But this _read() function is used for user interface now. The user accounts\n * memory usage by memory cgroup and he _always_ requires exact value because\n * he accounts memory. Even if we provide quick-and-fuzzy read, we always\n * have to visit all online cpus and make sum. So, for now, unnecessary\n * synchronization is not implemented. (just implemented for cpu hotplug)\n *\n * If there are kernel internal actions which can make use of some not-exact\n * value, and reading all cpu value can be performance bottleneck in some\n * common workload, threashold and synchonization as vmstat[] should be\n * implemented.\n */\nstatic long mem_cgroup_read_stat(struct mem_cgroup *memcg,\n\t\t\t\t enum mem_cgroup_stat_index idx)\n{\n\tlong val = 0;\n\tint cpu;\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu)\n\t\tval += per_cpu(memcg->stat->count[idx], cpu);\n#ifdef CONFIG_HOTPLUG_CPU\n\tspin_lock(&memcg->pcp_counter_lock);\n\tval += memcg->nocpu_base.count[idx];\n\tspin_unlock(&memcg->pcp_counter_lock);\n#endif\n\tput_online_cpus();\n\treturn val;\n}\n\nstatic void mem_cgroup_swap_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t bool charge)\n{\n\tint val = (charge) ? 1 : -1;\n\tthis_cpu_add(memcg->stat->count[MEM_CGROUP_STAT_SWAPOUT], val);\n}\n\nstatic unsigned long mem_cgroup_read_events(struct mem_cgroup *memcg,\n\t\t\t\t\t    enum mem_cgroup_events_index idx)\n{\n\tunsigned long val = 0;\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tval += per_cpu(memcg->stat->events[idx], cpu);\n#ifdef CONFIG_HOTPLUG_CPU\n\tspin_lock(&memcg->pcp_counter_lock);\n\tval += memcg->nocpu_base.events[idx];\n\tspin_unlock(&memcg->pcp_counter_lock);\n#endif\n\treturn val;\n}\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t bool file, int nr_pages)\n{\n\tpreempt_disable();\n\n\tif (file)\n\t\t__this_cpu_add(memcg->stat->count[MEM_CGROUP_STAT_CACHE],\n\t\t\t\tnr_pages);\n\telse\n\t\t__this_cpu_add(memcg->stat->count[MEM_CGROUP_STAT_RSS],\n\t\t\t\tnr_pages);\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__this_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGPGIN]);\n\telse {\n\t\t__this_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGPGOUT]);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat->events[MEM_CGROUP_EVENTS_COUNT], nr_pages);\n\n\tpreempt_enable();\n}\n\nunsigned long\nmem_cgroup_zone_nr_lru_pages(struct mem_cgroup *memcg, int nid, int zid,\n\t\t\tunsigned int lru_mask)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tenum lru_list l;\n\tunsigned long ret = 0;\n\n\tmz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\n\tfor_each_lru(l) {\n\t\tif (BIT(l) & lru_mask)\n\t\t\tret += MEM_CGROUP_ZSTAT(mz, l);\n\t}\n\treturn ret;\n}\n\nstatic unsigned long\nmem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tint nid, unsigned int lru_mask)\n{\n\tu64 total = 0;\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++)\n\t\ttotal += mem_cgroup_zone_nr_lru_pages(memcg,\n\t\t\t\t\t\tnid, zid, lru_mask);\n\n\treturn total;\n}\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tint nid;\n\tu64 total = 0;\n\n\tfor_each_node_state(nid, N_HIGH_MEMORY)\n\t\ttotal += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn total;\n}\n\nstatic bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,\n\t\t\t\t       enum mem_cgroup_events_target target)\n{\n\tunsigned long val, next;\n\n\tval = __this_cpu_read(memcg->stat->events[MEM_CGROUP_EVENTS_COUNT]);\n\tnext = __this_cpu_read(memcg->stat->targets[target]);\n\t/* from time_after() in jiffies.h */\n\tif ((long)next - (long)val < 0) {\n\t\tswitch (target) {\n\t\tcase MEM_CGROUP_TARGET_THRESH:\n\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:\n\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_NUMAINFO:\n\t\t\tnext = val + NUMAINFO_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t__this_cpu_write(memcg->stat->targets[target], next);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * Check events in order.\n *\n */\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\tpreempt_disable();\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tpreempt_enable();\n\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t} else\n\t\tpreempt_enable();\n}\n\nstruct mem_cgroup *mem_cgroup_from_cont(struct cgroup *cont)\n{\n\treturn container_of(cgroup_subsys_state(cont,\n\t\t\t\tmem_cgroup_subsys_id), struct mem_cgroup,\n\t\t\t\tcss);\n}\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn container_of(task_subsys_state(p, mem_cgroup_subsys_id),\n\t\t\t\tstruct mem_cgroup, css);\n}\n\nstruct mem_cgroup *try_get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\n\tif (!mm)\n\t\treturn NULL;\n\t/*\n\t * Because we have no locks, mm->owner's may be being moved to other\n\t * cgroup. We use css_tryget() here even if this looks\n\t * pessimistic (rather than adding locks here).\n\t */\n\trcu_read_lock();\n\tdo {\n\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\tif (unlikely(!memcg))\n\t\t\tbreak;\n\t} while (!css_tryget(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}\n\n/**\n * mem_cgroup_iter - iterate over memory cgroup hierarchy\n * @root: hierarchy root\n * @prev: previously returned memcg, NULL on first invocation\n * @reclaim: cookie for shared reclaim walks, NULL for full walks\n *\n * Returns references to children of the hierarchy below @root, or\n * @root itself, or %NULL after a full round-trip.\n *\n * Caller must pass the return value in @prev on subsequent\n * invocations for reference counting, or use mem_cgroup_iter_break()\n * to cancel a hierarchy walk before the round-trip is complete.\n *\n * Reclaimers can specify a zone and a priority level in @reclaim to\n * divide up the memcgs in the hierarchy among all concurrent\n * reclaimers operating on the same zone and priority.\n */\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tint id = 0;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tid = css_id(&prev->css);\n\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\treturn NULL;\n\t\treturn root;\n\t}\n\n\twhile (!memcg) {\n\t\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\t\tstruct cgroup_subsys_state *css;\n\n\t\tif (reclaim) {\n\t\t\tint nid = zone_to_nid(reclaim->zone);\n\t\t\tint zid = zone_idx(reclaim->zone);\n\t\t\tstruct mem_cgroup_per_zone *mz;\n\n\t\t\tmz = mem_cgroup_zoneinfo(root, nid, zid);\n\t\t\titer = &mz->reclaim_iter[reclaim->priority];\n\t\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\t\treturn NULL;\n\t\t\tid = iter->position;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tcss = css_get_next(&mem_cgroup_subsys, id + 1, &root->css, &id);\n\t\tif (css) {\n\t\t\tif (css == &root->css || css_tryget(css))\n\t\t\t\tmemcg = container_of(css,\n\t\t\t\t\t\t     struct mem_cgroup, css);\n\t\t} else\n\t\t\tid = 0;\n\t\trcu_read_unlock();\n\n\t\tif (reclaim) {\n\t\t\titer->position = id;\n\t\t\tif (!css)\n\t\t\t\titer->generation++;\n\t\t\telse if (!prev && memcg)\n\t\t\t\treclaim->generation = iter->generation;\n\t\t}\n\n\t\tif (prev && !css)\n\t\t\treturn NULL;\n\t}\n\treturn memcg;\n}\n\n/**\n * mem_cgroup_iter_break - abort a hierarchy walk prematurely\n * @root: hierarchy root\n * @prev: last visited hierarchy member as returned by mem_cgroup_iter()\n */\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}\n\n/*\n * Iteration constructs for visiting all cgroups (under a tree).  If\n * loops are exited prematurely (break), mem_cgroup_iter_break() must\n * be used for reference counting.\n */\n#define for_each_mem_cgroup_tree(iter, root)\t\t\\\n\tfor (iter = mem_cgroup_iter(root, NULL, NULL);\t\\\n\t     iter != NULL;\t\t\t\t\\\n\t     iter = mem_cgroup_iter(root, iter, NULL))\n\n#define for_each_mem_cgroup(iter)\t\t\t\\\n\tfor (iter = mem_cgroup_iter(NULL, NULL, NULL);\t\\\n\t     iter != NULL;\t\t\t\t\\\n\t     iter = mem_cgroup_iter(NULL, iter, NULL))\n\nstatic inline bool mem_cgroup_is_root(struct mem_cgroup *memcg)\n{\n\treturn (memcg == root_mem_cgroup);\n}\n\nvoid mem_cgroup_count_vm_event(struct mm_struct *mm, enum vm_event_item idx)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!mm)\n\t\treturn;\n\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\tif (unlikely(!memcg))\n\t\tgoto out;\n\n\tswitch (idx) {\n\tcase PGFAULT:\n\t\tthis_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGFAULT]);\n\t\tbreak;\n\tcase PGMAJFAULT:\n\t\tthis_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGMAJFAULT]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(mem_cgroup_count_vm_event);\n\n/**\n * mem_cgroup_zone_lruvec - get the lru list vector for a zone and memcg\n * @zone: zone of the wanted lruvec\n * @mem: memcg of the wanted lruvec\n *\n * Returns the lru list vector holding pages for the given @zone and\n * @mem.  This can be the global zone lruvec, if the memory controller\n * is disabled.\n */\nstruct lruvec *mem_cgroup_zone_lruvec(struct zone *zone,\n\t\t\t\t      struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\n\tmz = mem_cgroup_zoneinfo(memcg, zone_to_nid(zone), zone_idx(zone));\n\treturn &mz->lruvec;\n}\n\n/*\n * Following LRU functions are allowed to be used without PCG_LOCK.\n * Operations are called by routine of global LRU independently from memcg.\n * What we have to take care of here is validness of pc->mem_cgroup.\n *\n * Changes to pc->mem_cgroup happens when\n * 1. charge\n * 2. moving account\n * In typical case, \"charge\" is done before add-to-lru. Exception is SwapCache.\n * It is added to LRU before charge.\n * If PCG_USED bit is not set, page_cgroup is not added to this private LRU.\n * When moving account, the page is not on LRU. It's isolated.\n */\n\n/**\n * mem_cgroup_lru_add_list - account for adding an lru page and return lruvec\n * @zone: zone of the page\n * @page: the page\n * @lru: current lru\n *\n * This function accounts for @page being added to @lru, and returns\n * the lruvec for the given @zone and the memcg @page is charged to.\n *\n * The callsite is then responsible for physically linking the page to\n * the returned lruvec->lists[@lru].\n */\nstruct lruvec *mem_cgroup_lru_add_list(struct zone *zone, struct page *page,\n\t\t\t\t       enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\t/* compound_order() is stabilized through lru_lock */\n\tMEM_CGROUP_ZSTAT(mz, lru) += 1 << compound_order(page);\n\treturn &mz->lruvec;\n}\n\n/**\n * mem_cgroup_lru_del_list - account for removing an lru page\n * @page: the page\n * @lru: target lru\n *\n * This function accounts for @page being removed from @lru.\n *\n * The callsite is then responsible for physically unlinking\n * @page->lru.\n */\nvoid mem_cgroup_lru_del_list(struct page *page, enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tVM_BUG_ON(!memcg);\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\t/* huge page split is done under lru_lock. so, we have no races. */\n\tVM_BUG_ON(MEM_CGROUP_ZSTAT(mz, lru) < (1 << compound_order(page)));\n\tMEM_CGROUP_ZSTAT(mz, lru) -= 1 << compound_order(page);\n}\n\nvoid mem_cgroup_lru_del(struct page *page)\n{\n\tmem_cgroup_lru_del_list(page, page_lru(page));\n}\n\n/**\n * mem_cgroup_lru_move_lists - account for moving a page between lrus\n * @zone: zone of the page\n * @page: the page\n * @from: current lru\n * @to: target lru\n *\n * This function accounts for @page being moved between the lrus @from\n * and @to, and returns the lruvec for the given @zone and the memcg\n * @page is charged to.\n *\n * The callsite is then responsible for physically relinking\n * @page->lru to the returned lruvec->lists[@to].\n */\nstruct lruvec *mem_cgroup_lru_move_lists(struct zone *zone,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t enum lru_list from,\n\t\t\t\t\t enum lru_list to)\n{\n\t/* XXX: Optimize this, especially for @from == @to */\n\tmem_cgroup_lru_del_list(page, from);\n\treturn mem_cgroup_lru_add_list(zone, page, to);\n}\n\n/*\n * Checks whether given mem is same or in the root_mem_cgroup's\n * hierarchy subtree\n */\nstatic bool mem_cgroup_same_or_subtree(const struct mem_cgroup *root_memcg,\n\t\tstruct mem_cgroup *memcg)\n{\n\tif (root_memcg != memcg) {\n\t\treturn (root_memcg->use_hierarchy &&\n\t\t\tcss_is_ancestor(&memcg->css, &root_memcg->css));\n\t}\n\n\treturn true;\n}\n\nint task_in_mem_cgroup(struct task_struct *task, const struct mem_cgroup *memcg)\n{\n\tint ret;\n\tstruct mem_cgroup *curr = NULL;\n\tstruct task_struct *p;\n\n\tp = find_lock_task_mm(task);\n\tif (p) {\n\t\tcurr = try_get_mem_cgroup_from_mm(p->mm);\n\t\ttask_unlock(p);\n\t} else {\n\t\t/*\n\t\t * All threads may have already detached their mm's, but the oom\n\t\t * killer still needs to detect if they have already been oom\n\t\t * killed to prevent needlessly killing additional tasks.\n\t\t */\n\t\ttask_lock(task);\n\t\tcurr = mem_cgroup_from_task(task);\n\t\tif (curr)\n\t\t\tcss_get(&curr->css);\n\t\ttask_unlock(task);\n\t}\n\tif (!curr)\n\t\treturn 0;\n\t/*\n\t * We should check use_hierarchy of \"memcg\" not \"curr\". Because checking\n\t * use_hierarchy of \"curr\" here make this function true if hierarchy is\n\t * enabled in \"curr\" and \"curr\" is a child of \"memcg\" in *cgroup*\n\t * hierarchy(even if use_hierarchy is disabled in \"memcg\").\n\t */\n\tret = mem_cgroup_same_or_subtree(memcg, curr);\n\tcss_put(&curr->css);\n\treturn ret;\n}\n\nint mem_cgroup_inactive_anon_is_low(struct mem_cgroup *memcg, struct zone *zone)\n{\n\tunsigned long inactive_ratio;\n\tint nid = zone_to_nid(zone);\n\tint zid = zone_idx(zone);\n\tunsigned long inactive;\n\tunsigned long active;\n\tunsigned long gb;\n\n\tinactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t\tBIT(LRU_INACTIVE_ANON));\n\tactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t      BIT(LRU_ACTIVE_ANON));\n\n\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\tif (gb)\n\t\tinactive_ratio = int_sqrt(10 * gb);\n\telse\n\t\tinactive_ratio = 1;\n\n\treturn inactive * inactive_ratio < active;\n}\n\nint mem_cgroup_inactive_file_is_low(struct mem_cgroup *memcg, struct zone *zone)\n{\n\tunsigned long active;\n\tunsigned long inactive;\n\tint zid = zone_idx(zone);\n\tint nid = zone_to_nid(zone);\n\n\tinactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t\tBIT(LRU_INACTIVE_FILE));\n\tactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t      BIT(LRU_ACTIVE_FILE));\n\n\treturn (active > inactive);\n}\n\nstruct zone_reclaim_stat *mem_cgroup_get_reclaim_stat(struct mem_cgroup *memcg,\n\t\t\t\t\t\t      struct zone *zone)\n{\n\tint nid = zone_to_nid(zone);\n\tint zid = zone_idx(zone);\n\tstruct mem_cgroup_per_zone *mz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\n\treturn &mz->reclaim_stat;\n}\n\nstruct zone_reclaim_stat *\nmem_cgroup_get_reclaim_stat_from_page(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\tstruct mem_cgroup_per_zone *mz;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tpc = lookup_page_cgroup(page);\n\tif (!PageCgroupUsed(pc))\n\t\treturn NULL;\n\t/* Ensure pc->mem_cgroup is visible after reading PCG_USED. */\n\tsmp_rmb();\n\tmz = page_cgroup_zoneinfo(pc->mem_cgroup, page);\n\treturn &mz->reclaim_stat;\n}\n\n#define mem_cgroup_from_res_counter(counter, member)\t\\\n\tcontainer_of(counter, struct mem_cgroup, member)\n\n/**\n * mem_cgroup_margin - calculate chargeable space of a memory cgroup\n * @mem: the memory cgroup\n *\n * Returns the maximum amount of memory @mem can be charged with, in\n * pages.\n */\nstatic unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)\n{\n\tunsigned long long margin;\n\n\tmargin = res_counter_margin(&memcg->res);\n\tif (do_swap_account)\n\t\tmargin = min(margin, res_counter_margin(&memcg->memsw));\n\treturn margin >> PAGE_SHIFT;\n}\n\nint mem_cgroup_swappiness(struct mem_cgroup *memcg)\n{\n\tstruct cgroup *cgrp = memcg->css.cgroup;\n\n\t/* root ? */\n\tif (cgrp->parent == NULL)\n\t\treturn vm_swappiness;\n\n\treturn memcg->swappiness;\n}\n\nstatic void mem_cgroup_start_move(struct mem_cgroup *memcg)\n{\n\tint cpu;\n\n\tget_online_cpus();\n\tspin_lock(&memcg->pcp_counter_lock);\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(memcg->stat->count[MEM_CGROUP_ON_MOVE], cpu) += 1;\n\tmemcg->nocpu_base.count[MEM_CGROUP_ON_MOVE] += 1;\n\tspin_unlock(&memcg->pcp_counter_lock);\n\tput_online_cpus();\n\n\tsynchronize_rcu();\n}\n\nstatic void mem_cgroup_end_move(struct mem_cgroup *memcg)\n{\n\tint cpu;\n\n\tif (!memcg)\n\t\treturn;\n\tget_online_cpus();\n\tspin_lock(&memcg->pcp_counter_lock);\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(memcg->stat->count[MEM_CGROUP_ON_MOVE], cpu) -= 1;\n\tmemcg->nocpu_base.count[MEM_CGROUP_ON_MOVE] -= 1;\n\tspin_unlock(&memcg->pcp_counter_lock);\n\tput_online_cpus();\n}\n/*\n * 2 routines for checking \"mem\" is under move_account() or not.\n *\n * mem_cgroup_stealed() - checking a cgroup is mc.from or not. This is used\n *\t\t\t  for avoiding race in accounting. If true,\n *\t\t\t  pc->mem_cgroup may be overwritten.\n *\n * mem_cgroup_under_move() - checking a cgroup is mc.from or mc.to or\n *\t\t\t  under hierarchy of moving cgroups. This is for\n *\t\t\t  waiting at hith-memory prressure caused by \"move\".\n */\n\nstatic bool mem_cgroup_stealed(struct mem_cgroup *memcg)\n{\n\tVM_BUG_ON(!rcu_read_lock_held());\n\treturn this_cpu_read(memcg->stat->count[MEM_CGROUP_ON_MOVE]) > 0;\n}\n\nstatic bool mem_cgroup_under_move(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tbool ret = false;\n\t/*\n\t * Unlike task_move routines, we access mc.to, mc.from not under\n\t * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.\n\t */\n\tspin_lock(&mc.lock);\n\tfrom = mc.from;\n\tto = mc.to;\n\tif (!from)\n\t\tgoto unlock;\n\n\tret = mem_cgroup_same_or_subtree(memcg, from)\n\t\t|| mem_cgroup_same_or_subtree(memcg, to);\nunlock:\n\tspin_unlock(&mc.lock);\n\treturn ret;\n}\n\nstatic bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)\n{\n\tif (mc.moving_task && current != mc.moving_task) {\n\t\tif (mem_cgroup_under_move(memcg)) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\tprepare_to_wait(&mc.waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\t/* moving charge context might have finished. */\n\t\t\tif (mc.moving_task)\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&mc.waitq, &wait);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * mem_cgroup_print_oom_info: Called from OOM with tasklist_lock held in read mode.\n * @memcg: The memory cgroup that went over limit\n * @p: Task that is going to be killed\n *\n * NOTE: @memcg and @p's mem_cgroup can be different when hierarchy is\n * enabled\n */\nvoid mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)\n{\n\tstruct cgroup *task_cgrp;\n\tstruct cgroup *mem_cgrp;\n\t/*\n\t * Need a buffer in BSS, can't rely on allocations. The code relies\n\t * on the assumption that OOM is serialized for memory controller.\n\t * If this assumption is broken, revisit this code.\n\t */\n\tstatic char memcg_name[PATH_MAX];\n\tint ret;\n\n\tif (!memcg || !p)\n\t\treturn;\n\n\n\trcu_read_lock();\n\n\tmem_cgrp = memcg->css.cgroup;\n\ttask_cgrp = task_cgroup(p, mem_cgroup_subsys_id);\n\n\tret = cgroup_path(task_cgrp, memcg_name, PATH_MAX);\n\tif (ret < 0) {\n\t\t/*\n\t\t * Unfortunately, we are unable to convert to a useful name\n\t\t * But we'll still print out the usage information\n\t\t */\n\t\trcu_read_unlock();\n\t\tgoto done;\n\t}\n\trcu_read_unlock();\n\n\tprintk(KERN_INFO \"Task in %s killed\", memcg_name);\n\n\trcu_read_lock();\n\tret = cgroup_path(mem_cgrp, memcg_name, PATH_MAX);\n\tif (ret < 0) {\n\t\trcu_read_unlock();\n\t\tgoto done;\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Continues from above, so we don't need an KERN_ level\n\t */\n\tprintk(KERN_CONT \" as a result of limit of %s\\n\", memcg_name);\ndone:\n\n\tprintk(KERN_INFO \"memory: usage %llukB, limit %llukB, failcnt %llu\\n\",\n\t\tres_counter_read_u64(&memcg->res, RES_USAGE) >> 10,\n\t\tres_counter_read_u64(&memcg->res, RES_LIMIT) >> 10,\n\t\tres_counter_read_u64(&memcg->res, RES_FAILCNT));\n\tprintk(KERN_INFO \"memory+swap: usage %llukB, limit %llukB, \"\n\t\t\"failcnt %llu\\n\",\n\t\tres_counter_read_u64(&memcg->memsw, RES_USAGE) >> 10,\n\t\tres_counter_read_u64(&memcg->memsw, RES_LIMIT) >> 10,\n\t\tres_counter_read_u64(&memcg->memsw, RES_FAILCNT));\n}\n\n/*\n * This function returns the number of memcg under hierarchy tree. Returns\n * 1(self count) if no children.\n */\nstatic int mem_cgroup_count_children(struct mem_cgroup *memcg)\n{\n\tint num = 0;\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tnum++;\n\treturn num;\n}\n\n/*\n * Return the memory (and swap, if configured) limit for a memcg.\n */\nu64 mem_cgroup_get_limit(struct mem_cgroup *memcg)\n{\n\tu64 limit;\n\tu64 memsw;\n\n\tlimit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\tlimit += total_swap_pages << PAGE_SHIFT;\n\n\tmemsw = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t/*\n\t * If memsw is finite and limits the amount of swap space available\n\t * to this memcg, return that limit.\n\t */\n\treturn min(limit, memsw);\n}\n\nstatic unsigned long mem_cgroup_reclaim(struct mem_cgroup *memcg,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long flags)\n{\n\tunsigned long total = 0;\n\tbool noswap = false;\n\tint loop;\n\n\tif (flags & MEM_CGROUP_RECLAIM_NOSWAP)\n\t\tnoswap = true;\n\tif (!(flags & MEM_CGROUP_RECLAIM_SHRINK) && memcg->memsw_is_minimum)\n\t\tnoswap = true;\n\n\tfor (loop = 0; loop < MEM_CGROUP_MAX_RECLAIM_LOOPS; loop++) {\n\t\tif (loop)\n\t\t\tdrain_all_stock_async(memcg);\n\t\ttotal += try_to_free_mem_cgroup_pages(memcg, gfp_mask, noswap);\n\t\t/*\n\t\t * Allow limit shrinkers, which are triggered directly\n\t\t * by userspace, to catch signals and stop reclaim\n\t\t * after minimal progress, regardless of the margin.\n\t\t */\n\t\tif (total && (flags & MEM_CGROUP_RECLAIM_SHRINK))\n\t\t\tbreak;\n\t\tif (mem_cgroup_margin(memcg))\n\t\t\tbreak;\n\t\t/*\n\t\t * If nothing was reclaimed after two attempts, there\n\t\t * may be no reclaimable pages in this hierarchy.\n\t\t */\n\t\tif (loop && !total)\n\t\t\tbreak;\n\t}\n\treturn total;\n}\n\n/**\n * test_mem_cgroup_node_reclaimable\n * @mem: the target memcg\n * @nid: the node ID to be checked.\n * @noswap : specify true here if the user wants flle only information.\n *\n * This function returns whether the specified memcg contains any\n * reclaimable pages on a node. Returns true if there are any reclaimable\n * pages in the node.\n */\nstatic bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}\n#if MAX_NUMNODES > 1\n\n/*\n * Always updating the nodemask is not very good - even if we have an empty\n * list or the wrong list here, we can start from some node and traverse all\n * nodes based on the zonelist. So update the list loosely once per 10 secs.\n *\n */\nstatic void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)\n{\n\tint nid;\n\t/*\n\t * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET\n\t * pagein/pageout changes since the last update.\n\t */\n\tif (!atomic_read(&memcg->numainfo_events))\n\t\treturn;\n\tif (atomic_inc_return(&memcg->numainfo_updating) > 1)\n\t\treturn;\n\n\t/* make a nodemask where this memcg uses memory from */\n\tmemcg->scan_nodes = node_states[N_HIGH_MEMORY];\n\n\tfor_each_node_mask(nid, node_states[N_HIGH_MEMORY]) {\n\n\t\tif (!test_mem_cgroup_node_reclaimable(memcg, nid, false))\n\t\t\tnode_clear(nid, memcg->scan_nodes);\n\t}\n\n\tatomic_set(&memcg->numainfo_events, 0);\n\tatomic_set(&memcg->numainfo_updating, 0);\n}\n\n/*\n * Selecting a node where we start reclaim from. Because what we need is just\n * reducing usage counter, start from anywhere is O,K. Considering\n * memory reclaim from current node, there are pros. and cons.\n *\n * Freeing memory from current node means freeing memory from a node which\n * we'll use or we've used. So, it may make LRU bad. And if several threads\n * hit limits, it will see a contention on a node. But freeing from remote\n * node means more costs for memory reclaim because of memory latency.\n *\n * Now, we use round-robin. Better algorithm is welcomed.\n */\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_may_update_nodemask(memcg);\n\tnode = memcg->last_scanned_node;\n\n\tnode = next_node(node, memcg->scan_nodes);\n\tif (node == MAX_NUMNODES)\n\t\tnode = first_node(memcg->scan_nodes);\n\t/*\n\t * We call this when we hit limit, not when pages are added to LRU.\n\t * No LRU may hold pages because all pages are UNEVICTABLE or\n\t * memcg is too small and all pages are not on LRU. In that case,\n\t * we use curret node.\n\t */\n\tif (unlikely(node == MAX_NUMNODES))\n\t\tnode = numa_node_id();\n\n\tmemcg->last_scanned_node = node;\n\treturn node;\n}\n\n/*\n * Check all nodes whether it contains reclaimable pages or not.\n * For quick scan, we make use of scan_nodes. This will allow us to skip\n * unused nodes. But scan_nodes is lazily updated and may not cotain\n * enough new information. We need to do double check.\n */\nbool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)\n{\n\tint nid;\n\n\t/*\n\t * quick check...making use of scan_node.\n\t * We can skip unused nodes.\n\t */\n\tif (!nodes_empty(memcg->scan_nodes)) {\n\t\tfor (nid = first_node(memcg->scan_nodes);\n\t\t     nid < MAX_NUMNODES;\n\t\t     nid = next_node(nid, memcg->scan_nodes)) {\n\n\t\t\tif (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\t/*\n\t * Check rest of nodes.\n\t */\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tif (node_isset(nid, memcg->scan_nodes))\n\t\t\tcontinue;\n\t\tif (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n#else\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}\n\nbool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)\n{\n\treturn test_mem_cgroup_node_reclaimable(memcg, 0, noswap);\n}\n#endif\n\nstatic int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   struct zone *zone,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.zone = zone,\n\t\t.priority = 0,\n\t};\n\n\texcess = res_counter_soft_limit_excess(&root_memcg->res) >> PAGE_SHIFT;\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mem_cgroup_reclaimable(victim, false))\n\t\t\tcontinue;\n\t\ttotal += mem_cgroup_shrink_node_zone(victim, gfp_mask, false,\n\t\t\t\t\t\t     zone, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!res_counter_soft_limit_excess(&root_memcg->res))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}\n\n/*\n * Check OOM-Killer is already running under our hierarchy.\n * If someone is running, return false.\n * Has to be called with memcg_oom_lock\n */\nstatic bool mem_cgroup_oom_lock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter, *failed = NULL;\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter->oom_lock) {\n\t\t\t/*\n\t\t\t * this subtree of our hierarchy is already locked\n\t\t\t * so we cannot give a lock.\n\t\t\t */\n\t\t\tfailed = iter;\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t} else\n\t\t\titer->oom_lock = true;\n\t}\n\n\tif (!failed)\n\t\treturn true;\n\n\t/*\n\t * OK, we failed to lock the whole subtree so we have to clean up\n\t * what we set up to the failing subtree\n\t */\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter == failed) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t\titer->oom_lock = false;\n\t}\n\treturn false;\n}\n\n/*\n * Has to be called with memcg_oom_lock\n */\nstatic int mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\treturn 0;\n}\n\nstatic void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tatomic_inc(&iter->under_oom);\n}\n\nstatic void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\t/*\n\t * When a new child is created while the hierarchy is under oom,\n\t * mem_cgroup_oom_lock() may not be called. We have to use\n\t * atomic_add_unless() here.\n\t */\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tatomic_add_unless(&iter->under_oom, -1, 0);\n}\n\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstruct oom_wait_info {\n\tstruct mem_cgroup *mem;\n\twait_queue_t\twait;\n};\n\nstatic int memcg_oom_wake_function(wait_queue_t *wait,\n\tunsigned mode, int sync, void *arg)\n{\n\tstruct mem_cgroup *wake_memcg = (struct mem_cgroup *)arg,\n\t\t\t  *oom_wait_memcg;\n\tstruct oom_wait_info *oom_wait_info;\n\n\toom_wait_info = container_of(wait, struct oom_wait_info, wait);\n\toom_wait_memcg = oom_wait_info->mem;\n\n\t/*\n\t * Both of oom_wait_info->mem and wake_mem are stable under us.\n\t * Then we can use css_is_ancestor without taking care of RCU.\n\t */\n\tif (!mem_cgroup_same_or_subtree(oom_wait_memcg, wake_memcg)\n\t\t&& !mem_cgroup_same_or_subtree(wake_memcg, oom_wait_memcg))\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, arg);\n}\n\nstatic void memcg_wakeup_oom(struct mem_cgroup *memcg)\n{\n\t/* for filtering, pass \"memcg\" as argument. */\n\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\tif (memcg && atomic_read(&memcg->under_oom))\n\t\tmemcg_wakeup_oom(memcg);\n}\n\n/*\n * try to call OOM killer. returns false if we should exit memory-reclaim loop.\n */\nbool mem_cgroup_handle_oom(struct mem_cgroup *memcg, gfp_t mask)\n{\n\tstruct oom_wait_info owait;\n\tbool locked, need_to_kill;\n\n\towait.mem = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.task_list);\n\tneed_to_kill = true;\n\tmem_cgroup_mark_under_oom(memcg);\n\n\t/* At first, try to OOM lock hierarchy under memcg.*/\n\tspin_lock(&memcg_oom_lock);\n\tlocked = mem_cgroup_oom_lock(memcg);\n\t/*\n\t * Even if signal_pending(), we can't quit charge() loop without\n\t * accounting. So, UNINTERRUPTIBLE is appropriate. But SIGKILL\n\t * under OOM is always welcomed, use TASK_KILLABLE here.\n\t */\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tif (!locked || memcg->oom_kill_disable)\n\t\tneed_to_kill = false;\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\tspin_unlock(&memcg_oom_lock);\n\n\tif (need_to_kill) {\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, mask);\n\t} else {\n\t\tschedule();\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\tspin_lock(&memcg_oom_lock);\n\tif (locked)\n\t\tmem_cgroup_oom_unlock(memcg);\n\tmemcg_wakeup_oom(memcg);\n\tspin_unlock(&memcg_oom_lock);\n\n\tmem_cgroup_unmark_under_oom(memcg);\n\n\tif (test_thread_flag(TIF_MEMDIE) || fatal_signal_pending(current))\n\t\treturn false;\n\t/* Give chance to dying process */\n\tschedule_timeout_uninterruptible(1);\n\treturn true;\n}\n\n/*\n * Currently used to update mapped file statistics, but the routine can be\n * generalized to update other statistics as well.\n *\n * Notes: Race condition\n *\n * We usually use page_cgroup_lock() for accessing page_cgroup member but\n * it tends to be costly. But considering some conditions, we doesn't need\n * to do so _always_.\n *\n * Considering \"charge\", lock_page_cgroup() is not required because all\n * file-stat operations happen after a page is attached to radix-tree. There\n * are no race with \"charge\".\n *\n * Considering \"uncharge\", we know that memcg doesn't clear pc->mem_cgroup\n * at \"uncharge\" intentionally. So, we always see valid pc->mem_cgroup even\n * if there are race with \"uncharge\". Statistics itself is properly handled\n * by flags.\n *\n * Considering \"move\", this is an only case we see a race. To make the race\n * small, we check MEM_CGROUP_ON_MOVE percpu value and detect there are\n * possibility of race condition. If there is, we take a lock.\n */\n\nvoid mem_cgroup_update_page_stat(struct page *page,\n\t\t\t\t enum mem_cgroup_page_stat_item idx, int val)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc = lookup_page_cgroup(page);\n\tbool need_unlock = false;\n\tunsigned long uninitialized_var(flags);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\trcu_read_lock();\n\tmemcg = pc->mem_cgroup;\n\tif (unlikely(!memcg || !PageCgroupUsed(pc)))\n\t\tgoto out;\n\t/* pc->mem_cgroup is unstable ? */\n\tif (unlikely(mem_cgroup_stealed(memcg)) || PageTransHuge(page)) {\n\t\t/* take a lock against to access pc->mem_cgroup */\n\t\tmove_lock_page_cgroup(pc, &flags);\n\t\tneed_unlock = true;\n\t\tmemcg = pc->mem_cgroup;\n\t\tif (!memcg || !PageCgroupUsed(pc))\n\t\t\tgoto out;\n\t}\n\n\tswitch (idx) {\n\tcase MEMCG_NR_FILE_MAPPED:\n\t\tif (val > 0)\n\t\t\tSetPageCgroupFileMapped(pc);\n\t\telse if (!page_mapped(page))\n\t\t\tClearPageCgroupFileMapped(pc);\n\t\tidx = MEM_CGROUP_STAT_FILE_MAPPED;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tthis_cpu_add(memcg->stat->count[idx], val);\n\nout:\n\tif (unlikely(need_unlock))\n\t\tmove_unlock_page_cgroup(pc, &flags);\n\trcu_read_unlock();\n\treturn;\n}\nEXPORT_SYMBOL(mem_cgroup_update_page_stat);\n\n/*\n * size of first charge trial. \"32\" comes from vmscan.c's magic value.\n * TODO: maybe necessary to use big numbers in big irons.\n */\n#define CHARGE_BATCH\t32U\nstruct memcg_stock_pcp {\n\tstruct mem_cgroup *cached; /* this never be root cgroup */\n\tunsigned int nr_pages;\n\tstruct work_struct work;\n\tunsigned long flags;\n#define FLUSHING_CACHED_CHARGE\t(0)\n};\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\n/*\n * Try to consume stocked charge on this cpu. If success, one page is consumed\n * from local stock and true is returned. If the stock is 0 or charges from a\n * cgroup which is not current target, returns false. This stock will be\n * refilled.\n */\nstatic bool consume_stock(struct mem_cgroup *memcg)\n{\n\tstruct memcg_stock_pcp *stock;\n\tbool ret = true;\n\n\tstock = &get_cpu_var(memcg_stock);\n\tif (memcg == stock->cached && stock->nr_pages)\n\t\tstock->nr_pages--;\n\telse /* need to call res_counter_charge */\n\t\tret = false;\n\tput_cpu_var(memcg_stock);\n\treturn ret;\n}\n\n/*\n * Returns stocks cached in percpu to res_counter and reset cached information.\n */\nstatic void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tunsigned long bytes = stock->nr_pages * PAGE_SIZE;\n\n\t\tres_counter_uncharge(&old->res, bytes);\n\t\tif (do_swap_account)\n\t\t\tres_counter_uncharge(&old->memsw, bytes);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}\n\n/*\n * This must be called under preempt disabled or must be called by\n * a thread which is pinned to local cpu.\n */\nstatic void drain_local_stock(struct work_struct *dummy)\n{\n\tstruct memcg_stock_pcp *stock = &__get_cpu_var(memcg_stock);\n\tdrain_stock(stock);\n\tclear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);\n}\n\n/*\n * Cache charges(val) which is from res_counter, to local per_cpu area.\n * This will be consumed by consume_stock() function, later.\n */\nstatic void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock = &get_cpu_var(memcg_stock);\n\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\tput_cpu_var(memcg_stock);\n}\n\n/*\n * Drains all per-CPU charge caches for given root_memcg resp. subtree\n * of the hierarchy under it. sync flag says whether we should block\n * until the work is done.\n */\nstatic void drain_all_stock(struct mem_cgroup *root_memcg, bool sync)\n{\n\tint cpu, curcpu;\n\n\t/* Notify other cpus that system-wide \"drain\" is running */\n\tget_online_cpus();\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages)\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_same_or_subtree(root_memcg, memcg))\n\t\t\tcontinue;\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t}\n\tput_cpu();\n\n\tif (!sync)\n\t\tgoto out;\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tif (test_bit(FLUSHING_CACHED_CHARGE, &stock->flags))\n\t\t\tflush_work(&stock->work);\n\t}\nout:\n \tput_online_cpus();\n}\n\n/*\n * Tries to drain stocked charges in other cpus. This function is asynchronous\n * and just put a work per cpu for draining localy on each cpu. Caller can\n * expects some charges will be back to res_counter later but cannot wait for\n * it.\n */\nstatic void drain_all_stock_async(struct mem_cgroup *root_memcg)\n{\n\t/*\n\t * If someone calls draining, avoid adding more kworker runs.\n\t */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\tdrain_all_stock(root_memcg, false);\n\tmutex_unlock(&percpu_charge_mutex);\n}\n\n/* This is a synchronous drain interface. */\nstatic void drain_all_stock_sync(struct mem_cgroup *root_memcg)\n{\n\t/* called when force_empty is called */\n\tmutex_lock(&percpu_charge_mutex);\n\tdrain_all_stock(root_memcg, true);\n\tmutex_unlock(&percpu_charge_mutex);\n}\n\n/*\n * This function drains percpu counter value from DEAD cpu and\n * move it to local cpu. Note that this function can be preempted.\n */\nstatic void mem_cgroup_drain_pcp_counter(struct mem_cgroup *memcg, int cpu)\n{\n\tint i;\n\n\tspin_lock(&memcg->pcp_counter_lock);\n\tfor (i = 0; i < MEM_CGROUP_STAT_DATA; i++) {\n\t\tlong x = per_cpu(memcg->stat->count[i], cpu);\n\n\t\tper_cpu(memcg->stat->count[i], cpu) = 0;\n\t\tmemcg->nocpu_base.count[i] += x;\n\t}\n\tfor (i = 0; i < MEM_CGROUP_EVENTS_NSTATS; i++) {\n\t\tunsigned long x = per_cpu(memcg->stat->events[i], cpu);\n\n\t\tper_cpu(memcg->stat->events[i], cpu) = 0;\n\t\tmemcg->nocpu_base.events[i] += x;\n\t}\n\t/* need to clear ON_MOVE value, works as a kind of lock. */\n\tper_cpu(memcg->stat->count[MEM_CGROUP_ON_MOVE], cpu) = 0;\n\tspin_unlock(&memcg->pcp_counter_lock);\n}\n\nstatic void synchronize_mem_cgroup_on_move(struct mem_cgroup *memcg, int cpu)\n{\n\tint idx = MEM_CGROUP_ON_MOVE;\n\n\tspin_lock(&memcg->pcp_counter_lock);\n\tper_cpu(memcg->stat->count[idx], cpu) = memcg->nocpu_base.count[idx];\n\tspin_unlock(&memcg->pcp_counter_lock);\n}\n\nstatic int __cpuinit memcg_cpu_hotplug_callback(struct notifier_block *nb,\n\t\t\t\t\tunsigned long action,\n\t\t\t\t\tvoid *hcpu)\n{\n\tint cpu = (unsigned long)hcpu;\n\tstruct memcg_stock_pcp *stock;\n\tstruct mem_cgroup *iter;\n\n\tif ((action == CPU_ONLINE)) {\n\t\tfor_each_mem_cgroup(iter)\n\t\t\tsynchronize_mem_cgroup_on_move(iter, cpu);\n\t\treturn NOTIFY_OK;\n\t}\n\n\tif ((action != CPU_DEAD) || action != CPU_DEAD_FROZEN)\n\t\treturn NOTIFY_OK;\n\n\tfor_each_mem_cgroup(iter)\n\t\tmem_cgroup_drain_pcp_counter(iter, cpu);\n\n\tstock = &per_cpu(memcg_stock, cpu);\n\tdrain_stock(stock);\n\treturn NOTIFY_OK;\n}\n\n\n/* See __mem_cgroup_try_charge() for details */\nenum {\n\tCHARGE_OK,\t\t/* success */\n\tCHARGE_RETRY,\t\t/* need to retry but retry is not bad */\n\tCHARGE_NOMEM,\t\t/* we can't do more. return -ENOMEM */\n\tCHARGE_WOULDBLOCK,\t/* GFP_WAIT wasn't set and no enough res. */\n\tCHARGE_OOM_DIE,\t\t/* the current is killed because of OOM */\n};\n\nstatic int mem_cgroup_do_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\tunsigned int nr_pages, bool oom_check)\n{\n\tunsigned long csize = nr_pages * PAGE_SIZE;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct res_counter *fail_res;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tret = res_counter_charge(&memcg->res, csize, &fail_res);\n\n\tif (likely(!ret)) {\n\t\tif (!do_swap_account)\n\t\t\treturn CHARGE_OK;\n\t\tret = res_counter_charge(&memcg->memsw, csize, &fail_res);\n\t\tif (likely(!ret))\n\t\t\treturn CHARGE_OK;\n\n\t\tres_counter_uncharge(&memcg->res, csize);\n\t\tmem_over_limit = mem_cgroup_from_res_counter(fail_res, memsw);\n\t\tflags |= MEM_CGROUP_RECLAIM_NOSWAP;\n\t} else\n\t\tmem_over_limit = mem_cgroup_from_res_counter(fail_res, res);\n\t/*\n\t * nr_pages can be either a huge page (HPAGE_PMD_NR), a batch\n\t * of regular pages (CHARGE_BATCH), or a single regular page (1).\n\t *\n\t * Never reclaim on behalf of optional batching, retry with a\n\t * single page instead.\n\t */\n\tif (nr_pages == CHARGE_BATCH)\n\t\treturn CHARGE_RETRY;\n\n\tif (!(gfp_mask & __GFP_WAIT))\n\t\treturn CHARGE_WOULDBLOCK;\n\n\tret = mem_cgroup_reclaim(mem_over_limit, gfp_mask, flags);\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\treturn CHARGE_RETRY;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_pages == 1 && ret)\n\t\treturn CHARGE_RETRY;\n\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\treturn CHARGE_RETRY;\n\n\t/* If we don't need to call oom-killer at el, return immediately */\n\tif (!oom_check)\n\t\treturn CHARGE_NOMEM;\n\t/* check OOM */\n\tif (!mem_cgroup_handle_oom(mem_over_limit, gfp_mask))\n\t\treturn CHARGE_OOM_DIE;\n\n\treturn CHARGE_RETRY;\n}\n\n/*\n * __mem_cgroup_try_charge() does\n * 1. detect memcg to be charged against from passed *mm and *ptr,\n * 2. update res_counter\n * 3. call memory reclaim if necessary.\n *\n * In some special case, if the task is fatal, fatal_signal_pending() or\n * has TIF_MEMDIE, this function returns -EINTR while writing root_mem_cgroup\n * to *ptr. There are two reasons for this. 1: fatal threads should quit as soon\n * as possible without any hazards. 2: all pages should have a valid\n * pc->mem_cgroup. If mm is NULL and the caller doesn't pass a valid memcg\n * pointer, that is treated as a charge to root_mem_cgroup.\n *\n * So __mem_cgroup_try_charge() will return\n *  0       ...  on success, filling *ptr with a valid memcg pointer.\n *  -ENOMEM ...  charge failure because of resource limits.\n *  -EINTR  ...  if thread is fatal. *ptr is filled with root_mem_cgroup.\n *\n * Unlike the exported interface, an \"oom\" parameter is added. if oom==true,\n * the oom-killer can be invoked.\n */\nstatic int __mem_cgroup_try_charge(struct mm_struct *mm,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned int nr_pages,\n\t\t\t\t   struct mem_cgroup **ptr,\n\t\t\t\t   bool oom)\n{\n\tunsigned int batch = max(CHARGE_BATCH, nr_pages);\n\tint nr_oom_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *memcg = NULL;\n\tint ret;\n\n\t/*\n\t * Unlike gloval-vm's OOM-kill, we're not in memory shortage\n\t * in system level. So, allow to go ahead dying process in addition to\n\t * MEMDIE process.\n\t */\n\tif (unlikely(test_thread_flag(TIF_MEMDIE)\n\t\t     || fatal_signal_pending(current)))\n\t\tgoto bypass;\n\n\t/*\n\t * We always charge the cgroup the mm_struct belongs to.\n\t * The mm_struct's mem_cgroup changes on task migration if the\n\t * thread group leader migrates. It's possible that mm is not\n\t * set, if so charge the init_mm (happens for pagecache usage).\n\t */\n\tif (!*ptr && !mm)\n\t\t*ptr = root_mem_cgroup;\nagain:\n\tif (*ptr) { /* css should be a valid one */\n\t\tmemcg = *ptr;\n\t\tVM_BUG_ON(css_is_removed(&memcg->css));\n\t\tif (mem_cgroup_is_root(memcg))\n\t\t\tgoto done;\n\t\tif (nr_pages == 1 && consume_stock(memcg))\n\t\t\tgoto done;\n\t\tcss_get(&memcg->css);\n\t} else {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tp = rcu_dereference(mm->owner);\n\t\t/*\n\t\t * Because we don't have task_lock(), \"p\" can exit.\n\t\t * In that case, \"memcg\" can point to root or p can be NULL with\n\t\t * race with swapoff. Then, we have small risk of mis-accouning.\n\t\t * But such kind of mis-account by race always happens because\n\t\t * we don't have cgroup_mutex(). It's overkill and we allo that\n\t\t * small race, here.\n\t\t * (*) swapoff at el will charge against mm-struct not against\n\t\t * task-struct. So, mm->owner can be NULL.\n\t\t */\n\t\tmemcg = mem_cgroup_from_task(p);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t\tif (mem_cgroup_is_root(memcg)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto done;\n\t\t}\n\t\tif (nr_pages == 1 && consume_stock(memcg)) {\n\t\t\t/*\n\t\t\t * It seems dagerous to access memcg without css_get().\n\t\t\t * But considering how consume_stok works, it's not\n\t\t\t * necessary. If consume_stock success, some charges\n\t\t\t * from this memcg are cached on this cpu. So, we\n\t\t\t * don't need to call css_get()/css_tryget() before\n\t\t\t * calling consume_stock().\n\t\t\t */\n\t\t\trcu_read_unlock();\n\t\t\tgoto done;\n\t\t}\n\t\t/* after here, we may be blocked. we need to get refcnt */\n\t\tif (!css_tryget(&memcg->css)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto again;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tdo {\n\t\tbool oom_check;\n\n\t\t/* If killed, bypass charge */\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tgoto bypass;\n\t\t}\n\n\t\toom_check = false;\n\t\tif (oom && !nr_oom_retries) {\n\t\t\toom_check = true;\n\t\t\tnr_oom_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\t}\n\n\t\tret = mem_cgroup_do_charge(memcg, gfp_mask, batch, oom_check);\n\t\tswitch (ret) {\n\t\tcase CHARGE_OK:\n\t\t\tbreak;\n\t\tcase CHARGE_RETRY: /* not in OOM situation but retry */\n\t\t\tbatch = nr_pages;\n\t\t\tcss_put(&memcg->css);\n\t\t\tmemcg = NULL;\n\t\t\tgoto again;\n\t\tcase CHARGE_WOULDBLOCK: /* !__GFP_WAIT */\n\t\t\tcss_put(&memcg->css);\n\t\t\tgoto nomem;\n\t\tcase CHARGE_NOMEM: /* OOM routine works */\n\t\t\tif (!oom) {\n\t\t\t\tcss_put(&memcg->css);\n\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t\t/* If oom, we never return -ENOMEM */\n\t\t\tnr_oom_retries--;\n\t\t\tbreak;\n\t\tcase CHARGE_OOM_DIE: /* Killed by OOM Killer */\n\t\t\tcss_put(&memcg->css);\n\t\t\tgoto bypass;\n\t\t}\n\t} while (ret != CHARGE_OK);\n\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\tcss_put(&memcg->css);\ndone:\n\t*ptr = memcg;\n\treturn 0;\nnomem:\n\t*ptr = NULL;\n\treturn -ENOMEM;\nbypass:\n\t*ptr = root_mem_cgroup;\n\treturn -EINTR;\n}\n\n/*\n * Somemtimes we have to undo a charge we got by try_charge().\n * This function is for that and do uncharge, put css's refcnt.\n * gotten by try_charge().\n */\nstatic void __mem_cgroup_cancel_charge(struct mem_cgroup *memcg,\n\t\t\t\t       unsigned int nr_pages)\n{\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tunsigned long bytes = nr_pages * PAGE_SIZE;\n\n\t\tres_counter_uncharge(&memcg->res, bytes);\n\t\tif (do_swap_account)\n\t\t\tres_counter_uncharge(&memcg->memsw, bytes);\n\t}\n}\n\n/*\n * A helper function to get mem_cgroup from ID. must be called under\n * rcu_read_lock(). The caller must check css_is_removed() or some if\n * it's concern. (dropping refcnt from swap can be called against removed\n * memcg.)\n */\nstatic struct mem_cgroup *mem_cgroup_lookup(unsigned short id)\n{\n\tstruct cgroup_subsys_state *css;\n\n\t/* ID 0 is unused ID */\n\tif (!id)\n\t\treturn NULL;\n\tcss = css_lookup(&mem_cgroup_subsys, id);\n\tif (!css)\n\t\treturn NULL;\n\treturn container_of(css, struct mem_cgroup, css);\n}\n\nstruct mem_cgroup *try_get_mem_cgroup_from_page(struct page *page)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct page_cgroup *pc;\n\tunsigned short id;\n\tswp_entry_t ent;\n\n\tVM_BUG_ON(!PageLocked(page));\n\n\tpc = lookup_page_cgroup(page);\n\tlock_page_cgroup(pc);\n\tif (PageCgroupUsed(pc)) {\n\t\tmemcg = pc->mem_cgroup;\n\t\tif (memcg && !css_tryget(&memcg->css))\n\t\t\tmemcg = NULL;\n\t} else if (PageSwapCache(page)) {\n\t\tent.val = page_private(page);\n\t\tid = lookup_swap_cgroup_id(ent);\n\t\trcu_read_lock();\n\t\tmemcg = mem_cgroup_lookup(id);\n\t\tif (memcg && !css_tryget(&memcg->css))\n\t\t\tmemcg = NULL;\n\t\trcu_read_unlock();\n\t}\n\tunlock_page_cgroup(pc);\n\treturn memcg;\n}\n\nstatic void __mem_cgroup_commit_charge(struct mem_cgroup *memcg,\n\t\t\t\t       struct page *page,\n\t\t\t\t       unsigned int nr_pages,\n\t\t\t\t       struct page_cgroup *pc,\n\t\t\t\t       enum charge_type ctype)\n{\n\tlock_page_cgroup(pc);\n\tif (unlikely(PageCgroupUsed(pc))) {\n\t\tunlock_page_cgroup(pc);\n\t\t__mem_cgroup_cancel_charge(memcg, nr_pages);\n\t\treturn;\n\t}\n\t/*\n\t * we don't need page_cgroup_lock about tail pages, becase they are not\n\t * accessed by any other context at this point.\n\t */\n\tpc->mem_cgroup = memcg;\n\t/*\n\t * We access a page_cgroup asynchronously without lock_page_cgroup().\n\t * Especially when a page_cgroup is taken from a page, pc->mem_cgroup\n\t * is accessed after testing USED bit. To make pc->mem_cgroup visible\n\t * before USED bit, we need memory barrier here.\n\t * See mem_cgroup_add_lru_list(), etc.\n \t */\n\tsmp_wmb();\n\tswitch (ctype) {\n\tcase MEM_CGROUP_CHARGE_TYPE_CACHE:\n\tcase MEM_CGROUP_CHARGE_TYPE_SHMEM:\n\t\tSetPageCgroupCache(pc);\n\t\tSetPageCgroupUsed(pc);\n\t\tbreak;\n\tcase MEM_CGROUP_CHARGE_TYPE_MAPPED:\n\t\tClearPageCgroupCache(pc);\n\t\tSetPageCgroupUsed(pc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), nr_pages);\n\tunlock_page_cgroup(pc);\n\tWARN_ON_ONCE(PageLRU(page));\n\t/*\n\t * \"charge_statistics\" updated event counter. Then, check it.\n\t * Insert ancestor (and ancestor's ancestors), to softlimit RB-tree.\n\t * if they exceeds softlimit.\n\t */\n\tmemcg_check_events(memcg, page);\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\n#define PCGF_NOCOPY_AT_SPLIT ((1 << PCG_LOCK) | (1 << PCG_MOVE_LOCK) |\\\n\t\t\t(1 << PCG_MIGRATION))\n/*\n * Because tail pages are not marked as \"used\", set it. We're under\n * zone->lru_lock, 'splitting on pmd' and compound_lock.\n * charge/uncharge will be never happen and move_account() is done under\n * compound_lock(), so we don't have to take care of races.\n */\nvoid mem_cgroup_split_huge_fixup(struct page *head)\n{\n\tstruct page_cgroup *head_pc = lookup_page_cgroup(head);\n\tstruct page_cgroup *pc;\n\tint i;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\tpc = head_pc + i;\n\t\tpc->mem_cgroup = head_pc->mem_cgroup;\n\t\tsmp_wmb();/* see __commit_charge() */\n\t\tpc->flags = head_pc->flags & ~PCGF_NOCOPY_AT_SPLIT;\n\t}\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\n/**\n * mem_cgroup_move_account - move account of the page\n * @page: the page\n * @nr_pages: number of regular pages (>1 for huge pages)\n * @pc:\tpage_cgroup of the page.\n * @from: mem_cgroup which the page is moved from.\n * @to:\tmem_cgroup which the page is moved to. @from != @to.\n * @uncharge: whether we should call uncharge and css_put against @from.\n *\n * The caller must confirm following.\n * - page is not on LRU (isolate_page() is useful.)\n * - compound_lock is held when nr_pages > 1\n *\n * This function doesn't do \"charge\" nor css_get to new cgroup. It should be\n * done by a caller(__mem_cgroup_try_charge would be useful). If @uncharge is\n * true, this function does \"uncharge\" from old cgroup, but it doesn't if\n * @uncharge is false, so a caller should do \"uncharge\".\n */\nstatic int mem_cgroup_move_account(struct page *page,\n\t\t\t\t   unsigned int nr_pages,\n\t\t\t\t   struct page_cgroup *pc,\n\t\t\t\t   struct mem_cgroup *from,\n\t\t\t\t   struct mem_cgroup *to,\n\t\t\t\t   bool uncharge)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tVM_BUG_ON(from == to);\n\tVM_BUG_ON(PageLRU(page));\n\t/*\n\t * The page is isolated from LRU. So, collapse function\n\t * will not handle this page. But page splitting can happen.\n\t * Do this check under compound_page_lock(). The caller should\n\t * hold it.\n\t */\n\tret = -EBUSY;\n\tif (nr_pages > 1 && !PageTransHuge(page))\n\t\tgoto out;\n\n\tlock_page_cgroup(pc);\n\n\tret = -EINVAL;\n\tif (!PageCgroupUsed(pc) || pc->mem_cgroup != from)\n\t\tgoto unlock;\n\n\tmove_lock_page_cgroup(pc, &flags);\n\n\tif (PageCgroupFileMapped(pc)) {\n\t\t/* Update mapped_file data for mem_cgroup */\n\t\tpreempt_disable();\n\t\t__this_cpu_dec(from->stat->count[MEM_CGROUP_STAT_FILE_MAPPED]);\n\t\t__this_cpu_inc(to->stat->count[MEM_CGROUP_STAT_FILE_MAPPED]);\n\t\tpreempt_enable();\n\t}\n\tmem_cgroup_charge_statistics(from, PageCgroupCache(pc), -nr_pages);\n\tif (uncharge)\n\t\t/* This is not \"cancel\", but cancel_charge does all we need. */\n\t\t__mem_cgroup_cancel_charge(from, nr_pages);\n\n\t/* caller should have done css_get */\n\tpc->mem_cgroup = to;\n\tmem_cgroup_charge_statistics(to, PageCgroupCache(pc), nr_pages);\n\t/*\n\t * We charges against \"to\" which may not have any tasks. Then, \"to\"\n\t * can be under rmdir(). But in current implementation, caller of\n\t * this function is just force_empty() and move charge, so it's\n\t * guaranteed that \"to\" is never removed. So, we don't check rmdir\n\t * status here.\n\t */\n\tmove_unlock_page_cgroup(pc, &flags);\n\tret = 0;\nunlock:\n\tunlock_page_cgroup(pc);\n\t/*\n\t * check events\n\t */\n\tmemcg_check_events(to, page);\n\tmemcg_check_events(from, page);\nout:\n\treturn ret;\n}\n\n/*\n * move charges to its parent.\n */\n\nstatic int mem_cgroup_move_parent(struct page *page,\n\t\t\t\t  struct page_cgroup *pc,\n\t\t\t\t  struct mem_cgroup *child,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct cgroup *cg = child->css.cgroup;\n\tstruct cgroup *pcg = cg->parent;\n\tstruct mem_cgroup *parent;\n\tunsigned int nr_pages;\n\tunsigned long uninitialized_var(flags);\n\tint ret;\n\n\t/* Is ROOT ? */\n\tif (!pcg)\n\t\treturn -EINVAL;\n\n\tret = -EBUSY;\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tif (isolate_lru_page(page))\n\t\tgoto put;\n\n\tnr_pages = hpage_nr_pages(page);\n\n\tparent = mem_cgroup_from_cont(pcg);\n\tret = __mem_cgroup_try_charge(NULL, gfp_mask, nr_pages, &parent, false);\n\tif (ret)\n\t\tgoto put_back;\n\n\tif (nr_pages > 1)\n\t\tflags = compound_lock_irqsave(page);\n\n\tret = mem_cgroup_move_account(page, nr_pages, pc, child, parent, true);\n\tif (ret)\n\t\t__mem_cgroup_cancel_charge(parent, nr_pages);\n\n\tif (nr_pages > 1)\n\t\tcompound_unlock_irqrestore(page, flags);\nput_back:\n\tputback_lru_page(page);\nput:\n\tput_page(page);\nout:\n\treturn ret;\n}\n\n/*\n * Charge the memory controller for page usage.\n * Return\n * 0 if the charge was successful\n * < 0 if the cgroup is over its limit\n */\nstatic int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\tbool oom = true;\n\tint ret;\n\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t\t/*\n\t\t * Never OOM-kill a process for a huge page.  The\n\t\t * fault handler will fall back to regular pages.\n\t\t */\n\t\toom = false;\n\t}\n\n\tpc = lookup_page_cgroup(page);\n\tret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &memcg, oom);\n\tif (ret == -ENOMEM)\n\t\treturn ret;\n\t__mem_cgroup_commit_charge(memcg, page, nr_pages, pc, ctype);\n\treturn 0;\n}\n\nint mem_cgroup_newpage_charge(struct page *page,\n\t\t\t      struct mm_struct *mm, gfp_t gfp_mask)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\tVM_BUG_ON(page_mapped(page));\n\tVM_BUG_ON(page->mapping && !PageAnon(page));\n\tVM_BUG_ON(!mm);\n\treturn mem_cgroup_charge_common(page, mm, gfp_mask,\n\t\t\t\t\tMEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n\nstatic void\n__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *ptr,\n\t\t\t\t\tenum charge_type ctype);\n\nstatic void\n__mem_cgroup_commit_charge_lrucare(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tstruct page_cgroup *pc = lookup_page_cgroup(page);\n\tstruct zone *zone = page_zone(page);\n\tunsigned long flags;\n\tbool removed = false;\n\n\t/*\n\t * In some case, SwapCache, FUSE(splice_buf->radixtree), the page\n\t * is already on LRU. It means the page may on some other page_cgroup's\n\t * LRU. Take care of it.\n\t */\n\tspin_lock_irqsave(&zone->lru_lock, flags);\n\tif (PageLRU(page)) {\n\t\tdel_page_from_lru_list(zone, page, page_lru(page));\n\t\tClearPageLRU(page);\n\t\tremoved = true;\n\t}\n\t__mem_cgroup_commit_charge(memcg, page, 1, pc, ctype);\n\tif (removed) {\n\t\tadd_page_to_lru_list(zone, page, page_lru(page));\n\t\tSetPageLRU(page);\n\t}\n\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\treturn;\n}\n\nint mem_cgroup_cache_charge(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tenum charge_type type = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\tint ret;\n\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\tif (PageCompound(page))\n\t\treturn 0;\n\n\tif (unlikely(!mm))\n\t\tmm = &init_mm;\n\tif (!page_is_file_cache(page))\n\t\ttype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\n\tif (!PageSwapCache(page))\n\t\tret = mem_cgroup_charge_common(page, mm, gfp_mask, type);\n\telse { /* page is swapcache/shmem */\n\t\tret = mem_cgroup_try_charge_swapin(mm, page, gfp_mask, &memcg);\n\t\tif (!ret)\n\t\t\t__mem_cgroup_commit_charge_swapin(page, memcg, type);\n\t}\n\treturn ret;\n}\n\n/*\n * While swap-in, try_charge -> commit or cancel, the page is locked.\n * And when try_charge() successfully returns, one refcnt to memcg without\n * struct page_cgroup is acquired. This refcnt will be consumed by\n * \"commit()\" or removed by \"cancel()\"\n */\nint mem_cgroup_try_charge_swapin(struct mm_struct *mm,\n\t\t\t\t struct page *page,\n\t\t\t\t gfp_t mask, struct mem_cgroup **memcgp)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\t*memcgp = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\n\tif (!do_swap_account)\n\t\tgoto charge_cur_mm;\n\t/*\n\t * A racing thread's fault, or swapoff, may have already updated\n\t * the pte, and even removed page from swap cache: in those cases\n\t * do_swap_page()'s pte_same() test will fail; but there's also a\n\t * KSM case which does need to charge the page.\n\t */\n\tif (!PageSwapCache(page))\n\t\tgoto charge_cur_mm;\n\tmemcg = try_get_mem_cgroup_from_page(page);\n\tif (!memcg)\n\t\tgoto charge_cur_mm;\n\t*memcgp = memcg;\n\tret = __mem_cgroup_try_charge(NULL, mask, 1, memcgp, true);\n\tcss_put(&memcg->css);\n\tif (ret == -EINTR)\n\t\tret = 0;\n\treturn ret;\ncharge_cur_mm:\n\tif (unlikely(!mm))\n\t\tmm = &init_mm;\n\tret = __mem_cgroup_try_charge(mm, mask, 1, memcgp, true);\n\tif (ret == -EINTR)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void\n__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\tcgroup_exclude_rmdir(&memcg->css);\n\n\t__mem_cgroup_commit_charge_lrucare(page, memcg, ctype);\n\t/*\n\t * Now swap is on-memory. This means this page may be\n\t * counted both as mem and swap....double count.\n\t * Fix it by uncharging from memsw. Basically, this SwapCache is stable\n\t * under lock_page(). But in do_swap_page()::memory.c, reuse_swap_page()\n\t * may call delete_from_swap_cache() before reach here.\n\t */\n\tif (do_swap_account && PageSwapCache(page)) {\n\t\tswp_entry_t ent = {.val = page_private(page)};\n\t\tstruct mem_cgroup *swap_memcg;\n\t\tunsigned short id;\n\n\t\tid = swap_cgroup_record(ent, 0);\n\t\trcu_read_lock();\n\t\tswap_memcg = mem_cgroup_lookup(id);\n\t\tif (swap_memcg) {\n\t\t\t/*\n\t\t\t * This recorded memcg can be obsolete one. So, avoid\n\t\t\t * calling css_tryget\n\t\t\t */\n\t\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\t\tres_counter_uncharge(&swap_memcg->memsw,\n\t\t\t\t\t\t     PAGE_SIZE);\n\t\t\tmem_cgroup_swap_statistics(swap_memcg, false);\n\t\t\tmem_cgroup_put(swap_memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\t/*\n\t * At swapin, we may charge account against cgroup which has no tasks.\n\t * So, rmdir()->pre_destroy() can be called while we do this charge.\n\t * In that case, we need to call pre_destroy() again. check it here.\n\t */\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}\n\nvoid mem_cgroup_commit_charge_swapin(struct page *page,\n\t\t\t\t     struct mem_cgroup *memcg)\n{\n\t__mem_cgroup_commit_charge_swapin(page, memcg,\n\t\t\t\t\t  MEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n\nvoid mem_cgroup_cancel_charge_swapin(struct mem_cgroup *memcg)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\t__mem_cgroup_cancel_charge(memcg, 1);\n}\n\nstatic void mem_cgroup_do_uncharge(struct mem_cgroup *memcg,\n\t\t\t\t   unsigned int nr_pages,\n\t\t\t\t   const enum charge_type ctype)\n{\n\tstruct memcg_batch_info *batch = NULL;\n\tbool uncharge_memsw = true;\n\n\t/* If swapout, usage of swap doesn't decrease */\n\tif (!do_swap_account || ctype == MEM_CGROUP_CHARGE_TYPE_SWAPOUT)\n\t\tuncharge_memsw = false;\n\n\tbatch = &current->memcg_batch;\n\t/*\n\t * In usual, we do css_get() when we remember memcg pointer.\n\t * But in this case, we keep res->usage until end of a series of\n\t * uncharges. Then, it's ok to ignore memcg's refcnt.\n\t */\n\tif (!batch->memcg)\n\t\tbatch->memcg = memcg;\n\t/*\n\t * do_batch > 0 when unmapping pages or inode invalidate/truncate.\n\t * In those cases, all pages freed continuously can be expected to be in\n\t * the same cgroup and we have chance to coalesce uncharges.\n\t * But we do uncharge one by one if this is killed by OOM(TIF_MEMDIE)\n\t * because we want to do uncharge as soon as possible.\n\t */\n\n\tif (!batch->do_batch || test_thread_flag(TIF_MEMDIE))\n\t\tgoto direct_uncharge;\n\n\tif (nr_pages > 1)\n\t\tgoto direct_uncharge;\n\n\t/*\n\t * In typical case, batch->memcg == mem. This means we can\n\t * merge a series of uncharges to an uncharge of res_counter.\n\t * If not, we uncharge res_counter ony by one.\n\t */\n\tif (batch->memcg != memcg)\n\t\tgoto direct_uncharge;\n\t/* remember freed charge and uncharge it later */\n\tbatch->nr_pages++;\n\tif (uncharge_memsw)\n\t\tbatch->memsw_nr_pages++;\n\treturn;\ndirect_uncharge:\n\tres_counter_uncharge(&memcg->res, nr_pages * PAGE_SIZE);\n\tif (uncharge_memsw)\n\t\tres_counter_uncharge(&memcg->memsw, nr_pages * PAGE_SIZE);\n\tif (unlikely(batch->memcg != memcg))\n\t\tmemcg_oom_recover(memcg);\n\treturn;\n}\n\n/*\n * uncharge if !page_mapped(page)\n */\nstatic struct mem_cgroup *\n__mem_cgroup_uncharge_common(struct page *page, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (PageSwapCache(page))\n\t\treturn NULL;\n\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t}\n\t/*\n\t * Check if our page_cgroup is valid\n\t */\n\tpc = lookup_page_cgroup(page);\n\tif (unlikely(!PageCgroupUsed(pc)))\n\t\treturn NULL;\n\n\tlock_page_cgroup(pc);\n\n\tmemcg = pc->mem_cgroup;\n\n\tif (!PageCgroupUsed(pc))\n\t\tgoto unlock_out;\n\n\tswitch (ctype) {\n\tcase MEM_CGROUP_CHARGE_TYPE_MAPPED:\n\tcase MEM_CGROUP_CHARGE_TYPE_DROP:\n\t\t/* See mem_cgroup_prepare_migration() */\n\t\tif (page_mapped(page) || PageCgroupMigration(pc))\n\t\t\tgoto unlock_out;\n\t\tbreak;\n\tcase MEM_CGROUP_CHARGE_TYPE_SWAPOUT:\n\t\tif (!PageAnon(page)) {\t/* Shared memory */\n\t\t\tif (page->mapping && !page_is_file_cache(page))\n\t\t\t\tgoto unlock_out;\n\t\t} else if (page_mapped(page)) /* Anon */\n\t\t\t\tgoto unlock_out;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), -nr_pages);\n\n\tClearPageCgroupUsed(pc);\n\t/*\n\t * pc->mem_cgroup is not cleared here. It will be accessed when it's\n\t * freed from LRU. This is safe because uncharged page is expected not\n\t * to be reused (freed soon). Exception is SwapCache, it's handled by\n\t * special functions.\n\t */\n\n\tunlock_page_cgroup(pc);\n\t/*\n\t * even after unlock, we have memcg->res.usage here and this memcg\n\t * will never be freed.\n\t */\n\tmemcg_check_events(memcg, page);\n\tif (do_swap_account && ctype == MEM_CGROUP_CHARGE_TYPE_SWAPOUT) {\n\t\tmem_cgroup_swap_statistics(memcg, true);\n\t\tmem_cgroup_get(memcg);\n\t}\n\tif (!mem_cgroup_is_root(memcg))\n\t\tmem_cgroup_do_uncharge(memcg, nr_pages, ctype);\n\n\treturn memcg;\n\nunlock_out:\n\tunlock_page_cgroup(pc);\n\treturn NULL;\n}\n\nvoid mem_cgroup_uncharge_page(struct page *page)\n{\n\t/* early check. */\n\tif (page_mapped(page))\n\t\treturn;\n\tVM_BUG_ON(page->mapping && !PageAnon(page));\n\t__mem_cgroup_uncharge_common(page, MEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n\nvoid mem_cgroup_uncharge_cache_page(struct page *page)\n{\n\tVM_BUG_ON(page_mapped(page));\n\tVM_BUG_ON(page->mapping);\n\t__mem_cgroup_uncharge_common(page, MEM_CGROUP_CHARGE_TYPE_CACHE);\n}\n\n/*\n * Batch_start/batch_end is called in unmap_page_range/invlidate/trucate.\n * In that cases, pages are freed continuously and we can expect pages\n * are in the same memcg. All these calls itself limits the number of\n * pages freed at once, then uncharge_start/end() is called properly.\n * This may be called prural(2) times in a context,\n */\n\nvoid mem_cgroup_uncharge_start(void)\n{\n\tcurrent->memcg_batch.do_batch++;\n\t/* We can do nest. */\n\tif (current->memcg_batch.do_batch == 1) {\n\t\tcurrent->memcg_batch.memcg = NULL;\n\t\tcurrent->memcg_batch.nr_pages = 0;\n\t\tcurrent->memcg_batch.memsw_nr_pages = 0;\n\t}\n}\n\nvoid mem_cgroup_uncharge_end(void)\n{\n\tstruct memcg_batch_info *batch = &current->memcg_batch;\n\n\tif (!batch->do_batch)\n\t\treturn;\n\n\tbatch->do_batch--;\n\tif (batch->do_batch) /* If stacked, do nothing. */\n\t\treturn;\n\n\tif (!batch->memcg)\n\t\treturn;\n\t/*\n\t * This \"batch->memcg\" is valid without any css_get/put etc...\n\t * bacause we hide charges behind us.\n\t */\n\tif (batch->nr_pages)\n\t\tres_counter_uncharge(&batch->memcg->res,\n\t\t\t\t     batch->nr_pages * PAGE_SIZE);\n\tif (batch->memsw_nr_pages)\n\t\tres_counter_uncharge(&batch->memcg->memsw,\n\t\t\t\t     batch->memsw_nr_pages * PAGE_SIZE);\n\tmemcg_oom_recover(batch->memcg);\n\t/* forget this pointer (for sanity check) */\n\tbatch->memcg = NULL;\n}\n\n/*\n * A function for resetting pc->mem_cgroup for newly allocated pages.\n * This function should be called if the newpage will be added to LRU\n * before start accounting.\n */\nvoid mem_cgroup_reset_owner(struct page *newpage)\n{\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(newpage);\n\tVM_BUG_ON(PageCgroupUsed(pc));\n\tpc->mem_cgroup = root_mem_cgroup;\n}\n\n#ifdef CONFIG_SWAP\n/*\n * called after __delete_from_swap_cache() and drop \"page\" account.\n * memcg information is recorded to swap_cgroup of \"ent\"\n */\nvoid\nmem_cgroup_uncharge_swapcache(struct page *page, swp_entry_t ent, bool swapout)\n{\n\tstruct mem_cgroup *memcg;\n\tint ctype = MEM_CGROUP_CHARGE_TYPE_SWAPOUT;\n\n\tif (!swapout) /* this was a swap cache but the swap is unused ! */\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_DROP;\n\n\tmemcg = __mem_cgroup_uncharge_common(page, ctype);\n\n\t/*\n\t * record memcg information,  if swapout && memcg != NULL,\n\t * mem_cgroup_get() was called in uncharge().\n\t */\n\tif (do_swap_account && swapout && memcg)\n\t\tswap_cgroup_record(ent, css_id(&memcg->css));\n}\n#endif\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\n/*\n * called from swap_entry_free(). remove record in swap_cgroup and\n * uncharge \"memsw\" account.\n */\nvoid mem_cgroup_uncharge_swap(swp_entry_t ent)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(ent, 0);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_lookup(id);\n\tif (memcg) {\n\t\t/*\n\t\t * We uncharge this because swap is freed.\n\t\t * This memcg can be obsolete one. We avoid calling css_tryget\n\t\t */\n\t\tif (!mem_cgroup_is_root(memcg))\n\t\t\tres_counter_uncharge(&memcg->memsw, PAGE_SIZE);\n\t\tmem_cgroup_swap_statistics(memcg, false);\n\t\tmem_cgroup_put(memcg);\n\t}\n\trcu_read_unlock();\n}\n\n/**\n * mem_cgroup_move_swap_account - move swap charge and swap_cgroup's record.\n * @entry: swap entry to be moved\n * @from:  mem_cgroup which the entry is moved from\n * @to:  mem_cgroup which the entry is moved to\n * @need_fixup: whether we should fixup res_counters and refcounts.\n *\n * It succeeds only when the swap_cgroup's record for this entry is the same\n * as the mem_cgroup's id of @from.\n *\n * Returns 0 on success, -EINVAL on failure.\n *\n * The caller must have charged to @to, IOW, called res_counter_charge() about\n * both res and memsw, and called css_get().\n */\nstatic int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\tstruct mem_cgroup *from, struct mem_cgroup *to, bool need_fixup)\n{\n\tunsigned short old_id, new_id;\n\n\told_id = css_id(&from->css);\n\tnew_id = css_id(&to->css);\n\n\tif (swap_cgroup_cmpxchg(entry, old_id, new_id) == old_id) {\n\t\tmem_cgroup_swap_statistics(from, false);\n\t\tmem_cgroup_swap_statistics(to, true);\n\t\t/*\n\t\t * This function is only called from task migration context now.\n\t\t * It postpones res_counter and refcount handling till the end\n\t\t * of task migration(mem_cgroup_clear_mc()) for performance\n\t\t * improvement. But we cannot postpone mem_cgroup_get(to)\n\t\t * because if the process that has been moved to @to does\n\t\t * swap-in, the refcount of @to might be decreased to 0.\n\t\t */\n\t\tmem_cgroup_get(to);\n\t\tif (need_fixup) {\n\t\t\tif (!mem_cgroup_is_root(from))\n\t\t\t\tres_counter_uncharge(&from->memsw, PAGE_SIZE);\n\t\t\tmem_cgroup_put(from);\n\t\t\t/*\n\t\t\t * we charged both to->res and to->memsw, so we should\n\t\t\t * uncharge to->res.\n\t\t\t */\n\t\t\tif (!mem_cgroup_is_root(to))\n\t\t\t\tres_counter_uncharge(&to->res, PAGE_SIZE);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n#else\nstatic inline int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\tstruct mem_cgroup *from, struct mem_cgroup *to, bool need_fixup)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Before starting migration, account PAGE_SIZE to mem_cgroup that the old\n * page belongs to.\n */\nint mem_cgroup_prepare_migration(struct page *page,\n\tstruct page *newpage, struct mem_cgroup **memcgp, gfp_t gfp_mask)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct page_cgroup *pc;\n\tenum charge_type ctype;\n\tint ret = 0;\n\n\t*memcgp = NULL;\n\n\tVM_BUG_ON(PageTransHuge(page));\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\n\tpc = lookup_page_cgroup(page);\n\tlock_page_cgroup(pc);\n\tif (PageCgroupUsed(pc)) {\n\t\tmemcg = pc->mem_cgroup;\n\t\tcss_get(&memcg->css);\n\t\t/*\n\t\t * At migrating an anonymous page, its mapcount goes down\n\t\t * to 0 and uncharge() will be called. But, even if it's fully\n\t\t * unmapped, migration may fail and this page has to be\n\t\t * charged again. We set MIGRATION flag here and delay uncharge\n\t\t * until end_migration() is called\n\t\t *\n\t\t * Corner Case Thinking\n\t\t * A)\n\t\t * When the old page was mapped as Anon and it's unmap-and-freed\n\t\t * while migration was ongoing.\n\t\t * If unmap finds the old page, uncharge() of it will be delayed\n\t\t * until end_migration(). If unmap finds a new page, it's\n\t\t * uncharged when it make mapcount to be 1->0. If unmap code\n\t\t * finds swap_migration_entry, the new page will not be mapped\n\t\t * and end_migration() will find it(mapcount==0).\n\t\t *\n\t\t * B)\n\t\t * When the old page was mapped but migraion fails, the kernel\n\t\t * remaps it. A charge for it is kept by MIGRATION flag even\n\t\t * if mapcount goes down to 0. We can do remap successfully\n\t\t * without charging it again.\n\t\t *\n\t\t * C)\n\t\t * The \"old\" page is under lock_page() until the end of\n\t\t * migration, so, the old page itself will not be swapped-out.\n\t\t * If the new page is swapped out before end_migraton, our\n\t\t * hook to usual swap-out path will catch the event.\n\t\t */\n\t\tif (PageAnon(page))\n\t\t\tSetPageCgroupMigration(pc);\n\t}\n\tunlock_page_cgroup(pc);\n\t/*\n\t * If the page is not charged at this point,\n\t * we return here.\n\t */\n\tif (!memcg)\n\t\treturn 0;\n\n\t*memcgp = memcg;\n\tret = __mem_cgroup_try_charge(NULL, gfp_mask, 1, memcgp, false);\n\tcss_put(&memcg->css);/* drop extra refcnt */\n\tif (ret) {\n\t\tif (PageAnon(page)) {\n\t\t\tlock_page_cgroup(pc);\n\t\t\tClearPageCgroupMigration(pc);\n\t\t\tunlock_page_cgroup(pc);\n\t\t\t/*\n\t\t\t * The old page may be fully unmapped while we kept it.\n\t\t\t */\n\t\t\tmem_cgroup_uncharge_page(page);\n\t\t}\n\t\t/* we'll need to revisit this error code (we have -EINTR) */\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * We charge new page before it's used/mapped. So, even if unlock_page()\n\t * is called before end_migration, we can catch all events on this new\n\t * page. In the case new page is migrated but not remapped, new page's\n\t * mapcount will be finally 0 and we call uncharge in end_migration().\n\t */\n\tpc = lookup_page_cgroup(newpage);\n\tif (PageAnon(page))\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_MAPPED;\n\telse if (page_is_file_cache(page))\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\telse\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\t__mem_cgroup_commit_charge(memcg, newpage, 1, pc, ctype);\n\treturn ret;\n}\n\n/* remove redundant charge if migration failed*/\nvoid mem_cgroup_end_migration(struct mem_cgroup *memcg,\n\tstruct page *oldpage, struct page *newpage, bool migration_ok)\n{\n\tstruct page *used, *unused;\n\tstruct page_cgroup *pc;\n\n\tif (!memcg)\n\t\treturn;\n\t/* blocks rmdir() */\n\tcgroup_exclude_rmdir(&memcg->css);\n\tif (!migration_ok) {\n\t\tused = oldpage;\n\t\tunused = newpage;\n\t} else {\n\t\tused = newpage;\n\t\tunused = oldpage;\n\t}\n\t/*\n\t * We disallowed uncharge of pages under migration because mapcount\n\t * of the page goes down to zero, temporarly.\n\t * Clear the flag and check the page should be charged.\n\t */\n\tpc = lookup_page_cgroup(oldpage);\n\tlock_page_cgroup(pc);\n\tClearPageCgroupMigration(pc);\n\tunlock_page_cgroup(pc);\n\n\t__mem_cgroup_uncharge_common(unused, MEM_CGROUP_CHARGE_TYPE_FORCE);\n\n\t/*\n\t * If a page is a file cache, radix-tree replacement is very atomic\n\t * and we can skip this check. When it was an Anon page, its mapcount\n\t * goes down to 0. But because we added MIGRATION flage, it's not\n\t * uncharged yet. There are several case but page->mapcount check\n\t * and USED bit check in mem_cgroup_uncharge_page() will do enough\n\t * check. (see prepare_charge() also)\n\t */\n\tif (PageAnon(used))\n\t\tmem_cgroup_uncharge_page(used);\n\t/*\n\t * At migration, we may charge account against cgroup which has no\n\t * tasks.\n\t * So, rmdir()->pre_destroy() can be called while we do this charge.\n\t * In that case, we need to call pre_destroy() again. check it here.\n\t */\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}\n\n/*\n * At replace page cache, newpage is not under any memcg but it's on\n * LRU. So, this function doesn't touch res_counter but handles LRU\n * in correct way. Both pages are locked so we cannot race with uncharge.\n */\nvoid mem_cgroup_replace_page_cache(struct page *oldpage,\n\t\t\t\t  struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\tenum charge_type type = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(oldpage);\n\t/* fix accounting on old pages */\n\tlock_page_cgroup(pc);\n\tmemcg = pc->mem_cgroup;\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), -1);\n\tClearPageCgroupUsed(pc);\n\tunlock_page_cgroup(pc);\n\n\tif (PageSwapBacked(oldpage))\n\t\ttype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\n\t/*\n\t * Even if newpage->mapping was NULL before starting replacement,\n\t * the newpage may be on LRU(or pagevec for LRU) already. We lock\n\t * LRU while we overwrite pc->mem_cgroup.\n\t */\n\t__mem_cgroup_commit_charge_lrucare(newpage, memcg, type);\n}\n\n#ifdef CONFIG_DEBUG_VM\nstatic struct page_cgroup *lookup_page_cgroup_used(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\n\tpc = lookup_page_cgroup(page);\n\t/*\n\t * Can be NULL while feeding pages into the page allocator for\n\t * the first time, i.e. during boot or memory hotplug;\n\t * or when mem_cgroup_disabled().\n\t */\n\tif (likely(pc) && PageCgroupUsed(pc))\n\t\treturn pc;\n\treturn NULL;\n}\n\nbool mem_cgroup_bad_page_check(struct page *page)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn false;\n\n\treturn lookup_page_cgroup_used(page) != NULL;\n}\n\nvoid mem_cgroup_print_bad_page(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\n\tpc = lookup_page_cgroup_used(page);\n\tif (pc) {\n\t\tprintk(KERN_ALERT \"pc:%p pc->flags:%lx pc->mem_cgroup:%p\\n\",\n\t\t       pc, pc->flags, pc->mem_cgroup);\n\t}\n}\n#endif\n\nstatic DEFINE_MUTEX(set_limit_mutex);\n\nstatic int mem_cgroup_resize_limit(struct mem_cgroup *memcg,\n\t\t\t\tunsigned long long val)\n{\n\tint retry_count;\n\tu64 memswlimit, memlimit;\n\tint ret = 0;\n\tint children = mem_cgroup_count_children(memcg);\n\tu64 curusage, oldusage;\n\tint enlarge;\n\n\t/*\n\t * For keeping hierarchical_reclaim simple, how long we should retry\n\t * is depends on callers. We set our retry-count to be function\n\t * of # of children which we should visit in this loop.\n\t */\n\tretry_count = MEM_CGROUP_RECLAIM_RETRIES * children;\n\n\toldusage = res_counter_read_u64(&memcg->res, RES_USAGE);\n\n\tenlarge = 0;\n\twhile (retry_count) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Rather than hide all in some function, I do this in\n\t\t * open coded manner. You see what this really does.\n\t\t * We have to guarantee memcg->res.limit < memcg->memsw.limit.\n\t\t */\n\t\tmutex_lock(&set_limit_mutex);\n\t\tmemswlimit = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t\tif (memswlimit < val) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&set_limit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemlimit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\t\tif (memlimit < val)\n\t\t\tenlarge = 1;\n\n\t\tret = res_counter_set_limit(&memcg->res, val);\n\t\tif (!ret) {\n\t\t\tif (memswlimit == val)\n\t\t\t\tmemcg->memsw_is_minimum = true;\n\t\t\telse\n\t\t\t\tmemcg->memsw_is_minimum = false;\n\t\t}\n\t\tmutex_unlock(&set_limit_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmem_cgroup_reclaim(memcg, GFP_KERNEL,\n\t\t\t\t   MEM_CGROUP_RECLAIM_SHRINK);\n\t\tcurusage = res_counter_read_u64(&memcg->res, RES_USAGE);\n\t\t/* Usage is reduced ? */\n  \t\tif (curusage >= oldusage)\n\t\t\tretry_count--;\n\t\telse\n\t\t\toldusage = curusage;\n\t}\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn ret;\n}\n\nstatic int mem_cgroup_resize_memsw_limit(struct mem_cgroup *memcg,\n\t\t\t\t\tunsigned long long val)\n{\n\tint retry_count;\n\tu64 memlimit, memswlimit, oldusage, curusage;\n\tint children = mem_cgroup_count_children(memcg);\n\tint ret = -EBUSY;\n\tint enlarge = 0;\n\n\t/* see mem_cgroup_resize_res_limit */\n \tretry_count = children * MEM_CGROUP_RECLAIM_RETRIES;\n\toldusage = res_counter_read_u64(&memcg->memsw, RES_USAGE);\n\twhile (retry_count) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Rather than hide all in some function, I do this in\n\t\t * open coded manner. You see what this really does.\n\t\t * We have to guarantee memcg->res.limit < memcg->memsw.limit.\n\t\t */\n\t\tmutex_lock(&set_limit_mutex);\n\t\tmemlimit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\t\tif (memlimit > val) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&set_limit_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tmemswlimit = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t\tif (memswlimit < val)\n\t\t\tenlarge = 1;\n\t\tret = res_counter_set_limit(&memcg->memsw, val);\n\t\tif (!ret) {\n\t\t\tif (memlimit == val)\n\t\t\t\tmemcg->memsw_is_minimum = true;\n\t\t\telse\n\t\t\t\tmemcg->memsw_is_minimum = false;\n\t\t}\n\t\tmutex_unlock(&set_limit_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmem_cgroup_reclaim(memcg, GFP_KERNEL,\n\t\t\t\t   MEM_CGROUP_RECLAIM_NOSWAP |\n\t\t\t\t   MEM_CGROUP_RECLAIM_SHRINK);\n\t\tcurusage = res_counter_read_u64(&memcg->memsw, RES_USAGE);\n\t\t/* Usage is reduced ? */\n\t\tif (curusage >= oldusage)\n\t\t\tretry_count--;\n\t\telse\n\t\t\toldusage = curusage;\n\t}\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\treturn ret;\n}\n\nunsigned long mem_cgroup_soft_limit_reclaim(struct zone *zone, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_zone *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\tunsigned long long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node_zone(zone_to_nid(zone), zone_idx(zone));\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->mem, zone,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock(&mctz->lock);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed) {\n\t\t\tdo {\n\t\t\t\t/*\n\t\t\t\t * Loop until we find yet another one.\n\t\t\t\t *\n\t\t\t\t * By the time we get the soft_limit lock\n\t\t\t\t * again, someone might have aded the\n\t\t\t\t * group back on the RB tree. Iterate to\n\t\t\t\t * make sure we get a different mem.\n\t\t\t\t * mem_cgroup_largest_soft_limit_node returns\n\t\t\t\t * NULL if no other cgroup is present on\n\t\t\t\t * the tree\n\t\t\t\t */\n\t\t\t\tnext_mz =\n\t\t\t\t__mem_cgroup_largest_soft_limit_node(mctz);\n\t\t\t\tif (next_mz == mz)\n\t\t\t\t\tcss_put(&next_mz->mem->css);\n\t\t\t\telse /* next_mz == NULL or other memcg */\n\t\t\t\t\tbreak;\n\t\t\t} while (1);\n\t\t}\n\t\t__mem_cgroup_remove_exceeded(mz->mem, mz, mctz);\n\t\texcess = res_counter_soft_limit_excess(&mz->mem->res);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz->mem, mz, mctz, excess);\n\t\tspin_unlock(&mctz->lock);\n\t\tcss_put(&mz->mem->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->mem->css);\n\treturn nr_reclaimed;\n}\n\n/*\n * This routine traverse page_cgroup in given list and drop them all.\n * *And* this routine doesn't reclaim page itself, just removes page_cgroup.\n */\nstatic int mem_cgroup_force_empty_list(struct mem_cgroup *memcg,\n\t\t\t\tint node, int zid, enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tunsigned long flags, loop;\n\tstruct list_head *list;\n\tstruct page *busy;\n\tstruct zone *zone;\n\tint ret = 0;\n\n\tzone = &NODE_DATA(node)->node_zones[zid];\n\tmz = mem_cgroup_zoneinfo(memcg, node, zid);\n\tlist = &mz->lruvec.lists[lru];\n\n\tloop = MEM_CGROUP_ZSTAT(mz, lru);\n\t/* give some margin against EBUSY etc...*/\n\tloop += 256;\n\tbusy = NULL;\n\twhile (loop--) {\n\t\tstruct page_cgroup *pc;\n\t\tstruct page *page;\n\n\t\tret = 0;\n\t\tspin_lock_irqsave(&zone->lru_lock, flags);\n\t\tif (list_empty(list)) {\n\t\t\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tpage = list_entry(list->prev, struct page, lru);\n\t\tif (busy == page) {\n\t\t\tlist_move(&page->lru, list);\n\t\t\tbusy = NULL;\n\t\t\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\n\t\tpc = lookup_page_cgroup(page);\n\n\t\tret = mem_cgroup_move_parent(page, pc, memcg, GFP_KERNEL);\n\t\tif (ret == -ENOMEM || ret == -EINTR)\n\t\t\tbreak;\n\n\t\tif (ret == -EBUSY || ret == -EINVAL) {\n\t\t\t/* found lock contention or \"pc\" is obsolete. */\n\t\t\tbusy = page;\n\t\t\tcond_resched();\n\t\t} else\n\t\t\tbusy = NULL;\n\t}\n\n\tif (!ret && !list_empty(list))\n\t\treturn -EBUSY;\n\treturn ret;\n}\n\n/*\n * make mem_cgroup's charge to be 0 if there is no task.\n * This enables deleting this mem_cgroup.\n */\nstatic int mem_cgroup_force_empty(struct mem_cgroup *memcg, bool free_all)\n{\n\tint ret;\n\tint node, zid, shrink;\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct cgroup *cgrp = memcg->css.cgroup;\n\n\tcss_get(&memcg->css);\n\n\tshrink = 0;\n\t/* should free all ? */\n\tif (free_all)\n\t\tgoto try_to_free;\nmove_account:\n\tdo {\n\t\tret = -EBUSY;\n\t\tif (cgroup_task_count(cgrp) || !list_empty(&cgrp->children))\n\t\t\tgoto out;\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\t/* This is for making all *used* pages to be on LRU. */\n\t\tlru_add_drain_all();\n\t\tdrain_all_stock_sync(memcg);\n\t\tret = 0;\n\t\tmem_cgroup_start_move(memcg);\n\t\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\t\tfor (zid = 0; !ret && zid < MAX_NR_ZONES; zid++) {\n\t\t\t\tenum lru_list l;\n\t\t\t\tfor_each_lru(l) {\n\t\t\t\t\tret = mem_cgroup_force_empty_list(memcg,\n\t\t\t\t\t\t\tnode, zid, l);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tmem_cgroup_end_move(memcg);\n\t\tmemcg_oom_recover(memcg);\n\t\t/* it seems parent cgroup doesn't have enough mem */\n\t\tif (ret == -ENOMEM)\n\t\t\tgoto try_to_free;\n\t\tcond_resched();\n\t/* \"ret\" should also be checked to ensure all lists are empty. */\n\t} while (memcg->res.usage > 0 || ret);\nout:\n\tcss_put(&memcg->css);\n\treturn ret;\n\ntry_to_free:\n\t/* returns EBUSY if there is a task or if we come here twice. */\n\tif (cgroup_task_count(cgrp) || !list_empty(&cgrp->children) || shrink) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\t/* we call try-to-free pages for make this cgroup empty */\n\tlru_add_drain_all();\n\t/* try to free all pages in this cgroup */\n\tshrink = 1;\n\twhile (nr_retries && memcg->res.usage > 0) {\n\t\tint progress;\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tprogress = try_to_free_mem_cgroup_pages(memcg, GFP_KERNEL,\n\t\t\t\t\t\tfalse);\n\t\tif (!progress) {\n\t\t\tnr_retries--;\n\t\t\t/* maybe some writeback is necessary */\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t}\n\tlru_add_drain();\n\t/* try move_account...there may be some *locked* pages. */\n\tgoto move_account;\n}\n\nint mem_cgroup_force_empty_write(struct cgroup *cont, unsigned int event)\n{\n\treturn mem_cgroup_force_empty(mem_cgroup_from_cont(cont), true);\n}\n\n\nstatic u64 mem_cgroup_hierarchy_read(struct cgroup *cont, struct cftype *cft)\n{\n\treturn mem_cgroup_from_cont(cont)->use_hierarchy;\n}\n\nstatic int mem_cgroup_hierarchy_write(struct cgroup *cont, struct cftype *cft,\n\t\t\t\t\tu64 val)\n{\n\tint retval = 0;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\tstruct cgroup *parent = cont->parent;\n\tstruct mem_cgroup *parent_memcg = NULL;\n\n\tif (parent)\n\t\tparent_memcg = mem_cgroup_from_cont(parent);\n\n\tcgroup_lock();\n\t/*\n\t * If parent's use_hierarchy is set, we can't make any modifications\n\t * in the child subtrees. If it is unset, then the change can\n\t * occur, provided the current cgroup has no children.\n\t *\n\t * For the root cgroup, parent_mem is NULL, we allow value to be\n\t * set if there are no children.\n\t */\n\tif ((!parent_memcg || !parent_memcg->use_hierarchy) &&\n\t\t\t\t(val == 1 || val == 0)) {\n\t\tif (list_empty(&cont->children))\n\t\t\tmemcg->use_hierarchy = val;\n\t\telse\n\t\t\tretval = -EBUSY;\n\t} else\n\t\tretval = -EINVAL;\n\tcgroup_unlock();\n\n\treturn retval;\n}\n\n\nstatic unsigned long mem_cgroup_recursive_stat(struct mem_cgroup *memcg,\n\t\t\t\t\t       enum mem_cgroup_stat_index idx)\n{\n\tstruct mem_cgroup *iter;\n\tlong val = 0;\n\n\t/* Per-cpu values can be negative, use a signed accumulator */\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tval += mem_cgroup_read_stat(iter, idx);\n\n\tif (val < 0) /* race ? */\n\t\tval = 0;\n\treturn val;\n}\n\nstatic inline u64 mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)\n{\n\tu64 val;\n\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tif (!swap)\n\t\t\treturn res_counter_read_u64(&memcg->res, RES_USAGE);\n\t\telse\n\t\t\treturn res_counter_read_u64(&memcg->memsw, RES_USAGE);\n\t}\n\n\tval = mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_CACHE);\n\tval += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_RSS);\n\n\tif (swap)\n\t\tval += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_SWAPOUT);\n\n\treturn val << PAGE_SHIFT;\n}\n\nstatic u64 mem_cgroup_read(struct cgroup *cont, struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\tu64 val;\n\tint type, name;\n\n\ttype = MEMFILE_TYPE(cft->private);\n\tname = MEMFILE_ATTR(cft->private);\n\tswitch (type) {\n\tcase _MEM:\n\t\tif (name == RES_USAGE)\n\t\t\tval = mem_cgroup_usage(memcg, false);\n\t\telse\n\t\t\tval = res_counter_read_u64(&memcg->res, name);\n\t\tbreak;\n\tcase _MEMSWAP:\n\t\tif (name == RES_USAGE)\n\t\t\tval = mem_cgroup_usage(memcg, true);\n\t\telse\n\t\t\tval = res_counter_read_u64(&memcg->memsw, name);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\treturn val;\n}\n/*\n * The user of this function is...\n * RES_LIMIT.\n */\nstatic int mem_cgroup_write(struct cgroup *cont, struct cftype *cft,\n\t\t\t    const char *buffer)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\tint type, name;\n\tunsigned long long val;\n\tint ret;\n\n\ttype = MEMFILE_TYPE(cft->private);\n\tname = MEMFILE_ATTR(cft->private);\n\tswitch (name) {\n\tcase RES_LIMIT:\n\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* This function does all necessary parse...reuse it */\n\t\tret = res_counter_memparse_write_strategy(buffer, &val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (type == _MEM)\n\t\t\tret = mem_cgroup_resize_limit(memcg, val);\n\t\telse\n\t\t\tret = mem_cgroup_resize_memsw_limit(memcg, val);\n\t\tbreak;\n\tcase RES_SOFT_LIMIT:\n\t\tret = res_counter_memparse_write_strategy(buffer, &val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * For memsw, soft limits are hard to implement in terms\n\t\t * of semantics, for now, we support soft limits for\n\t\t * control without swap\n\t\t */\n\t\tif (type == _MEM)\n\t\t\tret = res_counter_set_soft_limit(&memcg->res, val);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL; /* should be BUG() ? */\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void memcg_get_hierarchical_limit(struct mem_cgroup *memcg,\n\t\tunsigned long long *mem_limit, unsigned long long *memsw_limit)\n{\n\tstruct cgroup *cgroup;\n\tunsigned long long min_limit, min_memsw_limit, tmp;\n\n\tmin_limit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\tmin_memsw_limit = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\tcgroup = memcg->css.cgroup;\n\tif (!memcg->use_hierarchy)\n\t\tgoto out;\n\n\twhile (cgroup->parent) {\n\t\tcgroup = cgroup->parent;\n\t\tmemcg = mem_cgroup_from_cont(cgroup);\n\t\tif (!memcg->use_hierarchy)\n\t\t\tbreak;\n\t\ttmp = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\t\tmin_limit = min(min_limit, tmp);\n\t\ttmp = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t\tmin_memsw_limit = min(min_memsw_limit, tmp);\n\t}\nout:\n\t*mem_limit = min_limit;\n\t*memsw_limit = min_memsw_limit;\n\treturn;\n}\n\nstatic int mem_cgroup_reset(struct cgroup *cont, unsigned int event)\n{\n\tstruct mem_cgroup *memcg;\n\tint type, name;\n\n\tmemcg = mem_cgroup_from_cont(cont);\n\ttype = MEMFILE_TYPE(event);\n\tname = MEMFILE_ATTR(event);\n\tswitch (name) {\n\tcase RES_MAX_USAGE:\n\t\tif (type == _MEM)\n\t\t\tres_counter_reset_max(&memcg->res);\n\t\telse\n\t\t\tres_counter_reset_max(&memcg->memsw);\n\t\tbreak;\n\tcase RES_FAILCNT:\n\t\tif (type == _MEM)\n\t\t\tres_counter_reset_failcnt(&memcg->res);\n\t\telse\n\t\t\tres_counter_reset_failcnt(&memcg->memsw);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 mem_cgroup_move_charge_read(struct cgroup *cgrp,\n\t\t\t\t\tstruct cftype *cft)\n{\n\treturn mem_cgroup_from_cont(cgrp)->move_charge_at_immigrate;\n}\n\n#ifdef CONFIG_MMU\nstatic int mem_cgroup_move_charge_write(struct cgroup *cgrp,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\n\tif (val >= (1 << NR_MOVE_TYPE))\n\t\treturn -EINVAL;\n\t/*\n\t * We check this value several times in both in can_attach() and\n\t * attach(), so we need cgroup lock to prevent this value from being\n\t * inconsistent.\n\t */\n\tcgroup_lock();\n\tmemcg->move_charge_at_immigrate = val;\n\tcgroup_unlock();\n\n\treturn 0;\n}\n#else\nstatic int mem_cgroup_move_charge_write(struct cgroup *cgrp,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\treturn -ENOSYS;\n}\n#endif\n\n\n/* For read statistics */\nenum {\n\tMCS_CACHE,\n\tMCS_RSS,\n\tMCS_FILE_MAPPED,\n\tMCS_PGPGIN,\n\tMCS_PGPGOUT,\n\tMCS_SWAP,\n\tMCS_PGFAULT,\n\tMCS_PGMAJFAULT,\n\tMCS_INACTIVE_ANON,\n\tMCS_ACTIVE_ANON,\n\tMCS_INACTIVE_FILE,\n\tMCS_ACTIVE_FILE,\n\tMCS_UNEVICTABLE,\n\tNR_MCS_STAT,\n};\n\nstruct mcs_total_stat {\n\ts64 stat[NR_MCS_STAT];\n};\n\nstruct {\n\tchar *local_name;\n\tchar *total_name;\n} memcg_stat_strings[NR_MCS_STAT] = {\n\t{\"cache\", \"total_cache\"},\n\t{\"rss\", \"total_rss\"},\n\t{\"mapped_file\", \"total_mapped_file\"},\n\t{\"pgpgin\", \"total_pgpgin\"},\n\t{\"pgpgout\", \"total_pgpgout\"},\n\t{\"swap\", \"total_swap\"},\n\t{\"pgfault\", \"total_pgfault\"},\n\t{\"pgmajfault\", \"total_pgmajfault\"},\n\t{\"inactive_anon\", \"total_inactive_anon\"},\n\t{\"active_anon\", \"total_active_anon\"},\n\t{\"inactive_file\", \"total_inactive_file\"},\n\t{\"active_file\", \"total_active_file\"},\n\t{\"unevictable\", \"total_unevictable\"}\n};\n\n\nstatic void\nmem_cgroup_get_local_stat(struct mem_cgroup *memcg, struct mcs_total_stat *s)\n{\n\ts64 val;\n\n\t/* per cpu stat */\n\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_CACHE);\n\ts->stat[MCS_CACHE] += val * PAGE_SIZE;\n\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_RSS);\n\ts->stat[MCS_RSS] += val * PAGE_SIZE;\n\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_FILE_MAPPED);\n\ts->stat[MCS_FILE_MAPPED] += val * PAGE_SIZE;\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGPGIN);\n\ts->stat[MCS_PGPGIN] += val;\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGPGOUT);\n\ts->stat[MCS_PGPGOUT] += val;\n\tif (do_swap_account) {\n\t\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_SWAPOUT);\n\t\ts->stat[MCS_SWAP] += val * PAGE_SIZE;\n\t}\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGFAULT);\n\ts->stat[MCS_PGFAULT] += val;\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGMAJFAULT);\n\ts->stat[MCS_PGMAJFAULT] += val;\n\n\t/* per zone stat */\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_INACTIVE_ANON));\n\ts->stat[MCS_INACTIVE_ANON] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_ACTIVE_ANON));\n\ts->stat[MCS_ACTIVE_ANON] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_INACTIVE_FILE));\n\ts->stat[MCS_INACTIVE_FILE] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_ACTIVE_FILE));\n\ts->stat[MCS_ACTIVE_FILE] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_UNEVICTABLE));\n\ts->stat[MCS_UNEVICTABLE] += val * PAGE_SIZE;\n}\n\nstatic void\nmem_cgroup_get_total_stat(struct mem_cgroup *memcg, struct mcs_total_stat *s)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_get_local_stat(iter, s);\n}\n\n#ifdef CONFIG_NUMA\nstatic int mem_control_numa_stat_show(struct seq_file *m, void *arg)\n{\n\tint nid;\n\tunsigned long total_nr, file_nr, anon_nr, unevictable_nr;\n\tunsigned long node_nr;\n\tstruct cgroup *cont = m->private;\n\tstruct mem_cgroup *mem_cont = mem_cgroup_from_cont(cont);\n\n\ttotal_nr = mem_cgroup_nr_lru_pages(mem_cont, LRU_ALL);\n\tseq_printf(m, \"total=%lu\", total_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid, LRU_ALL);\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\n\tfile_nr = mem_cgroup_nr_lru_pages(mem_cont, LRU_ALL_FILE);\n\tseq_printf(m, \"file=%lu\", file_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid,\n\t\t\t\tLRU_ALL_FILE);\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\n\tanon_nr = mem_cgroup_nr_lru_pages(mem_cont, LRU_ALL_ANON);\n\tseq_printf(m, \"anon=%lu\", anon_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid,\n\t\t\t\tLRU_ALL_ANON);\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\n\tunevictable_nr = mem_cgroup_nr_lru_pages(mem_cont, BIT(LRU_UNEVICTABLE));\n\tseq_printf(m, \"unevictable=%lu\", unevictable_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid,\n\t\t\t\tBIT(LRU_UNEVICTABLE));\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n#endif /* CONFIG_NUMA */\n\nstatic int mem_control_stat_show(struct cgroup *cont, struct cftype *cft,\n\t\t\t\t struct cgroup_map_cb *cb)\n{\n\tstruct mem_cgroup *mem_cont = mem_cgroup_from_cont(cont);\n\tstruct mcs_total_stat mystat;\n\tint i;\n\n\tmemset(&mystat, 0, sizeof(mystat));\n\tmem_cgroup_get_local_stat(mem_cont, &mystat);\n\n\n\tfor (i = 0; i < NR_MCS_STAT; i++) {\n\t\tif (i == MCS_SWAP && !do_swap_account)\n\t\t\tcontinue;\n\t\tcb->fill(cb, memcg_stat_strings[i].local_name, mystat.stat[i]);\n\t}\n\n\t/* Hierarchical information */\n\t{\n\t\tunsigned long long limit, memsw_limit;\n\t\tmemcg_get_hierarchical_limit(mem_cont, &limit, &memsw_limit);\n\t\tcb->fill(cb, \"hierarchical_memory_limit\", limit);\n\t\tif (do_swap_account)\n\t\t\tcb->fill(cb, \"hierarchical_memsw_limit\", memsw_limit);\n\t}\n\n\tmemset(&mystat, 0, sizeof(mystat));\n\tmem_cgroup_get_total_stat(mem_cont, &mystat);\n\tfor (i = 0; i < NR_MCS_STAT; i++) {\n\t\tif (i == MCS_SWAP && !do_swap_account)\n\t\t\tcontinue;\n\t\tcb->fill(cb, memcg_stat_strings[i].total_name, mystat.stat[i]);\n\t}\n\n#ifdef CONFIG_DEBUG_VM\n\t{\n\t\tint nid, zid;\n\t\tstruct mem_cgroup_per_zone *mz;\n\t\tunsigned long recent_rotated[2] = {0, 0};\n\t\tunsigned long recent_scanned[2] = {0, 0};\n\n\t\tfor_each_online_node(nid)\n\t\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\t\tmz = mem_cgroup_zoneinfo(mem_cont, nid, zid);\n\n\t\t\t\trecent_rotated[0] +=\n\t\t\t\t\tmz->reclaim_stat.recent_rotated[0];\n\t\t\t\trecent_rotated[1] +=\n\t\t\t\t\tmz->reclaim_stat.recent_rotated[1];\n\t\t\t\trecent_scanned[0] +=\n\t\t\t\t\tmz->reclaim_stat.recent_scanned[0];\n\t\t\t\trecent_scanned[1] +=\n\t\t\t\t\tmz->reclaim_stat.recent_scanned[1];\n\t\t\t}\n\t\tcb->fill(cb, \"recent_rotated_anon\", recent_rotated[0]);\n\t\tcb->fill(cb, \"recent_rotated_file\", recent_rotated[1]);\n\t\tcb->fill(cb, \"recent_scanned_anon\", recent_scanned[0]);\n\t\tcb->fill(cb, \"recent_scanned_file\", recent_scanned[1]);\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic u64 mem_cgroup_swappiness_read(struct cgroup *cgrp, struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\n\treturn mem_cgroup_swappiness(memcg);\n}\n\nstatic int mem_cgroup_swappiness_write(struct cgroup *cgrp, struct cftype *cft,\n\t\t\t\t       u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup *parent;\n\n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\tif (cgrp->parent == NULL)\n\t\treturn -EINVAL;\n\n\tparent = mem_cgroup_from_cont(cgrp->parent);\n\n\tcgroup_lock();\n\n\t/* If under hierarchy, only empty-root can set this value */\n\tif ((parent->use_hierarchy) ||\n\t    (memcg->use_hierarchy && !list_empty(&cgrp->children))) {\n\t\tcgroup_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tmemcg->swappiness = val;\n\n\tcgroup_unlock();\n\n\treturn 0;\n}\n\nstatic void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tu64 usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg)\n{\n\twhile (memcg) {\n\t\t__mem_cgroup_threshold(memcg, false);\n\t\tif (do_swap_account)\n\t\t\t__mem_cgroup_threshold(memcg, true);\n\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t}\n}\n\nstatic int compare_thresholds(const void *a, const void *b)\n{\n\tconst struct mem_cgroup_threshold *_a = a;\n\tconst struct mem_cgroup_threshold *_b = b;\n\n\treturn _a->threshold - _b->threshold;\n}\n\nstatic int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_eventfd_list *ev;\n\n\tlist_for_each_entry(ev, &memcg->oom_notify, list)\n\t\teventfd_signal(ev->eventfd, 1);\n\treturn 0;\n}\n\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_oom_notify_cb(iter);\n}\n\nstatic int mem_cgroup_usage_register_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 threshold, usage;\n\tint i, size, ret;\n\n\tret = res_counter_memparse_write_strategy(args, &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold < usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}\n\nstatic void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\n\t/*\n\t * Something went wrong if we trying to unregister a threshold\n\t * if we don't have thresholds\n\t */\n\tBUG_ON(!thresholds);\n\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\n\tmutex_unlock(&memcg->thresholds_lock);\n}\n\nstatic int mem_cgroup_oom_register_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_eventfd_list *event;\n\tint type = MEMFILE_TYPE(cft->private);\n\n\tBUG_ON(type != _OOM_TYPE);\n\tevent = kmalloc(sizeof(*event),\tGFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tevent->eventfd = eventfd;\n\tlist_add(&event->list, &memcg->oom_notify);\n\n\t/* already in OOM ? */\n\tif (atomic_read(&memcg->under_oom))\n\t\teventfd_signal(eventfd, 1);\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn 0;\n}\n\nstatic void mem_cgroup_oom_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_eventfd_list *ev, *tmp;\n\tint type = MEMFILE_TYPE(cft->private);\n\n\tBUG_ON(type != _OOM_TYPE);\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry_safe(ev, tmp, &memcg->oom_notify, list) {\n\t\tif (ev->eventfd == eventfd) {\n\t\t\tlist_del(&ev->list);\n\t\t\tkfree(ev);\n\t\t}\n\t}\n\n\tspin_unlock(&memcg_oom_lock);\n}\n\nstatic int mem_cgroup_oom_control_read(struct cgroup *cgrp,\n\tstruct cftype *cft,  struct cgroup_map_cb *cb)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\n\tcb->fill(cb, \"oom_kill_disable\", memcg->oom_kill_disable);\n\n\tif (atomic_read(&memcg->under_oom))\n\t\tcb->fill(cb, \"under_oom\", 1);\n\telse\n\t\tcb->fill(cb, \"under_oom\", 0);\n\treturn 0;\n}\n\nstatic int mem_cgroup_oom_control_write(struct cgroup *cgrp,\n\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup *parent;\n\n\t/* cannot set to root cgroup and only 0 and 1 are allowed */\n\tif (!cgrp->parent || !((val == 0) || (val == 1)))\n\t\treturn -EINVAL;\n\n\tparent = mem_cgroup_from_cont(cgrp->parent);\n\n\tcgroup_lock();\n\t/* oom-kill-disable is a flag for subhierarchy. */\n\tif ((parent->use_hierarchy) ||\n\t    (memcg->use_hierarchy && !list_empty(&cgrp->children))) {\n\t\tcgroup_unlock();\n\t\treturn -EINVAL;\n\t}\n\tmemcg->oom_kill_disable = val;\n\tif (!val)\n\t\tmemcg_oom_recover(memcg);\n\tcgroup_unlock();\n\treturn 0;\n}\n\n#ifdef CONFIG_NUMA\nstatic const struct file_operations mem_control_numa_stat_file_operations = {\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int mem_control_numa_stat_open(struct inode *unused, struct file *file)\n{\n\tstruct cgroup *cont = file->f_dentry->d_parent->d_fsdata;\n\n\tfile->f_op = &mem_control_numa_stat_file_operations;\n\treturn single_open(file, mem_control_numa_stat_show, cont);\n}\n#endif /* CONFIG_NUMA */\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM\nstatic int register_kmem_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\t/*\n\t * Part of this would be better living in a separate allocation\n\t * function, leaving us with just the cgroup tree population work.\n\t * We, however, depend on state such as network's proto_list that\n\t * is only initialized after cgroup creation. I found the less\n\t * cumbersome way to deal with it to defer it all to populate time\n\t */\n\treturn mem_cgroup_sockets_init(cont, ss);\n};\n\nstatic void kmem_cgroup_destroy(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n\tmem_cgroup_sockets_destroy(cont, ss);\n}\n#else\nstatic int register_kmem_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\treturn 0;\n}\n\nstatic void kmem_cgroup_destroy(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n}\n#endif\n\nstatic struct cftype mem_cgroup_files[] = {\n\t{\n\t\t.name = \"usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_USAGE),\n\t\t.read_u64 = mem_cgroup_read,\n\t\t.register_event = mem_cgroup_usage_register_event,\n\t\t.unregister_event = mem_cgroup_usage_unregister_event,\n\t},\n\t{\n\t\t.name = \"max_usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_MAX_USAGE),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"limit_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_LIMIT),\n\t\t.write_string = mem_cgroup_write,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"soft_limit_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_SOFT_LIMIT),\n\t\t.write_string = mem_cgroup_write,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"failcnt\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_FAILCNT),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"stat\",\n\t\t.read_map = mem_control_stat_show,\n\t},\n\t{\n\t\t.name = \"force_empty\",\n\t\t.trigger = mem_cgroup_force_empty_write,\n\t},\n\t{\n\t\t.name = \"use_hierarchy\",\n\t\t.write_u64 = mem_cgroup_hierarchy_write,\n\t\t.read_u64 = mem_cgroup_hierarchy_read,\n\t},\n\t{\n\t\t.name = \"swappiness\",\n\t\t.read_u64 = mem_cgroup_swappiness_read,\n\t\t.write_u64 = mem_cgroup_swappiness_write,\n\t},\n\t{\n\t\t.name = \"move_charge_at_immigrate\",\n\t\t.read_u64 = mem_cgroup_move_charge_read,\n\t\t.write_u64 = mem_cgroup_move_charge_write,\n\t},\n\t{\n\t\t.name = \"oom_control\",\n\t\t.read_map = mem_cgroup_oom_control_read,\n\t\t.write_u64 = mem_cgroup_oom_control_write,\n\t\t.register_event = mem_cgroup_oom_register_event,\n\t\t.unregister_event = mem_cgroup_oom_unregister_event,\n\t\t.private = MEMFILE_PRIVATE(_OOM_TYPE, OOM_CONTROL),\n\t},\n#ifdef CONFIG_NUMA\n\t{\n\t\t.name = \"numa_stat\",\n\t\t.open = mem_control_numa_stat_open,\n\t\t.mode = S_IRUGO,\n\t},\n#endif\n};\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\nstatic struct cftype memsw_cgroup_files[] = {\n\t{\n\t\t.name = \"memsw.usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_USAGE),\n\t\t.read_u64 = mem_cgroup_read,\n\t\t.register_event = mem_cgroup_usage_register_event,\n\t\t.unregister_event = mem_cgroup_usage_unregister_event,\n\t},\n\t{\n\t\t.name = \"memsw.max_usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_MAX_USAGE),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"memsw.limit_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_LIMIT),\n\t\t.write_string = mem_cgroup_write,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"memsw.failcnt\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_FAILCNT),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n};\n\nstatic int register_memsw_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\tif (!do_swap_account)\n\t\treturn 0;\n\treturn cgroup_add_files(cont, ss, memsw_cgroup_files,\n\t\t\t\tARRAY_SIZE(memsw_cgroup_files));\n};\n#else\nstatic int register_memsw_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\treturn 0;\n}\n#endif\n\nstatic int alloc_mem_cgroup_per_zone_info(struct mem_cgroup *memcg, int node)\n{\n\tstruct mem_cgroup_per_node *pn;\n\tstruct mem_cgroup_per_zone *mz;\n\tenum lru_list l;\n\tint zone, tmp = node;\n\t/*\n\t * This routine is called against possible nodes.\n\t * But it's BUG to call kmalloc() against offline node.\n\t *\n\t * TODO: this routine can waste much memory for nodes which will\n\t *       never be onlined. It's better to use memory hotplug callback\n\t *       function.\n\t */\n\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\ttmp = -1;\n\tpn = kzalloc_node(sizeof(*pn), GFP_KERNEL, tmp);\n\tif (!pn)\n\t\treturn 1;\n\n\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\tmz = &pn->zoneinfo[zone];\n\t\tfor_each_lru(l)\n\t\t\tINIT_LIST_HEAD(&mz->lruvec.lists[l]);\n\t\tmz->usage_in_excess = 0;\n\t\tmz->on_tree = false;\n\t\tmz->mem = memcg;\n\t}\n\tmemcg->info.nodeinfo[node] = pn;\n\treturn 0;\n}\n\nstatic void free_mem_cgroup_per_zone_info(struct mem_cgroup *memcg, int node)\n{\n\tkfree(memcg->info.nodeinfo[node]);\n}\n\nstatic struct mem_cgroup *mem_cgroup_alloc(void)\n{\n\tstruct mem_cgroup *mem;\n\tint size = sizeof(struct mem_cgroup);\n\n\t/* Can be very big if MAX_NUMNODES is very big */\n\tif (size < PAGE_SIZE)\n\t\tmem = kzalloc(size, GFP_KERNEL);\n\telse\n\t\tmem = vzalloc(size);\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tmem->stat = alloc_percpu(struct mem_cgroup_stat_cpu);\n\tif (!mem->stat)\n\t\tgoto out_free;\n\tspin_lock_init(&mem->pcp_counter_lock);\n\treturn mem;\n\nout_free:\n\tif (size < PAGE_SIZE)\n\t\tkfree(mem);\n\telse\n\t\tvfree(mem);\n\treturn NULL;\n}\n\n/*\n * At destroying mem_cgroup, references from swap_cgroup can remain.\n * (scanning all at force_empty is too costly...)\n *\n * Instead of clearing all references at force_empty, we remember\n * the number of reference from swap_cgroup and free mem_cgroup when\n * it goes down to 0.\n *\n * Removal of cgroup itself succeeds regardless of refs from swap.\n */\n\nstatic void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_remove_from_trees(memcg);\n\tfree_css_id(&mem_cgroup_subsys, &memcg->css);\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_zone_info(memcg, node);\n\n\tfree_percpu(memcg->stat);\n\tif (sizeof(struct mem_cgroup) < PAGE_SIZE)\n\t\tkfree(memcg);\n\telse\n\t\tvfree(memcg);\n}\n\nstatic void mem_cgroup_get(struct mem_cgroup *memcg)\n{\n\tatomic_inc(&memcg->refcnt);\n}\n\nstatic void __mem_cgroup_put(struct mem_cgroup *memcg, int count)\n{\n\tif (atomic_sub_and_test(count, &memcg->refcnt)) {\n\t\tstruct mem_cgroup *parent = parent_mem_cgroup(memcg);\n\t\t__mem_cgroup_free(memcg);\n\t\tif (parent)\n\t\t\tmem_cgroup_put(parent);\n\t}\n}\n\nstatic void mem_cgroup_put(struct mem_cgroup *memcg)\n{\n\t__mem_cgroup_put(memcg, 1);\n}\n\n/*\n * Returns the parent mem_cgroup in memcgroup hierarchy with hierarchy enabled.\n */\nstruct mem_cgroup *parent_mem_cgroup(struct mem_cgroup *memcg)\n{\n\tif (!memcg->res.parent)\n\t\treturn NULL;\n\treturn mem_cgroup_from_res_counter(memcg->res.parent, res);\n}\nEXPORT_SYMBOL(parent_mem_cgroup);\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\nstatic void __init enable_swap_cgroup(void)\n{\n\tif (!mem_cgroup_disabled() && really_do_swap_account)\n\t\tdo_swap_account = 1;\n}\n#else\nstatic void __init enable_swap_cgroup(void)\n{\n}\n#endif\n\nstatic int mem_cgroup_soft_limit_tree_init(void)\n{\n\tstruct mem_cgroup_tree_per_node *rtpn;\n\tstruct mem_cgroup_tree_per_zone *rtpz;\n\tint tmp, node, zone;\n\n\tfor_each_node(node) {\n\t\ttmp = node;\n\t\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\t\ttmp = -1;\n\t\trtpn = kzalloc_node(sizeof(*rtpn), GFP_KERNEL, tmp);\n\t\tif (!rtpn)\n\t\t\tgoto err_cleanup;\n\n\t\tsoft_limit_tree.rb_tree_per_node[node] = rtpn;\n\n\t\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\t\trtpz = &rtpn->rb_tree_per_zone[zone];\n\t\t\trtpz->rb_root = RB_ROOT;\n\t\t\tspin_lock_init(&rtpz->lock);\n\t\t}\n\t}\n\treturn 0;\n\nerr_cleanup:\n\tfor_each_node(node) {\n\t\tif (!soft_limit_tree.rb_tree_per_node[node])\n\t\t\tbreak;\n\t\tkfree(soft_limit_tree.rb_tree_per_node[node]);\n\t\tsoft_limit_tree.rb_tree_per_node[node] = NULL;\n\t}\n\treturn 1;\n\n}\n\nstatic struct cgroup_subsys_state * __ref\nmem_cgroup_create(struct cgroup_subsys *ss, struct cgroup *cont)\n{\n\tstruct mem_cgroup *memcg, *parent;\n\tlong error = -ENOMEM;\n\tint node;\n\n\tmemcg = mem_cgroup_alloc();\n\tif (!memcg)\n\t\treturn ERR_PTR(error);\n\n\tfor_each_node(node)\n\t\tif (alloc_mem_cgroup_per_zone_info(memcg, node))\n\t\t\tgoto free_out;\n\n\t/* root ? */\n\tif (cont->parent == NULL) {\n\t\tint cpu;\n\t\tenable_swap_cgroup();\n\t\tparent = NULL;\n\t\tif (mem_cgroup_soft_limit_tree_init())\n\t\t\tgoto free_out;\n\t\troot_mem_cgroup = memcg;\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct memcg_stock_pcp *stock =\n\t\t\t\t\t\t&per_cpu(memcg_stock, cpu);\n\t\t\tINIT_WORK(&stock->work, drain_local_stock);\n\t\t}\n\t\thotcpu_notifier(memcg_cpu_hotplug_callback, 0);\n\t} else {\n\t\tparent = mem_cgroup_from_cont(cont->parent);\n\t\tmemcg->use_hierarchy = parent->use_hierarchy;\n\t\tmemcg->oom_kill_disable = parent->oom_kill_disable;\n\t}\n\n\tif (parent && parent->use_hierarchy) {\n\t\tres_counter_init(&memcg->res, &parent->res);\n\t\tres_counter_init(&memcg->memsw, &parent->memsw);\n\t\t/*\n\t\t * We increment refcnt of the parent to ensure that we can\n\t\t * safely access it on res_counter_charge/uncharge.\n\t\t * This refcnt will be decremented when freeing this\n\t\t * mem_cgroup(see mem_cgroup_put).\n\t\t */\n\t\tmem_cgroup_get(parent);\n\t} else {\n\t\tres_counter_init(&memcg->res, NULL);\n\t\tres_counter_init(&memcg->memsw, NULL);\n\t}\n\tmemcg->last_scanned_node = MAX_NUMNODES;\n\tINIT_LIST_HEAD(&memcg->oom_notify);\n\n\tif (parent)\n\t\tmemcg->swappiness = mem_cgroup_swappiness(parent);\n\tatomic_set(&memcg->refcnt, 1);\n\tmemcg->move_charge_at_immigrate = 0;\n\tmutex_init(&memcg->thresholds_lock);\n\treturn &memcg->css;\nfree_out:\n\t__mem_cgroup_free(memcg);\n\treturn ERR_PTR(error);\n}\n\nstatic int mem_cgroup_pre_destroy(struct cgroup_subsys *ss,\n\t\t\t\t\tstruct cgroup *cont)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\n\treturn mem_cgroup_force_empty(memcg, false);\n}\n\nstatic void mem_cgroup_destroy(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\n\tkmem_cgroup_destroy(ss, cont);\n\n\tmem_cgroup_put(memcg);\n}\n\nstatic int mem_cgroup_populate(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n\tint ret;\n\n\tret = cgroup_add_files(cont, ss, mem_cgroup_files,\n\t\t\t\tARRAY_SIZE(mem_cgroup_files));\n\n\tif (!ret)\n\t\tret = register_memsw_files(cont, ss);\n\n\tif (!ret)\n\t\tret = register_kmem_files(cont, ss);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_MMU\n/* Handlers for move charge at task migration. */\n#define PRECHARGE_COUNT_AT_ONCE\t256\nstatic int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret = 0;\n\tint batch_count = PRECHARGE_COUNT_AT_ONCE;\n\tstruct mem_cgroup *memcg = mc.to;\n\n\tif (mem_cgroup_is_root(memcg)) {\n\t\tmc.precharge += count;\n\t\t/* we don't need css_get for root */\n\t\treturn ret;\n\t}\n\t/* try to charge at once */\n\tif (count > 1) {\n\t\tstruct res_counter *dummy;\n\t\t/*\n\t\t * \"memcg\" cannot be under rmdir() because we've already checked\n\t\t * by cgroup_lock_live_cgroup() that it is not removed and we\n\t\t * are still under the same cgroup_mutex. So we can postpone\n\t\t * css_get().\n\t\t */\n\t\tif (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))\n\t\t\tgoto one_by_one;\n\t\tif (do_swap_account && res_counter_charge(&memcg->memsw,\n\t\t\t\t\t\tPAGE_SIZE * count, &dummy)) {\n\t\t\tres_counter_uncharge(&memcg->res, PAGE_SIZE * count);\n\t\t\tgoto one_by_one;\n\t\t}\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\none_by_one:\n\t/* fall back to one by one charge */\n\twhile (count--) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (!batch_count--) {\n\t\t\tbatch_count = PRECHARGE_COUNT_AT_ONCE;\n\t\t\tcond_resched();\n\t\t}\n\t\tret = __mem_cgroup_try_charge(NULL,\n\t\t\t\t\tGFP_KERNEL, 1, &memcg, false);\n\t\tif (ret)\n\t\t\t/* mem_cgroup_clear_mc() will do uncharge later */\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t}\n\treturn ret;\n}\n\n/**\n * is_target_pte_for_mc - check a pte whether it is valid for move charge\n * @vma: the vma the pte to be checked belongs\n * @addr: the address corresponding to the pte to be checked\n * @ptent: the pte to be checked\n * @target: the pointer the target page or swap ent will be stored(can be NULL)\n *\n * Returns\n *   0(MC_TARGET_NONE): if the pte is not a target for move charge.\n *   1(MC_TARGET_PAGE): if the page corresponding to this pte is a target for\n *     move charge. if @target is not NULL, the page is stored in target->page\n *     with extra refcnt got(Callers should handle it).\n *   2(MC_TARGET_SWAP): if the swap entry corresponding to this pte is a\n *     target for charge migration. if @target is not NULL, the entry is stored\n *     in target->ent.\n *\n * Called with pte lock held.\n */\nunion mc_target {\n\tstruct page\t*page;\n\tswp_entry_t\tent;\n};\n\nenum mc_target_type {\n\tMC_TARGET_NONE,\t/* not used */\n\tMC_TARGET_PAGE,\n\tMC_TARGET_SWAP,\n};\n\nstatic struct page *mc_handle_present_pte(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr, pte_t ptent)\n{\n\tstruct page *page = vm_normal_page(vma, addr, ptent);\n\n\tif (!page || !page_mapped(page))\n\t\treturn NULL;\n\tif (PageAnon(page)) {\n\t\t/* we don't move shared anon */\n\t\tif (!move_anon() || page_mapcount(page) > 2)\n\t\t\treturn NULL;\n\t} else if (!move_file())\n\t\t/* we ignore mapcount for file pages */\n\t\treturn NULL;\n\tif (!get_page_unless_zero(page))\n\t\treturn NULL;\n\n\treturn page;\n}\n\nstatic struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tint usage_count;\n\tstruct page *page = NULL;\n\tswp_entry_t ent = pte_to_swp_entry(ptent);\n\n\tif (!move_anon() || non_swap_entry(ent))\n\t\treturn NULL;\n\tusage_count = mem_cgroup_count_swap_user(ent, &page);\n\tif (usage_count > 1) { /* we don't move shared anon */\n\t\tif (page)\n\t\t\tput_page(page);\n\t\treturn NULL;\n\t}\n\tif (do_swap_account)\n\t\tentry->val = ent.val;\n\n\treturn page;\n}\n\nstatic struct page *mc_handle_file_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\tif (!vma->vm_file) /* anonymous vma */\n\t\treturn NULL;\n\tif (!move_file())\n\t\treturn NULL;\n\n\tinode = vma->vm_file->f_path.dentry->d_inode;\n\tmapping = vma->vm_file->f_mapping;\n\tif (pte_none(ptent))\n\t\tpgoff = linear_page_index(vma, addr);\n\telse /* pte_file(ptent) is true */\n\t\tpgoff = pte_to_pgoff(ptent);\n\n\t/* page is moved even if it's not RSS of this task(page-faulted). */\n\tpage = find_get_page(mapping, pgoff);\n\n#ifdef CONFIG_SWAP\n\t/* shmem/tmpfs may report page out on swap: account for that too. */\n\tif (radix_tree_exceptional_entry(page)) {\n\t\tswp_entry_t swap = radix_to_swp_entry(page);\n\t\tif (do_swap_account)\n\t\t\t*entry = swap;\n\t\tpage = find_get_page(&swapper_space, swap.val);\n\t}\n#endif\n\treturn page;\n}\n\nstatic int is_target_pte_for_mc(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t ptent, union mc_target *target)\n{\n\tstruct page *page = NULL;\n\tstruct page_cgroup *pc;\n\tint ret = 0;\n\tswp_entry_t ent = { .val = 0 };\n\n\tif (pte_present(ptent))\n\t\tpage = mc_handle_present_pte(vma, addr, ptent);\n\telse if (is_swap_pte(ptent))\n\t\tpage = mc_handle_swap_pte(vma, addr, ptent, &ent);\n\telse if (pte_none(ptent) || pte_file(ptent))\n\t\tpage = mc_handle_file_pte(vma, addr, ptent, &ent);\n\n\tif (!page && !ent.val)\n\t\treturn 0;\n\tif (page) {\n\t\tpc = lookup_page_cgroup(page);\n\t\t/*\n\t\t * Do only loose check w/o page_cgroup lock.\n\t\t * mem_cgroup_move_account() checks the pc is valid or not under\n\t\t * the lock.\n\t\t */\n\t\tif (PageCgroupUsed(pc) && pc->mem_cgroup == mc.from) {\n\t\t\tret = MC_TARGET_PAGE;\n\t\t\tif (target)\n\t\t\t\ttarget->page = page;\n\t\t}\n\t\tif (!ret || !target)\n\t\t\tput_page(page);\n\t}\n\t/* There is a swap entry and a page doesn't exist or isn't charged */\n\tif (ent.val && !ret &&\n\t\t\tcss_id(&mc.from->css) == lookup_swap_cgroup_id(ent)) {\n\t\tret = MC_TARGET_SWAP;\n\t\tif (target)\n\t\t\ttarget->ent = ent;\n\t}\n\treturn ret;\n}\n\nstatic int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (is_target_pte_for_mc(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}\n\nstatic unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)\n{\n\tunsigned long precharge;\n\tstruct vm_area_struct *vma;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tstruct mm_walk mem_cgroup_count_precharge_walk = {\n\t\t\t.pmd_entry = mem_cgroup_count_precharge_pte_range,\n\t\t\t.mm = mm,\n\t\t\t.private = vma,\n\t\t};\n\t\tif (is_vm_hugetlb_page(vma))\n\t\t\tcontinue;\n\t\twalk_page_range(vma->vm_start, vma->vm_end,\n\t\t\t\t\t&mem_cgroup_count_precharge_walk);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tprecharge = mc.precharge;\n\tmc.precharge = 0;\n\n\treturn precharge;\n}\n\nstatic int mem_cgroup_precharge_mc(struct mm_struct *mm)\n{\n\tunsigned long precharge = mem_cgroup_count_precharge(mm);\n\n\tVM_BUG_ON(mc.moving_task);\n\tmc.moving_task = current;\n\treturn mem_cgroup_do_precharge(precharge);\n}\n\n/* cancels all extra charges on mc.from and mc.to, and wakes up all waiters. */\nstatic void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\t__mem_cgroup_cancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\t__mem_cgroup_cancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tres_counter_uncharge(&mc.from->memsw,\n\t\t\t\t\t\tPAGE_SIZE * mc.moved_swap);\n\t\t__mem_cgroup_put(mc.from, mc.moved_swap);\n\n\t\tif (!mem_cgroup_is_root(mc.to)) {\n\t\t\t/*\n\t\t\t * we charged both to->res and to->memsw, so we should\n\t\t\t * uncharge to->res.\n\t\t\t */\n\t\t\tres_counter_uncharge(&mc.to->res,\n\t\t\t\t\t\tPAGE_SIZE * mc.moved_swap);\n\t\t}\n\t\t/* we've already done mem_cgroup_get(mc.to) */\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}\n\nstatic void mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tspin_unlock(&mc.lock);\n\tmem_cgroup_end_move(from);\n}\n\nstatic int mem_cgroup_can_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\tstruct task_struct *p = cgroup_taskset_first(tset);\n\tint ret = 0;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgroup);\n\n\tif (memcg->move_charge_at_immigrate) {\n\t\tstruct mm_struct *mm;\n\t\tstruct mem_cgroup *from = mem_cgroup_from_task(p);\n\n\t\tVM_BUG_ON(from == memcg);\n\n\t\tmm = get_task_mm(p);\n\t\tif (!mm)\n\t\t\treturn 0;\n\t\t/* We move charges only when we move a owner of the mm */\n\t\tif (mm->owner == p) {\n\t\t\tVM_BUG_ON(mc.from);\n\t\t\tVM_BUG_ON(mc.to);\n\t\t\tVM_BUG_ON(mc.precharge);\n\t\t\tVM_BUG_ON(mc.moved_charge);\n\t\t\tVM_BUG_ON(mc.moved_swap);\n\t\t\tmem_cgroup_start_move(from);\n\t\t\tspin_lock(&mc.lock);\n\t\t\tmc.from = from;\n\t\t\tmc.to = memcg;\n\t\t\tspin_unlock(&mc.lock);\n\t\t\t/* We set mc.moving_task later */\n\n\t\t\tret = mem_cgroup_precharge_mc(mm);\n\t\t\tif (ret)\n\t\t\t\tmem_cgroup_clear_mc();\n\t\t}\n\t\tmmput(mm);\n\t}\n\treturn ret;\n}\n\nstatic void mem_cgroup_cancel_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\tmem_cgroup_clear_mc();\n}\n\nstatic int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tunion mc_target target;\n\t\tint type;\n\t\tstruct page *page;\n\t\tstruct page_cgroup *pc;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\ttype = is_target_pte_for_mc(vma, addr, ptent, &target);\n\t\tswitch (type) {\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\tif (isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tpc = lookup_page_cgroup(page);\n\t\t\tif (!mem_cgroup_move_account(page, 1, pc,\n\t\t\t\t\t\t     mc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tputback_lru_page(page);\nput:\t\t\t/* is_target_pte_for_mc() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent,\n\t\t\t\t\t\tmc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}\n\nstatic void mem_cgroup_move_charge(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tlru_add_drain_all();\nretry:\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem))) {\n\t\t/*\n\t\t * Someone who are holding the mmap_sem might be waiting in\n\t\t * waitq. So we cancel all extra charges, wake up all waiters,\n\t\t * and retry. Because we cancel precharges, we might not be able\n\t\t * to move enough charges, but moving charge is a best-effort\n\t\t * feature anyway, so it wouldn't be a big problem.\n\t\t */\n\t\t__mem_cgroup_clear_mc();\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tint ret;\n\t\tstruct mm_walk mem_cgroup_move_charge_walk = {\n\t\t\t.pmd_entry = mem_cgroup_move_charge_pte_range,\n\t\t\t.mm = mm,\n\t\t\t.private = vma,\n\t\t};\n\t\tif (is_vm_hugetlb_page(vma))\n\t\t\tcontinue;\n\t\tret = walk_page_range(vma->vm_start, vma->vm_end,\n\t\t\t\t\t\t&mem_cgroup_move_charge_walk);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * means we have consumed all precharges and failed in\n\t\t\t * doing additional charge. Just abandon here.\n\t\t\t */\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n}\n\nstatic void mem_cgroup_move_task(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\tstruct task_struct *p = cgroup_taskset_first(tset);\n\tstruct mm_struct *mm = get_task_mm(p);\n\n\tif (mm) {\n\t\tif (mc.to)\n\t\t\tmem_cgroup_move_charge(mm);\n\t\tput_swap_token(mm);\n\t\tmmput(mm);\n\t}\n\tif (mc.to)\n\t\tmem_cgroup_clear_mc();\n}\n#else\t/* !CONFIG_MMU */\nstatic int mem_cgroup_can_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\treturn 0;\n}\nstatic void mem_cgroup_cancel_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n}\nstatic void mem_cgroup_move_task(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n}\n#endif\n\nstruct cgroup_subsys mem_cgroup_subsys = {\n\t.name = \"memory\",\n\t.subsys_id = mem_cgroup_subsys_id,\n\t.create = mem_cgroup_create,\n\t.pre_destroy = mem_cgroup_pre_destroy,\n\t.destroy = mem_cgroup_destroy,\n\t.populate = mem_cgroup_populate,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.attach = mem_cgroup_move_task,\n\t.early_init = 0,\n\t.use_id = 1,\n};\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\nstatic int __init enable_swap_account(char *s)\n{\n\t/* consider enabled if no parameter or 1 is given */\n\tif (!strcmp(s, \"1\"))\n\t\treally_do_swap_account = 1;\n\telse if (!strcmp(s, \"0\"))\n\t\treally_do_swap_account = 0;\n\treturn 1;\n}\n__setup(\"swapaccount=\", enable_swap_account);\n\n#endif\n"], "fixing_code": ["/* memcontrol.c - Memory Controller\n *\n * Copyright IBM Corporation, 2007\n * Author Balbir Singh <balbir@linux.vnet.ibm.com>\n *\n * Copyright 2007 OpenVZ SWsoft Inc\n * Author: Pavel Emelianov <xemul@openvz.org>\n *\n * Memory thresholds\n * Copyright (C) 2009 Nokia Corporation\n * Author: Kirill A. Shutemov\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include <linux/res_counter.h>\n#include <linux/memcontrol.h>\n#include <linux/cgroup.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/page-flags.h>\n#include <linux/backing-dev.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/limits.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/spinlock.h>\n#include <linux/eventfd.h>\n#include <linux/sort.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/mm_inline.h>\n#include <linux/page_cgroup.h>\n#include <linux/cpu.h>\n#include <linux/oom.h>\n#include \"internal.h\"\n#include <net/sock.h>\n#include <net/tcp_memcontrol.h>\n\n#include <asm/uaccess.h>\n\n#include <trace/events/vmscan.h>\n\nstruct cgroup_subsys mem_cgroup_subsys __read_mostly;\n#define MEM_CGROUP_RECLAIM_RETRIES\t5\nstruct mem_cgroup *root_mem_cgroup __read_mostly;\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\n/* Turned on only when memory cgroup is enabled && really_do_swap_account = 1 */\nint do_swap_account __read_mostly;\n\n/* for remember boot option*/\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP_ENABLED\nstatic int really_do_swap_account __initdata = 1;\n#else\nstatic int really_do_swap_account __initdata = 0;\n#endif\n\n#else\n#define do_swap_account\t\t(0)\n#endif\n\n\n/*\n * Statistics for memory cgroup.\n */\nenum mem_cgroup_stat_index {\n\t/*\n\t * For MEM_CONTAINER_TYPE_ALL, usage = pagecache + rss.\n\t */\n\tMEM_CGROUP_STAT_CACHE, \t   /* # of pages charged as cache */\n\tMEM_CGROUP_STAT_RSS,\t   /* # of pages charged as anon rss */\n\tMEM_CGROUP_STAT_FILE_MAPPED,  /* # of pages charged as file rss */\n\tMEM_CGROUP_STAT_SWAPOUT, /* # of pages, swapped out */\n\tMEM_CGROUP_STAT_DATA, /* end of data requires synchronization */\n\tMEM_CGROUP_ON_MOVE,\t/* someone is moving account between groups */\n\tMEM_CGROUP_STAT_NSTATS,\n};\n\nenum mem_cgroup_events_index {\n\tMEM_CGROUP_EVENTS_PGPGIN,\t/* # of pages paged in */\n\tMEM_CGROUP_EVENTS_PGPGOUT,\t/* # of pages paged out */\n\tMEM_CGROUP_EVENTS_COUNT,\t/* # of pages paged in/out */\n\tMEM_CGROUP_EVENTS_PGFAULT,\t/* # of page-faults */\n\tMEM_CGROUP_EVENTS_PGMAJFAULT,\t/* # of major page-faults */\n\tMEM_CGROUP_EVENTS_NSTATS,\n};\n/*\n * Per memcg event counter is incremented at every pagein/pageout. With THP,\n * it will be incremated by the number of pages. This counter is used for\n * for trigger some periodic events. This is straightforward and better\n * than using jiffies etc. to handle periodic memcg event.\n */\nenum mem_cgroup_events_target {\n\tMEM_CGROUP_TARGET_THRESH,\n\tMEM_CGROUP_TARGET_SOFTLIMIT,\n\tMEM_CGROUP_TARGET_NUMAINFO,\n\tMEM_CGROUP_NTARGETS,\n};\n#define THRESHOLDS_EVENTS_TARGET (128)\n#define SOFTLIMIT_EVENTS_TARGET (1024)\n#define NUMAINFO_EVENTS_TARGET\t(1024)\n\nstruct mem_cgroup_stat_cpu {\n\tlong count[MEM_CGROUP_STAT_NSTATS];\n\tunsigned long events[MEM_CGROUP_EVENTS_NSTATS];\n\tunsigned long targets[MEM_CGROUP_NTARGETS];\n};\n\nstruct mem_cgroup_reclaim_iter {\n\t/* css_id of the last scanned hierarchy member */\n\tint position;\n\t/* scan generation, increased every round-trip */\n\tunsigned int generation;\n};\n\n/*\n * per-zone information in memory controller.\n */\nstruct mem_cgroup_per_zone {\n\tstruct lruvec\t\tlruvec;\n\tunsigned long\t\tcount[NR_LRU_LISTS];\n\n\tstruct mem_cgroup_reclaim_iter reclaim_iter[DEF_PRIORITY + 1];\n\n\tstruct zone_reclaim_stat reclaim_stat;\n\tstruct rb_node\t\ttree_node;\t/* RB tree node */\n\tunsigned long long\tusage_in_excess;/* Set to the value by which */\n\t\t\t\t\t\t/* the soft limit is exceeded*/\n\tbool\t\t\ton_tree;\n\tstruct mem_cgroup\t*mem;\t\t/* Back pointer, we cannot */\n\t\t\t\t\t\t/* use container_of\t   */\n};\n/* Macro for accessing counter */\n#define MEM_CGROUP_ZSTAT(mz, idx)\t((mz)->count[(idx)])\n\nstruct mem_cgroup_per_node {\n\tstruct mem_cgroup_per_zone zoneinfo[MAX_NR_ZONES];\n};\n\nstruct mem_cgroup_lru_info {\n\tstruct mem_cgroup_per_node *nodeinfo[MAX_NUMNODES];\n};\n\n/*\n * Cgroups above their limits are maintained in a RB-Tree, independent of\n * their hierarchy representation\n */\n\nstruct mem_cgroup_tree_per_zone {\n\tstruct rb_root rb_root;\n\tspinlock_t lock;\n};\n\nstruct mem_cgroup_tree_per_node {\n\tstruct mem_cgroup_tree_per_zone rb_tree_per_zone[MAX_NR_ZONES];\n};\n\nstruct mem_cgroup_tree {\n\tstruct mem_cgroup_tree_per_node *rb_tree_per_node[MAX_NUMNODES];\n};\n\nstatic struct mem_cgroup_tree soft_limit_tree __read_mostly;\n\nstruct mem_cgroup_threshold {\n\tstruct eventfd_ctx *eventfd;\n\tu64 threshold;\n};\n\n/* For threshold */\nstruct mem_cgroup_threshold_ary {\n\t/* An array index points to threshold just below usage. */\n\tint current_threshold;\n\t/* Size of entries[] */\n\tunsigned int size;\n\t/* Array of thresholds */\n\tstruct mem_cgroup_threshold entries[0];\n};\n\nstruct mem_cgroup_thresholds {\n\t/* Primary thresholds array */\n\tstruct mem_cgroup_threshold_ary *primary;\n\t/*\n\t * Spare threshold array.\n\t * This is needed to make mem_cgroup_unregister_event() \"never fail\".\n\t * It must be able to store at least primary->size - 1 entries.\n\t */\n\tstruct mem_cgroup_threshold_ary *spare;\n};\n\n/* for OOM */\nstruct mem_cgroup_eventfd_list {\n\tstruct list_head list;\n\tstruct eventfd_ctx *eventfd;\n};\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\n\n/*\n * The memory controller data structure. The memory controller controls both\n * page cache and RSS per cgroup. We would eventually like to provide\n * statistics based on the statistics developed by Rik Van Riel for clock-pro,\n * to help the administrator determine what knobs to tune.\n *\n * TODO: Add a water mark for the memory controller. Reclaim will begin when\n * we hit the water mark. May be even add a low water mark, such that\n * no reclaim occurs from a cgroup at it's low water mark, this is\n * a feature that will be implemented much later in the future.\n */\nstruct mem_cgroup {\n\tstruct cgroup_subsys_state css;\n\t/*\n\t * the counter to account for memory usage\n\t */\n\tstruct res_counter res;\n\t/*\n\t * the counter to account for mem+swap usage.\n\t */\n\tstruct res_counter memsw;\n\t/*\n\t * Per cgroup active and inactive list, similar to the\n\t * per zone LRU lists.\n\t */\n\tstruct mem_cgroup_lru_info info;\n\tint last_scanned_node;\n#if MAX_NUMNODES > 1\n\tnodemask_t\tscan_nodes;\n\tatomic_t\tnumainfo_events;\n\tatomic_t\tnumainfo_updating;\n#endif\n\t/*\n\t * Should the accounting and control be hierarchical, per subtree?\n\t */\n\tbool use_hierarchy;\n\n\tbool\t\toom_lock;\n\tatomic_t\tunder_oom;\n\n\tatomic_t\trefcnt;\n\n\tint\tswappiness;\n\t/* OOM-Killer disable */\n\tint\t\toom_kill_disable;\n\n\t/* set when res.limit == memsw.limit */\n\tbool\t\tmemsw_is_minimum;\n\n\t/* protect arrays of thresholds */\n\tstruct mutex thresholds_lock;\n\n\t/* thresholds for memory usage. RCU-protected */\n\tstruct mem_cgroup_thresholds thresholds;\n\n\t/* thresholds for mem+swap usage. RCU-protected */\n\tstruct mem_cgroup_thresholds memsw_thresholds;\n\n\t/* For oom notifier event fd */\n\tstruct list_head oom_notify;\n\n\t/*\n\t * Should we move charges of a task when a task is moved into this\n\t * mem_cgroup ? And what type of charges should we move ?\n\t */\n\tunsigned long \tmove_charge_at_immigrate;\n\t/*\n\t * percpu counter.\n\t */\n\tstruct mem_cgroup_stat_cpu *stat;\n\t/*\n\t * used when a cpu is offlined or other synchronizations\n\t * See mem_cgroup_read_stat().\n\t */\n\tstruct mem_cgroup_stat_cpu nocpu_base;\n\tspinlock_t pcp_counter_lock;\n\n#ifdef CONFIG_INET\n\tstruct tcp_memcontrol tcp_mem;\n#endif\n};\n\n/* Stuffs for move charges at task migration. */\n/*\n * Types of charges to be moved. \"move_charge_at_immitgrate\" is treated as a\n * left-shifted bitmap of these types.\n */\nenum move_type {\n\tMOVE_CHARGE_TYPE_ANON,\t/* private anonymous page and swap of it */\n\tMOVE_CHARGE_TYPE_FILE,\t/* file page(including tmpfs) and swap of it */\n\tNR_MOVE_TYPE,\n};\n\n/* \"mc\" and its members are protected by cgroup_mutex */\nstatic struct move_charge_struct {\n\tspinlock_t\t  lock; /* for from, to */\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tunsigned long precharge;\n\tunsigned long moved_charge;\n\tunsigned long moved_swap;\n\tstruct task_struct *moving_task;\t/* a task moving charges */\n\twait_queue_head_t waitq;\t\t/* a waitq for other context */\n} mc = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mc.lock),\n\t.waitq = __WAIT_QUEUE_HEAD_INITIALIZER(mc.waitq),\n};\n\nstatic bool move_anon(void)\n{\n\treturn test_bit(MOVE_CHARGE_TYPE_ANON,\n\t\t\t\t\t&mc.to->move_charge_at_immigrate);\n}\n\nstatic bool move_file(void)\n{\n\treturn test_bit(MOVE_CHARGE_TYPE_FILE,\n\t\t\t\t\t&mc.to->move_charge_at_immigrate);\n}\n\n/*\n * Maximum loops in mem_cgroup_hierarchical_reclaim(), used for soft\n * limit reclaim to prevent infinite loops, if they ever occur.\n */\n#define\tMEM_CGROUP_MAX_RECLAIM_LOOPS\t\t(100)\n#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t(2)\n\nenum charge_type {\n\tMEM_CGROUP_CHARGE_TYPE_CACHE = 0,\n\tMEM_CGROUP_CHARGE_TYPE_MAPPED,\n\tMEM_CGROUP_CHARGE_TYPE_SHMEM,\t/* used by page migration of shmem */\n\tMEM_CGROUP_CHARGE_TYPE_FORCE,\t/* used by force_empty */\n\tMEM_CGROUP_CHARGE_TYPE_SWAPOUT,\t/* for accounting swapcache */\n\tMEM_CGROUP_CHARGE_TYPE_DROP,\t/* a page was unused swap cache */\n\tNR_CHARGE_TYPE,\n};\n\n/* for encoding cft->private value on file */\n#define _MEM\t\t\t(0)\n#define _MEMSWAP\t\t(1)\n#define _OOM_TYPE\t\t(2)\n#define MEMFILE_PRIVATE(x, val)\t(((x) << 16) | (val))\n#define MEMFILE_TYPE(val)\t(((val) >> 16) & 0xffff)\n#define MEMFILE_ATTR(val)\t((val) & 0xffff)\n/* Used for OOM nofiier */\n#define OOM_CONTROL\t\t(0)\n\n/*\n * Reclaim flags for mem_cgroup_hierarchical_reclaim\n */\n#define MEM_CGROUP_RECLAIM_NOSWAP_BIT\t0x0\n#define MEM_CGROUP_RECLAIM_NOSWAP\t(1 << MEM_CGROUP_RECLAIM_NOSWAP_BIT)\n#define MEM_CGROUP_RECLAIM_SHRINK_BIT\t0x1\n#define MEM_CGROUP_RECLAIM_SHRINK\t(1 << MEM_CGROUP_RECLAIM_SHRINK_BIT)\n\nstatic void mem_cgroup_get(struct mem_cgroup *memcg);\nstatic void mem_cgroup_put(struct mem_cgroup *memcg);\n\n/* Writing them here to avoid exposing memcg's inner layout */\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM\n#include <net/sock.h>\n#include <net/ip.h>\n\nstatic bool mem_cgroup_is_root(struct mem_cgroup *memcg);\nvoid sock_update_memcg(struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled) {\n\t\tstruct mem_cgroup *memcg;\n\n\t\tBUG_ON(!sk->sk_prot->proto_cgroup);\n\n\t\t/* Socket cloning can throw us here with sk_cgrp already\n\t\t * filled. It won't however, necessarily happen from\n\t\t * process context. So the test for root memcg given\n\t\t * the current task's memcg won't help us in this case.\n\t\t *\n\t\t * Respecting the original socket's memcg is a better\n\t\t * decision in this case.\n\t\t */\n\t\tif (sk->sk_cgrp) {\n\t\t\tBUG_ON(mem_cgroup_is_root(sk->sk_cgrp->memcg));\n\t\t\tmem_cgroup_get(sk->sk_cgrp->memcg);\n\t\t\treturn;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tmemcg = mem_cgroup_from_task(current);\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tmem_cgroup_get(memcg);\n\t\t\tsk->sk_cgrp = sk->sk_prot->proto_cgroup(memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL(sock_update_memcg);\n\nvoid sock_release_memcg(struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled && sk->sk_cgrp) {\n\t\tstruct mem_cgroup *memcg;\n\t\tWARN_ON(!sk->sk_cgrp->memcg);\n\t\tmemcg = sk->sk_cgrp->memcg;\n\t\tmem_cgroup_put(memcg);\n\t}\n}\n\n#ifdef CONFIG_INET\nstruct cg_proto *tcp_proto_cgroup(struct mem_cgroup *memcg)\n{\n\tif (!memcg || mem_cgroup_is_root(memcg))\n\t\treturn NULL;\n\n\treturn &memcg->tcp_mem.cg_proto;\n}\nEXPORT_SYMBOL(tcp_proto_cgroup);\n#endif /* CONFIG_INET */\n#endif /* CONFIG_CGROUP_MEM_RES_CTLR_KMEM */\n\nstatic void drain_all_stock_async(struct mem_cgroup *memcg);\n\nstatic struct mem_cgroup_per_zone *\nmem_cgroup_zoneinfo(struct mem_cgroup *memcg, int nid, int zid)\n{\n\treturn &memcg->info.nodeinfo[nid]->zoneinfo[zid];\n}\n\nstruct cgroup_subsys_state *mem_cgroup_css(struct mem_cgroup *memcg)\n{\n\treturn &memcg->css;\n}\n\nstatic struct mem_cgroup_per_zone *\npage_cgroup_zoneinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\n\treturn mem_cgroup_zoneinfo(memcg, nid, zid);\n}\n\nstatic struct mem_cgroup_tree_per_zone *\nsoft_limit_tree_node_zone(int nid, int zid)\n{\n\treturn &soft_limit_tree.rb_tree_per_node[nid]->rb_tree_per_zone[zid];\n}\n\nstatic struct mem_cgroup_tree_per_zone *\nsoft_limit_tree_from_page(struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\n\treturn &soft_limit_tree.rb_tree_per_node[nid]->rb_tree_per_zone[zid];\n}\n\nstatic void\n__mem_cgroup_insert_exceeded(struct mem_cgroup *memcg,\n\t\t\t\tstruct mem_cgroup_per_zone *mz,\n\t\t\t\tstruct mem_cgroup_tree_per_zone *mctz,\n\t\t\t\tunsigned long long new_usage_in_excess)\n{\n\tstruct rb_node **p = &mctz->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mem_cgroup_per_zone *mz_node;\n\n\tif (mz->on_tree)\n\t\treturn;\n\n\tmz->usage_in_excess = new_usage_in_excess;\n\tif (!mz->usage_in_excess)\n\t\treturn;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmz_node = rb_entry(parent, struct mem_cgroup_per_zone,\n\t\t\t\t\ttree_node);\n\t\tif (mz->usage_in_excess < mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_left;\n\t\t/*\n\t\t * We can't avoid mem cgroups that are over their soft\n\t\t * limit by the same amount\n\t\t */\n\t\telse if (mz->usage_in_excess >= mz_node->usage_in_excess)\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&mz->tree_node, parent, p);\n\trb_insert_color(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = true;\n}\n\nstatic void\n__mem_cgroup_remove_exceeded(struct mem_cgroup *memcg,\n\t\t\t\tstruct mem_cgroup_per_zone *mz,\n\t\t\t\tstruct mem_cgroup_tree_per_zone *mctz)\n{\n\tif (!mz->on_tree)\n\t\treturn;\n\trb_erase(&mz->tree_node, &mctz->rb_root);\n\tmz->on_tree = false;\n}\n\nstatic void\nmem_cgroup_remove_exceeded(struct mem_cgroup *memcg,\n\t\t\t\tstruct mem_cgroup_per_zone *mz,\n\t\t\t\tstruct mem_cgroup_tree_per_zone *mctz)\n{\n\tspin_lock(&mctz->lock);\n\t__mem_cgroup_remove_exceeded(memcg, mz, mctz);\n\tspin_unlock(&mctz->lock);\n}\n\n\nstatic void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long long excess;\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\tmctz = soft_limit_tree_from_page(page);\n\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\t\texcess = res_counter_soft_limit_excess(&memcg->res);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tspin_lock(&mctz->lock);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(memcg, mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(memcg, mz, mctz, excess);\n\t\t\tspin_unlock(&mctz->lock);\n\t\t}\n\t}\n}\n\nstatic void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)\n{\n\tint node, zone;\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\n\tfor_each_node(node) {\n\t\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\t\tmz = mem_cgroup_zoneinfo(memcg, node, zone);\n\t\t\tmctz = soft_limit_tree_node_zone(node, zone);\n\t\t\tmem_cgroup_remove_exceeded(memcg, mz, mctz);\n\t\t}\n\t}\n}\n\nstatic struct mem_cgroup_per_zone *\n__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)\n{\n\tstruct rb_node *rightmost = NULL;\n\tstruct mem_cgroup_per_zone *mz;\n\nretry:\n\tmz = NULL;\n\trightmost = rb_last(&mctz->rb_root);\n\tif (!rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(rightmost, struct mem_cgroup_per_zone, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz->mem, mz, mctz);\n\tif (!res_counter_soft_limit_excess(&mz->mem->res) ||\n\t\t!css_tryget(&mz->mem->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}\n\nstatic struct mem_cgroup_per_zone *\nmem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\n\tspin_lock(&mctz->lock);\n\tmz = __mem_cgroup_largest_soft_limit_node(mctz);\n\tspin_unlock(&mctz->lock);\n\treturn mz;\n}\n\n/*\n * Implementation Note: reading percpu statistics for memcg.\n *\n * Both of vmstat[] and percpu_counter has threshold and do periodic\n * synchronization to implement \"quick\" read. There are trade-off between\n * reading cost and precision of value. Then, we may have a chance to implement\n * a periodic synchronizion of counter in memcg's counter.\n *\n * But this _read() function is used for user interface now. The user accounts\n * memory usage by memory cgroup and he _always_ requires exact value because\n * he accounts memory. Even if we provide quick-and-fuzzy read, we always\n * have to visit all online cpus and make sum. So, for now, unnecessary\n * synchronization is not implemented. (just implemented for cpu hotplug)\n *\n * If there are kernel internal actions which can make use of some not-exact\n * value, and reading all cpu value can be performance bottleneck in some\n * common workload, threashold and synchonization as vmstat[] should be\n * implemented.\n */\nstatic long mem_cgroup_read_stat(struct mem_cgroup *memcg,\n\t\t\t\t enum mem_cgroup_stat_index idx)\n{\n\tlong val = 0;\n\tint cpu;\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu)\n\t\tval += per_cpu(memcg->stat->count[idx], cpu);\n#ifdef CONFIG_HOTPLUG_CPU\n\tspin_lock(&memcg->pcp_counter_lock);\n\tval += memcg->nocpu_base.count[idx];\n\tspin_unlock(&memcg->pcp_counter_lock);\n#endif\n\tput_online_cpus();\n\treturn val;\n}\n\nstatic void mem_cgroup_swap_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t bool charge)\n{\n\tint val = (charge) ? 1 : -1;\n\tthis_cpu_add(memcg->stat->count[MEM_CGROUP_STAT_SWAPOUT], val);\n}\n\nstatic unsigned long mem_cgroup_read_events(struct mem_cgroup *memcg,\n\t\t\t\t\t    enum mem_cgroup_events_index idx)\n{\n\tunsigned long val = 0;\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tval += per_cpu(memcg->stat->events[idx], cpu);\n#ifdef CONFIG_HOTPLUG_CPU\n\tspin_lock(&memcg->pcp_counter_lock);\n\tval += memcg->nocpu_base.events[idx];\n\tspin_unlock(&memcg->pcp_counter_lock);\n#endif\n\treturn val;\n}\n\nstatic void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,\n\t\t\t\t\t bool file, int nr_pages)\n{\n\tpreempt_disable();\n\n\tif (file)\n\t\t__this_cpu_add(memcg->stat->count[MEM_CGROUP_STAT_CACHE],\n\t\t\t\tnr_pages);\n\telse\n\t\t__this_cpu_add(memcg->stat->count[MEM_CGROUP_STAT_RSS],\n\t\t\t\tnr_pages);\n\n\t/* pagein of a big page is an event. So, ignore page size */\n\tif (nr_pages > 0)\n\t\t__this_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGPGIN]);\n\telse {\n\t\t__this_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGPGOUT]);\n\t\tnr_pages = -nr_pages; /* for event */\n\t}\n\n\t__this_cpu_add(memcg->stat->events[MEM_CGROUP_EVENTS_COUNT], nr_pages);\n\n\tpreempt_enable();\n}\n\nunsigned long\nmem_cgroup_zone_nr_lru_pages(struct mem_cgroup *memcg, int nid, int zid,\n\t\t\tunsigned int lru_mask)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tenum lru_list l;\n\tunsigned long ret = 0;\n\n\tmz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\n\tfor_each_lru(l) {\n\t\tif (BIT(l) & lru_mask)\n\t\t\tret += MEM_CGROUP_ZSTAT(mz, l);\n\t}\n\treturn ret;\n}\n\nstatic unsigned long\nmem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tint nid, unsigned int lru_mask)\n{\n\tu64 total = 0;\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++)\n\t\ttotal += mem_cgroup_zone_nr_lru_pages(memcg,\n\t\t\t\t\t\tnid, zid, lru_mask);\n\n\treturn total;\n}\n\nstatic unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\tunsigned int lru_mask)\n{\n\tint nid;\n\tu64 total = 0;\n\n\tfor_each_node_state(nid, N_HIGH_MEMORY)\n\t\ttotal += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n\treturn total;\n}\n\nstatic bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,\n\t\t\t\t       enum mem_cgroup_events_target target)\n{\n\tunsigned long val, next;\n\n\tval = __this_cpu_read(memcg->stat->events[MEM_CGROUP_EVENTS_COUNT]);\n\tnext = __this_cpu_read(memcg->stat->targets[target]);\n\t/* from time_after() in jiffies.h */\n\tif ((long)next - (long)val < 0) {\n\t\tswitch (target) {\n\t\tcase MEM_CGROUP_TARGET_THRESH:\n\t\t\tnext = val + THRESHOLDS_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_SOFTLIMIT:\n\t\t\tnext = val + SOFTLIMIT_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tcase MEM_CGROUP_TARGET_NUMAINFO:\n\t\t\tnext = val + NUMAINFO_EVENTS_TARGET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t__this_cpu_write(memcg->stat->targets[target], next);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * Check events in order.\n *\n */\nstatic void memcg_check_events(struct mem_cgroup *memcg, struct page *page)\n{\n\tpreempt_disable();\n\t/* threshold event is triggered in finer grain than soft limit */\n\tif (unlikely(mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_THRESH))) {\n\t\tbool do_softlimit;\n\t\tbool do_numainfo __maybe_unused;\n\n\t\tdo_softlimit = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_SOFTLIMIT);\n#if MAX_NUMNODES > 1\n\t\tdo_numainfo = mem_cgroup_event_ratelimit(memcg,\n\t\t\t\t\t\tMEM_CGROUP_TARGET_NUMAINFO);\n#endif\n\t\tpreempt_enable();\n\n\t\tmem_cgroup_threshold(memcg);\n\t\tif (unlikely(do_softlimit))\n\t\t\tmem_cgroup_update_tree(memcg, page);\n#if MAX_NUMNODES > 1\n\t\tif (unlikely(do_numainfo))\n\t\t\tatomic_inc(&memcg->numainfo_events);\n#endif\n\t} else\n\t\tpreempt_enable();\n}\n\nstruct mem_cgroup *mem_cgroup_from_cont(struct cgroup *cont)\n{\n\treturn container_of(cgroup_subsys_state(cont,\n\t\t\t\tmem_cgroup_subsys_id), struct mem_cgroup,\n\t\t\t\tcss);\n}\n\nstruct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)\n{\n\t/*\n\t * mm_update_next_owner() may clear mm->owner to NULL\n\t * if it races with swapoff, page migration, etc.\n\t * So this can be called with p == NULL.\n\t */\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\treturn container_of(task_subsys_state(p, mem_cgroup_subsys_id),\n\t\t\t\tstruct mem_cgroup, css);\n}\n\nstruct mem_cgroup *try_get_mem_cgroup_from_mm(struct mm_struct *mm)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\n\tif (!mm)\n\t\treturn NULL;\n\t/*\n\t * Because we have no locks, mm->owner's may be being moved to other\n\t * cgroup. We use css_tryget() here even if this looks\n\t * pessimistic (rather than adding locks here).\n\t */\n\trcu_read_lock();\n\tdo {\n\t\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\t\tif (unlikely(!memcg))\n\t\t\tbreak;\n\t} while (!css_tryget(&memcg->css));\n\trcu_read_unlock();\n\treturn memcg;\n}\n\n/**\n * mem_cgroup_iter - iterate over memory cgroup hierarchy\n * @root: hierarchy root\n * @prev: previously returned memcg, NULL on first invocation\n * @reclaim: cookie for shared reclaim walks, NULL for full walks\n *\n * Returns references to children of the hierarchy below @root, or\n * @root itself, or %NULL after a full round-trip.\n *\n * Caller must pass the return value in @prev on subsequent\n * invocations for reference counting, or use mem_cgroup_iter_break()\n * to cancel a hierarchy walk before the round-trip is complete.\n *\n * Reclaimers can specify a zone and a priority level in @reclaim to\n * divide up the memcgs in the hierarchy among all concurrent\n * reclaimers operating on the same zone and priority.\n */\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tint id = 0;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tid = css_id(&prev->css);\n\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\treturn NULL;\n\t\treturn root;\n\t}\n\n\twhile (!memcg) {\n\t\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\t\tstruct cgroup_subsys_state *css;\n\n\t\tif (reclaim) {\n\t\t\tint nid = zone_to_nid(reclaim->zone);\n\t\t\tint zid = zone_idx(reclaim->zone);\n\t\t\tstruct mem_cgroup_per_zone *mz;\n\n\t\t\tmz = mem_cgroup_zoneinfo(root, nid, zid);\n\t\t\titer = &mz->reclaim_iter[reclaim->priority];\n\t\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\t\treturn NULL;\n\t\t\tid = iter->position;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tcss = css_get_next(&mem_cgroup_subsys, id + 1, &root->css, &id);\n\t\tif (css) {\n\t\t\tif (css == &root->css || css_tryget(css))\n\t\t\t\tmemcg = container_of(css,\n\t\t\t\t\t\t     struct mem_cgroup, css);\n\t\t} else\n\t\t\tid = 0;\n\t\trcu_read_unlock();\n\n\t\tif (reclaim) {\n\t\t\titer->position = id;\n\t\t\tif (!css)\n\t\t\t\titer->generation++;\n\t\t\telse if (!prev && memcg)\n\t\t\t\treclaim->generation = iter->generation;\n\t\t}\n\n\t\tif (prev && !css)\n\t\t\treturn NULL;\n\t}\n\treturn memcg;\n}\n\n/**\n * mem_cgroup_iter_break - abort a hierarchy walk prematurely\n * @root: hierarchy root\n * @prev: last visited hierarchy member as returned by mem_cgroup_iter()\n */\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}\n\n/*\n * Iteration constructs for visiting all cgroups (under a tree).  If\n * loops are exited prematurely (break), mem_cgroup_iter_break() must\n * be used for reference counting.\n */\n#define for_each_mem_cgroup_tree(iter, root)\t\t\\\n\tfor (iter = mem_cgroup_iter(root, NULL, NULL);\t\\\n\t     iter != NULL;\t\t\t\t\\\n\t     iter = mem_cgroup_iter(root, iter, NULL))\n\n#define for_each_mem_cgroup(iter)\t\t\t\\\n\tfor (iter = mem_cgroup_iter(NULL, NULL, NULL);\t\\\n\t     iter != NULL;\t\t\t\t\\\n\t     iter = mem_cgroup_iter(NULL, iter, NULL))\n\nstatic inline bool mem_cgroup_is_root(struct mem_cgroup *memcg)\n{\n\treturn (memcg == root_mem_cgroup);\n}\n\nvoid mem_cgroup_count_vm_event(struct mm_struct *mm, enum vm_event_item idx)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!mm)\n\t\treturn;\n\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_task(rcu_dereference(mm->owner));\n\tif (unlikely(!memcg))\n\t\tgoto out;\n\n\tswitch (idx) {\n\tcase PGFAULT:\n\t\tthis_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGFAULT]);\n\t\tbreak;\n\tcase PGMAJFAULT:\n\t\tthis_cpu_inc(memcg->stat->events[MEM_CGROUP_EVENTS_PGMAJFAULT]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(mem_cgroup_count_vm_event);\n\n/**\n * mem_cgroup_zone_lruvec - get the lru list vector for a zone and memcg\n * @zone: zone of the wanted lruvec\n * @mem: memcg of the wanted lruvec\n *\n * Returns the lru list vector holding pages for the given @zone and\n * @mem.  This can be the global zone lruvec, if the memory controller\n * is disabled.\n */\nstruct lruvec *mem_cgroup_zone_lruvec(struct zone *zone,\n\t\t\t\t      struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\n\tmz = mem_cgroup_zoneinfo(memcg, zone_to_nid(zone), zone_idx(zone));\n\treturn &mz->lruvec;\n}\n\n/*\n * Following LRU functions are allowed to be used without PCG_LOCK.\n * Operations are called by routine of global LRU independently from memcg.\n * What we have to take care of here is validness of pc->mem_cgroup.\n *\n * Changes to pc->mem_cgroup happens when\n * 1. charge\n * 2. moving account\n * In typical case, \"charge\" is done before add-to-lru. Exception is SwapCache.\n * It is added to LRU before charge.\n * If PCG_USED bit is not set, page_cgroup is not added to this private LRU.\n * When moving account, the page is not on LRU. It's isolated.\n */\n\n/**\n * mem_cgroup_lru_add_list - account for adding an lru page and return lruvec\n * @zone: zone of the page\n * @page: the page\n * @lru: current lru\n *\n * This function accounts for @page being added to @lru, and returns\n * the lruvec for the given @zone and the memcg @page is charged to.\n *\n * The callsite is then responsible for physically linking the page to\n * the returned lruvec->lists[@lru].\n */\nstruct lruvec *mem_cgroup_lru_add_list(struct zone *zone, struct page *page,\n\t\t\t\t       enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\t/* compound_order() is stabilized through lru_lock */\n\tMEM_CGROUP_ZSTAT(mz, lru) += 1 << compound_order(page);\n\treturn &mz->lruvec;\n}\n\n/**\n * mem_cgroup_lru_del_list - account for removing an lru page\n * @page: the page\n * @lru: target lru\n *\n * This function accounts for @page being removed from @lru.\n *\n * The callsite is then responsible for physically unlinking\n * @page->lru.\n */\nvoid mem_cgroup_lru_del_list(struct page *page, enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tVM_BUG_ON(!memcg);\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\t/* huge page split is done under lru_lock. so, we have no races. */\n\tVM_BUG_ON(MEM_CGROUP_ZSTAT(mz, lru) < (1 << compound_order(page)));\n\tMEM_CGROUP_ZSTAT(mz, lru) -= 1 << compound_order(page);\n}\n\nvoid mem_cgroup_lru_del(struct page *page)\n{\n\tmem_cgroup_lru_del_list(page, page_lru(page));\n}\n\n/**\n * mem_cgroup_lru_move_lists - account for moving a page between lrus\n * @zone: zone of the page\n * @page: the page\n * @from: current lru\n * @to: target lru\n *\n * This function accounts for @page being moved between the lrus @from\n * and @to, and returns the lruvec for the given @zone and the memcg\n * @page is charged to.\n *\n * The callsite is then responsible for physically relinking\n * @page->lru to the returned lruvec->lists[@to].\n */\nstruct lruvec *mem_cgroup_lru_move_lists(struct zone *zone,\n\t\t\t\t\t struct page *page,\n\t\t\t\t\t enum lru_list from,\n\t\t\t\t\t enum lru_list to)\n{\n\t/* XXX: Optimize this, especially for @from == @to */\n\tmem_cgroup_lru_del_list(page, from);\n\treturn mem_cgroup_lru_add_list(zone, page, to);\n}\n\n/*\n * Checks whether given mem is same or in the root_mem_cgroup's\n * hierarchy subtree\n */\nstatic bool mem_cgroup_same_or_subtree(const struct mem_cgroup *root_memcg,\n\t\tstruct mem_cgroup *memcg)\n{\n\tif (root_memcg != memcg) {\n\t\treturn (root_memcg->use_hierarchy &&\n\t\t\tcss_is_ancestor(&memcg->css, &root_memcg->css));\n\t}\n\n\treturn true;\n}\n\nint task_in_mem_cgroup(struct task_struct *task, const struct mem_cgroup *memcg)\n{\n\tint ret;\n\tstruct mem_cgroup *curr = NULL;\n\tstruct task_struct *p;\n\n\tp = find_lock_task_mm(task);\n\tif (p) {\n\t\tcurr = try_get_mem_cgroup_from_mm(p->mm);\n\t\ttask_unlock(p);\n\t} else {\n\t\t/*\n\t\t * All threads may have already detached their mm's, but the oom\n\t\t * killer still needs to detect if they have already been oom\n\t\t * killed to prevent needlessly killing additional tasks.\n\t\t */\n\t\ttask_lock(task);\n\t\tcurr = mem_cgroup_from_task(task);\n\t\tif (curr)\n\t\t\tcss_get(&curr->css);\n\t\ttask_unlock(task);\n\t}\n\tif (!curr)\n\t\treturn 0;\n\t/*\n\t * We should check use_hierarchy of \"memcg\" not \"curr\". Because checking\n\t * use_hierarchy of \"curr\" here make this function true if hierarchy is\n\t * enabled in \"curr\" and \"curr\" is a child of \"memcg\" in *cgroup*\n\t * hierarchy(even if use_hierarchy is disabled in \"memcg\").\n\t */\n\tret = mem_cgroup_same_or_subtree(memcg, curr);\n\tcss_put(&curr->css);\n\treturn ret;\n}\n\nint mem_cgroup_inactive_anon_is_low(struct mem_cgroup *memcg, struct zone *zone)\n{\n\tunsigned long inactive_ratio;\n\tint nid = zone_to_nid(zone);\n\tint zid = zone_idx(zone);\n\tunsigned long inactive;\n\tunsigned long active;\n\tunsigned long gb;\n\n\tinactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t\tBIT(LRU_INACTIVE_ANON));\n\tactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t      BIT(LRU_ACTIVE_ANON));\n\n\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\tif (gb)\n\t\tinactive_ratio = int_sqrt(10 * gb);\n\telse\n\t\tinactive_ratio = 1;\n\n\treturn inactive * inactive_ratio < active;\n}\n\nint mem_cgroup_inactive_file_is_low(struct mem_cgroup *memcg, struct zone *zone)\n{\n\tunsigned long active;\n\tunsigned long inactive;\n\tint zid = zone_idx(zone);\n\tint nid = zone_to_nid(zone);\n\n\tinactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t\tBIT(LRU_INACTIVE_FILE));\n\tactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t      BIT(LRU_ACTIVE_FILE));\n\n\treturn (active > inactive);\n}\n\nstruct zone_reclaim_stat *mem_cgroup_get_reclaim_stat(struct mem_cgroup *memcg,\n\t\t\t\t\t\t      struct zone *zone)\n{\n\tint nid = zone_to_nid(zone);\n\tint zid = zone_idx(zone);\n\tstruct mem_cgroup_per_zone *mz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\n\treturn &mz->reclaim_stat;\n}\n\nstruct zone_reclaim_stat *\nmem_cgroup_get_reclaim_stat_from_page(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\tstruct mem_cgroup_per_zone *mz;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tpc = lookup_page_cgroup(page);\n\tif (!PageCgroupUsed(pc))\n\t\treturn NULL;\n\t/* Ensure pc->mem_cgroup is visible after reading PCG_USED. */\n\tsmp_rmb();\n\tmz = page_cgroup_zoneinfo(pc->mem_cgroup, page);\n\treturn &mz->reclaim_stat;\n}\n\n#define mem_cgroup_from_res_counter(counter, member)\t\\\n\tcontainer_of(counter, struct mem_cgroup, member)\n\n/**\n * mem_cgroup_margin - calculate chargeable space of a memory cgroup\n * @mem: the memory cgroup\n *\n * Returns the maximum amount of memory @mem can be charged with, in\n * pages.\n */\nstatic unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)\n{\n\tunsigned long long margin;\n\n\tmargin = res_counter_margin(&memcg->res);\n\tif (do_swap_account)\n\t\tmargin = min(margin, res_counter_margin(&memcg->memsw));\n\treturn margin >> PAGE_SHIFT;\n}\n\nint mem_cgroup_swappiness(struct mem_cgroup *memcg)\n{\n\tstruct cgroup *cgrp = memcg->css.cgroup;\n\n\t/* root ? */\n\tif (cgrp->parent == NULL)\n\t\treturn vm_swappiness;\n\n\treturn memcg->swappiness;\n}\n\nstatic void mem_cgroup_start_move(struct mem_cgroup *memcg)\n{\n\tint cpu;\n\n\tget_online_cpus();\n\tspin_lock(&memcg->pcp_counter_lock);\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(memcg->stat->count[MEM_CGROUP_ON_MOVE], cpu) += 1;\n\tmemcg->nocpu_base.count[MEM_CGROUP_ON_MOVE] += 1;\n\tspin_unlock(&memcg->pcp_counter_lock);\n\tput_online_cpus();\n\n\tsynchronize_rcu();\n}\n\nstatic void mem_cgroup_end_move(struct mem_cgroup *memcg)\n{\n\tint cpu;\n\n\tif (!memcg)\n\t\treturn;\n\tget_online_cpus();\n\tspin_lock(&memcg->pcp_counter_lock);\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu(memcg->stat->count[MEM_CGROUP_ON_MOVE], cpu) -= 1;\n\tmemcg->nocpu_base.count[MEM_CGROUP_ON_MOVE] -= 1;\n\tspin_unlock(&memcg->pcp_counter_lock);\n\tput_online_cpus();\n}\n/*\n * 2 routines for checking \"mem\" is under move_account() or not.\n *\n * mem_cgroup_stealed() - checking a cgroup is mc.from or not. This is used\n *\t\t\t  for avoiding race in accounting. If true,\n *\t\t\t  pc->mem_cgroup may be overwritten.\n *\n * mem_cgroup_under_move() - checking a cgroup is mc.from or mc.to or\n *\t\t\t  under hierarchy of moving cgroups. This is for\n *\t\t\t  waiting at hith-memory prressure caused by \"move\".\n */\n\nstatic bool mem_cgroup_stealed(struct mem_cgroup *memcg)\n{\n\tVM_BUG_ON(!rcu_read_lock_held());\n\treturn this_cpu_read(memcg->stat->count[MEM_CGROUP_ON_MOVE]) > 0;\n}\n\nstatic bool mem_cgroup_under_move(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *from;\n\tstruct mem_cgroup *to;\n\tbool ret = false;\n\t/*\n\t * Unlike task_move routines, we access mc.to, mc.from not under\n\t * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.\n\t */\n\tspin_lock(&mc.lock);\n\tfrom = mc.from;\n\tto = mc.to;\n\tif (!from)\n\t\tgoto unlock;\n\n\tret = mem_cgroup_same_or_subtree(memcg, from)\n\t\t|| mem_cgroup_same_or_subtree(memcg, to);\nunlock:\n\tspin_unlock(&mc.lock);\n\treturn ret;\n}\n\nstatic bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)\n{\n\tif (mc.moving_task && current != mc.moving_task) {\n\t\tif (mem_cgroup_under_move(memcg)) {\n\t\t\tDEFINE_WAIT(wait);\n\t\t\tprepare_to_wait(&mc.waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\t/* moving charge context might have finished. */\n\t\t\tif (mc.moving_task)\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&mc.waitq, &wait);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * mem_cgroup_print_oom_info: Called from OOM with tasklist_lock held in read mode.\n * @memcg: The memory cgroup that went over limit\n * @p: Task that is going to be killed\n *\n * NOTE: @memcg and @p's mem_cgroup can be different when hierarchy is\n * enabled\n */\nvoid mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)\n{\n\tstruct cgroup *task_cgrp;\n\tstruct cgroup *mem_cgrp;\n\t/*\n\t * Need a buffer in BSS, can't rely on allocations. The code relies\n\t * on the assumption that OOM is serialized for memory controller.\n\t * If this assumption is broken, revisit this code.\n\t */\n\tstatic char memcg_name[PATH_MAX];\n\tint ret;\n\n\tif (!memcg || !p)\n\t\treturn;\n\n\n\trcu_read_lock();\n\n\tmem_cgrp = memcg->css.cgroup;\n\ttask_cgrp = task_cgroup(p, mem_cgroup_subsys_id);\n\n\tret = cgroup_path(task_cgrp, memcg_name, PATH_MAX);\n\tif (ret < 0) {\n\t\t/*\n\t\t * Unfortunately, we are unable to convert to a useful name\n\t\t * But we'll still print out the usage information\n\t\t */\n\t\trcu_read_unlock();\n\t\tgoto done;\n\t}\n\trcu_read_unlock();\n\n\tprintk(KERN_INFO \"Task in %s killed\", memcg_name);\n\n\trcu_read_lock();\n\tret = cgroup_path(mem_cgrp, memcg_name, PATH_MAX);\n\tif (ret < 0) {\n\t\trcu_read_unlock();\n\t\tgoto done;\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Continues from above, so we don't need an KERN_ level\n\t */\n\tprintk(KERN_CONT \" as a result of limit of %s\\n\", memcg_name);\ndone:\n\n\tprintk(KERN_INFO \"memory: usage %llukB, limit %llukB, failcnt %llu\\n\",\n\t\tres_counter_read_u64(&memcg->res, RES_USAGE) >> 10,\n\t\tres_counter_read_u64(&memcg->res, RES_LIMIT) >> 10,\n\t\tres_counter_read_u64(&memcg->res, RES_FAILCNT));\n\tprintk(KERN_INFO \"memory+swap: usage %llukB, limit %llukB, \"\n\t\t\"failcnt %llu\\n\",\n\t\tres_counter_read_u64(&memcg->memsw, RES_USAGE) >> 10,\n\t\tres_counter_read_u64(&memcg->memsw, RES_LIMIT) >> 10,\n\t\tres_counter_read_u64(&memcg->memsw, RES_FAILCNT));\n}\n\n/*\n * This function returns the number of memcg under hierarchy tree. Returns\n * 1(self count) if no children.\n */\nstatic int mem_cgroup_count_children(struct mem_cgroup *memcg)\n{\n\tint num = 0;\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tnum++;\n\treturn num;\n}\n\n/*\n * Return the memory (and swap, if configured) limit for a memcg.\n */\nu64 mem_cgroup_get_limit(struct mem_cgroup *memcg)\n{\n\tu64 limit;\n\tu64 memsw;\n\n\tlimit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\tlimit += total_swap_pages << PAGE_SHIFT;\n\n\tmemsw = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t/*\n\t * If memsw is finite and limits the amount of swap space available\n\t * to this memcg, return that limit.\n\t */\n\treturn min(limit, memsw);\n}\n\nstatic unsigned long mem_cgroup_reclaim(struct mem_cgroup *memcg,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long flags)\n{\n\tunsigned long total = 0;\n\tbool noswap = false;\n\tint loop;\n\n\tif (flags & MEM_CGROUP_RECLAIM_NOSWAP)\n\t\tnoswap = true;\n\tif (!(flags & MEM_CGROUP_RECLAIM_SHRINK) && memcg->memsw_is_minimum)\n\t\tnoswap = true;\n\n\tfor (loop = 0; loop < MEM_CGROUP_MAX_RECLAIM_LOOPS; loop++) {\n\t\tif (loop)\n\t\t\tdrain_all_stock_async(memcg);\n\t\ttotal += try_to_free_mem_cgroup_pages(memcg, gfp_mask, noswap);\n\t\t/*\n\t\t * Allow limit shrinkers, which are triggered directly\n\t\t * by userspace, to catch signals and stop reclaim\n\t\t * after minimal progress, regardless of the margin.\n\t\t */\n\t\tif (total && (flags & MEM_CGROUP_RECLAIM_SHRINK))\n\t\t\tbreak;\n\t\tif (mem_cgroup_margin(memcg))\n\t\t\tbreak;\n\t\t/*\n\t\t * If nothing was reclaimed after two attempts, there\n\t\t * may be no reclaimable pages in this hierarchy.\n\t\t */\n\t\tif (loop && !total)\n\t\t\tbreak;\n\t}\n\treturn total;\n}\n\n/**\n * test_mem_cgroup_node_reclaimable\n * @mem: the target memcg\n * @nid: the node ID to be checked.\n * @noswap : specify true here if the user wants flle only information.\n *\n * This function returns whether the specified memcg contains any\n * reclaimable pages on a node. Returns true if there are any reclaimable\n * pages in the node.\n */\nstatic bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}\n#if MAX_NUMNODES > 1\n\n/*\n * Always updating the nodemask is not very good - even if we have an empty\n * list or the wrong list here, we can start from some node and traverse all\n * nodes based on the zonelist. So update the list loosely once per 10 secs.\n *\n */\nstatic void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)\n{\n\tint nid;\n\t/*\n\t * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET\n\t * pagein/pageout changes since the last update.\n\t */\n\tif (!atomic_read(&memcg->numainfo_events))\n\t\treturn;\n\tif (atomic_inc_return(&memcg->numainfo_updating) > 1)\n\t\treturn;\n\n\t/* make a nodemask where this memcg uses memory from */\n\tmemcg->scan_nodes = node_states[N_HIGH_MEMORY];\n\n\tfor_each_node_mask(nid, node_states[N_HIGH_MEMORY]) {\n\n\t\tif (!test_mem_cgroup_node_reclaimable(memcg, nid, false))\n\t\t\tnode_clear(nid, memcg->scan_nodes);\n\t}\n\n\tatomic_set(&memcg->numainfo_events, 0);\n\tatomic_set(&memcg->numainfo_updating, 0);\n}\n\n/*\n * Selecting a node where we start reclaim from. Because what we need is just\n * reducing usage counter, start from anywhere is O,K. Considering\n * memory reclaim from current node, there are pros. and cons.\n *\n * Freeing memory from current node means freeing memory from a node which\n * we'll use or we've used. So, it may make LRU bad. And if several threads\n * hit limits, it will see a contention on a node. But freeing from remote\n * node means more costs for memory reclaim because of memory latency.\n *\n * Now, we use round-robin. Better algorithm is welcomed.\n */\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_may_update_nodemask(memcg);\n\tnode = memcg->last_scanned_node;\n\n\tnode = next_node(node, memcg->scan_nodes);\n\tif (node == MAX_NUMNODES)\n\t\tnode = first_node(memcg->scan_nodes);\n\t/*\n\t * We call this when we hit limit, not when pages are added to LRU.\n\t * No LRU may hold pages because all pages are UNEVICTABLE or\n\t * memcg is too small and all pages are not on LRU. In that case,\n\t * we use curret node.\n\t */\n\tif (unlikely(node == MAX_NUMNODES))\n\t\tnode = numa_node_id();\n\n\tmemcg->last_scanned_node = node;\n\treturn node;\n}\n\n/*\n * Check all nodes whether it contains reclaimable pages or not.\n * For quick scan, we make use of scan_nodes. This will allow us to skip\n * unused nodes. But scan_nodes is lazily updated and may not cotain\n * enough new information. We need to do double check.\n */\nbool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)\n{\n\tint nid;\n\n\t/*\n\t * quick check...making use of scan_node.\n\t * We can skip unused nodes.\n\t */\n\tif (!nodes_empty(memcg->scan_nodes)) {\n\t\tfor (nid = first_node(memcg->scan_nodes);\n\t\t     nid < MAX_NUMNODES;\n\t\t     nid = next_node(nid, memcg->scan_nodes)) {\n\n\t\t\tif (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\t/*\n\t * Check rest of nodes.\n\t */\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tif (node_isset(nid, memcg->scan_nodes))\n\t\t\tcontinue;\n\t\tif (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n#else\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}\n\nbool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)\n{\n\treturn test_mem_cgroup_node_reclaimable(memcg, 0, noswap);\n}\n#endif\n\nstatic int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   struct zone *zone,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.zone = zone,\n\t\t.priority = 0,\n\t};\n\n\texcess = res_counter_soft_limit_excess(&root_memcg->res) >> PAGE_SHIFT;\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mem_cgroup_reclaimable(victim, false))\n\t\t\tcontinue;\n\t\ttotal += mem_cgroup_shrink_node_zone(victim, gfp_mask, false,\n\t\t\t\t\t\t     zone, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!res_counter_soft_limit_excess(&root_memcg->res))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}\n\n/*\n * Check OOM-Killer is already running under our hierarchy.\n * If someone is running, return false.\n * Has to be called with memcg_oom_lock\n */\nstatic bool mem_cgroup_oom_lock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter, *failed = NULL;\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter->oom_lock) {\n\t\t\t/*\n\t\t\t * this subtree of our hierarchy is already locked\n\t\t\t * so we cannot give a lock.\n\t\t\t */\n\t\t\tfailed = iter;\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t} else\n\t\t\titer->oom_lock = true;\n\t}\n\n\tif (!failed)\n\t\treturn true;\n\n\t/*\n\t * OK, we failed to lock the whole subtree so we have to clean up\n\t * what we set up to the failing subtree\n\t */\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tif (iter == failed) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t\titer->oom_lock = false;\n\t}\n\treturn false;\n}\n\n/*\n * Has to be called with memcg_oom_lock\n */\nstatic int mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\treturn 0;\n}\n\nstatic void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tatomic_inc(&iter->under_oom);\n}\n\nstatic void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\t/*\n\t * When a new child is created while the hierarchy is under oom,\n\t * mem_cgroup_oom_lock() may not be called. We have to use\n\t * atomic_add_unless() here.\n\t */\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tatomic_add_unless(&iter->under_oom, -1, 0);\n}\n\nstatic DEFINE_SPINLOCK(memcg_oom_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nstruct oom_wait_info {\n\tstruct mem_cgroup *mem;\n\twait_queue_t\twait;\n};\n\nstatic int memcg_oom_wake_function(wait_queue_t *wait,\n\tunsigned mode, int sync, void *arg)\n{\n\tstruct mem_cgroup *wake_memcg = (struct mem_cgroup *)arg,\n\t\t\t  *oom_wait_memcg;\n\tstruct oom_wait_info *oom_wait_info;\n\n\toom_wait_info = container_of(wait, struct oom_wait_info, wait);\n\toom_wait_memcg = oom_wait_info->mem;\n\n\t/*\n\t * Both of oom_wait_info->mem and wake_mem are stable under us.\n\t * Then we can use css_is_ancestor without taking care of RCU.\n\t */\n\tif (!mem_cgroup_same_or_subtree(oom_wait_memcg, wake_memcg)\n\t\t&& !mem_cgroup_same_or_subtree(wake_memcg, oom_wait_memcg))\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, arg);\n}\n\nstatic void memcg_wakeup_oom(struct mem_cgroup *memcg)\n{\n\t/* for filtering, pass \"memcg\" as argument. */\n\t__wake_up(&memcg_oom_waitq, TASK_NORMAL, 0, memcg);\n}\n\nstatic void memcg_oom_recover(struct mem_cgroup *memcg)\n{\n\tif (memcg && atomic_read(&memcg->under_oom))\n\t\tmemcg_wakeup_oom(memcg);\n}\n\n/*\n * try to call OOM killer. returns false if we should exit memory-reclaim loop.\n */\nbool mem_cgroup_handle_oom(struct mem_cgroup *memcg, gfp_t mask)\n{\n\tstruct oom_wait_info owait;\n\tbool locked, need_to_kill;\n\n\towait.mem = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.task_list);\n\tneed_to_kill = true;\n\tmem_cgroup_mark_under_oom(memcg);\n\n\t/* At first, try to OOM lock hierarchy under memcg.*/\n\tspin_lock(&memcg_oom_lock);\n\tlocked = mem_cgroup_oom_lock(memcg);\n\t/*\n\t * Even if signal_pending(), we can't quit charge() loop without\n\t * accounting. So, UNINTERRUPTIBLE is appropriate. But SIGKILL\n\t * under OOM is always welcomed, use TASK_KILLABLE here.\n\t */\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tif (!locked || memcg->oom_kill_disable)\n\t\tneed_to_kill = false;\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\tspin_unlock(&memcg_oom_lock);\n\n\tif (need_to_kill) {\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, mask);\n\t} else {\n\t\tschedule();\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\tspin_lock(&memcg_oom_lock);\n\tif (locked)\n\t\tmem_cgroup_oom_unlock(memcg);\n\tmemcg_wakeup_oom(memcg);\n\tspin_unlock(&memcg_oom_lock);\n\n\tmem_cgroup_unmark_under_oom(memcg);\n\n\tif (test_thread_flag(TIF_MEMDIE) || fatal_signal_pending(current))\n\t\treturn false;\n\t/* Give chance to dying process */\n\tschedule_timeout_uninterruptible(1);\n\treturn true;\n}\n\n/*\n * Currently used to update mapped file statistics, but the routine can be\n * generalized to update other statistics as well.\n *\n * Notes: Race condition\n *\n * We usually use page_cgroup_lock() for accessing page_cgroup member but\n * it tends to be costly. But considering some conditions, we doesn't need\n * to do so _always_.\n *\n * Considering \"charge\", lock_page_cgroup() is not required because all\n * file-stat operations happen after a page is attached to radix-tree. There\n * are no race with \"charge\".\n *\n * Considering \"uncharge\", we know that memcg doesn't clear pc->mem_cgroup\n * at \"uncharge\" intentionally. So, we always see valid pc->mem_cgroup even\n * if there are race with \"uncharge\". Statistics itself is properly handled\n * by flags.\n *\n * Considering \"move\", this is an only case we see a race. To make the race\n * small, we check MEM_CGROUP_ON_MOVE percpu value and detect there are\n * possibility of race condition. If there is, we take a lock.\n */\n\nvoid mem_cgroup_update_page_stat(struct page *page,\n\t\t\t\t enum mem_cgroup_page_stat_item idx, int val)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc = lookup_page_cgroup(page);\n\tbool need_unlock = false;\n\tunsigned long uninitialized_var(flags);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\trcu_read_lock();\n\tmemcg = pc->mem_cgroup;\n\tif (unlikely(!memcg || !PageCgroupUsed(pc)))\n\t\tgoto out;\n\t/* pc->mem_cgroup is unstable ? */\n\tif (unlikely(mem_cgroup_stealed(memcg)) || PageTransHuge(page)) {\n\t\t/* take a lock against to access pc->mem_cgroup */\n\t\tmove_lock_page_cgroup(pc, &flags);\n\t\tneed_unlock = true;\n\t\tmemcg = pc->mem_cgroup;\n\t\tif (!memcg || !PageCgroupUsed(pc))\n\t\t\tgoto out;\n\t}\n\n\tswitch (idx) {\n\tcase MEMCG_NR_FILE_MAPPED:\n\t\tif (val > 0)\n\t\t\tSetPageCgroupFileMapped(pc);\n\t\telse if (!page_mapped(page))\n\t\t\tClearPageCgroupFileMapped(pc);\n\t\tidx = MEM_CGROUP_STAT_FILE_MAPPED;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tthis_cpu_add(memcg->stat->count[idx], val);\n\nout:\n\tif (unlikely(need_unlock))\n\t\tmove_unlock_page_cgroup(pc, &flags);\n\trcu_read_unlock();\n\treturn;\n}\nEXPORT_SYMBOL(mem_cgroup_update_page_stat);\n\n/*\n * size of first charge trial. \"32\" comes from vmscan.c's magic value.\n * TODO: maybe necessary to use big numbers in big irons.\n */\n#define CHARGE_BATCH\t32U\nstruct memcg_stock_pcp {\n\tstruct mem_cgroup *cached; /* this never be root cgroup */\n\tunsigned int nr_pages;\n\tstruct work_struct work;\n\tunsigned long flags;\n#define FLUSHING_CACHED_CHARGE\t(0)\n};\nstatic DEFINE_PER_CPU(struct memcg_stock_pcp, memcg_stock);\nstatic DEFINE_MUTEX(percpu_charge_mutex);\n\n/*\n * Try to consume stocked charge on this cpu. If success, one page is consumed\n * from local stock and true is returned. If the stock is 0 or charges from a\n * cgroup which is not current target, returns false. This stock will be\n * refilled.\n */\nstatic bool consume_stock(struct mem_cgroup *memcg)\n{\n\tstruct memcg_stock_pcp *stock;\n\tbool ret = true;\n\n\tstock = &get_cpu_var(memcg_stock);\n\tif (memcg == stock->cached && stock->nr_pages)\n\t\tstock->nr_pages--;\n\telse /* need to call res_counter_charge */\n\t\tret = false;\n\tput_cpu_var(memcg_stock);\n\treturn ret;\n}\n\n/*\n * Returns stocks cached in percpu to res_counter and reset cached information.\n */\nstatic void drain_stock(struct memcg_stock_pcp *stock)\n{\n\tstruct mem_cgroup *old = stock->cached;\n\n\tif (stock->nr_pages) {\n\t\tunsigned long bytes = stock->nr_pages * PAGE_SIZE;\n\n\t\tres_counter_uncharge(&old->res, bytes);\n\t\tif (do_swap_account)\n\t\t\tres_counter_uncharge(&old->memsw, bytes);\n\t\tstock->nr_pages = 0;\n\t}\n\tstock->cached = NULL;\n}\n\n/*\n * This must be called under preempt disabled or must be called by\n * a thread which is pinned to local cpu.\n */\nstatic void drain_local_stock(struct work_struct *dummy)\n{\n\tstruct memcg_stock_pcp *stock = &__get_cpu_var(memcg_stock);\n\tdrain_stock(stock);\n\tclear_bit(FLUSHING_CACHED_CHARGE, &stock->flags);\n}\n\n/*\n * Cache charges(val) which is from res_counter, to local per_cpu area.\n * This will be consumed by consume_stock() function, later.\n */\nstatic void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)\n{\n\tstruct memcg_stock_pcp *stock = &get_cpu_var(memcg_stock);\n\n\tif (stock->cached != memcg) { /* reset if necessary */\n\t\tdrain_stock(stock);\n\t\tstock->cached = memcg;\n\t}\n\tstock->nr_pages += nr_pages;\n\tput_cpu_var(memcg_stock);\n}\n\n/*\n * Drains all per-CPU charge caches for given root_memcg resp. subtree\n * of the hierarchy under it. sync flag says whether we should block\n * until the work is done.\n */\nstatic void drain_all_stock(struct mem_cgroup *root_memcg, bool sync)\n{\n\tint cpu, curcpu;\n\n\t/* Notify other cpus that system-wide \"drain\" is running */\n\tget_online_cpus();\n\tcurcpu = get_cpu();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = stock->cached;\n\t\tif (!memcg || !stock->nr_pages)\n\t\t\tcontinue;\n\t\tif (!mem_cgroup_same_or_subtree(root_memcg, memcg))\n\t\t\tcontinue;\n\t\tif (!test_and_set_bit(FLUSHING_CACHED_CHARGE, &stock->flags)) {\n\t\t\tif (cpu == curcpu)\n\t\t\t\tdrain_local_stock(&stock->work);\n\t\t\telse\n\t\t\t\tschedule_work_on(cpu, &stock->work);\n\t\t}\n\t}\n\tput_cpu();\n\n\tif (!sync)\n\t\tgoto out;\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct memcg_stock_pcp *stock = &per_cpu(memcg_stock, cpu);\n\t\tif (test_bit(FLUSHING_CACHED_CHARGE, &stock->flags))\n\t\t\tflush_work(&stock->work);\n\t}\nout:\n \tput_online_cpus();\n}\n\n/*\n * Tries to drain stocked charges in other cpus. This function is asynchronous\n * and just put a work per cpu for draining localy on each cpu. Caller can\n * expects some charges will be back to res_counter later but cannot wait for\n * it.\n */\nstatic void drain_all_stock_async(struct mem_cgroup *root_memcg)\n{\n\t/*\n\t * If someone calls draining, avoid adding more kworker runs.\n\t */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\tdrain_all_stock(root_memcg, false);\n\tmutex_unlock(&percpu_charge_mutex);\n}\n\n/* This is a synchronous drain interface. */\nstatic void drain_all_stock_sync(struct mem_cgroup *root_memcg)\n{\n\t/* called when force_empty is called */\n\tmutex_lock(&percpu_charge_mutex);\n\tdrain_all_stock(root_memcg, true);\n\tmutex_unlock(&percpu_charge_mutex);\n}\n\n/*\n * This function drains percpu counter value from DEAD cpu and\n * move it to local cpu. Note that this function can be preempted.\n */\nstatic void mem_cgroup_drain_pcp_counter(struct mem_cgroup *memcg, int cpu)\n{\n\tint i;\n\n\tspin_lock(&memcg->pcp_counter_lock);\n\tfor (i = 0; i < MEM_CGROUP_STAT_DATA; i++) {\n\t\tlong x = per_cpu(memcg->stat->count[i], cpu);\n\n\t\tper_cpu(memcg->stat->count[i], cpu) = 0;\n\t\tmemcg->nocpu_base.count[i] += x;\n\t}\n\tfor (i = 0; i < MEM_CGROUP_EVENTS_NSTATS; i++) {\n\t\tunsigned long x = per_cpu(memcg->stat->events[i], cpu);\n\n\t\tper_cpu(memcg->stat->events[i], cpu) = 0;\n\t\tmemcg->nocpu_base.events[i] += x;\n\t}\n\t/* need to clear ON_MOVE value, works as a kind of lock. */\n\tper_cpu(memcg->stat->count[MEM_CGROUP_ON_MOVE], cpu) = 0;\n\tspin_unlock(&memcg->pcp_counter_lock);\n}\n\nstatic void synchronize_mem_cgroup_on_move(struct mem_cgroup *memcg, int cpu)\n{\n\tint idx = MEM_CGROUP_ON_MOVE;\n\n\tspin_lock(&memcg->pcp_counter_lock);\n\tper_cpu(memcg->stat->count[idx], cpu) = memcg->nocpu_base.count[idx];\n\tspin_unlock(&memcg->pcp_counter_lock);\n}\n\nstatic int __cpuinit memcg_cpu_hotplug_callback(struct notifier_block *nb,\n\t\t\t\t\tunsigned long action,\n\t\t\t\t\tvoid *hcpu)\n{\n\tint cpu = (unsigned long)hcpu;\n\tstruct memcg_stock_pcp *stock;\n\tstruct mem_cgroup *iter;\n\n\tif ((action == CPU_ONLINE)) {\n\t\tfor_each_mem_cgroup(iter)\n\t\t\tsynchronize_mem_cgroup_on_move(iter, cpu);\n\t\treturn NOTIFY_OK;\n\t}\n\n\tif ((action != CPU_DEAD) || action != CPU_DEAD_FROZEN)\n\t\treturn NOTIFY_OK;\n\n\tfor_each_mem_cgroup(iter)\n\t\tmem_cgroup_drain_pcp_counter(iter, cpu);\n\n\tstock = &per_cpu(memcg_stock, cpu);\n\tdrain_stock(stock);\n\treturn NOTIFY_OK;\n}\n\n\n/* See __mem_cgroup_try_charge() for details */\nenum {\n\tCHARGE_OK,\t\t/* success */\n\tCHARGE_RETRY,\t\t/* need to retry but retry is not bad */\n\tCHARGE_NOMEM,\t\t/* we can't do more. return -ENOMEM */\n\tCHARGE_WOULDBLOCK,\t/* GFP_WAIT wasn't set and no enough res. */\n\tCHARGE_OOM_DIE,\t\t/* the current is killed because of OOM */\n};\n\nstatic int mem_cgroup_do_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,\n\t\t\t\tunsigned int nr_pages, bool oom_check)\n{\n\tunsigned long csize = nr_pages * PAGE_SIZE;\n\tstruct mem_cgroup *mem_over_limit;\n\tstruct res_counter *fail_res;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tret = res_counter_charge(&memcg->res, csize, &fail_res);\n\n\tif (likely(!ret)) {\n\t\tif (!do_swap_account)\n\t\t\treturn CHARGE_OK;\n\t\tret = res_counter_charge(&memcg->memsw, csize, &fail_res);\n\t\tif (likely(!ret))\n\t\t\treturn CHARGE_OK;\n\n\t\tres_counter_uncharge(&memcg->res, csize);\n\t\tmem_over_limit = mem_cgroup_from_res_counter(fail_res, memsw);\n\t\tflags |= MEM_CGROUP_RECLAIM_NOSWAP;\n\t} else\n\t\tmem_over_limit = mem_cgroup_from_res_counter(fail_res, res);\n\t/*\n\t * nr_pages can be either a huge page (HPAGE_PMD_NR), a batch\n\t * of regular pages (CHARGE_BATCH), or a single regular page (1).\n\t *\n\t * Never reclaim on behalf of optional batching, retry with a\n\t * single page instead.\n\t */\n\tif (nr_pages == CHARGE_BATCH)\n\t\treturn CHARGE_RETRY;\n\n\tif (!(gfp_mask & __GFP_WAIT))\n\t\treturn CHARGE_WOULDBLOCK;\n\n\tret = mem_cgroup_reclaim(mem_over_limit, gfp_mask, flags);\n\tif (mem_cgroup_margin(mem_over_limit) >= nr_pages)\n\t\treturn CHARGE_RETRY;\n\t/*\n\t * Even though the limit is exceeded at this point, reclaim\n\t * may have been able to free some pages.  Retry the charge\n\t * before killing the task.\n\t *\n\t * Only for regular pages, though: huge pages are rather\n\t * unlikely to succeed so close to the limit, and we fall back\n\t * to regular pages anyway in case of failure.\n\t */\n\tif (nr_pages == 1 && ret)\n\t\treturn CHARGE_RETRY;\n\n\t/*\n\t * At task move, charge accounts can be doubly counted. So, it's\n\t * better to wait until the end of task_move if something is going on.\n\t */\n\tif (mem_cgroup_wait_acct_move(mem_over_limit))\n\t\treturn CHARGE_RETRY;\n\n\t/* If we don't need to call oom-killer at el, return immediately */\n\tif (!oom_check)\n\t\treturn CHARGE_NOMEM;\n\t/* check OOM */\n\tif (!mem_cgroup_handle_oom(mem_over_limit, gfp_mask))\n\t\treturn CHARGE_OOM_DIE;\n\n\treturn CHARGE_RETRY;\n}\n\n/*\n * __mem_cgroup_try_charge() does\n * 1. detect memcg to be charged against from passed *mm and *ptr,\n * 2. update res_counter\n * 3. call memory reclaim if necessary.\n *\n * In some special case, if the task is fatal, fatal_signal_pending() or\n * has TIF_MEMDIE, this function returns -EINTR while writing root_mem_cgroup\n * to *ptr. There are two reasons for this. 1: fatal threads should quit as soon\n * as possible without any hazards. 2: all pages should have a valid\n * pc->mem_cgroup. If mm is NULL and the caller doesn't pass a valid memcg\n * pointer, that is treated as a charge to root_mem_cgroup.\n *\n * So __mem_cgroup_try_charge() will return\n *  0       ...  on success, filling *ptr with a valid memcg pointer.\n *  -ENOMEM ...  charge failure because of resource limits.\n *  -EINTR  ...  if thread is fatal. *ptr is filled with root_mem_cgroup.\n *\n * Unlike the exported interface, an \"oom\" parameter is added. if oom==true,\n * the oom-killer can be invoked.\n */\nstatic int __mem_cgroup_try_charge(struct mm_struct *mm,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned int nr_pages,\n\t\t\t\t   struct mem_cgroup **ptr,\n\t\t\t\t   bool oom)\n{\n\tunsigned int batch = max(CHARGE_BATCH, nr_pages);\n\tint nr_oom_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct mem_cgroup *memcg = NULL;\n\tint ret;\n\n\t/*\n\t * Unlike gloval-vm's OOM-kill, we're not in memory shortage\n\t * in system level. So, allow to go ahead dying process in addition to\n\t * MEMDIE process.\n\t */\n\tif (unlikely(test_thread_flag(TIF_MEMDIE)\n\t\t     || fatal_signal_pending(current)))\n\t\tgoto bypass;\n\n\t/*\n\t * We always charge the cgroup the mm_struct belongs to.\n\t * The mm_struct's mem_cgroup changes on task migration if the\n\t * thread group leader migrates. It's possible that mm is not\n\t * set, if so charge the init_mm (happens for pagecache usage).\n\t */\n\tif (!*ptr && !mm)\n\t\t*ptr = root_mem_cgroup;\nagain:\n\tif (*ptr) { /* css should be a valid one */\n\t\tmemcg = *ptr;\n\t\tVM_BUG_ON(css_is_removed(&memcg->css));\n\t\tif (mem_cgroup_is_root(memcg))\n\t\t\tgoto done;\n\t\tif (nr_pages == 1 && consume_stock(memcg))\n\t\t\tgoto done;\n\t\tcss_get(&memcg->css);\n\t} else {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tp = rcu_dereference(mm->owner);\n\t\t/*\n\t\t * Because we don't have task_lock(), \"p\" can exit.\n\t\t * In that case, \"memcg\" can point to root or p can be NULL with\n\t\t * race with swapoff. Then, we have small risk of mis-accouning.\n\t\t * But such kind of mis-account by race always happens because\n\t\t * we don't have cgroup_mutex(). It's overkill and we allo that\n\t\t * small race, here.\n\t\t * (*) swapoff at el will charge against mm-struct not against\n\t\t * task-struct. So, mm->owner can be NULL.\n\t\t */\n\t\tmemcg = mem_cgroup_from_task(p);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t\tif (mem_cgroup_is_root(memcg)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto done;\n\t\t}\n\t\tif (nr_pages == 1 && consume_stock(memcg)) {\n\t\t\t/*\n\t\t\t * It seems dagerous to access memcg without css_get().\n\t\t\t * But considering how consume_stok works, it's not\n\t\t\t * necessary. If consume_stock success, some charges\n\t\t\t * from this memcg are cached on this cpu. So, we\n\t\t\t * don't need to call css_get()/css_tryget() before\n\t\t\t * calling consume_stock().\n\t\t\t */\n\t\t\trcu_read_unlock();\n\t\t\tgoto done;\n\t\t}\n\t\t/* after here, we may be blocked. we need to get refcnt */\n\t\tif (!css_tryget(&memcg->css)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto again;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tdo {\n\t\tbool oom_check;\n\n\t\t/* If killed, bypass charge */\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcss_put(&memcg->css);\n\t\t\tgoto bypass;\n\t\t}\n\n\t\toom_check = false;\n\t\tif (oom && !nr_oom_retries) {\n\t\t\toom_check = true;\n\t\t\tnr_oom_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\t\t}\n\n\t\tret = mem_cgroup_do_charge(memcg, gfp_mask, batch, oom_check);\n\t\tswitch (ret) {\n\t\tcase CHARGE_OK:\n\t\t\tbreak;\n\t\tcase CHARGE_RETRY: /* not in OOM situation but retry */\n\t\t\tbatch = nr_pages;\n\t\t\tcss_put(&memcg->css);\n\t\t\tmemcg = NULL;\n\t\t\tgoto again;\n\t\tcase CHARGE_WOULDBLOCK: /* !__GFP_WAIT */\n\t\t\tcss_put(&memcg->css);\n\t\t\tgoto nomem;\n\t\tcase CHARGE_NOMEM: /* OOM routine works */\n\t\t\tif (!oom) {\n\t\t\t\tcss_put(&memcg->css);\n\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t\t/* If oom, we never return -ENOMEM */\n\t\t\tnr_oom_retries--;\n\t\t\tbreak;\n\t\tcase CHARGE_OOM_DIE: /* Killed by OOM Killer */\n\t\t\tcss_put(&memcg->css);\n\t\t\tgoto bypass;\n\t\t}\n\t} while (ret != CHARGE_OK);\n\n\tif (batch > nr_pages)\n\t\trefill_stock(memcg, batch - nr_pages);\n\tcss_put(&memcg->css);\ndone:\n\t*ptr = memcg;\n\treturn 0;\nnomem:\n\t*ptr = NULL;\n\treturn -ENOMEM;\nbypass:\n\t*ptr = root_mem_cgroup;\n\treturn -EINTR;\n}\n\n/*\n * Somemtimes we have to undo a charge we got by try_charge().\n * This function is for that and do uncharge, put css's refcnt.\n * gotten by try_charge().\n */\nstatic void __mem_cgroup_cancel_charge(struct mem_cgroup *memcg,\n\t\t\t\t       unsigned int nr_pages)\n{\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tunsigned long bytes = nr_pages * PAGE_SIZE;\n\n\t\tres_counter_uncharge(&memcg->res, bytes);\n\t\tif (do_swap_account)\n\t\t\tres_counter_uncharge(&memcg->memsw, bytes);\n\t}\n}\n\n/*\n * A helper function to get mem_cgroup from ID. must be called under\n * rcu_read_lock(). The caller must check css_is_removed() or some if\n * it's concern. (dropping refcnt from swap can be called against removed\n * memcg.)\n */\nstatic struct mem_cgroup *mem_cgroup_lookup(unsigned short id)\n{\n\tstruct cgroup_subsys_state *css;\n\n\t/* ID 0 is unused ID */\n\tif (!id)\n\t\treturn NULL;\n\tcss = css_lookup(&mem_cgroup_subsys, id);\n\tif (!css)\n\t\treturn NULL;\n\treturn container_of(css, struct mem_cgroup, css);\n}\n\nstruct mem_cgroup *try_get_mem_cgroup_from_page(struct page *page)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct page_cgroup *pc;\n\tunsigned short id;\n\tswp_entry_t ent;\n\n\tVM_BUG_ON(!PageLocked(page));\n\n\tpc = lookup_page_cgroup(page);\n\tlock_page_cgroup(pc);\n\tif (PageCgroupUsed(pc)) {\n\t\tmemcg = pc->mem_cgroup;\n\t\tif (memcg && !css_tryget(&memcg->css))\n\t\t\tmemcg = NULL;\n\t} else if (PageSwapCache(page)) {\n\t\tent.val = page_private(page);\n\t\tid = lookup_swap_cgroup_id(ent);\n\t\trcu_read_lock();\n\t\tmemcg = mem_cgroup_lookup(id);\n\t\tif (memcg && !css_tryget(&memcg->css))\n\t\t\tmemcg = NULL;\n\t\trcu_read_unlock();\n\t}\n\tunlock_page_cgroup(pc);\n\treturn memcg;\n}\n\nstatic void __mem_cgroup_commit_charge(struct mem_cgroup *memcg,\n\t\t\t\t       struct page *page,\n\t\t\t\t       unsigned int nr_pages,\n\t\t\t\t       struct page_cgroup *pc,\n\t\t\t\t       enum charge_type ctype)\n{\n\tlock_page_cgroup(pc);\n\tif (unlikely(PageCgroupUsed(pc))) {\n\t\tunlock_page_cgroup(pc);\n\t\t__mem_cgroup_cancel_charge(memcg, nr_pages);\n\t\treturn;\n\t}\n\t/*\n\t * we don't need page_cgroup_lock about tail pages, becase they are not\n\t * accessed by any other context at this point.\n\t */\n\tpc->mem_cgroup = memcg;\n\t/*\n\t * We access a page_cgroup asynchronously without lock_page_cgroup().\n\t * Especially when a page_cgroup is taken from a page, pc->mem_cgroup\n\t * is accessed after testing USED bit. To make pc->mem_cgroup visible\n\t * before USED bit, we need memory barrier here.\n\t * See mem_cgroup_add_lru_list(), etc.\n \t */\n\tsmp_wmb();\n\tswitch (ctype) {\n\tcase MEM_CGROUP_CHARGE_TYPE_CACHE:\n\tcase MEM_CGROUP_CHARGE_TYPE_SHMEM:\n\t\tSetPageCgroupCache(pc);\n\t\tSetPageCgroupUsed(pc);\n\t\tbreak;\n\tcase MEM_CGROUP_CHARGE_TYPE_MAPPED:\n\t\tClearPageCgroupCache(pc);\n\t\tSetPageCgroupUsed(pc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), nr_pages);\n\tunlock_page_cgroup(pc);\n\tWARN_ON_ONCE(PageLRU(page));\n\t/*\n\t * \"charge_statistics\" updated event counter. Then, check it.\n\t * Insert ancestor (and ancestor's ancestors), to softlimit RB-tree.\n\t * if they exceeds softlimit.\n\t */\n\tmemcg_check_events(memcg, page);\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\n#define PCGF_NOCOPY_AT_SPLIT ((1 << PCG_LOCK) | (1 << PCG_MOVE_LOCK) |\\\n\t\t\t(1 << PCG_MIGRATION))\n/*\n * Because tail pages are not marked as \"used\", set it. We're under\n * zone->lru_lock, 'splitting on pmd' and compound_lock.\n * charge/uncharge will be never happen and move_account() is done under\n * compound_lock(), so we don't have to take care of races.\n */\nvoid mem_cgroup_split_huge_fixup(struct page *head)\n{\n\tstruct page_cgroup *head_pc = lookup_page_cgroup(head);\n\tstruct page_cgroup *pc;\n\tint i;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\tpc = head_pc + i;\n\t\tpc->mem_cgroup = head_pc->mem_cgroup;\n\t\tsmp_wmb();/* see __commit_charge() */\n\t\tpc->flags = head_pc->flags & ~PCGF_NOCOPY_AT_SPLIT;\n\t}\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\n/**\n * mem_cgroup_move_account - move account of the page\n * @page: the page\n * @nr_pages: number of regular pages (>1 for huge pages)\n * @pc:\tpage_cgroup of the page.\n * @from: mem_cgroup which the page is moved from.\n * @to:\tmem_cgroup which the page is moved to. @from != @to.\n * @uncharge: whether we should call uncharge and css_put against @from.\n *\n * The caller must confirm following.\n * - page is not on LRU (isolate_page() is useful.)\n * - compound_lock is held when nr_pages > 1\n *\n * This function doesn't do \"charge\" nor css_get to new cgroup. It should be\n * done by a caller(__mem_cgroup_try_charge would be useful). If @uncharge is\n * true, this function does \"uncharge\" from old cgroup, but it doesn't if\n * @uncharge is false, so a caller should do \"uncharge\".\n */\nstatic int mem_cgroup_move_account(struct page *page,\n\t\t\t\t   unsigned int nr_pages,\n\t\t\t\t   struct page_cgroup *pc,\n\t\t\t\t   struct mem_cgroup *from,\n\t\t\t\t   struct mem_cgroup *to,\n\t\t\t\t   bool uncharge)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tVM_BUG_ON(from == to);\n\tVM_BUG_ON(PageLRU(page));\n\t/*\n\t * The page is isolated from LRU. So, collapse function\n\t * will not handle this page. But page splitting can happen.\n\t * Do this check under compound_page_lock(). The caller should\n\t * hold it.\n\t */\n\tret = -EBUSY;\n\tif (nr_pages > 1 && !PageTransHuge(page))\n\t\tgoto out;\n\n\tlock_page_cgroup(pc);\n\n\tret = -EINVAL;\n\tif (!PageCgroupUsed(pc) || pc->mem_cgroup != from)\n\t\tgoto unlock;\n\n\tmove_lock_page_cgroup(pc, &flags);\n\n\tif (PageCgroupFileMapped(pc)) {\n\t\t/* Update mapped_file data for mem_cgroup */\n\t\tpreempt_disable();\n\t\t__this_cpu_dec(from->stat->count[MEM_CGROUP_STAT_FILE_MAPPED]);\n\t\t__this_cpu_inc(to->stat->count[MEM_CGROUP_STAT_FILE_MAPPED]);\n\t\tpreempt_enable();\n\t}\n\tmem_cgroup_charge_statistics(from, PageCgroupCache(pc), -nr_pages);\n\tif (uncharge)\n\t\t/* This is not \"cancel\", but cancel_charge does all we need. */\n\t\t__mem_cgroup_cancel_charge(from, nr_pages);\n\n\t/* caller should have done css_get */\n\tpc->mem_cgroup = to;\n\tmem_cgroup_charge_statistics(to, PageCgroupCache(pc), nr_pages);\n\t/*\n\t * We charges against \"to\" which may not have any tasks. Then, \"to\"\n\t * can be under rmdir(). But in current implementation, caller of\n\t * this function is just force_empty() and move charge, so it's\n\t * guaranteed that \"to\" is never removed. So, we don't check rmdir\n\t * status here.\n\t */\n\tmove_unlock_page_cgroup(pc, &flags);\n\tret = 0;\nunlock:\n\tunlock_page_cgroup(pc);\n\t/*\n\t * check events\n\t */\n\tmemcg_check_events(to, page);\n\tmemcg_check_events(from, page);\nout:\n\treturn ret;\n}\n\n/*\n * move charges to its parent.\n */\n\nstatic int mem_cgroup_move_parent(struct page *page,\n\t\t\t\t  struct page_cgroup *pc,\n\t\t\t\t  struct mem_cgroup *child,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct cgroup *cg = child->css.cgroup;\n\tstruct cgroup *pcg = cg->parent;\n\tstruct mem_cgroup *parent;\n\tunsigned int nr_pages;\n\tunsigned long uninitialized_var(flags);\n\tint ret;\n\n\t/* Is ROOT ? */\n\tif (!pcg)\n\t\treturn -EINVAL;\n\n\tret = -EBUSY;\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tif (isolate_lru_page(page))\n\t\tgoto put;\n\n\tnr_pages = hpage_nr_pages(page);\n\n\tparent = mem_cgroup_from_cont(pcg);\n\tret = __mem_cgroup_try_charge(NULL, gfp_mask, nr_pages, &parent, false);\n\tif (ret)\n\t\tgoto put_back;\n\n\tif (nr_pages > 1)\n\t\tflags = compound_lock_irqsave(page);\n\n\tret = mem_cgroup_move_account(page, nr_pages, pc, child, parent, true);\n\tif (ret)\n\t\t__mem_cgroup_cancel_charge(parent, nr_pages);\n\n\tif (nr_pages > 1)\n\t\tcompound_unlock_irqrestore(page, flags);\nput_back:\n\tputback_lru_page(page);\nput:\n\tput_page(page);\nout:\n\treturn ret;\n}\n\n/*\n * Charge the memory controller for page usage.\n * Return\n * 0 if the charge was successful\n * < 0 if the cgroup is over its limit\n */\nstatic int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\tbool oom = true;\n\tint ret;\n\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t\t/*\n\t\t * Never OOM-kill a process for a huge page.  The\n\t\t * fault handler will fall back to regular pages.\n\t\t */\n\t\toom = false;\n\t}\n\n\tpc = lookup_page_cgroup(page);\n\tret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &memcg, oom);\n\tif (ret == -ENOMEM)\n\t\treturn ret;\n\t__mem_cgroup_commit_charge(memcg, page, nr_pages, pc, ctype);\n\treturn 0;\n}\n\nint mem_cgroup_newpage_charge(struct page *page,\n\t\t\t      struct mm_struct *mm, gfp_t gfp_mask)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\tVM_BUG_ON(page_mapped(page));\n\tVM_BUG_ON(page->mapping && !PageAnon(page));\n\tVM_BUG_ON(!mm);\n\treturn mem_cgroup_charge_common(page, mm, gfp_mask,\n\t\t\t\t\tMEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n\nstatic void\n__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *ptr,\n\t\t\t\t\tenum charge_type ctype);\n\nstatic void\n__mem_cgroup_commit_charge_lrucare(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tstruct page_cgroup *pc = lookup_page_cgroup(page);\n\tstruct zone *zone = page_zone(page);\n\tunsigned long flags;\n\tbool removed = false;\n\n\t/*\n\t * In some case, SwapCache, FUSE(splice_buf->radixtree), the page\n\t * is already on LRU. It means the page may on some other page_cgroup's\n\t * LRU. Take care of it.\n\t */\n\tspin_lock_irqsave(&zone->lru_lock, flags);\n\tif (PageLRU(page)) {\n\t\tdel_page_from_lru_list(zone, page, page_lru(page));\n\t\tClearPageLRU(page);\n\t\tremoved = true;\n\t}\n\t__mem_cgroup_commit_charge(memcg, page, 1, pc, ctype);\n\tif (removed) {\n\t\tadd_page_to_lru_list(zone, page, page_lru(page));\n\t\tSetPageLRU(page);\n\t}\n\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\treturn;\n}\n\nint mem_cgroup_cache_charge(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tenum charge_type type = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\tint ret;\n\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\tif (PageCompound(page))\n\t\treturn 0;\n\n\tif (unlikely(!mm))\n\t\tmm = &init_mm;\n\tif (!page_is_file_cache(page))\n\t\ttype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\n\tif (!PageSwapCache(page))\n\t\tret = mem_cgroup_charge_common(page, mm, gfp_mask, type);\n\telse { /* page is swapcache/shmem */\n\t\tret = mem_cgroup_try_charge_swapin(mm, page, gfp_mask, &memcg);\n\t\tif (!ret)\n\t\t\t__mem_cgroup_commit_charge_swapin(page, memcg, type);\n\t}\n\treturn ret;\n}\n\n/*\n * While swap-in, try_charge -> commit or cancel, the page is locked.\n * And when try_charge() successfully returns, one refcnt to memcg without\n * struct page_cgroup is acquired. This refcnt will be consumed by\n * \"commit()\" or removed by \"cancel()\"\n */\nint mem_cgroup_try_charge_swapin(struct mm_struct *mm,\n\t\t\t\t struct page *page,\n\t\t\t\t gfp_t mask, struct mem_cgroup **memcgp)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\t*memcgp = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\n\tif (!do_swap_account)\n\t\tgoto charge_cur_mm;\n\t/*\n\t * A racing thread's fault, or swapoff, may have already updated\n\t * the pte, and even removed page from swap cache: in those cases\n\t * do_swap_page()'s pte_same() test will fail; but there's also a\n\t * KSM case which does need to charge the page.\n\t */\n\tif (!PageSwapCache(page))\n\t\tgoto charge_cur_mm;\n\tmemcg = try_get_mem_cgroup_from_page(page);\n\tif (!memcg)\n\t\tgoto charge_cur_mm;\n\t*memcgp = memcg;\n\tret = __mem_cgroup_try_charge(NULL, mask, 1, memcgp, true);\n\tcss_put(&memcg->css);\n\tif (ret == -EINTR)\n\t\tret = 0;\n\treturn ret;\ncharge_cur_mm:\n\tif (unlikely(!mm))\n\t\tmm = &init_mm;\n\tret = __mem_cgroup_try_charge(mm, mask, 1, memcgp, true);\n\tif (ret == -EINTR)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void\n__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\tcgroup_exclude_rmdir(&memcg->css);\n\n\t__mem_cgroup_commit_charge_lrucare(page, memcg, ctype);\n\t/*\n\t * Now swap is on-memory. This means this page may be\n\t * counted both as mem and swap....double count.\n\t * Fix it by uncharging from memsw. Basically, this SwapCache is stable\n\t * under lock_page(). But in do_swap_page()::memory.c, reuse_swap_page()\n\t * may call delete_from_swap_cache() before reach here.\n\t */\n\tif (do_swap_account && PageSwapCache(page)) {\n\t\tswp_entry_t ent = {.val = page_private(page)};\n\t\tstruct mem_cgroup *swap_memcg;\n\t\tunsigned short id;\n\n\t\tid = swap_cgroup_record(ent, 0);\n\t\trcu_read_lock();\n\t\tswap_memcg = mem_cgroup_lookup(id);\n\t\tif (swap_memcg) {\n\t\t\t/*\n\t\t\t * This recorded memcg can be obsolete one. So, avoid\n\t\t\t * calling css_tryget\n\t\t\t */\n\t\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\t\tres_counter_uncharge(&swap_memcg->memsw,\n\t\t\t\t\t\t     PAGE_SIZE);\n\t\t\tmem_cgroup_swap_statistics(swap_memcg, false);\n\t\t\tmem_cgroup_put(swap_memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\t/*\n\t * At swapin, we may charge account against cgroup which has no tasks.\n\t * So, rmdir()->pre_destroy() can be called while we do this charge.\n\t * In that case, we need to call pre_destroy() again. check it here.\n\t */\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}\n\nvoid mem_cgroup_commit_charge_swapin(struct page *page,\n\t\t\t\t     struct mem_cgroup *memcg)\n{\n\t__mem_cgroup_commit_charge_swapin(page, memcg,\n\t\t\t\t\t  MEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n\nvoid mem_cgroup_cancel_charge_swapin(struct mem_cgroup *memcg)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\t__mem_cgroup_cancel_charge(memcg, 1);\n}\n\nstatic void mem_cgroup_do_uncharge(struct mem_cgroup *memcg,\n\t\t\t\t   unsigned int nr_pages,\n\t\t\t\t   const enum charge_type ctype)\n{\n\tstruct memcg_batch_info *batch = NULL;\n\tbool uncharge_memsw = true;\n\n\t/* If swapout, usage of swap doesn't decrease */\n\tif (!do_swap_account || ctype == MEM_CGROUP_CHARGE_TYPE_SWAPOUT)\n\t\tuncharge_memsw = false;\n\n\tbatch = &current->memcg_batch;\n\t/*\n\t * In usual, we do css_get() when we remember memcg pointer.\n\t * But in this case, we keep res->usage until end of a series of\n\t * uncharges. Then, it's ok to ignore memcg's refcnt.\n\t */\n\tif (!batch->memcg)\n\t\tbatch->memcg = memcg;\n\t/*\n\t * do_batch > 0 when unmapping pages or inode invalidate/truncate.\n\t * In those cases, all pages freed continuously can be expected to be in\n\t * the same cgroup and we have chance to coalesce uncharges.\n\t * But we do uncharge one by one if this is killed by OOM(TIF_MEMDIE)\n\t * because we want to do uncharge as soon as possible.\n\t */\n\n\tif (!batch->do_batch || test_thread_flag(TIF_MEMDIE))\n\t\tgoto direct_uncharge;\n\n\tif (nr_pages > 1)\n\t\tgoto direct_uncharge;\n\n\t/*\n\t * In typical case, batch->memcg == mem. This means we can\n\t * merge a series of uncharges to an uncharge of res_counter.\n\t * If not, we uncharge res_counter ony by one.\n\t */\n\tif (batch->memcg != memcg)\n\t\tgoto direct_uncharge;\n\t/* remember freed charge and uncharge it later */\n\tbatch->nr_pages++;\n\tif (uncharge_memsw)\n\t\tbatch->memsw_nr_pages++;\n\treturn;\ndirect_uncharge:\n\tres_counter_uncharge(&memcg->res, nr_pages * PAGE_SIZE);\n\tif (uncharge_memsw)\n\t\tres_counter_uncharge(&memcg->memsw, nr_pages * PAGE_SIZE);\n\tif (unlikely(batch->memcg != memcg))\n\t\tmemcg_oom_recover(memcg);\n\treturn;\n}\n\n/*\n * uncharge if !page_mapped(page)\n */\nstatic struct mem_cgroup *\n__mem_cgroup_uncharge_common(struct page *page, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (PageSwapCache(page))\n\t\treturn NULL;\n\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t}\n\t/*\n\t * Check if our page_cgroup is valid\n\t */\n\tpc = lookup_page_cgroup(page);\n\tif (unlikely(!PageCgroupUsed(pc)))\n\t\treturn NULL;\n\n\tlock_page_cgroup(pc);\n\n\tmemcg = pc->mem_cgroup;\n\n\tif (!PageCgroupUsed(pc))\n\t\tgoto unlock_out;\n\n\tswitch (ctype) {\n\tcase MEM_CGROUP_CHARGE_TYPE_MAPPED:\n\tcase MEM_CGROUP_CHARGE_TYPE_DROP:\n\t\t/* See mem_cgroup_prepare_migration() */\n\t\tif (page_mapped(page) || PageCgroupMigration(pc))\n\t\t\tgoto unlock_out;\n\t\tbreak;\n\tcase MEM_CGROUP_CHARGE_TYPE_SWAPOUT:\n\t\tif (!PageAnon(page)) {\t/* Shared memory */\n\t\t\tif (page->mapping && !page_is_file_cache(page))\n\t\t\t\tgoto unlock_out;\n\t\t} else if (page_mapped(page)) /* Anon */\n\t\t\t\tgoto unlock_out;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), -nr_pages);\n\n\tClearPageCgroupUsed(pc);\n\t/*\n\t * pc->mem_cgroup is not cleared here. It will be accessed when it's\n\t * freed from LRU. This is safe because uncharged page is expected not\n\t * to be reused (freed soon). Exception is SwapCache, it's handled by\n\t * special functions.\n\t */\n\n\tunlock_page_cgroup(pc);\n\t/*\n\t * even after unlock, we have memcg->res.usage here and this memcg\n\t * will never be freed.\n\t */\n\tmemcg_check_events(memcg, page);\n\tif (do_swap_account && ctype == MEM_CGROUP_CHARGE_TYPE_SWAPOUT) {\n\t\tmem_cgroup_swap_statistics(memcg, true);\n\t\tmem_cgroup_get(memcg);\n\t}\n\tif (!mem_cgroup_is_root(memcg))\n\t\tmem_cgroup_do_uncharge(memcg, nr_pages, ctype);\n\n\treturn memcg;\n\nunlock_out:\n\tunlock_page_cgroup(pc);\n\treturn NULL;\n}\n\nvoid mem_cgroup_uncharge_page(struct page *page)\n{\n\t/* early check. */\n\tif (page_mapped(page))\n\t\treturn;\n\tVM_BUG_ON(page->mapping && !PageAnon(page));\n\t__mem_cgroup_uncharge_common(page, MEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n\nvoid mem_cgroup_uncharge_cache_page(struct page *page)\n{\n\tVM_BUG_ON(page_mapped(page));\n\tVM_BUG_ON(page->mapping);\n\t__mem_cgroup_uncharge_common(page, MEM_CGROUP_CHARGE_TYPE_CACHE);\n}\n\n/*\n * Batch_start/batch_end is called in unmap_page_range/invlidate/trucate.\n * In that cases, pages are freed continuously and we can expect pages\n * are in the same memcg. All these calls itself limits the number of\n * pages freed at once, then uncharge_start/end() is called properly.\n * This may be called prural(2) times in a context,\n */\n\nvoid mem_cgroup_uncharge_start(void)\n{\n\tcurrent->memcg_batch.do_batch++;\n\t/* We can do nest. */\n\tif (current->memcg_batch.do_batch == 1) {\n\t\tcurrent->memcg_batch.memcg = NULL;\n\t\tcurrent->memcg_batch.nr_pages = 0;\n\t\tcurrent->memcg_batch.memsw_nr_pages = 0;\n\t}\n}\n\nvoid mem_cgroup_uncharge_end(void)\n{\n\tstruct memcg_batch_info *batch = &current->memcg_batch;\n\n\tif (!batch->do_batch)\n\t\treturn;\n\n\tbatch->do_batch--;\n\tif (batch->do_batch) /* If stacked, do nothing. */\n\t\treturn;\n\n\tif (!batch->memcg)\n\t\treturn;\n\t/*\n\t * This \"batch->memcg\" is valid without any css_get/put etc...\n\t * bacause we hide charges behind us.\n\t */\n\tif (batch->nr_pages)\n\t\tres_counter_uncharge(&batch->memcg->res,\n\t\t\t\t     batch->nr_pages * PAGE_SIZE);\n\tif (batch->memsw_nr_pages)\n\t\tres_counter_uncharge(&batch->memcg->memsw,\n\t\t\t\t     batch->memsw_nr_pages * PAGE_SIZE);\n\tmemcg_oom_recover(batch->memcg);\n\t/* forget this pointer (for sanity check) */\n\tbatch->memcg = NULL;\n}\n\n/*\n * A function for resetting pc->mem_cgroup for newly allocated pages.\n * This function should be called if the newpage will be added to LRU\n * before start accounting.\n */\nvoid mem_cgroup_reset_owner(struct page *newpage)\n{\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(newpage);\n\tVM_BUG_ON(PageCgroupUsed(pc));\n\tpc->mem_cgroup = root_mem_cgroup;\n}\n\n#ifdef CONFIG_SWAP\n/*\n * called after __delete_from_swap_cache() and drop \"page\" account.\n * memcg information is recorded to swap_cgroup of \"ent\"\n */\nvoid\nmem_cgroup_uncharge_swapcache(struct page *page, swp_entry_t ent, bool swapout)\n{\n\tstruct mem_cgroup *memcg;\n\tint ctype = MEM_CGROUP_CHARGE_TYPE_SWAPOUT;\n\n\tif (!swapout) /* this was a swap cache but the swap is unused ! */\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_DROP;\n\n\tmemcg = __mem_cgroup_uncharge_common(page, ctype);\n\n\t/*\n\t * record memcg information,  if swapout && memcg != NULL,\n\t * mem_cgroup_get() was called in uncharge().\n\t */\n\tif (do_swap_account && swapout && memcg)\n\t\tswap_cgroup_record(ent, css_id(&memcg->css));\n}\n#endif\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\n/*\n * called from swap_entry_free(). remove record in swap_cgroup and\n * uncharge \"memsw\" account.\n */\nvoid mem_cgroup_uncharge_swap(swp_entry_t ent)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(ent, 0);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_lookup(id);\n\tif (memcg) {\n\t\t/*\n\t\t * We uncharge this because swap is freed.\n\t\t * This memcg can be obsolete one. We avoid calling css_tryget\n\t\t */\n\t\tif (!mem_cgroup_is_root(memcg))\n\t\t\tres_counter_uncharge(&memcg->memsw, PAGE_SIZE);\n\t\tmem_cgroup_swap_statistics(memcg, false);\n\t\tmem_cgroup_put(memcg);\n\t}\n\trcu_read_unlock();\n}\n\n/**\n * mem_cgroup_move_swap_account - move swap charge and swap_cgroup's record.\n * @entry: swap entry to be moved\n * @from:  mem_cgroup which the entry is moved from\n * @to:  mem_cgroup which the entry is moved to\n * @need_fixup: whether we should fixup res_counters and refcounts.\n *\n * It succeeds only when the swap_cgroup's record for this entry is the same\n * as the mem_cgroup's id of @from.\n *\n * Returns 0 on success, -EINVAL on failure.\n *\n * The caller must have charged to @to, IOW, called res_counter_charge() about\n * both res and memsw, and called css_get().\n */\nstatic int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\tstruct mem_cgroup *from, struct mem_cgroup *to, bool need_fixup)\n{\n\tunsigned short old_id, new_id;\n\n\told_id = css_id(&from->css);\n\tnew_id = css_id(&to->css);\n\n\tif (swap_cgroup_cmpxchg(entry, old_id, new_id) == old_id) {\n\t\tmem_cgroup_swap_statistics(from, false);\n\t\tmem_cgroup_swap_statistics(to, true);\n\t\t/*\n\t\t * This function is only called from task migration context now.\n\t\t * It postpones res_counter and refcount handling till the end\n\t\t * of task migration(mem_cgroup_clear_mc()) for performance\n\t\t * improvement. But we cannot postpone mem_cgroup_get(to)\n\t\t * because if the process that has been moved to @to does\n\t\t * swap-in, the refcount of @to might be decreased to 0.\n\t\t */\n\t\tmem_cgroup_get(to);\n\t\tif (need_fixup) {\n\t\t\tif (!mem_cgroup_is_root(from))\n\t\t\t\tres_counter_uncharge(&from->memsw, PAGE_SIZE);\n\t\t\tmem_cgroup_put(from);\n\t\t\t/*\n\t\t\t * we charged both to->res and to->memsw, so we should\n\t\t\t * uncharge to->res.\n\t\t\t */\n\t\t\tif (!mem_cgroup_is_root(to))\n\t\t\t\tres_counter_uncharge(&to->res, PAGE_SIZE);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n#else\nstatic inline int mem_cgroup_move_swap_account(swp_entry_t entry,\n\t\tstruct mem_cgroup *from, struct mem_cgroup *to, bool need_fixup)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Before starting migration, account PAGE_SIZE to mem_cgroup that the old\n * page belongs to.\n */\nint mem_cgroup_prepare_migration(struct page *page,\n\tstruct page *newpage, struct mem_cgroup **memcgp, gfp_t gfp_mask)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct page_cgroup *pc;\n\tenum charge_type ctype;\n\tint ret = 0;\n\n\t*memcgp = NULL;\n\n\tVM_BUG_ON(PageTransHuge(page));\n\tif (mem_cgroup_disabled())\n\t\treturn 0;\n\n\tpc = lookup_page_cgroup(page);\n\tlock_page_cgroup(pc);\n\tif (PageCgroupUsed(pc)) {\n\t\tmemcg = pc->mem_cgroup;\n\t\tcss_get(&memcg->css);\n\t\t/*\n\t\t * At migrating an anonymous page, its mapcount goes down\n\t\t * to 0 and uncharge() will be called. But, even if it's fully\n\t\t * unmapped, migration may fail and this page has to be\n\t\t * charged again. We set MIGRATION flag here and delay uncharge\n\t\t * until end_migration() is called\n\t\t *\n\t\t * Corner Case Thinking\n\t\t * A)\n\t\t * When the old page was mapped as Anon and it's unmap-and-freed\n\t\t * while migration was ongoing.\n\t\t * If unmap finds the old page, uncharge() of it will be delayed\n\t\t * until end_migration(). If unmap finds a new page, it's\n\t\t * uncharged when it make mapcount to be 1->0. If unmap code\n\t\t * finds swap_migration_entry, the new page will not be mapped\n\t\t * and end_migration() will find it(mapcount==0).\n\t\t *\n\t\t * B)\n\t\t * When the old page was mapped but migraion fails, the kernel\n\t\t * remaps it. A charge for it is kept by MIGRATION flag even\n\t\t * if mapcount goes down to 0. We can do remap successfully\n\t\t * without charging it again.\n\t\t *\n\t\t * C)\n\t\t * The \"old\" page is under lock_page() until the end of\n\t\t * migration, so, the old page itself will not be swapped-out.\n\t\t * If the new page is swapped out before end_migraton, our\n\t\t * hook to usual swap-out path will catch the event.\n\t\t */\n\t\tif (PageAnon(page))\n\t\t\tSetPageCgroupMigration(pc);\n\t}\n\tunlock_page_cgroup(pc);\n\t/*\n\t * If the page is not charged at this point,\n\t * we return here.\n\t */\n\tif (!memcg)\n\t\treturn 0;\n\n\t*memcgp = memcg;\n\tret = __mem_cgroup_try_charge(NULL, gfp_mask, 1, memcgp, false);\n\tcss_put(&memcg->css);/* drop extra refcnt */\n\tif (ret) {\n\t\tif (PageAnon(page)) {\n\t\t\tlock_page_cgroup(pc);\n\t\t\tClearPageCgroupMigration(pc);\n\t\t\tunlock_page_cgroup(pc);\n\t\t\t/*\n\t\t\t * The old page may be fully unmapped while we kept it.\n\t\t\t */\n\t\t\tmem_cgroup_uncharge_page(page);\n\t\t}\n\t\t/* we'll need to revisit this error code (we have -EINTR) */\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * We charge new page before it's used/mapped. So, even if unlock_page()\n\t * is called before end_migration, we can catch all events on this new\n\t * page. In the case new page is migrated but not remapped, new page's\n\t * mapcount will be finally 0 and we call uncharge in end_migration().\n\t */\n\tpc = lookup_page_cgroup(newpage);\n\tif (PageAnon(page))\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_MAPPED;\n\telse if (page_is_file_cache(page))\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\telse\n\t\tctype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\t__mem_cgroup_commit_charge(memcg, newpage, 1, pc, ctype);\n\treturn ret;\n}\n\n/* remove redundant charge if migration failed*/\nvoid mem_cgroup_end_migration(struct mem_cgroup *memcg,\n\tstruct page *oldpage, struct page *newpage, bool migration_ok)\n{\n\tstruct page *used, *unused;\n\tstruct page_cgroup *pc;\n\n\tif (!memcg)\n\t\treturn;\n\t/* blocks rmdir() */\n\tcgroup_exclude_rmdir(&memcg->css);\n\tif (!migration_ok) {\n\t\tused = oldpage;\n\t\tunused = newpage;\n\t} else {\n\t\tused = newpage;\n\t\tunused = oldpage;\n\t}\n\t/*\n\t * We disallowed uncharge of pages under migration because mapcount\n\t * of the page goes down to zero, temporarly.\n\t * Clear the flag and check the page should be charged.\n\t */\n\tpc = lookup_page_cgroup(oldpage);\n\tlock_page_cgroup(pc);\n\tClearPageCgroupMigration(pc);\n\tunlock_page_cgroup(pc);\n\n\t__mem_cgroup_uncharge_common(unused, MEM_CGROUP_CHARGE_TYPE_FORCE);\n\n\t/*\n\t * If a page is a file cache, radix-tree replacement is very atomic\n\t * and we can skip this check. When it was an Anon page, its mapcount\n\t * goes down to 0. But because we added MIGRATION flage, it's not\n\t * uncharged yet. There are several case but page->mapcount check\n\t * and USED bit check in mem_cgroup_uncharge_page() will do enough\n\t * check. (see prepare_charge() also)\n\t */\n\tif (PageAnon(used))\n\t\tmem_cgroup_uncharge_page(used);\n\t/*\n\t * At migration, we may charge account against cgroup which has no\n\t * tasks.\n\t * So, rmdir()->pre_destroy() can be called while we do this charge.\n\t * In that case, we need to call pre_destroy() again. check it here.\n\t */\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}\n\n/*\n * At replace page cache, newpage is not under any memcg but it's on\n * LRU. So, this function doesn't touch res_counter but handles LRU\n * in correct way. Both pages are locked so we cannot race with uncharge.\n */\nvoid mem_cgroup_replace_page_cache(struct page *oldpage,\n\t\t\t\t  struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\tenum charge_type type = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(oldpage);\n\t/* fix accounting on old pages */\n\tlock_page_cgroup(pc);\n\tmemcg = pc->mem_cgroup;\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), -1);\n\tClearPageCgroupUsed(pc);\n\tunlock_page_cgroup(pc);\n\n\tif (PageSwapBacked(oldpage))\n\t\ttype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\n\t/*\n\t * Even if newpage->mapping was NULL before starting replacement,\n\t * the newpage may be on LRU(or pagevec for LRU) already. We lock\n\t * LRU while we overwrite pc->mem_cgroup.\n\t */\n\t__mem_cgroup_commit_charge_lrucare(newpage, memcg, type);\n}\n\n#ifdef CONFIG_DEBUG_VM\nstatic struct page_cgroup *lookup_page_cgroup_used(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\n\tpc = lookup_page_cgroup(page);\n\t/*\n\t * Can be NULL while feeding pages into the page allocator for\n\t * the first time, i.e. during boot or memory hotplug;\n\t * or when mem_cgroup_disabled().\n\t */\n\tif (likely(pc) && PageCgroupUsed(pc))\n\t\treturn pc;\n\treturn NULL;\n}\n\nbool mem_cgroup_bad_page_check(struct page *page)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn false;\n\n\treturn lookup_page_cgroup_used(page) != NULL;\n}\n\nvoid mem_cgroup_print_bad_page(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\n\tpc = lookup_page_cgroup_used(page);\n\tif (pc) {\n\t\tprintk(KERN_ALERT \"pc:%p pc->flags:%lx pc->mem_cgroup:%p\\n\",\n\t\t       pc, pc->flags, pc->mem_cgroup);\n\t}\n}\n#endif\n\nstatic DEFINE_MUTEX(set_limit_mutex);\n\nstatic int mem_cgroup_resize_limit(struct mem_cgroup *memcg,\n\t\t\t\tunsigned long long val)\n{\n\tint retry_count;\n\tu64 memswlimit, memlimit;\n\tint ret = 0;\n\tint children = mem_cgroup_count_children(memcg);\n\tu64 curusage, oldusage;\n\tint enlarge;\n\n\t/*\n\t * For keeping hierarchical_reclaim simple, how long we should retry\n\t * is depends on callers. We set our retry-count to be function\n\t * of # of children which we should visit in this loop.\n\t */\n\tretry_count = MEM_CGROUP_RECLAIM_RETRIES * children;\n\n\toldusage = res_counter_read_u64(&memcg->res, RES_USAGE);\n\n\tenlarge = 0;\n\twhile (retry_count) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Rather than hide all in some function, I do this in\n\t\t * open coded manner. You see what this really does.\n\t\t * We have to guarantee memcg->res.limit < memcg->memsw.limit.\n\t\t */\n\t\tmutex_lock(&set_limit_mutex);\n\t\tmemswlimit = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t\tif (memswlimit < val) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&set_limit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemlimit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\t\tif (memlimit < val)\n\t\t\tenlarge = 1;\n\n\t\tret = res_counter_set_limit(&memcg->res, val);\n\t\tif (!ret) {\n\t\t\tif (memswlimit == val)\n\t\t\t\tmemcg->memsw_is_minimum = true;\n\t\t\telse\n\t\t\t\tmemcg->memsw_is_minimum = false;\n\t\t}\n\t\tmutex_unlock(&set_limit_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmem_cgroup_reclaim(memcg, GFP_KERNEL,\n\t\t\t\t   MEM_CGROUP_RECLAIM_SHRINK);\n\t\tcurusage = res_counter_read_u64(&memcg->res, RES_USAGE);\n\t\t/* Usage is reduced ? */\n  \t\tif (curusage >= oldusage)\n\t\t\tretry_count--;\n\t\telse\n\t\t\toldusage = curusage;\n\t}\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\n\treturn ret;\n}\n\nstatic int mem_cgroup_resize_memsw_limit(struct mem_cgroup *memcg,\n\t\t\t\t\tunsigned long long val)\n{\n\tint retry_count;\n\tu64 memlimit, memswlimit, oldusage, curusage;\n\tint children = mem_cgroup_count_children(memcg);\n\tint ret = -EBUSY;\n\tint enlarge = 0;\n\n\t/* see mem_cgroup_resize_res_limit */\n \tretry_count = children * MEM_CGROUP_RECLAIM_RETRIES;\n\toldusage = res_counter_read_u64(&memcg->memsw, RES_USAGE);\n\twhile (retry_count) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Rather than hide all in some function, I do this in\n\t\t * open coded manner. You see what this really does.\n\t\t * We have to guarantee memcg->res.limit < memcg->memsw.limit.\n\t\t */\n\t\tmutex_lock(&set_limit_mutex);\n\t\tmemlimit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\t\tif (memlimit > val) {\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&set_limit_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tmemswlimit = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t\tif (memswlimit < val)\n\t\t\tenlarge = 1;\n\t\tret = res_counter_set_limit(&memcg->memsw, val);\n\t\tif (!ret) {\n\t\t\tif (memlimit == val)\n\t\t\t\tmemcg->memsw_is_minimum = true;\n\t\t\telse\n\t\t\t\tmemcg->memsw_is_minimum = false;\n\t\t}\n\t\tmutex_unlock(&set_limit_mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmem_cgroup_reclaim(memcg, GFP_KERNEL,\n\t\t\t\t   MEM_CGROUP_RECLAIM_NOSWAP |\n\t\t\t\t   MEM_CGROUP_RECLAIM_SHRINK);\n\t\tcurusage = res_counter_read_u64(&memcg->memsw, RES_USAGE);\n\t\t/* Usage is reduced ? */\n\t\tif (curusage >= oldusage)\n\t\t\tretry_count--;\n\t\telse\n\t\t\toldusage = curusage;\n\t}\n\tif (!ret && enlarge)\n\t\tmemcg_oom_recover(memcg);\n\treturn ret;\n}\n\nunsigned long mem_cgroup_soft_limit_reclaim(struct zone *zone, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_zone *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\tunsigned long long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node_zone(zone_to_nid(zone), zone_idx(zone));\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->mem, zone,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock(&mctz->lock);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed) {\n\t\t\tdo {\n\t\t\t\t/*\n\t\t\t\t * Loop until we find yet another one.\n\t\t\t\t *\n\t\t\t\t * By the time we get the soft_limit lock\n\t\t\t\t * again, someone might have aded the\n\t\t\t\t * group back on the RB tree. Iterate to\n\t\t\t\t * make sure we get a different mem.\n\t\t\t\t * mem_cgroup_largest_soft_limit_node returns\n\t\t\t\t * NULL if no other cgroup is present on\n\t\t\t\t * the tree\n\t\t\t\t */\n\t\t\t\tnext_mz =\n\t\t\t\t__mem_cgroup_largest_soft_limit_node(mctz);\n\t\t\t\tif (next_mz == mz)\n\t\t\t\t\tcss_put(&next_mz->mem->css);\n\t\t\t\telse /* next_mz == NULL or other memcg */\n\t\t\t\t\tbreak;\n\t\t\t} while (1);\n\t\t}\n\t\t__mem_cgroup_remove_exceeded(mz->mem, mz, mctz);\n\t\texcess = res_counter_soft_limit_excess(&mz->mem->res);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz->mem, mz, mctz, excess);\n\t\tspin_unlock(&mctz->lock);\n\t\tcss_put(&mz->mem->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->mem->css);\n\treturn nr_reclaimed;\n}\n\n/*\n * This routine traverse page_cgroup in given list and drop them all.\n * *And* this routine doesn't reclaim page itself, just removes page_cgroup.\n */\nstatic int mem_cgroup_force_empty_list(struct mem_cgroup *memcg,\n\t\t\t\tint node, int zid, enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tunsigned long flags, loop;\n\tstruct list_head *list;\n\tstruct page *busy;\n\tstruct zone *zone;\n\tint ret = 0;\n\n\tzone = &NODE_DATA(node)->node_zones[zid];\n\tmz = mem_cgroup_zoneinfo(memcg, node, zid);\n\tlist = &mz->lruvec.lists[lru];\n\n\tloop = MEM_CGROUP_ZSTAT(mz, lru);\n\t/* give some margin against EBUSY etc...*/\n\tloop += 256;\n\tbusy = NULL;\n\twhile (loop--) {\n\t\tstruct page_cgroup *pc;\n\t\tstruct page *page;\n\n\t\tret = 0;\n\t\tspin_lock_irqsave(&zone->lru_lock, flags);\n\t\tif (list_empty(list)) {\n\t\t\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tpage = list_entry(list->prev, struct page, lru);\n\t\tif (busy == page) {\n\t\t\tlist_move(&page->lru, list);\n\t\t\tbusy = NULL;\n\t\t\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lru_lock, flags);\n\n\t\tpc = lookup_page_cgroup(page);\n\n\t\tret = mem_cgroup_move_parent(page, pc, memcg, GFP_KERNEL);\n\t\tif (ret == -ENOMEM || ret == -EINTR)\n\t\t\tbreak;\n\n\t\tif (ret == -EBUSY || ret == -EINVAL) {\n\t\t\t/* found lock contention or \"pc\" is obsolete. */\n\t\t\tbusy = page;\n\t\t\tcond_resched();\n\t\t} else\n\t\t\tbusy = NULL;\n\t}\n\n\tif (!ret && !list_empty(list))\n\t\treturn -EBUSY;\n\treturn ret;\n}\n\n/*\n * make mem_cgroup's charge to be 0 if there is no task.\n * This enables deleting this mem_cgroup.\n */\nstatic int mem_cgroup_force_empty(struct mem_cgroup *memcg, bool free_all)\n{\n\tint ret;\n\tint node, zid, shrink;\n\tint nr_retries = MEM_CGROUP_RECLAIM_RETRIES;\n\tstruct cgroup *cgrp = memcg->css.cgroup;\n\n\tcss_get(&memcg->css);\n\n\tshrink = 0;\n\t/* should free all ? */\n\tif (free_all)\n\t\tgoto try_to_free;\nmove_account:\n\tdo {\n\t\tret = -EBUSY;\n\t\tif (cgroup_task_count(cgrp) || !list_empty(&cgrp->children))\n\t\t\tgoto out;\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\t/* This is for making all *used* pages to be on LRU. */\n\t\tlru_add_drain_all();\n\t\tdrain_all_stock_sync(memcg);\n\t\tret = 0;\n\t\tmem_cgroup_start_move(memcg);\n\t\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\t\tfor (zid = 0; !ret && zid < MAX_NR_ZONES; zid++) {\n\t\t\t\tenum lru_list l;\n\t\t\t\tfor_each_lru(l) {\n\t\t\t\t\tret = mem_cgroup_force_empty_list(memcg,\n\t\t\t\t\t\t\tnode, zid, l);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tmem_cgroup_end_move(memcg);\n\t\tmemcg_oom_recover(memcg);\n\t\t/* it seems parent cgroup doesn't have enough mem */\n\t\tif (ret == -ENOMEM)\n\t\t\tgoto try_to_free;\n\t\tcond_resched();\n\t/* \"ret\" should also be checked to ensure all lists are empty. */\n\t} while (memcg->res.usage > 0 || ret);\nout:\n\tcss_put(&memcg->css);\n\treturn ret;\n\ntry_to_free:\n\t/* returns EBUSY if there is a task or if we come here twice. */\n\tif (cgroup_task_count(cgrp) || !list_empty(&cgrp->children) || shrink) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\t/* we call try-to-free pages for make this cgroup empty */\n\tlru_add_drain_all();\n\t/* try to free all pages in this cgroup */\n\tshrink = 1;\n\twhile (nr_retries && memcg->res.usage > 0) {\n\t\tint progress;\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tprogress = try_to_free_mem_cgroup_pages(memcg, GFP_KERNEL,\n\t\t\t\t\t\tfalse);\n\t\tif (!progress) {\n\t\t\tnr_retries--;\n\t\t\t/* maybe some writeback is necessary */\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t}\n\tlru_add_drain();\n\t/* try move_account...there may be some *locked* pages. */\n\tgoto move_account;\n}\n\nint mem_cgroup_force_empty_write(struct cgroup *cont, unsigned int event)\n{\n\treturn mem_cgroup_force_empty(mem_cgroup_from_cont(cont), true);\n}\n\n\nstatic u64 mem_cgroup_hierarchy_read(struct cgroup *cont, struct cftype *cft)\n{\n\treturn mem_cgroup_from_cont(cont)->use_hierarchy;\n}\n\nstatic int mem_cgroup_hierarchy_write(struct cgroup *cont, struct cftype *cft,\n\t\t\t\t\tu64 val)\n{\n\tint retval = 0;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\tstruct cgroup *parent = cont->parent;\n\tstruct mem_cgroup *parent_memcg = NULL;\n\n\tif (parent)\n\t\tparent_memcg = mem_cgroup_from_cont(parent);\n\n\tcgroup_lock();\n\t/*\n\t * If parent's use_hierarchy is set, we can't make any modifications\n\t * in the child subtrees. If it is unset, then the change can\n\t * occur, provided the current cgroup has no children.\n\t *\n\t * For the root cgroup, parent_mem is NULL, we allow value to be\n\t * set if there are no children.\n\t */\n\tif ((!parent_memcg || !parent_memcg->use_hierarchy) &&\n\t\t\t\t(val == 1 || val == 0)) {\n\t\tif (list_empty(&cont->children))\n\t\t\tmemcg->use_hierarchy = val;\n\t\telse\n\t\t\tretval = -EBUSY;\n\t} else\n\t\tretval = -EINVAL;\n\tcgroup_unlock();\n\n\treturn retval;\n}\n\n\nstatic unsigned long mem_cgroup_recursive_stat(struct mem_cgroup *memcg,\n\t\t\t\t\t       enum mem_cgroup_stat_index idx)\n{\n\tstruct mem_cgroup *iter;\n\tlong val = 0;\n\n\t/* Per-cpu values can be negative, use a signed accumulator */\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tval += mem_cgroup_read_stat(iter, idx);\n\n\tif (val < 0) /* race ? */\n\t\tval = 0;\n\treturn val;\n}\n\nstatic inline u64 mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)\n{\n\tu64 val;\n\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tif (!swap)\n\t\t\treturn res_counter_read_u64(&memcg->res, RES_USAGE);\n\t\telse\n\t\t\treturn res_counter_read_u64(&memcg->memsw, RES_USAGE);\n\t}\n\n\tval = mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_CACHE);\n\tval += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_RSS);\n\n\tif (swap)\n\t\tval += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_SWAPOUT);\n\n\treturn val << PAGE_SHIFT;\n}\n\nstatic u64 mem_cgroup_read(struct cgroup *cont, struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\tu64 val;\n\tint type, name;\n\n\ttype = MEMFILE_TYPE(cft->private);\n\tname = MEMFILE_ATTR(cft->private);\n\tswitch (type) {\n\tcase _MEM:\n\t\tif (name == RES_USAGE)\n\t\t\tval = mem_cgroup_usage(memcg, false);\n\t\telse\n\t\t\tval = res_counter_read_u64(&memcg->res, name);\n\t\tbreak;\n\tcase _MEMSWAP:\n\t\tif (name == RES_USAGE)\n\t\t\tval = mem_cgroup_usage(memcg, true);\n\t\telse\n\t\t\tval = res_counter_read_u64(&memcg->memsw, name);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\treturn val;\n}\n/*\n * The user of this function is...\n * RES_LIMIT.\n */\nstatic int mem_cgroup_write(struct cgroup *cont, struct cftype *cft,\n\t\t\t    const char *buffer)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\tint type, name;\n\tunsigned long long val;\n\tint ret;\n\n\ttype = MEMFILE_TYPE(cft->private);\n\tname = MEMFILE_ATTR(cft->private);\n\tswitch (name) {\n\tcase RES_LIMIT:\n\t\tif (mem_cgroup_is_root(memcg)) { /* Can't set limit on root */\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* This function does all necessary parse...reuse it */\n\t\tret = res_counter_memparse_write_strategy(buffer, &val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (type == _MEM)\n\t\t\tret = mem_cgroup_resize_limit(memcg, val);\n\t\telse\n\t\t\tret = mem_cgroup_resize_memsw_limit(memcg, val);\n\t\tbreak;\n\tcase RES_SOFT_LIMIT:\n\t\tret = res_counter_memparse_write_strategy(buffer, &val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/*\n\t\t * For memsw, soft limits are hard to implement in terms\n\t\t * of semantics, for now, we support soft limits for\n\t\t * control without swap\n\t\t */\n\t\tif (type == _MEM)\n\t\t\tret = res_counter_set_soft_limit(&memcg->res, val);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL; /* should be BUG() ? */\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void memcg_get_hierarchical_limit(struct mem_cgroup *memcg,\n\t\tunsigned long long *mem_limit, unsigned long long *memsw_limit)\n{\n\tstruct cgroup *cgroup;\n\tunsigned long long min_limit, min_memsw_limit, tmp;\n\n\tmin_limit = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\tmin_memsw_limit = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\tcgroup = memcg->css.cgroup;\n\tif (!memcg->use_hierarchy)\n\t\tgoto out;\n\n\twhile (cgroup->parent) {\n\t\tcgroup = cgroup->parent;\n\t\tmemcg = mem_cgroup_from_cont(cgroup);\n\t\tif (!memcg->use_hierarchy)\n\t\t\tbreak;\n\t\ttmp = res_counter_read_u64(&memcg->res, RES_LIMIT);\n\t\tmin_limit = min(min_limit, tmp);\n\t\ttmp = res_counter_read_u64(&memcg->memsw, RES_LIMIT);\n\t\tmin_memsw_limit = min(min_memsw_limit, tmp);\n\t}\nout:\n\t*mem_limit = min_limit;\n\t*memsw_limit = min_memsw_limit;\n\treturn;\n}\n\nstatic int mem_cgroup_reset(struct cgroup *cont, unsigned int event)\n{\n\tstruct mem_cgroup *memcg;\n\tint type, name;\n\n\tmemcg = mem_cgroup_from_cont(cont);\n\ttype = MEMFILE_TYPE(event);\n\tname = MEMFILE_ATTR(event);\n\tswitch (name) {\n\tcase RES_MAX_USAGE:\n\t\tif (type == _MEM)\n\t\t\tres_counter_reset_max(&memcg->res);\n\t\telse\n\t\t\tres_counter_reset_max(&memcg->memsw);\n\t\tbreak;\n\tcase RES_FAILCNT:\n\t\tif (type == _MEM)\n\t\t\tres_counter_reset_failcnt(&memcg->res);\n\t\telse\n\t\t\tres_counter_reset_failcnt(&memcg->memsw);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 mem_cgroup_move_charge_read(struct cgroup *cgrp,\n\t\t\t\t\tstruct cftype *cft)\n{\n\treturn mem_cgroup_from_cont(cgrp)->move_charge_at_immigrate;\n}\n\n#ifdef CONFIG_MMU\nstatic int mem_cgroup_move_charge_write(struct cgroup *cgrp,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\n\tif (val >= (1 << NR_MOVE_TYPE))\n\t\treturn -EINVAL;\n\t/*\n\t * We check this value several times in both in can_attach() and\n\t * attach(), so we need cgroup lock to prevent this value from being\n\t * inconsistent.\n\t */\n\tcgroup_lock();\n\tmemcg->move_charge_at_immigrate = val;\n\tcgroup_unlock();\n\n\treturn 0;\n}\n#else\nstatic int mem_cgroup_move_charge_write(struct cgroup *cgrp,\n\t\t\t\t\tstruct cftype *cft, u64 val)\n{\n\treturn -ENOSYS;\n}\n#endif\n\n\n/* For read statistics */\nenum {\n\tMCS_CACHE,\n\tMCS_RSS,\n\tMCS_FILE_MAPPED,\n\tMCS_PGPGIN,\n\tMCS_PGPGOUT,\n\tMCS_SWAP,\n\tMCS_PGFAULT,\n\tMCS_PGMAJFAULT,\n\tMCS_INACTIVE_ANON,\n\tMCS_ACTIVE_ANON,\n\tMCS_INACTIVE_FILE,\n\tMCS_ACTIVE_FILE,\n\tMCS_UNEVICTABLE,\n\tNR_MCS_STAT,\n};\n\nstruct mcs_total_stat {\n\ts64 stat[NR_MCS_STAT];\n};\n\nstruct {\n\tchar *local_name;\n\tchar *total_name;\n} memcg_stat_strings[NR_MCS_STAT] = {\n\t{\"cache\", \"total_cache\"},\n\t{\"rss\", \"total_rss\"},\n\t{\"mapped_file\", \"total_mapped_file\"},\n\t{\"pgpgin\", \"total_pgpgin\"},\n\t{\"pgpgout\", \"total_pgpgout\"},\n\t{\"swap\", \"total_swap\"},\n\t{\"pgfault\", \"total_pgfault\"},\n\t{\"pgmajfault\", \"total_pgmajfault\"},\n\t{\"inactive_anon\", \"total_inactive_anon\"},\n\t{\"active_anon\", \"total_active_anon\"},\n\t{\"inactive_file\", \"total_inactive_file\"},\n\t{\"active_file\", \"total_active_file\"},\n\t{\"unevictable\", \"total_unevictable\"}\n};\n\n\nstatic void\nmem_cgroup_get_local_stat(struct mem_cgroup *memcg, struct mcs_total_stat *s)\n{\n\ts64 val;\n\n\t/* per cpu stat */\n\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_CACHE);\n\ts->stat[MCS_CACHE] += val * PAGE_SIZE;\n\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_RSS);\n\ts->stat[MCS_RSS] += val * PAGE_SIZE;\n\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_FILE_MAPPED);\n\ts->stat[MCS_FILE_MAPPED] += val * PAGE_SIZE;\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGPGIN);\n\ts->stat[MCS_PGPGIN] += val;\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGPGOUT);\n\ts->stat[MCS_PGPGOUT] += val;\n\tif (do_swap_account) {\n\t\tval = mem_cgroup_read_stat(memcg, MEM_CGROUP_STAT_SWAPOUT);\n\t\ts->stat[MCS_SWAP] += val * PAGE_SIZE;\n\t}\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGFAULT);\n\ts->stat[MCS_PGFAULT] += val;\n\tval = mem_cgroup_read_events(memcg, MEM_CGROUP_EVENTS_PGMAJFAULT);\n\ts->stat[MCS_PGMAJFAULT] += val;\n\n\t/* per zone stat */\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_INACTIVE_ANON));\n\ts->stat[MCS_INACTIVE_ANON] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_ACTIVE_ANON));\n\ts->stat[MCS_ACTIVE_ANON] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_INACTIVE_FILE));\n\ts->stat[MCS_INACTIVE_FILE] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_ACTIVE_FILE));\n\ts->stat[MCS_ACTIVE_FILE] += val * PAGE_SIZE;\n\tval = mem_cgroup_nr_lru_pages(memcg, BIT(LRU_UNEVICTABLE));\n\ts->stat[MCS_UNEVICTABLE] += val * PAGE_SIZE;\n}\n\nstatic void\nmem_cgroup_get_total_stat(struct mem_cgroup *memcg, struct mcs_total_stat *s)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_get_local_stat(iter, s);\n}\n\n#ifdef CONFIG_NUMA\nstatic int mem_control_numa_stat_show(struct seq_file *m, void *arg)\n{\n\tint nid;\n\tunsigned long total_nr, file_nr, anon_nr, unevictable_nr;\n\tunsigned long node_nr;\n\tstruct cgroup *cont = m->private;\n\tstruct mem_cgroup *mem_cont = mem_cgroup_from_cont(cont);\n\n\ttotal_nr = mem_cgroup_nr_lru_pages(mem_cont, LRU_ALL);\n\tseq_printf(m, \"total=%lu\", total_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid, LRU_ALL);\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\n\tfile_nr = mem_cgroup_nr_lru_pages(mem_cont, LRU_ALL_FILE);\n\tseq_printf(m, \"file=%lu\", file_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid,\n\t\t\t\tLRU_ALL_FILE);\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\n\tanon_nr = mem_cgroup_nr_lru_pages(mem_cont, LRU_ALL_ANON);\n\tseq_printf(m, \"anon=%lu\", anon_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid,\n\t\t\t\tLRU_ALL_ANON);\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\n\tunevictable_nr = mem_cgroup_nr_lru_pages(mem_cont, BIT(LRU_UNEVICTABLE));\n\tseq_printf(m, \"unevictable=%lu\", unevictable_nr);\n\tfor_each_node_state(nid, N_HIGH_MEMORY) {\n\t\tnode_nr = mem_cgroup_node_nr_lru_pages(mem_cont, nid,\n\t\t\t\tBIT(LRU_UNEVICTABLE));\n\t\tseq_printf(m, \" N%d=%lu\", nid, node_nr);\n\t}\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n#endif /* CONFIG_NUMA */\n\nstatic int mem_control_stat_show(struct cgroup *cont, struct cftype *cft,\n\t\t\t\t struct cgroup_map_cb *cb)\n{\n\tstruct mem_cgroup *mem_cont = mem_cgroup_from_cont(cont);\n\tstruct mcs_total_stat mystat;\n\tint i;\n\n\tmemset(&mystat, 0, sizeof(mystat));\n\tmem_cgroup_get_local_stat(mem_cont, &mystat);\n\n\n\tfor (i = 0; i < NR_MCS_STAT; i++) {\n\t\tif (i == MCS_SWAP && !do_swap_account)\n\t\t\tcontinue;\n\t\tcb->fill(cb, memcg_stat_strings[i].local_name, mystat.stat[i]);\n\t}\n\n\t/* Hierarchical information */\n\t{\n\t\tunsigned long long limit, memsw_limit;\n\t\tmemcg_get_hierarchical_limit(mem_cont, &limit, &memsw_limit);\n\t\tcb->fill(cb, \"hierarchical_memory_limit\", limit);\n\t\tif (do_swap_account)\n\t\t\tcb->fill(cb, \"hierarchical_memsw_limit\", memsw_limit);\n\t}\n\n\tmemset(&mystat, 0, sizeof(mystat));\n\tmem_cgroup_get_total_stat(mem_cont, &mystat);\n\tfor (i = 0; i < NR_MCS_STAT; i++) {\n\t\tif (i == MCS_SWAP && !do_swap_account)\n\t\t\tcontinue;\n\t\tcb->fill(cb, memcg_stat_strings[i].total_name, mystat.stat[i]);\n\t}\n\n#ifdef CONFIG_DEBUG_VM\n\t{\n\t\tint nid, zid;\n\t\tstruct mem_cgroup_per_zone *mz;\n\t\tunsigned long recent_rotated[2] = {0, 0};\n\t\tunsigned long recent_scanned[2] = {0, 0};\n\n\t\tfor_each_online_node(nid)\n\t\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\t\tmz = mem_cgroup_zoneinfo(mem_cont, nid, zid);\n\n\t\t\t\trecent_rotated[0] +=\n\t\t\t\t\tmz->reclaim_stat.recent_rotated[0];\n\t\t\t\trecent_rotated[1] +=\n\t\t\t\t\tmz->reclaim_stat.recent_rotated[1];\n\t\t\t\trecent_scanned[0] +=\n\t\t\t\t\tmz->reclaim_stat.recent_scanned[0];\n\t\t\t\trecent_scanned[1] +=\n\t\t\t\t\tmz->reclaim_stat.recent_scanned[1];\n\t\t\t}\n\t\tcb->fill(cb, \"recent_rotated_anon\", recent_rotated[0]);\n\t\tcb->fill(cb, \"recent_rotated_file\", recent_rotated[1]);\n\t\tcb->fill(cb, \"recent_scanned_anon\", recent_scanned[0]);\n\t\tcb->fill(cb, \"recent_scanned_file\", recent_scanned[1]);\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic u64 mem_cgroup_swappiness_read(struct cgroup *cgrp, struct cftype *cft)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\n\treturn mem_cgroup_swappiness(memcg);\n}\n\nstatic int mem_cgroup_swappiness_write(struct cgroup *cgrp, struct cftype *cft,\n\t\t\t\t       u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup *parent;\n\n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\tif (cgrp->parent == NULL)\n\t\treturn -EINVAL;\n\n\tparent = mem_cgroup_from_cont(cgrp->parent);\n\n\tcgroup_lock();\n\n\t/* If under hierarchy, only empty-root can set this value */\n\tif ((parent->use_hierarchy) ||\n\t    (memcg->use_hierarchy && !list_empty(&cgrp->children))) {\n\t\tcgroup_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tmemcg->swappiness = val;\n\n\tcgroup_unlock();\n\n\treturn 0;\n}\n\nstatic void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)\n{\n\tstruct mem_cgroup_threshold_ary *t;\n\tu64 usage;\n\tint i;\n\n\trcu_read_lock();\n\tif (!swap)\n\t\tt = rcu_dereference(memcg->thresholds.primary);\n\telse\n\t\tt = rcu_dereference(memcg->memsw_thresholds.primary);\n\n\tif (!t)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, swap);\n\n\t/*\n\t * current_threshold points to threshold just below usage.\n\t * If it's not true, a threshold was crossed after last\n\t * call of __mem_cgroup_threshold().\n\t */\n\ti = t->current_threshold;\n\n\t/*\n\t * Iterate backward over array of thresholds starting from\n\t * current_threshold and check if a threshold is crossed.\n\t * If none of thresholds below usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i >= 0 && unlikely(t->entries[i].threshold > usage); i--)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* i = current_threshold + 1 */\n\ti++;\n\n\t/*\n\t * Iterate forward over array of thresholds starting from\n\t * current_threshold+1 and check if a threshold is crossed.\n\t * If none of thresholds above usage is crossed, we read\n\t * only one element of the array here.\n\t */\n\tfor (; i < t->size && unlikely(t->entries[i].threshold <= usage); i++)\n\t\teventfd_signal(t->entries[i].eventfd, 1);\n\n\t/* Update current_threshold */\n\tt->current_threshold = i - 1;\nunlock:\n\trcu_read_unlock();\n}\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg)\n{\n\twhile (memcg) {\n\t\t__mem_cgroup_threshold(memcg, false);\n\t\tif (do_swap_account)\n\t\t\t__mem_cgroup_threshold(memcg, true);\n\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t}\n}\n\nstatic int compare_thresholds(const void *a, const void *b)\n{\n\tconst struct mem_cgroup_threshold *_a = a;\n\tconst struct mem_cgroup_threshold *_b = b;\n\n\treturn _a->threshold - _b->threshold;\n}\n\nstatic int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_eventfd_list *ev;\n\n\tlist_for_each_entry(ev, &memcg->oom_notify, list)\n\t\teventfd_signal(ev->eventfd, 1);\n\treturn 0;\n}\n\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\tmem_cgroup_oom_notify_cb(iter);\n}\n\nstatic int mem_cgroup_usage_register_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 threshold, usage;\n\tint i, size, ret;\n\n\tret = res_counter_memparse_write_strategy(args, &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold < usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}\n\nstatic void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\n\t/*\n\t * Something went wrong if we trying to unregister a threshold\n\t * if we don't have thresholds\n\t */\n\tBUG_ON(!thresholds);\n\n\tif (!thresholds->primary)\n\t\tgoto unlock;\n\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\n\t/* Check if a threshold crossed before removing */\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\t/* Calculate new number of threshold */\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\n\tnew = thresholds->spare;\n\n\t/* Set thresholds array to NULL if we don't have thresholds */\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\n\tnew->size = size;\n\n\t/* Copy thresholds and find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used\n\t\t\t * until rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\n\nswap_buffers:\n\t/* Swap primary and spare array */\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n}\n\nstatic int mem_cgroup_oom_register_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_eventfd_list *event;\n\tint type = MEMFILE_TYPE(cft->private);\n\n\tBUG_ON(type != _OOM_TYPE);\n\tevent = kmalloc(sizeof(*event),\tGFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&memcg_oom_lock);\n\n\tevent->eventfd = eventfd;\n\tlist_add(&event->list, &memcg->oom_notify);\n\n\t/* already in OOM ? */\n\tif (atomic_read(&memcg->under_oom))\n\t\teventfd_signal(eventfd, 1);\n\tspin_unlock(&memcg_oom_lock);\n\n\treturn 0;\n}\n\nstatic void mem_cgroup_oom_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_eventfd_list *ev, *tmp;\n\tint type = MEMFILE_TYPE(cft->private);\n\n\tBUG_ON(type != _OOM_TYPE);\n\n\tspin_lock(&memcg_oom_lock);\n\n\tlist_for_each_entry_safe(ev, tmp, &memcg->oom_notify, list) {\n\t\tif (ev->eventfd == eventfd) {\n\t\t\tlist_del(&ev->list);\n\t\t\tkfree(ev);\n\t\t}\n\t}\n\n\tspin_unlock(&memcg_oom_lock);\n}\n\nstatic int mem_cgroup_oom_control_read(struct cgroup *cgrp,\n\tstruct cftype *cft,  struct cgroup_map_cb *cb)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\n\tcb->fill(cb, \"oom_kill_disable\", memcg->oom_kill_disable);\n\n\tif (atomic_read(&memcg->under_oom))\n\t\tcb->fill(cb, \"under_oom\", 1);\n\telse\n\t\tcb->fill(cb, \"under_oom\", 0);\n\treturn 0;\n}\n\nstatic int mem_cgroup_oom_control_write(struct cgroup *cgrp,\n\tstruct cftype *cft, u64 val)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup *parent;\n\n\t/* cannot set to root cgroup and only 0 and 1 are allowed */\n\tif (!cgrp->parent || !((val == 0) || (val == 1)))\n\t\treturn -EINVAL;\n\n\tparent = mem_cgroup_from_cont(cgrp->parent);\n\n\tcgroup_lock();\n\t/* oom-kill-disable is a flag for subhierarchy. */\n\tif ((parent->use_hierarchy) ||\n\t    (memcg->use_hierarchy && !list_empty(&cgrp->children))) {\n\t\tcgroup_unlock();\n\t\treturn -EINVAL;\n\t}\n\tmemcg->oom_kill_disable = val;\n\tif (!val)\n\t\tmemcg_oom_recover(memcg);\n\tcgroup_unlock();\n\treturn 0;\n}\n\n#ifdef CONFIG_NUMA\nstatic const struct file_operations mem_control_numa_stat_file_operations = {\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int mem_control_numa_stat_open(struct inode *unused, struct file *file)\n{\n\tstruct cgroup *cont = file->f_dentry->d_parent->d_fsdata;\n\n\tfile->f_op = &mem_control_numa_stat_file_operations;\n\treturn single_open(file, mem_control_numa_stat_show, cont);\n}\n#endif /* CONFIG_NUMA */\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM\nstatic int register_kmem_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\t/*\n\t * Part of this would be better living in a separate allocation\n\t * function, leaving us with just the cgroup tree population work.\n\t * We, however, depend on state such as network's proto_list that\n\t * is only initialized after cgroup creation. I found the less\n\t * cumbersome way to deal with it to defer it all to populate time\n\t */\n\treturn mem_cgroup_sockets_init(cont, ss);\n};\n\nstatic void kmem_cgroup_destroy(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n\tmem_cgroup_sockets_destroy(cont, ss);\n}\n#else\nstatic int register_kmem_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\treturn 0;\n}\n\nstatic void kmem_cgroup_destroy(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n}\n#endif\n\nstatic struct cftype mem_cgroup_files[] = {\n\t{\n\t\t.name = \"usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_USAGE),\n\t\t.read_u64 = mem_cgroup_read,\n\t\t.register_event = mem_cgroup_usage_register_event,\n\t\t.unregister_event = mem_cgroup_usage_unregister_event,\n\t},\n\t{\n\t\t.name = \"max_usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_MAX_USAGE),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"limit_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_LIMIT),\n\t\t.write_string = mem_cgroup_write,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"soft_limit_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_SOFT_LIMIT),\n\t\t.write_string = mem_cgroup_write,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"failcnt\",\n\t\t.private = MEMFILE_PRIVATE(_MEM, RES_FAILCNT),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"stat\",\n\t\t.read_map = mem_control_stat_show,\n\t},\n\t{\n\t\t.name = \"force_empty\",\n\t\t.trigger = mem_cgroup_force_empty_write,\n\t},\n\t{\n\t\t.name = \"use_hierarchy\",\n\t\t.write_u64 = mem_cgroup_hierarchy_write,\n\t\t.read_u64 = mem_cgroup_hierarchy_read,\n\t},\n\t{\n\t\t.name = \"swappiness\",\n\t\t.read_u64 = mem_cgroup_swappiness_read,\n\t\t.write_u64 = mem_cgroup_swappiness_write,\n\t},\n\t{\n\t\t.name = \"move_charge_at_immigrate\",\n\t\t.read_u64 = mem_cgroup_move_charge_read,\n\t\t.write_u64 = mem_cgroup_move_charge_write,\n\t},\n\t{\n\t\t.name = \"oom_control\",\n\t\t.read_map = mem_cgroup_oom_control_read,\n\t\t.write_u64 = mem_cgroup_oom_control_write,\n\t\t.register_event = mem_cgroup_oom_register_event,\n\t\t.unregister_event = mem_cgroup_oom_unregister_event,\n\t\t.private = MEMFILE_PRIVATE(_OOM_TYPE, OOM_CONTROL),\n\t},\n#ifdef CONFIG_NUMA\n\t{\n\t\t.name = \"numa_stat\",\n\t\t.open = mem_control_numa_stat_open,\n\t\t.mode = S_IRUGO,\n\t},\n#endif\n};\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\nstatic struct cftype memsw_cgroup_files[] = {\n\t{\n\t\t.name = \"memsw.usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_USAGE),\n\t\t.read_u64 = mem_cgroup_read,\n\t\t.register_event = mem_cgroup_usage_register_event,\n\t\t.unregister_event = mem_cgroup_usage_unregister_event,\n\t},\n\t{\n\t\t.name = \"memsw.max_usage_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_MAX_USAGE),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"memsw.limit_in_bytes\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_LIMIT),\n\t\t.write_string = mem_cgroup_write,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n\t{\n\t\t.name = \"memsw.failcnt\",\n\t\t.private = MEMFILE_PRIVATE(_MEMSWAP, RES_FAILCNT),\n\t\t.trigger = mem_cgroup_reset,\n\t\t.read_u64 = mem_cgroup_read,\n\t},\n};\n\nstatic int register_memsw_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\tif (!do_swap_account)\n\t\treturn 0;\n\treturn cgroup_add_files(cont, ss, memsw_cgroup_files,\n\t\t\t\tARRAY_SIZE(memsw_cgroup_files));\n};\n#else\nstatic int register_memsw_files(struct cgroup *cont, struct cgroup_subsys *ss)\n{\n\treturn 0;\n}\n#endif\n\nstatic int alloc_mem_cgroup_per_zone_info(struct mem_cgroup *memcg, int node)\n{\n\tstruct mem_cgroup_per_node *pn;\n\tstruct mem_cgroup_per_zone *mz;\n\tenum lru_list l;\n\tint zone, tmp = node;\n\t/*\n\t * This routine is called against possible nodes.\n\t * But it's BUG to call kmalloc() against offline node.\n\t *\n\t * TODO: this routine can waste much memory for nodes which will\n\t *       never be onlined. It's better to use memory hotplug callback\n\t *       function.\n\t */\n\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\ttmp = -1;\n\tpn = kzalloc_node(sizeof(*pn), GFP_KERNEL, tmp);\n\tif (!pn)\n\t\treturn 1;\n\n\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\tmz = &pn->zoneinfo[zone];\n\t\tfor_each_lru(l)\n\t\t\tINIT_LIST_HEAD(&mz->lruvec.lists[l]);\n\t\tmz->usage_in_excess = 0;\n\t\tmz->on_tree = false;\n\t\tmz->mem = memcg;\n\t}\n\tmemcg->info.nodeinfo[node] = pn;\n\treturn 0;\n}\n\nstatic void free_mem_cgroup_per_zone_info(struct mem_cgroup *memcg, int node)\n{\n\tkfree(memcg->info.nodeinfo[node]);\n}\n\nstatic struct mem_cgroup *mem_cgroup_alloc(void)\n{\n\tstruct mem_cgroup *mem;\n\tint size = sizeof(struct mem_cgroup);\n\n\t/* Can be very big if MAX_NUMNODES is very big */\n\tif (size < PAGE_SIZE)\n\t\tmem = kzalloc(size, GFP_KERNEL);\n\telse\n\t\tmem = vzalloc(size);\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tmem->stat = alloc_percpu(struct mem_cgroup_stat_cpu);\n\tif (!mem->stat)\n\t\tgoto out_free;\n\tspin_lock_init(&mem->pcp_counter_lock);\n\treturn mem;\n\nout_free:\n\tif (size < PAGE_SIZE)\n\t\tkfree(mem);\n\telse\n\t\tvfree(mem);\n\treturn NULL;\n}\n\n/*\n * At destroying mem_cgroup, references from swap_cgroup can remain.\n * (scanning all at force_empty is too costly...)\n *\n * Instead of clearing all references at force_empty, we remember\n * the number of reference from swap_cgroup and free mem_cgroup when\n * it goes down to 0.\n *\n * Removal of cgroup itself succeeds regardless of refs from swap.\n */\n\nstatic void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_remove_from_trees(memcg);\n\tfree_css_id(&mem_cgroup_subsys, &memcg->css);\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_zone_info(memcg, node);\n\n\tfree_percpu(memcg->stat);\n\tif (sizeof(struct mem_cgroup) < PAGE_SIZE)\n\t\tkfree(memcg);\n\telse\n\t\tvfree(memcg);\n}\n\nstatic void mem_cgroup_get(struct mem_cgroup *memcg)\n{\n\tatomic_inc(&memcg->refcnt);\n}\n\nstatic void __mem_cgroup_put(struct mem_cgroup *memcg, int count)\n{\n\tif (atomic_sub_and_test(count, &memcg->refcnt)) {\n\t\tstruct mem_cgroup *parent = parent_mem_cgroup(memcg);\n\t\t__mem_cgroup_free(memcg);\n\t\tif (parent)\n\t\t\tmem_cgroup_put(parent);\n\t}\n}\n\nstatic void mem_cgroup_put(struct mem_cgroup *memcg)\n{\n\t__mem_cgroup_put(memcg, 1);\n}\n\n/*\n * Returns the parent mem_cgroup in memcgroup hierarchy with hierarchy enabled.\n */\nstruct mem_cgroup *parent_mem_cgroup(struct mem_cgroup *memcg)\n{\n\tif (!memcg->res.parent)\n\t\treturn NULL;\n\treturn mem_cgroup_from_res_counter(memcg->res.parent, res);\n}\nEXPORT_SYMBOL(parent_mem_cgroup);\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\nstatic void __init enable_swap_cgroup(void)\n{\n\tif (!mem_cgroup_disabled() && really_do_swap_account)\n\t\tdo_swap_account = 1;\n}\n#else\nstatic void __init enable_swap_cgroup(void)\n{\n}\n#endif\n\nstatic int mem_cgroup_soft_limit_tree_init(void)\n{\n\tstruct mem_cgroup_tree_per_node *rtpn;\n\tstruct mem_cgroup_tree_per_zone *rtpz;\n\tint tmp, node, zone;\n\n\tfor_each_node(node) {\n\t\ttmp = node;\n\t\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\t\ttmp = -1;\n\t\trtpn = kzalloc_node(sizeof(*rtpn), GFP_KERNEL, tmp);\n\t\tif (!rtpn)\n\t\t\tgoto err_cleanup;\n\n\t\tsoft_limit_tree.rb_tree_per_node[node] = rtpn;\n\n\t\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\t\trtpz = &rtpn->rb_tree_per_zone[zone];\n\t\t\trtpz->rb_root = RB_ROOT;\n\t\t\tspin_lock_init(&rtpz->lock);\n\t\t}\n\t}\n\treturn 0;\n\nerr_cleanup:\n\tfor_each_node(node) {\n\t\tif (!soft_limit_tree.rb_tree_per_node[node])\n\t\t\tbreak;\n\t\tkfree(soft_limit_tree.rb_tree_per_node[node]);\n\t\tsoft_limit_tree.rb_tree_per_node[node] = NULL;\n\t}\n\treturn 1;\n\n}\n\nstatic struct cgroup_subsys_state * __ref\nmem_cgroup_create(struct cgroup_subsys *ss, struct cgroup *cont)\n{\n\tstruct mem_cgroup *memcg, *parent;\n\tlong error = -ENOMEM;\n\tint node;\n\n\tmemcg = mem_cgroup_alloc();\n\tif (!memcg)\n\t\treturn ERR_PTR(error);\n\n\tfor_each_node(node)\n\t\tif (alloc_mem_cgroup_per_zone_info(memcg, node))\n\t\t\tgoto free_out;\n\n\t/* root ? */\n\tif (cont->parent == NULL) {\n\t\tint cpu;\n\t\tenable_swap_cgroup();\n\t\tparent = NULL;\n\t\tif (mem_cgroup_soft_limit_tree_init())\n\t\t\tgoto free_out;\n\t\troot_mem_cgroup = memcg;\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct memcg_stock_pcp *stock =\n\t\t\t\t\t\t&per_cpu(memcg_stock, cpu);\n\t\t\tINIT_WORK(&stock->work, drain_local_stock);\n\t\t}\n\t\thotcpu_notifier(memcg_cpu_hotplug_callback, 0);\n\t} else {\n\t\tparent = mem_cgroup_from_cont(cont->parent);\n\t\tmemcg->use_hierarchy = parent->use_hierarchy;\n\t\tmemcg->oom_kill_disable = parent->oom_kill_disable;\n\t}\n\n\tif (parent && parent->use_hierarchy) {\n\t\tres_counter_init(&memcg->res, &parent->res);\n\t\tres_counter_init(&memcg->memsw, &parent->memsw);\n\t\t/*\n\t\t * We increment refcnt of the parent to ensure that we can\n\t\t * safely access it on res_counter_charge/uncharge.\n\t\t * This refcnt will be decremented when freeing this\n\t\t * mem_cgroup(see mem_cgroup_put).\n\t\t */\n\t\tmem_cgroup_get(parent);\n\t} else {\n\t\tres_counter_init(&memcg->res, NULL);\n\t\tres_counter_init(&memcg->memsw, NULL);\n\t}\n\tmemcg->last_scanned_node = MAX_NUMNODES;\n\tINIT_LIST_HEAD(&memcg->oom_notify);\n\n\tif (parent)\n\t\tmemcg->swappiness = mem_cgroup_swappiness(parent);\n\tatomic_set(&memcg->refcnt, 1);\n\tmemcg->move_charge_at_immigrate = 0;\n\tmutex_init(&memcg->thresholds_lock);\n\treturn &memcg->css;\nfree_out:\n\t__mem_cgroup_free(memcg);\n\treturn ERR_PTR(error);\n}\n\nstatic int mem_cgroup_pre_destroy(struct cgroup_subsys *ss,\n\t\t\t\t\tstruct cgroup *cont)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\n\treturn mem_cgroup_force_empty(memcg, false);\n}\n\nstatic void mem_cgroup_destroy(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cont);\n\n\tkmem_cgroup_destroy(ss, cont);\n\n\tmem_cgroup_put(memcg);\n}\n\nstatic int mem_cgroup_populate(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont)\n{\n\tint ret;\n\n\tret = cgroup_add_files(cont, ss, mem_cgroup_files,\n\t\t\t\tARRAY_SIZE(mem_cgroup_files));\n\n\tif (!ret)\n\t\tret = register_memsw_files(cont, ss);\n\n\tif (!ret)\n\t\tret = register_kmem_files(cont, ss);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_MMU\n/* Handlers for move charge at task migration. */\n#define PRECHARGE_COUNT_AT_ONCE\t256\nstatic int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret = 0;\n\tint batch_count = PRECHARGE_COUNT_AT_ONCE;\n\tstruct mem_cgroup *memcg = mc.to;\n\n\tif (mem_cgroup_is_root(memcg)) {\n\t\tmc.precharge += count;\n\t\t/* we don't need css_get for root */\n\t\treturn ret;\n\t}\n\t/* try to charge at once */\n\tif (count > 1) {\n\t\tstruct res_counter *dummy;\n\t\t/*\n\t\t * \"memcg\" cannot be under rmdir() because we've already checked\n\t\t * by cgroup_lock_live_cgroup() that it is not removed and we\n\t\t * are still under the same cgroup_mutex. So we can postpone\n\t\t * css_get().\n\t\t */\n\t\tif (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))\n\t\t\tgoto one_by_one;\n\t\tif (do_swap_account && res_counter_charge(&memcg->memsw,\n\t\t\t\t\t\tPAGE_SIZE * count, &dummy)) {\n\t\t\tres_counter_uncharge(&memcg->res, PAGE_SIZE * count);\n\t\t\tgoto one_by_one;\n\t\t}\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\none_by_one:\n\t/* fall back to one by one charge */\n\twhile (count--) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (!batch_count--) {\n\t\t\tbatch_count = PRECHARGE_COUNT_AT_ONCE;\n\t\t\tcond_resched();\n\t\t}\n\t\tret = __mem_cgroup_try_charge(NULL,\n\t\t\t\t\tGFP_KERNEL, 1, &memcg, false);\n\t\tif (ret)\n\t\t\t/* mem_cgroup_clear_mc() will do uncharge later */\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t}\n\treturn ret;\n}\n\n/**\n * is_target_pte_for_mc - check a pte whether it is valid for move charge\n * @vma: the vma the pte to be checked belongs\n * @addr: the address corresponding to the pte to be checked\n * @ptent: the pte to be checked\n * @target: the pointer the target page or swap ent will be stored(can be NULL)\n *\n * Returns\n *   0(MC_TARGET_NONE): if the pte is not a target for move charge.\n *   1(MC_TARGET_PAGE): if the page corresponding to this pte is a target for\n *     move charge. if @target is not NULL, the page is stored in target->page\n *     with extra refcnt got(Callers should handle it).\n *   2(MC_TARGET_SWAP): if the swap entry corresponding to this pte is a\n *     target for charge migration. if @target is not NULL, the entry is stored\n *     in target->ent.\n *\n * Called with pte lock held.\n */\nunion mc_target {\n\tstruct page\t*page;\n\tswp_entry_t\tent;\n};\n\nenum mc_target_type {\n\tMC_TARGET_NONE,\t/* not used */\n\tMC_TARGET_PAGE,\n\tMC_TARGET_SWAP,\n};\n\nstatic struct page *mc_handle_present_pte(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr, pte_t ptent)\n{\n\tstruct page *page = vm_normal_page(vma, addr, ptent);\n\n\tif (!page || !page_mapped(page))\n\t\treturn NULL;\n\tif (PageAnon(page)) {\n\t\t/* we don't move shared anon */\n\t\tif (!move_anon() || page_mapcount(page) > 2)\n\t\t\treturn NULL;\n\t} else if (!move_file())\n\t\t/* we ignore mapcount for file pages */\n\t\treturn NULL;\n\tif (!get_page_unless_zero(page))\n\t\treturn NULL;\n\n\treturn page;\n}\n\nstatic struct page *mc_handle_swap_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tint usage_count;\n\tstruct page *page = NULL;\n\tswp_entry_t ent = pte_to_swp_entry(ptent);\n\n\tif (!move_anon() || non_swap_entry(ent))\n\t\treturn NULL;\n\tusage_count = mem_cgroup_count_swap_user(ent, &page);\n\tif (usage_count > 1) { /* we don't move shared anon */\n\t\tif (page)\n\t\t\tput_page(page);\n\t\treturn NULL;\n\t}\n\tif (do_swap_account)\n\t\tentry->val = ent.val;\n\n\treturn page;\n}\n\nstatic struct page *mc_handle_file_pte(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, pte_t ptent, swp_entry_t *entry)\n{\n\tstruct page *page = NULL;\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tpgoff_t pgoff;\n\n\tif (!vma->vm_file) /* anonymous vma */\n\t\treturn NULL;\n\tif (!move_file())\n\t\treturn NULL;\n\n\tinode = vma->vm_file->f_path.dentry->d_inode;\n\tmapping = vma->vm_file->f_mapping;\n\tif (pte_none(ptent))\n\t\tpgoff = linear_page_index(vma, addr);\n\telse /* pte_file(ptent) is true */\n\t\tpgoff = pte_to_pgoff(ptent);\n\n\t/* page is moved even if it's not RSS of this task(page-faulted). */\n\tpage = find_get_page(mapping, pgoff);\n\n#ifdef CONFIG_SWAP\n\t/* shmem/tmpfs may report page out on swap: account for that too. */\n\tif (radix_tree_exceptional_entry(page)) {\n\t\tswp_entry_t swap = radix_to_swp_entry(page);\n\t\tif (do_swap_account)\n\t\t\t*entry = swap;\n\t\tpage = find_get_page(&swapper_space, swap.val);\n\t}\n#endif\n\treturn page;\n}\n\nstatic int is_target_pte_for_mc(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t ptent, union mc_target *target)\n{\n\tstruct page *page = NULL;\n\tstruct page_cgroup *pc;\n\tint ret = 0;\n\tswp_entry_t ent = { .val = 0 };\n\n\tif (pte_present(ptent))\n\t\tpage = mc_handle_present_pte(vma, addr, ptent);\n\telse if (is_swap_pte(ptent))\n\t\tpage = mc_handle_swap_pte(vma, addr, ptent, &ent);\n\telse if (pte_none(ptent) || pte_file(ptent))\n\t\tpage = mc_handle_file_pte(vma, addr, ptent, &ent);\n\n\tif (!page && !ent.val)\n\t\treturn 0;\n\tif (page) {\n\t\tpc = lookup_page_cgroup(page);\n\t\t/*\n\t\t * Do only loose check w/o page_cgroup lock.\n\t\t * mem_cgroup_move_account() checks the pc is valid or not under\n\t\t * the lock.\n\t\t */\n\t\tif (PageCgroupUsed(pc) && pc->mem_cgroup == mc.from) {\n\t\t\tret = MC_TARGET_PAGE;\n\t\t\tif (target)\n\t\t\t\ttarget->page = page;\n\t\t}\n\t\tif (!ret || !target)\n\t\t\tput_page(page);\n\t}\n\t/* There is a swap entry and a page doesn't exist or isn't charged */\n\tif (ent.val && !ret &&\n\t\t\tcss_id(&mc.from->css) == lookup_swap_cgroup_id(ent)) {\n\t\tret = MC_TARGET_SWAP;\n\t\tif (target)\n\t\t\ttarget->ent = ent;\n\t}\n\treturn ret;\n}\n\nstatic int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (is_target_pte_for_mc(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}\n\nstatic unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)\n{\n\tunsigned long precharge;\n\tstruct vm_area_struct *vma;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tstruct mm_walk mem_cgroup_count_precharge_walk = {\n\t\t\t.pmd_entry = mem_cgroup_count_precharge_pte_range,\n\t\t\t.mm = mm,\n\t\t\t.private = vma,\n\t\t};\n\t\tif (is_vm_hugetlb_page(vma))\n\t\t\tcontinue;\n\t\twalk_page_range(vma->vm_start, vma->vm_end,\n\t\t\t\t\t&mem_cgroup_count_precharge_walk);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tprecharge = mc.precharge;\n\tmc.precharge = 0;\n\n\treturn precharge;\n}\n\nstatic int mem_cgroup_precharge_mc(struct mm_struct *mm)\n{\n\tunsigned long precharge = mem_cgroup_count_precharge(mm);\n\n\tVM_BUG_ON(mc.moving_task);\n\tmc.moving_task = current;\n\treturn mem_cgroup_do_precharge(precharge);\n}\n\n/* cancels all extra charges on mc.from and mc.to, and wakes up all waiters. */\nstatic void __mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\tstruct mem_cgroup *to = mc.to;\n\n\t/* we must uncharge all the leftover precharges from mc.to */\n\tif (mc.precharge) {\n\t\t__mem_cgroup_cancel_charge(mc.to, mc.precharge);\n\t\tmc.precharge = 0;\n\t}\n\t/*\n\t * we didn't uncharge from mc.from at mem_cgroup_move_account(), so\n\t * we must uncharge here.\n\t */\n\tif (mc.moved_charge) {\n\t\t__mem_cgroup_cancel_charge(mc.from, mc.moved_charge);\n\t\tmc.moved_charge = 0;\n\t}\n\t/* we must fixup refcnts and charges */\n\tif (mc.moved_swap) {\n\t\t/* uncharge swap account from the old cgroup */\n\t\tif (!mem_cgroup_is_root(mc.from))\n\t\t\tres_counter_uncharge(&mc.from->memsw,\n\t\t\t\t\t\tPAGE_SIZE * mc.moved_swap);\n\t\t__mem_cgroup_put(mc.from, mc.moved_swap);\n\n\t\tif (!mem_cgroup_is_root(mc.to)) {\n\t\t\t/*\n\t\t\t * we charged both to->res and to->memsw, so we should\n\t\t\t * uncharge to->res.\n\t\t\t */\n\t\t\tres_counter_uncharge(&mc.to->res,\n\t\t\t\t\t\tPAGE_SIZE * mc.moved_swap);\n\t\t}\n\t\t/* we've already done mem_cgroup_get(mc.to) */\n\t\tmc.moved_swap = 0;\n\t}\n\tmemcg_oom_recover(from);\n\tmemcg_oom_recover(to);\n\twake_up_all(&mc.waitq);\n}\n\nstatic void mem_cgroup_clear_mc(void)\n{\n\tstruct mem_cgroup *from = mc.from;\n\n\t/*\n\t * we must clear moving_task before waking up waiters at the end of\n\t * task migration.\n\t */\n\tmc.moving_task = NULL;\n\t__mem_cgroup_clear_mc();\n\tspin_lock(&mc.lock);\n\tmc.from = NULL;\n\tmc.to = NULL;\n\tspin_unlock(&mc.lock);\n\tmem_cgroup_end_move(from);\n}\n\nstatic int mem_cgroup_can_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\tstruct task_struct *p = cgroup_taskset_first(tset);\n\tint ret = 0;\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgroup);\n\n\tif (memcg->move_charge_at_immigrate) {\n\t\tstruct mm_struct *mm;\n\t\tstruct mem_cgroup *from = mem_cgroup_from_task(p);\n\n\t\tVM_BUG_ON(from == memcg);\n\n\t\tmm = get_task_mm(p);\n\t\tif (!mm)\n\t\t\treturn 0;\n\t\t/* We move charges only when we move a owner of the mm */\n\t\tif (mm->owner == p) {\n\t\t\tVM_BUG_ON(mc.from);\n\t\t\tVM_BUG_ON(mc.to);\n\t\t\tVM_BUG_ON(mc.precharge);\n\t\t\tVM_BUG_ON(mc.moved_charge);\n\t\t\tVM_BUG_ON(mc.moved_swap);\n\t\t\tmem_cgroup_start_move(from);\n\t\t\tspin_lock(&mc.lock);\n\t\t\tmc.from = from;\n\t\t\tmc.to = memcg;\n\t\t\tspin_unlock(&mc.lock);\n\t\t\t/* We set mc.moving_task later */\n\n\t\t\tret = mem_cgroup_precharge_mc(mm);\n\t\t\tif (ret)\n\t\t\t\tmem_cgroup_clear_mc();\n\t\t}\n\t\tmmput(mm);\n\t}\n\treturn ret;\n}\n\nstatic void mem_cgroup_cancel_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\tmem_cgroup_clear_mc();\n}\n\nstatic int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tunion mc_target target;\n\t\tint type;\n\t\tstruct page *page;\n\t\tstruct page_cgroup *pc;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\ttype = is_target_pte_for_mc(vma, addr, ptent, &target);\n\t\tswitch (type) {\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\tif (isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tpc = lookup_page_cgroup(page);\n\t\t\tif (!mem_cgroup_move_account(page, 1, pc,\n\t\t\t\t\t\t     mc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tputback_lru_page(page);\nput:\t\t\t/* is_target_pte_for_mc() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent,\n\t\t\t\t\t\tmc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}\n\nstatic void mem_cgroup_move_charge(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tlru_add_drain_all();\nretry:\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem))) {\n\t\t/*\n\t\t * Someone who are holding the mmap_sem might be waiting in\n\t\t * waitq. So we cancel all extra charges, wake up all waiters,\n\t\t * and retry. Because we cancel precharges, we might not be able\n\t\t * to move enough charges, but moving charge is a best-effort\n\t\t * feature anyway, so it wouldn't be a big problem.\n\t\t */\n\t\t__mem_cgroup_clear_mc();\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tint ret;\n\t\tstruct mm_walk mem_cgroup_move_charge_walk = {\n\t\t\t.pmd_entry = mem_cgroup_move_charge_pte_range,\n\t\t\t.mm = mm,\n\t\t\t.private = vma,\n\t\t};\n\t\tif (is_vm_hugetlb_page(vma))\n\t\t\tcontinue;\n\t\tret = walk_page_range(vma->vm_start, vma->vm_end,\n\t\t\t\t\t\t&mem_cgroup_move_charge_walk);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * means we have consumed all precharges and failed in\n\t\t\t * doing additional charge. Just abandon here.\n\t\t\t */\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n}\n\nstatic void mem_cgroup_move_task(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\tstruct task_struct *p = cgroup_taskset_first(tset);\n\tstruct mm_struct *mm = get_task_mm(p);\n\n\tif (mm) {\n\t\tif (mc.to)\n\t\t\tmem_cgroup_move_charge(mm);\n\t\tput_swap_token(mm);\n\t\tmmput(mm);\n\t}\n\tif (mc.to)\n\t\tmem_cgroup_clear_mc();\n}\n#else\t/* !CONFIG_MMU */\nstatic int mem_cgroup_can_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n\treturn 0;\n}\nstatic void mem_cgroup_cancel_attach(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cgroup,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n}\nstatic void mem_cgroup_move_task(struct cgroup_subsys *ss,\n\t\t\t\tstruct cgroup *cont,\n\t\t\t\tstruct cgroup_taskset *tset)\n{\n}\n#endif\n\nstruct cgroup_subsys mem_cgroup_subsys = {\n\t.name = \"memory\",\n\t.subsys_id = mem_cgroup_subsys_id,\n\t.create = mem_cgroup_create,\n\t.pre_destroy = mem_cgroup_pre_destroy,\n\t.destroy = mem_cgroup_destroy,\n\t.populate = mem_cgroup_populate,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.attach = mem_cgroup_move_task,\n\t.early_init = 0,\n\t.use_id = 1,\n};\n\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP\nstatic int __init enable_swap_account(char *s)\n{\n\t/* consider enabled if no parameter or 1 is given */\n\tif (!strcmp(s, \"1\"))\n\t\treally_do_swap_account = 1;\n\telse if (!strcmp(s, \"0\"))\n\t\treally_do_swap_account = 0;\n\treturn 1;\n}\n__setup(\"swapaccount=\", enable_swap_account);\n\n#endif\n"], "filenames": ["mm/memcontrol.c"], "buggy_code_start_loc": [4416], "buggy_code_end_loc": [4466], "fixing_code_start_loc": [4417], "fixing_code_end_loc": [4469], "type": "CWE-476", "message": "The mem_cgroup_usage_unregister_event function in mm/memcontrol.c in the Linux kernel before 3.2.10 does not properly handle multiple events that are attached to the same eventfd, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by registering memory threshold events.", "other": {"cve": {"id": "CVE-2012-1146", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:37.397", "lastModified": "2023-02-13T04:33:06.237", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mem_cgroup_usage_unregister_event function in mm/memcontrol.c in the Linux kernel before 3.2.10 does not properly handle multiple events that are attached to the same eventfd, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by registering memory threshold events."}, {"lang": "es", "value": "La funci\u00f3n mem_cgroup_usage_unregister_event en mm/memcontrol.c en el n\u00facleo de Linux anteriores a v3.2.10 no maneja apropiadamente m\u00faltiples eventos que son asociados al mismo eventfd, lo cual permite a usuarios locales causar una denegaci\u00f3n de servicio (puntero nulo sin referencia y ca\u00edda del sistema) o posiblemente tener un impacto no especificado por el registro de eventos en el l\u00edmite de la memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.10", "matchCriteriaId": "3C16692B-B239-405B-998B-114907D6243D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:16:*:*:*:*:*:*:*", "matchCriteriaId": "706C6399-CAD1-46E3-87A2-8DFE2CF497ED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "00720D8C-3FF3-4B1C-B74B-91F01A544399"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "DF49412C-CF41-4251-B1FB-F0E63AC9E019"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:*:vmware:*:*", "matchCriteriaId": "DB4D6749-81A1-41D7-BF4F-1C45A7F49A22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:-:*:*:*", "matchCriteriaId": "1A9E2971-0D30-4A8D-8BF8-99E4E9E4CF86"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=371528caec553785c37f73fa3926ea0de84f986f", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-March/075781.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-04/msg00021.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.2.10", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/07/3", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=800813", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/73711", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/371528caec553785c37f73fa3926ea0de84f986f", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/371528caec553785c37f73fa3926ea0de84f986f"}}