{"buggy_code": ["//go:build linux\n// +build linux\n\n/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage integration\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n)\n\nfunc TestAdditionalGids(t *testing.T) {\n\ttestPodLogDir, err := os.MkdirTemp(\"/tmp\", \"additional-gids\")\n\trequire.NoError(t, err)\n\tdefer os.RemoveAll(testPodLogDir)\n\n\tt.Log(\"Create a sandbox with log directory\")\n\tsb, sbConfig := PodSandboxConfigWithCleanup(t, \"sandbox\", \"additional-gids\",\n\t\tWithPodLogDirectory(testPodLogDir))\n\n\tvar (\n\t\ttestImage     = GetImage(BusyBox)\n\t\tcontainerName = \"test-container\"\n\t)\n\n\tEnsureImageExists(t, testImage)\n\n\tt.Log(\"Create a container to print id\")\n\tcnConfig := ContainerConfig(\n\t\tcontainerName,\n\t\ttestImage,\n\t\tWithCommand(\"id\"),\n\t\tWithLogPath(containerName),\n\t\tWithSupplementalGroups([]int64{1 /*daemon*/, 1234 /*new group*/}),\n\t)\n\tcn, err := runtimeService.CreateContainer(sb, cnConfig, sbConfig)\n\trequire.NoError(t, err)\n\n\tt.Log(\"Start the container\")\n\trequire.NoError(t, runtimeService.StartContainer(cn))\n\n\tt.Log(\"Wait for container to finish running\")\n\trequire.NoError(t, Eventually(func() (bool, error) {\n\t\ts, err := runtimeService.ContainerStatus(cn)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif s.GetState() == runtime.ContainerState_CONTAINER_EXITED {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\t}, time.Second, 30*time.Second))\n\n\tt.Log(\"Search additional groups in container log\")\n\tcontent, err := os.ReadFile(filepath.Join(testPodLogDir, containerName))\n\tassert.NoError(t, err)\n\tassert.Contains(t, string(content), \"groups=1(daemon),10(wheel),1234\")\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage integration\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\tgoruntime \"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/containerd/containerd\"\n\t\"github.com/containerd/containerd/containers\"\n\tcri \"github.com/containerd/containerd/integration/cri-api/pkg/apis\"\n\t\"github.com/containerd/containerd/integration/remote\"\n\tdialer \"github.com/containerd/containerd/integration/util\"\n\tcriconfig \"github.com/containerd/containerd/pkg/cri/config\"\n\t\"github.com/containerd/containerd/pkg/cri/constants\"\n\t\"github.com/containerd/containerd/pkg/cri/server\"\n\t\"github.com/containerd/containerd/pkg/cri/util\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\texec \"golang.org/x/sys/execabs\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n)\n\nconst (\n\ttimeout      = 1 * time.Minute\n\tk8sNamespace = constants.K8sContainerdNamespace\n)\n\nvar (\n\truntimeService     cri.RuntimeService\n\tcontainerdClient   *containerd.Client\n\tcontainerdEndpoint string\n)\n\nvar criEndpoint = flag.String(\"cri-endpoint\", \"unix:///run/containerd/containerd.sock\", \"The endpoint of cri plugin.\")\nvar criRoot = flag.String(\"cri-root\", \"/var/lib/containerd/io.containerd.grpc.v1.cri\", \"The root directory of cri plugin.\")\nvar runtimeHandler = flag.String(\"runtime-handler\", \"\", \"The runtime handler to use in the test.\")\nvar containerdBin = flag.String(\"containerd-bin\", \"containerd\", \"The containerd binary name. The name is used to restart containerd during test.\")\nvar imageListFile = flag.String(\"image-list\", \"\", \"The TOML file containing the non-default images to be used in tests.\")\n\nfunc TestMain(m *testing.M) {\n\tflag.Parse()\n\tinitImages(*imageListFile)\n\tif err := ConnectDaemons(); err != nil {\n\t\tlogrus.WithError(err).Fatalf(\"Failed to connect daemons\")\n\t}\n\tos.Exit(m.Run())\n}\n\n// ConnectDaemons connect cri plugin and containerd, and initialize the clients.\nfunc ConnectDaemons() error {\n\tvar err error\n\truntimeService, err = remote.NewRuntimeService(*criEndpoint, timeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create runtime service: %w\", err)\n\t}\n\timageService, err = remote.NewImageService(*criEndpoint, timeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create image service: %w\", err)\n\t}\n\t// Since CRI grpc client doesn't have `WithBlock` specified, we\n\t// need to check whether it is actually connected.\n\t// TODO(#6069) Use grpc options to block on connect and remove for this list containers request.\n\t_, err = runtimeService.ListContainers(&runtime.ContainerFilter{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list containers: %w\", err)\n\t}\n\t_, err = imageService.ListImages(&runtime.ImageFilter{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list images: %w\", err)\n\t}\n\t// containerdEndpoint is the same with criEndpoint now\n\tcontainerdEndpoint = strings.TrimPrefix(*criEndpoint, \"unix://\")\n\tcontainerdEndpoint = strings.TrimPrefix(containerdEndpoint, \"npipe:\")\n\tcontainerdClient, err = containerd.New(containerdEndpoint, containerd.WithDefaultNamespace(k8sNamespace))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect containerd: %w\", err)\n\t}\n\treturn nil\n}\n\n// Opts sets specific information in pod sandbox config.\ntype PodSandboxOpts func(*runtime.PodSandboxConfig)\n\n// Set host network.\nfunc WithHostNetwork(p *runtime.PodSandboxConfig) {\n\tif p.Linux == nil {\n\t\tp.Linux = &runtime.LinuxPodSandboxConfig{}\n\t}\n\tif p.Linux.SecurityContext == nil {\n\t\tp.Linux.SecurityContext = &runtime.LinuxSandboxSecurityContext{}\n\t}\n\tif p.Linux.SecurityContext.NamespaceOptions == nil {\n\t\tp.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t}\n\tp.Linux.SecurityContext.NamespaceOptions.Network = runtime.NamespaceMode_NODE\n}\n\n// Set host pid.\nfunc WithHostPid(p *runtime.PodSandboxConfig) {\n\tif p.Linux == nil {\n\t\tp.Linux = &runtime.LinuxPodSandboxConfig{}\n\t}\n\tif p.Linux.SecurityContext == nil {\n\t\tp.Linux.SecurityContext = &runtime.LinuxSandboxSecurityContext{}\n\t}\n\tif p.Linux.SecurityContext.NamespaceOptions == nil {\n\t\tp.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t}\n\tp.Linux.SecurityContext.NamespaceOptions.Pid = runtime.NamespaceMode_NODE\n}\n\n// Set pod pid.\nfunc WithPodPid(p *runtime.PodSandboxConfig) {\n\tif p.Linux == nil {\n\t\tp.Linux = &runtime.LinuxPodSandboxConfig{}\n\t}\n\tif p.Linux.SecurityContext == nil {\n\t\tp.Linux.SecurityContext = &runtime.LinuxSandboxSecurityContext{}\n\t}\n\tif p.Linux.SecurityContext.NamespaceOptions == nil {\n\t\tp.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t}\n\tp.Linux.SecurityContext.NamespaceOptions.Pid = runtime.NamespaceMode_POD\n}\n\n// Add pod log directory.\nfunc WithPodLogDirectory(dir string) PodSandboxOpts {\n\treturn func(p *runtime.PodSandboxConfig) {\n\t\tp.LogDirectory = dir\n\t}\n}\n\n// Add pod hostname.\nfunc WithPodHostname(hostname string) PodSandboxOpts {\n\treturn func(p *runtime.PodSandboxConfig) {\n\t\tp.Hostname = hostname\n\t}\n}\n\n// Add pod labels.\nfunc WithPodLabels(kvs map[string]string) PodSandboxOpts {\n\treturn func(p *runtime.PodSandboxConfig) {\n\t\tfor k, v := range kvs {\n\t\t\tp.Labels[k] = v\n\t\t}\n\t}\n}\n\n// PodSandboxConfig generates a pod sandbox config for test.\nfunc PodSandboxConfig(name, ns string, opts ...PodSandboxOpts) *runtime.PodSandboxConfig {\n\tconfig := &runtime.PodSandboxConfig{\n\t\tMetadata: &runtime.PodSandboxMetadata{\n\t\t\tName: name,\n\t\t\t// Using random id as uuid is good enough for local\n\t\t\t// integration test.\n\t\t\tUid:       util.GenerateID(),\n\t\t\tNamespace: Randomize(ns),\n\t\t},\n\t\tLinux:       &runtime.LinuxPodSandboxConfig{},\n\t\tAnnotations: make(map[string]string),\n\t\tLabels:      make(map[string]string),\n\t}\n\tfor _, opt := range opts {\n\t\topt(config)\n\t}\n\treturn config\n}\n\nfunc PodSandboxConfigWithCleanup(t *testing.T, name, ns string, opts ...PodSandboxOpts) (string, *runtime.PodSandboxConfig) {\n\tsbConfig := PodSandboxConfig(name, ns, opts...)\n\tsb, err := runtimeService.RunPodSandbox(sbConfig, *runtimeHandler)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\tassert.NoError(t, runtimeService.StopPodSandbox(sb))\n\t\tassert.NoError(t, runtimeService.RemovePodSandbox(sb))\n\t})\n\n\treturn sb, sbConfig\n}\n\n// Set Windows HostProcess on the pod.\nfunc WithWindowsHostProcessPod(p *runtime.PodSandboxConfig) { //nolint:unused\n\tif p.Windows == nil {\n\t\tp.Windows = &runtime.WindowsPodSandboxConfig{}\n\t}\n\tif p.Windows.SecurityContext == nil {\n\t\tp.Windows.SecurityContext = &runtime.WindowsSandboxSecurityContext{}\n\t}\n\tp.Windows.SecurityContext.HostProcess = true\n}\n\n// ContainerOpts to set any specific attribute like labels,\n// annotations, metadata etc\ntype ContainerOpts func(*runtime.ContainerConfig)\n\nfunc WithTestLabels() ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.Labels = map[string]string{\"key\": \"value\"}\n\t}\n}\n\nfunc WithTestAnnotations() ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.Annotations = map[string]string{\"a.b.c\": \"test\"}\n\t}\n}\n\n// Add container resource limits.\nfunc WithResources(r *runtime.LinuxContainerResources) ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tc.Linux.Resources = r\n\t}\n}\n\nfunc WithVolumeMount(hostPath, containerPath string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\thostPath, _ = filepath.Abs(hostPath)\n\t\tcontainerPath, _ = filepath.Abs(containerPath)\n\t\tmount := &runtime.Mount{HostPath: hostPath, ContainerPath: containerPath}\n\t\tc.Mounts = append(c.Mounts, mount)\n\t}\n}\n\nfunc WithWindowsUsername(username string) ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Windows == nil {\n\t\t\tc.Windows = &runtime.WindowsContainerConfig{}\n\t\t}\n\t\tif c.Windows.SecurityContext == nil {\n\t\t\tc.Windows.SecurityContext = &runtime.WindowsContainerSecurityContext{}\n\t\t}\n\t\tc.Windows.SecurityContext.RunAsUsername = username\n\t}\n}\n\nfunc WithWindowsHostProcessContainer() ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Windows == nil {\n\t\t\tc.Windows = &runtime.WindowsContainerConfig{}\n\t\t}\n\t\tif c.Windows.SecurityContext == nil {\n\t\t\tc.Windows.SecurityContext = &runtime.WindowsContainerSecurityContext{}\n\t\t}\n\t\tc.Windows.SecurityContext.HostProcess = true\n\t}\n}\n\n// Add container command.\nfunc WithCommand(cmd string, args ...string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.Command = []string{cmd}\n\t\tc.Args = args\n\t}\n}\n\n// Add pid namespace mode.\nfunc WithPidNamespace(mode runtime.NamespaceMode) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tif c.Linux.SecurityContext.NamespaceOptions == nil {\n\t\t\tc.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t\t}\n\t\tc.Linux.SecurityContext.NamespaceOptions.Pid = mode\n\t}\n\n}\n\n// Add container log path.\nfunc WithLogPath(path string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.LogPath = path\n\t}\n}\n\n// WithSupplementalGroups adds supplemental groups.\nfunc WithSupplementalGroups(gids []int64) ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tc.Linux.SecurityContext.SupplementalGroups = gids\n\t}\n}\n\n// ContainerConfig creates a container config given a name and image name\n// and additional container config options\nfunc ContainerConfig(name, image string, opts ...ContainerOpts) *runtime.ContainerConfig {\n\tcConfig := &runtime.ContainerConfig{\n\t\tMetadata: &runtime.ContainerMetadata{\n\t\t\tName: name,\n\t\t},\n\t\tImage: &runtime.ImageSpec{Image: image},\n\t}\n\tfor _, opt := range opts {\n\t\topt(cConfig)\n\t}\n\treturn cConfig\n}\n\n// CheckFunc is the function used to check a condition is true/false.\ntype CheckFunc func() (bool, error)\n\n// Eventually waits for f to return true, it checks every period, and\n// returns error if timeout exceeds. If f returns error, Eventually\n// will return the same error immediately.\nfunc Eventually(f CheckFunc, period, timeout time.Duration) error {\n\tstart := time.Now()\n\tfor {\n\t\tdone, err := f()\n\t\tif done {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif time.Since(start) >= timeout {\n\t\t\treturn errors.New(\"timeout exceeded\")\n\t\t}\n\t\ttime.Sleep(period)\n\t}\n}\n\n// Consistently makes sure that f consistently returns true without\n// error before timeout exceeds. If f returns error, Consistently\n// will return the same error immediately.\nfunc Consistently(f CheckFunc, period, timeout time.Duration) error {\n\tstart := time.Now()\n\tfor {\n\t\tok, err := f()\n\t\tif !ok {\n\t\t\treturn errors.New(\"get false\")\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif time.Since(start) >= timeout {\n\t\t\treturn nil\n\t\t}\n\t\ttime.Sleep(period)\n\t}\n}\n\n// Randomize adds uuid after a string.\nfunc Randomize(str string) string {\n\treturn str + \"-\" + util.GenerateID()\n}\n\n// KillProcess kills the process by name. pkill is used.\nfunc KillProcess(name string, signal syscall.Signal) error {\n\tvar command []string\n\tif goruntime.GOOS == \"windows\" {\n\t\tcommand = []string{\"taskkill\", \"/IM\", name, \"/F\"}\n\t} else {\n\t\tcommand = []string{\"pkill\", \"-\" + strconv.Itoa(int(signal)), \"-x\", fmt.Sprintf(\"^%s$\", name)}\n\t}\n\n\toutput, err := exec.Command(command[0], command[1:]...).CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to kill %q - error: %v, output: %q\", name, err, output)\n\t}\n\treturn nil\n}\n\n// KillPid kills the process by pid. kill is used.\nfunc KillPid(pid int) error { //nolint:unused\n\toutput, err := exec.Command(\"kill\", strconv.Itoa(pid)).CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to kill %d - error: %v, output: %q\", pid, err, output)\n\t}\n\treturn nil\n}\n\n// PidOf returns pid of a process by name.\nfunc PidOf(name string) (int, error) {\n\tb, err := exec.Command(\"pidof\", \"-s\", name).CombinedOutput()\n\toutput := strings.TrimSpace(string(b))\n\tif err != nil {\n\t\tif len(output) != 0 {\n\t\t\treturn 0, fmt.Errorf(\"failed to run pidof %q - error: %v, output: %q\", name, err, output)\n\t\t}\n\t\treturn 0, nil\n\t}\n\treturn strconv.Atoi(output)\n}\n\n// PidsOf returns pid(s) of a process by name\nfunc PidsOf(name string) ([]int, error) {\n\tif len(name) == 0 {\n\t\treturn []int{}, fmt.Errorf(\"name is required\")\n\t}\n\n\tprocDirFD, err := os.Open(\"/proc\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open /proc: %w\", err)\n\t}\n\tdefer procDirFD.Close()\n\n\tres := []int{}\n\tfor {\n\t\tfileInfos, err := procDirFD.Readdir(100)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"failed to readdir: %w\", err)\n\t\t}\n\n\t\tfor _, fileInfo := range fileInfos {\n\t\t\tif !fileInfo.IsDir() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpid, err := strconv.Atoi(fileInfo.Name())\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\texePath, err := os.Readlink(filepath.Join(\"/proc\", fileInfo.Name(), \"exe\"))\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif strings.HasSuffix(exePath, name) {\n\t\t\t\tres = append(res, pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn res, nil\n}\n\n// PidEnvs returns the environ of pid in key-value pairs.\nfunc PidEnvs(pid int) (map[string]string, error) {\n\tenvPath := filepath.Join(\"/proc\", strconv.Itoa(pid), \"environ\")\n\n\tb, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read %s: %w\", envPath, err)\n\t}\n\n\tvalues := bytes.Split(b, []byte{0})\n\tif len(values) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tres := make(map[string]string)\n\tfor _, value := range values {\n\t\tvalue := strings.TrimSpace(string(value))\n\t\tif len(value) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tparts := strings.SplitN(value, \"=\", 2)\n\t\tif len(parts) == 2 {\n\t\t\tres[parts[0]] = parts[1]\n\t\t}\n\t}\n\treturn res, nil\n}\n\n// RawRuntimeClient returns a raw grpc runtime service client.\nfunc RawRuntimeClient() (runtime.RuntimeServiceClient, error) {\n\taddr, dialer, err := dialer.GetAddressAndDialer(*criEndpoint)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get dialer: %w\", err)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\tconn, err := grpc.DialContext(ctx, addr,\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithContextDialer(dialer),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect cri endpoint: %w\", err)\n\t}\n\treturn runtime.NewRuntimeServiceClient(conn), nil\n}\n\n// CRIConfig gets current cri config from containerd.\nfunc CRIConfig() (*criconfig.Config, error) {\n\tclient, err := RawRuntimeClient()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get raw runtime client: %w\", err)\n\t}\n\tresp, err := client.Status(context.Background(), &runtime.StatusRequest{Verbose: true})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get status: %w\", err)\n\t}\n\tconfig := &criconfig.Config{}\n\tif err := json.Unmarshal([]byte(resp.Info[\"config\"]), config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal config: %w\", err)\n\t}\n\treturn config, nil\n}\n\n// SandboxInfo gets sandbox info.\nfunc SandboxInfo(id string) (*runtime.PodSandboxStatus, *server.SandboxInfo, error) { //nolint:unused\n\tclient, err := RawRuntimeClient()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get raw runtime client: %w\", err)\n\t}\n\tresp, err := client.PodSandboxStatus(context.Background(), &runtime.PodSandboxStatusRequest{\n\t\tPodSandboxId: id,\n\t\tVerbose:      true,\n\t})\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get sandbox status: %w\", err)\n\t}\n\tstatus := resp.GetStatus()\n\tvar info server.SandboxInfo\n\tif err := json.Unmarshal([]byte(resp.GetInfo()[\"info\"]), &info); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to unmarshal sandbox info: %w\", err)\n\t}\n\treturn status, &info, nil\n}\n\nfunc RestartContainerd(t *testing.T, signal syscall.Signal) {\n\trequire.NoError(t, KillProcess(*containerdBin, signal))\n\n\t// Use assert so that the 3rd wait always runs, this makes sure\n\t// containerd is running before this function returns.\n\tassert.NoError(t, Eventually(func() (bool, error) {\n\t\tpid, err := PidOf(*containerdBin)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn pid == 0, nil\n\t}, time.Second, 30*time.Second), \"wait for containerd to be killed\")\n\n\trequire.NoError(t, Eventually(func() (bool, error) {\n\t\treturn ConnectDaemons() == nil, nil\n\t}, time.Second, 30*time.Second), \"wait for containerd to be restarted\")\n}\n\nfunc GetContainer(id string) (containers.Container, error) {\n\treturn containerdClient.ContainerService().Get(context.Background(), id)\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage oci\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/containers\"\n\t\"github.com/containerd/containerd/content\"\n\t\"github.com/containerd/containerd/images\"\n\t\"github.com/containerd/containerd/mount\"\n\t\"github.com/containerd/containerd/namespaces\"\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/continuity/fs\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/opencontainers/runc/libcontainer/user\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// SpecOpts sets spec specific information to a newly generated OCI spec\ntype SpecOpts func(context.Context, Client, *containers.Container, *Spec) error\n\n// Compose converts a sequence of spec operations into a single operation\nfunc Compose(opts ...SpecOpts) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n\t\tfor _, o := range opts {\n\t\t\tif err := o(ctx, client, c, s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// setProcess sets Process to empty if unset\nfunc setProcess(s *Spec) {\n\tif s.Process == nil {\n\t\ts.Process = &specs.Process{}\n\t}\n}\n\n// setRoot sets Root to empty if unset\nfunc setRoot(s *Spec) {\n\tif s.Root == nil {\n\t\ts.Root = &specs.Root{}\n\t}\n}\n\n// setLinux sets Linux to empty if unset\nfunc setLinux(s *Spec) {\n\tif s.Linux == nil {\n\t\ts.Linux = &specs.Linux{}\n\t}\n}\n\n// nolint\nfunc setResources(s *Spec) {\n\tif s.Linux != nil {\n\t\tif s.Linux.Resources == nil {\n\t\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t\t}\n\t}\n\tif s.Windows != nil {\n\t\tif s.Windows.Resources == nil {\n\t\t\ts.Windows.Resources = &specs.WindowsResources{}\n\t\t}\n\t}\n}\n\n// nolint\nfunc setCPU(s *Spec) {\n\tsetResources(s)\n\tif s.Linux != nil {\n\t\tif s.Linux.Resources.CPU == nil {\n\t\t\ts.Linux.Resources.CPU = &specs.LinuxCPU{}\n\t\t}\n\t}\n\tif s.Windows != nil {\n\t\tif s.Windows.Resources.CPU == nil {\n\t\t\ts.Windows.Resources.CPU = &specs.WindowsCPUResources{}\n\t\t}\n\t}\n}\n\n// setCapabilities sets Linux Capabilities to empty if unset\nfunc setCapabilities(s *Spec) {\n\tsetProcess(s)\n\tif s.Process.Capabilities == nil {\n\t\ts.Process.Capabilities = &specs.LinuxCapabilities{}\n\t}\n}\n\n// WithDefaultSpec returns a SpecOpts that will populate the spec with default\n// values.\n//\n// Use as the first option to clear the spec, then apply options afterwards.\nfunc WithDefaultSpec() SpecOpts {\n\treturn func(ctx context.Context, _ Client, c *containers.Container, s *Spec) error {\n\t\treturn generateDefaultSpecWithPlatform(ctx, platforms.DefaultString(), c.ID, s)\n\t}\n}\n\n// WithDefaultSpecForPlatform returns a SpecOpts that will populate the spec\n// with default values for a given platform.\n//\n// Use as the first option to clear the spec, then apply options afterwards.\nfunc WithDefaultSpecForPlatform(platform string) SpecOpts {\n\treturn func(ctx context.Context, _ Client, c *containers.Container, s *Spec) error {\n\t\treturn generateDefaultSpecWithPlatform(ctx, platform, c.ID, s)\n\t}\n}\n\n// WithSpecFromBytes loads the spec from the provided byte slice.\nfunc WithSpecFromBytes(p []byte) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\t*s = Spec{} // make sure spec is cleared.\n\t\tif err := json.Unmarshal(p, s); err != nil {\n\t\t\treturn fmt.Errorf(\"decoding spec config file failed, current supported OCI runtime-spec : v%s: %w\", specs.Version, err)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithSpecFromFile loads the specification from the provided filename.\nfunc WithSpecFromFile(filename string) SpecOpts {\n\treturn func(ctx context.Context, c Client, container *containers.Container, s *Spec) error {\n\t\tp, err := os.ReadFile(filename)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot load spec config file: %w\", err)\n\t\t}\n\t\treturn WithSpecFromBytes(p)(ctx, c, container, s)\n\t}\n}\n\n// WithEnv appends environment variables\nfunc WithEnv(environmentVariables []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tif len(environmentVariables) > 0 {\n\t\t\tsetProcess(s)\n\t\t\ts.Process.Env = replaceOrAppendEnvValues(s.Process.Env, environmentVariables)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithDefaultPathEnv sets the $PATH environment variable to the\n// default PATH defined in this package.\nfunc WithDefaultPathEnv(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Process.Env = replaceOrAppendEnvValues(s.Process.Env, defaultUnixEnv)\n\treturn nil\n}\n\n// replaceOrAppendEnvValues returns the defaults with the overrides either\n// replaced by env key or appended to the list\nfunc replaceOrAppendEnvValues(defaults, overrides []string) []string {\n\tcache := make(map[string]int, len(defaults))\n\tresults := make([]string, 0, len(defaults))\n\tfor i, e := range defaults {\n\t\tparts := strings.SplitN(e, \"=\", 2)\n\t\tresults = append(results, e)\n\t\tcache[parts[0]] = i\n\t}\n\n\tfor _, value := range overrides {\n\t\t// Values w/o = means they want this env to be removed/unset.\n\t\tif !strings.Contains(value, \"=\") {\n\t\t\tif i, exists := cache[value]; exists {\n\t\t\t\tresults[i] = \"\" // Used to indicate it should be removed\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Just do a normal set/update\n\t\tparts := strings.SplitN(value, \"=\", 2)\n\t\tif i, exists := cache[parts[0]]; exists {\n\t\t\tresults[i] = value\n\t\t} else {\n\t\t\tresults = append(results, value)\n\t\t}\n\t}\n\n\t// Now remove all entries that we want to \"unset\"\n\tfor i := 0; i < len(results); i++ {\n\t\tif results[i] == \"\" {\n\t\t\tresults = append(results[:i], results[i+1:]...)\n\t\t\ti--\n\t\t}\n\t}\n\n\treturn results\n}\n\n// WithProcessArgs replaces the args on the generated spec\nfunc WithProcessArgs(args ...string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.Args = args\n\t\treturn nil\n\t}\n}\n\n// WithProcessCwd replaces the current working directory on the generated spec\nfunc WithProcessCwd(cwd string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.Cwd = cwd\n\t\treturn nil\n\t}\n}\n\n// WithTTY sets the information on the spec as well as the environment variables for\n// using a TTY\nfunc WithTTY(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetProcess(s)\n\ts.Process.Terminal = true\n\tif s.Linux != nil {\n\t\ts.Process.Env = append(s.Process.Env, \"TERM=xterm\")\n\t}\n\n\treturn nil\n}\n\n// WithTTYSize sets the information on the spec as well as the environment variables for\n// using a TTY\nfunc WithTTYSize(width, height int) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\tif s.Process.ConsoleSize == nil {\n\t\t\ts.Process.ConsoleSize = &specs.Box{}\n\t\t}\n\t\ts.Process.ConsoleSize.Width = uint(width)\n\t\ts.Process.ConsoleSize.Height = uint(height)\n\t\treturn nil\n\t}\n}\n\n// WithHostname sets the container's hostname\nfunc WithHostname(name string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\ts.Hostname = name\n\t\treturn nil\n\t}\n}\n\n// WithMounts appends mounts\nfunc WithMounts(mounts []specs.Mount) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\ts.Mounts = append(s.Mounts, mounts...)\n\t\treturn nil\n\t}\n}\n\n// WithoutMounts removes mounts\nfunc WithoutMounts(dests ...string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tvar (\n\t\t\tmounts  []specs.Mount\n\t\t\tcurrent = s.Mounts\n\t\t)\n\tmLoop:\n\t\tfor _, m := range current {\n\t\t\tmDestination := filepath.Clean(m.Destination)\n\t\t\tfor _, dest := range dests {\n\t\t\t\tif mDestination == dest {\n\t\t\t\t\tcontinue mLoop\n\t\t\t\t}\n\t\t\t}\n\t\t\tmounts = append(mounts, m)\n\t\t}\n\t\ts.Mounts = mounts\n\t\treturn nil\n\t}\n}\n\n// WithHostNamespace allows a task to run inside the host's linux namespace\nfunc WithHostNamespace(ns specs.LinuxNamespaceType) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\tfor i, n := range s.Linux.Namespaces {\n\t\t\tif n.Type == ns {\n\t\t\t\ts.Linux.Namespaces = append(s.Linux.Namespaces[:i], s.Linux.Namespaces[i+1:]...)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithLinuxNamespace uses the passed in namespace for the spec. If a namespace of the same type already exists in the\n// spec, the existing namespace is replaced by the one provided.\nfunc WithLinuxNamespace(ns specs.LinuxNamespace) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\tfor i, n := range s.Linux.Namespaces {\n\t\t\tif n.Type == ns.Type {\n\t\t\t\ts.Linux.Namespaces[i] = ns\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\ts.Linux.Namespaces = append(s.Linux.Namespaces, ns)\n\t\treturn nil\n\t}\n}\n\n// WithNewPrivileges turns off the NoNewPrivileges feature flag in the spec\nfunc WithNewPrivileges(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetProcess(s)\n\ts.Process.NoNewPrivileges = false\n\n\treturn nil\n}\n\n// WithImageConfig configures the spec to from the configuration of an Image\nfunc WithImageConfig(image Image) SpecOpts {\n\treturn WithImageConfigArgs(image, nil)\n}\n\n// WithImageConfigArgs configures the spec to from the configuration of an Image with additional args that\n// replaces the CMD of the image\nfunc WithImageConfigArgs(image Image, args []string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n\t\tic, err := image.Config(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar (\n\t\t\tociimage v1.Image\n\t\t\tconfig   v1.ImageConfig\n\t\t)\n\t\tswitch ic.MediaType {\n\t\tcase v1.MediaTypeImageConfig, images.MediaTypeDockerSchema2Config:\n\t\t\tp, err := content.ReadBlob(ctx, image.ContentStore(), ic)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := json.Unmarshal(p, &ociimage); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tconfig = ociimage.Config\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown image config media type %s\", ic.MediaType)\n\t\t}\n\n\t\tsetProcess(s)\n\t\tif s.Linux != nil {\n\t\t\tdefaults := config.Env\n\t\t\tif len(defaults) == 0 {\n\t\t\t\tdefaults = defaultUnixEnv\n\t\t\t}\n\t\t\ts.Process.Env = replaceOrAppendEnvValues(defaults, s.Process.Env)\n\t\t\tcmd := config.Cmd\n\t\t\tif len(args) > 0 {\n\t\t\t\tcmd = args\n\t\t\t}\n\t\t\ts.Process.Args = append(config.Entrypoint, cmd...)\n\n\t\t\tcwd := config.WorkingDir\n\t\t\tif cwd == \"\" {\n\t\t\t\tcwd = \"/\"\n\t\t\t}\n\t\t\ts.Process.Cwd = cwd\n\t\t\tif config.User != \"\" {\n\t\t\t\tif err := WithUser(config.User)(ctx, client, c, s); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn WithAdditionalGIDs(fmt.Sprintf(\"%d\", s.Process.User.UID))(ctx, client, c, s)\n\t\t\t}\n\t\t\t// we should query the image's /etc/group for additional GIDs\n\t\t\t// even if there is no specified user in the image config\n\t\t\treturn WithAdditionalGIDs(\"root\")(ctx, client, c, s)\n\t\t} else if s.Windows != nil {\n\t\t\ts.Process.Env = replaceOrAppendEnvValues(config.Env, s.Process.Env)\n\t\t\tcmd := config.Cmd\n\t\t\tif len(args) > 0 {\n\t\t\t\tcmd = args\n\t\t\t}\n\t\t\ts.Process.Args = append(config.Entrypoint, cmd...)\n\n\t\t\ts.Process.Cwd = config.WorkingDir\n\t\t\ts.Process.User = specs.User{\n\t\t\t\tUsername: config.User,\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(\"spec does not contain Linux or Windows section\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithRootFSPath specifies unmanaged rootfs path.\nfunc WithRootFSPath(path string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetRoot(s)\n\t\ts.Root.Path = path\n\t\t// Entrypoint is not set here (it's up to caller)\n\t\treturn nil\n\t}\n}\n\n// WithRootFSReadonly sets specs.Root.Readonly to true\nfunc WithRootFSReadonly() SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetRoot(s)\n\t\ts.Root.Readonly = true\n\t\treturn nil\n\t}\n}\n\n// WithNoNewPrivileges sets no_new_privileges on the process for the container\nfunc WithNoNewPrivileges(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetProcess(s)\n\ts.Process.NoNewPrivileges = true\n\treturn nil\n}\n\n// WithHostHostsFile bind-mounts the host's /etc/hosts into the container as readonly\nfunc WithHostHostsFile(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Mounts = append(s.Mounts, specs.Mount{\n\t\tDestination: \"/etc/hosts\",\n\t\tType:        \"bind\",\n\t\tSource:      \"/etc/hosts\",\n\t\tOptions:     []string{\"rbind\", \"ro\"},\n\t})\n\treturn nil\n}\n\n// WithHostResolvconf bind-mounts the host's /etc/resolv.conf into the container as readonly\nfunc WithHostResolvconf(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Mounts = append(s.Mounts, specs.Mount{\n\t\tDestination: \"/etc/resolv.conf\",\n\t\tType:        \"bind\",\n\t\tSource:      \"/etc/resolv.conf\",\n\t\tOptions:     []string{\"rbind\", \"ro\"},\n\t})\n\treturn nil\n}\n\n// WithHostLocaltime bind-mounts the host's /etc/localtime into the container as readonly\nfunc WithHostLocaltime(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Mounts = append(s.Mounts, specs.Mount{\n\t\tDestination: \"/etc/localtime\",\n\t\tType:        \"bind\",\n\t\tSource:      \"/etc/localtime\",\n\t\tOptions:     []string{\"rbind\", \"ro\"},\n\t})\n\treturn nil\n}\n\n// WithUserNamespace sets the uid and gid mappings for the task\n// this can be called multiple times to add more mappings to the generated spec\nfunc WithUserNamespace(uidMap, gidMap []specs.LinuxIDMapping) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tvar hasUserns bool\n\t\tsetLinux(s)\n\t\tfor _, ns := range s.Linux.Namespaces {\n\t\t\tif ns.Type == specs.UserNamespace {\n\t\t\t\thasUserns = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !hasUserns {\n\t\t\ts.Linux.Namespaces = append(s.Linux.Namespaces, specs.LinuxNamespace{\n\t\t\t\tType: specs.UserNamespace,\n\t\t\t})\n\t\t}\n\t\ts.Linux.UIDMappings = append(s.Linux.UIDMappings, uidMap...)\n\t\ts.Linux.GIDMappings = append(s.Linux.GIDMappings, gidMap...)\n\t\treturn nil\n\t}\n}\n\n// WithCgroup sets the container's cgroup path\nfunc WithCgroup(path string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.CgroupsPath = path\n\t\treturn nil\n\t}\n}\n\n// WithNamespacedCgroup uses the namespace set on the context to create a\n// root directory for containers in the cgroup with the id as the subcgroup\nfunc WithNamespacedCgroup() SpecOpts {\n\treturn func(ctx context.Context, _ Client, c *containers.Container, s *Spec) error {\n\t\tnamespace, err := namespaces.NamespaceRequired(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsetLinux(s)\n\t\ts.Linux.CgroupsPath = filepath.Join(\"/\", namespace, c.ID)\n\t\treturn nil\n\t}\n}\n\n// WithUser sets the user to be used within the container.\n// It accepts a valid user string in OCI Image Spec v1.0.0:\n//\n//\tuser, uid, user:group, uid:gid, uid:group, user:gid\nfunc WithUser(userstr string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\n\t\t// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't\n\t\t// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the\n\t\t// guest itself. To accommodate this, a spot to place the user string provided by a client as-is is needed.\n\t\t// The `Username` field on the runtime spec is marked by Platform as only for Windows, and in this case it\n\t\t// *is* being set on a Windows host at least, but will be used as a temporary holding spot until the guest\n\t\t// can use the string to perform these same operations to grab the uid:gid inside.\n\t\tif s.Windows != nil && s.Linux != nil {\n\t\t\ts.Process.User.Username = userstr\n\t\t\treturn nil\n\t\t}\n\n\t\tparts := strings.Split(userstr, \":\")\n\t\tswitch len(parts) {\n\t\tcase 1:\n\t\t\tv, err := strconv.Atoi(parts[0])\n\t\t\tif err != nil {\n\t\t\t\t// if we cannot parse as a uint they try to see if it is a username\n\t\t\t\treturn WithUsername(userstr)(ctx, client, c, s)\n\t\t\t}\n\t\t\treturn WithUserID(uint32(v))(ctx, client, c, s)\n\t\tcase 2:\n\t\t\tvar (\n\t\t\t\tusername  string\n\t\t\t\tgroupname string\n\t\t\t)\n\t\t\tvar uid, gid uint32\n\t\t\tv, err := strconv.Atoi(parts[0])\n\t\t\tif err != nil {\n\t\t\t\tusername = parts[0]\n\t\t\t} else {\n\t\t\t\tuid = uint32(v)\n\t\t\t}\n\t\t\tif v, err = strconv.Atoi(parts[1]); err != nil {\n\t\t\t\tgroupname = parts[1]\n\t\t\t} else {\n\t\t\t\tgid = uint32(v)\n\t\t\t}\n\t\t\tif username == \"\" && groupname == \"\" {\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, gid\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tf := func(root string) error {\n\t\t\t\tif username != \"\" {\n\t\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\t\t\treturn u.Name == username\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tuid = uint32(user.Uid)\n\t\t\t\t}\n\t\t\t\tif groupname != \"\" {\n\t\t\t\t\tgid, err = GIDFromPath(root, func(g user.Group) bool {\n\t\t\t\t\t\treturn g.Name == groupname\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, gid\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t\t}\n\t\t\t\treturn f(s.Root.Path)\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" {\n\t\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t\t}\n\t\t\tif c.SnapshotKey == \"\" {\n\t\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t\t}\n\t\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmounts = tryReadonlyMounts(mounts)\n\t\t\treturn mount.WithTempMount(ctx, mounts, f)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid USER value %s\", userstr)\n\t\t}\n\t}\n}\n\n// WithUIDGID allows the UID and GID for the Process to be set\nfunc WithUIDGID(uid, gid uint32) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.User.UID = uid\n\t\ts.Process.User.GID = gid\n\t\treturn nil\n\t}\n}\n\n// WithUserID sets the correct UID and GID for the container based\n// on the image's /etc/passwd contents. If /etc/passwd does not exist,\n// or uid is not found in /etc/passwd, it sets the requested uid,\n// additionally sets the gid to 0, and does not return an error.\nfunc WithUserID(uid uint32) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\tsetProcess(s)\n\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t}\n\t\t\tuser, err := UserFromPath(s.Root.Path, func(u user.User) bool {\n\t\t\t\treturn u.Uid == int(uid)\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) || err == ErrNoUsersFound {\n\t\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, 0\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n\t\t\treturn nil\n\n\t\t}\n\t\tif c.Snapshotter == \"\" {\n\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t}\n\t\tif c.SnapshotKey == \"\" {\n\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t}\n\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmounts = tryReadonlyMounts(mounts)\n\t\treturn mount.WithTempMount(ctx, mounts, func(root string) error {\n\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\treturn u.Uid == int(uid)\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) || err == ErrNoUsersFound {\n\t\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, 0\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n\t\t\treturn nil\n\t\t})\n\t}\n}\n\n// WithUsername sets the correct UID and GID for the container\n// based on the image's /etc/passwd contents. If /etc/passwd\n// does not exist, or the username is not found in /etc/passwd,\n// it returns error. On Windows this sets the username as provided,\n// the operating system will validate the user when going to run\n// the container.\nfunc WithUsername(username string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\tsetProcess(s)\n\t\tif s.Linux != nil {\n\t\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t\t}\n\t\t\t\tuser, err := UserFromPath(s.Root.Path, func(u user.User) bool {\n\t\t\t\t\treturn u.Name == username\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" {\n\t\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t\t}\n\t\t\tif c.SnapshotKey == \"\" {\n\t\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t\t}\n\t\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmounts = tryReadonlyMounts(mounts)\n\t\t\treturn mount.WithTempMount(ctx, mounts, func(root string) error {\n\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\t\treturn u.Name == username\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t} else if s.Windows != nil {\n\t\t\ts.Process.User.Username = username\n\t\t} else {\n\t\t\treturn errors.New(\"spec does not contain Linux or Windows section\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithAdditionalGIDs sets the OCI spec's additionalGids array to any additional groups listed\n// for a particular user in the /etc/groups file of the image's root filesystem\n// The passed in user can be either a uid or a username.\nfunc WithAdditionalGIDs(userstr string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\t// For LCOW or on Darwin additional GID's not supported\n\t\tif s.Windows != nil || runtime.GOOS == \"darwin\" {\n\t\t\treturn nil\n\t\t}\n\t\tsetProcess(s)\n\t\tsetAdditionalGids := func(root string) error {\n\t\t\tvar username string\n\t\t\tuid, err := strconv.Atoi(userstr)\n\t\t\tif err == nil {\n\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\t\treturn u.Uid == uid\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tif os.IsNotExist(err) || err == ErrNoUsersFound {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tusername = user.Name\n\t\t\t} else {\n\t\t\t\tusername = userstr\n\t\t\t}\n\t\t\tgids, err := getSupplementalGroupsFromPath(root, func(g user.Group) bool {\n\t\t\t\t// we only want supplemental groups\n\t\t\t\tif g.Name == username {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tfor _, entry := range g.List {\n\t\t\t\t\tif entry == username {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Process.User.AdditionalGids = gids\n\t\t\treturn nil\n\t\t}\n\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t}\n\t\t\treturn setAdditionalGids(s.Root.Path)\n\t\t}\n\t\tif c.Snapshotter == \"\" {\n\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t}\n\t\tif c.SnapshotKey == \"\" {\n\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t}\n\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmounts = tryReadonlyMounts(mounts)\n\t\treturn mount.WithTempMount(ctx, mounts, setAdditionalGids)\n\t}\n}\n\n// WithCapabilities sets Linux capabilities on the process\nfunc WithCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\n\t\ts.Process.Capabilities.Bounding = caps\n\t\ts.Process.Capabilities.Effective = caps\n\t\ts.Process.Capabilities.Permitted = caps\n\n\t\treturn nil\n\t}\n}\n\nfunc capsContain(caps []string, s string) bool {\n\tfor _, c := range caps {\n\t\tif c == s {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc removeCap(caps *[]string, s string) {\n\tvar newcaps []string\n\tfor _, c := range *caps {\n\t\tif c == s {\n\t\t\tcontinue\n\t\t}\n\t\tnewcaps = append(newcaps, c)\n\t}\n\t*caps = newcaps\n}\n\n// WithAddedCapabilities adds the provided capabilities\nfunc WithAddedCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\t\tfor _, c := range caps {\n\t\t\tfor _, cl := range []*[]string{\n\t\t\t\t&s.Process.Capabilities.Bounding,\n\t\t\t\t&s.Process.Capabilities.Effective,\n\t\t\t\t&s.Process.Capabilities.Permitted,\n\t\t\t} {\n\t\t\t\tif !capsContain(*cl, c) {\n\t\t\t\t\t*cl = append(*cl, c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithDroppedCapabilities removes the provided capabilities\nfunc WithDroppedCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\t\tfor _, c := range caps {\n\t\t\tfor _, cl := range []*[]string{\n\t\t\t\t&s.Process.Capabilities.Bounding,\n\t\t\t\t&s.Process.Capabilities.Effective,\n\t\t\t\t&s.Process.Capabilities.Permitted,\n\t\t\t} {\n\t\t\t\tremoveCap(cl, c)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithAmbientCapabilities set the Linux ambient capabilities for the process\n// Ambient capabilities should only be set for non-root users or the caller should\n// understand how these capabilities are used and set\nfunc WithAmbientCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\t\ts.Process.Capabilities.Inheritable = caps\n\t\ts.Process.Capabilities.Ambient = caps\n\t\treturn nil\n\t}\n}\n\n// ErrNoUsersFound can be returned from UserFromPath\nvar ErrNoUsersFound = errors.New(\"no users found\")\n\n// UserFromPath inspects the user object using /etc/passwd in the specified rootfs.\n// filter can be nil.\nfunc UserFromPath(root string, filter func(user.User) bool) (user.User, error) {\n\tppath, err := fs.RootPath(root, \"/etc/passwd\")\n\tif err != nil {\n\t\treturn user.User{}, err\n\t}\n\tusers, err := user.ParsePasswdFileFilter(ppath, filter)\n\tif err != nil {\n\t\treturn user.User{}, err\n\t}\n\tif len(users) == 0 {\n\t\treturn user.User{}, ErrNoUsersFound\n\t}\n\treturn users[0], nil\n}\n\n// ErrNoGroupsFound can be returned from GIDFromPath\nvar ErrNoGroupsFound = errors.New(\"no groups found\")\n\n// GIDFromPath inspects the GID using /etc/passwd in the specified rootfs.\n// filter can be nil.\nfunc GIDFromPath(root string, filter func(user.Group) bool) (gid uint32, err error) {\n\tgpath, err := fs.RootPath(root, \"/etc/group\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tgroups, err := user.ParseGroupFileFilter(gpath, filter)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(groups) == 0 {\n\t\treturn 0, ErrNoGroupsFound\n\t}\n\tg := groups[0]\n\treturn uint32(g.Gid), nil\n}\n\nfunc getSupplementalGroupsFromPath(root string, filter func(user.Group) bool) ([]uint32, error) {\n\tgpath, err := fs.RootPath(root, \"/etc/group\")\n\tif err != nil {\n\t\treturn []uint32{}, err\n\t}\n\tgroups, err := user.ParseGroupFileFilter(gpath, filter)\n\tif err != nil {\n\t\treturn []uint32{}, err\n\t}\n\tif len(groups) == 0 {\n\t\t// if there are no additional groups; just return an empty set\n\t\treturn []uint32{}, nil\n\t}\n\taddlGids := []uint32{}\n\tfor _, grp := range groups {\n\t\taddlGids = append(addlGids, uint32(grp.Gid))\n\t}\n\treturn addlGids, nil\n}\n\nfunc isRootfsAbs(root string) bool {\n\treturn filepath.IsAbs(root)\n}\n\n// WithMaskedPaths sets the masked paths option\nfunc WithMaskedPaths(paths []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.MaskedPaths = paths\n\t\treturn nil\n\t}\n}\n\n// WithReadonlyPaths sets the read only paths option\nfunc WithReadonlyPaths(paths []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.ReadonlyPaths = paths\n\t\treturn nil\n\t}\n}\n\n// WithWriteableSysfs makes any sysfs mounts writeable\nfunc WithWriteableSysfs(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tfor _, m := range s.Mounts {\n\t\tif m.Type == \"sysfs\" {\n\t\t\tfor i, o := range m.Options {\n\t\t\t\tif o == \"ro\" {\n\t\t\t\t\tm.Options[i] = \"rw\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// WithWriteableCgroupfs makes any cgroup mounts writeable\nfunc WithWriteableCgroupfs(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tfor _, m := range s.Mounts {\n\t\tif m.Type == \"cgroup\" {\n\t\t\tfor i, o := range m.Options {\n\t\t\t\tif o == \"ro\" {\n\t\t\t\t\tm.Options[i] = \"rw\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// WithSelinuxLabel sets the process SELinux label\nfunc WithSelinuxLabel(label string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.SelinuxLabel = label\n\t\treturn nil\n\t}\n}\n\n// WithApparmorProfile sets the Apparmor profile for the process\nfunc WithApparmorProfile(profile string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.ApparmorProfile = profile\n\t\treturn nil\n\t}\n}\n\n// WithSeccompUnconfined clears the seccomp profile\nfunc WithSeccompUnconfined(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\ts.Linux.Seccomp = nil\n\treturn nil\n}\n\n// WithParentCgroupDevices uses the default cgroup setup to inherit the container's parent cgroup's\n// allowed and denied devices\nfunc WithParentCgroupDevices(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t}\n\ts.Linux.Resources.Devices = nil\n\treturn nil\n}\n\n// WithAllDevicesAllowed permits READ WRITE MKNOD on all devices nodes for the container\nfunc WithAllDevicesAllowed(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t}\n\ts.Linux.Resources.Devices = []specs.LinuxDeviceCgroup{\n\t\t{\n\t\t\tAllow:  true,\n\t\t\tAccess: rwm,\n\t\t},\n\t}\n\treturn nil\n}\n\n// WithDefaultUnixDevices adds the default devices for unix such as /dev/null, /dev/random to\n// the container's resource cgroup spec\nfunc WithDefaultUnixDevices(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t}\n\tintptr := func(i int64) *int64 {\n\t\treturn &i\n\t}\n\ts.Linux.Resources.Devices = append(s.Linux.Resources.Devices, []specs.LinuxDeviceCgroup{\n\t\t{\n\t\t\t// \"/dev/null\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(3),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/random\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(8),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/full\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(7),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/tty\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(5),\n\t\t\tMinor:  intptr(0),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/zero\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(5),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/urandom\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(9),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/console\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(5),\n\t\t\tMinor:  intptr(1),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t// /dev/pts/ - pts namespaces are \"coming soon\"\n\t\t{\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(136),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"dev/ptmx\"\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(5),\n\t\t\tMinor:  intptr(2),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t}...)\n\treturn nil\n}\n\n// WithPrivileged sets up options for a privileged container\nvar WithPrivileged = Compose(\n\tWithAllCurrentCapabilities,\n\tWithMaskedPaths(nil),\n\tWithReadonlyPaths(nil),\n\tWithWriteableSysfs,\n\tWithWriteableCgroupfs,\n\tWithSelinuxLabel(\"\"),\n\tWithApparmorProfile(\"\"),\n\tWithSeccompUnconfined,\n)\n\n// WithWindowsHyperV sets the Windows.HyperV section for HyperV isolation of containers.\nfunc WithWindowsHyperV(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tif s.Windows == nil {\n\t\ts.Windows = &specs.Windows{}\n\t}\n\tif s.Windows.HyperV == nil {\n\t\ts.Windows.HyperV = &specs.WindowsHyperV{}\n\t}\n\treturn nil\n}\n\n// WithMemoryLimit sets the `Linux.LinuxResources.Memory.Limit` section to the\n// `limit` specified if the `Linux` section is not `nil`. Additionally sets the\n// `Windows.WindowsResources.Memory.Limit` section if the `Windows` section is\n// not `nil`.\nfunc WithMemoryLimit(limit uint64) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tif s.Linux != nil {\n\t\t\tif s.Linux.Resources == nil {\n\t\t\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t\t\t}\n\t\t\tif s.Linux.Resources.Memory == nil {\n\t\t\t\ts.Linux.Resources.Memory = &specs.LinuxMemory{}\n\t\t\t}\n\t\t\tl := int64(limit)\n\t\t\ts.Linux.Resources.Memory.Limit = &l\n\t\t}\n\t\tif s.Windows != nil {\n\t\t\tif s.Windows.Resources == nil {\n\t\t\t\ts.Windows.Resources = &specs.WindowsResources{}\n\t\t\t}\n\t\t\tif s.Windows.Resources.Memory == nil {\n\t\t\t\ts.Windows.Resources.Memory = &specs.WindowsMemoryResources{}\n\t\t\t}\n\t\t\ts.Windows.Resources.Memory.Limit = &limit\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithAnnotations appends or replaces the annotations on the spec with the\n// provided annotations\nfunc WithAnnotations(annotations map[string]string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tif s.Annotations == nil {\n\t\t\ts.Annotations = make(map[string]string)\n\t\t}\n\t\tfor k, v := range annotations {\n\t\t\ts.Annotations[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithLinuxDevices adds the provided linux devices to the spec\nfunc WithLinuxDevices(devices []specs.LinuxDevice) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.Devices = append(s.Linux.Devices, devices...)\n\t\treturn nil\n\t}\n}\n\n// WithLinuxDevice adds the device specified by path to the spec\nfunc WithLinuxDevice(path, permissions string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\tsetResources(s)\n\n\t\tdev, err := DeviceFromPath(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ts.Linux.Devices = append(s.Linux.Devices, *dev)\n\n\t\ts.Linux.Resources.Devices = append(s.Linux.Resources.Devices, specs.LinuxDeviceCgroup{\n\t\t\tType:   dev.Type,\n\t\t\tAllow:  true,\n\t\t\tMajor:  &dev.Major,\n\t\t\tMinor:  &dev.Minor,\n\t\t\tAccess: permissions,\n\t\t})\n\n\t\treturn nil\n\t}\n}\n\n// WithEnvFile adds environment variables from a file to the container's spec\nfunc WithEnvFile(path string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tvar vars []string\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\tsc := bufio.NewScanner(f)\n\t\tfor sc.Scan() {\n\t\t\tvars = append(vars, sc.Text())\n\t\t}\n\t\tif err = sc.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn WithEnv(vars)(nil, nil, nil, s)\n\t}\n}\n\n// ErrNoShmMount is returned when there is no /dev/shm mount specified in the config\n// and an Opts was trying to set a configuration value on the mount.\nvar ErrNoShmMount = errors.New(\"no /dev/shm mount specified\")\n\n// WithDevShmSize sets the size of the /dev/shm mount for the container.\n//\n// The size value is specified in kb, kilobytes.\nfunc WithDevShmSize(kb int64) SpecOpts {\n\treturn func(ctx context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tfor i, m := range s.Mounts {\n\t\t\tif filepath.Clean(m.Destination) == \"/dev/shm\" && m.Source == \"shm\" && m.Type == \"tmpfs\" {\n\t\t\t\tfor i := 0; i < len(m.Options); i++ {\n\t\t\t\t\tif strings.HasPrefix(m.Options[i], \"size=\") {\n\t\t\t\t\t\tm.Options = append(m.Options[:i], m.Options[i+1:]...)\n\t\t\t\t\t\ti--\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.Mounts[i].Options = append(m.Options, fmt.Sprintf(\"size=%dk\", kb))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn ErrNoShmMount\n\t}\n}\n\n// tryReadonlyMounts is used by the options which are trying to get user/group\n// information from container's rootfs. Since the option does read operation\n// only, this helper will append ReadOnly mount option to prevent linux kernel\n// from syncing whole filesystem in umount syscall.\n//\n// TODO(fuweid):\n//\n// Currently, it only works for overlayfs. I think we can apply it to other\n// kinds of filesystem. Maybe we can return `ro` option by `snapshotter.Mount`\n// API, when the caller passes that experimental annotation\n// `containerd.io/snapshot/readonly.mount` something like that.\nfunc tryReadonlyMounts(mounts []mount.Mount) []mount.Mount {\n\tif len(mounts) == 1 && mounts[0].Type == \"overlay\" {\n\t\tmounts[0].Options = append(mounts[0].Options, \"ro\")\n\t}\n\treturn mounts\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage oci\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/containerd/containerd/pkg/testutil\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestAddCaps(t *testing.T) {\n\tt.Parallel()\n\n\tvar s specs.Spec\n\n\tif err := WithAddedCapabilities([]string{\"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif !capsContain(cl, \"CAP_CHOWN\") {\n\t\t\tt.Errorf(\"cap list %d does not contain added cap\", i)\n\t\t}\n\t}\n}\n\nfunc TestDropCaps(t *testing.T) {\n\tt.Parallel()\n\n\tvar s specs.Spec\n\n\tif err := WithAllKnownCapabilities(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := WithDroppedCapabilities([]string{\"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif capsContain(cl, \"CAP_CHOWN\") {\n\t\t\tt.Errorf(\"cap list %d contains dropped cap\", i)\n\t\t}\n\t}\n\n\t// Add all capabilities back and drop a different cap.\n\tif err := WithAllKnownCapabilities(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := WithDroppedCapabilities([]string{\"CAP_FOWNER\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif capsContain(cl, \"CAP_FOWNER\") {\n\t\t\tt.Errorf(\"cap list %d contains dropped cap\", i)\n\t\t}\n\t\tif !capsContain(cl, \"CAP_CHOWN\") {\n\t\t\tt.Errorf(\"cap list %d doesn't contain non-dropped cap\", i)\n\t\t}\n\t}\n\n\t// Drop all duplicated caps.\n\tif err := WithCapabilities([]string{\"CAP_CHOWN\", \"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := WithDroppedCapabilities([]string{\"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif len(cl) != 0 {\n\t\t\tt.Errorf(\"cap list %d is not empty\", i)\n\t\t}\n\t}\n}\n\nfunc TestGetDevices(t *testing.T) {\n\ttestutil.RequiresRoot(t)\n\n\tdir, err := os.MkdirTemp(\"/dev\", t.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dir)\n\n\tzero := filepath.Join(dir, \"zero\")\n\tif err := os.WriteFile(zero, nil, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := unix.Mount(\"/dev/zero\", zero, \"\", unix.MS_BIND, \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer unix.Unmount(filepath.Join(dir, \"zero\"), unix.MNT_DETACH)\n\n\tt.Run(\"single device\", func(t *testing.T) {\n\t\tt.Run(\"no container path\", func(t *testing.T) {\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(devices) != 1 {\n\t\t\t\tt.Fatalf(\"expected one device %v\", devices)\n\t\t\t}\n\t\t\tif devices[0].Path != zero {\n\t\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[0].Path)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"with container path\", func(t *testing.T) {\n\t\t\tnewPath := \"/dev/testNew\"\n\t\t\tdevices, err := getDevices(dir, newPath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(devices) != 1 {\n\t\t\t\tt.Fatalf(\"expected one device %v\", devices)\n\t\t\t}\n\t\t\tif devices[0].Path != filepath.Join(newPath, \"zero\") {\n\t\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[0].Path)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"two devices\", func(t *testing.T) {\n\t\tnullDev := filepath.Join(dir, \"null\")\n\t\tif err := os.WriteFile(nullDev, nil, 0600); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := unix.Mount(\"/dev/null\", nullDev, \"\", unix.MS_BIND, \"\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer unix.Unmount(filepath.Join(dir, \"null\"), unix.MNT_DETACH)\n\t\tdevices, err := getDevices(dir, \"\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(devices) != 2 {\n\t\t\tt.Fatalf(\"expected two devices %v\", devices)\n\t\t}\n\t\tif devices[0].Path == devices[1].Path {\n\t\t\tt.Fatalf(\"got same path for the two devices %s\", devices[0].Path)\n\t\t}\n\t\tif devices[0].Path != zero && devices[0].Path != nullDev {\n\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[0].Path)\n\t\t}\n\t\tif devices[1].Path != zero && devices[1].Path != nullDev {\n\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[1].Path)\n\t\t}\n\t\tif devices[0].Major == devices[1].Major && devices[0].Minor == devices[1].Minor {\n\t\t\tt.Fatalf(\"got sema mojor and minor on two devices %s %s\", devices[0].Path, devices[1].Path)\n\t\t}\n\t})\n\tt.Run(\"With symlink in dir\", func(t *testing.T) {\n\t\tif err := os.Symlink(\"/dev/zero\", filepath.Join(dir, \"zerosym\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdevices, err := getDevices(dir, \"\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(devices) != 1 {\n\t\t\tt.Fatalf(\"expected one device %v\", devices)\n\t\t}\n\t\tif devices[0].Path != filepath.Join(dir, \"zero\") {\n\t\t\tt.Fatalf(\"got unexpected device path, expected %q, got %q\", filepath.Join(dir, \"zero\"), devices[0].Path)\n\t\t}\n\t})\n\tt.Run(\"No devices\", func(t *testing.T) {\n\t\tdir := dir + \"2\"\n\t\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer os.RemoveAll(dir)\n\n\t\tt.Run(\"empty dir\", func(T *testing.T) {\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(devices) != 0 {\n\t\t\t\tt.Fatalf(\"expected no devices, got %+v\", devices)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"symlink to device in dir\", func(t *testing.T) {\n\t\t\tif err := os.Symlink(\"/dev/zero\", filepath.Join(dir, \"zerosym\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer os.Remove(filepath.Join(dir, \"zerosym\"))\n\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(devices) != 0 {\n\t\t\t\tt.Fatalf(\"expected no devices, got %+v\", devices)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"regular file in dir\", func(t *testing.T) {\n\t\t\tif err := os.WriteFile(filepath.Join(dir, \"somefile\"), []byte(\"hello\"), 0600); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer os.Remove(filepath.Join(dir, \"somefile\"))\n\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(devices) != 0 {\n\t\t\t\tt.Fatalf(\"expected no devices, got %+v\", devices)\n\t\t\t}\n\t\t})\n\t})\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage server\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/cgroups\"\n\t\"github.com/containerd/containerd/contrib/apparmor\"\n\t\"github.com/containerd/containerd/contrib/seccomp\"\n\t\"github.com/containerd/containerd/oci\"\n\timagespec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\truntimespec \"github.com/opencontainers/runtime-spec/specs-go\"\n\tselinux \"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n\n\t\"github.com/containerd/containerd/pkg/cri/annotations\"\n\t\"github.com/containerd/containerd/pkg/cri/config\"\n\tcustomopts \"github.com/containerd/containerd/pkg/cri/opts\"\n)\n\nconst (\n\t// profileNamePrefix is the prefix for loading profiles on a localhost. Eg. AppArmor localhost/profileName.\n\tprofileNamePrefix = \"localhost/\" // TODO (mikebrow): get localhost/ & runtime/default from CRI kubernetes/kubernetes#51747\n\t// runtimeDefault indicates that we should use or create a runtime default profile.\n\truntimeDefault = \"runtime/default\"\n\t// dockerDefault indicates that we should use or create a docker default profile.\n\tdockerDefault = \"docker/default\"\n\t// appArmorDefaultProfileName is name to use when creating a default apparmor profile.\n\tappArmorDefaultProfileName = \"cri-containerd.apparmor.d\"\n\t// unconfinedProfile is a string indicating one should run a pod/containerd without a security profile\n\tunconfinedProfile = \"unconfined\"\n\t// seccompDefaultProfile is the default seccomp profile.\n\tseccompDefaultProfile = dockerDefault\n)\n\n// containerMounts sets up necessary container system file mounts\n// including /dev/shm, /etc/hosts and /etc/resolv.conf.\nfunc (c *criService) containerMounts(sandboxID string, config *runtime.ContainerConfig) []*runtime.Mount {\n\tvar mounts []*runtime.Mount\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tif !isInCRIMounts(etcHostname, config.GetMounts()) {\n\t\t// /etc/hostname is added since 1.1.6, 1.2.4 and 1.3.\n\t\t// For in-place upgrade, the old sandbox doesn't have the hostname file,\n\t\t// do not mount this in that case.\n\t\t// TODO(random-liu): Remove the check and always mount this when\n\t\t// containerd 1.1 and 1.2 are deprecated.\n\t\thostpath := c.getSandboxHostname(sandboxID)\n\t\tif _, err := c.os.Stat(hostpath); err == nil {\n\t\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\t\tContainerPath:  etcHostname,\n\t\t\t\tHostPath:       hostpath,\n\t\t\t\tReadonly:       securityContext.GetReadonlyRootfs(),\n\t\t\t\tSelinuxRelabel: true,\n\t\t\t})\n\t\t}\n\t}\n\n\tif !isInCRIMounts(etcHosts, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  etcHosts,\n\t\t\tHostPath:       c.getSandboxHosts(sandboxID),\n\t\t\tReadonly:       securityContext.GetReadonlyRootfs(),\n\t\t\tSelinuxRelabel: true,\n\t\t})\n\t}\n\n\t// Mount sandbox resolv.config.\n\t// TODO: Need to figure out whether we should always mount it as read-only\n\tif !isInCRIMounts(resolvConfPath, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  resolvConfPath,\n\t\t\tHostPath:       c.getResolvPath(sandboxID),\n\t\t\tReadonly:       securityContext.GetReadonlyRootfs(),\n\t\t\tSelinuxRelabel: true,\n\t\t})\n\t}\n\n\tif !isInCRIMounts(devShm, config.GetMounts()) {\n\t\tsandboxDevShm := c.getSandboxDevShm(sandboxID)\n\t\tif securityContext.GetNamespaceOptions().GetIpc() == runtime.NamespaceMode_NODE {\n\t\t\tsandboxDevShm = devShm\n\t\t}\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  devShm,\n\t\t\tHostPath:       sandboxDevShm,\n\t\t\tReadonly:       false,\n\t\t\tSelinuxRelabel: sandboxDevShm != devShm,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc (c *criService) containerSpec(\n\tid string,\n\tsandboxID string,\n\tsandboxPid uint32,\n\tnetNSPath string,\n\tcontainerName string,\n\timageName string,\n\tconfig *runtime.ContainerConfig,\n\tsandboxConfig *runtime.PodSandboxConfig,\n\timageConfig *imagespec.ImageConfig,\n\textraMounts []*runtime.Mount,\n\tociRuntime config.Runtime,\n) (_ *runtimespec.Spec, retErr error) {\n\tspecOpts := []oci.SpecOpts{\n\t\toci.WithoutRunMount,\n\t}\n\t// only clear the default security settings if the runtime does not have a custom\n\t// base runtime spec spec.  Admins can use this functionality to define\n\t// default ulimits, seccomp, or other default settings.\n\tif ociRuntime.BaseRuntimeSpec == \"\" {\n\t\tspecOpts = append(specOpts, customopts.WithoutDefaultSecuritySettings)\n\t}\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithRelativeRoot(relativeRootfsPath),\n\t\tcustomopts.WithProcessArgs(config, imageConfig),\n\t\toci.WithDefaultPathEnv,\n\t\t// this will be set based on the security context below\n\t\toci.WithNewPrivileges,\n\t)\n\tif config.GetWorkingDir() != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(config.GetWorkingDir()))\n\t} else if imageConfig.WorkingDir != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(imageConfig.WorkingDir))\n\t}\n\n\tif config.GetTty() {\n\t\tspecOpts = append(specOpts, oci.WithTTY)\n\t}\n\n\t// Add HOSTNAME env.\n\tvar (\n\t\terr      error\n\t\thostname = sandboxConfig.GetHostname()\n\t)\n\tif hostname == \"\" {\n\t\tif hostname, err = c.os.Hostname(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv([]string{hostnameEnv + \"=\" + hostname}))\n\n\t// Apply envs from image config first, so that envs from container config\n\t// can override them.\n\tenv := append([]string{}, imageConfig.Env...)\n\tfor _, e := range config.GetEnvs() {\n\t\tenv = append(env, e.GetKey()+\"=\"+e.GetValue())\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv(env))\n\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tlabelOptions, err := toLabel(securityContext.GetSelinuxOptions())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(labelOptions) == 0 {\n\t\t// Use pod level SELinux config\n\t\tif sandbox, err := c.sandboxStore.Get(sandboxID); err == nil {\n\t\t\tlabelOptions, err = selinux.DupSecOpt(sandbox.ProcessLabel)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tprocessLabel, mountLabel, err := label.InitLabels(labelOptions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to init selinux options %+v: %w\", securityContext.GetSelinuxOptions(), err)\n\t}\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\t_ = label.ReleaseLabel(processLabel)\n\t\t}\n\t}()\n\n\tspecOpts = append(specOpts, customopts.WithMounts(c.os, config, extraMounts, mountLabel))\n\n\tif !c.config.DisableProcMount {\n\t\t// Change the default masked/readonly paths to empty slices\n\t\t// See https://github.com/containerd/containerd/issues/5029\n\t\t// TODO: Provide an option to set default paths to the ones in oci.populateDefaultUnixSpec()\n\t\tspecOpts = append(specOpts, oci.WithMaskedPaths([]string{}), oci.WithReadonlyPaths([]string{}))\n\n\t\t// Apply masked paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif maskedPaths := securityContext.GetMaskedPaths(); maskedPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithMaskedPaths(maskedPaths))\n\t\t}\n\n\t\t// Apply readonly paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif readonlyPaths := securityContext.GetReadonlyPaths(); readonlyPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithReadonlyPaths(readonlyPaths))\n\t\t}\n\t}\n\n\tspecOpts = append(specOpts, customopts.WithDevices(c.os, config, c.config.DeviceOwnershipFromSecurityContext),\n\t\tcustomopts.WithCapabilities(securityContext, c.allCaps))\n\n\tif securityContext.GetPrivileged() {\n\t\tif !sandboxConfig.GetLinux().GetSecurityContext().GetPrivileged() {\n\t\t\treturn nil, errors.New(\"no privileged container allowed in sandbox\")\n\t\t}\n\t\tspecOpts = append(specOpts, oci.WithPrivileged)\n\t\tif !ociRuntime.PrivilegedWithoutHostDevices {\n\t\t\tspecOpts = append(specOpts, oci.WithHostDevices, oci.WithAllDevicesAllowed)\n\t\t}\n\t}\n\n\t// Clear all ambient capabilities. The implication of non-root + caps\n\t// is not clearly defined in Kubernetes.\n\t// See https://github.com/kubernetes/kubernetes/issues/56374\n\t// Keep docker's behavior for now.\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithoutAmbientCaps,\n\t\tcustomopts.WithSelinuxLabels(processLabel, mountLabel),\n\t)\n\n\t// TODO: Figure out whether we should set no new privilege for sandbox container by default\n\tif securityContext.GetNoNewPrivs() {\n\t\tspecOpts = append(specOpts, oci.WithNoNewPrivileges)\n\t}\n\t// TODO(random-liu): [P1] Set selinux options (privileged or not).\n\tif securityContext.GetReadonlyRootfs() {\n\t\tspecOpts = append(specOpts, oci.WithRootFSReadonly())\n\t}\n\n\tif c.config.DisableCgroup {\n\t\tspecOpts = append(specOpts, customopts.WithDisabledCgroups)\n\t} else {\n\t\tspecOpts = append(specOpts, customopts.WithResources(config.GetLinux().GetResources(), c.config.TolerateMissingHugetlbController, c.config.DisableHugetlbController))\n\t\tif sandboxConfig.GetLinux().GetCgroupParent() != \"\" {\n\t\t\tcgroupsPath := getCgroupsPath(sandboxConfig.GetLinux().GetCgroupParent(), id)\n\t\t\tspecOpts = append(specOpts, oci.WithCgroup(cgroupsPath))\n\t\t}\n\t}\n\n\tsupplementalGroups := securityContext.GetSupplementalGroups()\n\n\t// Get RDT class\n\trdtClass, err := c.rdtClassFromAnnotations(config.GetMetadata().GetName(), config.Annotations, sandboxConfig.Annotations)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to set RDT class: %w\", err)\n\t}\n\tif rdtClass != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithRdt(rdtClass, \"\", \"\"))\n\t}\n\n\tfor pKey, pValue := range getPassthroughAnnotations(sandboxConfig.Annotations,\n\t\tociRuntime.PodAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\tfor pKey, pValue := range getPassthroughAnnotations(config.Annotations,\n\t\tociRuntime.ContainerAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\t// Default target PID namespace is the sandbox PID.\n\ttargetPid := sandboxPid\n\t// If the container targets another container's PID namespace,\n\t// set targetPid to the PID of that container.\n\tnsOpts := securityContext.GetNamespaceOptions()\n\tif nsOpts.GetPid() == runtime.NamespaceMode_TARGET {\n\t\ttargetContainer, err := c.validateTargetContainer(sandboxID, nsOpts.TargetId)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid target container: %w\", err)\n\t\t}\n\n\t\tstatus := targetContainer.Status.Get()\n\t\ttargetPid = status.Pid\n\t}\n\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithOOMScoreAdj(config, c.config.RestrictOOMScoreAdj),\n\t\tcustomopts.WithPodNamespaces(securityContext, sandboxPid, targetPid),\n\t\tcustomopts.WithSupplementalGroups(supplementalGroups),\n\t\tcustomopts.WithAnnotation(annotations.ContainerType, annotations.ContainerTypeContainer),\n\t\tcustomopts.WithAnnotation(annotations.SandboxID, sandboxID),\n\t\tcustomopts.WithAnnotation(annotations.SandboxNamespace, sandboxConfig.GetMetadata().GetNamespace()),\n\t\tcustomopts.WithAnnotation(annotations.SandboxUID, sandboxConfig.GetMetadata().GetUid()),\n\t\tcustomopts.WithAnnotation(annotations.SandboxName, sandboxConfig.GetMetadata().GetName()),\n\t\tcustomopts.WithAnnotation(annotations.ContainerName, containerName),\n\t\tcustomopts.WithAnnotation(annotations.ImageName, imageName),\n\t)\n\t// cgroupns is used for hiding /sys/fs/cgroup from containers.\n\t// For compatibility, cgroupns is not used when running in cgroup v1 mode or in privileged.\n\t// https://github.com/containers/libpod/issues/4363\n\t// https://github.com/kubernetes/enhancements/blob/0e409b47497e398b369c281074485c8de129694f/keps/sig-node/20191118-cgroups-v2.md#cgroup-namespace\n\tif cgroups.Mode() == cgroups.Unified && !securityContext.GetPrivileged() {\n\t\tspecOpts = append(specOpts, oci.WithLinuxNamespace(\n\t\t\truntimespec.LinuxNamespace{\n\t\t\t\tType: runtimespec.CgroupNamespace,\n\t\t\t}))\n\t}\n\treturn c.runtimeSpec(id, ociRuntime.BaseRuntimeSpec, specOpts...)\n}\n\nfunc (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageConfig *imagespec.ImageConfig) ([]oci.SpecOpts, error) {\n\tvar specOpts []oci.SpecOpts\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\t// Set container username. This could only be done by containerd, because it needs\n\t// access to the container rootfs. Pass user name to containerd, and let it overwrite\n\t// the spec for us.\n\tuserstr, err := generateUserString(\n\t\tsecurityContext.GetRunAsUsername(),\n\t\tsecurityContext.GetRunAsUser(),\n\t\tsecurityContext.GetRunAsGroup())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate user string: %w\", err)\n\t}\n\tif userstr == \"\" {\n\t\t// Lastly, since no user override was passed via CRI try to set via OCI\n\t\t// Image\n\t\tuserstr = imageConfig.User\n\t}\n\tif userstr != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithUser(userstr))\n\t}\n\n\tif securityContext.GetRunAsUsername() != \"\" {\n\t\tuserstr = securityContext.GetRunAsUsername()\n\t} else {\n\t\t// Even if RunAsUser is not set, we still call `GetValue` to get uid 0.\n\t\t// Because it is still useful to get additional gids for uid 0.\n\t\tuserstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)\n\t}\n\tspecOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr))\n\n\tasp := securityContext.GetApparmor()\n\tif asp == nil {\n\t\tasp, err = generateApparmorSecurityProfile(securityContext.GetApparmorProfile()) //nolint:staticcheck // Deprecated but we don't want to remove yet\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to generate apparmor spec opts: %w\", err)\n\t\t}\n\t}\n\tapparmorSpecOpts, err := generateApparmorSpecOpts(\n\t\tasp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.apparmorEnabled())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate apparmor spec opts: %w\", err)\n\t}\n\tif apparmorSpecOpts != nil {\n\t\tspecOpts = append(specOpts, apparmorSpecOpts)\n\t}\n\n\tssp := securityContext.GetSeccomp()\n\tif ssp == nil {\n\t\tssp, err = generateSeccompSecurityProfile(\n\t\t\tsecurityContext.GetSeccompProfilePath(), //nolint:staticcheck // Deprecated but we don't want to remove yet\n\t\t\tc.config.UnsetSeccompProfile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to generate seccomp spec opts: %w\", err)\n\t\t}\n\t}\n\tseccompSpecOpts, err := c.generateSeccompSpecOpts(\n\t\tssp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.seccompEnabled())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate seccomp spec opts: %w\", err)\n\t}\n\tif seccompSpecOpts != nil {\n\t\tspecOpts = append(specOpts, seccompSpecOpts)\n\t}\n\treturn specOpts, nil\n}\n\nfunc generateSeccompSecurityProfile(profilePath string, unsetProfilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\tif unsetProfilePath != \"\" {\n\t\treturn generateSecurityProfile(unsetProfilePath)\n\t}\n\treturn nil, nil\n}\nfunc generateApparmorSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\treturn nil, nil\n}\n\nfunc generateSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tswitch profilePath {\n\tcase runtimeDefault, dockerDefault, \"\":\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_RuntimeDefault,\n\t\t}, nil\n\tcase unconfinedProfile:\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_Unconfined,\n\t\t}, nil\n\tdefault:\n\t\t// Require and Trim default profile name prefix\n\t\tif !strings.HasPrefix(profilePath, profileNamePrefix) {\n\t\t\treturn nil, fmt.Errorf(\"invalid profile %q\", profilePath)\n\t\t}\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType:  runtime.SecurityProfile_Localhost,\n\t\t\tLocalhostRef: strings.TrimPrefix(profilePath, profileNamePrefix),\n\t\t}, nil\n\t}\n}\n\n// generateSeccompSpecOpts generates containerd SpecOpts for seccomp.\nfunc (c *criService) generateSeccompSpecOpts(sp *runtime.SecurityProfile, privileged, seccompEnabled bool) (oci.SpecOpts, error) {\n\tif privileged {\n\t\t// Do not set seccomp profile when container is privileged\n\t\treturn nil, nil\n\t}\n\tif !seccompEnabled {\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"seccomp is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\treturn nil, nil\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"seccomp config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set seccomp profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\treturn seccomp.WithDefaultProfile(), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even though it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\treturn seccomp.WithProfile(strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)), nil\n\tdefault:\n\t\treturn nil, errors.New(\"seccomp unknown ProfileType\")\n\t}\n}\n\n// generateApparmorSpecOpts generates containerd SpecOpts for apparmor.\nfunc generateApparmorSpecOpts(sp *runtime.SecurityProfile, privileged, apparmorEnabled bool) (oci.SpecOpts, error) {\n\tif !apparmorEnabled {\n\t\t// Should fail loudly if user try to specify apparmor profile\n\t\t// but we don't support it.\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"apparmor is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\t// Based on kubernetes#51746, default apparmor profile should be applied\n\t\t// for when apparmor is not specified.\n\t\tsp, _ = generateSecurityProfile(\"\")\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"apparmor config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set apparmor profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\tif privileged {\n\t\t\t// Do not set apparmor profile when container is privileged\n\t\t\treturn nil, nil\n\t\t}\n\t\t// TODO (mikebrow): delete created apparmor default profile\n\t\treturn apparmor.WithDefaultProfile(appArmorDefaultProfileName), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even through it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\tappArmorProfile := strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)\n\t\tif profileExists, err := appArmorProfileExists(appArmorProfile); !profileExists {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to generate apparmor spec opts: %w\", err)\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"apparmor profile not found %s\", appArmorProfile)\n\t\t}\n\t\treturn apparmor.WithProfile(appArmorProfile), nil\n\tdefault:\n\t\treturn nil, errors.New(\"apparmor unknown ProfileType\")\n\t}\n}\n\n// appArmorProfileExists scans apparmor/profiles for the requested profile\nfunc appArmorProfileExists(profile string) (bool, error) {\n\tif profile == \"\" {\n\t\treturn false, errors.New(\"nil apparmor profile is not supported\")\n\t}\n\tprofiles, err := os.Open(\"/sys/kernel/security/apparmor/profiles\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer profiles.Close()\n\n\trbuff := bufio.NewReader(profiles)\n\tfor {\n\t\tline, err := rbuff.ReadString('\\n')\n\t\tswitch err {\n\t\tcase nil:\n\t\t\tif strings.HasPrefix(line, profile+\" (\") {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase io.EOF:\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\treturn false, err\n\t\t}\n\t}\n}\n\n// generateUserString generates valid user string based on OCI Image Spec\n// v1.0.0.\n//\n// CRI defines that the following combinations are valid:\n//\n// (none) -> \"\"\n// username -> username\n// username, uid -> username\n// username, uid, gid -> username:gid\n// username, gid -> username:gid\n// uid -> uid\n// uid, gid -> uid:gid\n// gid -> error\n//\n// TODO(random-liu): Add group name support in CRI.\nfunc generateUserString(username string, uid, gid *runtime.Int64Value) (string, error) {\n\tvar userstr, groupstr string\n\tif uid != nil {\n\t\tuserstr = strconv.FormatInt(uid.GetValue(), 10)\n\t}\n\tif username != \"\" {\n\t\tuserstr = username\n\t}\n\tif gid != nil {\n\t\tgroupstr = strconv.FormatInt(gid.GetValue(), 10)\n\t}\n\tif userstr == \"\" {\n\t\tif groupstr != \"\" {\n\t\t\treturn \"\", fmt.Errorf(\"user group %q is specified without user\", groupstr)\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tif groupstr != \"\" {\n\t\tuserstr = userstr + \":\" + groupstr\n\t}\n\treturn userstr, nil\n}\n"], "fixing_code": ["//go:build linux\n// +build linux\n\n/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage integration\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n)\n\nfunc TestAdditionalGids(t *testing.T) {\n\ttestImage := GetImage(BusyBox)\n\tEnsureImageExists(t, testImage)\n\ttype testCase struct {\n\t\tdescription string\n\t\topts        []ContainerOpts\n\t\texpected    string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run` (no option)\",\n\t\t\topts:        nil,\n\t\t\texpected:    \"groups=0(root),10(wheel)\",\n\t\t},\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run --group-add 1 --group-add 1234`\",\n\t\t\topts:        []ContainerOpts{WithSupplementalGroups([]int64{1 /*daemon*/, 1234 /*new group*/})},\n\t\t\texpected:    \"groups=0(root),1(daemon),10(wheel),1234\",\n\t\t},\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run --user 1234`\",\n\t\t\topts:        []ContainerOpts{WithRunAsUser(1234)},\n\t\t\texpected:    \"groups=0(root)\",\n\t\t},\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run --user 1234:1234`\",\n\t\t\topts:        []ContainerOpts{WithRunAsUser(1234), WithRunAsGroup(1234)},\n\t\t\texpected:    \"groups=1234\",\n\t\t},\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run --user 1234 --group-add 1234`\",\n\t\t\topts:        []ContainerOpts{WithRunAsUser(1234), WithSupplementalGroups([]int64{1234})},\n\t\t\texpected:    \"groups=0(root),1234\",\n\t\t},\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run --user daemon` (Supported by CRI, although unsupported by kube-apiserver)\",\n\t\t\topts:        []ContainerOpts{WithRunAsUsername(\"daemon\")},\n\t\t\texpected:    \"groups=1(daemon)\",\n\t\t},\n\t\t{\n\t\t\tdescription: \"Equivalent of `docker run --user daemon --group-add 1234` (Supported by CRI, although unsupported by kube-apiserver)\",\n\t\t\topts:        []ContainerOpts{WithRunAsUsername(\"daemon\"), WithSupplementalGroups([]int64{1234})},\n\t\t\texpected:    \"groups=1(daemon),1234\",\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\ti, tc := i, tc\n\t\ttBasename := fmt.Sprintf(\"case-%d\", i)\n\t\tt.Run(tBasename, func(t *testing.T) {\n\t\t\tt.Log(tc.description)\n\t\t\tt.Logf(\"Expected=%q\", tc.expected)\n\n\t\t\ttestPodLogDir := t.TempDir()\n\n\t\t\tt.Log(\"Create a sandbox with log directory\")\n\t\t\tsb, sbConfig := PodSandboxConfigWithCleanup(t, \"sandbox\", tBasename,\n\t\t\t\tWithPodLogDirectory(testPodLogDir))\n\n\t\t\tt.Log(\"Create a container to print id\")\n\t\t\tcontainerName := tBasename\n\t\t\tcnConfig := ContainerConfig(\n\t\t\t\tcontainerName,\n\t\t\t\ttestImage,\n\t\t\t\tappend(\n\t\t\t\t\t[]ContainerOpts{\n\t\t\t\t\t\tWithCommand(\"id\"),\n\t\t\t\t\t\tWithLogPath(containerName),\n\t\t\t\t\t}, tc.opts...)...,\n\t\t\t)\n\t\t\tcn, err := runtimeService.CreateContainer(sb, cnConfig, sbConfig)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tt.Log(\"Start the container\")\n\t\t\trequire.NoError(t, runtimeService.StartContainer(cn))\n\n\t\t\tt.Log(\"Wait for container to finish running\")\n\t\t\trequire.NoError(t, Eventually(func() (bool, error) {\n\t\t\t\ts, err := runtimeService.ContainerStatus(cn)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t\tif s.GetState() == runtime.ContainerState_CONTAINER_EXITED {\n\t\t\t\t\treturn true, nil\n\t\t\t\t}\n\t\t\t\treturn false, nil\n\t\t\t}, time.Second, 30*time.Second))\n\n\t\t\tt.Log(\"Search additional groups in container log\")\n\t\t\tcontent, err := os.ReadFile(filepath.Join(testPodLogDir, containerName))\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, string(content), tc.expected+\"\\n\")\n\t\t})\n\t}\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage integration\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\tgoruntime \"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/containerd/containerd\"\n\t\"github.com/containerd/containerd/containers\"\n\tcri \"github.com/containerd/containerd/integration/cri-api/pkg/apis\"\n\t\"github.com/containerd/containerd/integration/remote\"\n\tdialer \"github.com/containerd/containerd/integration/util\"\n\tcriconfig \"github.com/containerd/containerd/pkg/cri/config\"\n\t\"github.com/containerd/containerd/pkg/cri/constants\"\n\t\"github.com/containerd/containerd/pkg/cri/server\"\n\t\"github.com/containerd/containerd/pkg/cri/util\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\texec \"golang.org/x/sys/execabs\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n)\n\nconst (\n\ttimeout      = 1 * time.Minute\n\tk8sNamespace = constants.K8sContainerdNamespace\n)\n\nvar (\n\truntimeService     cri.RuntimeService\n\tcontainerdClient   *containerd.Client\n\tcontainerdEndpoint string\n)\n\nvar criEndpoint = flag.String(\"cri-endpoint\", \"unix:///run/containerd/containerd.sock\", \"The endpoint of cri plugin.\")\nvar criRoot = flag.String(\"cri-root\", \"/var/lib/containerd/io.containerd.grpc.v1.cri\", \"The root directory of cri plugin.\")\nvar runtimeHandler = flag.String(\"runtime-handler\", \"\", \"The runtime handler to use in the test.\")\nvar containerdBin = flag.String(\"containerd-bin\", \"containerd\", \"The containerd binary name. The name is used to restart containerd during test.\")\nvar imageListFile = flag.String(\"image-list\", \"\", \"The TOML file containing the non-default images to be used in tests.\")\n\nfunc TestMain(m *testing.M) {\n\tflag.Parse()\n\tinitImages(*imageListFile)\n\tif err := ConnectDaemons(); err != nil {\n\t\tlogrus.WithError(err).Fatalf(\"Failed to connect daemons\")\n\t}\n\tos.Exit(m.Run())\n}\n\n// ConnectDaemons connect cri plugin and containerd, and initialize the clients.\nfunc ConnectDaemons() error {\n\tvar err error\n\truntimeService, err = remote.NewRuntimeService(*criEndpoint, timeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create runtime service: %w\", err)\n\t}\n\timageService, err = remote.NewImageService(*criEndpoint, timeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create image service: %w\", err)\n\t}\n\t// Since CRI grpc client doesn't have `WithBlock` specified, we\n\t// need to check whether it is actually connected.\n\t// TODO(#6069) Use grpc options to block on connect and remove for this list containers request.\n\t_, err = runtimeService.ListContainers(&runtime.ContainerFilter{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list containers: %w\", err)\n\t}\n\t_, err = imageService.ListImages(&runtime.ImageFilter{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list images: %w\", err)\n\t}\n\t// containerdEndpoint is the same with criEndpoint now\n\tcontainerdEndpoint = strings.TrimPrefix(*criEndpoint, \"unix://\")\n\tcontainerdEndpoint = strings.TrimPrefix(containerdEndpoint, \"npipe:\")\n\tcontainerdClient, err = containerd.New(containerdEndpoint, containerd.WithDefaultNamespace(k8sNamespace))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect containerd: %w\", err)\n\t}\n\treturn nil\n}\n\n// Opts sets specific information in pod sandbox config.\ntype PodSandboxOpts func(*runtime.PodSandboxConfig)\n\n// Set host network.\nfunc WithHostNetwork(p *runtime.PodSandboxConfig) {\n\tif p.Linux == nil {\n\t\tp.Linux = &runtime.LinuxPodSandboxConfig{}\n\t}\n\tif p.Linux.SecurityContext == nil {\n\t\tp.Linux.SecurityContext = &runtime.LinuxSandboxSecurityContext{}\n\t}\n\tif p.Linux.SecurityContext.NamespaceOptions == nil {\n\t\tp.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t}\n\tp.Linux.SecurityContext.NamespaceOptions.Network = runtime.NamespaceMode_NODE\n}\n\n// Set host pid.\nfunc WithHostPid(p *runtime.PodSandboxConfig) {\n\tif p.Linux == nil {\n\t\tp.Linux = &runtime.LinuxPodSandboxConfig{}\n\t}\n\tif p.Linux.SecurityContext == nil {\n\t\tp.Linux.SecurityContext = &runtime.LinuxSandboxSecurityContext{}\n\t}\n\tif p.Linux.SecurityContext.NamespaceOptions == nil {\n\t\tp.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t}\n\tp.Linux.SecurityContext.NamespaceOptions.Pid = runtime.NamespaceMode_NODE\n}\n\n// Set pod pid.\nfunc WithPodPid(p *runtime.PodSandboxConfig) {\n\tif p.Linux == nil {\n\t\tp.Linux = &runtime.LinuxPodSandboxConfig{}\n\t}\n\tif p.Linux.SecurityContext == nil {\n\t\tp.Linux.SecurityContext = &runtime.LinuxSandboxSecurityContext{}\n\t}\n\tif p.Linux.SecurityContext.NamespaceOptions == nil {\n\t\tp.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t}\n\tp.Linux.SecurityContext.NamespaceOptions.Pid = runtime.NamespaceMode_POD\n}\n\n// Add pod log directory.\nfunc WithPodLogDirectory(dir string) PodSandboxOpts {\n\treturn func(p *runtime.PodSandboxConfig) {\n\t\tp.LogDirectory = dir\n\t}\n}\n\n// Add pod hostname.\nfunc WithPodHostname(hostname string) PodSandboxOpts {\n\treturn func(p *runtime.PodSandboxConfig) {\n\t\tp.Hostname = hostname\n\t}\n}\n\n// Add pod labels.\nfunc WithPodLabels(kvs map[string]string) PodSandboxOpts {\n\treturn func(p *runtime.PodSandboxConfig) {\n\t\tfor k, v := range kvs {\n\t\t\tp.Labels[k] = v\n\t\t}\n\t}\n}\n\n// PodSandboxConfig generates a pod sandbox config for test.\nfunc PodSandboxConfig(name, ns string, opts ...PodSandboxOpts) *runtime.PodSandboxConfig {\n\tconfig := &runtime.PodSandboxConfig{\n\t\tMetadata: &runtime.PodSandboxMetadata{\n\t\t\tName: name,\n\t\t\t// Using random id as uuid is good enough for local\n\t\t\t// integration test.\n\t\t\tUid:       util.GenerateID(),\n\t\t\tNamespace: Randomize(ns),\n\t\t},\n\t\tLinux:       &runtime.LinuxPodSandboxConfig{},\n\t\tAnnotations: make(map[string]string),\n\t\tLabels:      make(map[string]string),\n\t}\n\tfor _, opt := range opts {\n\t\topt(config)\n\t}\n\treturn config\n}\n\nfunc PodSandboxConfigWithCleanup(t *testing.T, name, ns string, opts ...PodSandboxOpts) (string, *runtime.PodSandboxConfig) {\n\tsbConfig := PodSandboxConfig(name, ns, opts...)\n\tsb, err := runtimeService.RunPodSandbox(sbConfig, *runtimeHandler)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\tassert.NoError(t, runtimeService.StopPodSandbox(sb))\n\t\tassert.NoError(t, runtimeService.RemovePodSandbox(sb))\n\t})\n\n\treturn sb, sbConfig\n}\n\n// Set Windows HostProcess on the pod.\nfunc WithWindowsHostProcessPod(p *runtime.PodSandboxConfig) { //nolint:unused\n\tif p.Windows == nil {\n\t\tp.Windows = &runtime.WindowsPodSandboxConfig{}\n\t}\n\tif p.Windows.SecurityContext == nil {\n\t\tp.Windows.SecurityContext = &runtime.WindowsSandboxSecurityContext{}\n\t}\n\tp.Windows.SecurityContext.HostProcess = true\n}\n\n// ContainerOpts to set any specific attribute like labels,\n// annotations, metadata etc\ntype ContainerOpts func(*runtime.ContainerConfig)\n\nfunc WithTestLabels() ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.Labels = map[string]string{\"key\": \"value\"}\n\t}\n}\n\nfunc WithTestAnnotations() ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.Annotations = map[string]string{\"a.b.c\": \"test\"}\n\t}\n}\n\n// Add container resource limits.\nfunc WithResources(r *runtime.LinuxContainerResources) ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tc.Linux.Resources = r\n\t}\n}\n\nfunc WithVolumeMount(hostPath, containerPath string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\thostPath, _ = filepath.Abs(hostPath)\n\t\tcontainerPath, _ = filepath.Abs(containerPath)\n\t\tmount := &runtime.Mount{HostPath: hostPath, ContainerPath: containerPath}\n\t\tc.Mounts = append(c.Mounts, mount)\n\t}\n}\n\nfunc WithWindowsUsername(username string) ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Windows == nil {\n\t\t\tc.Windows = &runtime.WindowsContainerConfig{}\n\t\t}\n\t\tif c.Windows.SecurityContext == nil {\n\t\t\tc.Windows.SecurityContext = &runtime.WindowsContainerSecurityContext{}\n\t\t}\n\t\tc.Windows.SecurityContext.RunAsUsername = username\n\t}\n}\n\nfunc WithWindowsHostProcessContainer() ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Windows == nil {\n\t\t\tc.Windows = &runtime.WindowsContainerConfig{}\n\t\t}\n\t\tif c.Windows.SecurityContext == nil {\n\t\t\tc.Windows.SecurityContext = &runtime.WindowsContainerSecurityContext{}\n\t\t}\n\t\tc.Windows.SecurityContext.HostProcess = true\n\t}\n}\n\n// Add container command.\nfunc WithCommand(cmd string, args ...string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.Command = []string{cmd}\n\t\tc.Args = args\n\t}\n}\n\n// Add pid namespace mode.\nfunc WithPidNamespace(mode runtime.NamespaceMode) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tif c.Linux.SecurityContext.NamespaceOptions == nil {\n\t\t\tc.Linux.SecurityContext.NamespaceOptions = &runtime.NamespaceOption{}\n\t\t}\n\t\tc.Linux.SecurityContext.NamespaceOptions.Pid = mode\n\t}\n\n}\n\n// Add container log path.\nfunc WithLogPath(path string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tc.LogPath = path\n\t}\n}\n\n// WithRunAsUser sets the uid.\nfunc WithRunAsUser(uid int64) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tc.Linux.SecurityContext.RunAsUser = &runtime.Int64Value{Value: uid}\n\t}\n}\n\n// WithRunAsUsername sets the username.\nfunc WithRunAsUsername(username string) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tc.Linux.SecurityContext.RunAsUsername = username\n\t}\n}\n\n// WithRunAsGroup sets the gid.\nfunc WithRunAsGroup(gid int64) ContainerOpts {\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tc.Linux.SecurityContext.RunAsGroup = &runtime.Int64Value{Value: gid}\n\t}\n}\n\n// WithSupplementalGroups adds supplemental groups.\nfunc WithSupplementalGroups(gids []int64) ContainerOpts { //nolint:unused\n\treturn func(c *runtime.ContainerConfig) {\n\t\tif c.Linux == nil {\n\t\t\tc.Linux = &runtime.LinuxContainerConfig{}\n\t\t}\n\t\tif c.Linux.SecurityContext == nil {\n\t\t\tc.Linux.SecurityContext = &runtime.LinuxContainerSecurityContext{}\n\t\t}\n\t\tc.Linux.SecurityContext.SupplementalGroups = gids\n\t}\n}\n\n// ContainerConfig creates a container config given a name and image name\n// and additional container config options\nfunc ContainerConfig(name, image string, opts ...ContainerOpts) *runtime.ContainerConfig {\n\tcConfig := &runtime.ContainerConfig{\n\t\tMetadata: &runtime.ContainerMetadata{\n\t\t\tName: name,\n\t\t},\n\t\tImage: &runtime.ImageSpec{Image: image},\n\t}\n\tfor _, opt := range opts {\n\t\topt(cConfig)\n\t}\n\treturn cConfig\n}\n\n// CheckFunc is the function used to check a condition is true/false.\ntype CheckFunc func() (bool, error)\n\n// Eventually waits for f to return true, it checks every period, and\n// returns error if timeout exceeds. If f returns error, Eventually\n// will return the same error immediately.\nfunc Eventually(f CheckFunc, period, timeout time.Duration) error {\n\tstart := time.Now()\n\tfor {\n\t\tdone, err := f()\n\t\tif done {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif time.Since(start) >= timeout {\n\t\t\treturn errors.New(\"timeout exceeded\")\n\t\t}\n\t\ttime.Sleep(period)\n\t}\n}\n\n// Consistently makes sure that f consistently returns true without\n// error before timeout exceeds. If f returns error, Consistently\n// will return the same error immediately.\nfunc Consistently(f CheckFunc, period, timeout time.Duration) error {\n\tstart := time.Now()\n\tfor {\n\t\tok, err := f()\n\t\tif !ok {\n\t\t\treturn errors.New(\"get false\")\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif time.Since(start) >= timeout {\n\t\t\treturn nil\n\t\t}\n\t\ttime.Sleep(period)\n\t}\n}\n\n// Randomize adds uuid after a string.\nfunc Randomize(str string) string {\n\treturn str + \"-\" + util.GenerateID()\n}\n\n// KillProcess kills the process by name. pkill is used.\nfunc KillProcess(name string, signal syscall.Signal) error {\n\tvar command []string\n\tif goruntime.GOOS == \"windows\" {\n\t\tcommand = []string{\"taskkill\", \"/IM\", name, \"/F\"}\n\t} else {\n\t\tcommand = []string{\"pkill\", \"-\" + strconv.Itoa(int(signal)), \"-x\", fmt.Sprintf(\"^%s$\", name)}\n\t}\n\n\toutput, err := exec.Command(command[0], command[1:]...).CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to kill %q - error: %v, output: %q\", name, err, output)\n\t}\n\treturn nil\n}\n\n// KillPid kills the process by pid. kill is used.\nfunc KillPid(pid int) error { //nolint:unused\n\toutput, err := exec.Command(\"kill\", strconv.Itoa(pid)).CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to kill %d - error: %v, output: %q\", pid, err, output)\n\t}\n\treturn nil\n}\n\n// PidOf returns pid of a process by name.\nfunc PidOf(name string) (int, error) {\n\tb, err := exec.Command(\"pidof\", \"-s\", name).CombinedOutput()\n\toutput := strings.TrimSpace(string(b))\n\tif err != nil {\n\t\tif len(output) != 0 {\n\t\t\treturn 0, fmt.Errorf(\"failed to run pidof %q - error: %v, output: %q\", name, err, output)\n\t\t}\n\t\treturn 0, nil\n\t}\n\treturn strconv.Atoi(output)\n}\n\n// PidsOf returns pid(s) of a process by name\nfunc PidsOf(name string) ([]int, error) {\n\tif len(name) == 0 {\n\t\treturn []int{}, fmt.Errorf(\"name is required\")\n\t}\n\n\tprocDirFD, err := os.Open(\"/proc\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open /proc: %w\", err)\n\t}\n\tdefer procDirFD.Close()\n\n\tres := []int{}\n\tfor {\n\t\tfileInfos, err := procDirFD.Readdir(100)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"failed to readdir: %w\", err)\n\t\t}\n\n\t\tfor _, fileInfo := range fileInfos {\n\t\t\tif !fileInfo.IsDir() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpid, err := strconv.Atoi(fileInfo.Name())\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\texePath, err := os.Readlink(filepath.Join(\"/proc\", fileInfo.Name(), \"exe\"))\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif strings.HasSuffix(exePath, name) {\n\t\t\t\tres = append(res, pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn res, nil\n}\n\n// PidEnvs returns the environ of pid in key-value pairs.\nfunc PidEnvs(pid int) (map[string]string, error) {\n\tenvPath := filepath.Join(\"/proc\", strconv.Itoa(pid), \"environ\")\n\n\tb, err := os.ReadFile(envPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read %s: %w\", envPath, err)\n\t}\n\n\tvalues := bytes.Split(b, []byte{0})\n\tif len(values) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tres := make(map[string]string)\n\tfor _, value := range values {\n\t\tvalue := strings.TrimSpace(string(value))\n\t\tif len(value) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tparts := strings.SplitN(value, \"=\", 2)\n\t\tif len(parts) == 2 {\n\t\t\tres[parts[0]] = parts[1]\n\t\t}\n\t}\n\treturn res, nil\n}\n\n// RawRuntimeClient returns a raw grpc runtime service client.\nfunc RawRuntimeClient() (runtime.RuntimeServiceClient, error) {\n\taddr, dialer, err := dialer.GetAddressAndDialer(*criEndpoint)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get dialer: %w\", err)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\tconn, err := grpc.DialContext(ctx, addr,\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithContextDialer(dialer),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect cri endpoint: %w\", err)\n\t}\n\treturn runtime.NewRuntimeServiceClient(conn), nil\n}\n\n// CRIConfig gets current cri config from containerd.\nfunc CRIConfig() (*criconfig.Config, error) {\n\tclient, err := RawRuntimeClient()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get raw runtime client: %w\", err)\n\t}\n\tresp, err := client.Status(context.Background(), &runtime.StatusRequest{Verbose: true})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get status: %w\", err)\n\t}\n\tconfig := &criconfig.Config{}\n\tif err := json.Unmarshal([]byte(resp.Info[\"config\"]), config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal config: %w\", err)\n\t}\n\treturn config, nil\n}\n\n// SandboxInfo gets sandbox info.\nfunc SandboxInfo(id string) (*runtime.PodSandboxStatus, *server.SandboxInfo, error) { //nolint:unused\n\tclient, err := RawRuntimeClient()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get raw runtime client: %w\", err)\n\t}\n\tresp, err := client.PodSandboxStatus(context.Background(), &runtime.PodSandboxStatusRequest{\n\t\tPodSandboxId: id,\n\t\tVerbose:      true,\n\t})\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get sandbox status: %w\", err)\n\t}\n\tstatus := resp.GetStatus()\n\tvar info server.SandboxInfo\n\tif err := json.Unmarshal([]byte(resp.GetInfo()[\"info\"]), &info); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to unmarshal sandbox info: %w\", err)\n\t}\n\treturn status, &info, nil\n}\n\nfunc RestartContainerd(t *testing.T, signal syscall.Signal) {\n\trequire.NoError(t, KillProcess(*containerdBin, signal))\n\n\t// Use assert so that the 3rd wait always runs, this makes sure\n\t// containerd is running before this function returns.\n\tassert.NoError(t, Eventually(func() (bool, error) {\n\t\tpid, err := PidOf(*containerdBin)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn pid == 0, nil\n\t}, time.Second, 30*time.Second), \"wait for containerd to be killed\")\n\n\trequire.NoError(t, Eventually(func() (bool, error) {\n\t\treturn ConnectDaemons() == nil, nil\n\t}, time.Second, 30*time.Second), \"wait for containerd to be restarted\")\n}\n\nfunc GetContainer(id string) (containers.Container, error) {\n\treturn containerdClient.ContainerService().Get(context.Background(), id)\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage oci\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/containers\"\n\t\"github.com/containerd/containerd/content\"\n\t\"github.com/containerd/containerd/images\"\n\t\"github.com/containerd/containerd/mount\"\n\t\"github.com/containerd/containerd/namespaces\"\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/continuity/fs\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/opencontainers/runc/libcontainer/user\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// SpecOpts sets spec specific information to a newly generated OCI spec\ntype SpecOpts func(context.Context, Client, *containers.Container, *Spec) error\n\n// Compose converts a sequence of spec operations into a single operation\nfunc Compose(opts ...SpecOpts) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n\t\tfor _, o := range opts {\n\t\t\tif err := o(ctx, client, c, s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// setProcess sets Process to empty if unset\nfunc setProcess(s *Spec) {\n\tif s.Process == nil {\n\t\ts.Process = &specs.Process{}\n\t}\n}\n\n// setRoot sets Root to empty if unset\nfunc setRoot(s *Spec) {\n\tif s.Root == nil {\n\t\ts.Root = &specs.Root{}\n\t}\n}\n\n// setLinux sets Linux to empty if unset\nfunc setLinux(s *Spec) {\n\tif s.Linux == nil {\n\t\ts.Linux = &specs.Linux{}\n\t}\n}\n\n// nolint\nfunc setResources(s *Spec) {\n\tif s.Linux != nil {\n\t\tif s.Linux.Resources == nil {\n\t\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t\t}\n\t}\n\tif s.Windows != nil {\n\t\tif s.Windows.Resources == nil {\n\t\t\ts.Windows.Resources = &specs.WindowsResources{}\n\t\t}\n\t}\n}\n\n// nolint\nfunc setCPU(s *Spec) {\n\tsetResources(s)\n\tif s.Linux != nil {\n\t\tif s.Linux.Resources.CPU == nil {\n\t\t\ts.Linux.Resources.CPU = &specs.LinuxCPU{}\n\t\t}\n\t}\n\tif s.Windows != nil {\n\t\tif s.Windows.Resources.CPU == nil {\n\t\t\ts.Windows.Resources.CPU = &specs.WindowsCPUResources{}\n\t\t}\n\t}\n}\n\n// setCapabilities sets Linux Capabilities to empty if unset\nfunc setCapabilities(s *Spec) {\n\tsetProcess(s)\n\tif s.Process.Capabilities == nil {\n\t\ts.Process.Capabilities = &specs.LinuxCapabilities{}\n\t}\n}\n\n// ensureAdditionalGids ensures that the primary GID is also included in the additional GID list.\nfunc ensureAdditionalGids(s *Spec) {\n\tsetProcess(s)\n\tfor _, f := range s.Process.User.AdditionalGids {\n\t\tif f == s.Process.User.GID {\n\t\t\treturn\n\t\t}\n\t}\n\ts.Process.User.AdditionalGids = append([]uint32{s.Process.User.GID}, s.Process.User.AdditionalGids...)\n}\n\n// WithDefaultSpec returns a SpecOpts that will populate the spec with default\n// values.\n//\n// Use as the first option to clear the spec, then apply options afterwards.\nfunc WithDefaultSpec() SpecOpts {\n\treturn func(ctx context.Context, _ Client, c *containers.Container, s *Spec) error {\n\t\treturn generateDefaultSpecWithPlatform(ctx, platforms.DefaultString(), c.ID, s)\n\t}\n}\n\n// WithDefaultSpecForPlatform returns a SpecOpts that will populate the spec\n// with default values for a given platform.\n//\n// Use as the first option to clear the spec, then apply options afterwards.\nfunc WithDefaultSpecForPlatform(platform string) SpecOpts {\n\treturn func(ctx context.Context, _ Client, c *containers.Container, s *Spec) error {\n\t\treturn generateDefaultSpecWithPlatform(ctx, platform, c.ID, s)\n\t}\n}\n\n// WithSpecFromBytes loads the spec from the provided byte slice.\nfunc WithSpecFromBytes(p []byte) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\t*s = Spec{} // make sure spec is cleared.\n\t\tif err := json.Unmarshal(p, s); err != nil {\n\t\t\treturn fmt.Errorf(\"decoding spec config file failed, current supported OCI runtime-spec : v%s: %w\", specs.Version, err)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithSpecFromFile loads the specification from the provided filename.\nfunc WithSpecFromFile(filename string) SpecOpts {\n\treturn func(ctx context.Context, c Client, container *containers.Container, s *Spec) error {\n\t\tp, err := os.ReadFile(filename)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot load spec config file: %w\", err)\n\t\t}\n\t\treturn WithSpecFromBytes(p)(ctx, c, container, s)\n\t}\n}\n\n// WithEnv appends environment variables\nfunc WithEnv(environmentVariables []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tif len(environmentVariables) > 0 {\n\t\t\tsetProcess(s)\n\t\t\ts.Process.Env = replaceOrAppendEnvValues(s.Process.Env, environmentVariables)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithDefaultPathEnv sets the $PATH environment variable to the\n// default PATH defined in this package.\nfunc WithDefaultPathEnv(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Process.Env = replaceOrAppendEnvValues(s.Process.Env, defaultUnixEnv)\n\treturn nil\n}\n\n// replaceOrAppendEnvValues returns the defaults with the overrides either\n// replaced by env key or appended to the list\nfunc replaceOrAppendEnvValues(defaults, overrides []string) []string {\n\tcache := make(map[string]int, len(defaults))\n\tresults := make([]string, 0, len(defaults))\n\tfor i, e := range defaults {\n\t\tparts := strings.SplitN(e, \"=\", 2)\n\t\tresults = append(results, e)\n\t\tcache[parts[0]] = i\n\t}\n\n\tfor _, value := range overrides {\n\t\t// Values w/o = means they want this env to be removed/unset.\n\t\tif !strings.Contains(value, \"=\") {\n\t\t\tif i, exists := cache[value]; exists {\n\t\t\t\tresults[i] = \"\" // Used to indicate it should be removed\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Just do a normal set/update\n\t\tparts := strings.SplitN(value, \"=\", 2)\n\t\tif i, exists := cache[parts[0]]; exists {\n\t\t\tresults[i] = value\n\t\t} else {\n\t\t\tresults = append(results, value)\n\t\t}\n\t}\n\n\t// Now remove all entries that we want to \"unset\"\n\tfor i := 0; i < len(results); i++ {\n\t\tif results[i] == \"\" {\n\t\t\tresults = append(results[:i], results[i+1:]...)\n\t\t\ti--\n\t\t}\n\t}\n\n\treturn results\n}\n\n// WithProcessArgs replaces the args on the generated spec\nfunc WithProcessArgs(args ...string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.Args = args\n\t\treturn nil\n\t}\n}\n\n// WithProcessCwd replaces the current working directory on the generated spec\nfunc WithProcessCwd(cwd string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.Cwd = cwd\n\t\treturn nil\n\t}\n}\n\n// WithTTY sets the information on the spec as well as the environment variables for\n// using a TTY\nfunc WithTTY(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetProcess(s)\n\ts.Process.Terminal = true\n\tif s.Linux != nil {\n\t\ts.Process.Env = append(s.Process.Env, \"TERM=xterm\")\n\t}\n\n\treturn nil\n}\n\n// WithTTYSize sets the information on the spec as well as the environment variables for\n// using a TTY\nfunc WithTTYSize(width, height int) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\tif s.Process.ConsoleSize == nil {\n\t\t\ts.Process.ConsoleSize = &specs.Box{}\n\t\t}\n\t\ts.Process.ConsoleSize.Width = uint(width)\n\t\ts.Process.ConsoleSize.Height = uint(height)\n\t\treturn nil\n\t}\n}\n\n// WithHostname sets the container's hostname\nfunc WithHostname(name string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\ts.Hostname = name\n\t\treturn nil\n\t}\n}\n\n// WithMounts appends mounts\nfunc WithMounts(mounts []specs.Mount) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\ts.Mounts = append(s.Mounts, mounts...)\n\t\treturn nil\n\t}\n}\n\n// WithoutMounts removes mounts\nfunc WithoutMounts(dests ...string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tvar (\n\t\t\tmounts  []specs.Mount\n\t\t\tcurrent = s.Mounts\n\t\t)\n\tmLoop:\n\t\tfor _, m := range current {\n\t\t\tmDestination := filepath.Clean(m.Destination)\n\t\t\tfor _, dest := range dests {\n\t\t\t\tif mDestination == dest {\n\t\t\t\t\tcontinue mLoop\n\t\t\t\t}\n\t\t\t}\n\t\t\tmounts = append(mounts, m)\n\t\t}\n\t\ts.Mounts = mounts\n\t\treturn nil\n\t}\n}\n\n// WithHostNamespace allows a task to run inside the host's linux namespace\nfunc WithHostNamespace(ns specs.LinuxNamespaceType) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\tfor i, n := range s.Linux.Namespaces {\n\t\t\tif n.Type == ns {\n\t\t\t\ts.Linux.Namespaces = append(s.Linux.Namespaces[:i], s.Linux.Namespaces[i+1:]...)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithLinuxNamespace uses the passed in namespace for the spec. If a namespace of the same type already exists in the\n// spec, the existing namespace is replaced by the one provided.\nfunc WithLinuxNamespace(ns specs.LinuxNamespace) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\tfor i, n := range s.Linux.Namespaces {\n\t\t\tif n.Type == ns.Type {\n\t\t\t\ts.Linux.Namespaces[i] = ns\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\ts.Linux.Namespaces = append(s.Linux.Namespaces, ns)\n\t\treturn nil\n\t}\n}\n\n// WithNewPrivileges turns off the NoNewPrivileges feature flag in the spec\nfunc WithNewPrivileges(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetProcess(s)\n\ts.Process.NoNewPrivileges = false\n\n\treturn nil\n}\n\n// WithImageConfig configures the spec to from the configuration of an Image\nfunc WithImageConfig(image Image) SpecOpts {\n\treturn WithImageConfigArgs(image, nil)\n}\n\n// WithImageConfigArgs configures the spec to from the configuration of an Image with additional args that\n// replaces the CMD of the image\nfunc WithImageConfigArgs(image Image, args []string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n\t\tic, err := image.Config(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar (\n\t\t\tociimage v1.Image\n\t\t\tconfig   v1.ImageConfig\n\t\t)\n\t\tswitch ic.MediaType {\n\t\tcase v1.MediaTypeImageConfig, images.MediaTypeDockerSchema2Config:\n\t\t\tp, err := content.ReadBlob(ctx, image.ContentStore(), ic)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := json.Unmarshal(p, &ociimage); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tconfig = ociimage.Config\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown image config media type %s\", ic.MediaType)\n\t\t}\n\n\t\tsetProcess(s)\n\t\tif s.Linux != nil {\n\t\t\tdefaults := config.Env\n\t\t\tif len(defaults) == 0 {\n\t\t\t\tdefaults = defaultUnixEnv\n\t\t\t}\n\t\t\ts.Process.Env = replaceOrAppendEnvValues(defaults, s.Process.Env)\n\t\t\tcmd := config.Cmd\n\t\t\tif len(args) > 0 {\n\t\t\t\tcmd = args\n\t\t\t}\n\t\t\ts.Process.Args = append(config.Entrypoint, cmd...)\n\n\t\t\tcwd := config.WorkingDir\n\t\t\tif cwd == \"\" {\n\t\t\t\tcwd = \"/\"\n\t\t\t}\n\t\t\ts.Process.Cwd = cwd\n\t\t\tif config.User != \"\" {\n\t\t\t\tif err := WithUser(config.User)(ctx, client, c, s); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn WithAdditionalGIDs(fmt.Sprintf(\"%d\", s.Process.User.UID))(ctx, client, c, s)\n\t\t\t}\n\t\t\t// we should query the image's /etc/group for additional GIDs\n\t\t\t// even if there is no specified user in the image config\n\t\t\treturn WithAdditionalGIDs(\"root\")(ctx, client, c, s)\n\t\t} else if s.Windows != nil {\n\t\t\ts.Process.Env = replaceOrAppendEnvValues(config.Env, s.Process.Env)\n\t\t\tcmd := config.Cmd\n\t\t\tif len(args) > 0 {\n\t\t\t\tcmd = args\n\t\t\t}\n\t\t\ts.Process.Args = append(config.Entrypoint, cmd...)\n\n\t\t\ts.Process.Cwd = config.WorkingDir\n\t\t\ts.Process.User = specs.User{\n\t\t\t\tUsername: config.User,\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(\"spec does not contain Linux or Windows section\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithRootFSPath specifies unmanaged rootfs path.\nfunc WithRootFSPath(path string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetRoot(s)\n\t\ts.Root.Path = path\n\t\t// Entrypoint is not set here (it's up to caller)\n\t\treturn nil\n\t}\n}\n\n// WithRootFSReadonly sets specs.Root.Readonly to true\nfunc WithRootFSReadonly() SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetRoot(s)\n\t\ts.Root.Readonly = true\n\t\treturn nil\n\t}\n}\n\n// WithNoNewPrivileges sets no_new_privileges on the process for the container\nfunc WithNoNewPrivileges(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetProcess(s)\n\ts.Process.NoNewPrivileges = true\n\treturn nil\n}\n\n// WithHostHostsFile bind-mounts the host's /etc/hosts into the container as readonly\nfunc WithHostHostsFile(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Mounts = append(s.Mounts, specs.Mount{\n\t\tDestination: \"/etc/hosts\",\n\t\tType:        \"bind\",\n\t\tSource:      \"/etc/hosts\",\n\t\tOptions:     []string{\"rbind\", \"ro\"},\n\t})\n\treturn nil\n}\n\n// WithHostResolvconf bind-mounts the host's /etc/resolv.conf into the container as readonly\nfunc WithHostResolvconf(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Mounts = append(s.Mounts, specs.Mount{\n\t\tDestination: \"/etc/resolv.conf\",\n\t\tType:        \"bind\",\n\t\tSource:      \"/etc/resolv.conf\",\n\t\tOptions:     []string{\"rbind\", \"ro\"},\n\t})\n\treturn nil\n}\n\n// WithHostLocaltime bind-mounts the host's /etc/localtime into the container as readonly\nfunc WithHostLocaltime(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\ts.Mounts = append(s.Mounts, specs.Mount{\n\t\tDestination: \"/etc/localtime\",\n\t\tType:        \"bind\",\n\t\tSource:      \"/etc/localtime\",\n\t\tOptions:     []string{\"rbind\", \"ro\"},\n\t})\n\treturn nil\n}\n\n// WithUserNamespace sets the uid and gid mappings for the task\n// this can be called multiple times to add more mappings to the generated spec\nfunc WithUserNamespace(uidMap, gidMap []specs.LinuxIDMapping) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tvar hasUserns bool\n\t\tsetLinux(s)\n\t\tfor _, ns := range s.Linux.Namespaces {\n\t\t\tif ns.Type == specs.UserNamespace {\n\t\t\t\thasUserns = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !hasUserns {\n\t\t\ts.Linux.Namespaces = append(s.Linux.Namespaces, specs.LinuxNamespace{\n\t\t\t\tType: specs.UserNamespace,\n\t\t\t})\n\t\t}\n\t\ts.Linux.UIDMappings = append(s.Linux.UIDMappings, uidMap...)\n\t\ts.Linux.GIDMappings = append(s.Linux.GIDMappings, gidMap...)\n\t\treturn nil\n\t}\n}\n\n// WithCgroup sets the container's cgroup path\nfunc WithCgroup(path string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.CgroupsPath = path\n\t\treturn nil\n\t}\n}\n\n// WithNamespacedCgroup uses the namespace set on the context to create a\n// root directory for containers in the cgroup with the id as the subcgroup\nfunc WithNamespacedCgroup() SpecOpts {\n\treturn func(ctx context.Context, _ Client, c *containers.Container, s *Spec) error {\n\t\tnamespace, err := namespaces.NamespaceRequired(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsetLinux(s)\n\t\ts.Linux.CgroupsPath = filepath.Join(\"/\", namespace, c.ID)\n\t\treturn nil\n\t}\n}\n\n// WithUser sets the user to be used within the container.\n// It accepts a valid user string in OCI Image Spec v1.0.0:\n//\n//\tuser, uid, user:group, uid:gid, uid:group, user:gid\nfunc WithUser(userstr string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {\n\t\tdefer ensureAdditionalGids(s)\n\t\tsetProcess(s)\n\t\ts.Process.User.AdditionalGids = nil\n\n\t\t// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't\n\t\t// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the\n\t\t// guest itself. To accommodate this, a spot to place the user string provided by a client as-is is needed.\n\t\t// The `Username` field on the runtime spec is marked by Platform as only for Windows, and in this case it\n\t\t// *is* being set on a Windows host at least, but will be used as a temporary holding spot until the guest\n\t\t// can use the string to perform these same operations to grab the uid:gid inside.\n\t\tif s.Windows != nil && s.Linux != nil {\n\t\t\ts.Process.User.Username = userstr\n\t\t\treturn nil\n\t\t}\n\n\t\tparts := strings.Split(userstr, \":\")\n\t\tswitch len(parts) {\n\t\tcase 1:\n\t\t\tv, err := strconv.Atoi(parts[0])\n\t\t\tif err != nil {\n\t\t\t\t// if we cannot parse as a uint they try to see if it is a username\n\t\t\t\treturn WithUsername(userstr)(ctx, client, c, s)\n\t\t\t}\n\t\t\treturn WithUserID(uint32(v))(ctx, client, c, s)\n\t\tcase 2:\n\t\t\tvar (\n\t\t\t\tusername  string\n\t\t\t\tgroupname string\n\t\t\t)\n\t\t\tvar uid, gid uint32\n\t\t\tv, err := strconv.Atoi(parts[0])\n\t\t\tif err != nil {\n\t\t\t\tusername = parts[0]\n\t\t\t} else {\n\t\t\t\tuid = uint32(v)\n\t\t\t}\n\t\t\tif v, err = strconv.Atoi(parts[1]); err != nil {\n\t\t\t\tgroupname = parts[1]\n\t\t\t} else {\n\t\t\t\tgid = uint32(v)\n\t\t\t}\n\t\t\tif username == \"\" && groupname == \"\" {\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, gid\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tf := func(root string) error {\n\t\t\t\tif username != \"\" {\n\t\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\t\t\treturn u.Name == username\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tuid = uint32(user.Uid)\n\t\t\t\t}\n\t\t\t\tif groupname != \"\" {\n\t\t\t\t\tgid, err = GIDFromPath(root, func(g user.Group) bool {\n\t\t\t\t\t\treturn g.Name == groupname\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, gid\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t\t}\n\t\t\t\treturn f(s.Root.Path)\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" {\n\t\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t\t}\n\t\t\tif c.SnapshotKey == \"\" {\n\t\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t\t}\n\t\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmounts = tryReadonlyMounts(mounts)\n\t\t\treturn mount.WithTempMount(ctx, mounts, f)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid USER value %s\", userstr)\n\t\t}\n\t}\n}\n\n// WithUIDGID allows the UID and GID for the Process to be set\nfunc WithUIDGID(uid, gid uint32) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tdefer ensureAdditionalGids(s)\n\t\tsetProcess(s)\n\t\ts.Process.User.AdditionalGids = nil\n\t\ts.Process.User.UID = uid\n\t\ts.Process.User.GID = gid\n\t\treturn nil\n\t}\n}\n\n// WithUserID sets the correct UID and GID for the container based\n// on the image's /etc/passwd contents. If /etc/passwd does not exist,\n// or uid is not found in /etc/passwd, it sets the requested uid,\n// additionally sets the gid to 0, and does not return an error.\nfunc WithUserID(uid uint32) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\tdefer ensureAdditionalGids(s)\n\t\tsetProcess(s)\n\t\ts.Process.User.AdditionalGids = nil\n\t\tsetUser := func(root string) error {\n\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\treturn u.Uid == int(uid)\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) || err == ErrNoUsersFound {\n\t\t\t\t\ts.Process.User.UID, s.Process.User.GID = uid, 0\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n\t\t\treturn nil\n\t\t}\n\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t}\n\t\t\treturn setUser(s.Root.Path)\n\t\t}\n\t\tif c.Snapshotter == \"\" {\n\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t}\n\t\tif c.SnapshotKey == \"\" {\n\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t}\n\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmounts = tryReadonlyMounts(mounts)\n\t\treturn mount.WithTempMount(ctx, mounts, setUser)\n\t}\n}\n\n// WithUsername sets the correct UID and GID for the container\n// based on the image's /etc/passwd contents. If /etc/passwd\n// does not exist, or the username is not found in /etc/passwd,\n// it returns error. On Windows this sets the username as provided,\n// the operating system will validate the user when going to run\n// the container.\nfunc WithUsername(username string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\tdefer ensureAdditionalGids(s)\n\t\tsetProcess(s)\n\t\ts.Process.User.AdditionalGids = nil\n\t\tif s.Linux != nil {\n\t\t\tsetUser := func(root string) error {\n\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\t\treturn u.Name == username\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t\t}\n\t\t\t\treturn setUser(s.Root.Path)\n\t\t\t}\n\t\t\tif c.Snapshotter == \"\" {\n\t\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t\t}\n\t\t\tif c.SnapshotKey == \"\" {\n\t\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t\t}\n\t\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmounts = tryReadonlyMounts(mounts)\n\t\t\treturn mount.WithTempMount(ctx, mounts, setUser)\n\t\t} else if s.Windows != nil {\n\t\t\ts.Process.User.Username = username\n\t\t} else {\n\t\t\treturn errors.New(\"spec does not contain Linux or Windows section\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithAdditionalGIDs sets the OCI spec's additionalGids array to any additional groups listed\n// for a particular user in the /etc/group file of the image's root filesystem\n// The passed in user can be either a uid or a username.\nfunc WithAdditionalGIDs(userstr string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\t// For LCOW or on Darwin additional GID's not supported\n\t\tif s.Windows != nil || runtime.GOOS == \"darwin\" {\n\t\t\treturn nil\n\t\t}\n\t\tsetProcess(s)\n\t\ts.Process.User.AdditionalGids = nil\n\t\tsetAdditionalGids := func(root string) error {\n\t\t\tdefer ensureAdditionalGids(s)\n\t\t\tvar username string\n\t\t\tuid, err := strconv.Atoi(userstr)\n\t\t\tif err == nil {\n\t\t\t\tuser, err := UserFromPath(root, func(u user.User) bool {\n\t\t\t\t\treturn u.Uid == uid\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tif os.IsNotExist(err) || err == ErrNoUsersFound {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tusername = user.Name\n\t\t\t} else {\n\t\t\t\tusername = userstr\n\t\t\t}\n\t\t\tgids, err := getSupplementalGroupsFromPath(root, func(g user.Group) bool {\n\t\t\t\t// we only want supplemental groups\n\t\t\t\tif g.Name == username {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tfor _, entry := range g.List {\n\t\t\t\t\tif entry == username {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Process.User.AdditionalGids = gids\n\t\t\treturn nil\n\t\t}\n\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\tif !isRootfsAbs(s.Root.Path) {\n\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t}\n\t\t\treturn setAdditionalGids(s.Root.Path)\n\t\t}\n\t\tif c.Snapshotter == \"\" {\n\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t}\n\t\tif c.SnapshotKey == \"\" {\n\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t}\n\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmounts = tryReadonlyMounts(mounts)\n\t\treturn mount.WithTempMount(ctx, mounts, setAdditionalGids)\n\t}\n}\n\n// WithAppendAdditionalGroups append additional groups within the container.\n// The passed in groups can be either a gid or a groupname.\nfunc WithAppendAdditionalGroups(groups ...string) SpecOpts {\n\treturn func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {\n\t\t// For LCOW or on Darwin additional GID's are not supported\n\t\tif s.Windows != nil || runtime.GOOS == \"darwin\" {\n\t\t\treturn nil\n\t\t}\n\t\tsetProcess(s)\n\t\tsetAdditionalGids := func(root string) error {\n\t\t\tdefer ensureAdditionalGids(s)\n\t\t\tgpath, err := fs.RootPath(root, \"/etc/group\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tugroups, err := user.ParseGroupFile(gpath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tgroupMap := make(map[string]user.Group)\n\t\t\tfor _, group := range ugroups {\n\t\t\t\tgroupMap[group.Name] = group\n\t\t\t}\n\t\t\tvar gids []uint32\n\t\t\tfor _, group := range groups {\n\t\t\t\tgid, err := strconv.ParseUint(group, 10, 32)\n\t\t\t\tif err == nil {\n\t\t\t\t\tgids = append(gids, uint32(gid))\n\t\t\t\t} else {\n\t\t\t\t\tg, ok := groupMap[group]\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn fmt.Errorf(\"unable to find group %s\", group)\n\t\t\t\t\t}\n\t\t\t\t\tgids = append(gids, uint32(g.Gid))\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.Process.User.AdditionalGids = append(s.Process.User.AdditionalGids, gids...)\n\t\t\treturn nil\n\t\t}\n\t\tif c.Snapshotter == \"\" && c.SnapshotKey == \"\" {\n\t\t\tif !filepath.IsAbs(s.Root.Path) {\n\t\t\t\treturn errors.New(\"rootfs absolute path is required\")\n\t\t\t}\n\t\t\treturn setAdditionalGids(s.Root.Path)\n\t\t}\n\t\tif c.Snapshotter == \"\" {\n\t\t\treturn errors.New(\"no snapshotter set for container\")\n\t\t}\n\t\tif c.SnapshotKey == \"\" {\n\t\t\treturn errors.New(\"rootfs snapshot not created for container\")\n\t\t}\n\t\tsnapshotter := client.SnapshotService(c.Snapshotter)\n\t\tmounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmounts = tryReadonlyMounts(mounts)\n\t\treturn mount.WithTempMount(ctx, mounts, setAdditionalGids)\n\t}\n}\n\n// WithCapabilities sets Linux capabilities on the process\nfunc WithCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\n\t\ts.Process.Capabilities.Bounding = caps\n\t\ts.Process.Capabilities.Effective = caps\n\t\ts.Process.Capabilities.Permitted = caps\n\n\t\treturn nil\n\t}\n}\n\nfunc capsContain(caps []string, s string) bool {\n\tfor _, c := range caps {\n\t\tif c == s {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc removeCap(caps *[]string, s string) {\n\tvar newcaps []string\n\tfor _, c := range *caps {\n\t\tif c == s {\n\t\t\tcontinue\n\t\t}\n\t\tnewcaps = append(newcaps, c)\n\t}\n\t*caps = newcaps\n}\n\n// WithAddedCapabilities adds the provided capabilities\nfunc WithAddedCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\t\tfor _, c := range caps {\n\t\t\tfor _, cl := range []*[]string{\n\t\t\t\t&s.Process.Capabilities.Bounding,\n\t\t\t\t&s.Process.Capabilities.Effective,\n\t\t\t\t&s.Process.Capabilities.Permitted,\n\t\t\t} {\n\t\t\t\tif !capsContain(*cl, c) {\n\t\t\t\t\t*cl = append(*cl, c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithDroppedCapabilities removes the provided capabilities\nfunc WithDroppedCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\t\tfor _, c := range caps {\n\t\t\tfor _, cl := range []*[]string{\n\t\t\t\t&s.Process.Capabilities.Bounding,\n\t\t\t\t&s.Process.Capabilities.Effective,\n\t\t\t\t&s.Process.Capabilities.Permitted,\n\t\t\t} {\n\t\t\t\tremoveCap(cl, c)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithAmbientCapabilities set the Linux ambient capabilities for the process\n// Ambient capabilities should only be set for non-root users or the caller should\n// understand how these capabilities are used and set\nfunc WithAmbientCapabilities(caps []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetCapabilities(s)\n\t\ts.Process.Capabilities.Inheritable = caps\n\t\ts.Process.Capabilities.Ambient = caps\n\t\treturn nil\n\t}\n}\n\n// ErrNoUsersFound can be returned from UserFromPath\nvar ErrNoUsersFound = errors.New(\"no users found\")\n\n// UserFromPath inspects the user object using /etc/passwd in the specified rootfs.\n// filter can be nil.\nfunc UserFromPath(root string, filter func(user.User) bool) (user.User, error) {\n\tppath, err := fs.RootPath(root, \"/etc/passwd\")\n\tif err != nil {\n\t\treturn user.User{}, err\n\t}\n\tusers, err := user.ParsePasswdFileFilter(ppath, filter)\n\tif err != nil {\n\t\treturn user.User{}, err\n\t}\n\tif len(users) == 0 {\n\t\treturn user.User{}, ErrNoUsersFound\n\t}\n\treturn users[0], nil\n}\n\n// ErrNoGroupsFound can be returned from GIDFromPath\nvar ErrNoGroupsFound = errors.New(\"no groups found\")\n\n// GIDFromPath inspects the GID using /etc/group in the specified rootfs.\n// filter can be nil.\nfunc GIDFromPath(root string, filter func(user.Group) bool) (gid uint32, err error) {\n\tgpath, err := fs.RootPath(root, \"/etc/group\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tgroups, err := user.ParseGroupFileFilter(gpath, filter)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(groups) == 0 {\n\t\treturn 0, ErrNoGroupsFound\n\t}\n\tg := groups[0]\n\treturn uint32(g.Gid), nil\n}\n\nfunc getSupplementalGroupsFromPath(root string, filter func(user.Group) bool) ([]uint32, error) {\n\tgpath, err := fs.RootPath(root, \"/etc/group\")\n\tif err != nil {\n\t\treturn []uint32{}, err\n\t}\n\tgroups, err := user.ParseGroupFileFilter(gpath, filter)\n\tif err != nil {\n\t\treturn []uint32{}, err\n\t}\n\tif len(groups) == 0 {\n\t\t// if there are no additional groups; just return an empty set\n\t\treturn []uint32{}, nil\n\t}\n\taddlGids := []uint32{}\n\tfor _, grp := range groups {\n\t\taddlGids = append(addlGids, uint32(grp.Gid))\n\t}\n\treturn addlGids, nil\n}\n\nfunc isRootfsAbs(root string) bool {\n\treturn filepath.IsAbs(root)\n}\n\n// WithMaskedPaths sets the masked paths option\nfunc WithMaskedPaths(paths []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.MaskedPaths = paths\n\t\treturn nil\n\t}\n}\n\n// WithReadonlyPaths sets the read only paths option\nfunc WithReadonlyPaths(paths []string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.ReadonlyPaths = paths\n\t\treturn nil\n\t}\n}\n\n// WithWriteableSysfs makes any sysfs mounts writeable\nfunc WithWriteableSysfs(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tfor _, m := range s.Mounts {\n\t\tif m.Type == \"sysfs\" {\n\t\t\tfor i, o := range m.Options {\n\t\t\t\tif o == \"ro\" {\n\t\t\t\t\tm.Options[i] = \"rw\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// WithWriteableCgroupfs makes any cgroup mounts writeable\nfunc WithWriteableCgroupfs(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tfor _, m := range s.Mounts {\n\t\tif m.Type == \"cgroup\" {\n\t\t\tfor i, o := range m.Options {\n\t\t\t\tif o == \"ro\" {\n\t\t\t\t\tm.Options[i] = \"rw\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// WithSelinuxLabel sets the process SELinux label\nfunc WithSelinuxLabel(label string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.SelinuxLabel = label\n\t\treturn nil\n\t}\n}\n\n// WithApparmorProfile sets the Apparmor profile for the process\nfunc WithApparmorProfile(profile string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetProcess(s)\n\t\ts.Process.ApparmorProfile = profile\n\t\treturn nil\n\t}\n}\n\n// WithSeccompUnconfined clears the seccomp profile\nfunc WithSeccompUnconfined(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\ts.Linux.Seccomp = nil\n\treturn nil\n}\n\n// WithParentCgroupDevices uses the default cgroup setup to inherit the container's parent cgroup's\n// allowed and denied devices\nfunc WithParentCgroupDevices(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t}\n\ts.Linux.Resources.Devices = nil\n\treturn nil\n}\n\n// WithAllDevicesAllowed permits READ WRITE MKNOD on all devices nodes for the container\nfunc WithAllDevicesAllowed(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t}\n\ts.Linux.Resources.Devices = []specs.LinuxDeviceCgroup{\n\t\t{\n\t\t\tAllow:  true,\n\t\t\tAccess: rwm,\n\t\t},\n\t}\n\treturn nil\n}\n\n// WithDefaultUnixDevices adds the default devices for unix such as /dev/null, /dev/random to\n// the container's resource cgroup spec\nfunc WithDefaultUnixDevices(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tsetLinux(s)\n\tif s.Linux.Resources == nil {\n\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t}\n\tintptr := func(i int64) *int64 {\n\t\treturn &i\n\t}\n\ts.Linux.Resources.Devices = append(s.Linux.Resources.Devices, []specs.LinuxDeviceCgroup{\n\t\t{\n\t\t\t// \"/dev/null\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(3),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/random\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(8),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/full\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(7),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/tty\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(5),\n\t\t\tMinor:  intptr(0),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/zero\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(5),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/urandom\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(1),\n\t\t\tMinor:  intptr(9),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"/dev/console\",\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(5),\n\t\t\tMinor:  intptr(1),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t// /dev/pts/ - pts namespaces are \"coming soon\"\n\t\t{\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(136),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t\t{\n\t\t\t// \"dev/ptmx\"\n\t\t\tType:   \"c\",\n\t\t\tMajor:  intptr(5),\n\t\t\tMinor:  intptr(2),\n\t\t\tAccess: rwm,\n\t\t\tAllow:  true,\n\t\t},\n\t}...)\n\treturn nil\n}\n\n// WithPrivileged sets up options for a privileged container\nvar WithPrivileged = Compose(\n\tWithAllCurrentCapabilities,\n\tWithMaskedPaths(nil),\n\tWithReadonlyPaths(nil),\n\tWithWriteableSysfs,\n\tWithWriteableCgroupfs,\n\tWithSelinuxLabel(\"\"),\n\tWithApparmorProfile(\"\"),\n\tWithSeccompUnconfined,\n)\n\n// WithWindowsHyperV sets the Windows.HyperV section for HyperV isolation of containers.\nfunc WithWindowsHyperV(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\tif s.Windows == nil {\n\t\ts.Windows = &specs.Windows{}\n\t}\n\tif s.Windows.HyperV == nil {\n\t\ts.Windows.HyperV = &specs.WindowsHyperV{}\n\t}\n\treturn nil\n}\n\n// WithMemoryLimit sets the `Linux.LinuxResources.Memory.Limit` section to the\n// `limit` specified if the `Linux` section is not `nil`. Additionally sets the\n// `Windows.WindowsResources.Memory.Limit` section if the `Windows` section is\n// not `nil`.\nfunc WithMemoryLimit(limit uint64) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tif s.Linux != nil {\n\t\t\tif s.Linux.Resources == nil {\n\t\t\t\ts.Linux.Resources = &specs.LinuxResources{}\n\t\t\t}\n\t\t\tif s.Linux.Resources.Memory == nil {\n\t\t\t\ts.Linux.Resources.Memory = &specs.LinuxMemory{}\n\t\t\t}\n\t\t\tl := int64(limit)\n\t\t\ts.Linux.Resources.Memory.Limit = &l\n\t\t}\n\t\tif s.Windows != nil {\n\t\t\tif s.Windows.Resources == nil {\n\t\t\t\ts.Windows.Resources = &specs.WindowsResources{}\n\t\t\t}\n\t\t\tif s.Windows.Resources.Memory == nil {\n\t\t\t\ts.Windows.Resources.Memory = &specs.WindowsMemoryResources{}\n\t\t\t}\n\t\t\ts.Windows.Resources.Memory.Limit = &limit\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithAnnotations appends or replaces the annotations on the spec with the\n// provided annotations\nfunc WithAnnotations(annotations map[string]string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tif s.Annotations == nil {\n\t\t\ts.Annotations = make(map[string]string)\n\t\t}\n\t\tfor k, v := range annotations {\n\t\t\ts.Annotations[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithLinuxDevices adds the provided linux devices to the spec\nfunc WithLinuxDevices(devices []specs.LinuxDevice) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\ts.Linux.Devices = append(s.Linux.Devices, devices...)\n\t\treturn nil\n\t}\n}\n\n// WithLinuxDevice adds the device specified by path to the spec\nfunc WithLinuxDevice(path, permissions string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tsetLinux(s)\n\t\tsetResources(s)\n\n\t\tdev, err := DeviceFromPath(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ts.Linux.Devices = append(s.Linux.Devices, *dev)\n\n\t\ts.Linux.Resources.Devices = append(s.Linux.Resources.Devices, specs.LinuxDeviceCgroup{\n\t\t\tType:   dev.Type,\n\t\t\tAllow:  true,\n\t\t\tMajor:  &dev.Major,\n\t\t\tMinor:  &dev.Minor,\n\t\t\tAccess: permissions,\n\t\t})\n\n\t\treturn nil\n\t}\n}\n\n// WithEnvFile adds environment variables from a file to the container's spec\nfunc WithEnvFile(path string) SpecOpts {\n\treturn func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tvar vars []string\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\tsc := bufio.NewScanner(f)\n\t\tfor sc.Scan() {\n\t\t\tvars = append(vars, sc.Text())\n\t\t}\n\t\tif err = sc.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn WithEnv(vars)(nil, nil, nil, s)\n\t}\n}\n\n// ErrNoShmMount is returned when there is no /dev/shm mount specified in the config\n// and an Opts was trying to set a configuration value on the mount.\nvar ErrNoShmMount = errors.New(\"no /dev/shm mount specified\")\n\n// WithDevShmSize sets the size of the /dev/shm mount for the container.\n//\n// The size value is specified in kb, kilobytes.\nfunc WithDevShmSize(kb int64) SpecOpts {\n\treturn func(ctx context.Context, _ Client, _ *containers.Container, s *Spec) error {\n\t\tfor i, m := range s.Mounts {\n\t\t\tif filepath.Clean(m.Destination) == \"/dev/shm\" && m.Source == \"shm\" && m.Type == \"tmpfs\" {\n\t\t\t\tfor i := 0; i < len(m.Options); i++ {\n\t\t\t\t\tif strings.HasPrefix(m.Options[i], \"size=\") {\n\t\t\t\t\t\tm.Options = append(m.Options[:i], m.Options[i+1:]...)\n\t\t\t\t\t\ti--\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.Mounts[i].Options = append(m.Options, fmt.Sprintf(\"size=%dk\", kb))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn ErrNoShmMount\n\t}\n}\n\n// tryReadonlyMounts is used by the options which are trying to get user/group\n// information from container's rootfs. Since the option does read operation\n// only, this helper will append ReadOnly mount option to prevent linux kernel\n// from syncing whole filesystem in umount syscall.\n//\n// TODO(fuweid):\n//\n// Currently, it only works for overlayfs. I think we can apply it to other\n// kinds of filesystem. Maybe we can return `ro` option by `snapshotter.Mount`\n// API, when the caller passes that experimental annotation\n// `containerd.io/snapshot/readonly.mount` something like that.\nfunc tryReadonlyMounts(mounts []mount.Mount) []mount.Mount {\n\tif len(mounts) == 1 && mounts[0].Type == \"overlay\" {\n\t\tmounts[0].Options = append(mounts[0].Options, \"ro\")\n\t}\n\treturn mounts\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage oci\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/containerd/containerd/containers\"\n\t\"github.com/containerd/containerd/pkg/testutil\"\n\t\"github.com/containerd/continuity/fs/fstest\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// nolint:gosec\nfunc TestWithUserID(t *testing.T) {\n\tt.Parallel()\n\n\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\nguest:x:405:100:guest:/dev/null:/sbin/nologin\n`\n\ttd := t.TempDir()\n\tapply := fstest.Apply(\n\t\tfstest.CreateDir(\"/etc\", 0777),\n\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n\t)\n\tif err := apply.Apply(td); err != nil {\n\t\tt.Fatalf(\"failed to apply: %v\", err)\n\t}\n\tc := containers.Container{ID: t.Name()}\n\ttestCases := []struct {\n\t\tuserID      uint32\n\t\texpectedUID uint32\n\t\texpectedGID uint32\n\t}{\n\t\t{\n\t\t\tuserID:      0,\n\t\t\texpectedUID: 0,\n\t\t\texpectedGID: 0,\n\t\t},\n\t\t{\n\t\t\tuserID:      405,\n\t\t\texpectedUID: 405,\n\t\t\texpectedGID: 100,\n\t\t},\n\t\t{\n\t\t\tuserID:      1000,\n\t\t\texpectedUID: 1000,\n\t\t\texpectedGID: 0,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(fmt.Sprintf(\"user %d\", testCase.userID), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ts := Spec{\n\t\t\t\tVersion: specs.Version,\n\t\t\t\tRoot: &specs.Root{\n\t\t\t\t\tPath: td,\n\t\t\t\t},\n\t\t\t\tLinux: &specs.Linux{},\n\t\t\t}\n\t\t\terr := WithUserID(testCase.userID)(context.Background(), nil, &c, &s)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n\t\t})\n\t}\n}\n\n// nolint:gosec\nfunc TestWithUsername(t *testing.T) {\n\tt.Parallel()\n\n\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\nguest:x:405:100:guest:/dev/null:/sbin/nologin\n`\n\ttd := t.TempDir()\n\tapply := fstest.Apply(\n\t\tfstest.CreateDir(\"/etc\", 0777),\n\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n\t)\n\tif err := apply.Apply(td); err != nil {\n\t\tt.Fatalf(\"failed to apply: %v\", err)\n\t}\n\tc := containers.Container{ID: t.Name()}\n\ttestCases := []struct {\n\t\tuser        string\n\t\texpectedUID uint32\n\t\texpectedGID uint32\n\t\terr         string\n\t}{\n\t\t{\n\t\t\tuser:        \"root\",\n\t\t\texpectedUID: 0,\n\t\t\texpectedGID: 0,\n\t\t},\n\t\t{\n\t\t\tuser:        \"guest\",\n\t\t\texpectedUID: 405,\n\t\t\texpectedGID: 100,\n\t\t},\n\t\t{\n\t\t\tuser: \"1000\",\n\t\t\terr:  \"no users found\",\n\t\t},\n\t\t{\n\t\t\tuser: \"unknown\",\n\t\t\terr:  \"no users found\",\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.user, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ts := Spec{\n\t\t\t\tVersion: specs.Version,\n\t\t\t\tRoot: &specs.Root{\n\t\t\t\t\tPath: td,\n\t\t\t\t},\n\t\t\t\tLinux: &specs.Linux{},\n\t\t\t}\n\t\t\terr := WithUsername(testCase.user)(context.Background(), nil, &c, &s)\n\t\t\tif err != nil {\n\t\t\t\tassert.EqualError(t, err, testCase.err)\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n\t\t})\n\t}\n\n}\n\n// nolint:gosec\nfunc TestWithAdditionalGIDs(t *testing.T) {\n\tt.Parallel()\n\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\n`\n\texpectedGroup := `root:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\n`\n\ttd := t.TempDir()\n\tapply := fstest.Apply(\n\t\tfstest.CreateDir(\"/etc\", 0777),\n\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedGroup), 0777),\n\t)\n\tif err := apply.Apply(td); err != nil {\n\t\tt.Fatalf(\"failed to apply: %v\", err)\n\t}\n\tc := containers.Container{ID: t.Name()}\n\n\ttestCases := []struct {\n\t\tuser     string\n\t\texpected []uint32\n\t}{\n\t\t{\n\t\t\tuser:     \"root\",\n\t\t\texpected: []uint32{0, 1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tuser:     \"1000\",\n\t\t\texpected: []uint32{0},\n\t\t},\n\t\t{\n\t\t\tuser:     \"bin\",\n\t\t\texpected: []uint32{0, 2, 3},\n\t\t},\n\t\t{\n\t\t\tuser:     \"bin:root\",\n\t\t\texpected: []uint32{0},\n\t\t},\n\t\t{\n\t\t\tuser:     \"daemon\",\n\t\t\texpected: []uint32{0, 1},\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.user, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ts := Spec{\n\t\t\t\tVersion: specs.Version,\n\t\t\t\tRoot: &specs.Root{\n\t\t\t\t\tPath: td,\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := WithAdditionalGIDs(testCase.user)(context.Background(), nil, &c, &s)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, testCase.expected, s.Process.User.AdditionalGids)\n\t\t})\n\t}\n}\n\nfunc TestAddCaps(t *testing.T) {\n\tt.Parallel()\n\n\tvar s specs.Spec\n\n\tif err := WithAddedCapabilities([]string{\"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif !capsContain(cl, \"CAP_CHOWN\") {\n\t\t\tt.Errorf(\"cap list %d does not contain added cap\", i)\n\t\t}\n\t}\n}\n\nfunc TestDropCaps(t *testing.T) {\n\tt.Parallel()\n\n\tvar s specs.Spec\n\n\tif err := WithAllKnownCapabilities(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := WithDroppedCapabilities([]string{\"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif capsContain(cl, \"CAP_CHOWN\") {\n\t\t\tt.Errorf(\"cap list %d contains dropped cap\", i)\n\t\t}\n\t}\n\n\t// Add all capabilities back and drop a different cap.\n\tif err := WithAllKnownCapabilities(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := WithDroppedCapabilities([]string{\"CAP_FOWNER\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif capsContain(cl, \"CAP_FOWNER\") {\n\t\t\tt.Errorf(\"cap list %d contains dropped cap\", i)\n\t\t}\n\t\tif !capsContain(cl, \"CAP_CHOWN\") {\n\t\t\tt.Errorf(\"cap list %d doesn't contain non-dropped cap\", i)\n\t\t}\n\t}\n\n\t// Drop all duplicated caps.\n\tif err := WithCapabilities([]string{\"CAP_CHOWN\", \"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := WithDroppedCapabilities([]string{\"CAP_CHOWN\"})(context.Background(), nil, nil, &s); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i, cl := range [][]string{\n\t\ts.Process.Capabilities.Bounding,\n\t\ts.Process.Capabilities.Effective,\n\t\ts.Process.Capabilities.Permitted,\n\t} {\n\t\tif len(cl) != 0 {\n\t\t\tt.Errorf(\"cap list %d is not empty\", i)\n\t\t}\n\t}\n}\n\nfunc TestGetDevices(t *testing.T) {\n\ttestutil.RequiresRoot(t)\n\n\tdir, err := os.MkdirTemp(\"/dev\", t.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dir)\n\n\tzero := filepath.Join(dir, \"zero\")\n\tif err := os.WriteFile(zero, nil, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := unix.Mount(\"/dev/zero\", zero, \"\", unix.MS_BIND, \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer unix.Unmount(filepath.Join(dir, \"zero\"), unix.MNT_DETACH)\n\n\tt.Run(\"single device\", func(t *testing.T) {\n\t\tt.Run(\"no container path\", func(t *testing.T) {\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(devices) != 1 {\n\t\t\t\tt.Fatalf(\"expected one device %v\", devices)\n\t\t\t}\n\t\t\tif devices[0].Path != zero {\n\t\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[0].Path)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"with container path\", func(t *testing.T) {\n\t\t\tnewPath := \"/dev/testNew\"\n\t\t\tdevices, err := getDevices(dir, newPath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(devices) != 1 {\n\t\t\t\tt.Fatalf(\"expected one device %v\", devices)\n\t\t\t}\n\t\t\tif devices[0].Path != filepath.Join(newPath, \"zero\") {\n\t\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[0].Path)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"two devices\", func(t *testing.T) {\n\t\tnullDev := filepath.Join(dir, \"null\")\n\t\tif err := os.WriteFile(nullDev, nil, 0600); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := unix.Mount(\"/dev/null\", nullDev, \"\", unix.MS_BIND, \"\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer unix.Unmount(filepath.Join(dir, \"null\"), unix.MNT_DETACH)\n\t\tdevices, err := getDevices(dir, \"\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(devices) != 2 {\n\t\t\tt.Fatalf(\"expected two devices %v\", devices)\n\t\t}\n\t\tif devices[0].Path == devices[1].Path {\n\t\t\tt.Fatalf(\"got same path for the two devices %s\", devices[0].Path)\n\t\t}\n\t\tif devices[0].Path != zero && devices[0].Path != nullDev {\n\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[0].Path)\n\t\t}\n\t\tif devices[1].Path != zero && devices[1].Path != nullDev {\n\t\t\tt.Fatalf(\"got unexpected device path %s\", devices[1].Path)\n\t\t}\n\t\tif devices[0].Major == devices[1].Major && devices[0].Minor == devices[1].Minor {\n\t\t\tt.Fatalf(\"got sema mojor and minor on two devices %s %s\", devices[0].Path, devices[1].Path)\n\t\t}\n\t})\n\tt.Run(\"With symlink in dir\", func(t *testing.T) {\n\t\tif err := os.Symlink(\"/dev/zero\", filepath.Join(dir, \"zerosym\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdevices, err := getDevices(dir, \"\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(devices) != 1 {\n\t\t\tt.Fatalf(\"expected one device %v\", devices)\n\t\t}\n\t\tif devices[0].Path != filepath.Join(dir, \"zero\") {\n\t\t\tt.Fatalf(\"got unexpected device path, expected %q, got %q\", filepath.Join(dir, \"zero\"), devices[0].Path)\n\t\t}\n\t})\n\tt.Run(\"No devices\", func(t *testing.T) {\n\t\tdir := dir + \"2\"\n\t\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer os.RemoveAll(dir)\n\n\t\tt.Run(\"empty dir\", func(T *testing.T) {\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(devices) != 0 {\n\t\t\t\tt.Fatalf(\"expected no devices, got %+v\", devices)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"symlink to device in dir\", func(t *testing.T) {\n\t\t\tif err := os.Symlink(\"/dev/zero\", filepath.Join(dir, \"zerosym\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer os.Remove(filepath.Join(dir, \"zerosym\"))\n\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(devices) != 0 {\n\t\t\t\tt.Fatalf(\"expected no devices, got %+v\", devices)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"regular file in dir\", func(t *testing.T) {\n\t\t\tif err := os.WriteFile(filepath.Join(dir, \"somefile\"), []byte(\"hello\"), 0600); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer os.Remove(filepath.Join(dir, \"somefile\"))\n\n\t\t\tdevices, err := getDevices(dir, \"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(devices) != 0 {\n\t\t\t\tt.Fatalf(\"expected no devices, got %+v\", devices)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestWithAppendAdditionalGroups(t *testing.T) {\n\tt.Parallel()\n\texpectedContent := `root:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\n`\n\ttd := t.TempDir()\n\tapply := fstest.Apply(\n\t\tfstest.CreateDir(\"/etc\", 0777),\n\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedContent), 0777),\n\t)\n\tif err := apply.Apply(td); err != nil {\n\t\tt.Fatalf(\"failed to apply: %v\", err)\n\t}\n\tc := containers.Container{ID: t.Name()}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tadditionalGIDs []uint32\n\t\tgroups         []string\n\t\texpected       []uint32\n\t\terr            string\n\t}{\n\t\t{\n\t\t\tname:     \"no additional gids\",\n\t\t\tgroups:   []string{},\n\t\t\texpected: []uint32{0},\n\t\t},\n\t\t{\n\t\t\tname:     \"no additional gids, append root gid\",\n\t\t\tgroups:   []string{\"root\"},\n\t\t\texpected: []uint32{0},\n\t\t},\n\t\t{\n\t\t\tname:     \"no additional gids, append bin and daemon gids\",\n\t\t\tgroups:   []string{\"bin\", \"daemon\"},\n\t\t\texpected: []uint32{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname:           \"has root additional gids, append bin and daemon gids\",\n\t\t\tadditionalGIDs: []uint32{0},\n\t\t\tgroups:         []string{\"bin\", \"daemon\"},\n\t\t\texpected:       []uint32{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"append group id\",\n\t\t\tgroups:   []string{\"999\"},\n\t\t\texpected: []uint32{0, 999},\n\t\t},\n\t\t{\n\t\t\tname:     \"unknown group\",\n\t\t\tgroups:   []string{\"unknown\"},\n\t\t\terr:      \"unable to find group unknown\",\n\t\t\texpected: []uint32{0},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ts := Spec{\n\t\t\t\tVersion: specs.Version,\n\t\t\t\tRoot: &specs.Root{\n\t\t\t\t\tPath: td,\n\t\t\t\t},\n\t\t\t\tProcess: &specs.Process{\n\t\t\t\t\tUser: specs.User{\n\t\t\t\t\t\tAdditionalGids: testCase.additionalGIDs,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := WithAppendAdditionalGroups(testCase.groups...)(context.Background(), nil, &c, &s)\n\t\t\tif err != nil {\n\t\t\t\tassert.EqualError(t, err, testCase.err)\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expected, s.Process.User.AdditionalGids)\n\t\t})\n\t}\n}\n", "/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage server\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/containerd/cgroups\"\n\t\"github.com/containerd/containerd/contrib/apparmor\"\n\t\"github.com/containerd/containerd/contrib/seccomp\"\n\t\"github.com/containerd/containerd/oci\"\n\timagespec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\truntimespec \"github.com/opencontainers/runtime-spec/specs-go\"\n\tselinux \"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\truntime \"k8s.io/cri-api/pkg/apis/runtime/v1\"\n\n\t\"github.com/containerd/containerd/pkg/cri/annotations\"\n\t\"github.com/containerd/containerd/pkg/cri/config\"\n\tcustomopts \"github.com/containerd/containerd/pkg/cri/opts\"\n)\n\nconst (\n\t// profileNamePrefix is the prefix for loading profiles on a localhost. Eg. AppArmor localhost/profileName.\n\tprofileNamePrefix = \"localhost/\" // TODO (mikebrow): get localhost/ & runtime/default from CRI kubernetes/kubernetes#51747\n\t// runtimeDefault indicates that we should use or create a runtime default profile.\n\truntimeDefault = \"runtime/default\"\n\t// dockerDefault indicates that we should use or create a docker default profile.\n\tdockerDefault = \"docker/default\"\n\t// appArmorDefaultProfileName is name to use when creating a default apparmor profile.\n\tappArmorDefaultProfileName = \"cri-containerd.apparmor.d\"\n\t// unconfinedProfile is a string indicating one should run a pod/containerd without a security profile\n\tunconfinedProfile = \"unconfined\"\n\t// seccompDefaultProfile is the default seccomp profile.\n\tseccompDefaultProfile = dockerDefault\n)\n\n// containerMounts sets up necessary container system file mounts\n// including /dev/shm, /etc/hosts and /etc/resolv.conf.\nfunc (c *criService) containerMounts(sandboxID string, config *runtime.ContainerConfig) []*runtime.Mount {\n\tvar mounts []*runtime.Mount\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tif !isInCRIMounts(etcHostname, config.GetMounts()) {\n\t\t// /etc/hostname is added since 1.1.6, 1.2.4 and 1.3.\n\t\t// For in-place upgrade, the old sandbox doesn't have the hostname file,\n\t\t// do not mount this in that case.\n\t\t// TODO(random-liu): Remove the check and always mount this when\n\t\t// containerd 1.1 and 1.2 are deprecated.\n\t\thostpath := c.getSandboxHostname(sandboxID)\n\t\tif _, err := c.os.Stat(hostpath); err == nil {\n\t\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\t\tContainerPath:  etcHostname,\n\t\t\t\tHostPath:       hostpath,\n\t\t\t\tReadonly:       securityContext.GetReadonlyRootfs(),\n\t\t\t\tSelinuxRelabel: true,\n\t\t\t})\n\t\t}\n\t}\n\n\tif !isInCRIMounts(etcHosts, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  etcHosts,\n\t\t\tHostPath:       c.getSandboxHosts(sandboxID),\n\t\t\tReadonly:       securityContext.GetReadonlyRootfs(),\n\t\t\tSelinuxRelabel: true,\n\t\t})\n\t}\n\n\t// Mount sandbox resolv.config.\n\t// TODO: Need to figure out whether we should always mount it as read-only\n\tif !isInCRIMounts(resolvConfPath, config.GetMounts()) {\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  resolvConfPath,\n\t\t\tHostPath:       c.getResolvPath(sandboxID),\n\t\t\tReadonly:       securityContext.GetReadonlyRootfs(),\n\t\t\tSelinuxRelabel: true,\n\t\t})\n\t}\n\n\tif !isInCRIMounts(devShm, config.GetMounts()) {\n\t\tsandboxDevShm := c.getSandboxDevShm(sandboxID)\n\t\tif securityContext.GetNamespaceOptions().GetIpc() == runtime.NamespaceMode_NODE {\n\t\t\tsandboxDevShm = devShm\n\t\t}\n\t\tmounts = append(mounts, &runtime.Mount{\n\t\t\tContainerPath:  devShm,\n\t\t\tHostPath:       sandboxDevShm,\n\t\t\tReadonly:       false,\n\t\t\tSelinuxRelabel: sandboxDevShm != devShm,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc (c *criService) containerSpec(\n\tid string,\n\tsandboxID string,\n\tsandboxPid uint32,\n\tnetNSPath string,\n\tcontainerName string,\n\timageName string,\n\tconfig *runtime.ContainerConfig,\n\tsandboxConfig *runtime.PodSandboxConfig,\n\timageConfig *imagespec.ImageConfig,\n\textraMounts []*runtime.Mount,\n\tociRuntime config.Runtime,\n) (_ *runtimespec.Spec, retErr error) {\n\tspecOpts := []oci.SpecOpts{\n\t\toci.WithoutRunMount,\n\t}\n\t// only clear the default security settings if the runtime does not have a custom\n\t// base runtime spec spec.  Admins can use this functionality to define\n\t// default ulimits, seccomp, or other default settings.\n\tif ociRuntime.BaseRuntimeSpec == \"\" {\n\t\tspecOpts = append(specOpts, customopts.WithoutDefaultSecuritySettings)\n\t}\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithRelativeRoot(relativeRootfsPath),\n\t\tcustomopts.WithProcessArgs(config, imageConfig),\n\t\toci.WithDefaultPathEnv,\n\t\t// this will be set based on the security context below\n\t\toci.WithNewPrivileges,\n\t)\n\tif config.GetWorkingDir() != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(config.GetWorkingDir()))\n\t} else if imageConfig.WorkingDir != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithProcessCwd(imageConfig.WorkingDir))\n\t}\n\n\tif config.GetTty() {\n\t\tspecOpts = append(specOpts, oci.WithTTY)\n\t}\n\n\t// Add HOSTNAME env.\n\tvar (\n\t\terr      error\n\t\thostname = sandboxConfig.GetHostname()\n\t)\n\tif hostname == \"\" {\n\t\tif hostname, err = c.os.Hostname(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv([]string{hostnameEnv + \"=\" + hostname}))\n\n\t// Apply envs from image config first, so that envs from container config\n\t// can override them.\n\tenv := append([]string{}, imageConfig.Env...)\n\tfor _, e := range config.GetEnvs() {\n\t\tenv = append(env, e.GetKey()+\"=\"+e.GetValue())\n\t}\n\tspecOpts = append(specOpts, oci.WithEnv(env))\n\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\tlabelOptions, err := toLabel(securityContext.GetSelinuxOptions())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(labelOptions) == 0 {\n\t\t// Use pod level SELinux config\n\t\tif sandbox, err := c.sandboxStore.Get(sandboxID); err == nil {\n\t\t\tlabelOptions, err = selinux.DupSecOpt(sandbox.ProcessLabel)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tprocessLabel, mountLabel, err := label.InitLabels(labelOptions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to init selinux options %+v: %w\", securityContext.GetSelinuxOptions(), err)\n\t}\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\t_ = label.ReleaseLabel(processLabel)\n\t\t}\n\t}()\n\n\tspecOpts = append(specOpts, customopts.WithMounts(c.os, config, extraMounts, mountLabel))\n\n\tif !c.config.DisableProcMount {\n\t\t// Change the default masked/readonly paths to empty slices\n\t\t// See https://github.com/containerd/containerd/issues/5029\n\t\t// TODO: Provide an option to set default paths to the ones in oci.populateDefaultUnixSpec()\n\t\tspecOpts = append(specOpts, oci.WithMaskedPaths([]string{}), oci.WithReadonlyPaths([]string{}))\n\n\t\t// Apply masked paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif maskedPaths := securityContext.GetMaskedPaths(); maskedPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithMaskedPaths(maskedPaths))\n\t\t}\n\n\t\t// Apply readonly paths if specified.\n\t\t// If the container is privileged, this will be cleared later on.\n\t\tif readonlyPaths := securityContext.GetReadonlyPaths(); readonlyPaths != nil {\n\t\t\tspecOpts = append(specOpts, oci.WithReadonlyPaths(readonlyPaths))\n\t\t}\n\t}\n\n\tspecOpts = append(specOpts, customopts.WithDevices(c.os, config, c.config.DeviceOwnershipFromSecurityContext),\n\t\tcustomopts.WithCapabilities(securityContext, c.allCaps))\n\n\tif securityContext.GetPrivileged() {\n\t\tif !sandboxConfig.GetLinux().GetSecurityContext().GetPrivileged() {\n\t\t\treturn nil, errors.New(\"no privileged container allowed in sandbox\")\n\t\t}\n\t\tspecOpts = append(specOpts, oci.WithPrivileged)\n\t\tif !ociRuntime.PrivilegedWithoutHostDevices {\n\t\t\tspecOpts = append(specOpts, oci.WithHostDevices, oci.WithAllDevicesAllowed)\n\t\t}\n\t}\n\n\t// Clear all ambient capabilities. The implication of non-root + caps\n\t// is not clearly defined in Kubernetes.\n\t// See https://github.com/kubernetes/kubernetes/issues/56374\n\t// Keep docker's behavior for now.\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithoutAmbientCaps,\n\t\tcustomopts.WithSelinuxLabels(processLabel, mountLabel),\n\t)\n\n\t// TODO: Figure out whether we should set no new privilege for sandbox container by default\n\tif securityContext.GetNoNewPrivs() {\n\t\tspecOpts = append(specOpts, oci.WithNoNewPrivileges)\n\t}\n\t// TODO(random-liu): [P1] Set selinux options (privileged or not).\n\tif securityContext.GetReadonlyRootfs() {\n\t\tspecOpts = append(specOpts, oci.WithRootFSReadonly())\n\t}\n\n\tif c.config.DisableCgroup {\n\t\tspecOpts = append(specOpts, customopts.WithDisabledCgroups)\n\t} else {\n\t\tspecOpts = append(specOpts, customopts.WithResources(config.GetLinux().GetResources(), c.config.TolerateMissingHugetlbController, c.config.DisableHugetlbController))\n\t\tif sandboxConfig.GetLinux().GetCgroupParent() != \"\" {\n\t\t\tcgroupsPath := getCgroupsPath(sandboxConfig.GetLinux().GetCgroupParent(), id)\n\t\t\tspecOpts = append(specOpts, oci.WithCgroup(cgroupsPath))\n\t\t}\n\t}\n\n\tsupplementalGroups := securityContext.GetSupplementalGroups()\n\n\t// Get RDT class\n\trdtClass, err := c.rdtClassFromAnnotations(config.GetMetadata().GetName(), config.Annotations, sandboxConfig.Annotations)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to set RDT class: %w\", err)\n\t}\n\tif rdtClass != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithRdt(rdtClass, \"\", \"\"))\n\t}\n\n\tfor pKey, pValue := range getPassthroughAnnotations(sandboxConfig.Annotations,\n\t\tociRuntime.PodAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\tfor pKey, pValue := range getPassthroughAnnotations(config.Annotations,\n\t\tociRuntime.ContainerAnnotations) {\n\t\tspecOpts = append(specOpts, customopts.WithAnnotation(pKey, pValue))\n\t}\n\n\t// Default target PID namespace is the sandbox PID.\n\ttargetPid := sandboxPid\n\t// If the container targets another container's PID namespace,\n\t// set targetPid to the PID of that container.\n\tnsOpts := securityContext.GetNamespaceOptions()\n\tif nsOpts.GetPid() == runtime.NamespaceMode_TARGET {\n\t\ttargetContainer, err := c.validateTargetContainer(sandboxID, nsOpts.TargetId)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid target container: %w\", err)\n\t\t}\n\n\t\tstatus := targetContainer.Status.Get()\n\t\ttargetPid = status.Pid\n\t}\n\n\tspecOpts = append(specOpts,\n\t\tcustomopts.WithOOMScoreAdj(config, c.config.RestrictOOMScoreAdj),\n\t\tcustomopts.WithPodNamespaces(securityContext, sandboxPid, targetPid),\n\t\tcustomopts.WithSupplementalGroups(supplementalGroups),\n\t\tcustomopts.WithAnnotation(annotations.ContainerType, annotations.ContainerTypeContainer),\n\t\tcustomopts.WithAnnotation(annotations.SandboxID, sandboxID),\n\t\tcustomopts.WithAnnotation(annotations.SandboxNamespace, sandboxConfig.GetMetadata().GetNamespace()),\n\t\tcustomopts.WithAnnotation(annotations.SandboxUID, sandboxConfig.GetMetadata().GetUid()),\n\t\tcustomopts.WithAnnotation(annotations.SandboxName, sandboxConfig.GetMetadata().GetName()),\n\t\tcustomopts.WithAnnotation(annotations.ContainerName, containerName),\n\t\tcustomopts.WithAnnotation(annotations.ImageName, imageName),\n\t)\n\t// cgroupns is used for hiding /sys/fs/cgroup from containers.\n\t// For compatibility, cgroupns is not used when running in cgroup v1 mode or in privileged.\n\t// https://github.com/containers/libpod/issues/4363\n\t// https://github.com/kubernetes/enhancements/blob/0e409b47497e398b369c281074485c8de129694f/keps/sig-node/20191118-cgroups-v2.md#cgroup-namespace\n\tif cgroups.Mode() == cgroups.Unified && !securityContext.GetPrivileged() {\n\t\tspecOpts = append(specOpts, oci.WithLinuxNamespace(\n\t\t\truntimespec.LinuxNamespace{\n\t\t\t\tType: runtimespec.CgroupNamespace,\n\t\t\t}))\n\t}\n\treturn c.runtimeSpec(id, ociRuntime.BaseRuntimeSpec, specOpts...)\n}\n\nfunc (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageConfig *imagespec.ImageConfig) ([]oci.SpecOpts, error) {\n\tvar specOpts []oci.SpecOpts\n\tsecurityContext := config.GetLinux().GetSecurityContext()\n\t// Set container username. This could only be done by containerd, because it needs\n\t// access to the container rootfs. Pass user name to containerd, and let it overwrite\n\t// the spec for us.\n\tuserstr, err := generateUserString(\n\t\tsecurityContext.GetRunAsUsername(),\n\t\tsecurityContext.GetRunAsUser(),\n\t\tsecurityContext.GetRunAsGroup())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate user string: %w\", err)\n\t}\n\tif userstr == \"\" {\n\t\t// Lastly, since no user override was passed via CRI try to set via OCI\n\t\t// Image\n\t\tuserstr = imageConfig.User\n\t}\n\tif userstr != \"\" {\n\t\tspecOpts = append(specOpts, oci.WithUser(userstr))\n\t}\n\n\tif securityContext.GetRunAsUsername() != \"\" {\n\t\tuserstr = securityContext.GetRunAsUsername()\n\t} else {\n\t\t// Even if RunAsUser is not set, we still call `GetValue` to get uid 0.\n\t\t// Because it is still useful to get additional gids for uid 0.\n\t\tuserstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)\n\t}\n\tspecOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr),\n\t\tcustomopts.WithSupplementalGroups(securityContext.GetSupplementalGroups()))\n\n\tasp := securityContext.GetApparmor()\n\tif asp == nil {\n\t\tasp, err = generateApparmorSecurityProfile(securityContext.GetApparmorProfile()) //nolint:staticcheck // Deprecated but we don't want to remove yet\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to generate apparmor spec opts: %w\", err)\n\t\t}\n\t}\n\tapparmorSpecOpts, err := generateApparmorSpecOpts(\n\t\tasp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.apparmorEnabled())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate apparmor spec opts: %w\", err)\n\t}\n\tif apparmorSpecOpts != nil {\n\t\tspecOpts = append(specOpts, apparmorSpecOpts)\n\t}\n\n\tssp := securityContext.GetSeccomp()\n\tif ssp == nil {\n\t\tssp, err = generateSeccompSecurityProfile(\n\t\t\tsecurityContext.GetSeccompProfilePath(), //nolint:staticcheck // Deprecated but we don't want to remove yet\n\t\t\tc.config.UnsetSeccompProfile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to generate seccomp spec opts: %w\", err)\n\t\t}\n\t}\n\tseccompSpecOpts, err := c.generateSeccompSpecOpts(\n\t\tssp,\n\t\tsecurityContext.GetPrivileged(),\n\t\tc.seccompEnabled())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate seccomp spec opts: %w\", err)\n\t}\n\tif seccompSpecOpts != nil {\n\t\tspecOpts = append(specOpts, seccompSpecOpts)\n\t}\n\treturn specOpts, nil\n}\n\nfunc generateSeccompSecurityProfile(profilePath string, unsetProfilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\tif unsetProfilePath != \"\" {\n\t\treturn generateSecurityProfile(unsetProfilePath)\n\t}\n\treturn nil, nil\n}\nfunc generateApparmorSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tif profilePath != \"\" {\n\t\treturn generateSecurityProfile(profilePath)\n\t}\n\treturn nil, nil\n}\n\nfunc generateSecurityProfile(profilePath string) (*runtime.SecurityProfile, error) {\n\tswitch profilePath {\n\tcase runtimeDefault, dockerDefault, \"\":\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_RuntimeDefault,\n\t\t}, nil\n\tcase unconfinedProfile:\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType: runtime.SecurityProfile_Unconfined,\n\t\t}, nil\n\tdefault:\n\t\t// Require and Trim default profile name prefix\n\t\tif !strings.HasPrefix(profilePath, profileNamePrefix) {\n\t\t\treturn nil, fmt.Errorf(\"invalid profile %q\", profilePath)\n\t\t}\n\t\treturn &runtime.SecurityProfile{\n\t\t\tProfileType:  runtime.SecurityProfile_Localhost,\n\t\t\tLocalhostRef: strings.TrimPrefix(profilePath, profileNamePrefix),\n\t\t}, nil\n\t}\n}\n\n// generateSeccompSpecOpts generates containerd SpecOpts for seccomp.\nfunc (c *criService) generateSeccompSpecOpts(sp *runtime.SecurityProfile, privileged, seccompEnabled bool) (oci.SpecOpts, error) {\n\tif privileged {\n\t\t// Do not set seccomp profile when container is privileged\n\t\treturn nil, nil\n\t}\n\tif !seccompEnabled {\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"seccomp is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\treturn nil, nil\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"seccomp config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set seccomp profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\treturn seccomp.WithDefaultProfile(), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even though it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\treturn seccomp.WithProfile(strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)), nil\n\tdefault:\n\t\treturn nil, errors.New(\"seccomp unknown ProfileType\")\n\t}\n}\n\n// generateApparmorSpecOpts generates containerd SpecOpts for apparmor.\nfunc generateApparmorSpecOpts(sp *runtime.SecurityProfile, privileged, apparmorEnabled bool) (oci.SpecOpts, error) {\n\tif !apparmorEnabled {\n\t\t// Should fail loudly if user try to specify apparmor profile\n\t\t// but we don't support it.\n\t\tif sp != nil {\n\t\t\tif sp.ProfileType != runtime.SecurityProfile_Unconfined {\n\t\t\t\treturn nil, errors.New(\"apparmor is not supported\")\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tif sp == nil {\n\t\t// Based on kubernetes#51746, default apparmor profile should be applied\n\t\t// for when apparmor is not specified.\n\t\tsp, _ = generateSecurityProfile(\"\")\n\t}\n\n\tif sp.ProfileType != runtime.SecurityProfile_Localhost && sp.LocalhostRef != \"\" {\n\t\treturn nil, errors.New(\"apparmor config invalid LocalhostRef must only be set if ProfileType is Localhost\")\n\t}\n\n\tswitch sp.ProfileType {\n\tcase runtime.SecurityProfile_Unconfined:\n\t\t// Do not set apparmor profile.\n\t\treturn nil, nil\n\tcase runtime.SecurityProfile_RuntimeDefault:\n\t\tif privileged {\n\t\t\t// Do not set apparmor profile when container is privileged\n\t\t\treturn nil, nil\n\t\t}\n\t\t// TODO (mikebrow): delete created apparmor default profile\n\t\treturn apparmor.WithDefaultProfile(appArmorDefaultProfileName), nil\n\tcase runtime.SecurityProfile_Localhost:\n\t\t// trimming the localhost/ prefix just in case even through it should not\n\t\t// be necessary with the new SecurityProfile struct\n\t\tappArmorProfile := strings.TrimPrefix(sp.LocalhostRef, profileNamePrefix)\n\t\tif profileExists, err := appArmorProfileExists(appArmorProfile); !profileExists {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to generate apparmor spec opts: %w\", err)\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"apparmor profile not found %s\", appArmorProfile)\n\t\t}\n\t\treturn apparmor.WithProfile(appArmorProfile), nil\n\tdefault:\n\t\treturn nil, errors.New(\"apparmor unknown ProfileType\")\n\t}\n}\n\n// appArmorProfileExists scans apparmor/profiles for the requested profile\nfunc appArmorProfileExists(profile string) (bool, error) {\n\tif profile == \"\" {\n\t\treturn false, errors.New(\"nil apparmor profile is not supported\")\n\t}\n\tprofiles, err := os.Open(\"/sys/kernel/security/apparmor/profiles\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer profiles.Close()\n\n\trbuff := bufio.NewReader(profiles)\n\tfor {\n\t\tline, err := rbuff.ReadString('\\n')\n\t\tswitch err {\n\t\tcase nil:\n\t\t\tif strings.HasPrefix(line, profile+\" (\") {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase io.EOF:\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\treturn false, err\n\t\t}\n\t}\n}\n\n// generateUserString generates valid user string based on OCI Image Spec\n// v1.0.0.\n//\n// CRI defines that the following combinations are valid:\n//\n// (none) -> \"\"\n// username -> username\n// username, uid -> username\n// username, uid, gid -> username:gid\n// username, gid -> username:gid\n// uid -> uid\n// uid, gid -> uid:gid\n// gid -> error\n//\n// TODO(random-liu): Add group name support in CRI.\nfunc generateUserString(username string, uid, gid *runtime.Int64Value) (string, error) {\n\tvar userstr, groupstr string\n\tif uid != nil {\n\t\tuserstr = strconv.FormatInt(uid.GetValue(), 10)\n\t}\n\tif username != \"\" {\n\t\tuserstr = username\n\t}\n\tif gid != nil {\n\t\tgroupstr = strconv.FormatInt(gid.GetValue(), 10)\n\t}\n\tif userstr == \"\" {\n\t\tif groupstr != \"\" {\n\t\t\treturn \"\", fmt.Errorf(\"user group %q is specified without user\", groupstr)\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tif groupstr != \"\" {\n\t\tuserstr = userstr + \":\" + groupstr\n\t}\n\treturn userstr, nil\n}\n"], "filenames": ["integration/addition_gids_test.go", "integration/main_test.go", "oci/spec_opts.go", "oci/spec_opts_linux_test.go", "pkg/cri/server/container_create_linux.go"], "buggy_code_start_loc": [22, 313, 115, 20, 351], "buggy_code_end_loc": [79, 313, 911, 249, 352], "fixing_code_start_loc": [23, 314, 116, 21, 351], "fixing_code_end_loc": [129, 353, 977, 519, 353], "type": "CWE-863", "message": "containerd is an open source container runtime. A bug was found in containerd prior to versions 1.6.18 and 1.5.18 where supplementary groups are not set up properly inside a container. If an attacker has direct access to a container and manipulates their supplementary group access, they may be able to use supplementary group access to bypass primary group restrictions in some cases, potentially gaining access to sensitive information or gaining the ability to execute code in that container. Downstream applications that use the containerd client library may be affected as well. This bug has been fixed in containerd v1.6.18 and v.1.5.18. Users should update to these versions and recreate containers to resolve this issue. Users who rely on a downstream application that uses containerd's client library should check that application for a separate advisory and instructions. As a workaround, ensure that the `\"USER $USERNAME\"` Dockerfile instruction is not used. Instead, set the container entrypoint to a value similar to `ENTRYPOINT [\"su\", \"-\", \"user\"]` to allow `su` to properly set up supplementary groups.", "other": {"cve": {"id": "CVE-2023-25173", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-16T15:15:20.057", "lastModified": "2023-02-24T16:56:30.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "containerd is an open source container runtime. A bug was found in containerd prior to versions 1.6.18 and 1.5.18 where supplementary groups are not set up properly inside a container. If an attacker has direct access to a container and manipulates their supplementary group access, they may be able to use supplementary group access to bypass primary group restrictions in some cases, potentially gaining access to sensitive information or gaining the ability to execute code in that container. Downstream applications that use the containerd client library may be affected as well. This bug has been fixed in containerd v1.6.18 and v.1.5.18. Users should update to these versions and recreate containers to resolve this issue. Users who rely on a downstream application that uses containerd's client library should check that application for a separate advisory and instructions. As a workaround, ensure that the `\"USER $USERNAME\"` Dockerfile instruction is not used. Instead, set the container entrypoint to a value similar to `ENTRYPOINT [\"su\", \"-\", \"user\"]` to allow `su` to properly set up supplementary groups."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.18", "matchCriteriaId": "4C98A2DA-3CDD-4438-AECC-DDDA67E61935"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:containerd:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.6.0", "versionEndExcluding": "1.6.18", "matchCriteriaId": "BDD5FC3E-BEEB-4CAA-845E-3BADF39E46B2"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-4wjj-jwc9-2x96", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/advisories/GHSA-fjm8-m7m6-2fjp", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/advisories/GHSA-phjr-8j92-w5v7", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/containerd/containerd/commit/133f6bb6cd827ce35a5fb279c1ead12b9d21460a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/containerd/containerd/releases/tag/v1.5.18", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/containerd/containerd/releases/tag/v1.6.18", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/containerd/containerd/security/advisories/GHSA-hmfx-3pcx-653p", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}, {"url": "https://github.com/moby/moby/security/advisories/GHSA-rc4r-wh2q-q6c4", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://www.benthamsgaze.org/2022/08/22/vulnerability-in-linux-containers-investigation-and-mitigation/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containerd/containerd/commit/133f6bb6cd827ce35a5fb279c1ead12b9d21460a"}}