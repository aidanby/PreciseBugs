{"buggy_code": ["Changes\n=======\n\n7.0 (unreleased)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 3.6.\n\nFeatures\n++++++++\n\n- Allow to use the package with Python 3.12 -- Caution: No security audit has\n  been done so far.\n\nFixes\n+++++\n\n- Prevent DeprecationWarnings from ``ast.Str`` and ``ast.Num`` on Python 3.12\n\n- Forbid using some attributes providing access to restricted Python internals.\n\n\n6.0 (2022-11-03)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 2.7 and 3.5.\n\nFeatures\n++++++++\n\n- Officially support Python 3.11.\n\n- Allow to use the Python 3.11 feature of exception groups and except\\*\n  (PEP 654).\n\n\n5.2 (2021-11-19)\n----------------\n\n- Document that ``__name__`` is needed to define classes.\n\n- Add support for Python 3.10. Auditing the Python 3.10 change log did not\n  reveal any changes which require actions in RestrictedPython.\n\n- Avoid deprecation warnings when using Python 3.8+.\n  (`#192 <https://github.com/zopefoundation/RestrictedPython/issues/192>`_)\n\n\n5.1 (2020-10-07)\n----------------\n\nFeatures\n++++++++\n\n- Add support for (Python 3.8+) assignment expressions (i.e. the ``:=`` operator)\n\n- Add support for Python 3.9 after checking the security implications of the\n  syntax changes made in that version.\n\n- Add support for the ``bytes`` and ``sorted`` builtins\n  (`#186 <https://github.com/zopefoundation/RestrictedPython/issues/186>`_)\n\nDocumentation\n+++++++++++++\n\n- Document parameter ``mode`` for the ``compile_restricted`` functions\n  (`#157 <https://github.com/zopefoundation/RestrictedPython/issues/157>`_)\n\n- Fix documentation for ``compile_restricted_function``\n  (`#158 <https://github.com/zopefoundation/RestrictedPython/issues/158>`_)\n\nFixes\n+++++\n\n- Fix ``compile_restricted_function`` with SyntaxErrors that have no text\n  (`#181 <https://github.com/zopefoundation/RestrictedPython/issues/181>`_)\n\n- Drop install dependency on ``setuptools``.\n  (`#189 <https://github.com/zopefoundation/RestrictedPython/issues/189>`_)\n\n\n5.0 (2019-09-03)\n----------------\n\nBreaking changes\n++++++++++++++++\n\n- Revert the allowance of the ``...`` (Ellipsis) statement, as of 4.0. It is\n  not needed to support Python 3.8.\n  The security implications of the Ellipsis Statement is not 100 % clear and is\n  not checked. ``...`` (Ellipsis) is disallowed again.\n\nFeatures\n++++++++\n\n- Add support for f-strings in Python 3.6+.\n  (`#123 <https://github.com/zopefoundation/RestrictedPython/issues/123>`_)\n\n\n4.0 (2019-05-10)\n----------------\n\nChanges since 3.6.0:\n\nBreaking changes\n++++++++++++++++\n\n- The ``compile_restricted*`` functions now return a\n  ``namedtuple CompileResult`` instead of a simple ``tuple``.\n\n- Drop the old implementation of version 3.x: `RCompile.py`,\n  `SelectCompiler.py`, `MutatingWorker.py`, `RestrictionMutator.py` and\n  `tests/verify.py`.\n\n- Drop support for long-deprecated ``sets`` module.\n\nSecurity related issues\n+++++++++++++++++++++++\n\n- RestrictedPython now ships with a default implementation for\n  ``_getattr_`` which prevents from using the ``format()`` method on\n  str/unicode as it is not safe, see:\n  http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n\n  **Caution:** If you do not already have secured the access to this\n  ``format()`` method in your ``_getattr_`` implementation use\n  ``RestrictedPython.Guards.safer_getattr()`` in your implementation to\n  benefit from this fix.\n\nFeatures\n++++++++\n\n- Mostly complete rewrite based on Python AST module.\n  [loechel (Alexander Loechel), icemac (Michael Howitz),\n  stephan-hof (Stephan Hofmockel), tlotze (Thomas Lotze)]\n\n- Add support for Python 3.5, 3.6, 3.7.\n\n- Add preliminary support for Python 3.8. as of 3.8.0a3 is released.\n\n- Warn when using another Python implementation than CPython as it is not safe\n  to use RestrictedPython with other versions than CPyton.\n  See https://bitbucket.org/pypy/pypy/issues/2653 for PyPy.\n\n- Allow the ``...`` (Ellipsis) statement. It is needed to support Python 3.8.\n\n- Allow `yield` and `yield from` statements.\n  Generator functions would now work in RestrictedPython.\n\n- Allow the following magic methods to be defined on classes.\n  (`#104 <https://github.com/zopefoundation/RestrictedPython/issues/104>`_)\n  They cannot be called directly but by the built-in way to use them (e. g.\n  class instantiation, or comparison):\n\n  + ``__init__``\n  + ``__contains__``\n  + ``__lt__``\n  + ``__le__``\n  + ``__eq__``\n  + ``__ne__``\n  + ``__gt__``\n  + ``__ge__``\n\n- Imports like ``from a import *`` (so called star imports) are now forbidden\n  as they allow to import names starting with an underscore which could\n  override protected build-ins.\n  (`#102 <https://github.com/zopefoundation/RestrictedPython/issues/102>`_)\n\n- Allow to use list comprehensions in the default implementation of\n  ``RestrictionCapableEval.eval()``.\n\n- Switch to pytest as test runner.\n\n- Bring test coverage to 100 %.\n\nBug fixes\n+++++++++\n\n- Improve `.Guards.safer_getattr` to prevent accessing names starting with\n  underscore.\n  (`#142 <https://github.com/zopefoundation/RestrictedPython/issues/142>`_)\n\n\n3.6.0 (2010-07-09)\n------------------\n\n- Add name check for names assigned during imports using the\n  ``from x import y`` format.\n\n- Add test for name check when assigning an alias using multiple-context\n  ``with`` statements in Python 2.7.\n\n- Add tests for protection of the iterators for dict and set comprehensions\n  in Python 2.7.\n\n3.6.0a1 (2010-06-05)\n--------------------\n\n- Remove support for ``DocumentTemplate.sequence`` - this is handled in the\n  DocumentTemplate package itself.\n\n3.5.2 (2010-04-30)\n------------------\n\n- Remove a testing dependency on ``zope.testing``.\n\n3.5.1 (2009-03-17)\n------------------\n\n- Add tests for ``Utilities`` module.\n\n- Filter DeprecationWarnings when importing Python's ``sets`` module.\n\n3.5.0 (2009-02-09)\n------------------\n\n- Drop legacy support for Python 2.1 / 2.2 (``__future__`` imports\n  of ``nested_scopes`` / ``generators``.).\n\n3.4.3 (2008-10-26)\n------------------\n\n- Fix deprecation warning: ``with`` is now a reserved keyword on\n  Python 2.6. That means RestrictedPython should run on Python 2.6\n  now. Thanks to Ranjith Kannikara, GSoC Student for the patch.\n\n- Add tests for ternary if expression and for ``with`` keyword and\n  context managers.\n\n3.4.2 (2007-07-28)\n------------------\n\n- Changed homepage URL to the PyPI site\n\n- Improve ``README.txt``.\n\n3.4.1 (2007-06-23)\n------------------\n\n- Fix http://www.zope.org/Collectors/Zope/2295: Bare conditional in\n  a Zope 2 PythonScript followed by a comment causes SyntaxError.\n\n3.4.0 (2007-06-04)\n------------------\n\n- RestrictedPython now has its own release cycle as a separate project.\n\n- Synchronized with RestrictedPython from Zope 2 tree.\n\n3.2.0 (2006-01-05)\n------------------\n\n- Corresponds to the verison of the RestrictedPython package shipped\n  as part of the Zope 3.2.0 release.\n\n- No changes from 3.1.0.\n\n3.1.0 (2005-10-03)\n------------------\n\n- Corresponds to the verison of the RestrictedPython package shipped\n  as part of the Zope 3.1.0 release.\n\n- Remove unused fossil module, ``SafeMapping``.\n\n- Replaced use of deprecated ``whrandom`` module with ``random`` (aliased\n  to ``whrandom`` for backward compatibility).\n\n3.0.0 (2004-11-07)\n------------------\n\n- Corresponds to the verison of the RestrictedPython package shipped\n  as part of the Zope X3.0.0 release.\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\n# This tiny set of safe builtins is extended by users of the module.\n# AccessControl.ZopeGuards contains a large set of wrappers for builtins.\n# DocumentTemplate.DT_UTil contains a few.\n\nimport builtins\n\nfrom RestrictedPython._compat import IS_PY311_OR_GREATER\n\n\nsafe_builtins = {}\n\n_safe_names = [\n    '__build_class__',\n    'None',\n    'False',\n    'True',\n    'abs',\n    'bool',\n    'bytes',\n    'callable',\n    'chr',\n    'complex',\n    'divmod',\n    'float',\n    'hash',\n    'hex',\n    'id',\n    'int',\n    'isinstance',\n    'issubclass',\n    'len',\n    'oct',\n    'ord',\n    'pow',\n    'range',\n    'repr',\n    'round',\n    'slice',\n    'sorted',\n    'str',\n    'tuple',\n    'zip'\n]\n\n_safe_exceptions = [\n    'ArithmeticError',\n    'AssertionError',\n    'AttributeError',\n    'BaseException',\n    'BufferError',\n    'BytesWarning',\n    'DeprecationWarning',\n    'EOFError',\n    'EnvironmentError',\n    'Exception',\n    'FloatingPointError',\n    'FutureWarning',\n    'GeneratorExit',\n    'IOError',\n    'ImportError',\n    'ImportWarning',\n    'IndentationError',\n    'IndexError',\n    'KeyError',\n    'KeyboardInterrupt',\n    'LookupError',\n    'MemoryError',\n    'NameError',\n    'NotImplementedError',\n    'OSError',\n    'OverflowError',\n    'PendingDeprecationWarning',\n    'ReferenceError',\n    'RuntimeError',\n    'RuntimeWarning',\n    'StopIteration',\n    'SyntaxError',\n    'SyntaxWarning',\n    'SystemError',\n    'SystemExit',\n    'TabError',\n    'TypeError',\n    'UnboundLocalError',\n    'UnicodeDecodeError',\n    'UnicodeEncodeError',\n    'UnicodeError',\n    'UnicodeTranslateError',\n    'UnicodeWarning',\n    'UserWarning',\n    'ValueError',\n    'Warning',\n    'ZeroDivisionError',\n]\n\nif IS_PY311_OR_GREATER:\n    _safe_exceptions.append(\"ExceptionGroup\")\n\nfor name in _safe_names:\n    safe_builtins[name] = getattr(builtins, name)\n\nfor name in _safe_exceptions:\n    safe_builtins[name] = getattr(builtins, name)\n\n\n# Wrappers provided by this module:\n# delattr\n# setattr\n\n# Wrappers provided by ZopeGuards:\n# __import__\n# apply\n# dict\n# enumerate\n# filter\n# getattr\n# hasattr\n# iter\n# list\n# map\n# max\n# min\n# sum\n# all\n# any\n\n# Builtins that are intentionally disabled\n# compile   - don't let them produce new code\n# dir       - a general purpose introspector, probably hard to wrap\n# execfile  - no direct I/O\n# file      - no direct I/O\n# globals   - uncontrolled namespace access\n# input     - no direct I/O\n# locals    - uncontrolled namespace access\n# open      - no direct I/O\n# raw_input - no direct I/O\n# vars      - uncontrolled namespace access\n\n# There are several strings that describe Python.  I think there's no\n# point to including these, although they are obviously safe:\n# copyright, credits, exit, help, license, quit\n\n# Not provided anywhere.  Do something about these?  Several are\n# related to new-style classes, which we are too scared of to support\n# <0.3 wink>.  coerce, buffer, and reload are esoteric enough that no\n# one should care.\n\n# buffer\n# bytearray\n# classmethod\n# coerce\n# eval\n# intern\n# memoryview\n# object\n# property\n# reload\n# staticmethod\n# super\n# type\n\n\ndef _write_wrapper():\n    # Construct the write wrapper class\n    def _handler(secattr, error_msg):\n        # Make a class method.\n        def handler(self, *args):\n            try:\n                f = getattr(self.ob, secattr)\n            except AttributeError:\n                raise TypeError(error_msg)\n            f(*args)\n        return handler\n\n    class Wrapper:\n        def __init__(self, ob):\n            self.__dict__['ob'] = ob\n\n        __setitem__ = _handler(\n            '__guarded_setitem__',\n            'object does not support item or slice assignment')\n\n        __delitem__ = _handler(\n            '__guarded_delitem__',\n            'object does not support item or slice assignment')\n\n        __setattr__ = _handler(\n            '__guarded_setattr__',\n            'attribute-less object (assign or del)')\n\n        __delattr__ = _handler(\n            '__guarded_delattr__',\n            'attribute-less object (assign or del)')\n    return Wrapper\n\n\ndef _full_write_guard():\n    # Nested scope abuse!\n    # safetypes and Wrapper variables are used by guard()\n    safetypes = {dict, list}\n    Wrapper = _write_wrapper()\n\n    def guard(ob):\n        # Don't bother wrapping simple types, or objects that claim to\n        # handle their own write security.\n        if type(ob) in safetypes or hasattr(ob, '_guarded_writes'):\n            return ob\n        # Hand the object to the Wrapper instance, then return the instance.\n        return Wrapper(ob)\n    return guard\n\n\nfull_write_guard = _full_write_guard()\n\n\ndef guarded_setattr(object, name, value):\n    setattr(full_write_guard(object), name, value)\n\n\nsafe_builtins['setattr'] = guarded_setattr\n\n\ndef guarded_delattr(object, name):\n    delattr(full_write_guard(object), name)\n\n\nsafe_builtins['delattr'] = guarded_delattr\n\n\ndef safer_getattr(object, name, default=None, getattr=getattr):\n    \"\"\"Getattr implementation which prevents using format on string objects.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n\n    \"\"\"\n    if isinstance(object, str) and name == 'format':\n        raise NotImplementedError(\n            'Using format() on a %s is not safe.' % object.__class__.__name__)\n    if name.startswith('_'):\n        raise AttributeError(\n            '\"{name}\" is an invalid attribute name because it '\n            'starts with \"_\"'.format(name=name)\n        )\n    return getattr(object, name, default)\n\n\nsafe_builtins['_getattr_'] = safer_getattr\n\n\ndef guarded_iter_unpack_sequence(it, spec, _getiter_):\n    \"\"\"Protect sequence unpacking of targets in a 'for loop'.\n\n    The target of a for loop could be a sequence.\n    For example \"for a, b in it\"\n    => Each object from the iterator needs guarded sequence unpacking.\n    \"\"\"\n    # The iteration itself needs to be protected as well.\n    for ob in _getiter_(it):\n        yield guarded_unpack_sequence(ob, spec, _getiter_)\n\n\ndef guarded_unpack_sequence(it, spec, _getiter_):\n    \"\"\"Protect nested sequence unpacking.\n\n    Protect the unpacking of 'it' by wrapping it with '_getiter_'.\n    Furthermore for each child element, defined by spec,\n    guarded_unpack_sequence is called again.\n\n    Have a look at transformer.py 'gen_unpack_spec' for a more detailed\n    explanation.\n    \"\"\"\n    # Do the guarded unpacking of the sequence.\n    ret = list(_getiter_(it))\n\n    # If the sequence is shorter then expected the interpreter will raise\n    # 'ValueError: need more than X value to unpack' anyway\n    # => No childs are unpacked => nothing to protect.\n    if len(ret) < spec['min_len']:\n        return ret\n\n    # For all child elements do the guarded unpacking again.\n    for (idx, child_spec) in spec['childs']:\n        ret[idx] = guarded_unpack_sequence(ret[idx], child_spec, _getiter_)\n\n    return ret\n\n\nsafe_globals = {'__builtins__': safe_builtins}\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\nimport math\nimport random\nimport string\n\n\nutility_builtins = {}\n\nutility_builtins['string'] = string\nutility_builtins['math'] = math\nutility_builtins['random'] = random\nutility_builtins['whrandom'] = random\nutility_builtins['set'] = set\nutility_builtins['frozenset'] = frozenset\n\ntry:\n    import DateTime\n    utility_builtins['DateTime'] = DateTime.DateTime\nexcept ImportError:\n    pass\n\n\ndef same_type(arg1, *args):\n    \"\"\"Compares the class or type of two or more objects.\"\"\"\n    t = getattr(arg1, '__class__', type(arg1))\n    for arg in args:\n        if getattr(arg, '__class__', type(arg)) is not t:\n            return False\n    return True\n\n\nutility_builtins['same_type'] = same_type\n\n\ndef test(*args):\n    length = len(args)\n    for i in range(1, length, 2):\n        if args[i - 1]:\n            return args[i]\n\n    if length % 2:\n        return args[-1]\n\n\nutility_builtins['test'] = test\n\n\ndef reorder(s, with_=None, without=()):\n    # s, with_, and without are sequences treated as sets.\n    # The result is subtract(intersect(s, with_), without),\n    # unless with_ is None, in which case it is subtract(s, without).\n    if with_ is None:\n        with_ = s\n    orig = {}\n    for item in s:\n        if isinstance(item, tuple) and len(item) == 2:\n            key, value = item\n        else:\n            key = value = item\n        orig[key] = value\n\n    result = []\n\n    for item in without:\n        if isinstance(item, tuple) and len(item) == 2:\n            key, ignored = item\n        else:\n            key = item\n        if key in orig:\n            del orig[key]\n\n    for item in with_:\n        if isinstance(item, tuple) and len(item) == 2:\n            key, ignored = item\n        else:\n            key = item\n        if key in orig:\n            result.append((key, orig[key]))\n            del orig[key]\n\n    return result\n\n\nutility_builtins['reorder'] = reorder\n", "import math\nimport random\nimport string\n\n\ndef test_string_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['string'] is string\n\n\ndef test_math_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['math'] is math\n\n\ndef test_whrandom_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['whrandom'] is random\n\n\ndef test_random_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['random'] is random\n\n\ndef test_set_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['set'] is set\n\n\ndef test_frozenset_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['frozenset'] is frozenset\n\n\ndef test_DateTime_in_utility_builtins_if_importable():\n    try:\n        import DateTime\n    except ImportError:\n        pass\n    else:\n        from RestrictedPython.Utilities import utility_builtins\n        assert DateTime.__name__ in utility_builtins\n\n\ndef test_same_type_in_utility_builtins():\n    from RestrictedPython.Utilities import same_type\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['same_type'] is same_type\n\n\ndef test_test_in_utility_builtins():\n    from RestrictedPython.Utilities import test\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['test'] is test\n\n\ndef test_reorder_in_utility_builtins():\n    from RestrictedPython.Utilities import reorder\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['reorder'] is reorder\n\n\ndef test_sametype_only_one_arg():\n    from RestrictedPython.Utilities import same_type\n    assert same_type(object())\n\n\ndef test_sametype_only_two_args_same():\n    from RestrictedPython.Utilities import same_type\n    assert same_type(object(), object())\n\n\ndef test_sametype_only_two_args_different():\n    from RestrictedPython.Utilities import same_type\n\n    class Foo:\n        pass\n    assert same_type(object(), Foo()) is False\n\n\ndef test_sametype_only_multiple_args_same():\n    from RestrictedPython.Utilities import same_type\n    assert same_type(object(), object(), object(), object())\n\n\ndef test_sametype_only_multipe_args_one_different():\n    from RestrictedPython.Utilities import same_type\n\n    class Foo:\n        pass\n    assert same_type(object(), object(), Foo()) is False\n\n\ndef test_test_single_value_true():\n    from RestrictedPython.Utilities import test\n    assert test(True) is True\n\n\ndef test_test_single_value_False():\n    from RestrictedPython.Utilities import test\n    assert test(False) is False\n\n\ndef test_test_even_values_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(True, 'first', True, 'second') == 'first'\n\n\ndef test_test_even_values_not_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', True, 'second') == 'second'\n\n\ndef test_test_odd_values_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(True, 'first', True, 'second', False) == 'first'\n\n\ndef test_test_odd_values_not_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', True, 'second', False) == 'second'\n\n\ndef test_test_odd_values_last_true():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', False, 'second', 'third') == 'third'\n\n\ndef test_test_odd_values_last_false():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', False, 'second', False) is False\n\n\ndef test_reorder_with__None():\n    from RestrictedPython.Utilities import reorder\n    before = ['a', 'b', 'c', 'd', 'e']\n    without = ['a', 'c', 'e']\n    after = reorder(before, without=without)\n    assert after == [('b', 'b'), ('d', 'd')]\n\n\ndef test_reorder_with__not_None():\n    from RestrictedPython.Utilities import reorder\n    before = ['a', 'b', 'c', 'd', 'e']\n    with_ = ['a', 'd']\n    without = ['a', 'c', 'e']\n    after = reorder(before, with_=with_, without=without)\n    assert after == [('d', 'd')]\n", "import pytest\n\nfrom RestrictedPython import compile_restricted_exec\nfrom RestrictedPython.Guards import guarded_unpack_sequence\nfrom RestrictedPython.Guards import safe_builtins\nfrom RestrictedPython.Guards import safe_globals\nfrom RestrictedPython.Guards import safer_getattr\nfrom tests.helper import restricted_eval\nfrom tests.helper import restricted_exec\n\n\ndef _write_(x):\n    return x\n\n\ndef test_Guards_bytes():\n    \"\"\"It contains bytes\"\"\"\n    assert restricted_eval('bytes(1)') == bytes(1)\n\n\ndef test_Guards_sorted():\n    \"\"\"It contains sorted\"\"\"\n    assert restricted_eval('sorted([5, 2, 8, 1])') == sorted([5, 2, 8, 1])\n\n\ndef test_Guards__safe_builtins__1():\n    \"\"\"It contains `slice()`.\"\"\"\n    assert restricted_eval('slice(1)') == slice(1)\n\n\ndef test_Guards__safe_builtins__2():\n    \"\"\"It allows to define new classes by allowing `__build_class__`.\n    \"\"\"\n\n    class_can_be_defined_code = '''\nclass MyClass:\n    value = None\n    def display(self):\n        return str(self.value)\n\nob1 = MyClass()\nob1.value = 2411\nresult = ob1.display()'''\n\n    restricted_globals = dict(\n        result=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr)\n\n    restricted_exec(class_can_be_defined_code, restricted_globals)\n    assert restricted_globals['result'] == '2411'\n\n\ndef test_Guards__guarded_setattr__1():\n    \"\"\"It allows use setattr and delattr when _guarded_writes is True.\n    \"\"\"\n    class MyObjectD:\n        value = None\n        _guarded_writes = 1\n\n    setattr_code = '''\nmy_object_d = MyObjectD()\nsetattr(my_object_d, 'value', 9999)'''\n\n    delattr_code = \"delattr(my_object_d, 'value')\"\n\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        MyObjectD=MyObjectD,\n        my_object_d=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr,)\n\n    restricted_exec(setattr_code, restricted_globals)\n    assert 9999 == restricted_globals['my_object_d'].value\n\n    restricted_exec(delattr_code, restricted_globals)\n    assert None is restricted_globals['my_object_d'].value\n\n\ndef test_Guards__write_wrapper__1():\n    \"\"\"It wraps the value attribute when it is not\n    marked with _guarded_writes.\"\"\"\n    class ObjWithoutGuardedWrites:\n        my_attr = None\n\n    setattr_without_guarded_writes_code = '''\nmy_ob = ObjWithoutGuardedWrites()\nsetattr(my_ob, 'my_attr', 'bar')'''\n\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        ObjWithoutGuardedWrites=ObjWithoutGuardedWrites,\n        my_attr=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr,)\n\n    with pytest.raises(TypeError) as excinfo:\n        restricted_exec(\n            setattr_without_guarded_writes_code, restricted_globals)\n    assert 'attribute-less object (assign or del)' in str(excinfo.value)\n\n\ndef test_Guards__write_wrapper__2():\n    \"\"\"It wraps setattr and it works when guarded_setattr is implemented.\"\"\"\n\n    class ObjWithGuardedSetattr:\n        my_attr = None\n\n        def __guarded_setattr__(self, key, value):\n            setattr(self, key, value)\n\n    set_attribute_using_guarded_setattr_code = '''\nmyobj_with_guarded_setattr = ObjWithGuardedSetattr()\nsetattr(myobj_with_guarded_setattr, 'my_attr', 'bar')\n    '''\n\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        ObjWithGuardedSetattr=ObjWithGuardedSetattr,\n        myobj_with_guarded_setattr=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr,)\n\n    restricted_exec(\n        set_attribute_using_guarded_setattr_code, restricted_globals)\n    assert restricted_globals['myobj_with_guarded_setattr'].my_attr == 'bar'\n\n\ndef test_Guards__guarded_unpack_sequence__1(mocker):\n    \"\"\"If the sequence is shorter then expected the interpreter will raise\n    'ValueError: need more than X value to unpack' anyway\n    => No childs are unpacked => nothing to protect.\"\"\"\n    src = \"one, two, three = (1, 2)\"\n\n    _getiter_ = mocker.stub()\n    _getiter_.side_effect = lambda it: it\n    glb = {\n        '_getiter_': _getiter_,\n        '_unpack_sequence_': guarded_unpack_sequence,\n    }\n\n    with pytest.raises(ValueError) as excinfo:\n        restricted_exec(src, glb)\n    assert 'values to unpack' in str(excinfo.value)\n    assert _getiter_.call_count == 1\n\n\nSTRING_DOT_FORMAT_DENIED = \"\"\"\\\na = 'Hello {}'\nb = a.format('world')\n\"\"\"\n\n\ndef test_Guards__safer_getattr__1():\n    \"\"\"It prevents using the format method of a string.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n    \"\"\"\n    glb = {\n        '__builtins__': safe_builtins,\n    }\n    with pytest.raises(NotImplementedError) as err:\n        restricted_exec(STRING_DOT_FORMAT_DENIED, glb)\n    assert 'Using format() on a str is not safe.' == str(err.value)\n\n\nUNICODE_DOT_FORMAT_DENIED = \"\"\"\\\na = u'Hello {}'\nb = a.format(u'world')\n\"\"\"\n\n\ndef test_Guards__safer_getattr__2():\n    \"\"\"It prevents using the format method of a unicode.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n    \"\"\"\n    glb = {\n        '__builtins__': safe_builtins,\n    }\n    with pytest.raises(NotImplementedError) as err:\n        restricted_exec(UNICODE_DOT_FORMAT_DENIED, glb)\n    assert 'Using format() on a str is not safe.' == str(err.value)\n\n\nSAFER_GETATTR_ALLOWED = \"\"\"\\\nclass A:\n\n    def __init__(self, value):\n        self.value = value\n\na = A(2)\nresult = getattr(a, 'value')\n\"\"\"\n\n\ndef test_Guards__safer_getattr__3():\n    \"\"\"It allows to use `safer_getattr`.\"\"\"\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        __name__=None,\n        __metaclass__=type,\n        _write_=_write_,\n        getattr=safer_getattr,\n        result=None,\n    )\n    restricted_exec(SAFER_GETATTR_ALLOWED, restricted_globals)\n    assert restricted_globals['result'] == 2\n\n\ndef test_call_py3_builtins():\n    \"\"\"It should not be allowed to access global builtins in Python3.\"\"\"\n    result = compile_restricted_exec('builtins[\"getattr\"]')\n    assert result.code is None\n    assert result.errors == ('Line 1: \"builtins\" is a reserved name.',)\n\n\nGETATTR_UNDERSCORE_NAME = \"\"\"\ngetattr([], '__class__')\n\"\"\"\n\n\ndef test_safer_getattr__underscore_name():\n    \"\"\"It prevents accessing an attribute which starts with an underscore.\"\"\"\n    result = compile_restricted_exec(GETATTR_UNDERSCORE_NAME)\n    assert result.errors == ()\n    assert result.warnings == []\n    glb = safe_globals.copy()\n    glb['getattr'] = safer_getattr\n    with pytest.raises(AttributeError) as err:\n        exec(result.code, glb, {})\n    assert (\n        '\"__class__\" is an invalid attribute name because it starts with \"_\"'\n        == str(err.value))\n", "from RestrictedPython.Utilities import reorder\nfrom RestrictedPython.Utilities import test\n\n\ndef test_Utilities__test_1():\n    \"\"\"It returns the first arg after the first argument which is True\"\"\"\n    assert test(True, 1, False, 2) == 1\n    assert test(False, 1, True, 2) == 2\n    assert test(False, 1, False, 2, True, 3) == 3\n\n\ndef test_Utilities__test_2():\n    \"\"\"If the above is not met, and there is an extra argument\n    it returns it.\"\"\"\n    assert test(False, 1, False, 2, 3) == 3\n    assert test(False, 1, 2) == 2\n    assert test(1) == 1\n    assert not test(False)\n\n\ndef test_Utilities__test_3():\n    \"\"\"It returns None if there are only False args followed by something.\"\"\"\n    assert test(False, 1) is None\n    assert test(False, 1, False, 2) is None\n\n\ndef test_Utilities__reorder_1():\n    \"\"\"It also supports 2-tuples containing key, value.\"\"\"\n    s = [('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')]\n    _with = [('k2', 'v2'), ('k3', 'v3')]\n    without = [('k2', 'v2'), ('k4', 'v4')]\n    assert reorder(s, _with, without) == [('k3', 'v3')]\n"], "fixing_code": ["Changes\n=======\n\n7.0 (unreleased)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 3.6.\n\nFeatures\n++++++++\n\n- Allow to use the package with Python 3.12 -- Caution: No security audit has\n  been done so far.\n\nFixes\n+++++\n\n- Prevent DeprecationWarnings from ``ast.Str`` and ``ast.Num`` on Python 3.12\n\n- Forbid using some attributes providing access to restricted Python internals.\n\n- Fix information disclosure problems through\n  Python's \"format\" functionality\n  (``format`` and ``format_map`` methods on ``str`` and its instances,\n  ``string.Formatter``).\n\n\n6.0 (2022-11-03)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 2.7 and 3.5.\n\nFeatures\n++++++++\n\n- Officially support Python 3.11.\n\n- Allow to use the Python 3.11 feature of exception groups and except\\*\n  (PEP 654).\n\n\n5.2 (2021-11-19)\n----------------\n\n- Document that ``__name__`` is needed to define classes.\n\n- Add support for Python 3.10. Auditing the Python 3.10 change log did not\n  reveal any changes which require actions in RestrictedPython.\n\n- Avoid deprecation warnings when using Python 3.8+.\n  (`#192 <https://github.com/zopefoundation/RestrictedPython/issues/192>`_)\n\n\n5.1 (2020-10-07)\n----------------\n\nFeatures\n++++++++\n\n- Add support for (Python 3.8+) assignment expressions (i.e. the ``:=`` operator)\n\n- Add support for Python 3.9 after checking the security implications of the\n  syntax changes made in that version.\n\n- Add support for the ``bytes`` and ``sorted`` builtins\n  (`#186 <https://github.com/zopefoundation/RestrictedPython/issues/186>`_)\n\nDocumentation\n+++++++++++++\n\n- Document parameter ``mode`` for the ``compile_restricted`` functions\n  (`#157 <https://github.com/zopefoundation/RestrictedPython/issues/157>`_)\n\n- Fix documentation for ``compile_restricted_function``\n  (`#158 <https://github.com/zopefoundation/RestrictedPython/issues/158>`_)\n\nFixes\n+++++\n\n- Fix ``compile_restricted_function`` with SyntaxErrors that have no text\n  (`#181 <https://github.com/zopefoundation/RestrictedPython/issues/181>`_)\n\n- Drop install dependency on ``setuptools``.\n  (`#189 <https://github.com/zopefoundation/RestrictedPython/issues/189>`_)\n\n\n5.0 (2019-09-03)\n----------------\n\nBreaking changes\n++++++++++++++++\n\n- Revert the allowance of the ``...`` (Ellipsis) statement, as of 4.0. It is\n  not needed to support Python 3.8.\n  The security implications of the Ellipsis Statement is not 100 % clear and is\n  not checked. ``...`` (Ellipsis) is disallowed again.\n\nFeatures\n++++++++\n\n- Add support for f-strings in Python 3.6+.\n  (`#123 <https://github.com/zopefoundation/RestrictedPython/issues/123>`_)\n\n\n4.0 (2019-05-10)\n----------------\n\nChanges since 3.6.0:\n\nBreaking changes\n++++++++++++++++\n\n- The ``compile_restricted*`` functions now return a\n  ``namedtuple CompileResult`` instead of a simple ``tuple``.\n\n- Drop the old implementation of version 3.x: `RCompile.py`,\n  `SelectCompiler.py`, `MutatingWorker.py`, `RestrictionMutator.py` and\n  `tests/verify.py`.\n\n- Drop support for long-deprecated ``sets`` module.\n\nSecurity related issues\n+++++++++++++++++++++++\n\n- RestrictedPython now ships with a default implementation for\n  ``_getattr_`` which prevents from using the ``format()`` method on\n  str/unicode as it is not safe, see:\n  http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n\n  **Caution:** If you do not already have secured the access to this\n  ``format()`` method in your ``_getattr_`` implementation use\n  ``RestrictedPython.Guards.safer_getattr()`` in your implementation to\n  benefit from this fix.\n\nFeatures\n++++++++\n\n- Mostly complete rewrite based on Python AST module.\n  [loechel (Alexander Loechel), icemac (Michael Howitz),\n  stephan-hof (Stephan Hofmockel), tlotze (Thomas Lotze)]\n\n- Add support for Python 3.5, 3.6, 3.7.\n\n- Add preliminary support for Python 3.8. as of 3.8.0a3 is released.\n\n- Warn when using another Python implementation than CPython as it is not safe\n  to use RestrictedPython with other versions than CPyton.\n  See https://bitbucket.org/pypy/pypy/issues/2653 for PyPy.\n\n- Allow the ``...`` (Ellipsis) statement. It is needed to support Python 3.8.\n\n- Allow `yield` and `yield from` statements.\n  Generator functions would now work in RestrictedPython.\n\n- Allow the following magic methods to be defined on classes.\n  (`#104 <https://github.com/zopefoundation/RestrictedPython/issues/104>`_)\n  They cannot be called directly but by the built-in way to use them (e. g.\n  class instantiation, or comparison):\n\n  + ``__init__``\n  + ``__contains__``\n  + ``__lt__``\n  + ``__le__``\n  + ``__eq__``\n  + ``__ne__``\n  + ``__gt__``\n  + ``__ge__``\n\n- Imports like ``from a import *`` (so called star imports) are now forbidden\n  as they allow to import names starting with an underscore which could\n  override protected build-ins.\n  (`#102 <https://github.com/zopefoundation/RestrictedPython/issues/102>`_)\n\n- Allow to use list comprehensions in the default implementation of\n  ``RestrictionCapableEval.eval()``.\n\n- Switch to pytest as test runner.\n\n- Bring test coverage to 100 %.\n\nBug fixes\n+++++++++\n\n- Improve `.Guards.safer_getattr` to prevent accessing names starting with\n  underscore.\n  (`#142 <https://github.com/zopefoundation/RestrictedPython/issues/142>`_)\n\n\n3.6.0 (2010-07-09)\n------------------\n\n- Add name check for names assigned during imports using the\n  ``from x import y`` format.\n\n- Add test for name check when assigning an alias using multiple-context\n  ``with`` statements in Python 2.7.\n\n- Add tests for protection of the iterators for dict and set comprehensions\n  in Python 2.7.\n\n3.6.0a1 (2010-06-05)\n--------------------\n\n- Remove support for ``DocumentTemplate.sequence`` - this is handled in the\n  DocumentTemplate package itself.\n\n3.5.2 (2010-04-30)\n------------------\n\n- Remove a testing dependency on ``zope.testing``.\n\n3.5.1 (2009-03-17)\n------------------\n\n- Add tests for ``Utilities`` module.\n\n- Filter DeprecationWarnings when importing Python's ``sets`` module.\n\n3.5.0 (2009-02-09)\n------------------\n\n- Drop legacy support for Python 2.1 / 2.2 (``__future__`` imports\n  of ``nested_scopes`` / ``generators``.).\n\n3.4.3 (2008-10-26)\n------------------\n\n- Fix deprecation warning: ``with`` is now a reserved keyword on\n  Python 2.6. That means RestrictedPython should run on Python 2.6\n  now. Thanks to Ranjith Kannikara, GSoC Student for the patch.\n\n- Add tests for ternary if expression and for ``with`` keyword and\n  context managers.\n\n3.4.2 (2007-07-28)\n------------------\n\n- Changed homepage URL to the PyPI site\n\n- Improve ``README.txt``.\n\n3.4.1 (2007-06-23)\n------------------\n\n- Fix http://www.zope.org/Collectors/Zope/2295: Bare conditional in\n  a Zope 2 PythonScript followed by a comment causes SyntaxError.\n\n3.4.0 (2007-06-04)\n------------------\n\n- RestrictedPython now has its own release cycle as a separate project.\n\n- Synchronized with RestrictedPython from Zope 2 tree.\n\n3.2.0 (2006-01-05)\n------------------\n\n- Corresponds to the verison of the RestrictedPython package shipped\n  as part of the Zope 3.2.0 release.\n\n- No changes from 3.1.0.\n\n3.1.0 (2005-10-03)\n------------------\n\n- Corresponds to the verison of the RestrictedPython package shipped\n  as part of the Zope 3.1.0 release.\n\n- Remove unused fossil module, ``SafeMapping``.\n\n- Replaced use of deprecated ``whrandom`` module with ``random`` (aliased\n  to ``whrandom`` for backward compatibility).\n\n3.0.0 (2004-11-07)\n------------------\n\n- Corresponds to the verison of the RestrictedPython package shipped\n  as part of the Zope X3.0.0 release.\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\n# This tiny set of safe builtins is extended by users of the module.\n# AccessControl.ZopeGuards contains a large set of wrappers for builtins.\n# DocumentTemplate.DT_UTil contains a few.\n\nimport builtins\n\nfrom RestrictedPython._compat import IS_PY311_OR_GREATER\n\n\nsafe_builtins = {}\n\n_safe_names = [\n    '__build_class__',\n    'None',\n    'False',\n    'True',\n    'abs',\n    'bool',\n    'bytes',\n    'callable',\n    'chr',\n    'complex',\n    'divmod',\n    'float',\n    'hash',\n    'hex',\n    'id',\n    'int',\n    'isinstance',\n    'issubclass',\n    'len',\n    'oct',\n    'ord',\n    'pow',\n    'range',\n    'repr',\n    'round',\n    'slice',\n    'sorted',\n    'str',\n    'tuple',\n    'zip'\n]\n\n_safe_exceptions = [\n    'ArithmeticError',\n    'AssertionError',\n    'AttributeError',\n    'BaseException',\n    'BufferError',\n    'BytesWarning',\n    'DeprecationWarning',\n    'EOFError',\n    'EnvironmentError',\n    'Exception',\n    'FloatingPointError',\n    'FutureWarning',\n    'GeneratorExit',\n    'IOError',\n    'ImportError',\n    'ImportWarning',\n    'IndentationError',\n    'IndexError',\n    'KeyError',\n    'KeyboardInterrupt',\n    'LookupError',\n    'MemoryError',\n    'NameError',\n    'NotImplementedError',\n    'OSError',\n    'OverflowError',\n    'PendingDeprecationWarning',\n    'ReferenceError',\n    'RuntimeError',\n    'RuntimeWarning',\n    'StopIteration',\n    'SyntaxError',\n    'SyntaxWarning',\n    'SystemError',\n    'SystemExit',\n    'TabError',\n    'TypeError',\n    'UnboundLocalError',\n    'UnicodeDecodeError',\n    'UnicodeEncodeError',\n    'UnicodeError',\n    'UnicodeTranslateError',\n    'UnicodeWarning',\n    'UserWarning',\n    'ValueError',\n    'Warning',\n    'ZeroDivisionError',\n]\n\nif IS_PY311_OR_GREATER:\n    _safe_exceptions.append(\"ExceptionGroup\")\n\nfor name in _safe_names:\n    safe_builtins[name] = getattr(builtins, name)\n\nfor name in _safe_exceptions:\n    safe_builtins[name] = getattr(builtins, name)\n\n\n# Wrappers provided by this module:\n# delattr\n# setattr\n\n# Wrappers provided by ZopeGuards:\n# __import__\n# apply\n# dict\n# enumerate\n# filter\n# getattr\n# hasattr\n# iter\n# list\n# map\n# max\n# min\n# sum\n# all\n# any\n\n# Builtins that are intentionally disabled\n# compile   - don't let them produce new code\n# dir       - a general purpose introspector, probably hard to wrap\n# execfile  - no direct I/O\n# file      - no direct I/O\n# globals   - uncontrolled namespace access\n# input     - no direct I/O\n# locals    - uncontrolled namespace access\n# open      - no direct I/O\n# raw_input - no direct I/O\n# vars      - uncontrolled namespace access\n\n# There are several strings that describe Python.  I think there's no\n# point to including these, although they are obviously safe:\n# copyright, credits, exit, help, license, quit\n\n# Not provided anywhere.  Do something about these?  Several are\n# related to new-style classes, which we are too scared of to support\n# <0.3 wink>.  coerce, buffer, and reload are esoteric enough that no\n# one should care.\n\n# buffer\n# bytearray\n# classmethod\n# coerce\n# eval\n# intern\n# memoryview\n# object\n# property\n# reload\n# staticmethod\n# super\n# type\n\n\ndef _write_wrapper():\n    # Construct the write wrapper class\n    def _handler(secattr, error_msg):\n        # Make a class method.\n        def handler(self, *args):\n            try:\n                f = getattr(self.ob, secattr)\n            except AttributeError:\n                raise TypeError(error_msg)\n            f(*args)\n        return handler\n\n    class Wrapper:\n        def __init__(self, ob):\n            self.__dict__['ob'] = ob\n\n        __setitem__ = _handler(\n            '__guarded_setitem__',\n            'object does not support item or slice assignment')\n\n        __delitem__ = _handler(\n            '__guarded_delitem__',\n            'object does not support item or slice assignment')\n\n        __setattr__ = _handler(\n            '__guarded_setattr__',\n            'attribute-less object (assign or del)')\n\n        __delattr__ = _handler(\n            '__guarded_delattr__',\n            'attribute-less object (assign or del)')\n    return Wrapper\n\n\ndef _full_write_guard():\n    # Nested scope abuse!\n    # safetypes and Wrapper variables are used by guard()\n    safetypes = {dict, list}\n    Wrapper = _write_wrapper()\n\n    def guard(ob):\n        # Don't bother wrapping simple types, or objects that claim to\n        # handle their own write security.\n        if type(ob) in safetypes or hasattr(ob, '_guarded_writes'):\n            return ob\n        # Hand the object to the Wrapper instance, then return the instance.\n        return Wrapper(ob)\n    return guard\n\n\nfull_write_guard = _full_write_guard()\n\n\ndef guarded_setattr(object, name, value):\n    setattr(full_write_guard(object), name, value)\n\n\nsafe_builtins['setattr'] = guarded_setattr\n\n\ndef guarded_delattr(object, name):\n    delattr(full_write_guard(object), name)\n\n\nsafe_builtins['delattr'] = guarded_delattr\n\n\ndef safer_getattr(object, name, default=None, getattr=getattr):\n    \"\"\"Getattr implementation which prevents using format on string objects.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n\n    \"\"\"\n    if name in ('format', 'format_map') and (\n            isinstance(object, str) or\n            (isinstance(object, type) and issubclass(object, str))):\n        raise NotImplementedError(\n            'Using the format*() methods of `str` is not safe')\n    if name.startswith('_'):\n        raise AttributeError(\n            '\"{name}\" is an invalid attribute name because it '\n            'starts with \"_\"'.format(name=name)\n        )\n    return getattr(object, name, default)\n\n\nsafe_builtins['_getattr_'] = safer_getattr\n\n\ndef guarded_iter_unpack_sequence(it, spec, _getiter_):\n    \"\"\"Protect sequence unpacking of targets in a 'for loop'.\n\n    The target of a for loop could be a sequence.\n    For example \"for a, b in it\"\n    => Each object from the iterator needs guarded sequence unpacking.\n    \"\"\"\n    # The iteration itself needs to be protected as well.\n    for ob in _getiter_(it):\n        yield guarded_unpack_sequence(ob, spec, _getiter_)\n\n\ndef guarded_unpack_sequence(it, spec, _getiter_):\n    \"\"\"Protect nested sequence unpacking.\n\n    Protect the unpacking of 'it' by wrapping it with '_getiter_'.\n    Furthermore for each child element, defined by spec,\n    guarded_unpack_sequence is called again.\n\n    Have a look at transformer.py 'gen_unpack_spec' for a more detailed\n    explanation.\n    \"\"\"\n    # Do the guarded unpacking of the sequence.\n    ret = list(_getiter_(it))\n\n    # If the sequence is shorter then expected the interpreter will raise\n    # 'ValueError: need more than X value to unpack' anyway\n    # => No childs are unpacked => nothing to protect.\n    if len(ret) < spec['min_len']:\n        return ret\n\n    # For all child elements do the guarded unpacking again.\n    for (idx, child_spec) in spec['childs']:\n        ret[idx] = guarded_unpack_sequence(ret[idx], child_spec, _getiter_)\n\n    return ret\n\n\nsafe_globals = {'__builtins__': safe_builtins}\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\nimport math\nimport random\nimport string\n\n\nutility_builtins = {}\n\n\nclass _AttributeDelegator:\n    def __init__(self, mod, *excludes):\n        \"\"\"delegate attribute lookups outside *excludes* to module *mod*.\"\"\"\n        self.__mod = mod\n        self.__excludes = excludes\n\n    def __getattr__(self, attr):\n        if attr in self.__excludes:\n            raise NotImplementedError(\n                f\"{self.__mod.__name__}.{attr} is not safe\")\n        return getattr(self.__mod, attr)\n\n\nutility_builtins['string'] = _AttributeDelegator(string, \"Formatter\")\nutility_builtins['math'] = math\nutility_builtins['random'] = random\nutility_builtins['whrandom'] = random\nutility_builtins['set'] = set\nutility_builtins['frozenset'] = frozenset\n\ntry:\n    import DateTime\n    utility_builtins['DateTime'] = DateTime.DateTime\nexcept ImportError:\n    pass\n\n\ndef same_type(arg1, *args):\n    \"\"\"Compares the class or type of two or more objects.\"\"\"\n    t = getattr(arg1, '__class__', type(arg1))\n    for arg in args:\n        if getattr(arg, '__class__', type(arg)) is not t:\n            return False\n    return True\n\n\nutility_builtins['same_type'] = same_type\n\n\ndef test(*args):\n    length = len(args)\n    for i in range(1, length, 2):\n        if args[i - 1]:\n            return args[i]\n\n    if length % 2:\n        return args[-1]\n\n\nutility_builtins['test'] = test\n\n\ndef reorder(s, with_=None, without=()):\n    # s, with_, and without are sequences treated as sets.\n    # The result is subtract(intersect(s, with_), without),\n    # unless with_ is None, in which case it is subtract(s, without).\n    if with_ is None:\n        with_ = s\n    orig = {}\n    for item in s:\n        if isinstance(item, tuple) and len(item) == 2:\n            key, value = item\n        else:\n            key = value = item\n        orig[key] = value\n\n    result = []\n\n    for item in without:\n        if isinstance(item, tuple) and len(item) == 2:\n            key, ignored = item\n        else:\n            key = item\n        if key in orig:\n            del orig[key]\n\n    for item in with_:\n        if isinstance(item, tuple) and len(item) == 2:\n            key, ignored = item\n        else:\n            key = item\n        if key in orig:\n            result.append((key, orig[key]))\n            del orig[key]\n\n    return result\n\n\nutility_builtins['reorder'] = reorder\n", "import math\nimport random\nimport string\n\n\ndef test_string_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n\n    # we no longer provide access to ``string`` itself, only to\n    # a restricted view of it\n    assert utility_builtins['string'].__name__ == string.__name__\n\n\ndef test_math_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['math'] is math\n\n\ndef test_whrandom_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['whrandom'] is random\n\n\ndef test_random_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['random'] is random\n\n\ndef test_set_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['set'] is set\n\n\ndef test_frozenset_in_utility_builtins():\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['frozenset'] is frozenset\n\n\ndef test_DateTime_in_utility_builtins_if_importable():\n    try:\n        import DateTime\n    except ImportError:\n        pass\n    else:\n        from RestrictedPython.Utilities import utility_builtins\n        assert DateTime.__name__ in utility_builtins\n\n\ndef test_same_type_in_utility_builtins():\n    from RestrictedPython.Utilities import same_type\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['same_type'] is same_type\n\n\ndef test_test_in_utility_builtins():\n    from RestrictedPython.Utilities import test\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['test'] is test\n\n\ndef test_reorder_in_utility_builtins():\n    from RestrictedPython.Utilities import reorder\n    from RestrictedPython.Utilities import utility_builtins\n    assert utility_builtins['reorder'] is reorder\n\n\ndef test_sametype_only_one_arg():\n    from RestrictedPython.Utilities import same_type\n    assert same_type(object())\n\n\ndef test_sametype_only_two_args_same():\n    from RestrictedPython.Utilities import same_type\n    assert same_type(object(), object())\n\n\ndef test_sametype_only_two_args_different():\n    from RestrictedPython.Utilities import same_type\n\n    class Foo:\n        pass\n    assert same_type(object(), Foo()) is False\n\n\ndef test_sametype_only_multiple_args_same():\n    from RestrictedPython.Utilities import same_type\n    assert same_type(object(), object(), object(), object())\n\n\ndef test_sametype_only_multipe_args_one_different():\n    from RestrictedPython.Utilities import same_type\n\n    class Foo:\n        pass\n    assert same_type(object(), object(), Foo()) is False\n\n\ndef test_test_single_value_true():\n    from RestrictedPython.Utilities import test\n    assert test(True) is True\n\n\ndef test_test_single_value_False():\n    from RestrictedPython.Utilities import test\n    assert test(False) is False\n\n\ndef test_test_even_values_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(True, 'first', True, 'second') == 'first'\n\n\ndef test_test_even_values_not_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', True, 'second') == 'second'\n\n\ndef test_test_odd_values_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(True, 'first', True, 'second', False) == 'first'\n\n\ndef test_test_odd_values_not_first_true():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', True, 'second', False) == 'second'\n\n\ndef test_test_odd_values_last_true():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', False, 'second', 'third') == 'third'\n\n\ndef test_test_odd_values_last_false():\n    from RestrictedPython.Utilities import test\n    assert test(False, 'first', False, 'second', False) is False\n\n\ndef test_reorder_with__None():\n    from RestrictedPython.Utilities import reorder\n    before = ['a', 'b', 'c', 'd', 'e']\n    without = ['a', 'c', 'e']\n    after = reorder(before, without=without)\n    assert after == [('b', 'b'), ('d', 'd')]\n\n\ndef test_reorder_with__not_None():\n    from RestrictedPython.Utilities import reorder\n    before = ['a', 'b', 'c', 'd', 'e']\n    with_ = ['a', 'd']\n    without = ['a', 'c', 'e']\n    after = reorder(before, with_=with_, without=without)\n    assert after == [('d', 'd')]\n", "import pytest\n\nfrom RestrictedPython import compile_restricted_exec\nfrom RestrictedPython.Guards import guarded_unpack_sequence\nfrom RestrictedPython.Guards import safe_builtins\nfrom RestrictedPython.Guards import safe_globals\nfrom RestrictedPython.Guards import safer_getattr\nfrom tests.helper import restricted_eval\nfrom tests.helper import restricted_exec\n\n\ndef _write_(x):\n    return x\n\n\ndef test_Guards_bytes():\n    \"\"\"It contains bytes\"\"\"\n    assert restricted_eval('bytes(1)') == bytes(1)\n\n\ndef test_Guards_sorted():\n    \"\"\"It contains sorted\"\"\"\n    assert restricted_eval('sorted([5, 2, 8, 1])') == sorted([5, 2, 8, 1])\n\n\ndef test_Guards__safe_builtins__1():\n    \"\"\"It contains `slice()`.\"\"\"\n    assert restricted_eval('slice(1)') == slice(1)\n\n\ndef test_Guards__safe_builtins__2():\n    \"\"\"It allows to define new classes by allowing `__build_class__`.\n    \"\"\"\n\n    class_can_be_defined_code = '''\nclass MyClass:\n    value = None\n    def display(self):\n        return str(self.value)\n\nob1 = MyClass()\nob1.value = 2411\nresult = ob1.display()'''\n\n    restricted_globals = dict(\n        result=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr)\n\n    restricted_exec(class_can_be_defined_code, restricted_globals)\n    assert restricted_globals['result'] == '2411'\n\n\ndef test_Guards__guarded_setattr__1():\n    \"\"\"It allows use setattr and delattr when _guarded_writes is True.\n    \"\"\"\n    class MyObjectD:\n        value = None\n        _guarded_writes = 1\n\n    setattr_code = '''\nmy_object_d = MyObjectD()\nsetattr(my_object_d, 'value', 9999)'''\n\n    delattr_code = \"delattr(my_object_d, 'value')\"\n\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        MyObjectD=MyObjectD,\n        my_object_d=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr,)\n\n    restricted_exec(setattr_code, restricted_globals)\n    assert 9999 == restricted_globals['my_object_d'].value\n\n    restricted_exec(delattr_code, restricted_globals)\n    assert None is restricted_globals['my_object_d'].value\n\n\ndef test_Guards__write_wrapper__1():\n    \"\"\"It wraps the value attribute when it is not\n    marked with _guarded_writes.\"\"\"\n    class ObjWithoutGuardedWrites:\n        my_attr = None\n\n    setattr_without_guarded_writes_code = '''\nmy_ob = ObjWithoutGuardedWrites()\nsetattr(my_ob, 'my_attr', 'bar')'''\n\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        ObjWithoutGuardedWrites=ObjWithoutGuardedWrites,\n        my_attr=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr,)\n\n    with pytest.raises(TypeError) as excinfo:\n        restricted_exec(\n            setattr_without_guarded_writes_code, restricted_globals)\n    assert 'attribute-less object (assign or del)' in str(excinfo.value)\n\n\ndef test_Guards__write_wrapper__2():\n    \"\"\"It wraps setattr and it works when guarded_setattr is implemented.\"\"\"\n\n    class ObjWithGuardedSetattr:\n        my_attr = None\n\n        def __guarded_setattr__(self, key, value):\n            setattr(self, key, value)\n\n    set_attribute_using_guarded_setattr_code = '''\nmyobj_with_guarded_setattr = ObjWithGuardedSetattr()\nsetattr(myobj_with_guarded_setattr, 'my_attr', 'bar')\n    '''\n\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        ObjWithGuardedSetattr=ObjWithGuardedSetattr,\n        myobj_with_guarded_setattr=None,\n        __name__='restricted_module',\n        __metaclass__=type,\n        _write_=_write_,\n        _getattr_=getattr,)\n\n    restricted_exec(\n        set_attribute_using_guarded_setattr_code, restricted_globals)\n    assert restricted_globals['myobj_with_guarded_setattr'].my_attr == 'bar'\n\n\ndef test_Guards__guarded_unpack_sequence__1(mocker):\n    \"\"\"If the sequence is shorter then expected the interpreter will raise\n    'ValueError: need more than X value to unpack' anyway\n    => No childs are unpacked => nothing to protect.\"\"\"\n    src = \"one, two, three = (1, 2)\"\n\n    _getiter_ = mocker.stub()\n    _getiter_.side_effect = lambda it: it\n    glb = {\n        '_getiter_': _getiter_,\n        '_unpack_sequence_': guarded_unpack_sequence,\n    }\n\n    with pytest.raises(ValueError) as excinfo:\n        restricted_exec(src, glb)\n    assert 'values to unpack' in str(excinfo.value)\n    assert _getiter_.call_count == 1\n\n\nSTRING_DOT_FORMAT_DENIED = \"\"\"\\\na = 'Hello {}'\nb = a.format('world')\n\"\"\"\n\n\ndef test_Guards__safer_getattr__1a():\n    \"\"\"It prevents using the format method of a string.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n    \"\"\"\n    glb = {\n        '__builtins__': safe_builtins,\n    }\n    with pytest.raises(NotImplementedError) as err:\n        restricted_exec(STRING_DOT_FORMAT_DENIED, glb)\n    assert 'Using the format*() methods of `str` is not safe' == str(err.value)\n\n\n# contributed by Ward Theunisse\nSTRING_DOT_FORMAT_MAP_DENIED = \"\"\"\\\na = 'Hello {foo.__dict__}'\nb = a.format_map({foo:str})\n\"\"\"\n\n\ndef test_Guards__safer_getattr__1b():\n    \"\"\"It prevents using the format method of a string.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n    \"\"\"\n    glb = {\n        '__builtins__': safe_builtins,\n    }\n    with pytest.raises(NotImplementedError) as err:\n        restricted_exec(STRING_DOT_FORMAT_MAP_DENIED, glb)\n    assert 'Using the format*() methods of `str` is not safe' == str(err.value)\n\n\n# contributed by Abhishek Govindarasu\nSTR_DOT_FORMAT_DENIED = \"\"\"\\\nstr.format('{0.__class__.__mro__[1]}', int)\n\"\"\"\n\n\ndef test_Guards__safer_getattr__1c():\n    \"\"\"It prevents using the format method of a string.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n    \"\"\"\n    glb = {\n        '__builtins__': safe_builtins,\n    }\n    with pytest.raises(NotImplementedError) as err:\n        restricted_exec(STR_DOT_FORMAT_DENIED, glb)\n    assert 'Using the format*() methods of `str` is not safe' == str(err.value)\n\n\nSTR_DOT_FORMAT_MAP_DENIED = \"\"\"\\\nstr.format_map('Hello {foo.__dict__}', {'foo':str})\n\"\"\"\n\n\ndef test_Guards__safer_getattr__1d():\n    \"\"\"It prevents using the format method of a string.\n\n    format() is considered harmful:\n    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n    \"\"\"\n    glb = {\n        '__builtins__': safe_builtins,\n    }\n    with pytest.raises(NotImplementedError) as err:\n        restricted_exec(STR_DOT_FORMAT_MAP_DENIED, glb)\n    assert 'Using the format*() methods of `str` is not safe' == str(err.value)\n\n\nSAFER_GETATTR_ALLOWED = \"\"\"\\\nclass A:\n\n    def __init__(self, value):\n        self.value = value\n\na = A(2)\nresult = getattr(a, 'value')\n\"\"\"\n\n\ndef test_Guards__safer_getattr__3():\n    \"\"\"It allows to use `safer_getattr`.\"\"\"\n    restricted_globals = dict(\n        __builtins__=safe_builtins,\n        __name__=None,\n        __metaclass__=type,\n        _write_=_write_,\n        getattr=safer_getattr,\n        result=None,\n    )\n    restricted_exec(SAFER_GETATTR_ALLOWED, restricted_globals)\n    assert restricted_globals['result'] == 2\n\n\ndef test_call_py3_builtins():\n    \"\"\"It should not be allowed to access global builtins in Python3.\"\"\"\n    result = compile_restricted_exec('builtins[\"getattr\"]')\n    assert result.code is None\n    assert result.errors == ('Line 1: \"builtins\" is a reserved name.',)\n\n\nGETATTR_UNDERSCORE_NAME = \"\"\"\ngetattr([], '__class__')\n\"\"\"\n\n\ndef test_safer_getattr__underscore_name():\n    \"\"\"It prevents accessing an attribute which starts with an underscore.\"\"\"\n    result = compile_restricted_exec(GETATTR_UNDERSCORE_NAME)\n    assert result.errors == ()\n    assert result.warnings == []\n    glb = safe_globals.copy()\n    glb['getattr'] = safer_getattr\n    with pytest.raises(AttributeError) as err:\n        exec(result.code, glb, {})\n    assert (\n        '\"__class__\" is an invalid attribute name because it starts with \"_\"'\n        == str(err.value))\n", "import pytest\n\nfrom RestrictedPython.Utilities import reorder\nfrom RestrictedPython.Utilities import test\nfrom RestrictedPython.Utilities import utility_builtins\n\n\ndef test_Utilities__test_1():\n    \"\"\"It returns the first arg after the first argument which is True\"\"\"\n    assert test(True, 1, False, 2) == 1\n    assert test(False, 1, True, 2) == 2\n    assert test(False, 1, False, 2, True, 3) == 3\n\n\ndef test_Utilities__test_2():\n    \"\"\"If the above is not met, and there is an extra argument\n    it returns it.\"\"\"\n    assert test(False, 1, False, 2, 3) == 3\n    assert test(False, 1, 2) == 2\n    assert test(1) == 1\n    assert not test(False)\n\n\ndef test_Utilities__test_3():\n    \"\"\"It returns None if there are only False args followed by something.\"\"\"\n    assert test(False, 1) is None\n    assert test(False, 1, False, 2) is None\n\n\ndef test_Utilities__reorder_1():\n    \"\"\"It also supports 2-tuples containing key, value.\"\"\"\n    s = [('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')]\n    _with = [('k2', 'v2'), ('k3', 'v3')]\n    without = [('k2', 'v2'), ('k4', 'v4')]\n    assert reorder(s, _with, without) == [('k3', 'v3')]\n\n\ndef test_Utilities_string_Formatter():\n    \"\"\"Access to ``string.Formatter`` is denied.\"\"\"\n    string = utility_builtins[\"string\"]\n    # access successful in principle\n    assert string.ascii_lowercase == 'abcdefghijklmnopqrstuvwxyz'\n    with pytest.raises(NotImplementedError) as exc:\n        string.Formatter\n    assert 'string.Formatter is not safe' == str(exc.value)\n"], "filenames": ["CHANGES.rst", "src/RestrictedPython/Guards.py", "src/RestrictedPython/Utilities.py", "tests/builtins/test_utilities.py", "tests/test_Guards.py", "tests/test_Utilities.py"], "buggy_code_start_loc": [23, 249, 21, 8, 163, 0], "buggy_code_end_loc": [23, 252, 22, 9, 195, 32], "fixing_code_start_loc": [24, 249, 21, 8, 163, 1], "fixing_code_end_loc": [29, 254, 36, 12, 235, 46], "type": "CWE-74", "message": "RestrictedPython is a restricted execution environment for Python to run untrusted code. Python's \"format\" functionality allows someone controlling the format string to \"read\" all objects accessible through recursive attribute lookup and subscription from objects he can access. This can lead to critical information disclosure. With `RestrictedPython`, the format functionality is available via the `format` and `format_map` methods of `str` (and `unicode`) (accessed either via the class or its instances) and via `string.Formatter`. All known versions of `RestrictedPython` are vulnerable. This issue has been addressed in commit `4134aedcff1` which has been included in the 5.4 and 6.2 releases. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n\n", "other": {"cve": {"id": "CVE-2023-41039", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-30T18:15:09.880", "lastModified": "2023-09-05T15:06:09.130", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RestrictedPython is a restricted execution environment for Python to run untrusted code. Python's \"format\" functionality allows someone controlling the format string to \"read\" all objects accessible through recursive attribute lookup and subscription from objects he can access. This can lead to critical information disclosure. With `RestrictedPython`, the format functionality is available via the `format` and `format_map` methods of `str` (and `unicode`) (accessed either via the class or its instances) and via `string.Formatter`. All known versions of `RestrictedPython` are vulnerable. This issue has been addressed in commit `4134aedcff1` which has been included in the 5.4 and 6.2 releases. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.7, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zope:restrictedpython:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.4", "matchCriteriaId": "674AE8A0-A0AB-428D-9C94-A7A9CBC74B42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zope:restrictedpython:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndExcluding": "6.2", "matchCriteriaId": "012A84D4-106D-4E27-8076-C46D700A779E"}]}]}], "references": [{"url": "https://github.com/zopefoundation/RestrictedPython/commit/4134aedcff17c977da7717693ed89ce56d54c120", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zopefoundation/RestrictedPython/security/advisories/GHSA-xjw2-6jm9-rf67", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zopefoundation/RestrictedPython/commit/4134aedcff17c977da7717693ed89ce56d54c120"}}