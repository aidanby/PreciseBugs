{"buggy_code": ["Thanks to Info-ZIP for info on the DOS-time/date conversion code,\nand some other general information gathered from their sources.\n\nThanks to these people for suggestions, testing, and bug reports:\n\nAlexander Galanin <al@galanin.nnov.ru>\nAlexandr Shadchin <alexandr.shadchin@gmail.com>\nAndrew Brampton <brampton@gmail.com>\nAndrew Molyneux <andrew@molyneuxfamily.co.uk>\nAnkur Kothari <ankz.kothari@gmail.com>\nBALATON Zoltan <balaton@eik.bme.hu>\nBenjamin Gilbert <bgilbert@backtick.net>\nBoaz Stolk <bstolk@aweta.nl>\nBogdan <bogiebog@gmail.com>\nChris Nehren <cnehren+libzip@pobox.com>\nCoverity <info@coverity.com>\nDane Springmeyer <dane.springmeyer@gmail.com>\nDavid Demelier <demelier.david@gmail.com>\nDel Merritt <del@alum.mit.edu>\nDmytro Rybachenko <atmoliton@gmail.com>\nFran\u00e7ois Simon <AT.GFI.Francois.SIMON@sesam-vitale.fr>\nFrederik Ramm <frederik@remote.org>\nHanno B\u00f6ck <hanno@hboeck.de>\nHeiko Hund <heiko@ist.eigentlich.net>\nInfo-ZIP group\nJan Wei\u00df <jan@geheimwerk.de>\nJay Freeman (saurik) <saurik@saurik.com>\nJoel Ebrahimi <joel.ebrahimi@gmail.com>\nJono Spiro <jono.spiro@gmail.com>\nKeith Jones <keith@keithjjones.com>\nKohei Yoshida <kohei.yoshida@gmail.com>\nLeith Bade <leith@mapbox.com>\nLubomir I. Ivanov <neolit123@gmail.com>\nMartin Buchholz <martinrb@google.com>\nMartin Szulecki <m.szulecki@libimobiledevice.org>\nMichael Beck <mm.beck@gmx.net>\nMichal Vyskocil <mvyskocil@suse.cz>\nMikhail Gusarov <dottedmag@dottedmag.net>.\nOliver Kaiser <under.northern.sky@googlemail.com>\nOliver Kuckertz <oliver.kuckertz@mologie.de>\nPascal Terjan <pterjan@gmail.com>\nPatrick Spendrin <ps_ml@gmx.de>\nPaul Harris <harris.pc@gmail.com>\nPaul Sheppard <shepsoft@googlemail.com>\nPierre Joye <pierre.php@gmail.com>\nPierre-Louis Cabelguen <plcabelguen@googlemail.com>\nRemi Collet <remi@fedoraproject.org>\nRick Carback <carback1@umbc.edu>\nRobert Norris <rw_norris@hotmail.com>\nRoberto Tirabassi <rtirabassi@3di.it>\nRoland Ortloff <Ortloff.R@gmx.de>\nSergei Ozerov <ru.programmist@gmail.com>\nSimon Talbot <simont@nse.co.uk>\nStephen Bryant <steve@bawue.de>\nTarmo Pikaro <tapika@yahoo.com>\nTimo Warns <warns@pre-sense.de>\nTom Callaway <tcallawa@redhat.com>\nTomas Hoger <thoger@redhat.com>\nTorsten Paul <Torsten.Paul@gmx.de>\nVassili Courzakis <vcoxvco@googlemail.com>\nWojciech Michalski <wmichalski@quay.pl>\nWolfgang Glunz <Wolfgang.Glunz@gmx.de>\n", "/*\n  zip_dirent.c -- read directory entry (local or central), clean dirent\n  Copyright (C) 1999-2016 Dieter Baron and Thomas Klausner\n\n  This file is part of libzip, a library to manipulate ZIP archives.\n  The authors can be contacted at <libzip@nih.at>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n     distribution.\n  3. The names of the authors may not be used to endorse or promote\n     products derived from this software without specific prior\n     written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n\n#include \"zipint.h\"\n\nstatic time_t _zip_d2u_time(zip_uint16_t, zip_uint16_t);\nstatic zip_string_t *_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str);\nstatic zip_extra_field_t *_zip_ef_utf8(zip_uint16_t, zip_string_t *, zip_error_t *);\nstatic bool _zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error);\n\n\nvoid\n_zip_cdir_free(zip_cdir_t *cd)\n{\n    zip_uint64_t i;\n\n    if (!cd)\n\treturn;\n\n    for (i=0; i<cd->nentry; i++)\n\t_zip_entry_finalize(cd->entry+i);\n    free(cd->entry);\n    _zip_string_free(cd->comment);\n    free(cd);\n}\n\n\nzip_cdir_t *\n_zip_cdir_new(zip_uint64_t nentry, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n\n    if ((cd=(zip_cdir_t *)malloc(sizeof(*cd))) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    cd->entry = NULL;\n    cd->nentry = cd->nentry_alloc = 0;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->is_zip64 = false;\n\n    if (!_zip_cdir_grow(cd, nentry, error)) {\n\t_zip_cdir_free(cd);\n\treturn NULL;\n    }\n\n    return cd;\n}\n\n\nbool\n_zip_cdir_grow(zip_cdir_t *cd, zip_uint64_t additional_entries, zip_error_t *error)\n{\n    zip_uint64_t i, new_alloc;\n    zip_entry_t *new_entry;\n\n    if (additional_entries == 0) {\n\treturn true;\n    }\n\n    new_alloc = cd->nentry_alloc + additional_entries;\n\n    if (new_alloc < additional_entries || new_alloc > SIZE_MAX/sizeof(*(cd->entry))) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn false;\n    }\n\n    if ((new_entry = (zip_entry_t *)realloc(cd->entry, sizeof(*(cd->entry))*(size_t)new_alloc)) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn false;\n    }\n\n    cd->entry = new_entry;\n\n    for (i = cd->nentry; i < new_alloc; i++) {\n\t_zip_entry_init(cd->entry+i);\n    }\n\n    cd->nentry = cd->nentry_alloc = new_alloc;\n\n    return true;\n}\n\n\nzip_int64_t\n_zip_cdir_write(zip_t *za, const zip_filelist_t *filelist, zip_uint64_t survivors)\n{\n    zip_uint64_t offset, size;\n    zip_string_t *comment;\n    zip_uint8_t buf[EOCDLEN + EOCD64LEN + EOCD64LOCLEN];\n    zip_buffer_t *buffer;\n    zip_int64_t off;\n    zip_uint64_t i;\n    bool is_zip64;\n    int ret;\n\n    if ((off = zip_source_tell_write(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return -1;\n    }\n    offset = (zip_uint64_t)off;\n\n    is_zip64 = false;\n\n    for (i=0; i<survivors; i++) {\n\tzip_entry_t *entry = za->entry+filelist[i].idx;\n\n\tif ((ret=_zip_dirent_write(za, entry->changes ? entry->changes : entry->orig, ZIP_FL_CENTRAL)) < 0)\n\t    return -1;\n\tif (ret)\n\t    is_zip64 = true;\n    }\n\n    if ((off = zip_source_tell_write(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return -1;\n    }\n    size = (zip_uint64_t)off - offset;\n\n    if (offset > ZIP_UINT32_MAX || survivors > ZIP_UINT16_MAX)\n\tis_zip64 = true;\n\n\n    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {\n        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n        return -1;\n    }\n\n    if (is_zip64) {\n\t_zip_buffer_put(buffer, EOCD64_MAGIC, 4);\n        _zip_buffer_put_64(buffer, EOCD64LEN-12);\n\t_zip_buffer_put_16(buffer, 45);\n\t_zip_buffer_put_16(buffer, 45);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_64(buffer, survivors);\n\t_zip_buffer_put_64(buffer, survivors);\n\t_zip_buffer_put_64(buffer, size);\n\t_zip_buffer_put_64(buffer, offset);\n\t_zip_buffer_put(buffer, EOCD64LOC_MAGIC, 4);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_64(buffer, offset+size);\n\t_zip_buffer_put_32(buffer, 1);\n    }\n\n    _zip_buffer_put(buffer, EOCD_MAGIC, 4);\n    _zip_buffer_put_32(buffer, 0);\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));\n    _zip_buffer_put_32(buffer, size >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)size);\n    _zip_buffer_put_32(buffer, offset >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)offset);\n\n    comment = za->comment_changed ? za->comment_changes : za->comment_orig;\n\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(comment ? comment->length : 0));\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        return -1;\n    }\n\n    if (_zip_write(za, _zip_buffer_data(buffer), _zip_buffer_offset(buffer)) < 0) {\n        _zip_buffer_free(buffer);\n\treturn -1;\n    }\n\n    _zip_buffer_free(buffer);\n\n    if (comment) {\n\tif (_zip_write(za, comment->raw, comment->length) < 0) {\n\t    return -1;\n\t}\n    }\n\n    return (zip_int64_t)size;\n}\n\n\nzip_dirent_t *\n_zip_dirent_clone(const zip_dirent_t *sde)\n{\n    zip_dirent_t *tde;\n\n    if ((tde=(zip_dirent_t *)malloc(sizeof(*tde))) == NULL)\n\treturn NULL;\n\n    if (sde)\n\tmemcpy(tde, sde, sizeof(*sde));\n    else\n\t_zip_dirent_init(tde);\n\n    tde->changed = 0;\n    tde->cloned = 1;\n\n    return tde;\n}\n\n\nvoid\n_zip_dirent_finalize(zip_dirent_t *zde)\n{\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_FILENAME) {\n\t_zip_string_free(zde->filename);\n\tzde->filename = NULL;\n    }\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_EXTRA_FIELD) {\n\t_zip_ef_free(zde->extra_fields);\n\tzde->extra_fields = NULL;\n    }\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_COMMENT) {\n\t_zip_string_free(zde->comment);\n\tzde->comment = NULL;\n    }\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_PASSWORD) {\n\tif (zde->password) {\n\t    _zip_crypto_clear(zde->password, strlen(zde->password));\n\t}\n\tfree(zde->password);\n\tzde->password = NULL;\n    }\n}\n\n\nvoid\n_zip_dirent_free(zip_dirent_t *zde)\n{\n    if (zde == NULL)\n\treturn;\n\n    _zip_dirent_finalize(zde);\n    free(zde);\n}\n\n\nvoid\n_zip_dirent_init(zip_dirent_t *de)\n{\n    de->changed = 0;\n    de->local_extra_fields_read = 0;\n    de->cloned = 0;\n\n    de->crc_valid = true;\n    de->version_madeby = 63 | (ZIP_OPSYS_DEFAULT << 8);\n    de->version_needed = 10; /* 1.0 */\n    de->bitflags = 0;\n    de->comp_method = ZIP_CM_DEFAULT;\n    de->last_mod = 0;\n    de->crc = 0;\n    de->comp_size = 0;\n    de->uncomp_size = 0;\n    de->filename = NULL;\n    de->extra_fields = NULL;\n    de->comment = NULL;\n    de->disk_number = 0;\n    de->int_attrib = 0;\n    de->ext_attrib = ZIP_EXT_ATTRIB_DEFAULT;\n    de->offset = 0;\n    de->compression_level = 0;\n    de->encryption_method = ZIP_EM_NONE;\n    de->password = NULL;\n}\n\n\nbool\n_zip_dirent_needs_zip64(const zip_dirent_t *de, zip_flags_t flags)\n{\n    if (de->uncomp_size >= ZIP_UINT32_MAX || de->comp_size >= ZIP_UINT32_MAX\n\t|| ((flags & ZIP_FL_CENTRAL) && de->offset >= ZIP_UINT32_MAX))\n\treturn true;\n\n    return false;\n}\n\n\nzip_dirent_t *\n_zip_dirent_new(void)\n{\n    zip_dirent_t *de;\n\n    if ((de=(zip_dirent_t *)malloc(sizeof(*de))) == NULL)\n\treturn NULL;\n\n    _zip_dirent_init(de);\n    return de;\n}\n\n\n/* _zip_dirent_read(zde, fp, bufp, left, localp, error):\n   Fills the zip directory entry zde.\n\n   If buffer is non-NULL, data is taken from there; otherwise data is read from fp as needed.\n\n   If local is true, it reads a local header instead of a central directory entry.\n\n   Returns size of dirent read if successful. On error, error is filled in and -1 is returned.\n*/\n\nzip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\tif (!from_buffer) {\n\t    _zip_buffer_free(buffer);\n\t}\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}\n\n\nstatic zip_string_t *\n_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str)\n{\n    zip_uint16_t ef_len;\n    zip_uint32_t ef_crc;\n    zip_buffer_t *buffer;\n\n    const zip_uint8_t *ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, id, 0, ZIP_EF_BOTH, NULL);\n\n    if (ef == NULL || ef_len < 5 || ef[0] != 1) {\n\treturn str;\n    }\n\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n        return str;\n    }\n\n    _zip_buffer_get_8(buffer);\n    ef_crc = _zip_buffer_get_32(buffer);\n\n    if (_zip_string_crc32(str) == ef_crc) {\n        zip_uint16_t len = (zip_uint16_t)_zip_buffer_left(buffer);\n        zip_string_t *ef_str = _zip_string_new(_zip_buffer_get(buffer, len), len, ZIP_FL_ENC_UTF_8, NULL);\n\n\tif (ef_str != NULL) {\n\t    _zip_string_free(str);\n\t    str = ef_str;\n\t}\n    }\n\n    _zip_buffer_free(buffer);\n\n    return str;\n}\n\n\nstatic bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t enc_method;\n\n\n    if (de->comp_method != ZIP_CM_WINZIP_AES) {\n\treturn true;\n    }\n\n    ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, ZIP_EF_WINZIP_AES, 0, ZIP_EF_BOTH, NULL);\n\n    if (ef == NULL || ef_len < 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn false;\n    }\n\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n\tzip_error_set(error, ZIP_ER_INTERNAL, 0);\n        return false;\n    }\n\n    /* version */\n\n    crc_valid = true;\n    switch (_zip_buffer_get_16(buffer)) {\n    case 1:\n\tbreak;\n\n    case 2:\n\tif (de->uncomp_size < 20 /* TODO: constant */) {\n\t    crc_valid = false;\n\t}\n\tbreak;\n\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    /* vendor */\n    if (memcmp(_zip_buffer_get(buffer, 2), \"AE\", 2) != 0) {\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    /* mode */\n    switch (_zip_buffer_get_8(buffer)) {\n    case 1:\n\tenc_method = ZIP_EM_AES_128;\n\tbreak;\n    case 2:\n\tenc_method = ZIP_EM_AES_192;\n\tbreak;\n    case 3:\n\tenc_method = ZIP_EM_AES_256;\n\tbreak;\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    if (ef_len != 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    de->crc_valid = crc_valid;\n    de->encryption_method = enc_method;\n    de->comp_method = _zip_buffer_get_16(buffer);\n\n    _zip_buffer_free(buffer);\n    return true;\n}\n\n\nzip_int32_t\n_zip_dirent_size(zip_source_t *src, zip_uint16_t flags, zip_error_t *error)\n{\n    zip_int32_t size;\n    bool local = (flags & ZIP_EF_LOCAL) != 0;\n    int i;\n    zip_uint8_t b[6];\n    zip_buffer_t *buffer;\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (zip_source_seek(src, local ? 26 : 28, SEEK_CUR) < 0) {\n        _zip_error_set_from_source(error, src);\n\treturn -1;\n    }\n\n    if ((buffer = _zip_buffer_new_from_source(src, local ? 4 : 6, b, error)) == NULL) {\n\treturn -1;\n    }\n\n    for (i=0; i<(local ? 2 : 3); i++) {\n\tsize += _zip_buffer_get_16(buffer);\n    }\n\n    if (!_zip_buffer_eof(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n\t_zip_buffer_free(buffer);\n        return -1;\n    }\n\n    _zip_buffer_free(buffer);\n    return size;\n}\n\n\n/* _zip_dirent_write\n   Writes zip directory entry.\n\n   If flags & ZIP_EF_LOCAL, it writes a local header instead of a central\n   directory entry.  If flags & ZIP_EF_FORCE_ZIP64, a ZIP64 extra field is written, even if not needed.\n\n   Returns 0 if successful, 1 if successful and wrote ZIP64 extra field. On error, error is filled in and -1 is\n   returned.\n*/\n\nint\n_zip_dirent_write(zip_t *za, zip_dirent_t *de, zip_flags_t flags)\n{\n    zip_uint16_t dostime, dosdate;\n    zip_encoding_type_t com_enc, name_enc;\n    zip_extra_field_t *ef;\n    zip_extra_field_t *ef64;\n    zip_uint32_t ef_total_size;\n    bool is_zip64;\n    bool is_really_zip64;\n    bool is_winzip_aes;\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_buffer_t *buffer;\n\n    ef = NULL;\n\n    name_enc = _zip_guess_encoding(de->filename, ZIP_ENCODING_UNKNOWN);\n    com_enc = _zip_guess_encoding(de->comment, ZIP_ENCODING_UNKNOWN);\n\n    if ((name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_ASCII) ||\n\t(name_enc == ZIP_ENCODING_ASCII && com_enc == ZIP_ENCODING_UTF8_KNOWN) ||\n\t(name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_UTF8_KNOWN))\n\tde->bitflags |= ZIP_GPBF_ENCODING_UTF_8;\n    else {\n\tde->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCODING_UTF_8;\n\tif (name_enc == ZIP_ENCODING_UTF8_KNOWN) {\n\t    ef = _zip_ef_utf8(ZIP_EF_UTF_8_NAME, de->filename, &za->error);\n\t    if (ef == NULL)\n\t\treturn -1;\n\t}\n\tif ((flags & ZIP_FL_LOCAL) == 0 && com_enc == ZIP_ENCODING_UTF8_KNOWN){\n\t    zip_extra_field_t *ef2 = _zip_ef_utf8(ZIP_EF_UTF_8_COMMENT, de->comment, &za->error);\n\t    if (ef2 == NULL) {\n\t\t_zip_ef_free(ef);\n\t\treturn -1;\n\t    }\n\t    ef2->next = ef;\n\t    ef = ef2;\n\t}\n    }\n\n    if (de->encryption_method == ZIP_EM_NONE) {\n\tde->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCRYPTED;\n    }\n    else {\n\tde->bitflags |= (zip_uint16_t)ZIP_GPBF_ENCRYPTED;\n    }\n\n    is_really_zip64 = _zip_dirent_needs_zip64(de, flags);\n    is_zip64 = (flags & (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64)) == (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64) || is_really_zip64;\n    is_winzip_aes = de->encryption_method == ZIP_EM_AES_128 || de->encryption_method == ZIP_EM_AES_192 || de->encryption_method == ZIP_EM_AES_256;\n\n    if (is_zip64) {\n        zip_uint8_t ef_zip64[EFZIP64SIZE];\n        zip_buffer_t *ef_buffer = _zip_buffer_new(ef_zip64, sizeof(ef_zip64));\n        if (ef_buffer == NULL) {\n            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n        if (flags & ZIP_FL_LOCAL) {\n            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX) {\n                _zip_buffer_put_64(ef_buffer, de->uncomp_size);\n                _zip_buffer_put_64(ef_buffer, de->comp_size);\n            }\n        }\n        else {\n            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX || de->offset > ZIP_UINT32_MAX) {\n                if (de->uncomp_size >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->uncomp_size);\n                }\n                if (de->comp_size >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->comp_size);\n                }\n                if (de->offset >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->offset);\n                }\n            }\n        }\n\n        if (!_zip_buffer_ok(ef_buffer)) {\n            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n            _zip_buffer_free(ef_buffer);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n        ef64 = _zip_ef_new(ZIP_EF_ZIP64, (zip_uint16_t)(_zip_buffer_offset(ef_buffer)), ef_zip64, ZIP_EF_BOTH);\n        _zip_buffer_free(ef_buffer);\n        ef64->next = ef;\n        ef = ef64;\n    }\n\n    if (is_winzip_aes) {\n\tzip_uint8_t data[EF_WINZIP_AES_SIZE];\n        zip_buffer_t *ef_buffer = _zip_buffer_new(data, sizeof(data));\n\tzip_extra_field_t *ef_winzip;\n\t\n        if (ef_buffer == NULL) {\n            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n\t_zip_buffer_put_16(ef_buffer, 2);\n\t_zip_buffer_put(ef_buffer, \"AE\", 2);\n\t_zip_buffer_put_8(ef_buffer, (zip_uint8_t)(de->encryption_method & 0xff));\n\t_zip_buffer_put_16(ef_buffer, (zip_uint16_t)de->comp_method);\n\n        if (!_zip_buffer_ok(ef_buffer)) {\n            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n            _zip_buffer_free(ef_buffer);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n        ef_winzip = _zip_ef_new(ZIP_EF_WINZIP_AES, EF_WINZIP_AES_SIZE, data, ZIP_EF_BOTH);\n        _zip_buffer_free(ef_buffer);\n        ef_winzip->next = ef;\n        ef = ef_winzip;\n    }\n\n    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {\n        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n        _zip_ef_free(ef);\n        return -1;\n    }\n\n    _zip_buffer_put(buffer, (flags & ZIP_FL_LOCAL) ? LOCAL_MAGIC : CENTRAL_MAGIC, 4);\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n        _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_madeby));\n    }\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_needed));\n    _zip_buffer_put_16(buffer, de->bitflags);\n    if (is_winzip_aes) {\n\t_zip_buffer_put_16(buffer, ZIP_CM_WINZIP_AES);\n    }\n    else {\n\t_zip_buffer_put_16(buffer, (zip_uint16_t)de->comp_method);\n    }\n\n    _zip_u2d_time(de->last_mod, &dostime, &dosdate);\n    _zip_buffer_put_16(buffer, dostime);\n    _zip_buffer_put_16(buffer, dosdate);\n\n    if (is_winzip_aes && de->uncomp_size < 20)  {\n\t_zip_buffer_put_32(buffer, 0);\n    }\n    else {\n\t_zip_buffer_put_32(buffer, de->crc);\n    }\n\n    if (((flags & ZIP_FL_LOCAL) == ZIP_FL_LOCAL) && ((de->comp_size >= ZIP_UINT32_MAX) || (de->uncomp_size >= ZIP_UINT32_MAX))) {\n\t/* In local headers, if a ZIP64 EF is written, it MUST contain\n\t * both compressed and uncompressed sizes (even if one of the\n\t * two is smaller than 0xFFFFFFFF); on the other hand, those\n\t * may only appear when the corresponding standard entry is\n\t * 0xFFFFFFFF.  (appnote.txt 4.5.3) */\n\t_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n\t_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n    }\n    else {\n        if (de->comp_size < ZIP_UINT32_MAX) {\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->comp_size);\n        }\n        else {\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n        }\n        if (de->uncomp_size < ZIP_UINT32_MAX) {\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->uncomp_size);\n        }\n        else {\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n        }\n    }\n\n    _zip_buffer_put_16(buffer, _zip_string_length(de->filename));\n    /* TODO: check for overflow */\n    ef_total_size = (zip_uint32_t)_zip_ef_size(de->extra_fields, flags) + (zip_uint32_t)_zip_ef_size(ef, ZIP_EF_BOTH);\n    _zip_buffer_put_16(buffer, (zip_uint16_t)ef_total_size);\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\t_zip_buffer_put_16(buffer, _zip_string_length(de->comment));\n\t_zip_buffer_put_16(buffer, (zip_uint16_t)de->disk_number);\n\t_zip_buffer_put_16(buffer, de->int_attrib);\n\t_zip_buffer_put_32(buffer, de->ext_attrib);\n\tif (de->offset < ZIP_UINT32_MAX)\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->offset);\n\telse\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        _zip_ef_free(ef);\n        return -1;\n    }\n\n    if (_zip_write(za, buf, _zip_buffer_offset(buffer)) < 0) {\n        _zip_buffer_free(buffer);\n        _zip_ef_free(ef);\n        return -1;\n    }\n\n    _zip_buffer_free(buffer);\n\n    if (de->filename) {\n\tif (_zip_string_write(za, de->filename) < 0) {\n            _zip_ef_free(ef);\n\t    return -1;\n\t}\n    }\n\n    if (ef) {\n\tif (_zip_ef_write(za, ef, ZIP_EF_BOTH) < 0) {\n            _zip_ef_free(ef);\n\t    return -1;\n\t}\n    }\n    _zip_ef_free(ef);\n    if (de->extra_fields) {\n\tif (_zip_ef_write(za, de->extra_fields, flags) < 0) {\n\t    return -1;\n\t}\n    }\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\tif (de->comment) {\n\t    if (_zip_string_write(za, de->comment) < 0) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n\n    return is_zip64;\n}\n\n\nstatic time_t\n_zip_d2u_time(zip_uint16_t dtime, zip_uint16_t ddate)\n{\n    struct tm tm;\n\n    memset(&tm, 0, sizeof(tm));\n\n    /* let mktime decide if DST is in effect */\n    tm.tm_isdst = -1;\n\n    tm.tm_year = ((ddate>>9)&127) + 1980 - 1900;\n    tm.tm_mon = ((ddate>>5)&15) - 1;\n    tm.tm_mday = ddate&31;\n\n    tm.tm_hour = (dtime>>11)&31;\n    tm.tm_min = (dtime>>5)&63;\n    tm.tm_sec = (dtime<<1)&62;\n\n    return mktime(&tm);\n}\n\n\nstatic zip_extra_field_t *\n_zip_ef_utf8(zip_uint16_t id, zip_string_t *str, zip_error_t *error)\n{\n    const zip_uint8_t *raw;\n    zip_uint32_t len;\n    zip_buffer_t *buffer;\n    zip_extra_field_t *ef;\n\n    if ((raw=_zip_string_get(str, &len, ZIP_FL_ENC_RAW, NULL)) == NULL) {\n\t/* error already set */\n\treturn NULL;\n    }\n\n    if (len+5 > ZIP_UINT16_MAX) {\n        zip_error_set(error, ZIP_ER_INVAL, 0); /* TODO: better error code? */\n        return NULL;\n    }\n\n    if ((buffer = _zip_buffer_new(NULL, len+5)) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    _zip_buffer_put_8(buffer, 1);\n    _zip_buffer_put_32(buffer, _zip_string_crc32(str));\n    _zip_buffer_put(buffer, raw, len);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        return NULL;\n    }\n\n    ef = _zip_ef_new(id, (zip_uint16_t)(_zip_buffer_offset(buffer)), _zip_buffer_data(buffer), ZIP_EF_BOTH);\n    _zip_buffer_free(buffer);\n\n    return ef;\n}\n\n\nzip_dirent_t *\n_zip_get_dirent(zip_t *za, zip_uint64_t idx, zip_flags_t flags, zip_error_t *error)\n{\n    if (error == NULL)\n\terror = &za->error;\n\n    if (idx >= za->nentry) {\n\tzip_error_set(error, ZIP_ER_INVAL, 0);\n\treturn NULL;\n    }\n\n    if ((flags & ZIP_FL_UNCHANGED) || za->entry[idx].changes == NULL) {\n\tif (za->entry[idx].orig == NULL) {\n\t    zip_error_set(error, ZIP_ER_INVAL, 0);\n\t    return NULL;\n\t}\n\tif (za->entry[idx].deleted && (flags & ZIP_FL_UNCHANGED) == 0) {\n\t    zip_error_set(error, ZIP_ER_DELETED, 0);\n\t    return NULL;\n\t}\n\treturn za->entry[idx].orig;\n    }\n    else\n\treturn za->entry[idx].changes;\n}\n\n\n\n\nvoid\n_zip_u2d_time(time_t intime, zip_uint16_t *dtime, zip_uint16_t *ddate)\n{\n    struct tm *tm;\n\n    tm = localtime(&intime);\n    if (tm->tm_year < 80) {\n\ttm->tm_year = 80;\n    }\n\n    *ddate = (zip_uint16_t)(((tm->tm_year+1900-1980)<<9) + ((tm->tm_mon+1)<<5) + tm->tm_mday);\n    *dtime = (zip_uint16_t)(((tm->tm_hour)<<11) + ((tm->tm_min)<<5) + ((tm->tm_sec)>>1));\n\n    return;\n}\n\n\nvoid\n_zip_dirent_set_version_needed(zip_dirent_t *de, bool force_zip64) {\n    zip_uint16_t length;\n\n    if (de->comp_method == ZIP_CM_LZMA) {\n\tde->version_needed = 63;\n\treturn;\n    }\n\n    if (de->comp_method == ZIP_CM_BZIP2) {\n\tde->version_needed = 46;\n\treturn;\n    }\n\n    if (force_zip64 || _zip_dirent_needs_zip64(de, 0)) {\n\tde->version_needed = 45;\n\treturn;\n    }\n    \n    if (de->comp_method == ZIP_CM_DEFLATE || de->encryption_method == ZIP_EM_TRAD_PKWARE) {\n\tde->version_needed = 20;\n\treturn;\n    }\n\n    /* directory */\n    if ((length = _zip_string_length(de->filename)) > 0) {\n\tif (de->filename->raw[length-1] == '/') {\n\t    de->version_needed = 20;\n\t    return;\n\t}\n    }\n    \n    de->version_needed = 10;\n}\n"], "fixing_code": ["Thanks to Info-ZIP for info on the DOS-time/date conversion code,\nand some other general information gathered from their sources.\n\nThanks to these people for suggestions, testing, and bug reports:\n\nAlexander Galanin <al@galanin.nnov.ru>\nAlexandr Shadchin <alexandr.shadchin@gmail.com>\nAndrew Brampton <brampton@gmail.com>\nAndrew Molyneux <andrew@molyneuxfamily.co.uk>\nAnkur Kothari <ankz.kothari@gmail.com>\nBALATON Zoltan <balaton@eik.bme.hu>\nBenjamin Gilbert <bgilbert@backtick.net>\nBoaz Stolk <bstolk@aweta.nl>\nBogdan <bogiebog@gmail.com>\nBrian 'geeknik' Carpenter <geeknik@protonmail.ch>\nChris Nehren <cnehren+libzip@pobox.com>\nCoverity <info@coverity.com>\nDane Springmeyer <dane.springmeyer@gmail.com>\nDavid Demelier <demelier.david@gmail.com>\nDel Merritt <del@alum.mit.edu>\nDmytro Rybachenko <atmoliton@gmail.com>\nFran\u00e7ois Simon <AT.GFI.Francois.SIMON@sesam-vitale.fr>\nFrederik Ramm <frederik@remote.org>\nHanno B\u00f6ck <hanno@hboeck.de>\nHeiko Hund <heiko@ist.eigentlich.net>\nInfo-ZIP group\nJan Wei\u00df <jan@geheimwerk.de>\nJay Freeman (saurik) <saurik@saurik.com>\nJoel Ebrahimi <joel.ebrahimi@gmail.com>\nJono Spiro <jono.spiro@gmail.com>\nKeith Jones <keith@keithjjones.com>\nKohei Yoshida <kohei.yoshida@gmail.com>\nLeith Bade <leith@mapbox.com>\nLubomir I. Ivanov <neolit123@gmail.com>\nMartin Buchholz <martinrb@google.com>\nMartin Szulecki <m.szulecki@libimobiledevice.org>\nMichael Beck <mm.beck@gmx.net>\nMichal Vyskocil <mvyskocil@suse.cz>\nMikhail Gusarov <dottedmag@dottedmag.net>.\nOliver Kaiser <under.northern.sky@googlemail.com>\nOliver Kuckertz <oliver.kuckertz@mologie.de>\nPascal Terjan <pterjan@gmail.com>\nPatrick Spendrin <ps_ml@gmx.de>\nPaul Harris <harris.pc@gmail.com>\nPaul Sheppard <shepsoft@googlemail.com>\nPierre Joye <pierre.php@gmail.com>\nPierre-Louis Cabelguen <plcabelguen@googlemail.com>\nRemi Collet <remi@fedoraproject.org>\nRick Carback <carback1@umbc.edu>\nRobert Norris <rw_norris@hotmail.com>\nRoberto Tirabassi <rtirabassi@3di.it>\nRoland Ortloff <Ortloff.R@gmx.de>\nSergei Ozerov <ru.programmist@gmail.com>\nSimon Talbot <simont@nse.co.uk>\nStephen Bryant <steve@bawue.de>\nTarmo Pikaro <tapika@yahoo.com>\nTimo Warns <warns@pre-sense.de>\nTom Callaway <tcallawa@redhat.com>\nTomas Hoger <thoger@redhat.com>\nTorsten Paul <Torsten.Paul@gmx.de>\nVassili Courzakis <vcoxvco@googlemail.com>\nWojciech Michalski <wmichalski@quay.pl>\nWolfgang Glunz <Wolfgang.Glunz@gmx.de>\n", "/*\n  zip_dirent.c -- read directory entry (local or central), clean dirent\n  Copyright (C) 1999-2016 Dieter Baron and Thomas Klausner\n\n  This file is part of libzip, a library to manipulate ZIP archives.\n  The authors can be contacted at <libzip@nih.at>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n     distribution.\n  3. The names of the authors may not be used to endorse or promote\n     products derived from this software without specific prior\n     written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n\n#include \"zipint.h\"\n\nstatic time_t _zip_d2u_time(zip_uint16_t, zip_uint16_t);\nstatic zip_string_t *_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str);\nstatic zip_extra_field_t *_zip_ef_utf8(zip_uint16_t, zip_string_t *, zip_error_t *);\nstatic bool _zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error);\n\n\nvoid\n_zip_cdir_free(zip_cdir_t *cd)\n{\n    zip_uint64_t i;\n\n    if (!cd)\n\treturn;\n\n    for (i=0; i<cd->nentry; i++)\n\t_zip_entry_finalize(cd->entry+i);\n    free(cd->entry);\n    _zip_string_free(cd->comment);\n    free(cd);\n}\n\n\nzip_cdir_t *\n_zip_cdir_new(zip_uint64_t nentry, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n\n    if ((cd=(zip_cdir_t *)malloc(sizeof(*cd))) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    cd->entry = NULL;\n    cd->nentry = cd->nentry_alloc = 0;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->is_zip64 = false;\n\n    if (!_zip_cdir_grow(cd, nentry, error)) {\n\t_zip_cdir_free(cd);\n\treturn NULL;\n    }\n\n    return cd;\n}\n\n\nbool\n_zip_cdir_grow(zip_cdir_t *cd, zip_uint64_t additional_entries, zip_error_t *error)\n{\n    zip_uint64_t i, new_alloc;\n    zip_entry_t *new_entry;\n\n    if (additional_entries == 0) {\n\treturn true;\n    }\n\n    new_alloc = cd->nentry_alloc + additional_entries;\n\n    if (new_alloc < additional_entries || new_alloc > SIZE_MAX/sizeof(*(cd->entry))) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn false;\n    }\n\n    if ((new_entry = (zip_entry_t *)realloc(cd->entry, sizeof(*(cd->entry))*(size_t)new_alloc)) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn false;\n    }\n\n    cd->entry = new_entry;\n\n    for (i = cd->nentry; i < new_alloc; i++) {\n\t_zip_entry_init(cd->entry+i);\n    }\n\n    cd->nentry = cd->nentry_alloc = new_alloc;\n\n    return true;\n}\n\n\nzip_int64_t\n_zip_cdir_write(zip_t *za, const zip_filelist_t *filelist, zip_uint64_t survivors)\n{\n    zip_uint64_t offset, size;\n    zip_string_t *comment;\n    zip_uint8_t buf[EOCDLEN + EOCD64LEN + EOCD64LOCLEN];\n    zip_buffer_t *buffer;\n    zip_int64_t off;\n    zip_uint64_t i;\n    bool is_zip64;\n    int ret;\n\n    if ((off = zip_source_tell_write(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return -1;\n    }\n    offset = (zip_uint64_t)off;\n\n    is_zip64 = false;\n\n    for (i=0; i<survivors; i++) {\n\tzip_entry_t *entry = za->entry+filelist[i].idx;\n\n\tif ((ret=_zip_dirent_write(za, entry->changes ? entry->changes : entry->orig, ZIP_FL_CENTRAL)) < 0)\n\t    return -1;\n\tif (ret)\n\t    is_zip64 = true;\n    }\n\n    if ((off = zip_source_tell_write(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return -1;\n    }\n    size = (zip_uint64_t)off - offset;\n\n    if (offset > ZIP_UINT32_MAX || survivors > ZIP_UINT16_MAX)\n\tis_zip64 = true;\n\n\n    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {\n        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n        return -1;\n    }\n\n    if (is_zip64) {\n\t_zip_buffer_put(buffer, EOCD64_MAGIC, 4);\n        _zip_buffer_put_64(buffer, EOCD64LEN-12);\n\t_zip_buffer_put_16(buffer, 45);\n\t_zip_buffer_put_16(buffer, 45);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_64(buffer, survivors);\n\t_zip_buffer_put_64(buffer, survivors);\n\t_zip_buffer_put_64(buffer, size);\n\t_zip_buffer_put_64(buffer, offset);\n\t_zip_buffer_put(buffer, EOCD64LOC_MAGIC, 4);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_64(buffer, offset+size);\n\t_zip_buffer_put_32(buffer, 1);\n    }\n\n    _zip_buffer_put(buffer, EOCD_MAGIC, 4);\n    _zip_buffer_put_32(buffer, 0);\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));\n    _zip_buffer_put_32(buffer, size >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)size);\n    _zip_buffer_put_32(buffer, offset >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)offset);\n\n    comment = za->comment_changed ? za->comment_changes : za->comment_orig;\n\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(comment ? comment->length : 0));\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        return -1;\n    }\n\n    if (_zip_write(za, _zip_buffer_data(buffer), _zip_buffer_offset(buffer)) < 0) {\n        _zip_buffer_free(buffer);\n\treturn -1;\n    }\n\n    _zip_buffer_free(buffer);\n\n    if (comment) {\n\tif (_zip_write(za, comment->raw, comment->length) < 0) {\n\t    return -1;\n\t}\n    }\n\n    return (zip_int64_t)size;\n}\n\n\nzip_dirent_t *\n_zip_dirent_clone(const zip_dirent_t *sde)\n{\n    zip_dirent_t *tde;\n\n    if ((tde=(zip_dirent_t *)malloc(sizeof(*tde))) == NULL)\n\treturn NULL;\n\n    if (sde)\n\tmemcpy(tde, sde, sizeof(*sde));\n    else\n\t_zip_dirent_init(tde);\n\n    tde->changed = 0;\n    tde->cloned = 1;\n\n    return tde;\n}\n\n\nvoid\n_zip_dirent_finalize(zip_dirent_t *zde)\n{\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_FILENAME) {\n\t_zip_string_free(zde->filename);\n\tzde->filename = NULL;\n    }\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_EXTRA_FIELD) {\n\t_zip_ef_free(zde->extra_fields);\n\tzde->extra_fields = NULL;\n    }\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_COMMENT) {\n\t_zip_string_free(zde->comment);\n\tzde->comment = NULL;\n    }\n    if (!zde->cloned || zde->changed & ZIP_DIRENT_PASSWORD) {\n\tif (zde->password) {\n\t    _zip_crypto_clear(zde->password, strlen(zde->password));\n\t}\n\tfree(zde->password);\n\tzde->password = NULL;\n    }\n}\n\n\nvoid\n_zip_dirent_free(zip_dirent_t *zde)\n{\n    if (zde == NULL)\n\treturn;\n\n    _zip_dirent_finalize(zde);\n    free(zde);\n}\n\n\nvoid\n_zip_dirent_init(zip_dirent_t *de)\n{\n    de->changed = 0;\n    de->local_extra_fields_read = 0;\n    de->cloned = 0;\n\n    de->crc_valid = true;\n    de->version_madeby = 63 | (ZIP_OPSYS_DEFAULT << 8);\n    de->version_needed = 10; /* 1.0 */\n    de->bitflags = 0;\n    de->comp_method = ZIP_CM_DEFAULT;\n    de->last_mod = 0;\n    de->crc = 0;\n    de->comp_size = 0;\n    de->uncomp_size = 0;\n    de->filename = NULL;\n    de->extra_fields = NULL;\n    de->comment = NULL;\n    de->disk_number = 0;\n    de->int_attrib = 0;\n    de->ext_attrib = ZIP_EXT_ATTRIB_DEFAULT;\n    de->offset = 0;\n    de->compression_level = 0;\n    de->encryption_method = ZIP_EM_NONE;\n    de->password = NULL;\n}\n\n\nbool\n_zip_dirent_needs_zip64(const zip_dirent_t *de, zip_flags_t flags)\n{\n    if (de->uncomp_size >= ZIP_UINT32_MAX || de->comp_size >= ZIP_UINT32_MAX\n\t|| ((flags & ZIP_FL_CENTRAL) && de->offset >= ZIP_UINT32_MAX))\n\treturn true;\n\n    return false;\n}\n\n\nzip_dirent_t *\n_zip_dirent_new(void)\n{\n    zip_dirent_t *de;\n\n    if ((de=(zip_dirent_t *)malloc(sizeof(*de))) == NULL)\n\treturn NULL;\n\n    _zip_dirent_init(de);\n    return de;\n}\n\n\n/* _zip_dirent_read(zde, fp, bufp, left, localp, error):\n   Fills the zip directory entry zde.\n\n   If buffer is non-NULL, data is taken from there; otherwise data is read from fp as needed.\n\n   If local is true, it reads a local header instead of a central directory entry.\n\n   Returns size of dirent read if successful. On error, error is filled in and -1 is returned.\n*/\n\nzip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}\n\n\nstatic zip_string_t *\n_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str)\n{\n    zip_uint16_t ef_len;\n    zip_uint32_t ef_crc;\n    zip_buffer_t *buffer;\n\n    const zip_uint8_t *ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, id, 0, ZIP_EF_BOTH, NULL);\n\n    if (ef == NULL || ef_len < 5 || ef[0] != 1) {\n\treturn str;\n    }\n\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n        return str;\n    }\n\n    _zip_buffer_get_8(buffer);\n    ef_crc = _zip_buffer_get_32(buffer);\n\n    if (_zip_string_crc32(str) == ef_crc) {\n        zip_uint16_t len = (zip_uint16_t)_zip_buffer_left(buffer);\n        zip_string_t *ef_str = _zip_string_new(_zip_buffer_get(buffer, len), len, ZIP_FL_ENC_UTF_8, NULL);\n\n\tif (ef_str != NULL) {\n\t    _zip_string_free(str);\n\t    str = ef_str;\n\t}\n    }\n\n    _zip_buffer_free(buffer);\n\n    return str;\n}\n\n\nstatic bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t enc_method;\n\n\n    if (de->comp_method != ZIP_CM_WINZIP_AES) {\n\treturn true;\n    }\n\n    ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, ZIP_EF_WINZIP_AES, 0, ZIP_EF_BOTH, NULL);\n\n    if (ef == NULL || ef_len < 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn false;\n    }\n\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n\tzip_error_set(error, ZIP_ER_INTERNAL, 0);\n        return false;\n    }\n\n    /* version */\n\n    crc_valid = true;\n    switch (_zip_buffer_get_16(buffer)) {\n    case 1:\n\tbreak;\n\n    case 2:\n\tif (de->uncomp_size < 20 /* TODO: constant */) {\n\t    crc_valid = false;\n\t}\n\tbreak;\n\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    /* vendor */\n    if (memcmp(_zip_buffer_get(buffer, 2), \"AE\", 2) != 0) {\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    /* mode */\n    switch (_zip_buffer_get_8(buffer)) {\n    case 1:\n\tenc_method = ZIP_EM_AES_128;\n\tbreak;\n    case 2:\n\tenc_method = ZIP_EM_AES_192;\n\tbreak;\n    case 3:\n\tenc_method = ZIP_EM_AES_256;\n\tbreak;\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    if (ef_len != 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    de->crc_valid = crc_valid;\n    de->encryption_method = enc_method;\n    de->comp_method = _zip_buffer_get_16(buffer);\n\n    _zip_buffer_free(buffer);\n    return true;\n}\n\n\nzip_int32_t\n_zip_dirent_size(zip_source_t *src, zip_uint16_t flags, zip_error_t *error)\n{\n    zip_int32_t size;\n    bool local = (flags & ZIP_EF_LOCAL) != 0;\n    int i;\n    zip_uint8_t b[6];\n    zip_buffer_t *buffer;\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (zip_source_seek(src, local ? 26 : 28, SEEK_CUR) < 0) {\n        _zip_error_set_from_source(error, src);\n\treturn -1;\n    }\n\n    if ((buffer = _zip_buffer_new_from_source(src, local ? 4 : 6, b, error)) == NULL) {\n\treturn -1;\n    }\n\n    for (i=0; i<(local ? 2 : 3); i++) {\n\tsize += _zip_buffer_get_16(buffer);\n    }\n\n    if (!_zip_buffer_eof(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n\t_zip_buffer_free(buffer);\n        return -1;\n    }\n\n    _zip_buffer_free(buffer);\n    return size;\n}\n\n\n/* _zip_dirent_write\n   Writes zip directory entry.\n\n   If flags & ZIP_EF_LOCAL, it writes a local header instead of a central\n   directory entry.  If flags & ZIP_EF_FORCE_ZIP64, a ZIP64 extra field is written, even if not needed.\n\n   Returns 0 if successful, 1 if successful and wrote ZIP64 extra field. On error, error is filled in and -1 is\n   returned.\n*/\n\nint\n_zip_dirent_write(zip_t *za, zip_dirent_t *de, zip_flags_t flags)\n{\n    zip_uint16_t dostime, dosdate;\n    zip_encoding_type_t com_enc, name_enc;\n    zip_extra_field_t *ef;\n    zip_extra_field_t *ef64;\n    zip_uint32_t ef_total_size;\n    bool is_zip64;\n    bool is_really_zip64;\n    bool is_winzip_aes;\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_buffer_t *buffer;\n\n    ef = NULL;\n\n    name_enc = _zip_guess_encoding(de->filename, ZIP_ENCODING_UNKNOWN);\n    com_enc = _zip_guess_encoding(de->comment, ZIP_ENCODING_UNKNOWN);\n\n    if ((name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_ASCII) ||\n\t(name_enc == ZIP_ENCODING_ASCII && com_enc == ZIP_ENCODING_UTF8_KNOWN) ||\n\t(name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_UTF8_KNOWN))\n\tde->bitflags |= ZIP_GPBF_ENCODING_UTF_8;\n    else {\n\tde->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCODING_UTF_8;\n\tif (name_enc == ZIP_ENCODING_UTF8_KNOWN) {\n\t    ef = _zip_ef_utf8(ZIP_EF_UTF_8_NAME, de->filename, &za->error);\n\t    if (ef == NULL)\n\t\treturn -1;\n\t}\n\tif ((flags & ZIP_FL_LOCAL) == 0 && com_enc == ZIP_ENCODING_UTF8_KNOWN){\n\t    zip_extra_field_t *ef2 = _zip_ef_utf8(ZIP_EF_UTF_8_COMMENT, de->comment, &za->error);\n\t    if (ef2 == NULL) {\n\t\t_zip_ef_free(ef);\n\t\treturn -1;\n\t    }\n\t    ef2->next = ef;\n\t    ef = ef2;\n\t}\n    }\n\n    if (de->encryption_method == ZIP_EM_NONE) {\n\tde->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCRYPTED;\n    }\n    else {\n\tde->bitflags |= (zip_uint16_t)ZIP_GPBF_ENCRYPTED;\n    }\n\n    is_really_zip64 = _zip_dirent_needs_zip64(de, flags);\n    is_zip64 = (flags & (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64)) == (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64) || is_really_zip64;\n    is_winzip_aes = de->encryption_method == ZIP_EM_AES_128 || de->encryption_method == ZIP_EM_AES_192 || de->encryption_method == ZIP_EM_AES_256;\n\n    if (is_zip64) {\n        zip_uint8_t ef_zip64[EFZIP64SIZE];\n        zip_buffer_t *ef_buffer = _zip_buffer_new(ef_zip64, sizeof(ef_zip64));\n        if (ef_buffer == NULL) {\n            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n        if (flags & ZIP_FL_LOCAL) {\n            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX) {\n                _zip_buffer_put_64(ef_buffer, de->uncomp_size);\n                _zip_buffer_put_64(ef_buffer, de->comp_size);\n            }\n        }\n        else {\n            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX || de->offset > ZIP_UINT32_MAX) {\n                if (de->uncomp_size >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->uncomp_size);\n                }\n                if (de->comp_size >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->comp_size);\n                }\n                if (de->offset >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->offset);\n                }\n            }\n        }\n\n        if (!_zip_buffer_ok(ef_buffer)) {\n            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n            _zip_buffer_free(ef_buffer);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n        ef64 = _zip_ef_new(ZIP_EF_ZIP64, (zip_uint16_t)(_zip_buffer_offset(ef_buffer)), ef_zip64, ZIP_EF_BOTH);\n        _zip_buffer_free(ef_buffer);\n        ef64->next = ef;\n        ef = ef64;\n    }\n\n    if (is_winzip_aes) {\n\tzip_uint8_t data[EF_WINZIP_AES_SIZE];\n        zip_buffer_t *ef_buffer = _zip_buffer_new(data, sizeof(data));\n\tzip_extra_field_t *ef_winzip;\n\t\n        if (ef_buffer == NULL) {\n            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n\t_zip_buffer_put_16(ef_buffer, 2);\n\t_zip_buffer_put(ef_buffer, \"AE\", 2);\n\t_zip_buffer_put_8(ef_buffer, (zip_uint8_t)(de->encryption_method & 0xff));\n\t_zip_buffer_put_16(ef_buffer, (zip_uint16_t)de->comp_method);\n\n        if (!_zip_buffer_ok(ef_buffer)) {\n            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n            _zip_buffer_free(ef_buffer);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\n        ef_winzip = _zip_ef_new(ZIP_EF_WINZIP_AES, EF_WINZIP_AES_SIZE, data, ZIP_EF_BOTH);\n        _zip_buffer_free(ef_buffer);\n        ef_winzip->next = ef;\n        ef = ef_winzip;\n    }\n\n    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {\n        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n        _zip_ef_free(ef);\n        return -1;\n    }\n\n    _zip_buffer_put(buffer, (flags & ZIP_FL_LOCAL) ? LOCAL_MAGIC : CENTRAL_MAGIC, 4);\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n        _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_madeby));\n    }\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_needed));\n    _zip_buffer_put_16(buffer, de->bitflags);\n    if (is_winzip_aes) {\n\t_zip_buffer_put_16(buffer, ZIP_CM_WINZIP_AES);\n    }\n    else {\n\t_zip_buffer_put_16(buffer, (zip_uint16_t)de->comp_method);\n    }\n\n    _zip_u2d_time(de->last_mod, &dostime, &dosdate);\n    _zip_buffer_put_16(buffer, dostime);\n    _zip_buffer_put_16(buffer, dosdate);\n\n    if (is_winzip_aes && de->uncomp_size < 20)  {\n\t_zip_buffer_put_32(buffer, 0);\n    }\n    else {\n\t_zip_buffer_put_32(buffer, de->crc);\n    }\n\n    if (((flags & ZIP_FL_LOCAL) == ZIP_FL_LOCAL) && ((de->comp_size >= ZIP_UINT32_MAX) || (de->uncomp_size >= ZIP_UINT32_MAX))) {\n\t/* In local headers, if a ZIP64 EF is written, it MUST contain\n\t * both compressed and uncompressed sizes (even if one of the\n\t * two is smaller than 0xFFFFFFFF); on the other hand, those\n\t * may only appear when the corresponding standard entry is\n\t * 0xFFFFFFFF.  (appnote.txt 4.5.3) */\n\t_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n\t_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n    }\n    else {\n        if (de->comp_size < ZIP_UINT32_MAX) {\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->comp_size);\n        }\n        else {\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n        }\n        if (de->uncomp_size < ZIP_UINT32_MAX) {\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->uncomp_size);\n        }\n        else {\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n        }\n    }\n\n    _zip_buffer_put_16(buffer, _zip_string_length(de->filename));\n    /* TODO: check for overflow */\n    ef_total_size = (zip_uint32_t)_zip_ef_size(de->extra_fields, flags) + (zip_uint32_t)_zip_ef_size(ef, ZIP_EF_BOTH);\n    _zip_buffer_put_16(buffer, (zip_uint16_t)ef_total_size);\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\t_zip_buffer_put_16(buffer, _zip_string_length(de->comment));\n\t_zip_buffer_put_16(buffer, (zip_uint16_t)de->disk_number);\n\t_zip_buffer_put_16(buffer, de->int_attrib);\n\t_zip_buffer_put_32(buffer, de->ext_attrib);\n\tif (de->offset < ZIP_UINT32_MAX)\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->offset);\n\telse\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        _zip_ef_free(ef);\n        return -1;\n    }\n\n    if (_zip_write(za, buf, _zip_buffer_offset(buffer)) < 0) {\n        _zip_buffer_free(buffer);\n        _zip_ef_free(ef);\n        return -1;\n    }\n\n    _zip_buffer_free(buffer);\n\n    if (de->filename) {\n\tif (_zip_string_write(za, de->filename) < 0) {\n            _zip_ef_free(ef);\n\t    return -1;\n\t}\n    }\n\n    if (ef) {\n\tif (_zip_ef_write(za, ef, ZIP_EF_BOTH) < 0) {\n            _zip_ef_free(ef);\n\t    return -1;\n\t}\n    }\n    _zip_ef_free(ef);\n    if (de->extra_fields) {\n\tif (_zip_ef_write(za, de->extra_fields, flags) < 0) {\n\t    return -1;\n\t}\n    }\n\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\tif (de->comment) {\n\t    if (_zip_string_write(za, de->comment) < 0) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n\n    return is_zip64;\n}\n\n\nstatic time_t\n_zip_d2u_time(zip_uint16_t dtime, zip_uint16_t ddate)\n{\n    struct tm tm;\n\n    memset(&tm, 0, sizeof(tm));\n\n    /* let mktime decide if DST is in effect */\n    tm.tm_isdst = -1;\n\n    tm.tm_year = ((ddate>>9)&127) + 1980 - 1900;\n    tm.tm_mon = ((ddate>>5)&15) - 1;\n    tm.tm_mday = ddate&31;\n\n    tm.tm_hour = (dtime>>11)&31;\n    tm.tm_min = (dtime>>5)&63;\n    tm.tm_sec = (dtime<<1)&62;\n\n    return mktime(&tm);\n}\n\n\nstatic zip_extra_field_t *\n_zip_ef_utf8(zip_uint16_t id, zip_string_t *str, zip_error_t *error)\n{\n    const zip_uint8_t *raw;\n    zip_uint32_t len;\n    zip_buffer_t *buffer;\n    zip_extra_field_t *ef;\n\n    if ((raw=_zip_string_get(str, &len, ZIP_FL_ENC_RAW, NULL)) == NULL) {\n\t/* error already set */\n\treturn NULL;\n    }\n\n    if (len+5 > ZIP_UINT16_MAX) {\n        zip_error_set(error, ZIP_ER_INVAL, 0); /* TODO: better error code? */\n        return NULL;\n    }\n\n    if ((buffer = _zip_buffer_new(NULL, len+5)) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    _zip_buffer_put_8(buffer, 1);\n    _zip_buffer_put_32(buffer, _zip_string_crc32(str));\n    _zip_buffer_put(buffer, raw, len);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        return NULL;\n    }\n\n    ef = _zip_ef_new(id, (zip_uint16_t)(_zip_buffer_offset(buffer)), _zip_buffer_data(buffer), ZIP_EF_BOTH);\n    _zip_buffer_free(buffer);\n\n    return ef;\n}\n\n\nzip_dirent_t *\n_zip_get_dirent(zip_t *za, zip_uint64_t idx, zip_flags_t flags, zip_error_t *error)\n{\n    if (error == NULL)\n\terror = &za->error;\n\n    if (idx >= za->nentry) {\n\tzip_error_set(error, ZIP_ER_INVAL, 0);\n\treturn NULL;\n    }\n\n    if ((flags & ZIP_FL_UNCHANGED) || za->entry[idx].changes == NULL) {\n\tif (za->entry[idx].orig == NULL) {\n\t    zip_error_set(error, ZIP_ER_INVAL, 0);\n\t    return NULL;\n\t}\n\tif (za->entry[idx].deleted && (flags & ZIP_FL_UNCHANGED) == 0) {\n\t    zip_error_set(error, ZIP_ER_DELETED, 0);\n\t    return NULL;\n\t}\n\treturn za->entry[idx].orig;\n    }\n    else\n\treturn za->entry[idx].changes;\n}\n\n\n\n\nvoid\n_zip_u2d_time(time_t intime, zip_uint16_t *dtime, zip_uint16_t *ddate)\n{\n    struct tm *tm;\n\n    tm = localtime(&intime);\n    if (tm->tm_year < 80) {\n\ttm->tm_year = 80;\n    }\n\n    *ddate = (zip_uint16_t)(((tm->tm_year+1900-1980)<<9) + ((tm->tm_mon+1)<<5) + tm->tm_mday);\n    *dtime = (zip_uint16_t)(((tm->tm_hour)<<11) + ((tm->tm_min)<<5) + ((tm->tm_sec)>>1));\n\n    return;\n}\n\n\nvoid\n_zip_dirent_set_version_needed(zip_dirent_t *de, bool force_zip64) {\n    zip_uint16_t length;\n\n    if (de->comp_method == ZIP_CM_LZMA) {\n\tde->version_needed = 63;\n\treturn;\n    }\n\n    if (de->comp_method == ZIP_CM_BZIP2) {\n\tde->version_needed = 46;\n\treturn;\n    }\n\n    if (force_zip64 || _zip_dirent_needs_zip64(de, 0)) {\n\tde->version_needed = 45;\n\treturn;\n    }\n    \n    if (de->comp_method == ZIP_CM_DEFLATE || de->encryption_method == ZIP_EM_TRAD_PKWARE) {\n\tde->version_needed = 20;\n\treturn;\n    }\n\n    /* directory */\n    if ((length = _zip_string_length(de->filename)) > 0) {\n\tif (de->filename->raw[length-1] == '/') {\n\t    de->version_needed = 20;\n\t    return;\n\t}\n    }\n    \n    de->version_needed = 10;\n}\n"], "filenames": ["THANKS", "lib/zip_dirent.c"], "buggy_code_start_loc": [14, 582], "buggy_code_end_loc": [14, 585], "fixing_code_start_loc": [15, 581], "fixing_code_end_loc": [16, 581], "type": "CWE-416", "message": "A use-after-free in the _zip_dirent_read function of zip_dirent.c in libzip 1.2.0 allows attackers to have an unspecified impact by attempting to unzip a malformed ZIP archive. NOTE: the discoverer states \"This use-after-free is triggered prior to the double free reported in CVE-2017-12858.\"", "other": {"cve": {"id": "CVE-2019-17582", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-09T19:15:12.553", "lastModified": "2021-02-16T15:39:10.470", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free in the _zip_dirent_read function of zip_dirent.c in libzip 1.2.0 allows attackers to have an unspecified impact by attempting to unzip a malformed ZIP archive. NOTE: the discoverer states \"This use-after-free is triggered prior to the double free reported in CVE-2017-12858.\""}, {"lang": "es", "value": "Un uso de la memoria previamente liberada en la funci\u00f3n _zip_dirent_read del archivo zip_dirent.c en libzip versi\u00f3n 1.2.0, permite a atacantes tener un impacto no especificado al intentar descomprimir un archivo ZIP malformado.&#xa0;NOTA: el descubridor afirma \"This use-after-free is triggered prior to the double free reported in CVE-2017-12858"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libzip:libzip:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "CBAF9F0B-71F7-4A20-9BA6-DCFCF3EA9268"}]}]}], "references": [{"url": "https://github.com/nih-at/libzip/commit/2217022b7d1142738656d891e00b3d2d9179b796", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nih-at/libzip/issues/5", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://libzip.org/libzip-discuss/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/nih-at/libzip/commit/2217022b7d1142738656d891e00b3d2d9179b796"}}