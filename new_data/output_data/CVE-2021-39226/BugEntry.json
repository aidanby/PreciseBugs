{"buggy_code": ["package api\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/infra/metrics\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/guardian\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n)\n\nvar client = &http.Client{\n\tTimeout:   time.Second * 5,\n\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n}\n\nfunc GetSharingOptions(c *models.ReqContext) {\n\tc.JSON(200, util.DynMap{\n\t\t\"externalSnapshotURL\":  setting.ExternalSnapshotUrl,\n\t\t\"externalSnapshotName\": setting.ExternalSnapshotName,\n\t\t\"externalEnabled\":      setting.ExternalEnabled,\n\t})\n}\n\ntype CreateExternalSnapshotResponse struct {\n\tKey       string `json:\"key\"`\n\tDeleteKey string `json:\"deleteKey\"`\n\tUrl       string `json:\"url\"`\n\tDeleteUrl string `json:\"deleteUrl\"`\n}\n\nfunc createExternalDashboardSnapshot(cmd models.CreateDashboardSnapshotCommand) (*CreateExternalSnapshotResponse, error) {\n\tvar createSnapshotResponse CreateExternalSnapshotResponse\n\tmessage := map[string]interface{}{\n\t\t\"name\":      cmd.Name,\n\t\t\"expires\":   cmd.Expires,\n\t\t\"dashboard\": cmd.Dashboard,\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t}\n\n\tmessageBytes, err := simplejson.NewFromAny(message).Encode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, err := client.Post(setting.ExternalSnapshotUrl+\"/api/snapshots\", \"application/json\", bytes.NewBuffer(messageBytes))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"create external snapshot response status code %d\", response.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(response.Body).Decode(&createSnapshotResponse); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &createSnapshotResponse, nil\n}\n\n// POST /api/snapshots\nfunc CreateDashboardSnapshot(c *models.ReqContext, cmd models.CreateDashboardSnapshotCommand) {\n\tif cmd.Name == \"\" {\n\t\tcmd.Name = \"Unnamed snapshot\"\n\t}\n\n\tvar url string\n\tcmd.ExternalUrl = \"\"\n\tcmd.OrgId = c.OrgId\n\tcmd.UserId = c.UserId\n\n\tif cmd.External {\n\t\tif !setting.ExternalEnabled {\n\t\t\tc.JsonApiErr(403, \"External dashboard creation is disabled\", nil)\n\t\t\treturn\n\t\t}\n\n\t\tresponse, err := createExternalDashboardSnapshot(cmd)\n\t\tif err != nil {\n\t\t\tc.JsonApiErr(500, \"Failed to create external snapshot\", err)\n\t\t\treturn\n\t\t}\n\n\t\turl = response.Url\n\t\tcmd.Key = response.Key\n\t\tcmd.DeleteKey = response.DeleteKey\n\t\tcmd.ExternalUrl = response.Url\n\t\tcmd.ExternalDeleteUrl = response.DeleteUrl\n\t\tcmd.Dashboard = simplejson.New()\n\n\t\tmetrics.MApiDashboardSnapshotExternal.Inc()\n\t} else {\n\t\tif cmd.Key == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.Key, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(500, \"Could not generate random string\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif cmd.DeleteKey == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.DeleteKey, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(500, \"Could not generate random string\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\turl = setting.ToAbsUrl(\"dashboard/snapshot/\" + cmd.Key)\n\n\t\tmetrics.MApiDashboardSnapshotCreate.Inc()\n\t}\n\n\tif err := bus.Dispatch(&cmd); err != nil {\n\t\tc.JsonApiErr(500, \"Failed to create snapshot\", err)\n\t\treturn\n\t}\n\n\tc.JSON(200, util.DynMap{\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t\t\"url\":       url,\n\t\t\"deleteUrl\": setting.ToAbsUrl(\"api/snapshots-delete/\" + cmd.DeleteKey),\n\t\t\"id\":        cmd.Result.Id,\n\t})\n}\n\n// GET /api/snapshots/:key\nfunc GetDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := c.Params(\":key\")\n\tquery := &models.GetDashboardSnapshotQuery{Key: key}\n\n\terr := bus.Dispatch(query)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard snapshot\", err)\n\t}\n\n\tsnapshot := query.Result\n\n\t// expired snapshots should also be removed from db\n\tif snapshot.Expires.Before(time.Now()) {\n\t\treturn response.Error(404, \"Dashboard snapshot not found\", err)\n\t}\n\n\tdashboard, err := snapshot.DashboardJSON()\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard data for dashboard snapshot\", err)\n\t}\n\n\tdto := dtos.DashboardFullWithMeta{\n\t\tDashboard: dashboard,\n\t\tMeta: dtos.DashboardMeta{\n\t\t\tType:       models.DashTypeSnapshot,\n\t\t\tIsSnapshot: true,\n\t\t\tCreated:    snapshot.Created,\n\t\t\tExpires:    snapshot.Expires,\n\t\t},\n\t}\n\n\tmetrics.MApiDashboardSnapshotGet.Inc()\n\n\treturn response.JSON(200, dto).SetHeader(\"Cache-Control\", \"public, max-age=3600\")\n}\n\nfunc deleteExternalDashboardSnapshot(externalUrl string) error {\n\tresponse, err := client.Get(externalUrl)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode == 200 {\n\t\treturn nil\n\t}\n\n\t// Gracefully ignore \"snapshot not found\" errors as they could have already\n\t// been removed either via the cleanup script or by request.\n\tif response.StatusCode == 500 {\n\t\tvar respJson map[string]interface{}\n\t\tif err := json.NewDecoder(response.Body).Decode(&respJson); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif respJson[\"message\"] == \"Failed to get dashboard snapshot\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"unexpected response when deleting external snapshot, status code: %d\", response.StatusCode)\n}\n\n// GET /api/snapshots-delete/:deleteKey\nfunc DeleteDashboardSnapshotByDeleteKey(c *models.ReqContext) response.Response {\n\tkey := c.Params(\":deleteKey\")\n\n\tquery := &models.GetDashboardSnapshotQuery{DeleteKey: key}\n\n\terr := bus.Dispatch(query)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard snapshot\", err)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\tcmd := &models.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := bus.Dispatch(cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(200, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// DELETE /api/snapshots/:key\nfunc DeleteDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := c.Params(\":key\")\n\n\tquery := &models.GetDashboardSnapshotQuery{Key: key}\n\n\terr := bus.Dispatch(query)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard snapshot\", err)\n\t}\n\tif query.Result == nil {\n\t\treturn response.Error(404, \"Failed to get dashboard snapshot\", nil)\n\t}\n\n\tdashboard, err := query.Result.DashboardJSON()\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard data for dashboard snapshot\", err)\n\t}\n\tdashboardID := dashboard.Get(\"id\").MustInt64()\n\n\tguardian := guardian.New(dashboardID, c.OrgId, c.SignedInUser)\n\tcanEdit, err := guardian.CanEdit()\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while checking permissions for snapshot\", err)\n\t}\n\n\tif !canEdit && query.Result.UserId != c.SignedInUser.UserId {\n\t\treturn response.Error(403, \"Access denied to this snapshot\", nil)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\tcmd := &models.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := bus.Dispatch(cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(200, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// GET /api/dashboard/snapshots\nfunc SearchDashboardSnapshots(c *models.ReqContext) response.Response {\n\tquery := c.Query(\"query\")\n\tlimit := c.QueryInt(\"limit\")\n\n\tif limit == 0 {\n\t\tlimit = 1000\n\t}\n\n\tsearchQuery := models.GetDashboardSnapshotsQuery{\n\t\tName:         query,\n\t\tLimit:        limit,\n\t\tOrgId:        c.OrgId,\n\t\tSignedInUser: c.SignedInUser,\n\t}\n\n\terr := bus.Dispatch(&searchQuery)\n\tif err != nil {\n\t\treturn response.Error(500, \"Search failed\", err)\n\t}\n\n\tdtos := make([]*models.DashboardSnapshotDTO, len(searchQuery.Result))\n\tfor i, snapshot := range searchQuery.Result {\n\t\tdtos[i] = &models.DashboardSnapshotDTO{\n\t\t\tId:          snapshot.Id,\n\t\t\tName:        snapshot.Name,\n\t\t\tKey:         snapshot.Key,\n\t\t\tOrgId:       snapshot.OrgId,\n\t\t\tUserId:      snapshot.UserId,\n\t\t\tExternal:    snapshot.External,\n\t\t\tExternalUrl: snapshot.ExternalUrl,\n\t\t\tExpires:     snapshot.Expires,\n\t\t\tCreated:     snapshot.Created,\n\t\t\tUpdated:     snapshot.Updated,\n\t\t}\n\t}\n\n\treturn response.JSON(200, dtos)\n}\n", "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar (\n\t// Known HTTP methods.\n\t_HTTP_METHODS = map[string]bool{\n\t\t\"GET\":     true,\n\t\t\"POST\":    true,\n\t\t\"PUT\":     true,\n\t\t\"DELETE\":  true,\n\t\t\"PATCH\":   true,\n\t\t\"OPTIONS\": true,\n\t\t\"HEAD\":    true,\n\t}\n)\n\n// routeMap represents a thread-safe map for route tree.\ntype routeMap struct {\n\tlock   sync.RWMutex\n\troutes map[string]map[string]*Leaf\n}\n\n// NewRouteMap initializes and returns a new routeMap.\nfunc NewRouteMap() *routeMap {\n\trm := &routeMap{\n\t\troutes: make(map[string]map[string]*Leaf),\n\t}\n\tfor m := range _HTTP_METHODS {\n\t\trm.routes[m] = make(map[string]*Leaf)\n\t}\n\treturn rm\n}\n\n// getLeaf returns Leaf object if a route has been registered.\nfunc (rm *routeMap) getLeaf(method, pattern string) *Leaf {\n\trm.lock.RLock()\n\tdefer rm.lock.RUnlock()\n\n\treturn rm.routes[method][pattern]\n}\n\n// add adds new route to route tree map.\nfunc (rm *routeMap) add(method, pattern string, leaf *Leaf) {\n\trm.lock.Lock()\n\tdefer rm.lock.Unlock()\n\n\trm.routes[method][pattern] = leaf\n}\n\ntype group struct {\n\tpattern  string\n\thandlers []Handler\n}\n\n// Router represents a Macaron router layer.\ntype Router struct {\n\tm        *Macaron\n\tautoHead bool\n\trouters  map[string]*Tree\n\t*routeMap\n\tnamedRoutes map[string]*Leaf\n\n\tgroups              []group\n\tnotFound            http.HandlerFunc\n\tinternalServerError func(*Context, error)\n\n\t// handlerWrapper is used to wrap arbitrary function from Handler to inject.FastInvoker.\n\thandlerWrapper func(Handler) Handler\n}\n\nfunc NewRouter() *Router {\n\treturn &Router{\n\t\trouters:     make(map[string]*Tree),\n\t\trouteMap:    NewRouteMap(),\n\t\tnamedRoutes: make(map[string]*Leaf),\n\t}\n}\n\n// SetAutoHead sets the value who determines whether add HEAD method automatically\n// when GET method is added.\nfunc (r *Router) SetAutoHead(v bool) {\n\tr.autoHead = v\n}\n\ntype Params map[string]string\n\n// Handle is a function that can be registered to a route to handle HTTP requests.\n// Like http.HandlerFunc, but has a third parameter for the values of wildcards (variables).\ntype Handle func(http.ResponseWriter, *http.Request, Params)\n\n// Route represents a wrapper of leaf route and upper level router.\ntype Route struct {\n\trouter *Router\n\tleaf   *Leaf\n}\n\n// Name sets name of route.\nfunc (r *Route) Name(name string) {\n\tif len(name) == 0 {\n\t\tpanic(\"route name cannot be empty\")\n\t} else if r.router.namedRoutes[name] != nil {\n\t\tpanic(\"route with given name already exists: \" + name)\n\t}\n\tr.router.namedRoutes[name] = r.leaf\n}\n\n// handle adds new route to the router tree.\nfunc (r *Router) handle(method, pattern string, handle Handle) *Route {\n\tmethod = strings.ToUpper(method)\n\n\tvar leaf *Leaf\n\t// Prevent duplicate routes.\n\tif leaf = r.getLeaf(method, pattern); leaf != nil {\n\t\treturn &Route{r, leaf}\n\t}\n\n\t// Validate HTTP methods.\n\tif !_HTTP_METHODS[method] && method != \"*\" {\n\t\tpanic(\"unknown HTTP method: \" + method)\n\t}\n\n\t// Generate methods need register.\n\tmethods := make(map[string]bool)\n\tif method == \"*\" {\n\t\tfor m := range _HTTP_METHODS {\n\t\t\tmethods[m] = true\n\t\t}\n\t} else {\n\t\tmethods[method] = true\n\t}\n\n\t// Add to router tree.\n\tfor m := range methods {\n\t\tif t, ok := r.routers[m]; ok {\n\t\t\tleaf = t.Add(pattern, handle)\n\t\t} else {\n\t\t\tt := NewTree()\n\t\t\tleaf = t.Add(pattern, handle)\n\t\t\tr.routers[m] = t\n\t\t}\n\t\tr.add(m, pattern, leaf)\n\t}\n\treturn &Route{r, leaf}\n}\n\n// Handle registers a new request handle with the given pattern, method and handlers.\nfunc (r *Router) Handle(method string, pattern string, handlers []Handler) *Route {\n\tif len(r.groups) > 0 {\n\t\tgroupPattern := \"\"\n\t\th := make([]Handler, 0)\n\t\tfor _, g := range r.groups {\n\t\t\tgroupPattern += g.pattern\n\t\t\th = append(h, g.handlers...)\n\t\t}\n\n\t\tpattern = groupPattern + pattern\n\t\th = append(h, handlers...)\n\t\thandlers = h\n\t}\n\thandlers = validateAndWrapHandlers(handlers, r.handlerWrapper)\n\n\treturn r.handle(method, pattern, func(resp http.ResponseWriter, req *http.Request, params Params) {\n\t\tc := r.m.createContext(resp, req)\n\t\tc.params = params\n\t\tc.handlers = make([]Handler, 0, len(r.m.handlers)+len(handlers))\n\t\tc.handlers = append(c.handlers, r.m.handlers...)\n\t\tc.handlers = append(c.handlers, handlers...)\n\t\tc.run()\n\t})\n}\n\nfunc (r *Router) Group(pattern string, fn func(), h ...Handler) {\n\tr.groups = append(r.groups, group{pattern, h})\n\tfn()\n\tr.groups = r.groups[:len(r.groups)-1]\n}\n\n// Get is a shortcut for r.Handle(\"GET\", pattern, handlers)\nfunc (r *Router) Get(pattern string, h ...Handler) (leaf *Route) {\n\tleaf = r.Handle(\"GET\", pattern, h)\n\tif r.autoHead {\n\t\tr.Head(pattern, h...)\n\t}\n\treturn leaf\n}\n\n// Patch is a shortcut for r.Handle(\"PATCH\", pattern, handlers)\nfunc (r *Router) Patch(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"PATCH\", pattern, h)\n}\n\n// Post is a shortcut for r.Handle(\"POST\", pattern, handlers)\nfunc (r *Router) Post(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"POST\", pattern, h)\n}\n\n// Put is a shortcut for r.Handle(\"PUT\", pattern, handlers)\nfunc (r *Router) Put(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"PUT\", pattern, h)\n}\n\n// Delete is a shortcut for r.Handle(\"DELETE\", pattern, handlers)\nfunc (r *Router) Delete(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"DELETE\", pattern, h)\n}\n\n// Options is a shortcut for r.Handle(\"OPTIONS\", pattern, handlers)\nfunc (r *Router) Options(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"OPTIONS\", pattern, h)\n}\n\n// Head is a shortcut for r.Handle(\"HEAD\", pattern, handlers)\nfunc (r *Router) Head(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"HEAD\", pattern, h)\n}\n\n// Any is a shortcut for r.Handle(\"*\", pattern, handlers)\nfunc (r *Router) Any(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"*\", pattern, h)\n}\n\n// Route is a shortcut for same handlers but different HTTP methods.\n//\n// Example:\n// \t\tm.Route(\"/\", \"GET,POST\", h)\nfunc (r *Router) Route(pattern, methods string, h ...Handler) (route *Route) {\n\tfor _, m := range strings.Split(methods, \",\") {\n\t\troute = r.Handle(strings.TrimSpace(m), pattern, h)\n\t}\n\treturn route\n}\n\n// Combo returns a combo router.\nfunc (r *Router) Combo(pattern string, h ...Handler) *ComboRouter {\n\treturn &ComboRouter{r, pattern, h, map[string]bool{}, nil}\n}\n\n// NotFound configurates http.HandlerFunc which is called when no matching route is\n// found. If it is not set, http.NotFound is used.\n// Be sure to set 404 response code in your handler.\nfunc (r *Router) NotFound(handlers ...Handler) {\n\thandlers = validateAndWrapHandlers(handlers)\n\tr.notFound = func(rw http.ResponseWriter, req *http.Request) {\n\t\tc := r.m.createContext(rw, req)\n\t\tc.handlers = make([]Handler, 0, len(r.m.handlers)+len(handlers))\n\t\tc.handlers = append(c.handlers, r.m.handlers...)\n\t\tc.handlers = append(c.handlers, handlers...)\n\t\tc.run()\n\t}\n}\n\n// InternalServerError configurates handler which is called when route handler returns\n// error. If it is not set, default handler is used.\n// Be sure to set 500 response code in your handler.\nfunc (r *Router) InternalServerError(handlers ...Handler) {\n\thandlers = validateAndWrapHandlers(handlers)\n\tr.internalServerError = func(c *Context, err error) {\n\t\tc.index = 0\n\t\tc.handlers = handlers\n\t\tc.Map(err)\n\t\tc.run()\n\t}\n}\n\n// SetHandlerWrapper sets handlerWrapper for the router.\nfunc (r *Router) SetHandlerWrapper(f func(Handler) Handler) {\n\tr.handlerWrapper = f\n}\n\nfunc (r *Router) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif t, ok := r.routers[req.Method]; ok {\n\t\t// Fast match for static routes\n\t\tleaf := r.getLeaf(req.Method, req.URL.Path)\n\t\tif leaf != nil {\n\t\t\tleaf.handle(rw, req, nil)\n\t\t\treturn\n\t\t}\n\n\t\th, p, ok := t.Match(req.URL.EscapedPath())\n\t\tif ok {\n\t\t\tif splat, ok := p[\"*0\"]; ok {\n\t\t\t\tp[\"*\"] = splat // Easy name.\n\t\t\t}\n\t\t\th(rw, req, p)\n\t\t\treturn\n\t\t}\n\t}\n\n\tr.notFound(rw, req)\n}\n\n// URLFor builds path part of URL by given pair values.\nfunc (r *Router) URLFor(name string, pairs ...string) string {\n\tleaf, ok := r.namedRoutes[name]\n\tif !ok {\n\t\tpanic(\"route with given name does not exists: \" + name)\n\t}\n\treturn leaf.URLPath(pairs...)\n}\n\n// ComboRouter represents a combo router.\ntype ComboRouter struct {\n\trouter   *Router\n\tpattern  string\n\thandlers []Handler\n\tmethods  map[string]bool // Registered methods.\n\n\tlastRoute *Route\n}\n\nfunc (cr *ComboRouter) checkMethod(name string) {\n\tif cr.methods[name] {\n\t\tpanic(\"method '\" + name + \"' has already been registered\")\n\t}\n\tcr.methods[name] = true\n}\n\nfunc (cr *ComboRouter) route(fn func(string, ...Handler) *Route, method string, h ...Handler) *ComboRouter {\n\tcr.checkMethod(method)\n\tcr.lastRoute = fn(cr.pattern, append(cr.handlers, h...)...)\n\treturn cr\n}\n\nfunc (cr *ComboRouter) Get(h ...Handler) *ComboRouter {\n\tif cr.router.autoHead {\n\t\tcr.Head(h...)\n\t}\n\treturn cr.route(cr.router.Get, \"GET\", h...)\n}\n\nfunc (cr *ComboRouter) Patch(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Patch, \"PATCH\", h...)\n}\n\nfunc (cr *ComboRouter) Post(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Post, \"POST\", h...)\n}\n\nfunc (cr *ComboRouter) Put(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Put, \"PUT\", h...)\n}\n\nfunc (cr *ComboRouter) Delete(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Delete, \"DELETE\", h...)\n}\n\nfunc (cr *ComboRouter) Options(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Options, \"OPTIONS\", h...)\n}\n\nfunc (cr *ComboRouter) Head(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Head, \"HEAD\", h...)\n}\n\n// Name sets name of ComboRouter route.\nfunc (cr *ComboRouter) Name(name string) {\n\tif cr.lastRoute == nil {\n\t\tpanic(\"no corresponding route to be named\")\n\t}\n\tcr.lastRoute.Name(name)\n}\n"], "fixing_code": ["package api\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/infra/metrics\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/guardian\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n)\n\nvar client = &http.Client{\n\tTimeout:   time.Second * 5,\n\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n}\n\nfunc GetSharingOptions(c *models.ReqContext) {\n\tc.JSON(200, util.DynMap{\n\t\t\"externalSnapshotURL\":  setting.ExternalSnapshotUrl,\n\t\t\"externalSnapshotName\": setting.ExternalSnapshotName,\n\t\t\"externalEnabled\":      setting.ExternalEnabled,\n\t})\n}\n\ntype CreateExternalSnapshotResponse struct {\n\tKey       string `json:\"key\"`\n\tDeleteKey string `json:\"deleteKey\"`\n\tUrl       string `json:\"url\"`\n\tDeleteUrl string `json:\"deleteUrl\"`\n}\n\nfunc createExternalDashboardSnapshot(cmd models.CreateDashboardSnapshotCommand) (*CreateExternalSnapshotResponse, error) {\n\tvar createSnapshotResponse CreateExternalSnapshotResponse\n\tmessage := map[string]interface{}{\n\t\t\"name\":      cmd.Name,\n\t\t\"expires\":   cmd.Expires,\n\t\t\"dashboard\": cmd.Dashboard,\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t}\n\n\tmessageBytes, err := simplejson.NewFromAny(message).Encode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, err := client.Post(setting.ExternalSnapshotUrl+\"/api/snapshots\", \"application/json\", bytes.NewBuffer(messageBytes))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"create external snapshot response status code %d\", response.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(response.Body).Decode(&createSnapshotResponse); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &createSnapshotResponse, nil\n}\n\n// POST /api/snapshots\nfunc CreateDashboardSnapshot(c *models.ReqContext, cmd models.CreateDashboardSnapshotCommand) {\n\tif cmd.Name == \"\" {\n\t\tcmd.Name = \"Unnamed snapshot\"\n\t}\n\n\tvar url string\n\tcmd.ExternalUrl = \"\"\n\tcmd.OrgId = c.OrgId\n\tcmd.UserId = c.UserId\n\n\tif cmd.External {\n\t\tif !setting.ExternalEnabled {\n\t\t\tc.JsonApiErr(403, \"External dashboard creation is disabled\", nil)\n\t\t\treturn\n\t\t}\n\n\t\tresponse, err := createExternalDashboardSnapshot(cmd)\n\t\tif err != nil {\n\t\t\tc.JsonApiErr(500, \"Failed to create external snapshot\", err)\n\t\t\treturn\n\t\t}\n\n\t\turl = response.Url\n\t\tcmd.Key = response.Key\n\t\tcmd.DeleteKey = response.DeleteKey\n\t\tcmd.ExternalUrl = response.Url\n\t\tcmd.ExternalDeleteUrl = response.DeleteUrl\n\t\tcmd.Dashboard = simplejson.New()\n\n\t\tmetrics.MApiDashboardSnapshotExternal.Inc()\n\t} else {\n\t\tif cmd.Key == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.Key, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(500, \"Could not generate random string\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif cmd.DeleteKey == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.DeleteKey, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(500, \"Could not generate random string\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\turl = setting.ToAbsUrl(\"dashboard/snapshot/\" + cmd.Key)\n\n\t\tmetrics.MApiDashboardSnapshotCreate.Inc()\n\t}\n\n\tif err := bus.Dispatch(&cmd); err != nil {\n\t\tc.JsonApiErr(500, \"Failed to create snapshot\", err)\n\t\treturn\n\t}\n\n\tc.JSON(200, util.DynMap{\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t\t\"url\":       url,\n\t\t\"deleteUrl\": setting.ToAbsUrl(\"api/snapshots-delete/\" + cmd.DeleteKey),\n\t\t\"id\":        cmd.Result.Id,\n\t})\n}\n\n// GET /api/snapshots/:key\nfunc GetDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := c.Params(\":key\")\n\tif len(key) == 0 {\n\t\treturn response.Error(404, \"Snapshot not found\", nil)\n\t}\n\tquery := &models.GetDashboardSnapshotQuery{Key: key}\n\n\terr := bus.Dispatch(query)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard snapshot\", err)\n\t}\n\n\tsnapshot := query.Result\n\n\t// expired snapshots should also be removed from db\n\tif snapshot.Expires.Before(time.Now()) {\n\t\treturn response.Error(404, \"Dashboard snapshot not found\", err)\n\t}\n\n\tdashboard, err := snapshot.DashboardJSON()\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard data for dashboard snapshot\", err)\n\t}\n\n\tdto := dtos.DashboardFullWithMeta{\n\t\tDashboard: dashboard,\n\t\tMeta: dtos.DashboardMeta{\n\t\t\tType:       models.DashTypeSnapshot,\n\t\t\tIsSnapshot: true,\n\t\t\tCreated:    snapshot.Created,\n\t\t\tExpires:    snapshot.Expires,\n\t\t},\n\t}\n\n\tmetrics.MApiDashboardSnapshotGet.Inc()\n\n\treturn response.JSON(200, dto).SetHeader(\"Cache-Control\", \"public, max-age=3600\")\n}\n\nfunc deleteExternalDashboardSnapshot(externalUrl string) error {\n\tresponse, err := client.Get(externalUrl)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode == 200 {\n\t\treturn nil\n\t}\n\n\t// Gracefully ignore \"snapshot not found\" errors as they could have already\n\t// been removed either via the cleanup script or by request.\n\tif response.StatusCode == 500 {\n\t\tvar respJson map[string]interface{}\n\t\tif err := json.NewDecoder(response.Body).Decode(&respJson); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif respJson[\"message\"] == \"Failed to get dashboard snapshot\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"unexpected response when deleting external snapshot, status code: %d\", response.StatusCode)\n}\n\n// GET /api/snapshots-delete/:deleteKey\nfunc DeleteDashboardSnapshotByDeleteKey(c *models.ReqContext) response.Response {\n\tkey := c.Params(\":deleteKey\")\n\tif len(key) == 0 {\n\t\treturn response.Error(404, \"Snapshot not found\", nil)\n\t}\n\n\tquery := &models.GetDashboardSnapshotQuery{DeleteKey: key}\n\n\terr := bus.Dispatch(query)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard snapshot\", err)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\tcmd := &models.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := bus.Dispatch(cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(200, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// DELETE /api/snapshots/:key\nfunc DeleteDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := c.Params(\":key\")\n\tif len(key) == 0 {\n\t\treturn response.Error(404, \"Snapshot not found\", nil)\n\t}\n\n\tquery := &models.GetDashboardSnapshotQuery{Key: key}\n\n\terr := bus.Dispatch(query)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard snapshot\", err)\n\t}\n\tif query.Result == nil {\n\t\treturn response.Error(404, \"Failed to get dashboard snapshot\", nil)\n\t}\n\n\tdashboard, err := query.Result.DashboardJSON()\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get dashboard data for dashboard snapshot\", err)\n\t}\n\tdashboardID := dashboard.Get(\"id\").MustInt64()\n\n\tguardian := guardian.New(dashboardID, c.OrgId, c.SignedInUser)\n\tcanEdit, err := guardian.CanEdit()\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while checking permissions for snapshot\", err)\n\t}\n\n\tif !canEdit && query.Result.UserId != c.SignedInUser.UserId {\n\t\treturn response.Error(403, \"Access denied to this snapshot\", nil)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\tcmd := &models.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := bus.Dispatch(cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(200, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// GET /api/dashboard/snapshots\nfunc SearchDashboardSnapshots(c *models.ReqContext) response.Response {\n\tquery := c.Query(\"query\")\n\tlimit := c.QueryInt(\"limit\")\n\n\tif limit == 0 {\n\t\tlimit = 1000\n\t}\n\n\tsearchQuery := models.GetDashboardSnapshotsQuery{\n\t\tName:         query,\n\t\tLimit:        limit,\n\t\tOrgId:        c.OrgId,\n\t\tSignedInUser: c.SignedInUser,\n\t}\n\n\terr := bus.Dispatch(&searchQuery)\n\tif err != nil {\n\t\treturn response.Error(500, \"Search failed\", err)\n\t}\n\n\tdtos := make([]*models.DashboardSnapshotDTO, len(searchQuery.Result))\n\tfor i, snapshot := range searchQuery.Result {\n\t\tdtos[i] = &models.DashboardSnapshotDTO{\n\t\t\tId:          snapshot.Id,\n\t\t\tName:        snapshot.Name,\n\t\t\tKey:         snapshot.Key,\n\t\t\tOrgId:       snapshot.OrgId,\n\t\t\tUserId:      snapshot.UserId,\n\t\t\tExternal:    snapshot.External,\n\t\t\tExternalUrl: snapshot.ExternalUrl,\n\t\t\tExpires:     snapshot.Expires,\n\t\t\tCreated:     snapshot.Created,\n\t\t\tUpdated:     snapshot.Updated,\n\t\t}\n\t}\n\n\treturn response.JSON(200, dtos)\n}\n", "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar (\n\t// Known HTTP methods.\n\t_HTTP_METHODS = map[string]bool{\n\t\t\"GET\":     true,\n\t\t\"POST\":    true,\n\t\t\"PUT\":     true,\n\t\t\"DELETE\":  true,\n\t\t\"PATCH\":   true,\n\t\t\"OPTIONS\": true,\n\t\t\"HEAD\":    true,\n\t}\n)\n\n// routeMap represents a thread-safe map for route tree.\ntype routeMap struct {\n\tlock   sync.RWMutex\n\troutes map[string]map[string]*Leaf\n}\n\n// NewRouteMap initializes and returns a new routeMap.\nfunc NewRouteMap() *routeMap {\n\trm := &routeMap{\n\t\troutes: make(map[string]map[string]*Leaf),\n\t}\n\tfor m := range _HTTP_METHODS {\n\t\trm.routes[m] = make(map[string]*Leaf)\n\t}\n\treturn rm\n}\n\n// getLeaf returns Leaf object if a route has been registered.\nfunc (rm *routeMap) getLeaf(method, pattern string) *Leaf {\n\trm.lock.RLock()\n\tdefer rm.lock.RUnlock()\n\n\treturn rm.routes[method][pattern]\n}\n\n// add adds new route to route tree map.\nfunc (rm *routeMap) add(method, pattern string, leaf *Leaf) {\n\trm.lock.Lock()\n\tdefer rm.lock.Unlock()\n\n\trm.routes[method][pattern] = leaf\n}\n\ntype group struct {\n\tpattern  string\n\thandlers []Handler\n}\n\n// Router represents a Macaron router layer.\ntype Router struct {\n\tm        *Macaron\n\tautoHead bool\n\trouters  map[string]*Tree\n\t*routeMap\n\tnamedRoutes map[string]*Leaf\n\n\tgroups              []group\n\tnotFound            http.HandlerFunc\n\tinternalServerError func(*Context, error)\n\n\t// handlerWrapper is used to wrap arbitrary function from Handler to inject.FastInvoker.\n\thandlerWrapper func(Handler) Handler\n}\n\nfunc NewRouter() *Router {\n\treturn &Router{\n\t\trouters:     make(map[string]*Tree),\n\t\trouteMap:    NewRouteMap(),\n\t\tnamedRoutes: make(map[string]*Leaf),\n\t}\n}\n\n// SetAutoHead sets the value who determines whether add HEAD method automatically\n// when GET method is added.\nfunc (r *Router) SetAutoHead(v bool) {\n\tr.autoHead = v\n}\n\ntype Params map[string]string\n\n// Handle is a function that can be registered to a route to handle HTTP requests.\n// Like http.HandlerFunc, but has a third parameter for the values of wildcards (variables).\ntype Handle func(http.ResponseWriter, *http.Request, Params)\n\n// Route represents a wrapper of leaf route and upper level router.\ntype Route struct {\n\trouter *Router\n\tleaf   *Leaf\n}\n\n// Name sets name of route.\nfunc (r *Route) Name(name string) {\n\tif len(name) == 0 {\n\t\tpanic(\"route name cannot be empty\")\n\t} else if r.router.namedRoutes[name] != nil {\n\t\tpanic(\"route with given name already exists: \" + name)\n\t}\n\tr.router.namedRoutes[name] = r.leaf\n}\n\n// handle adds new route to the router tree.\nfunc (r *Router) handle(method, pattern string, handle Handle) *Route {\n\tmethod = strings.ToUpper(method)\n\n\tvar leaf *Leaf\n\t// Prevent duplicate routes.\n\tif leaf = r.getLeaf(method, pattern); leaf != nil {\n\t\treturn &Route{r, leaf}\n\t}\n\n\t// Validate HTTP methods.\n\tif !_HTTP_METHODS[method] && method != \"*\" {\n\t\tpanic(\"unknown HTTP method: \" + method)\n\t}\n\n\t// Generate methods need register.\n\tmethods := make(map[string]bool)\n\tif method == \"*\" {\n\t\tfor m := range _HTTP_METHODS {\n\t\t\tmethods[m] = true\n\t\t}\n\t} else {\n\t\tmethods[method] = true\n\t}\n\n\t// Add to router tree.\n\tfor m := range methods {\n\t\tif t, ok := r.routers[m]; ok {\n\t\t\tleaf = t.Add(pattern, handle)\n\t\t} else {\n\t\t\tt := NewTree()\n\t\t\tleaf = t.Add(pattern, handle)\n\t\t\tr.routers[m] = t\n\t\t}\n\t\tr.add(m, pattern, leaf)\n\t}\n\treturn &Route{r, leaf}\n}\n\n// Handle registers a new request handle with the given pattern, method and handlers.\nfunc (r *Router) Handle(method string, pattern string, handlers []Handler) *Route {\n\tif len(r.groups) > 0 {\n\t\tgroupPattern := \"\"\n\t\th := make([]Handler, 0)\n\t\tfor _, g := range r.groups {\n\t\t\tgroupPattern += g.pattern\n\t\t\th = append(h, g.handlers...)\n\t\t}\n\n\t\tpattern = groupPattern + pattern\n\t\th = append(h, handlers...)\n\t\thandlers = h\n\t}\n\thandlers = validateAndWrapHandlers(handlers, r.handlerWrapper)\n\n\treturn r.handle(method, pattern, func(resp http.ResponseWriter, req *http.Request, params Params) {\n\t\tc := r.m.createContext(resp, req)\n\t\tc.params = params\n\t\tc.handlers = make([]Handler, 0, len(r.m.handlers)+len(handlers))\n\t\tc.handlers = append(c.handlers, r.m.handlers...)\n\t\tc.handlers = append(c.handlers, handlers...)\n\t\tc.run()\n\t})\n}\n\nfunc (r *Router) Group(pattern string, fn func(), h ...Handler) {\n\tr.groups = append(r.groups, group{pattern, h})\n\tfn()\n\tr.groups = r.groups[:len(r.groups)-1]\n}\n\n// Get is a shortcut for r.Handle(\"GET\", pattern, handlers)\nfunc (r *Router) Get(pattern string, h ...Handler) (leaf *Route) {\n\tleaf = r.Handle(\"GET\", pattern, h)\n\tif r.autoHead {\n\t\tr.Head(pattern, h...)\n\t}\n\treturn leaf\n}\n\n// Patch is a shortcut for r.Handle(\"PATCH\", pattern, handlers)\nfunc (r *Router) Patch(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"PATCH\", pattern, h)\n}\n\n// Post is a shortcut for r.Handle(\"POST\", pattern, handlers)\nfunc (r *Router) Post(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"POST\", pattern, h)\n}\n\n// Put is a shortcut for r.Handle(\"PUT\", pattern, handlers)\nfunc (r *Router) Put(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"PUT\", pattern, h)\n}\n\n// Delete is a shortcut for r.Handle(\"DELETE\", pattern, handlers)\nfunc (r *Router) Delete(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"DELETE\", pattern, h)\n}\n\n// Options is a shortcut for r.Handle(\"OPTIONS\", pattern, handlers)\nfunc (r *Router) Options(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"OPTIONS\", pattern, h)\n}\n\n// Head is a shortcut for r.Handle(\"HEAD\", pattern, handlers)\nfunc (r *Router) Head(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"HEAD\", pattern, h)\n}\n\n// Any is a shortcut for r.Handle(\"*\", pattern, handlers)\nfunc (r *Router) Any(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"*\", pattern, h)\n}\n\n// Route is a shortcut for same handlers but different HTTP methods.\n//\n// Example:\n// \t\tm.Route(\"/\", \"GET,POST\", h)\nfunc (r *Router) Route(pattern, methods string, h ...Handler) (route *Route) {\n\tfor _, m := range strings.Split(methods, \",\") {\n\t\troute = r.Handle(strings.TrimSpace(m), pattern, h)\n\t}\n\treturn route\n}\n\n// Combo returns a combo router.\nfunc (r *Router) Combo(pattern string, h ...Handler) *ComboRouter {\n\treturn &ComboRouter{r, pattern, h, map[string]bool{}, nil}\n}\n\n// NotFound configurates http.HandlerFunc which is called when no matching route is\n// found. If it is not set, http.NotFound is used.\n// Be sure to set 404 response code in your handler.\nfunc (r *Router) NotFound(handlers ...Handler) {\n\thandlers = validateAndWrapHandlers(handlers)\n\tr.notFound = func(rw http.ResponseWriter, req *http.Request) {\n\t\tc := r.m.createContext(rw, req)\n\t\tc.handlers = make([]Handler, 0, len(r.m.handlers)+len(handlers))\n\t\tc.handlers = append(c.handlers, r.m.handlers...)\n\t\tc.handlers = append(c.handlers, handlers...)\n\t\tc.run()\n\t}\n}\n\n// InternalServerError configurates handler which is called when route handler returns\n// error. If it is not set, default handler is used.\n// Be sure to set 500 response code in your handler.\nfunc (r *Router) InternalServerError(handlers ...Handler) {\n\thandlers = validateAndWrapHandlers(handlers)\n\tr.internalServerError = func(c *Context, err error) {\n\t\tc.index = 0\n\t\tc.handlers = handlers\n\t\tc.Map(err)\n\t\tc.run()\n\t}\n}\n\n// SetHandlerWrapper sets handlerWrapper for the router.\nfunc (r *Router) SetHandlerWrapper(f func(Handler) Handler) {\n\tr.handlerWrapper = f\n}\n\nfunc (r *Router) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif t, ok := r.routers[req.Method]; ok {\n\t\t// Fast match for static routes\n\t\tif !strings.ContainsAny(req.URL.Path, \":*\") {\n\t\t\tleaf := r.getLeaf(req.Method, req.URL.Path)\n\t\t\tif leaf != nil {\n\t\t\t\tleaf.handle(rw, req, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\th, p, ok := t.Match(req.URL.EscapedPath())\n\t\tif ok {\n\t\t\tif splat, ok := p[\"*0\"]; ok {\n\t\t\t\tp[\"*\"] = splat // Easy name.\n\t\t\t}\n\t\t\th(rw, req, p)\n\t\t\treturn\n\t\t}\n\t}\n\n\tr.notFound(rw, req)\n}\n\n// URLFor builds path part of URL by given pair values.\nfunc (r *Router) URLFor(name string, pairs ...string) string {\n\tleaf, ok := r.namedRoutes[name]\n\tif !ok {\n\t\tpanic(\"route with given name does not exists: \" + name)\n\t}\n\treturn leaf.URLPath(pairs...)\n}\n\n// ComboRouter represents a combo router.\ntype ComboRouter struct {\n\trouter   *Router\n\tpattern  string\n\thandlers []Handler\n\tmethods  map[string]bool // Registered methods.\n\n\tlastRoute *Route\n}\n\nfunc (cr *ComboRouter) checkMethod(name string) {\n\tif cr.methods[name] {\n\t\tpanic(\"method '\" + name + \"' has already been registered\")\n\t}\n\tcr.methods[name] = true\n}\n\nfunc (cr *ComboRouter) route(fn func(string, ...Handler) *Route, method string, h ...Handler) *ComboRouter {\n\tcr.checkMethod(method)\n\tcr.lastRoute = fn(cr.pattern, append(cr.handlers, h...)...)\n\treturn cr\n}\n\nfunc (cr *ComboRouter) Get(h ...Handler) *ComboRouter {\n\tif cr.router.autoHead {\n\t\tcr.Head(h...)\n\t}\n\treturn cr.route(cr.router.Get, \"GET\", h...)\n}\n\nfunc (cr *ComboRouter) Patch(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Patch, \"PATCH\", h...)\n}\n\nfunc (cr *ComboRouter) Post(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Post, \"POST\", h...)\n}\n\nfunc (cr *ComboRouter) Put(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Put, \"PUT\", h...)\n}\n\nfunc (cr *ComboRouter) Delete(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Delete, \"DELETE\", h...)\n}\n\nfunc (cr *ComboRouter) Options(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Options, \"OPTIONS\", h...)\n}\n\nfunc (cr *ComboRouter) Head(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Head, \"HEAD\", h...)\n}\n\n// Name sets name of ComboRouter route.\nfunc (cr *ComboRouter) Name(name string) {\n\tif cr.lastRoute == nil {\n\t\tpanic(\"no corresponding route to be named\")\n\t}\n\tcr.lastRoute.Name(name)\n}\n"], "filenames": ["pkg/api/dashboard_snapshot.go", "pkg/macaron/router.go"], "buggy_code_start_loc": [148, 292], "buggy_code_end_loc": [247, 296], "fixing_code_start_loc": [149, 292], "fixing_code_end_loc": [257, 298], "type": "CWE-287", "message": "Grafana is an open source data visualization platform. In affected versions unauthenticated and authenticated users are able to view the snapshot with the lowest database key by accessing the literal paths: /dashboard/snapshot/:key, or /api/snapshots/:key. If the snapshot \"public_mode\" configuration setting is set to true (vs default of false), unauthenticated users are able to delete the snapshot with the lowest database key by accessing the literal path: /api/snapshots-delete/:deleteKey. Regardless of the snapshot \"public_mode\" setting, authenticated users are able to delete the snapshot with the lowest database key by accessing the literal paths: /api/snapshots/:key, or /api/snapshots-delete/:deleteKey. The combination of deletion and viewing enables a complete walk through all snapshot data while resulting in complete snapshot data loss. This issue has been resolved in versions 8.1.6 and 7.5.11. If for some reason you cannot upgrade you can use a reverse proxy or similar to block access to the literal paths: /api/snapshots/:key, /api/snapshots-delete/:deleteKey, /dashboard/snapshot/:key, and /api/snapshots/:key. They have no normal function and can be disabled without side effects.", "other": {"cve": {"id": "CVE-2021-39226", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-05T18:15:07.947", "lastModified": "2021-11-28T23:22:05.317", "vulnStatus": "Analyzed", "cisaExploitAdd": "2022-08-25", "cisaActionDue": "2022-09-15", "cisaRequiredAction": "Apply updates per vendor instructions.", "cisaVulnerabilityName": "Grafana Authentication Bypass Vulnerability", "descriptions": [{"lang": "en", "value": "Grafana is an open source data visualization platform. In affected versions unauthenticated and authenticated users are able to view the snapshot with the lowest database key by accessing the literal paths: /dashboard/snapshot/:key, or /api/snapshots/:key. If the snapshot \"public_mode\" configuration setting is set to true (vs default of false), unauthenticated users are able to delete the snapshot with the lowest database key by accessing the literal path: /api/snapshots-delete/:deleteKey. Regardless of the snapshot \"public_mode\" setting, authenticated users are able to delete the snapshot with the lowest database key by accessing the literal paths: /api/snapshots/:key, or /api/snapshots-delete/:deleteKey. The combination of deletion and viewing enables a complete walk through all snapshot data while resulting in complete snapshot data loss. This issue has been resolved in versions 8.1.6 and 7.5.11. If for some reason you cannot upgrade you can use a reverse proxy or similar to block access to the literal paths: /api/snapshots/:key, /api/snapshots-delete/:deleteKey, /dashboard/snapshot/:key, and /api/snapshots/:key. They have no normal function and can be disabled without side effects."}, {"lang": "es", "value": "Grafana es una plataforma de visualizaci\u00f3n de datos de c\u00f3digo abierto. En las versiones afectadas los usuarios no autenticados y autenticados son capaces de visualizar la snapshot con la clave de base de datos m\u00e1s baja accediendo a las rutas literales /dashboard/snapshot/:key, o /api/snapshots/:key. Si el ajuste de configuraci\u00f3n \"public_mode\" de la snapshot se establece en true (frente a default o false), unos usuarios no autenticados pueden eliminar la snapshot con la clave de base de datos m\u00e1s baja al acceder a la ruta literal /api/snapshots-delete/:deleteKey. Independientemente de la configuraci\u00f3n de \"public_mode\" de la snapshot, unos usuarios autenticados pueden eliminar la snapshot con la clave de base de datos m\u00e1s baja accediendo a las rutas literales: /api/snapshots/:key, o /api/snapshots-delete/:deleteKey. La combinaci\u00f3n de borrado y visualizaci\u00f3n permite un recorrido completo mediante todos los datos de las snapshots mientras se produce una p\u00e9rdida total de datos de las mismas. Este problema se ha resuelto en las versiones 8.1.6 y 7.5.11. Si por alguna raz\u00f3n no puede actualizar puede usar un proxy inverso o similar para bloquear el acceso a las rutas literales /api/snapshots/:key, /api/snapshots-delete/:deleteKey, /dashboard/snapshot/:key, y /api/snapshots/:key. No tienen ninguna funci\u00f3n normal y pueden ser deshabilitadas sin efectos secundarios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.5.11", "matchCriteriaId": "B3C34F75-9949-40B3-819E-3030A44B0174"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.1.6", "matchCriteriaId": "3218296B-F9C5-4E9E-AE37-70A4296AC016"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/10/05/4", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/2d456a6375855364d098ede379438bf7f0667269", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-69j6-29vr-p3j9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://grafana.com/docs/grafana/latest/release-notes/release-notes-7-5-11/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://grafana.com/docs/grafana/latest/release-notes/release-notes-8-1-6/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DCKBFUSY6V4VU5AQUYWKISREZX5NLQJT/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6ANHRDBXQT6TURLP2THM26ZPDINFBEG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211029-0008/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/2d456a6375855364d098ede379438bf7f0667269"}}