{"buggy_code": ["/**\n** @file mruby/proc.h - Proc class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#ifndef MRUBY_PROC_H\n#define MRUBY_PROC_H\n\n#include \"common.h\"\n#include <mruby/irep.h>\n\n/**\n * Proc class\n */\nMRB_BEGIN_DECL\n\nstruct REnv {\n  MRB_OBJECT_HEADER;\n  mrb_value *stack;\n  struct mrb_context *cxt;\n  mrb_sym mid;\n};\n\n/* flags (21bits): 1(close):1(touched):1(heap):8(cioff/bidx):8(stack_len) */\n#define MRB_ENV_SET_LEN(e,len) ((e)->flags = (((e)->flags & ~0xff)|((unsigned int)(len) & 0xff)))\n#define MRB_ENV_LEN(e) ((mrb_int)((e)->flags & 0xff))\n#define MRB_ENV_CLOSED (1<<20)\n#define MRB_ENV_TOUCHED (1<<19)\n#define MRB_ENV_HEAPED (1<<18)\n#define MRB_ENV_CLOSE(e) ((e)->flags |= MRB_ENV_CLOSED)\n#define MRB_ENV_TOUCH(e) ((e)->flags |= MRB_ENV_TOUCHED)\n#define MRB_ENV_HEAP(e) ((e)->flags |= MRB_ENV_HEAPED)\n#define MRB_ENV_HEAP_P(e) ((e)->flags & MRB_ENV_HEAPED)\n#define MRB_ENV_ONSTACK_P(e) (((e)->flags & MRB_ENV_CLOSED) == 0)\n#define MRB_ENV_BIDX(e) (((e)->flags >> 8) & 0xff)\n#define MRB_ENV_SET_BIDX(e,idx) ((e)->flags = (((e)->flags & ~(0xff<<8))|((unsigned int)(idx) & 0xff)<<8))\n\nvoid mrb_env_unshare(mrb_state*, struct REnv*);\n\nstruct RProc {\n  MRB_OBJECT_HEADER;\n  union {\n    const mrb_irep *irep;\n    mrb_func_t func;\n  } body;\n  const struct RProc *upper;\n  union {\n    struct RClass *target_class;\n    struct REnv *env;\n  } e;\n};\n\n/* aspec access */\n#define MRB_ASPEC_REQ(a)          (((a) >> 18) & 0x1f)\n#define MRB_ASPEC_OPT(a)          (((a) >> 13) & 0x1f)\n#define MRB_ASPEC_REST(a)         (((a) >> 12) & 0x1)\n#define MRB_ASPEC_POST(a)         (((a) >> 7) & 0x1f)\n#define MRB_ASPEC_KEY(a)          (((a) >> 2) & 0x1f)\n#define MRB_ASPEC_KDICT(a)        (((a) >> 1) & 0x1)\n#define MRB_ASPEC_BLOCK(a)        ((a) & 1)\n\n#define MRB_PROC_CFUNC_FL 128\n#define MRB_PROC_CFUNC_P(p) (((p)->flags & MRB_PROC_CFUNC_FL) != 0)\n#define MRB_PROC_CFUNC(p) (p)->body.func\n#define MRB_PROC_STRICT 256\n#define MRB_PROC_STRICT_P(p) (((p)->flags & MRB_PROC_STRICT) != 0)\n#define MRB_PROC_ORPHAN 512\n#define MRB_PROC_ORPHAN_P(p) (((p)->flags & MRB_PROC_ORPHAN) != 0)\n#define MRB_PROC_ENVSET 1024\n#define MRB_PROC_ENV_P(p) (((p)->flags & MRB_PROC_ENVSET) != 0)\n#define MRB_PROC_ENV(p) (MRB_PROC_ENV_P(p) ? (p)->e.env : NULL)\n#define MRB_PROC_TARGET_CLASS(p) (MRB_PROC_ENV_P(p) ? (p)->e.env->c : (p)->e.target_class)\n#define MRB_PROC_SET_TARGET_CLASS(p,tc) do {\\\n  if (MRB_PROC_ENV_P(p)) {\\\n    (p)->e.env->c = (tc);\\\n    mrb_field_write_barrier(mrb, (struct RBasic*)(p)->e.env, (struct RBasic*)(tc));\\\n  }\\\n  else {\\\n    (p)->e.target_class = (tc);\\\n    mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)(tc));\\\n  }\\\n} while (0)\n#define MRB_PROC_SCOPE 2048\n#define MRB_PROC_SCOPE_P(p) (((p)->flags & MRB_PROC_SCOPE) != 0)\n#define MRB_PROC_NOARG 4096 /* for MRB_PROC_CFUNC_FL, it would be something like MRB_ARGS_NONE() or MRB_METHOD_NOARG_FL */\n#define MRB_PROC_NOARG_P(p) (((p)->flags & MRB_PROC_NOARG) != 0)\n\n#define mrb_proc_ptr(v)    ((struct RProc*)(mrb_ptr(v)))\n\nstruct RProc *mrb_proc_new(mrb_state*, const mrb_irep*);\nstruct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);\nMRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);\nMRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);\nvoid mrb_proc_copy(struct RProc *a, struct RProc *b);\nmrb_int mrb_proc_arity(const struct RProc *p);\n\n/* following functions are defined in mruby-proc-ext so please include it when using */\nMRB_API struct RProc *mrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const mrb_value *argv);\nMRB_API mrb_value mrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx);\n/* old name */\n#define mrb_cfunc_env_get(mrb, idx) mrb_proc_cfunc_env_get(mrb, idx)\n\n#define MRB_METHOD_FUNC_FL 1\n#define MRB_METHOD_NOARG_FL 2\n\n#ifndef MRB_USE_METHOD_T_STRUCT\n\n#define MRB_METHOD_FUNC_P(m) (((uintptr_t)(m))&MRB_METHOD_FUNC_FL)\n#define MRB_METHOD_NOARG_P(m) ((((uintptr_t)(m))&MRB_METHOD_NOARG_FL)?1:0)\n#define MRB_METHOD_NOARG_SET(m) ((m)=(mrb_method_t)(((uintptr_t)(m))|MRB_METHOD_NOARG_FL))\n#define MRB_METHOD_FUNC(m) ((mrb_func_t)((uintptr_t)(m)>>2))\n#define MRB_METHOD_FROM_FUNC(m,fn) ((m)=(mrb_method_t)((((uintptr_t)(fn))<<2)|MRB_METHOD_FUNC_FL))\n#define MRB_METHOD_FROM_PROC(m,pr) ((m)=(mrb_method_t)(pr))\n#define MRB_METHOD_PROC_P(m) (!MRB_METHOD_FUNC_P(m))\n#define MRB_METHOD_PROC(m) ((struct RProc*)(m))\n#define MRB_METHOD_UNDEF_P(m) ((m)==0)\n\n#else\n\n#define MRB_METHOD_FUNC_P(m) ((m).flags&MRB_METHOD_FUNC_FL)\n#define MRB_METHOD_NOARG_P(m) (((m).flags&MRB_METHOD_NOARG_FL)?1:0)\n#define MRB_METHOD_FUNC(m) ((m).func)\n#define MRB_METHOD_NOARG_SET(m) do{(m).flags|=MRB_METHOD_NOARG_FL;}while(0)\n#define MRB_METHOD_FROM_FUNC(m,fn) do{(m).flags=MRB_METHOD_FUNC_FL;(m).func=(fn);}while(0)\n#define MRB_METHOD_FROM_PROC(m,pr) do{(m).flags=0;(m).proc=(struct RProc*)(pr);}while(0)\n#define MRB_METHOD_PROC_P(m) (!MRB_METHOD_FUNC_P(m))\n#define MRB_METHOD_PROC(m) ((m).proc)\n#define MRB_METHOD_UNDEF_P(m) ((m).proc==NULL)\n\n#endif /* MRB_USE_METHOD_T_STRUCT */\n\n#define MRB_METHOD_CFUNC_P(m) (MRB_METHOD_FUNC_P(m)?TRUE:(MRB_METHOD_PROC(m)?(MRB_PROC_CFUNC_P(MRB_METHOD_PROC(m))):FALSE))\n#define MRB_METHOD_CFUNC(m) (MRB_METHOD_FUNC_P(m)?MRB_METHOD_FUNC(m):((MRB_METHOD_PROC(m)&&MRB_PROC_CFUNC_P(MRB_METHOD_PROC(m)))?MRB_PROC_CFUNC(MRB_METHOD_PROC(m)):NULL))\n\n\n#include <mruby/khash.h>\n\nMRB_API mrb_value mrb_load_proc(mrb_state *mrb, const struct RProc *proc);\n\nstatic inline void\nmrb_vm_ci_proc_set(mrb_callinfo *ci, const struct RProc *p)\n{\n  ci->proc = p;\n  ci->pc = (p && !MRB_PROC_CFUNC_P(p)) ? p->body.irep->iseq : NULL;\n}\n\nstatic inline struct RClass *\nmrb_vm_ci_target_class(const mrb_callinfo *ci)\n{\n  if (ci->u.env && ci->u.env->tt == MRB_TT_ENV) {\n    return ci->u.env->c;\n  }\n  else {\n    return ci->u.target_class;\n  }\n}\n\nstatic inline void\nmrb_vm_ci_target_class_set(mrb_callinfo *ci, struct RClass *tc)\n{\n  struct REnv *e = ci->u.env;\n  if (e) {\n    if (e->tt == MRB_TT_ENV) {\n      e->c = tc;\n    }\n    else {\n      ci->u.target_class = tc;\n    }\n  }\n}\n\nstatic inline struct REnv *\nmrb_vm_ci_env(const mrb_callinfo *ci)\n{\n  if (ci->u.env && ci->u.env->tt == MRB_TT_ENV) {\n    return ci->u.env;\n  }\n  else {\n    return NULL;\n  }\n}\n\nstatic inline void\nmrb_vm_ci_env_set(mrb_callinfo *ci, struct REnv *e)\n{\n  if (ci->u.env) {\n    if (ci->u.env->tt == MRB_TT_ENV) {\n      if (e) {\n        e->c = ci->u.env->c;\n        ci->u.env = e;\n      }\n      else {\n        ci->u.target_class = ci->u.env->c;\n      }\n    }\n    else {\n      if (e) {\n        e->c = ci->u.target_class;\n        ci->u.env = e;\n      }\n    }\n  }\n  else {\n    ci->u.env = e;\n  }\n}\n\nMRB_END_DECL\n\n#endif  /* MRUBY_PROC_H */\n", "/*\n** class.c - Class class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n#include <mruby/class.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/data.h>\n#include <mruby/istruct.h>\n#include <mruby/opcode.h>\n#include <mruby/presym.h>\n\nunion mt_ptr {\n  struct RProc *proc;\n  mrb_func_t func;\n};\n\nstruct mt_elem {\n  union mt_ptr ptr;\n  size_t func_p:1;\n  size_t noarg_p:1;\n  mrb_sym key:sizeof(mrb_sym)*8-2;\n};\n\n/* method table structure */\ntypedef struct mt_tbl {\n  size_t size;\n  size_t alloc;\n  struct mt_elem *table;\n} mt_tbl;\n\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n#define MT_CACHE_SIZE 256\nstatic uint8_t mt_cache[MT_CACHE_SIZE];\n#endif\n\n/* Creates the method table. */\nstatic mt_tbl*\nmt_new(mrb_state *mrb)\n{\n  mt_tbl *t;\n\n  t = (mt_tbl*)mrb_malloc(mrb, sizeof(mt_tbl));\n  t->size = 0;\n  t->alloc = 0;\n  t->table = NULL;\n\n  return t;\n}\n\nstatic struct mt_elem *mt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, size_t func_p, size_t noarg_p, union mt_ptr ptr);\n\nstatic void\nmt_rehash(mrb_state *mrb, mt_tbl *t)\n{\n  size_t old_alloc = t->alloc;\n  size_t new_alloc = old_alloc+8;\n  struct mt_elem *old_table = t->table;\n\n  khash_power2(new_alloc);\n  if (old_alloc == new_alloc) return;\n\n  t->alloc = new_alloc;\n  t->size = 0;\n  t->table = (struct mt_elem*)mrb_calloc(mrb, sizeof(struct mt_elem), new_alloc);\n\n  for (size_t i = 0; i < old_alloc; i++) {\n    struct mt_elem *slot = &old_table[i];\n\n    /* key = 0 means empty or deleted */\n    if (slot->key != 0) {\n      mt_put(mrb, t, slot->key, slot->func_p, slot->noarg_p, slot->ptr);\n    }\n  }\n  mrb_free(mrb, old_table);\n}\n\n#define slot_empty_p(slot) ((slot)->key == 0 && (slot)->func_p == 0)\n\n/* Set the value for the symbol in the method table. */\nstatic struct mt_elem*\nmt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, size_t func_p, size_t noarg_p, union mt_ptr ptr)\n{\n  size_t hash, pos, start;\n  struct mt_elem *dslot = NULL;\n\n  if (t->alloc == 0) {\n    mt_rehash(mrb, t);\n  }\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    struct mt_elem *slot = &t->table[pos];\n\n    if (slot->key == sym) {\n      slot->func_p = func_p;\n      slot->noarg_p = noarg_p;\n      slot->ptr = ptr;\n      return slot;\n    }\n    else if (slot->key == 0) {  /* empty or deleted */\n      if (slot->func_p == 0) {  /* empty */\n        t->size++;\n        slot->key = sym;\n        slot->func_p = func_p;\n        slot->noarg_p = noarg_p;\n        slot->ptr = ptr;\n        return slot;\n      }\n      else if (!dslot) {        /* deleted */\n        dslot = slot;\n      }\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      if (dslot) {\n        t->size++;\n        dslot->key = sym;\n        dslot->func_p = func_p;\n        dslot->noarg_p = noarg_p;\n        dslot->ptr = ptr;\n        return dslot;\n      }\n      /* no room */\n      mt_rehash(mrb, t);\n      start = pos = hash & (t->alloc-1);\n    }\n  }\n}\n\n/* Get a value for a symbol from the method table. */\nstatic struct mt_elem*\nmt_get(mrb_state *mrb, mt_tbl *t, mrb_sym sym)\n{\n  size_t hash, pos, start;\n\n  if (t == NULL) return NULL;\n  if (t->alloc == 0) return NULL;\n  if (t->size == 0) return NULL;\n\n  hash = kh_int_hash_func(mrb, sym);\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n  size_t cpos = (hash^(uintptr_t)t) % MT_CACHE_SIZE;\n  pos = mt_cache[cpos];\n  if (cpos < t->alloc && t->table[cpos].key == sym) {\n    return &t->table[cpos];\n  }\n#endif\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    struct mt_elem *slot = &t->table[pos];\n\n    if (slot->key == sym) {\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n      if (pos < 0xff) {\n        mt_cache[cpos] = pos;\n      }\n#endif\n      return slot;\n    }\n    else if (slot_empty_p(slot)) {\n      return NULL;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return NULL;\n    }\n  }\n}\n\n/* Deletes the value for the symbol from the method table. */\nstatic mrb_bool\nmt_del(mrb_state *mrb, mt_tbl *t, mrb_sym sym)\n{\n  size_t hash, pos, start;\n\n  if (t == NULL) return FALSE;\n  if (t->alloc == 0) return  FALSE;\n  if (t->size == 0) return FALSE;\n\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    struct mt_elem *slot = &t->table[pos];\n\n    if (slot->key == sym) {\n      t->size--;\n      slot->key = 0;\n      slot->func_p = 1;\n      return TRUE;\n    }\n    else if (slot_empty_p(slot)) {\n      return FALSE;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return FALSE;\n    }\n  }\n}\n\n/* Copy the method table. */\nstatic struct mt_tbl*\nmt_copy(mrb_state *mrb, mt_tbl *t)\n{\n  mt_tbl *t2;\n  size_t i;\n\n  if (t == NULL) return NULL;\n  if (t->alloc == 0) return NULL;\n  if (t->size == 0) return NULL;\n\n  t2 = mt_new(mrb);\n  for (i=0; i<t->alloc; i++) {\n    struct mt_elem *slot = &t->table[i];\n\n    if (slot->key) {\n      mt_put(mrb, t2, slot->key, slot->func_p, slot->noarg_p, slot->ptr);\n    }\n  }\n  return t2;\n}\n\n/* Free memory of the method table. */\nstatic void\nmt_free(mrb_state *mrb, mt_tbl *t)\n{\n  mrb_free(mrb, t->table);\n  mrb_free(mrb, t);\n}\n\nMRB_API void\nmrb_mt_foreach(mrb_state *mrb, struct RClass *c, mrb_mt_foreach_func *fn, void *p)\n{\n  mt_tbl *t = c->mt;\n  size_t i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  for (i=0; i<t->alloc; i++) {\n    struct mt_elem *slot = &t->table[i];\n\n    if (slot->key) {\n      mrb_method_t m;\n\n      if (slot->func_p) {\n        MRB_METHOD_FROM_FUNC(m, slot->ptr.func);\n      }\n      else {\n        MRB_METHOD_FROM_PROC(m, slot->ptr.proc);\n      }\n      if (slot->noarg_p) {\n        MRB_METHOD_NOARG_SET(m);\n      }\n\n      if (fn(mrb, slot->key, m, p) != 0)\n        return;\n    }\n  }\n  return;\n}\n\nvoid\nmrb_gc_mark_mt(mrb_state *mrb, struct RClass *c)\n{\n  mt_tbl *t = c->mt;\n  size_t i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  for (i=0; i<t->alloc; i++) {\n    struct mt_elem *slot = &t->table[i];\n\n    if (slot->key && !slot->func_p) { /* Proc pointer */\n      struct RProc *p = slot->ptr.proc;\n      mrb_gc_mark(mrb, (struct RBasic*)p);\n    }\n  }\n  return;\n}\n\nsize_t\nmrb_gc_mark_mt_size(mrb_state *mrb, struct RClass *c)\n{\n  struct mt_tbl *h = c->mt;\n\n  if (!h) return 0;\n  return h->size;\n}\n\nvoid\nmrb_gc_free_mt(mrb_state *mrb, struct RClass *c)\n{\n  if (c->mt) mt_free(mrb, c->mt);\n}\n\nvoid\nmrb_class_name_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_value name;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  if (mrb_obj_iv_defined(mrb, (struct RObject*)c, nsym)) return;\n  if (outer == NULL || outer == mrb->object_class) {\n    name = mrb_symbol_value(id);\n  }\n  else {\n    name = mrb_class_path(mrb, outer);\n    if (mrb_nil_p(name)) {      /* unnamed outer class */\n      if (outer != mrb->object_class && outer != c) {\n        mrb_obj_iv_set_force(mrb, (struct RObject*)c, MRB_SYM(__outer__),\n                             mrb_obj_value(outer));\n      }\n      return;\n    }\n    else {\n      mrb_int len;\n      const char *n = mrb_sym_name_len(mrb, id, &len);\n\n      mrb_str_cat_lit(mrb, name, \"::\");\n      mrb_str_cat(mrb, name, n, len);\n    }\n  }\n  mrb_obj_iv_set_force(mrb, (struct RObject*)c, nsym, name);\n}\n\nmrb_bool\nmrb_const_name_p(mrb_state *mrb, const char *name, mrb_int len)\n{\n  return len > 0 && ISUPPER(name[0]) && mrb_ident_p(name+1, len-1);\n}\n\nstatic void\nsetup_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_class_name_class(mrb, outer, c, id);\n  mrb_obj_iv_set(mrb, (struct RObject*)outer, id, mrb_obj_value(c));\n}\n\n#define make_metaclass(mrb, c) prepare_singleton_class((mrb), (struct RBasic*)(c))\n\nstatic void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}\n\nstatic mrb_value\nclass_name_str(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value path = mrb_class_path(mrb, c);\n  if (mrb_nil_p(path)) {\n    path = c->tt == MRB_TT_MODULE ? mrb_str_new_lit(mrb, \"#<Module:\") :\n                                    mrb_str_new_lit(mrb, \"#<Class:\");\n    mrb_str_cat_str(mrb, path, mrb_ptr_to_str(mrb, c));\n    mrb_str_cat_lit(mrb, path, \">\");\n  }\n  return path;\n}\n\nstatic struct RClass*\nclass_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}\n\nstatic struct RClass*\nmodule_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_MODULE);\n  return mrb_class_ptr(c);\n}\n\nstatic mrb_bool\nclass_ptr_p(mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n  case MRB_TT_CLASS:\n  case MRB_TT_SCLASS:\n  case MRB_TT_MODULE:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ncheck_if_class_or_module(mrb_state *mrb, mrb_value obj)\n{\n  if (!class_ptr_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class/module\", obj);\n  }\n}\n\nstatic struct RClass*\ndefine_module(mrb_state *mrb, mrb_sym name, struct RClass *outer)\n{\n  struct RClass *m;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    return module_from_sym(mrb, outer, name);\n  }\n  m = mrb_module_new(mrb);\n  setup_class(mrb, outer, m, name);\n\n  return m;\n}\n\nMRB_API struct RClass*\nmrb_define_module_id(mrb_state *mrb, mrb_sym name)\n{\n  return define_module(mrb, name, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_module(mrb_state *mrb, const char *name)\n{\n  return define_module(mrb, mrb_intern_cstr(mrb, name), mrb->object_class);\n}\n\nstruct RClass*\nmrb_vm_define_module(mrb_state *mrb, mrb_value outer, mrb_sym id)\n{\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_module_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a module\", old);\n    }\n    return mrb_class_ptr(old);\n  }\n  return define_module(mrb, id, mrb_class_ptr(outer));\n}\n\nMRB_API struct RClass*\nmrb_define_module_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  struct RClass * c = define_module(mrb, name, outer);\n\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c = define_module(mrb, id, outer);\n\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nstatic struct RClass*\nfind_origin(struct RClass *c)\n{\n  MRB_CLASS_ORIGIN(c);\n  return c;\n}\n\nstatic struct RClass*\ndefine_class(mrb_state *mrb, mrb_sym name, struct RClass *super, struct RClass *outer)\n{\n  struct RClass * c;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    c = class_from_sym(mrb, outer, name);\n    MRB_CLASS_ORIGIN(c);\n    if (super && mrb_class_real(c->super) != super) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for Class %n (%C not %C)\",\n                 name, c->super, super);\n    }\n    return c;\n  }\n\n  c = mrb_class_new(mrb, super);\n  setup_class(mrb, outer, c, name);\n\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_id(mrb_state *mrb, mrb_sym name, struct RClass *super)\n{\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%n', Object assumed\", name);\n  }\n  return define_class(mrb, name, super, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_class(mrb_state *mrb, const char *name, struct RClass *super)\n{\n  return mrb_define_class_id(mrb, mrb_intern_cstr(mrb, name), super);\n}\n\nstatic mrb_value mrb_bob_init(mrb_state *mrb, mrb_value);\n#ifndef MRB_NO_METHOD_CACHE\nstatic void mc_clear(mrb_state *mrb);\n#else\n#define mc_clear(mrb)\n#endif\n\nstatic void\nmrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FL_CLASS_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mrb_mc_clear_by_class(mrb, klass);\n  mid = MRB_SYM(inherited);\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_bob_init)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n\nstruct RClass*\nmrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (!mrb_class_p(super)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%!v given)\", super);\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_class_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class\", old);\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %v\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n\nMRB_API mrb_bool\nmrb_class_defined(mrb_state *mrb, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), name);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_class_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return class_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_class_get_under_id(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_exc_get_id(mrb_state *mrb, mrb_sym name)\n{\n  struct RClass *exc, *e;\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(mrb->object_class), name);\n\n  if (!mrb_class_p(c)) {\n    mrb_raise(mrb, mrb->eException_class, \"exception corrupted\");\n  }\n  exc = e = mrb_class_ptr(c);\n\n  while (e) {\n    if (e == mrb->eException_class)\n      return exc;\n    e = e->super;\n  }\n  return mrb->eException_class;\n}\n\nMRB_API struct RClass*\nmrb_module_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return module_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_module_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return module_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_module_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_module_get_under_id(mrb, mrb->object_class, name);\n}\n\n/*!\n * Defines a class under the namespace of \\a outer.\n * \\param outer  a class which contains the new class.\n * \\param name     name of the new class\n * \\param super  a class from which the new class will derive.\n *               NULL means \\c Object class.\n * \\return the created class\n * \\throw TypeError if the constant name \\a name is already taken but\n *                  the constant is not a \\c Class.\n * \\throw NameError if the class is already defined but the class can not\n *                  be reopened because its superclass is not \\a super.\n * \\post top-level constant named \\a name refers the returned class.\n *\n * \\note if a class named \\a name is already defined and its superclass is\n *       \\a super, the function just returns the defined class.\n */\nMRB_API struct RClass*\nmrb_define_class_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name, struct RClass *super)\n{\n  struct RClass * c;\n\n#if 0\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%C::%n', Object assumed\", outer, id);\n  }\n#endif\n  c = define_class(mrb, name, super, outer);\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super)\n{\n  return mrb_define_class_under_id(mrb, outer, mrb_intern_cstr(mrb, name), super);\n}\n\nMRB_API void\nmrb_define_method_raw(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_method_t m)\n{\n  mt_tbl *h;\n  union mt_ptr ptr;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  mrb_check_frozen(mrb, c);\n  if (!h) h = c->mt = mt_new(mrb);\n  if (MRB_METHOD_PROC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    ptr.proc = p;\n    if (p) {\n      if (p->color != MRB_GC_RED) {\n        p->flags |= MRB_PROC_SCOPE;\n        p->c = NULL;\n        mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)p);\n        if (!MRB_PROC_ENV_P(p)) {\n          MRB_PROC_SET_TARGET_CLASS(p, c);\n        }\n      }\n      else {\n        mrb_assert(MRB_FROZEN_P(p) && MRB_PROC_SCOPE_P(p));\n        mrb_assert(p->c == NULL && p->upper == NULL && p->e.target_class == NULL);\n      }\n    }\n  }\n  else {\n    ptr.func = MRB_METHOD_FUNC(m);\n  }\n  mt_put(mrb, h, mid, MRB_METHOD_FUNC_P(m), MRB_METHOD_NOARG_P(m), ptr);\n  mc_clear(mrb);\n}\n\nMRB_API void\nmrb_define_method_id(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_method_t m;\n  int ai = mrb_gc_arena_save(mrb);\n\n  MRB_METHOD_FROM_FUNC(m, func);\n#ifndef MRB_USE_METHOD_T_STRUCT\n  mrb_assert(MRB_METHOD_FUNC(m) == func);\n#endif\n  if (aspec == MRB_ARGS_NONE()) {\n    MRB_METHOD_NOARG_SET(m);\n  }\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_gc_arena_restore(mrb, ai);\n}\n\nMRB_API void\nmrb_define_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_method_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n/* a function to raise NotImplementedError with current method name */\nMRB_API void\nmrb_notimplement(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n\n  if (ci->mid) {\n    mrb_raisef(mrb, E_NOTIMP_ERROR, \"%n() function is unimplemented on this machine\", ci->mid);\n  }\n}\n\n/* a function to be replacement of unimplemented method */\nMRB_API mrb_value\nmrb_notimplement_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_notimplement(mrb);\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic void\nensure_class_type(mrb_state *mrb, mrb_value val)\n{\n  if (!class_ptr_p(val)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not class/module\", val);\n  }\n}\n\n#define to_sym(mrb, ss) mrb_obj_to_sym(mrb, ss)\n\nMRB_API mrb_int\nmrb_get_argc(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->ci->stack[1]);\n\n    argc = ARY_LEN(a);\n  }\n  return argc;\n}\n\nMRB_API const mrb_value*\nmrb_get_argv(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n  mrb_value *array_argv = mrb->c->ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    array_argv = ARY_PTR(a);\n  }\n  return array_argv;\n}\n\nMRB_API mrb_value\nmrb_get_arg1(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_int argc = ci->n;\n  mrb_value *array_argv = ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    argc = ARY_LEN(a);\n    array_argv = ARY_PTR(a);\n  }\n  if (argc == 0 && ci->nk == 15) {\n    mrb_int n = ci->n;\n    if (n == 15) n = 1;\n    return ci->stack[n+1];      /* kwhash next to positional arguments */\n  }\n  if (argc != 1) {\n    mrb_argnum_error(mrb, argc, 1, 1);\n  }\n  return array_argv[0];\n}\n\nmrb_int mrb_ci_bidx(mrb_callinfo *ci);\n\nMRB_API mrb_bool\nmrb_block_given_p(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_value b = ci->stack[mrb_ci_bidx(ci)];\n\n  return !mrb_nil_p(b);\n}\n\n/*\n  retrieve arguments from mrb_state.\n\n  mrb_get_args(mrb, format, ...)\n\n  returns number of arguments parsed.\n\n  format specifiers:\n\n    string  mruby type     C type                 note\n    ----------------------------------------------------------------------------------------------\n    o:      Object         [mrb_value]\n    C:      Class/Module   [mrb_value]            when ! follows, the value may be nil\n    S:      String         [mrb_value]            when ! follows, the value may be nil\n    A:      Array          [mrb_value]            when ! follows, the value may be nil\n    H:      Hash           [mrb_value]            when ! follows, the value may be nil\n    s:      String         [const char*,mrb_int]  Receive two arguments; s! gives (NULL,0) for nil\n    z:      String         [const char*]          NUL terminated string; z! gives NULL for nil\n    a:      Array          [const mrb_value*,mrb_int] Receive two arguments; a! gives (NULL,0) for nil\n    c:      Class/Module   [strcut RClass*]       c! gives NULL for nil\n    f:      Integer/Float  [mrb_float]\n    i:      Integer/Float  [mrb_int]\n    b:      boolean        [mrb_bool]\n    n:      String/Symbol  [mrb_sym]\n    d:      data           [void*,mrb_data_type const] 2nd argument will be used to check data type so it won't be modified; when ! follows, the value may be nil\n    I:      inline struct  [void*,struct RClass]  I! gives NULL for nil\n    &:      block          [mrb_value]            &! raises exception if no block given\n    *:      rest argument  [const mrb_value*,mrb_int] The rest of the arguments as an array; *! avoid copy of the stack\n    |:      optional                              Following arguments are optional\n    ?:      optional given [mrb_bool]             true if preceding argument (optional) is given\n    ':':    keyword args   [mrb_kwargs const]     Get keyword arguments\n\n  format modifiers:\n\n    string  note\n    ----------------------------------------------------------------------------------------------\n    !:      Switch to the alternate mode; The behaviour changes depending on the specifier\n    +:      Request a not frozen object; However, except nil value\n */\nMRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  const char *fmt = format;\n  char c;\n  int i = 0;\n  va_list ap;\n  mrb_callinfo *ci = mrb->c->ci;\n  int argc = ci->n;\n  const mrb_value *argv = ci->stack+1;\n  mrb_bool argv_on_stack;\n  mrb_bool opt = FALSE;\n  mrb_bool opt_skip = TRUE;\n  const mrb_value *pickarg = NULL; /* arguments currently being processed */\n  mrb_value kdict = mrb_nil_value();\n  mrb_bool reqkarg = FALSE;\n  int argc_min = 0, argc_max = 0;\n\n  va_start(ap, format);\n\n  while ((c = *fmt++)) {\n    switch (c) {\n    case '|':\n      opt = TRUE;\n      break;\n    case '*':\n      opt_skip = FALSE;\n      argc_max = -1;\n      if (!reqkarg) reqkarg = strchr(fmt, ':') ? TRUE : FALSE;\n      goto check_exit;\n    case '!':\n    case '+':\n      break;\n    case ':':\n      reqkarg = TRUE;\n      /* fall through */\n    case '&': case '?':\n      if (opt) opt_skip = FALSE;\n      break;\n    default:\n      if (!opt) argc_min++;\n      argc_max++;\n      break;\n    }\n  }\n\n check_exit:\n  if (!reqkarg && ci->nk > 0) {\n    mrb_assert(ci->nk == 15);\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    if (mrb_hash_p(kdict) && mrb_hash_size(mrb, kdict) > 0) {\n      if (argc < 14) {\n        ci->n++;\n        argc++;    /* include kdict in normal arguments */\n      }\n      else {\n        /* 14+1 == 15 so pack first */\n        if (argc == 14) {\n          /* pack arguments and kdict */\n          ci->stack[1] = mrb_ary_new_from_values(mrb, argc+1, &ci->stack[1]);\n          argc = ci->n = 15;\n        }\n        else {\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, ci->stack[1], kdict);\n        }\n        ci->stack[2] = ci->stack[mrb_ci_bidx(ci)];\n      }\n      ci->nk = 0;\n    }\n  }\n  if (reqkarg && ci->nk > 0) {\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    mrb_assert(ci->nk == 15);\n    mrb_assert(mrb_hash_p(kdict));\n  }\n\n  argv_on_stack = argc < 15;\n  if (!argv_on_stack) {\n    struct RArray *a = mrb_ary_ptr(*argv);\n    argv = ARY_PTR(a);\n    argc = ARY_LEN(a);\n  }\n\n  opt = FALSE;\n  i = 0;\n  while ((c = *format++)) {\n    mrb_bool altmode = FALSE;\n    mrb_bool needmodify = FALSE;\n\n    for (; *format; format++) {\n      switch (*format) {\n      case '!':\n        if (altmode) goto modifier_exit; /* not accept for multiple '!' */\n        altmode = TRUE;\n        break;\n      case '+':\n        if (needmodify) goto modifier_exit; /* not accept for multiple '+' */\n        needmodify = TRUE;\n        break;\n      default:\n        goto modifier_exit;\n      }\n    }\n\n  modifier_exit:\n    switch (c) {\n    case '|': case '*': case '&': case '?': case ':':\n      if (needmodify) {\n      bad_needmodify:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"wrong `%c+` modified specifier`\", c);\n      }\n      break;\n    default:\n      if (i < argc) {\n        pickarg = &argv[i++];\n        if (needmodify && !mrb_nil_p(*pickarg)) {\n          if (mrb_immediate_p(*pickarg)) {\n            mrb_raisef(mrb, E_FROZEN_ERROR, \"can't modify frozen %t\", *pickarg);\n          }\n          mrb_check_frozen(mrb, mrb_obj_ptr(*pickarg));\n        }\n      }\n      else {\n        if (opt) {\n          pickarg = NULL;\n        }\n        else {\n          mrb_argnum_error(mrb, argc, argc_min, argc_max);\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n    case 'C':\n    case 'S':\n    case 'A':\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (pickarg) {\n          if (!(altmode && mrb_nil_p(*pickarg))) {\n            switch (c) {\n            case 'C': ensure_class_type(mrb, *pickarg); break;\n            case 'S': mrb_ensure_string_type(mrb, *pickarg); break;\n            case 'A': mrb_ensure_array_type(mrb, *pickarg); break;\n            case 'H': mrb_ensure_hash_type(mrb, *pickarg); break;\n            }\n          }\n          *p = *pickarg;\n        }\n      }\n      break;\n    case 'c':\n      {\n        struct RClass **p;\n\n        p = va_arg(ap, struct RClass**);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            ensure_class_type(mrb, *pickarg);\n            *p = mrb_class_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n    case 's':\n      {\n        const char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, const char**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_PTR(*pickarg);\n            *pl = RSTRING_LEN(*pickarg);\n          }\n        }\n      }\n      break;\n    case 'z':\n      {\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_CSTR(mrb, *pickarg);\n          }\n        }\n      }\n      break;\n    case 'a':\n      {\n        struct RArray *a;\n        const mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *pb = 0;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_array_type(mrb, *pickarg);\n            a = mrb_ary_ptr(*pickarg);\n            *pb = ARY_PTR(a);\n            *pl = ARY_LEN(a);\n          }\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        struct RClass *klass;\n\n        p = va_arg(ap, void**);\n        klass = va_arg(ap, struct RClass*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            if (!mrb_obj_is_kind_of(mrb, *pickarg, klass)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not a %C\", *pickarg, klass);\n            }\n            if (!mrb_istruct_p(*pickarg)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not inline struct\", *pickarg);\n            }\n            *p = mrb_istruct_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n#ifndef MRB_NO_FLOAT\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (pickarg) {\n          *p = mrb_as_float(mrb, *pickarg);\n        }\n      }\n      break;\n#endif\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (pickarg) {\n          *p = mrb_as_int(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (pickarg) {\n          *boolp = mrb_test(*pickarg);\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (pickarg) {\n          *symp = to_sym(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *datap = 0;\n          }\n          else {\n            *datap = mrb_data_get_ptr(mrb, *pickarg, type);\n          }\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        bp = ci->stack + mrb_ci_bidx(ci);\n        if (altmode && mrb_nil_p(*bp)) {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      if (opt_skip && i == argc) goto finish;\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = pickarg ? TRUE : FALSE;\n      }\n      break;\n\n    case '*':\n      {\n        const mrb_value **var;\n        mrb_int *pl;\n        mrb_bool nocopy = (altmode || !argv_on_stack) ? TRUE : FALSE;\n\n        var = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            if (nocopy) {\n              *var = argv+i;\n            }\n            else {\n              mrb_value args = mrb_ary_new_from_values(mrb, *pl, argv+i);\n              RARRAY(args)->c = NULL;\n              *var = RARRAY_PTR(args);\n            }\n          }\n          i = argc;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n\n    case ':':\n      {\n        mrb_value ksrc = mrb_hash_p(kdict) ? mrb_hash_dup(mrb, kdict) : mrb_hash_new(mrb);\n        const mrb_kwargs *kwargs = va_arg(ap, const mrb_kwargs*);\n        mrb_value *rest;\n\n        if (kwargs == NULL) {\n          rest = NULL;\n        }\n        else {\n          uint32_t kwnum = kwargs->num;\n          uint32_t required = kwargs->required;\n          const mrb_sym *kname = kwargs->table;\n          mrb_value *values = kwargs->values;\n          uint32_t j;\n          const uint32_t keyword_max = 40;\n\n          if (kwnum > keyword_max || required > kwnum) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"keyword number is too large\");\n          }\n\n          for (j = required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (!mrb_hash_key_p(mrb, ksrc, k)) {\n              mrb_raisef(mrb, E_ARGUMENT_ERROR, \"missing keyword: %n\", *kname);\n            }\n            *values = mrb_hash_delete_key(mrb, ksrc, k);\n            mrb_gc_protect(mrb, *values);\n          }\n\n          for (j = kwnum - required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (mrb_hash_key_p(mrb, ksrc, k)) {\n              *values = mrb_hash_delete_key(mrb, ksrc, k);\n              mrb_gc_protect(mrb, *values);\n            }\n            else {\n              *values = mrb_undef_value();\n            }\n          }\n\n          rest = kwargs->rest;\n        }\n\n        if (rest) {\n          *rest = ksrc;\n        }\n        else if (!mrb_hash_empty_p(mrb, ksrc)) {\n          ksrc = mrb_hash_keys(mrb, ksrc);\n          ksrc = RARRAY_PTR(ksrc)[0];\n          mrb_raisef(mrb, E_ARGUMENT_ERROR, \"unknown keyword: %v\", ksrc);\n        }\n      }\n      break;\n\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %c\", c);\n      break;\n    }\n  }\n\n  if (!c && argc > i) {\n    mrb_argnum_error(mrb, argc, argc_min, argc_max);\n  }\n\nfinish:\n  va_end(ap);\n  return i;\n}\n\nstatic struct RClass*\nboot_defclass(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  c = MRB_OBJ_ALLOC(mrb, MRB_TT_CLASS, mrb->class_class);\n  if (super) {\n    c->super = super;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)super);\n  }\n  else {\n    c->super = mrb->object_class;\n  }\n  c->mt = mt_new(mrb);\n  return c;\n}\n\nstatic void\nboot_initmod(mrb_state *mrb, struct RClass *mod)\n{\n  if (!mod->mt) {\n    mod->mt = mt_new(mrb);\n  }\n}\n\nstatic struct RClass*\ninclude_class_new(mrb_state *mrb, struct RClass *m, struct RClass *super)\n{\n  struct RClass *ic = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, mrb->class_class);\n  if (m->tt == MRB_TT_ICLASS) {\n    m = m->c;\n  }\n  MRB_CLASS_ORIGIN(m);\n  ic->iv = m->iv;\n  ic->mt = m->mt;\n  ic->super = super;\n  if (m->tt == MRB_TT_ICLASS) {\n    ic->c = m->c;\n  }\n  else {\n    ic->c = m;\n  }\n  return ic;\n}\n\nstatic int\ninclude_module_at(mrb_state *mrb, struct RClass *c, struct RClass *ins_pos, struct RClass *m, int search_super)\n{\n  struct RClass *p, *ic;\n  void *klass_mt = find_origin(c)->mt;\n\n  while (m) {\n    int original_seen = FALSE;\n    int superclass_seen = FALSE;\n\n    if (c == ins_pos) original_seen = TRUE;\n    if (m->flags & MRB_FL_CLASS_IS_PREPENDED)\n      goto skip;\n\n    if (klass_mt && klass_mt == m->mt)\n      return -1;\n\n    p = c->super;\n    while (p) {\n      if (c == p) original_seen = TRUE;\n      if (p->tt == MRB_TT_ICLASS) {\n        if (p->mt == m->mt) {\n          if (!superclass_seen && original_seen) {\n            ins_pos = p; /* move insert point */\n          }\n          goto skip;\n        }\n      } else if (p->tt == MRB_TT_CLASS) {\n        if (!search_super) break;\n        superclass_seen = TRUE;\n      }\n      p = p->super;\n    }\n\n    ic = include_class_new(mrb, m, ins_pos->super);\n    m->flags |= MRB_FL_CLASS_IS_INHERITED;\n    ins_pos->super = ic;\n    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);\n    ins_pos = ic;\n  skip:\n    m = m->super;\n  }\n  mc_clear(mrb);\n  return 0;\n}\n\nstatic int\nfix_include_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n\n  if (obj->tt == MRB_TT_ICLASS && obj->c == m[0] && !MRB_FLAG_TEST(obj, MRB_FL_CLASS_IS_ORIGIN)) {\n    struct RClass *ic = (struct RClass*)obj;\n    include_module_at(mrb, ic, ic, m[1], 1);\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  mrb_check_frozen(mrb, c);\n  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_include_module, data);\n  }\n}\n\nstatic int\nfix_prepend_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n  struct RClass *c = (struct RClass*)obj;\n\n  if (c->tt == MRB_TT_CLASS || c->tt == MRB_TT_MODULE) {\n    struct RClass *p = c->super;\n    struct RClass *ins_pos = c;\n    while (p) {\n      if (c == m[0]) break;\n      if (p == m[0]->super->c) {\n        ins_pos = c;\n      }\n      if (p->tt == MRB_TT_CLASS) break;\n      if (p->c == m[0]) {\n        include_module_at(mrb, ins_pos, ins_pos, m[1], 0);\n        break;\n      }\n      c = p;\n      p = p->super;\n    }\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_prepend_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  struct RClass *origin;\n\n  mrb_check_frozen(mrb, c);\n  if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n    struct RClass *c0;\n\n    if (c->tt == MRB_TT_ICLASS) {\n      c0 = c->c;\n    }\n    else {\n      c0 = c;\n    }\n    origin = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, c0);\n    origin->flags |= MRB_FL_CLASS_IS_ORIGIN | MRB_FL_CLASS_IS_INHERITED;\n    origin->super = c->super;\n    c->super = origin;\n    origin->mt = c->mt;\n    c->mt = NULL;\n    origin->iv = c->iv;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)origin);\n    c->flags |= MRB_FL_CLASS_IS_PREPENDED;\n  }\n  if (include_module_at(mrb, c, c, m, 0) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic prepend detected\");\n  }\n  if (c->tt == MRB_TT_MODULE &&\n      (c->flags & (MRB_FL_CLASS_IS_INHERITED|MRB_FL_CLASS_IS_PREPENDED))) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_prepend_module, data);\n  }\n}\n\nstatic mrb_value\nmrb_mod_prepend_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_prepend_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_append_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_include_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\n/* 15.2.2.4.28 */\n/*\n *  call-seq:\n *     mod.include?(module)    -> true or false\n *\n *  Returns <code>true</code> if <i>module</i> is included in\n *  <i>mod</i> or one of <i>mod</i>'s ancestors.\n *\n *     module A\n *     end\n *     class B\n *       include A\n *     end\n *     class C < B\n *     end\n *     B.include?(A)   #=> true\n *     C.include?(A)   #=> true\n *     A.include?(A)   #=> false\n */\nstatic mrb_value\nmrb_mod_include_p(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value mod2;\n  struct RClass *c = mrb_class_ptr(mod);\n\n  mrb_get_args(mrb, \"C\", &mod2);\n  mrb_check_type(mrb, mod2, MRB_TT_MODULE);\n\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      if (c->c == mrb_class_ptr(mod2)) return mrb_true_value();\n    }\n    c = c->super;\n  }\n  return mrb_false_value();\n}\n\nstatic mrb_value\nmrb_mod_ancestors(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n    }\n    else if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c));\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_extend_object(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_include_module(mrb, mrb_class_ptr(mrb_singleton_class(mrb, obj)), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_initialize(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value b;\n  struct RClass *m = mrb_class_ptr(mod);\n  boot_initmod(mrb, m); /* bootstrap a newly initialized module */\n  mrb_get_args(mrb, \"|&\", &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &mod, mod, m);\n  }\n  return mod;\n}\n\n/* implementation of module_eval/class_eval */\nmrb_value mrb_mod_module_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\nmrb_mod_dummy_visibility(mrb_state *mrb, mrb_value mod)\n{\n  return mod;\n}\n\n/* returns mrb_class_ptr(mrb_singleton_class()) */\n/* except that it return NULL for immediate values */\nMRB_API struct RClass*\nmrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}\n\nMRB_API mrb_value\nmrb_singleton_class(mrb_state *mrb, mrb_value v)\n{\n  struct RClass *c = mrb_singleton_class_ptr(mrb, v);\n\n  if (c == NULL) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't define singleton\");\n  }\n  return mrb_obj_value(c);\n}\n\nMRB_API void\nmrb_define_singleton_method(mrb_state *mrb, struct RObject *o, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\nMRB_API void\nmrb_define_singleton_method_id(mrb_state *mrb, struct RObject *o, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method_id(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_class_method_id(mrb, c, name, func, aspec);\n  mrb_define_method_id(mrb, c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_module_function_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n#ifndef MRB_NO_METHOD_CACHE\nstatic void\nmc_clear(mrb_state *mrb)\n{\n  static const struct mrb_cache_entry ce_zero ={0};\n\n  for (int i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mrb->cache[i] = ce_zero;\n  }\n}\n\nvoid\nmrb_mc_clear_by_class(mrb_state *mrb, struct RClass *c)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FL_CLASS_IS_INHERITED) {\n    mc_clear(mrb);\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c) mc[i].c = 0;\n  }\n}\n#endif\n\nMRB_API mrb_method_t\nmrb_method_search_vm(mrb_state *mrb, struct RClass **cp, mrb_sym mid)\n{\n  mrb_method_t m;\n  struct RClass *c = *cp;\n#ifndef MRB_NO_METHOD_CACHE\n  struct RClass *oc = c;\n  int h = kh_int_hash_func(mrb, ((intptr_t)oc) ^ mid) & (MRB_METHOD_CACHE_SIZE-1);\n  struct mrb_cache_entry *mc = &mrb->cache[h];\n\n  if (mc->c == c && mc->mid == mid) {\n    *cp = mc->c0;\n    return mc->m;\n  }\n#endif\n\n  while (c) {\n    mt_tbl *h = c->mt;\n\n    if (h) {\n      struct mt_elem *e = mt_get(mrb, h, mid);\n      if (e) {\n        if (e->ptr.proc == 0) break;\n        *cp = c;\n        if (e->func_p) {\n          MRB_METHOD_FROM_FUNC(m, e->ptr.func);\n        }\n        else {\n          MRB_METHOD_FROM_PROC(m, e->ptr.proc);\n        }\n        if (e->noarg_p) {\n          MRB_METHOD_NOARG_SET(m);\n        }\n#ifndef MRB_NO_METHOD_CACHE\n        mc->c = oc;\n        mc->c0 = c;\n        mc->mid = mid;\n        mc->m = m;\n#endif\n        return m;\n      }\n    }\n    c = c->super;\n  }\n  MRB_METHOD_FROM_PROC(m, NULL);\n  return m;                  /* no method */\n}\n\nMRB_API mrb_method_t\nmrb_method_search(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    mrb_name_error(mrb, mid, \"undefined method '%n' for class %C\", mid, c);\n  }\n  return m;\n}\n\n#define ONSTACK_ALLOC_MAX 32\n\nstatic mrb_sym\nprepare_name_common(mrb_state *mrb, mrb_sym sym, const char *prefix, const char *suffix)\n{\n  char onstack[ONSTACK_ALLOC_MAX];\n  mrb_int sym_len;\n  const char *sym_str = mrb_sym_name_len(mrb, sym, &sym_len);\n  size_t prefix_len = prefix ? strlen(prefix) : 0;\n  size_t suffix_len = suffix ? strlen(suffix) : 0;\n  size_t name_len = sym_len + prefix_len + suffix_len;\n  char *buf = name_len > sizeof(onstack) ? (char *)mrb_alloca(mrb, name_len) : onstack;\n  char *p = buf;\n\n  if (prefix_len > 0) {\n    memcpy(p, prefix, prefix_len);\n    p += prefix_len;\n  }\n\n  memcpy(p, sym_str, sym_len);\n  p += sym_len;\n\n  if (suffix_len > 0) {\n    memcpy(p, suffix, suffix_len);\n    p += suffix_len;\n  }\n\n  return mrb_intern(mrb, buf, name_len);\n}\n\nstatic mrb_value\nprepare_ivar_name(mrb_state *mrb, mrb_sym sym)\n{\n  sym = prepare_name_common(mrb, sym, \"@\", NULL);\n  mrb_iv_name_sym_check(mrb, sym);\n  return mrb_symbol_value(sym);\n}\n\nstatic mrb_sym\nprepare_writer_name(mrb_state *mrb, mrb_sym sym)\n{\n  return prepare_name_common(mrb, sym, NULL, \"=\");\n}\n\nstatic mrb_value\nmod_attr_define(mrb_state *mrb, mrb_value mod, mrb_value (*accessor)(mrb_state *, mrb_value), mrb_sym (*access_name)(mrb_state *, mrb_sym))\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  const mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name;\n    mrb_sym method;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n    name = prepare_ivar_name(mrb, method);\n    if (access_name) {\n      method = access_name(mrb, method);\n    }\n\n    p = mrb_proc_new_cfunc_with_env(mrb, accessor, 1, &name);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nattr_reader(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  return mrb_iv_get(mrb, obj, to_sym(mrb, name));\n}\n\nstatic mrb_value\nmrb_mod_attr_reader(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_reader, NULL);\n}\n\nstatic mrb_value\nattr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val = mrb_get_arg1(mrb);\n\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_attr_writer(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_writer, prepare_writer_name);\n}\n\nstatic mrb_value\nmrb_instance_alloc(mrb_state *mrb, mrb_value cv)\n{\n  struct RClass *c = mrb_class_ptr(cv);\n  struct RObject *o;\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n\n  if (c->tt == MRB_TT_SCLASS)\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't create instance of singleton class\");\n\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  if (ttype <= MRB_TT_CPTR) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't create instance of %v\", cv);\n  }\n  o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);\n  return mrb_obj_value(o);\n}\n\n/*\n *  call-seq:\n *     class.new(args, ...)    ->  obj\n *\n *  Creates a new object of <i>class</i>'s class, then\n *  invokes that object's <code>initialize</code> method,\n *  passing it <i>args</i>. This is the method that ends\n *  up getting called whenever an object is constructed using\n *  `.new`.\n *\n */\n\nmrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_bob_init)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_obj_new(mrb_state *mrb, struct RClass *c, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value obj;\n  mrb_sym mid;\n\n  obj = mrb_instance_alloc(mrb, mrb_obj_value(c));\n  mid = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, mid, mrb_bob_init)) {\n    mrb_funcall_argv(mrb, obj, mid, argc, argv);\n  }\n  return obj;\n}\n\nstatic mrb_value\nmrb_class_initialize(mrb_state *mrb, mrb_value c)\n{\n  mrb_value a, b;\n\n  mrb_get_args(mrb, \"|C&\", &a, &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &c, c, mrb_class_ptr(c));\n  }\n  return c;\n}\n\nstatic mrb_value\nmrb_class_new_class(mrb_state *mrb, mrb_value cv)\n{\n  mrb_int n;\n  mrb_value super, blk;\n  mrb_value new_class;\n  mrb_sym mid;\n\n  n = mrb_get_args(mrb, \"|C&\", &super, &blk);\n  if (n == 0) {\n    super = mrb_obj_value(mrb->object_class);\n  }\n  new_class = mrb_obj_value(mrb_class_new(mrb, mrb_class_ptr(super)));\n  mid = MRB_SYM(initialize);\n  if (mrb_func_basic_p(mrb, new_class, mid, mrb_class_initialize)) {\n    mrb_class_initialize(mrb, new_class);\n  }\n  else {\n    mrb_funcall_with_block(mrb, new_class, mid, n, &super, blk);\n  }\n  mrb_class_inherited(mrb, mrb_class_ptr(super), mrb_class_ptr(new_class));\n  return new_class;\n}\n\nstatic mrb_value\nmrb_class_superclass(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c;\n\n  c = mrb_class_ptr(klass);\n  c = find_origin(c)->super;\n  while (c && c->tt == MRB_TT_ICLASS) {\n    c = find_origin(c)->super;\n  }\n  if (!c) return mrb_nil_value();\n  return mrb_obj_value(c);\n}\n\nstatic mrb_value\nmrb_bob_init(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n\n/* 15.3.1.3.1  */\n/* 15.3.1.3.10 */\n/* 15.3.1.3.11 */\n/*\n *  call-seq:\n *     obj == other        -> true or false\n *     obj.equal?(other)   -> true or false\n *     obj.eql?(other)     -> true or false\n *\n *  Equality---At the <code>Object</code> level, <code>==</code> returns\n *  <code>true</code> only if <i>obj</i> and <i>other</i> are the\n *  same object. Typically, this method is overridden in descendant\n *  classes to provide class-specific meaning.\n *\n *  Unlike <code>==</code>, the <code>equal?</code> method should never be\n *  overridden by subclasses: it is used to determine object identity\n *  (that is, <code>a.equal?(b)</code> iff <code>a</code> is the same\n *  object as <code>b</code>).\n *\n *  The <code>eql?</code> method returns <code>true</code> if\n *  <i>obj</i> and <i>anObject</i> have the same value. Used by\n *  <code>Hash</code> to test members for equality.  For objects of\n *  class <code>Object</code>, <code>eql?</code> is synonymous with\n *  <code>==</code>. Subclasses normally continue this tradition, but\n *  there are exceptions. <code>Numeric</code> types, for example,\n *  perform type conversion across <code>==</code>, but not across\n *  <code>eql?</code>, so:\n *\n *     1 == 1.0     #=> true\n *     1.eql? 1.0   #=> false\n */\nmrb_value\nmrb_obj_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg = mrb_get_arg1(mrb);\n\n  return mrb_bool_value(mrb_obj_equal(mrb, self, arg));\n}\n\nMRB_API mrb_bool\nmrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\nMRB_API mrb_bool\nmrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid)\n{\n  return mrb_obj_respond_to(mrb, mrb_class(mrb, obj), mid);\n}\n\nMRB_API mrb_value\nmrb_class_path(mrb_state *mrb, struct RClass *c)\n{\n  mrb_value path;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  path = mrb_obj_iv_get(mrb, (struct RObject*)c, nsym);\n  if (mrb_nil_p(path)) {\n    /* no name (yet) */\n    return mrb_class_find_path(mrb, c);\n  }\n  else if (mrb_symbol_p(path)) {\n    /* toplevel class/module */\n    return mrb_sym_str(mrb, mrb_symbol(path));\n  }\n  return mrb_str_dup(mrb, path);\n}\n\nMRB_API struct RClass*\nmrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}\n\nMRB_API const char*\nmrb_class_name(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value name;\n\n  if (c == NULL) return NULL;\n  name = class_name_str(mrb, c);\n  return RSTRING_PTR(name);\n}\n\nMRB_API const char*\nmrb_obj_classname(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_name(mrb, mrb_obj_class(mrb, obj));\n}\n\n/*!\n * Ensures a class can be derived from super.\n *\n * \\param super a reference to an object.\n * \\exception TypeError if \\a super is not a Class or \\a super is a singleton class.\n */\nstatic void\nmrb_check_inheritable(mrb_state *mrb, struct RClass *super)\n{\n  if (super->tt != MRB_TT_CLASS) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%C given)\", super);\n  }\n  if (super->tt == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of singleton class\");\n  }\n  if (super == mrb->class_class) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of Class\");\n  }\n}\n\n/*!\n * Creates a new class.\n * \\param super     a class from which the new class derives.\n * \\exception TypeError \\a super is not inheritable.\n * \\exception TypeError \\a super is the Class class.\n */\nMRB_API struct RClass*\nmrb_class_new(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  if (super) {\n    mrb_check_inheritable(mrb, super);\n  }\n  c = boot_defclass(mrb, super);\n  if (super) {\n    MRB_SET_INSTANCE_TT(c, MRB_INSTANCE_TT(super));\n  }\n  make_metaclass(mrb, c);\n\n  return c;\n}\n\n/*!\n * Creates a new module.\n */\nMRB_API struct RClass*\nmrb_module_new(mrb_state *mrb)\n{\n  struct RClass *m = MRB_OBJ_ALLOC(mrb, MRB_TT_MODULE, mrb->module_class);\n  boot_initmod(mrb, m);\n  return m;\n}\n\n/*\n *  call-seq:\n *     obj.class    => class\n *\n *  Returns the class of <i>obj</i>, now preferred over\n *  <code>Object#type</code>, as an object's type in Ruby is only\n *  loosely tied to that object's class. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Integer\n *     self.class   #=> Object\n */\n\nMRB_API struct RClass*\nmrb_obj_class(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_real(mrb_class(mrb, obj));\n}\n\nMRB_API void\nmrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  if (a == b) return;\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  if (!MRB_METHOD_CFUNC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    if (MRB_PROC_ENV_P(p)) {\n      MRB_PROC_ENV(p)->mid = b;\n    }\n    else if (p->color != MRB_GC_RED) {\n      struct RClass *tc = MRB_PROC_TARGET_CLASS(p);\n      struct REnv *e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n\n      e->mid = b;\n      if (tc) {\n        e->c = tc;\n        mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n      }\n      p->e.env = e;\n      p->flags |= MRB_PROC_ENVSET;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n    }\n  }\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\n/*!\n * Defines an alias of a method.\n * \\param mrb    the mruby state\n * \\param klass  the class which the original method belongs to\n * \\param name1  a new name for the method\n * \\param name2  the original name of the method\n */\nMRB_API void\nmrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2)\n{\n  mrb_alias_method(mrb, klass, mrb_intern_cstr(mrb, name1), mrb_intern_cstr(mrb, name2));\n}\n\nMRB_API void\nmrb_define_alias_id(mrb_state *mrb, struct RClass *klass, mrb_sym a, mrb_sym b)\n{\n  mrb_alias_method(mrb, klass, a, b);\n}\n\n/*\n * call-seq:\n *   mod.to_s   -> string\n *\n * Return a string representing this module or class. For basic\n * classes and modules, this is the name. For singletons, we\n * show information on the thing we're attached to as well.\n */\n\nmrb_value\nmrb_mod_to_s(mrb_state *mrb, mrb_value klass)\n{\n  if (mrb_sclass_p(klass)) {\n    mrb_value v = mrb_iv_get(mrb, klass, MRB_SYM(__attached__));\n    mrb_value str = mrb_str_new_lit(mrb, \"#<Class:\");\n\n    if (class_ptr_p(v)) {\n      mrb_str_cat_str(mrb, str, mrb_inspect(mrb, v));\n    }\n    else {\n      mrb_str_cat_str(mrb, str, mrb_any_to_s(mrb, v));\n    }\n    return mrb_str_cat_lit(mrb, str, \">\");\n  }\n  else {\n    return class_name_str(mrb, mrb_class_ptr(klass));\n  }\n}\n\nvoid mrb_method_added(mrb_state *mrb, struct RClass *c, mrb_sym mid);\n\nstatic mrb_value\nmrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  mrb_method_added(mrb, c, new_name);\n  return mod;\n}\n\nstatic void\nundef_method(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  mrb_method_t m;\n\n  MRB_METHOD_FROM_PROC(m, NULL);\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\nMRB_API void\nmrb_undef_method_id(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  if (!mrb_obj_respond_to(mrb, c, a)) {\n    mrb_name_error(mrb, a, \"undefined method '%n' for class '%C'\", a, c);\n  }\n  undef_method(mrb, c, a);\n}\n\nMRB_API void\nmrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API void\nmrb_undef_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name)\n{\n  mrb_undef_method_id(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_undef_class_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  mrb_undef_method(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}\n\nstatic mrb_value\nmrb_mod_undef(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_int argc;\n  const mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    mrb_undef_method_id(mrb, c, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mrb_nil_value();\n}\n\nstatic void\ncheck_const_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  mrb_int len;\n  const char *name = mrb_sym_name_len(mrb, id, &len);\n  if (!mrb_const_name_p(mrb, name, len)) {\n    mrb_name_error(mrb, id, \"wrong constant name %n\", id);\n  }\n}\n\nstatic mrb_value\nmrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  if (inherit) {\n    return mrb_bool_value(mrb_const_defined(mrb, mod, id));\n  }\n  return mrb_bool_value(mrb_const_defined_at(mrb, mod, id));\n}\n\nstatic mrb_value\nmrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}\n\nstatic mrb_value\nmrb_mod_const_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value path = mrb_get_arg1(mrb);\n  mrb_sym id;\n  char *ptr;\n  mrb_int off, end, len;\n\n  if (mrb_symbol_p(path)) {\n    /* const get with symbol */\n    id = mrb_symbol(path);\n    return mrb_const_get_sym(mrb, mod, id);\n  }\n\n  /* const get with class path string */\n  mrb_ensure_string_type(mrb, path);\n  ptr = RSTRING_PTR(path);\n  len = RSTRING_LEN(path);\n  off = 0;\n\n  while (off < len) {\n    end = mrb_str_index_lit(mrb, path, \"::\", off);\n    end = (end == -1) ? len : end;\n    id = mrb_intern(mrb, ptr+off, end-off);\n    mod = mrb_const_get_sym(mrb, mod, id);\n    if (end == len)\n      off = end;\n    else {\n      off = end + 2;\n      if (off == len) {         /* trailing \"::\" */\n        mrb_name_error(mrb, id, \"wrong constant name '%v'\", path);\n      }\n    }\n  }\n\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_const_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value value;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_const_name_sym(mrb, id);\n  mrb_const_set(mrb, mod, id, value);\n  return value;\n}\n\nstatic mrb_value\nmrb_mod_remove_const(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_const_name_sym(mrb, id);\n  val = mrb_iv_remove(mrb, mod, id);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, id, \"constant %n not defined\", id);\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_const_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb->c->ci->mid = 0;\n\n  if (mrb_class_real(mrb_class_ptr(mod)) != mrb->object_class) {\n    mrb_name_error(mrb, sym, \"uninitialized constant %v::%n\", mod, sym);\n  }\n  else {\n    mrb_name_error(mrb, sym, \"uninitialized constant %n\", sym);\n  }\n  /* not reached */\n  return mrb_nil_value();\n}\n\n/* 15.2.2.4.34 */\n/*\n *  call-seq:\n *     mod.method_defined?(symbol)    -> true or false\n *\n *  Returns +true+ if the named method is defined by\n *  _mod_ (or its included modules and, if _mod_ is a class,\n *  its ancestors). Public and protected methods are matched.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       include A\n *       def method3()  end\n *     end\n *\n *     A.method_defined? :method1    #=> true\n *     C.method_defined? \"method1\"   #=> true\n *     C.method_defined? \"method2\"   #=> true\n *     C.method_defined? \"method3\"   #=> true\n *     C.method_defined? \"method4\"   #=> false\n */\n\nstatic mrb_value\nmrb_mod_method_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  return mrb_bool_value(mrb_obj_respond_to(mrb, mrb_class_ptr(mod), id));\n}\n\nvoid\nmrb_method_added(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mrb_sym added;\n  mrb_value recv = mrb_obj_value(c);\n\n  if (c->tt == MRB_TT_SCLASS) {\n    added = MRB_SYM(singleton_method_added);\n    recv = mrb_iv_get(mrb, recv, MRB_SYM(__attached__));\n  }\n  else {\n    added = MRB_SYM(method_added);\n  }\n  mrb_funcall_id(mrb, recv, added, 1, mrb_symbol_value(mid));\n}\n\nmrb_value\nmrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\nmod_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb_class_ptr(self));\n}\n\nstatic mrb_value\ntop_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb->object_class);\n}\n\nstatic mrb_value\nmrb_mod_eqq(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_bool eqq;\n\n  eqq = mrb_obj_is_kind_of(mrb, obj, mrb_class_ptr(mod));\n\n  return mrb_bool_value(eqq);\n}\n\nstatic mrb_value\nmrb_mod_dup(mrb_state *mrb, mrb_value self)\n{\n  mrb_value mod = mrb_obj_clone(mrb, self);\n  MRB_UNSET_FROZEN_FLAG(mrb_obj_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_module_function(mrb_state *mrb, mrb_value mod)\n{\n  const mrb_value *argv;\n  mrb_int argc, i;\n  mrb_sym mid;\n  mrb_method_t m;\n  struct RClass *rclass;\n  int ai;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  if (argc == 0) {\n    /* set MODFUNC SCOPE if implemented */\n    return mod;\n  }\n\n  /* set PRIVATE method visibility if implemented */\n  /* mrb_mod_dummy_visibility(mrb, mod); */\n\n  for (i=0; i<argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_SYMBOL);\n\n    mid = mrb_symbol(argv[i]);\n    rclass = mrb_class_ptr(mod);\n    m = mrb_method_search(mrb, rclass, mid);\n\n    prepare_singleton_class(mrb, (struct RBasic*)rclass);\n    ai = mrb_gc_arena_save(mrb);\n    mrb_define_method_raw(mrb, rclass->c, mid, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n\n  return mod;\n}\n\nstatic struct RClass*\nmrb_singleton_class_clone(mrb_state *mrb, mrb_value obj)\n{\n  struct RClass *klass = mrb_basic_ptr(obj)->c;\n\n  if (klass->tt != MRB_TT_SCLASS)\n    return klass;\n  else {\n    /* copy singleton(unnamed) class */\n    struct RClass *clone = (struct RClass*)mrb_obj_alloc(mrb, klass->tt, mrb->class_class);\n\n    switch (mrb_type(obj)) {\n    case MRB_TT_CLASS:\n    case MRB_TT_SCLASS:\n      break;\n    default:\n      clone->c = mrb_singleton_class_clone(mrb, mrb_obj_value(klass));\n      break;\n    }\n    clone->super = klass->super;\n    if (klass->iv) {\n      mrb_iv_copy(mrb, mrb_obj_value(clone), mrb_obj_value(klass));\n      mrb_obj_iv_set(mrb, (struct RObject*)clone, MRB_SYM(__attached__), obj);\n    }\n    if (klass->mt) {\n      clone->mt = mt_copy(mrb, klass->mt);\n    }\n    else {\n      clone->mt = mt_new(mrb);\n    }\n    clone->tt = MRB_TT_SCLASS;\n    return clone;\n  }\n}\n\nstatic void\ncopy_class(mrb_state *mrb, mrb_value dst, mrb_value src)\n{\n  struct RClass *dc = mrb_class_ptr(dst);\n  struct RClass *sc = mrb_class_ptr(src);\n  /* if the origin is not the same as the class, then the origin and\n     the current class need to be copied */\n  if (sc->flags & MRB_FL_CLASS_IS_PREPENDED) {\n    struct RClass *c0 = sc->super;\n    struct RClass *c1 = dc;\n\n    /* copy prepended iclasses */\n    while (!(c0->flags & MRB_FL_CLASS_IS_ORIGIN)) {\n      c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n      c1 = c1->super;\n      c0 = c0->super;\n    }\n    c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n    c1->super->flags |= MRB_FL_CLASS_IS_ORIGIN;\n  }\n  if (sc->mt) {\n    dc->mt = mt_copy(mrb, sc->mt);\n  }\n  else {\n    dc->mt = mt_new(mrb);\n  }\n  dc->super = sc->super;\n  MRB_SET_INSTANCE_TT(dc, MRB_INSTANCE_TT(sc));\n}\n\n/* 15.3.1.3.16 */\nstatic mrb_value\nmrb_obj_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value orig = mrb_get_arg1(mrb);\n\n  if (mrb_obj_equal(mrb, self, orig)) return self;\n  if ((mrb_type(self) != mrb_type(orig)) || (mrb_obj_class(mrb, self) != mrb_obj_class(mrb, orig))) {\n      mrb_raise(mrb, E_TYPE_ERROR, \"initialize_copy should take same class object\");\n  }\n  return self;\n}\n\nstatic void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, MRB_SYM(__classname__));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  if (!mrb_func_basic_p(mrb, dest, MRB_SYM(initialize_copy), mrb_obj_init_copy)) {\n    mrb_funcall_id(mrb, dest, MRB_SYM(initialize_copy), 1, obj);\n  }\n}\n\n/* 15.3.1.3.8  */\n/*\n *  call-seq:\n *     obj.clone -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference. Copies\n *  the frozen state of <i>obj</i>. See also the discussion\n *  under <code>Object#dup</code>.\n *\n *     class Klass\n *        attr_accessor :str\n *     end\n *     s1 = Klass.new      #=> #<Klass:0x401b3a38>\n *     s1.str = \"Hello\"    #=> \"Hello\"\n *     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n *     s2.str[1,4] = \"i\"   #=> \"i\"\n *     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n *     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n *\n *  Some Class(True False Nil Symbol Integer Float) Object  cannot clone.\n */\nMRB_API mrb_value\nmrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    return self;\n  }\n  if (mrb_sclass_p(self)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FL_OBJ_IS_FROZEN;\n\n  return clone;\n}\n\n/* 15.3.1.3.9  */\n/*\n *  call-seq:\n *     obj.dup -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference.\n *  <code>dup</code> copies the frozen state of <i>obj</i>. See also\n *  the discussion under <code>Object#clone</code>. In general,\n *  <code>clone</code> and <code>dup</code> may have different semantics\n *  in descendant classes. While <code>clone</code> is used to duplicate\n *  an object, including its internal state, <code>dup</code> typically\n *  uses the class of the descendant object to create the new instance.\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n */\n\nMRB_API mrb_value\nmrb_obj_dup(mrb_state *mrb, mrb_value obj)\n{\n  struct RBasic *p;\n  mrb_value dup;\n\n  if (mrb_immediate_p(obj)) {\n    return obj;\n  }\n  if (mrb_sclass_p(obj)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't dup singleton class\");\n  }\n  p = mrb_obj_alloc(mrb, mrb_type(obj), mrb_obj_class(mrb, obj));\n  dup = mrb_obj_value(p);\n  init_copy(mrb, dup, obj);\n\n  return dup;\n}\n\n/* implementation of __id__ */\nmrb_value mrb_obj_id_m(mrb_state *mrb, mrb_value self);\n/* implementation of instance_eval */\nmrb_value mrb_obj_instance_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\ninspect_main(mrb_state *mrb, mrb_value mod)\n{\n  return mrb_str_new_lit(mrb, \"main\");\n}\n\nstatic const mrb_code new_iseq[] = {\n  OP_ENTER, 0x0, 0x10, 0x3,  // OP_ENTER     0:0:1:0:0:1:1\n  OP_LOADSELF, 4,            // OP_LOADSELF  R4\n  OP_SEND, 4, 0, 0,          // OP_SEND      R4  :allocate  n=0\n  OP_MOVE, 0, 4,             // OP_MOVE      R0  R4\n  OP_MOVE, 4, 3,             // OP_MOVE      R4  R3 (&)\n  OP_MOVE, 3, 2,             // OP_MOVE      R3  R2 (**)\n  OP_MOVE, 2, 1,             // OP_MOVE      R2  R1 (*)\n  OP_SSENDB, 1, 1, 255,      // OP_SSENDB    R1  :initialize n=*|nk=*\n  OP_RETURN, 0               // OP_RETURN    R0\n};\n\nMRB_PRESYM_DEFINE_VAR_AND_INITER(new_syms, 2, MRB_SYM(allocate), MRB_SYM(initialize))\n\nstatic const mrb_irep new_irep = {\n  4, 5, 0, MRB_IREP_STATIC,\n  new_iseq, NULL, new_syms, NULL, NULL, NULL,\n  sizeof(new_iseq), 0, 2, 0, 0,\n};\n\nstatic const struct RProc new_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &new_irep }, NULL, { NULL }\n};\n\nstatic void\ninit_class_new(mrb_state *mrb, struct RClass *cls)\n{\n  mrb_method_t m;\n\n  MRB_PRESYM_INIT_SYMBOLS(mrb, new_syms);\n  MRB_METHOD_FROM_PROC(m, &new_proc);\n  mrb_define_method_raw(mrb, cls, MRB_SYM(new), m);\n}\n\n/* implementation of #send method */\nmrb_value mrb_f_send(mrb_state *mrb, mrb_value self);\n\nvoid\nmrb_init_class(mrb_state *mrb)\n{\n  struct RClass *bob;           /* BasicObject */\n  struct RClass *obj;           /* Object */\n  struct RClass *mod;           /* Module */\n  struct RClass *cls;           /* Class */\n\n  /* boot class hierarchy */\n  bob = boot_defclass(mrb, 0);\n  obj = boot_defclass(mrb, bob); mrb->object_class = obj;\n  mod = boot_defclass(mrb, obj); mrb->module_class = mod;/* obj -> mod */\n  cls = boot_defclass(mrb, mod); mrb->class_class = cls; /* obj -> cls */\n  /* fix-up loose ends */\n  bob->c = obj->c = mod->c = cls->c = cls;\n  make_metaclass(mrb, bob);\n  make_metaclass(mrb, obj);\n  make_metaclass(mrb, mod);\n  make_metaclass(mrb, cls);\n\n  /* name basic classes */\n  mrb_define_const_id(mrb, bob, MRB_SYM(BasicObject), mrb_obj_value(bob));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Object),      mrb_obj_value(obj));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Module),      mrb_obj_value(mod));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Class),       mrb_obj_value(cls));\n\n  /* name each classes */\n  mrb_class_name_class(mrb, NULL, bob, MRB_SYM(BasicObject));\n  mrb_class_name_class(mrb, NULL, obj, MRB_SYM(Object)); /* 15.2.1 */\n  mrb_class_name_class(mrb, NULL, mod, MRB_SYM(Module)); /* 15.2.2 */\n  mrb_class_name_class(mrb, NULL, cls, MRB_SYM(Class));  /* 15.2.3 */\n\n  mrb->proc_class = mrb_define_class(mrb, \"Proc\", mrb->object_class);  /* 15.2.17 */\n  MRB_SET_INSTANCE_TT(mrb->proc_class, MRB_TT_PROC);\n\n  MRB_SET_INSTANCE_TT(cls, MRB_TT_CLASS);\n  mrb_define_method(mrb, bob, \"initialize\",              mrb_bob_init,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"!\",                       mrb_bob_not,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"==\",                      mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.1  */\n  mrb_define_method(mrb, bob, \"__id__\",                  mrb_obj_id_m,             MRB_ARGS_NONE()); /* 15.3.1.3.4  */\n  mrb_define_method(mrb, bob, \"__send__\",                mrb_f_send,               MRB_ARGS_REQ(1)|MRB_ARGS_REST()|MRB_ARGS_BLOCK());  /* 15.3.1.3.5  */\n  mrb_define_method(mrb, bob, \"equal?\",                  mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.11 */\n  mrb_define_method(mrb, bob, \"instance_eval\",           mrb_obj_instance_eval,    MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());  /* 15.3.1.3.18 */\n  mrb_define_method(mrb, bob, \"singleton_method_added\",  mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, cls, \"new\",               mrb_class_new_class,      MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, cls, \"allocate\",                mrb_instance_alloc,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, cls, \"superclass\",              mrb_class_superclass,     MRB_ARGS_NONE()); /* 15.2.3.3.4 */\n  mrb_define_method(mrb, cls, \"initialize\",              mrb_class_initialize,     MRB_ARGS_OPT(1)); /* 15.2.3.3.1 */\n  mrb_define_method(mrb, cls, \"inherited\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  init_class_new(mrb, cls);\n\n  MRB_SET_INSTANCE_TT(mod, MRB_TT_MODULE);\n  mrb_define_method(mrb, mod, \"extend_object\",           mrb_mod_extend_object,    MRB_ARGS_REQ(1)); /* 15.2.2.4.25 */\n  mrb_define_method(mrb, mod, \"extended\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.26 */\n  mrb_define_method(mrb, mod, \"prepended\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"prepend_features\",        mrb_mod_prepend_features, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"include?\",                mrb_mod_include_p,        MRB_ARGS_REQ(1)); /* 15.2.2.4.28 */\n  mrb_define_method(mrb, mod, \"append_features\",         mrb_mod_append_features,  MRB_ARGS_REQ(1)); /* 15.2.2.4.10 */\n  mrb_define_method(mrb, mod, \"class_eval\",              mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.15 */\n  mrb_define_method(mrb, mod, \"included\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.29 */\n  mrb_define_method(mrb, mod, \"initialize\",              mrb_mod_initialize,       MRB_ARGS_NONE()); /* 15.2.2.4.31 */\n  mrb_define_method(mrb, mod, \"module_eval\",             mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.35 */\n  mrb_define_method(mrb, mod, \"module_function\",         mrb_mod_module_function,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, mod, \"private\",                 mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.36 */\n  mrb_define_method(mrb, mod, \"protected\",               mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.37 */\n  mrb_define_method(mrb, mod, \"public\",                  mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.38 */\n  mrb_define_method(mrb, mod, \"attr_reader\",             mrb_mod_attr_reader,      MRB_ARGS_ANY());  /* 15.2.2.4.13 */\n  mrb_define_method(mrb, mod, \"attr_writer\",             mrb_mod_attr_writer,      MRB_ARGS_ANY());  /* 15.2.2.4.14 */\n  mrb_define_method(mrb, mod, \"to_s\",                    mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"inspect\",                 mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"alias_method\",            mrb_mod_alias,            MRB_ARGS_ANY());  /* 15.2.2.4.8 */\n  mrb_define_method(mrb, mod, \"ancestors\",               mrb_mod_ancestors,        MRB_ARGS_NONE()); /* 15.2.2.4.9 */\n  mrb_define_method(mrb, mod, \"undef_method\",            mrb_mod_undef,            MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"const_defined?\",          mrb_mod_const_defined,    MRB_ARGS_ARG(1,1)); /* 15.2.2.4.20 */\n  mrb_define_method(mrb, mod, \"const_get\",               mrb_mod_const_get,        MRB_ARGS_REQ(1)); /* 15.2.2.4.21 */\n  mrb_define_method(mrb, mod, \"const_set\",               mrb_mod_const_set,        MRB_ARGS_REQ(2)); /* 15.2.2.4.23 */\n  mrb_define_method(mrb, mod, \"remove_const\",            mrb_mod_remove_const,     MRB_ARGS_REQ(1)); /* 15.2.2.4.40 */\n  mrb_define_method(mrb, mod, \"const_missing\",           mrb_mod_const_missing,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"method_defined?\",         mrb_mod_method_defined,   MRB_ARGS_REQ(1)); /* 15.2.2.4.34 */\n  mrb_define_method(mrb, mod, \"define_method\",           mod_define_method,        MRB_ARGS_ARG(1,1));\n  mrb_define_method(mrb, mod, \"===\",                     mrb_mod_eqq,              MRB_ARGS_REQ(1)); /* 15.2.2.4.7 */\n  mrb_define_method(mrb, mod, \"dup\",                     mrb_mod_dup,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"method_added\",            mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  mrb_undef_method(mrb, cls, \"append_features\");\n  mrb_undef_method(mrb, cls, \"prepend_features\");\n  mrb_undef_method(mrb, cls, \"extend_object\");\n  mrb_undef_method(mrb, cls, \"module_function\");\n\n  mrb->top_self = MRB_OBJ_ALLOC(mrb, MRB_TT_OBJECT, mrb->object_class);\n  mrb_define_singleton_method(mrb, mrb->top_self, \"inspect\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"to_s\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"define_method\", top_define_method, MRB_ARGS_ARG(1,1));\n}\n", "/*\n** proc.c - Proc class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/opcode.h>\n#include <mruby/data.h>\n#include <mruby/presym.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n\nstatic const mrb_code call_iseq[] = {\n  OP_CALL,\n};\n\nstatic const mrb_irep call_irep = {\n  0,                                   /* nlocals */\n  2,                                   /* nregs */\n  0,                                   /* clen */\n  MRB_ISEQ_NO_FREE | MRB_IREP_NO_FREE, /* flags */\n  call_iseq,                           /* iseq */\n  NULL,                                /* pool */\n  NULL,                                /* syms */\n  NULL,                                /* reps */\n  NULL,                                /* lv */\n  NULL,                                /* debug_info */\n  1,                                   /* ilen */\n  0,                                   /* plen */\n  0,                                   /* slen */\n  1,                                   /* rlen */\n  0,                                   /* refcnt */\n};\n\nstatic const struct RProc call_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &call_irep }, NULL, { NULL }\n};\n\nstruct RProc*\nmrb_proc_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  if (ci) {\n    struct RClass *tc = NULL;\n\n    if (ci->proc) {\n      if (ci->proc->color != MRB_GC_RED) {\n        tc = MRB_PROC_TARGET_CLASS(ci->proc);\n      }\n      else {\n        tc = mrb_vm_ci_target_class(ci);\n        if (tc && tc->tt == MRB_TT_ICLASS) {\n          tc = tc->c;\n        }\n      }\n    }\n    if (tc == NULL) {\n      tc = mrb_vm_ci_target_class(ci);\n    }\n    p->upper = ci->proc;\n    p->e.target_class = tc;\n  }\n  p->body.irep = irep;\n  if (irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)irep);\n  }\n\n  return p;\n}\n\nstruct REnv*\nmrb_env_new(mrb_state *mrb, struct mrb_context *c, mrb_callinfo *ci, int nstacks, mrb_value *stack, struct RClass *tc)\n{\n  struct REnv *e;\n  mrb_int bidx = 1;\n  int n = ci->n;\n  int nk = ci->nk;\n\n  e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n  e->c = tc;\n  MRB_ENV_SET_LEN(e, nstacks);\n  bidx += (n == 15) ? 1 : n;\n  bidx += (nk == 15) ? 1 : (2*nk);\n  MRB_ENV_SET_BIDX(e, bidx);\n  e->mid = ci->mid;\n  e->stack = stack;\n  e->cxt = c;\n\n  return e;\n}\n\nstatic void\nclosure_setup(mrb_state *mrb, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  const struct RProc *up = p->upper;\n  struct REnv *e = NULL;\n\n  if (ci && (e = mrb_vm_ci_env(ci)) != NULL) {\n    /* do nothing, because e is assigned already */\n  }\n  else if (up) {\n    struct RClass *tc = ci->u.target_class;\n\n    e = mrb_env_new(mrb, mrb->c, ci, up->body.irep->nlocals, ci->stack, tc);\n    ci->u.env = e;\n    if (MRB_PROC_ENV_P(up) && MRB_PROC_ENV(up)->cxt == NULL) {\n      e->mid = MRB_PROC_ENV(up)->mid;\n    }\n  }\n  if (e) {\n    p->e.env = e;\n    p->flags |= MRB_PROC_ENVSET;\n    mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  }\n}\n\nstruct RProc*\nmrb_closure_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p = mrb_proc_new(mrb, irep);\n\n  closure_setup(mrb, p);\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc(mrb_state *mrb, mrb_func_t func)\n{\n  struct RProc *p;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  p->body.func = func;\n  p->flags |= MRB_PROC_CFUNC_FL;\n  p->upper = 0;\n  p->e.target_class = 0;\n\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p = mrb_proc_new_cfunc(mrb, func);\n  struct REnv *e;\n  int i;\n\n  p->e.env = e = mrb_env_new(mrb, mrb->c, mrb->c->ci, 0, NULL, NULL);\n  p->flags |= MRB_PROC_ENVSET;\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  MRB_ENV_CLOSE(e);\n\n  e->stack = (mrb_value*)mrb_malloc(mrb, sizeof(mrb_value) * argc);\n  MRB_ENV_SET_LEN(e, argc);\n\n  if (argv) {\n    for (i = 0; i < argc; ++i) {\n      e->stack[i] = argv[i];\n    }\n  }\n  else {\n    for (i = 0; i < argc; ++i) {\n      SET_NIL_VALUE(e->stack[i]);\n    }\n  }\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals)\n{\n  return mrb_proc_new_cfunc_with_env(mrb, func, nlocals, NULL);\n}\n\nMRB_API mrb_value\nmrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)\n{\n  const struct RProc *p = mrb->c->ci->proc;\n  struct REnv *e;\n\n  if (!p || !MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from non-cfunc proc\");\n  }\n  e = MRB_PROC_ENV(p);\n  if (!e) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from cfunc Proc without REnv\");\n  }\n  if (idx < 0 || MRB_ENV_LEN(e) <= idx) {\n    mrb_raisef(mrb, E_INDEX_ERROR, \"Env index out of range: %i (expected: 0 <= index < %i)\",\n               idx, MRB_ENV_LEN(e));\n  }\n\n  return e->stack[idx];\n}\n\nvoid\nmrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}\n\nstatic mrb_value\nmrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}\n\nstatic mrb_value\nmrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}\n\n/* 15.2.17.4.2 */\nstatic mrb_value\nproc_arity(mrb_state *mrb, mrb_value self)\n{\n  return mrb_int_value(mrb, mrb_proc_arity(mrb_proc_ptr(self)));\n}\n\n/* 15.3.1.2.6  */\n/* 15.3.1.3.27 */\n/*\n * call-seq:\n *   lambda { |...| block }  -> a_proc\n *\n * Equivalent to <code>Proc.new</code>, except the resulting Proc objects\n * check the number of parameters passed when called.\n */\nstatic mrb_value\nproc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}\n\nmrb_int\nmrb_proc_arity(const struct RProc *p)\n{\n  const mrb_irep *irep;\n  const mrb_code *pc;\n  mrb_aspec aspec;\n  int ma, op, ra, pa, arity;\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    /* TODO cfunc aspec not implemented yet */\n    return -1;\n  }\n\n  irep = p->body.irep;\n  if (!irep) {\n    return 0;\n  }\n\n  pc = irep->iseq;\n  /* arity is depend on OP_ENTER */\n  if (*pc != OP_ENTER) {\n    return 0;\n  }\n\n  aspec = PEEK_W(pc+1);\n  ma = MRB_ASPEC_REQ(aspec);\n  op = MRB_ASPEC_OPT(aspec);\n  ra = MRB_ASPEC_REST(aspec);\n  pa = MRB_ASPEC_POST(aspec);\n  arity = ra || (MRB_PROC_STRICT_P(p) && op) ? -(ma + pa + 1) : ma + pa;\n\n  return arity;\n}\n\nmrb_value\nmrb_proc_local_variables(mrb_state *mrb, const struct RProc *proc)\n{\n  const mrb_irep *irep;\n  mrb_value vars;\n  size_t i;\n\n  if (proc == NULL || MRB_PROC_CFUNC_P(proc)) {\n    return mrb_ary_new(mrb);\n  }\n  vars = mrb_hash_new(mrb);\n  while (proc) {\n    if (MRB_PROC_CFUNC_P(proc)) break;\n    irep = proc->body.irep;\n    if (irep->lv) {\n      for (i = 0; i + 1 < irep->nlocals; ++i) {\n        if (irep->lv[i]) {\n          mrb_sym sym = irep->lv[i];\n          const char *name = mrb_sym_name(mrb, sym);\n          switch (name[0]) {\n          case '*': case '&':\n            break;\n          default:\n            mrb_hash_set(mrb, vars, mrb_symbol_value(sym), mrb_true_value());\n            break;\n          }\n        }\n      }\n    }\n    if (MRB_PROC_SCOPE_P(proc)) break;\n    proc = proc->upper;\n  }\n\n  return mrb_hash_keys(mrb, vars);\n}\n\nconst struct RProc *\nmrb_proc_get_caller(mrb_state *mrb, struct REnv **envp)\n{\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = (c->ci > c->cibase) ? c->ci - 1 : c->cibase;\n  const struct RProc *proc = ci->proc;\n\n  if (!proc || MRB_PROC_CFUNC_P(proc)) {\n    if (envp) *envp = NULL;\n  }\n  else {\n    struct RClass *tc = MRB_PROC_TARGET_CLASS(proc);\n    struct REnv *e = mrb_vm_ci_env(ci);\n\n    if (e == NULL) {\n      int nstacks = proc->body.irep->nlocals;\n      e = mrb_env_new(mrb, c, ci, nstacks, ci->stack, tc);\n      ci->u.env = e;\n    }\n    else if (tc) {\n      e->c = tc;\n      mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n    }\n    if (envp) *envp = e;\n  }\n\n  return proc;\n}\n\n#define IREP_LVAR_MERGE_DEFAULT  50\n#define IREP_LVAR_MERGE_MINIMUM   8\n#define IREP_LVAR_MERGE_MAXIMUM 240\n\n#ifdef MRB_IREP_LVAR_MERGE_LIMIT\n# define IREP_LVAR_MERGE_LIMIT \\\n  ((MRB_IREP_LVAR_MERGE_LIMIT) < IREP_LVAR_MERGE_MINIMUM ? IREP_LVAR_MERGE_MINIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT) > IREP_LVAR_MERGE_MAXIMUM ? IREP_LVAR_MERGE_MAXIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT))\n#else\n# define IREP_LVAR_MERGE_LIMIT IREP_LVAR_MERGE_DEFAULT\n#endif\n\nvoid\nmrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, const mrb_sym *lv, const mrb_value *stack)\n{\n  mrb_assert(!(irep->flags & MRB_IREP_NO_FREE));\n\n  if ((irep->nlocals + num) > IREP_LVAR_MERGE_LIMIT) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"too many local variables for binding (mruby limitation)\");\n  }\n\n  if (!lv) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"unavailable local variable names\");\n  }\n\n  irep->lv = (mrb_sym*)mrb_realloc(mrb, (mrb_sym*)irep->lv, sizeof(mrb_sym) * (irep->nlocals + num));\n  env->stack = (mrb_value*)mrb_realloc(mrb, env->stack, sizeof(mrb_value) * (irep->nlocals + 1 /* self */ + num));\n\n  mrb_sym *destlv = (mrb_sym*)irep->lv + irep->nlocals - 1 /* self */;\n  mrb_value *destst = env->stack + irep->nlocals;\n  memmove(destlv, lv, sizeof(mrb_sym) * num);\n  if (stack) {\n    memmove(destst, stack, sizeof(mrb_value) * num);\n    for (int i = 0; i < num; i++) {\n      if (!mrb_immediate_p(stack[i])) {\n        mrb_field_write_barrier(mrb, (struct RBasic*)env, (struct RBasic*)mrb_obj_ptr(stack[i]));\n      }\n    }\n  }\n  else {\n    for (int i = num; i > 0; i--, destst++) {\n      *destst = mrb_nil_value();\n    }\n  }\n  irep->nlocals += num;\n  irep->nregs = irep->nlocals;\n  MRB_ENV_SET_LEN(env, irep->nlocals);\n}\n\nvoid\nmrb_init_proc(mrb_state *mrb)\n{\n  mrb_method_t m;\n\n  mrb_define_class_method(mrb, mrb->proc_class, \"new\", mrb_proc_s_new, MRB_ARGS_NONE()|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, mrb->proc_class, \"initialize_copy\", mrb_proc_init_copy, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mrb->proc_class, \"arity\", proc_arity, MRB_ARGS_NONE());\n\n  MRB_METHOD_FROM_PROC(m, &call_proc);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_SYM(call), m);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_OPSYM(aref), m);\n\n  mrb_define_class_method(mrb, mrb->kernel_module, \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.2.6  */\n  mrb_define_method(mrb, mrb->kernel_module,       \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.3.27 */\n}\n"], "fixing_code": ["/**\n** @file mruby/proc.h - Proc class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#ifndef MRUBY_PROC_H\n#define MRUBY_PROC_H\n\n#include \"common.h\"\n#include <mruby/irep.h>\n\n/**\n * Proc class\n */\nMRB_BEGIN_DECL\n\nstruct REnv {\n  MRB_OBJECT_HEADER;\n  mrb_value *stack;\n  struct mrb_context *cxt;\n  mrb_sym mid;\n};\n\n/* flags (21bits): 1(close):1(touched):1(heap):8(cioff/bidx):8(stack_len) */\n#define MRB_ENV_SET_LEN(e,len) ((e)->flags = (((e)->flags & ~0xff)|((unsigned int)(len) & 0xff)))\n#define MRB_ENV_LEN(e) ((mrb_int)((e)->flags & 0xff))\n#define MRB_ENV_CLOSED (1<<20)\n#define MRB_ENV_TOUCHED (1<<19)\n#define MRB_ENV_HEAPED (1<<18)\n#define MRB_ENV_CLOSE(e) ((e)->flags |= MRB_ENV_CLOSED)\n#define MRB_ENV_TOUCH(e) ((e)->flags |= MRB_ENV_TOUCHED)\n#define MRB_ENV_HEAP(e) ((e)->flags |= MRB_ENV_HEAPED)\n#define MRB_ENV_HEAP_P(e) ((e)->flags & MRB_ENV_HEAPED)\n#define MRB_ENV_ONSTACK_P(e) (((e)->flags & MRB_ENV_CLOSED) == 0)\n#define MRB_ENV_BIDX(e) (((e)->flags >> 8) & 0xff)\n#define MRB_ENV_SET_BIDX(e,idx) ((e)->flags = (((e)->flags & ~(0xff<<8))|((unsigned int)(idx) & 0xff)<<8))\n\nvoid mrb_env_unshare(mrb_state*, struct REnv*);\n\nstruct RProc {\n  MRB_OBJECT_HEADER;\n  union {\n    const mrb_irep *irep;\n    mrb_func_t func;\n  } body;\n  const struct RProc *upper;\n  union {\n    struct RClass *target_class;\n    struct REnv *env;\n  } e;\n};\n\n/* aspec access */\n#define MRB_ASPEC_REQ(a)          (((a) >> 18) & 0x1f)\n#define MRB_ASPEC_OPT(a)          (((a) >> 13) & 0x1f)\n#define MRB_ASPEC_REST(a)         (((a) >> 12) & 0x1)\n#define MRB_ASPEC_POST(a)         (((a) >> 7) & 0x1f)\n#define MRB_ASPEC_KEY(a)          (((a) >> 2) & 0x1f)\n#define MRB_ASPEC_KDICT(a)        (((a) >> 1) & 0x1)\n#define MRB_ASPEC_BLOCK(a)        ((a) & 1)\n\n#define MRB_PROC_CFUNC_FL 128\n#define MRB_PROC_CFUNC_P(p) (((p)->flags & MRB_PROC_CFUNC_FL) != 0)\n#define MRB_PROC_CFUNC(p) (p)->body.func\n#define MRB_PROC_STRICT 256\n#define MRB_PROC_STRICT_P(p) (((p)->flags & MRB_PROC_STRICT) != 0)\n#define MRB_PROC_ORPHAN 512\n#define MRB_PROC_ORPHAN_P(p) (((p)->flags & MRB_PROC_ORPHAN) != 0)\n#define MRB_PROC_ENVSET 1024\n#define MRB_PROC_ENV_P(p) (((p)->flags & MRB_PROC_ENVSET) != 0)\n#define MRB_PROC_ENV(p) (MRB_PROC_ENV_P(p) ? (p)->e.env : NULL)\n#define MRB_PROC_TARGET_CLASS(p) (MRB_PROC_ENV_P(p) ? (p)->e.env->c : (p)->e.target_class)\n#define MRB_PROC_SET_TARGET_CLASS(p,tc) do {\\\n  if (MRB_PROC_ENV_P(p)) {\\\n    (p)->e.env->c = (tc);\\\n    mrb_field_write_barrier(mrb, (struct RBasic*)(p)->e.env, (struct RBasic*)(tc));\\\n  }\\\n  else {\\\n    (p)->e.target_class = (tc);\\\n    mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)(tc));\\\n  }\\\n} while (0)\n#define MRB_PROC_SCOPE 2048\n#define MRB_PROC_SCOPE_P(p) (((p)->flags & MRB_PROC_SCOPE) != 0)\n#define MRB_PROC_NOARG 4096 /* for MRB_PROC_CFUNC_FL, it would be something like MRB_ARGS_NONE() or MRB_METHOD_NOARG_FL */\n#define MRB_PROC_NOARG_P(p) (((p)->flags & MRB_PROC_NOARG) != 0)\n\n#define mrb_proc_ptr(v)    ((struct RProc*)(mrb_ptr(v)))\n\nstruct RProc *mrb_proc_new(mrb_state*, const mrb_irep*);\nstruct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);\nMRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);\nMRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);\nvoid mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b);\nmrb_int mrb_proc_arity(const struct RProc *p);\n\n/* following functions are defined in mruby-proc-ext so please include it when using */\nMRB_API struct RProc *mrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const mrb_value *argv);\nMRB_API mrb_value mrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx);\n/* old name */\n#define mrb_cfunc_env_get(mrb, idx) mrb_proc_cfunc_env_get(mrb, idx)\n\n#define MRB_METHOD_FUNC_FL 1\n#define MRB_METHOD_NOARG_FL 2\n\n#ifndef MRB_USE_METHOD_T_STRUCT\n\n#define MRB_METHOD_FUNC_P(m) (((uintptr_t)(m))&MRB_METHOD_FUNC_FL)\n#define MRB_METHOD_NOARG_P(m) ((((uintptr_t)(m))&MRB_METHOD_NOARG_FL)?1:0)\n#define MRB_METHOD_NOARG_SET(m) ((m)=(mrb_method_t)(((uintptr_t)(m))|MRB_METHOD_NOARG_FL))\n#define MRB_METHOD_FUNC(m) ((mrb_func_t)((uintptr_t)(m)>>2))\n#define MRB_METHOD_FROM_FUNC(m,fn) ((m)=(mrb_method_t)((((uintptr_t)(fn))<<2)|MRB_METHOD_FUNC_FL))\n#define MRB_METHOD_FROM_PROC(m,pr) ((m)=(mrb_method_t)(pr))\n#define MRB_METHOD_PROC_P(m) (!MRB_METHOD_FUNC_P(m))\n#define MRB_METHOD_PROC(m) ((struct RProc*)(m))\n#define MRB_METHOD_UNDEF_P(m) ((m)==0)\n\n#else\n\n#define MRB_METHOD_FUNC_P(m) ((m).flags&MRB_METHOD_FUNC_FL)\n#define MRB_METHOD_NOARG_P(m) (((m).flags&MRB_METHOD_NOARG_FL)?1:0)\n#define MRB_METHOD_FUNC(m) ((m).func)\n#define MRB_METHOD_NOARG_SET(m) do{(m).flags|=MRB_METHOD_NOARG_FL;}while(0)\n#define MRB_METHOD_FROM_FUNC(m,fn) do{(m).flags=MRB_METHOD_FUNC_FL;(m).func=(fn);}while(0)\n#define MRB_METHOD_FROM_PROC(m,pr) do{(m).flags=0;(m).proc=(struct RProc*)(pr);}while(0)\n#define MRB_METHOD_PROC_P(m) (!MRB_METHOD_FUNC_P(m))\n#define MRB_METHOD_PROC(m) ((m).proc)\n#define MRB_METHOD_UNDEF_P(m) ((m).proc==NULL)\n\n#endif /* MRB_USE_METHOD_T_STRUCT */\n\n#define MRB_METHOD_CFUNC_P(m) (MRB_METHOD_FUNC_P(m)?TRUE:(MRB_METHOD_PROC(m)?(MRB_PROC_CFUNC_P(MRB_METHOD_PROC(m))):FALSE))\n#define MRB_METHOD_CFUNC(m) (MRB_METHOD_FUNC_P(m)?MRB_METHOD_FUNC(m):((MRB_METHOD_PROC(m)&&MRB_PROC_CFUNC_P(MRB_METHOD_PROC(m)))?MRB_PROC_CFUNC(MRB_METHOD_PROC(m)):NULL))\n\n\n#include <mruby/khash.h>\n\nMRB_API mrb_value mrb_load_proc(mrb_state *mrb, const struct RProc *proc);\n\nstatic inline void\nmrb_vm_ci_proc_set(mrb_callinfo *ci, const struct RProc *p)\n{\n  ci->proc = p;\n  ci->pc = (p && !MRB_PROC_CFUNC_P(p)) ? p->body.irep->iseq : NULL;\n}\n\nstatic inline struct RClass *\nmrb_vm_ci_target_class(const mrb_callinfo *ci)\n{\n  if (ci->u.env && ci->u.env->tt == MRB_TT_ENV) {\n    return ci->u.env->c;\n  }\n  else {\n    return ci->u.target_class;\n  }\n}\n\nstatic inline void\nmrb_vm_ci_target_class_set(mrb_callinfo *ci, struct RClass *tc)\n{\n  struct REnv *e = ci->u.env;\n  if (e) {\n    if (e->tt == MRB_TT_ENV) {\n      e->c = tc;\n    }\n    else {\n      ci->u.target_class = tc;\n    }\n  }\n}\n\nstatic inline struct REnv *\nmrb_vm_ci_env(const mrb_callinfo *ci)\n{\n  if (ci->u.env && ci->u.env->tt == MRB_TT_ENV) {\n    return ci->u.env;\n  }\n  else {\n    return NULL;\n  }\n}\n\nstatic inline void\nmrb_vm_ci_env_set(mrb_callinfo *ci, struct REnv *e)\n{\n  if (ci->u.env) {\n    if (ci->u.env->tt == MRB_TT_ENV) {\n      if (e) {\n        e->c = ci->u.env->c;\n        ci->u.env = e;\n      }\n      else {\n        ci->u.target_class = ci->u.env->c;\n      }\n    }\n    else {\n      if (e) {\n        e->c = ci->u.target_class;\n        ci->u.env = e;\n      }\n    }\n  }\n  else {\n    ci->u.env = e;\n  }\n}\n\nMRB_END_DECL\n\n#endif  /* MRUBY_PROC_H */\n", "/*\n** class.c - Class class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n#include <mruby/class.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/data.h>\n#include <mruby/istruct.h>\n#include <mruby/opcode.h>\n#include <mruby/presym.h>\n\nunion mt_ptr {\n  struct RProc *proc;\n  mrb_func_t func;\n};\n\nstruct mt_elem {\n  union mt_ptr ptr;\n  size_t func_p:1;\n  size_t noarg_p:1;\n  mrb_sym key:sizeof(mrb_sym)*8-2;\n};\n\n/* method table structure */\ntypedef struct mt_tbl {\n  size_t size;\n  size_t alloc;\n  struct mt_elem *table;\n} mt_tbl;\n\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n#define MT_CACHE_SIZE 256\nstatic uint8_t mt_cache[MT_CACHE_SIZE];\n#endif\n\n/* Creates the method table. */\nstatic mt_tbl*\nmt_new(mrb_state *mrb)\n{\n  mt_tbl *t;\n\n  t = (mt_tbl*)mrb_malloc(mrb, sizeof(mt_tbl));\n  t->size = 0;\n  t->alloc = 0;\n  t->table = NULL;\n\n  return t;\n}\n\nstatic struct mt_elem *mt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, size_t func_p, size_t noarg_p, union mt_ptr ptr);\n\nstatic void\nmt_rehash(mrb_state *mrb, mt_tbl *t)\n{\n  size_t old_alloc = t->alloc;\n  size_t new_alloc = old_alloc+8;\n  struct mt_elem *old_table = t->table;\n\n  khash_power2(new_alloc);\n  if (old_alloc == new_alloc) return;\n\n  t->alloc = new_alloc;\n  t->size = 0;\n  t->table = (struct mt_elem*)mrb_calloc(mrb, sizeof(struct mt_elem), new_alloc);\n\n  for (size_t i = 0; i < old_alloc; i++) {\n    struct mt_elem *slot = &old_table[i];\n\n    /* key = 0 means empty or deleted */\n    if (slot->key != 0) {\n      mt_put(mrb, t, slot->key, slot->func_p, slot->noarg_p, slot->ptr);\n    }\n  }\n  mrb_free(mrb, old_table);\n}\n\n#define slot_empty_p(slot) ((slot)->key == 0 && (slot)->func_p == 0)\n\n/* Set the value for the symbol in the method table. */\nstatic struct mt_elem*\nmt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, size_t func_p, size_t noarg_p, union mt_ptr ptr)\n{\n  size_t hash, pos, start;\n  struct mt_elem *dslot = NULL;\n\n  if (t->alloc == 0) {\n    mt_rehash(mrb, t);\n  }\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    struct mt_elem *slot = &t->table[pos];\n\n    if (slot->key == sym) {\n      slot->func_p = func_p;\n      slot->noarg_p = noarg_p;\n      slot->ptr = ptr;\n      return slot;\n    }\n    else if (slot->key == 0) {  /* empty or deleted */\n      if (slot->func_p == 0) {  /* empty */\n        t->size++;\n        slot->key = sym;\n        slot->func_p = func_p;\n        slot->noarg_p = noarg_p;\n        slot->ptr = ptr;\n        return slot;\n      }\n      else if (!dslot) {        /* deleted */\n        dslot = slot;\n      }\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      if (dslot) {\n        t->size++;\n        dslot->key = sym;\n        dslot->func_p = func_p;\n        dslot->noarg_p = noarg_p;\n        dslot->ptr = ptr;\n        return dslot;\n      }\n      /* no room */\n      mt_rehash(mrb, t);\n      start = pos = hash & (t->alloc-1);\n    }\n  }\n}\n\n/* Get a value for a symbol from the method table. */\nstatic struct mt_elem*\nmt_get(mrb_state *mrb, mt_tbl *t, mrb_sym sym)\n{\n  size_t hash, pos, start;\n\n  if (t == NULL) return NULL;\n  if (t->alloc == 0) return NULL;\n  if (t->size == 0) return NULL;\n\n  hash = kh_int_hash_func(mrb, sym);\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n  size_t cpos = (hash^(uintptr_t)t) % MT_CACHE_SIZE;\n  pos = mt_cache[cpos];\n  if (cpos < t->alloc && t->table[cpos].key == sym) {\n    return &t->table[cpos];\n  }\n#endif\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    struct mt_elem *slot = &t->table[pos];\n\n    if (slot->key == sym) {\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n      if (pos < 0xff) {\n        mt_cache[cpos] = pos;\n      }\n#endif\n      return slot;\n    }\n    else if (slot_empty_p(slot)) {\n      return NULL;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return NULL;\n    }\n  }\n}\n\n/* Deletes the value for the symbol from the method table. */\nstatic mrb_bool\nmt_del(mrb_state *mrb, mt_tbl *t, mrb_sym sym)\n{\n  size_t hash, pos, start;\n\n  if (t == NULL) return FALSE;\n  if (t->alloc == 0) return  FALSE;\n  if (t->size == 0) return FALSE;\n\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    struct mt_elem *slot = &t->table[pos];\n\n    if (slot->key == sym) {\n      t->size--;\n      slot->key = 0;\n      slot->func_p = 1;\n      return TRUE;\n    }\n    else if (slot_empty_p(slot)) {\n      return FALSE;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return FALSE;\n    }\n  }\n}\n\n/* Copy the method table. */\nstatic struct mt_tbl*\nmt_copy(mrb_state *mrb, mt_tbl *t)\n{\n  mt_tbl *t2;\n  size_t i;\n\n  if (t == NULL) return NULL;\n  if (t->alloc == 0) return NULL;\n  if (t->size == 0) return NULL;\n\n  t2 = mt_new(mrb);\n  for (i=0; i<t->alloc; i++) {\n    struct mt_elem *slot = &t->table[i];\n\n    if (slot->key) {\n      mt_put(mrb, t2, slot->key, slot->func_p, slot->noarg_p, slot->ptr);\n    }\n  }\n  return t2;\n}\n\n/* Free memory of the method table. */\nstatic void\nmt_free(mrb_state *mrb, mt_tbl *t)\n{\n  mrb_free(mrb, t->table);\n  mrb_free(mrb, t);\n}\n\nMRB_API void\nmrb_mt_foreach(mrb_state *mrb, struct RClass *c, mrb_mt_foreach_func *fn, void *p)\n{\n  mt_tbl *t = c->mt;\n  size_t i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  for (i=0; i<t->alloc; i++) {\n    struct mt_elem *slot = &t->table[i];\n\n    if (slot->key) {\n      mrb_method_t m;\n\n      if (slot->func_p) {\n        MRB_METHOD_FROM_FUNC(m, slot->ptr.func);\n      }\n      else {\n        MRB_METHOD_FROM_PROC(m, slot->ptr.proc);\n      }\n      if (slot->noarg_p) {\n        MRB_METHOD_NOARG_SET(m);\n      }\n\n      if (fn(mrb, slot->key, m, p) != 0)\n        return;\n    }\n  }\n  return;\n}\n\nvoid\nmrb_gc_mark_mt(mrb_state *mrb, struct RClass *c)\n{\n  mt_tbl *t = c->mt;\n  size_t i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  for (i=0; i<t->alloc; i++) {\n    struct mt_elem *slot = &t->table[i];\n\n    if (slot->key && !slot->func_p) { /* Proc pointer */\n      struct RProc *p = slot->ptr.proc;\n      mrb_gc_mark(mrb, (struct RBasic*)p);\n    }\n  }\n  return;\n}\n\nsize_t\nmrb_gc_mark_mt_size(mrb_state *mrb, struct RClass *c)\n{\n  struct mt_tbl *h = c->mt;\n\n  if (!h) return 0;\n  return h->size;\n}\n\nvoid\nmrb_gc_free_mt(mrb_state *mrb, struct RClass *c)\n{\n  if (c->mt) mt_free(mrb, c->mt);\n}\n\nvoid\nmrb_class_name_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_value name;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  if (mrb_obj_iv_defined(mrb, (struct RObject*)c, nsym)) return;\n  if (outer == NULL || outer == mrb->object_class) {\n    name = mrb_symbol_value(id);\n  }\n  else {\n    name = mrb_class_path(mrb, outer);\n    if (mrb_nil_p(name)) {      /* unnamed outer class */\n      if (outer != mrb->object_class && outer != c) {\n        mrb_obj_iv_set_force(mrb, (struct RObject*)c, MRB_SYM(__outer__),\n                             mrb_obj_value(outer));\n      }\n      return;\n    }\n    else {\n      mrb_int len;\n      const char *n = mrb_sym_name_len(mrb, id, &len);\n\n      mrb_str_cat_lit(mrb, name, \"::\");\n      mrb_str_cat(mrb, name, n, len);\n    }\n  }\n  mrb_obj_iv_set_force(mrb, (struct RObject*)c, nsym, name);\n}\n\nmrb_bool\nmrb_const_name_p(mrb_state *mrb, const char *name, mrb_int len)\n{\n  return len > 0 && ISUPPER(name[0]) && mrb_ident_p(name+1, len-1);\n}\n\nstatic void\nsetup_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_class_name_class(mrb, outer, c, id);\n  mrb_obj_iv_set(mrb, (struct RObject*)outer, id, mrb_obj_value(c));\n}\n\n#define make_metaclass(mrb, c) prepare_singleton_class((mrb), (struct RBasic*)(c))\n\nstatic void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}\n\nstatic mrb_value\nclass_name_str(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value path = mrb_class_path(mrb, c);\n  if (mrb_nil_p(path)) {\n    path = c->tt == MRB_TT_MODULE ? mrb_str_new_lit(mrb, \"#<Module:\") :\n                                    mrb_str_new_lit(mrb, \"#<Class:\");\n    mrb_str_cat_str(mrb, path, mrb_ptr_to_str(mrb, c));\n    mrb_str_cat_lit(mrb, path, \">\");\n  }\n  return path;\n}\n\nstatic struct RClass*\nclass_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}\n\nstatic struct RClass*\nmodule_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_MODULE);\n  return mrb_class_ptr(c);\n}\n\nstatic mrb_bool\nclass_ptr_p(mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n  case MRB_TT_CLASS:\n  case MRB_TT_SCLASS:\n  case MRB_TT_MODULE:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ncheck_if_class_or_module(mrb_state *mrb, mrb_value obj)\n{\n  if (!class_ptr_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class/module\", obj);\n  }\n}\n\nstatic struct RClass*\ndefine_module(mrb_state *mrb, mrb_sym name, struct RClass *outer)\n{\n  struct RClass *m;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    return module_from_sym(mrb, outer, name);\n  }\n  m = mrb_module_new(mrb);\n  setup_class(mrb, outer, m, name);\n\n  return m;\n}\n\nMRB_API struct RClass*\nmrb_define_module_id(mrb_state *mrb, mrb_sym name)\n{\n  return define_module(mrb, name, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_module(mrb_state *mrb, const char *name)\n{\n  return define_module(mrb, mrb_intern_cstr(mrb, name), mrb->object_class);\n}\n\nstruct RClass*\nmrb_vm_define_module(mrb_state *mrb, mrb_value outer, mrb_sym id)\n{\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_module_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a module\", old);\n    }\n    return mrb_class_ptr(old);\n  }\n  return define_module(mrb, id, mrb_class_ptr(outer));\n}\n\nMRB_API struct RClass*\nmrb_define_module_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  struct RClass * c = define_module(mrb, name, outer);\n\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c = define_module(mrb, id, outer);\n\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nstatic struct RClass*\nfind_origin(struct RClass *c)\n{\n  MRB_CLASS_ORIGIN(c);\n  return c;\n}\n\nstatic struct RClass*\ndefine_class(mrb_state *mrb, mrb_sym name, struct RClass *super, struct RClass *outer)\n{\n  struct RClass * c;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    c = class_from_sym(mrb, outer, name);\n    MRB_CLASS_ORIGIN(c);\n    if (super && mrb_class_real(c->super) != super) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for Class %n (%C not %C)\",\n                 name, c->super, super);\n    }\n    return c;\n  }\n\n  c = mrb_class_new(mrb, super);\n  setup_class(mrb, outer, c, name);\n\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_id(mrb_state *mrb, mrb_sym name, struct RClass *super)\n{\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%n', Object assumed\", name);\n  }\n  return define_class(mrb, name, super, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_class(mrb_state *mrb, const char *name, struct RClass *super)\n{\n  return mrb_define_class_id(mrb, mrb_intern_cstr(mrb, name), super);\n}\n\nstatic mrb_value mrb_bob_init(mrb_state *mrb, mrb_value);\n#ifndef MRB_NO_METHOD_CACHE\nstatic void mc_clear(mrb_state *mrb);\n#else\n#define mc_clear(mrb)\n#endif\n\nstatic void\nmrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FL_CLASS_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mrb_mc_clear_by_class(mrb, klass);\n  mid = MRB_SYM(inherited);\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_bob_init)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n\nstruct RClass*\nmrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (!mrb_class_p(super)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%!v given)\", super);\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_class_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class\", old);\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %v\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n\nMRB_API mrb_bool\nmrb_class_defined(mrb_state *mrb, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), name);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_class_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return class_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_class_get_under_id(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_exc_get_id(mrb_state *mrb, mrb_sym name)\n{\n  struct RClass *exc, *e;\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(mrb->object_class), name);\n\n  if (!mrb_class_p(c)) {\n    mrb_raise(mrb, mrb->eException_class, \"exception corrupted\");\n  }\n  exc = e = mrb_class_ptr(c);\n\n  while (e) {\n    if (e == mrb->eException_class)\n      return exc;\n    e = e->super;\n  }\n  return mrb->eException_class;\n}\n\nMRB_API struct RClass*\nmrb_module_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return module_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_module_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return module_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_module_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_module_get_under_id(mrb, mrb->object_class, name);\n}\n\n/*!\n * Defines a class under the namespace of \\a outer.\n * \\param outer  a class which contains the new class.\n * \\param name     name of the new class\n * \\param super  a class from which the new class will derive.\n *               NULL means \\c Object class.\n * \\return the created class\n * \\throw TypeError if the constant name \\a name is already taken but\n *                  the constant is not a \\c Class.\n * \\throw NameError if the class is already defined but the class can not\n *                  be reopened because its superclass is not \\a super.\n * \\post top-level constant named \\a name refers the returned class.\n *\n * \\note if a class named \\a name is already defined and its superclass is\n *       \\a super, the function just returns the defined class.\n */\nMRB_API struct RClass*\nmrb_define_class_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name, struct RClass *super)\n{\n  struct RClass * c;\n\n#if 0\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%C::%n', Object assumed\", outer, id);\n  }\n#endif\n  c = define_class(mrb, name, super, outer);\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super)\n{\n  return mrb_define_class_under_id(mrb, outer, mrb_intern_cstr(mrb, name), super);\n}\n\nMRB_API void\nmrb_define_method_raw(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_method_t m)\n{\n  mt_tbl *h;\n  union mt_ptr ptr;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  mrb_check_frozen(mrb, c);\n  if (!h) h = c->mt = mt_new(mrb);\n  if (MRB_METHOD_PROC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    ptr.proc = p;\n    if (p) {\n      if (p->color != MRB_GC_RED) {\n        p->flags |= MRB_PROC_SCOPE;\n        p->c = NULL;\n        mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)p);\n        if (!MRB_PROC_ENV_P(p)) {\n          MRB_PROC_SET_TARGET_CLASS(p, c);\n        }\n      }\n      else {\n        mrb_assert(MRB_FROZEN_P(p) && MRB_PROC_SCOPE_P(p));\n        mrb_assert(p->c == NULL && p->upper == NULL && p->e.target_class == NULL);\n      }\n    }\n  }\n  else {\n    ptr.func = MRB_METHOD_FUNC(m);\n  }\n  mt_put(mrb, h, mid, MRB_METHOD_FUNC_P(m), MRB_METHOD_NOARG_P(m), ptr);\n  mc_clear(mrb);\n}\n\nMRB_API void\nmrb_define_method_id(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_method_t m;\n  int ai = mrb_gc_arena_save(mrb);\n\n  MRB_METHOD_FROM_FUNC(m, func);\n#ifndef MRB_USE_METHOD_T_STRUCT\n  mrb_assert(MRB_METHOD_FUNC(m) == func);\n#endif\n  if (aspec == MRB_ARGS_NONE()) {\n    MRB_METHOD_NOARG_SET(m);\n  }\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_gc_arena_restore(mrb, ai);\n}\n\nMRB_API void\nmrb_define_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_method_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n/* a function to raise NotImplementedError with current method name */\nMRB_API void\nmrb_notimplement(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n\n  if (ci->mid) {\n    mrb_raisef(mrb, E_NOTIMP_ERROR, \"%n() function is unimplemented on this machine\", ci->mid);\n  }\n}\n\n/* a function to be replacement of unimplemented method */\nMRB_API mrb_value\nmrb_notimplement_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_notimplement(mrb);\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic void\nensure_class_type(mrb_state *mrb, mrb_value val)\n{\n  if (!class_ptr_p(val)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not class/module\", val);\n  }\n}\n\n#define to_sym(mrb, ss) mrb_obj_to_sym(mrb, ss)\n\nMRB_API mrb_int\nmrb_get_argc(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->ci->stack[1]);\n\n    argc = ARY_LEN(a);\n  }\n  return argc;\n}\n\nMRB_API const mrb_value*\nmrb_get_argv(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n  mrb_value *array_argv = mrb->c->ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    array_argv = ARY_PTR(a);\n  }\n  return array_argv;\n}\n\nMRB_API mrb_value\nmrb_get_arg1(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_int argc = ci->n;\n  mrb_value *array_argv = ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    argc = ARY_LEN(a);\n    array_argv = ARY_PTR(a);\n  }\n  if (argc == 0 && ci->nk == 15) {\n    mrb_int n = ci->n;\n    if (n == 15) n = 1;\n    return ci->stack[n+1];      /* kwhash next to positional arguments */\n  }\n  if (argc != 1) {\n    mrb_argnum_error(mrb, argc, 1, 1);\n  }\n  return array_argv[0];\n}\n\nmrb_int mrb_ci_bidx(mrb_callinfo *ci);\n\nMRB_API mrb_bool\nmrb_block_given_p(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_value b = ci->stack[mrb_ci_bidx(ci)];\n\n  return !mrb_nil_p(b);\n}\n\n/*\n  retrieve arguments from mrb_state.\n\n  mrb_get_args(mrb, format, ...)\n\n  returns number of arguments parsed.\n\n  format specifiers:\n\n    string  mruby type     C type                 note\n    ----------------------------------------------------------------------------------------------\n    o:      Object         [mrb_value]\n    C:      Class/Module   [mrb_value]            when ! follows, the value may be nil\n    S:      String         [mrb_value]            when ! follows, the value may be nil\n    A:      Array          [mrb_value]            when ! follows, the value may be nil\n    H:      Hash           [mrb_value]            when ! follows, the value may be nil\n    s:      String         [const char*,mrb_int]  Receive two arguments; s! gives (NULL,0) for nil\n    z:      String         [const char*]          NUL terminated string; z! gives NULL for nil\n    a:      Array          [const mrb_value*,mrb_int] Receive two arguments; a! gives (NULL,0) for nil\n    c:      Class/Module   [strcut RClass*]       c! gives NULL for nil\n    f:      Integer/Float  [mrb_float]\n    i:      Integer/Float  [mrb_int]\n    b:      boolean        [mrb_bool]\n    n:      String/Symbol  [mrb_sym]\n    d:      data           [void*,mrb_data_type const] 2nd argument will be used to check data type so it won't be modified; when ! follows, the value may be nil\n    I:      inline struct  [void*,struct RClass]  I! gives NULL for nil\n    &:      block          [mrb_value]            &! raises exception if no block given\n    *:      rest argument  [const mrb_value*,mrb_int] The rest of the arguments as an array; *! avoid copy of the stack\n    |:      optional                              Following arguments are optional\n    ?:      optional given [mrb_bool]             true if preceding argument (optional) is given\n    ':':    keyword args   [mrb_kwargs const]     Get keyword arguments\n\n  format modifiers:\n\n    string  note\n    ----------------------------------------------------------------------------------------------\n    !:      Switch to the alternate mode; The behaviour changes depending on the specifier\n    +:      Request a not frozen object; However, except nil value\n */\nMRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  const char *fmt = format;\n  char c;\n  int i = 0;\n  va_list ap;\n  mrb_callinfo *ci = mrb->c->ci;\n  int argc = ci->n;\n  const mrb_value *argv = ci->stack+1;\n  mrb_bool argv_on_stack;\n  mrb_bool opt = FALSE;\n  mrb_bool opt_skip = TRUE;\n  const mrb_value *pickarg = NULL; /* arguments currently being processed */\n  mrb_value kdict = mrb_nil_value();\n  mrb_bool reqkarg = FALSE;\n  int argc_min = 0, argc_max = 0;\n\n  va_start(ap, format);\n\n  while ((c = *fmt++)) {\n    switch (c) {\n    case '|':\n      opt = TRUE;\n      break;\n    case '*':\n      opt_skip = FALSE;\n      argc_max = -1;\n      if (!reqkarg) reqkarg = strchr(fmt, ':') ? TRUE : FALSE;\n      goto check_exit;\n    case '!':\n    case '+':\n      break;\n    case ':':\n      reqkarg = TRUE;\n      /* fall through */\n    case '&': case '?':\n      if (opt) opt_skip = FALSE;\n      break;\n    default:\n      if (!opt) argc_min++;\n      argc_max++;\n      break;\n    }\n  }\n\n check_exit:\n  if (!reqkarg && ci->nk > 0) {\n    mrb_assert(ci->nk == 15);\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    if (mrb_hash_p(kdict) && mrb_hash_size(mrb, kdict) > 0) {\n      if (argc < 14) {\n        ci->n++;\n        argc++;    /* include kdict in normal arguments */\n      }\n      else {\n        /* 14+1 == 15 so pack first */\n        if (argc == 14) {\n          /* pack arguments and kdict */\n          ci->stack[1] = mrb_ary_new_from_values(mrb, argc+1, &ci->stack[1]);\n          argc = ci->n = 15;\n        }\n        else {\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, ci->stack[1], kdict);\n        }\n        ci->stack[2] = ci->stack[mrb_ci_bidx(ci)];\n      }\n      ci->nk = 0;\n    }\n  }\n  if (reqkarg && ci->nk > 0) {\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    mrb_assert(ci->nk == 15);\n    mrb_assert(mrb_hash_p(kdict));\n  }\n\n  argv_on_stack = argc < 15;\n  if (!argv_on_stack) {\n    struct RArray *a = mrb_ary_ptr(*argv);\n    argv = ARY_PTR(a);\n    argc = ARY_LEN(a);\n  }\n\n  opt = FALSE;\n  i = 0;\n  while ((c = *format++)) {\n    mrb_bool altmode = FALSE;\n    mrb_bool needmodify = FALSE;\n\n    for (; *format; format++) {\n      switch (*format) {\n      case '!':\n        if (altmode) goto modifier_exit; /* not accept for multiple '!' */\n        altmode = TRUE;\n        break;\n      case '+':\n        if (needmodify) goto modifier_exit; /* not accept for multiple '+' */\n        needmodify = TRUE;\n        break;\n      default:\n        goto modifier_exit;\n      }\n    }\n\n  modifier_exit:\n    switch (c) {\n    case '|': case '*': case '&': case '?': case ':':\n      if (needmodify) {\n      bad_needmodify:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"wrong `%c+` modified specifier`\", c);\n      }\n      break;\n    default:\n      if (i < argc) {\n        pickarg = &argv[i++];\n        if (needmodify && !mrb_nil_p(*pickarg)) {\n          if (mrb_immediate_p(*pickarg)) {\n            mrb_raisef(mrb, E_FROZEN_ERROR, \"can't modify frozen %t\", *pickarg);\n          }\n          mrb_check_frozen(mrb, mrb_obj_ptr(*pickarg));\n        }\n      }\n      else {\n        if (opt) {\n          pickarg = NULL;\n        }\n        else {\n          mrb_argnum_error(mrb, argc, argc_min, argc_max);\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n    case 'C':\n    case 'S':\n    case 'A':\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (pickarg) {\n          if (!(altmode && mrb_nil_p(*pickarg))) {\n            switch (c) {\n            case 'C': ensure_class_type(mrb, *pickarg); break;\n            case 'S': mrb_ensure_string_type(mrb, *pickarg); break;\n            case 'A': mrb_ensure_array_type(mrb, *pickarg); break;\n            case 'H': mrb_ensure_hash_type(mrb, *pickarg); break;\n            }\n          }\n          *p = *pickarg;\n        }\n      }\n      break;\n    case 'c':\n      {\n        struct RClass **p;\n\n        p = va_arg(ap, struct RClass**);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            ensure_class_type(mrb, *pickarg);\n            *p = mrb_class_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n    case 's':\n      {\n        const char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, const char**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_PTR(*pickarg);\n            *pl = RSTRING_LEN(*pickarg);\n          }\n        }\n      }\n      break;\n    case 'z':\n      {\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_CSTR(mrb, *pickarg);\n          }\n        }\n      }\n      break;\n    case 'a':\n      {\n        struct RArray *a;\n        const mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *pb = 0;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_array_type(mrb, *pickarg);\n            a = mrb_ary_ptr(*pickarg);\n            *pb = ARY_PTR(a);\n            *pl = ARY_LEN(a);\n          }\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        struct RClass *klass;\n\n        p = va_arg(ap, void**);\n        klass = va_arg(ap, struct RClass*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            if (!mrb_obj_is_kind_of(mrb, *pickarg, klass)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not a %C\", *pickarg, klass);\n            }\n            if (!mrb_istruct_p(*pickarg)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not inline struct\", *pickarg);\n            }\n            *p = mrb_istruct_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n#ifndef MRB_NO_FLOAT\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (pickarg) {\n          *p = mrb_as_float(mrb, *pickarg);\n        }\n      }\n      break;\n#endif\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (pickarg) {\n          *p = mrb_as_int(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (pickarg) {\n          *boolp = mrb_test(*pickarg);\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (pickarg) {\n          *symp = to_sym(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *datap = 0;\n          }\n          else {\n            *datap = mrb_data_get_ptr(mrb, *pickarg, type);\n          }\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        bp = ci->stack + mrb_ci_bidx(ci);\n        if (altmode && mrb_nil_p(*bp)) {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      if (opt_skip && i == argc) goto finish;\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = pickarg ? TRUE : FALSE;\n      }\n      break;\n\n    case '*':\n      {\n        const mrb_value **var;\n        mrb_int *pl;\n        mrb_bool nocopy = (altmode || !argv_on_stack) ? TRUE : FALSE;\n\n        var = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            if (nocopy) {\n              *var = argv+i;\n            }\n            else {\n              mrb_value args = mrb_ary_new_from_values(mrb, *pl, argv+i);\n              RARRAY(args)->c = NULL;\n              *var = RARRAY_PTR(args);\n            }\n          }\n          i = argc;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n\n    case ':':\n      {\n        mrb_value ksrc = mrb_hash_p(kdict) ? mrb_hash_dup(mrb, kdict) : mrb_hash_new(mrb);\n        const mrb_kwargs *kwargs = va_arg(ap, const mrb_kwargs*);\n        mrb_value *rest;\n\n        if (kwargs == NULL) {\n          rest = NULL;\n        }\n        else {\n          uint32_t kwnum = kwargs->num;\n          uint32_t required = kwargs->required;\n          const mrb_sym *kname = kwargs->table;\n          mrb_value *values = kwargs->values;\n          uint32_t j;\n          const uint32_t keyword_max = 40;\n\n          if (kwnum > keyword_max || required > kwnum) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"keyword number is too large\");\n          }\n\n          for (j = required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (!mrb_hash_key_p(mrb, ksrc, k)) {\n              mrb_raisef(mrb, E_ARGUMENT_ERROR, \"missing keyword: %n\", *kname);\n            }\n            *values = mrb_hash_delete_key(mrb, ksrc, k);\n            mrb_gc_protect(mrb, *values);\n          }\n\n          for (j = kwnum - required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (mrb_hash_key_p(mrb, ksrc, k)) {\n              *values = mrb_hash_delete_key(mrb, ksrc, k);\n              mrb_gc_protect(mrb, *values);\n            }\n            else {\n              *values = mrb_undef_value();\n            }\n          }\n\n          rest = kwargs->rest;\n        }\n\n        if (rest) {\n          *rest = ksrc;\n        }\n        else if (!mrb_hash_empty_p(mrb, ksrc)) {\n          ksrc = mrb_hash_keys(mrb, ksrc);\n          ksrc = RARRAY_PTR(ksrc)[0];\n          mrb_raisef(mrb, E_ARGUMENT_ERROR, \"unknown keyword: %v\", ksrc);\n        }\n      }\n      break;\n\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %c\", c);\n      break;\n    }\n  }\n\n  if (!c && argc > i) {\n    mrb_argnum_error(mrb, argc, argc_min, argc_max);\n  }\n\nfinish:\n  va_end(ap);\n  return i;\n}\n\nstatic struct RClass*\nboot_defclass(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  c = MRB_OBJ_ALLOC(mrb, MRB_TT_CLASS, mrb->class_class);\n  if (super) {\n    c->super = super;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)super);\n  }\n  else {\n    c->super = mrb->object_class;\n  }\n  c->mt = mt_new(mrb);\n  return c;\n}\n\nstatic void\nboot_initmod(mrb_state *mrb, struct RClass *mod)\n{\n  if (!mod->mt) {\n    mod->mt = mt_new(mrb);\n  }\n}\n\nstatic struct RClass*\ninclude_class_new(mrb_state *mrb, struct RClass *m, struct RClass *super)\n{\n  struct RClass *ic = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, mrb->class_class);\n  if (m->tt == MRB_TT_ICLASS) {\n    m = m->c;\n  }\n  MRB_CLASS_ORIGIN(m);\n  ic->iv = m->iv;\n  ic->mt = m->mt;\n  ic->super = super;\n  if (m->tt == MRB_TT_ICLASS) {\n    ic->c = m->c;\n  }\n  else {\n    ic->c = m;\n  }\n  return ic;\n}\n\nstatic int\ninclude_module_at(mrb_state *mrb, struct RClass *c, struct RClass *ins_pos, struct RClass *m, int search_super)\n{\n  struct RClass *p, *ic;\n  void *klass_mt = find_origin(c)->mt;\n\n  while (m) {\n    int original_seen = FALSE;\n    int superclass_seen = FALSE;\n\n    if (c == ins_pos) original_seen = TRUE;\n    if (m->flags & MRB_FL_CLASS_IS_PREPENDED)\n      goto skip;\n\n    if (klass_mt && klass_mt == m->mt)\n      return -1;\n\n    p = c->super;\n    while (p) {\n      if (c == p) original_seen = TRUE;\n      if (p->tt == MRB_TT_ICLASS) {\n        if (p->mt == m->mt) {\n          if (!superclass_seen && original_seen) {\n            ins_pos = p; /* move insert point */\n          }\n          goto skip;\n        }\n      } else if (p->tt == MRB_TT_CLASS) {\n        if (!search_super) break;\n        superclass_seen = TRUE;\n      }\n      p = p->super;\n    }\n\n    ic = include_class_new(mrb, m, ins_pos->super);\n    m->flags |= MRB_FL_CLASS_IS_INHERITED;\n    ins_pos->super = ic;\n    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);\n    ins_pos = ic;\n  skip:\n    m = m->super;\n  }\n  mc_clear(mrb);\n  return 0;\n}\n\nstatic int\nfix_include_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n\n  if (obj->tt == MRB_TT_ICLASS && obj->c == m[0] && !MRB_FLAG_TEST(obj, MRB_FL_CLASS_IS_ORIGIN)) {\n    struct RClass *ic = (struct RClass*)obj;\n    include_module_at(mrb, ic, ic, m[1], 1);\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  mrb_check_frozen(mrb, c);\n  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_include_module, data);\n  }\n}\n\nstatic int\nfix_prepend_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n  struct RClass *c = (struct RClass*)obj;\n\n  if (c->tt == MRB_TT_CLASS || c->tt == MRB_TT_MODULE) {\n    struct RClass *p = c->super;\n    struct RClass *ins_pos = c;\n    while (p) {\n      if (c == m[0]) break;\n      if (p == m[0]->super->c) {\n        ins_pos = c;\n      }\n      if (p->tt == MRB_TT_CLASS) break;\n      if (p->c == m[0]) {\n        include_module_at(mrb, ins_pos, ins_pos, m[1], 0);\n        break;\n      }\n      c = p;\n      p = p->super;\n    }\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_prepend_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  struct RClass *origin;\n\n  mrb_check_frozen(mrb, c);\n  if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n    struct RClass *c0;\n\n    if (c->tt == MRB_TT_ICLASS) {\n      c0 = c->c;\n    }\n    else {\n      c0 = c;\n    }\n    origin = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, c0);\n    origin->flags |= MRB_FL_CLASS_IS_ORIGIN | MRB_FL_CLASS_IS_INHERITED;\n    origin->super = c->super;\n    c->super = origin;\n    origin->mt = c->mt;\n    c->mt = NULL;\n    origin->iv = c->iv;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)origin);\n    c->flags |= MRB_FL_CLASS_IS_PREPENDED;\n  }\n  if (include_module_at(mrb, c, c, m, 0) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic prepend detected\");\n  }\n  if (c->tt == MRB_TT_MODULE &&\n      (c->flags & (MRB_FL_CLASS_IS_INHERITED|MRB_FL_CLASS_IS_PREPENDED))) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_prepend_module, data);\n  }\n}\n\nstatic mrb_value\nmrb_mod_prepend_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_prepend_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_append_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_include_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\n/* 15.2.2.4.28 */\n/*\n *  call-seq:\n *     mod.include?(module)    -> true or false\n *\n *  Returns <code>true</code> if <i>module</i> is included in\n *  <i>mod</i> or one of <i>mod</i>'s ancestors.\n *\n *     module A\n *     end\n *     class B\n *       include A\n *     end\n *     class C < B\n *     end\n *     B.include?(A)   #=> true\n *     C.include?(A)   #=> true\n *     A.include?(A)   #=> false\n */\nstatic mrb_value\nmrb_mod_include_p(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value mod2;\n  struct RClass *c = mrb_class_ptr(mod);\n\n  mrb_get_args(mrb, \"C\", &mod2);\n  mrb_check_type(mrb, mod2, MRB_TT_MODULE);\n\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      if (c->c == mrb_class_ptr(mod2)) return mrb_true_value();\n    }\n    c = c->super;\n  }\n  return mrb_false_value();\n}\n\nstatic mrb_value\nmrb_mod_ancestors(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n    }\n    else if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c));\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_extend_object(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_include_module(mrb, mrb_class_ptr(mrb_singleton_class(mrb, obj)), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_initialize(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value b;\n  struct RClass *m = mrb_class_ptr(mod);\n  boot_initmod(mrb, m); /* bootstrap a newly initialized module */\n  mrb_get_args(mrb, \"|&\", &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &mod, mod, m);\n  }\n  return mod;\n}\n\n/* implementation of module_eval/class_eval */\nmrb_value mrb_mod_module_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\nmrb_mod_dummy_visibility(mrb_state *mrb, mrb_value mod)\n{\n  return mod;\n}\n\n/* returns mrb_class_ptr(mrb_singleton_class()) */\n/* except that it return NULL for immediate values */\nMRB_API struct RClass*\nmrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}\n\nMRB_API mrb_value\nmrb_singleton_class(mrb_state *mrb, mrb_value v)\n{\n  struct RClass *c = mrb_singleton_class_ptr(mrb, v);\n\n  if (c == NULL) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't define singleton\");\n  }\n  return mrb_obj_value(c);\n}\n\nMRB_API void\nmrb_define_singleton_method(mrb_state *mrb, struct RObject *o, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\nMRB_API void\nmrb_define_singleton_method_id(mrb_state *mrb, struct RObject *o, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method_id(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_class_method_id(mrb, c, name, func, aspec);\n  mrb_define_method_id(mrb, c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_module_function_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n#ifndef MRB_NO_METHOD_CACHE\nstatic void\nmc_clear(mrb_state *mrb)\n{\n  static const struct mrb_cache_entry ce_zero ={0};\n\n  for (int i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mrb->cache[i] = ce_zero;\n  }\n}\n\nvoid\nmrb_mc_clear_by_class(mrb_state *mrb, struct RClass *c)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FL_CLASS_IS_INHERITED) {\n    mc_clear(mrb);\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c) mc[i].c = 0;\n  }\n}\n#endif\n\nMRB_API mrb_method_t\nmrb_method_search_vm(mrb_state *mrb, struct RClass **cp, mrb_sym mid)\n{\n  mrb_method_t m;\n  struct RClass *c = *cp;\n#ifndef MRB_NO_METHOD_CACHE\n  struct RClass *oc = c;\n  int h = kh_int_hash_func(mrb, ((intptr_t)oc) ^ mid) & (MRB_METHOD_CACHE_SIZE-1);\n  struct mrb_cache_entry *mc = &mrb->cache[h];\n\n  if (mc->c == c && mc->mid == mid) {\n    *cp = mc->c0;\n    return mc->m;\n  }\n#endif\n\n  while (c) {\n    mt_tbl *h = c->mt;\n\n    if (h) {\n      struct mt_elem *e = mt_get(mrb, h, mid);\n      if (e) {\n        if (e->ptr.proc == 0) break;\n        *cp = c;\n        if (e->func_p) {\n          MRB_METHOD_FROM_FUNC(m, e->ptr.func);\n        }\n        else {\n          MRB_METHOD_FROM_PROC(m, e->ptr.proc);\n        }\n        if (e->noarg_p) {\n          MRB_METHOD_NOARG_SET(m);\n        }\n#ifndef MRB_NO_METHOD_CACHE\n        mc->c = oc;\n        mc->c0 = c;\n        mc->mid = mid;\n        mc->m = m;\n#endif\n        return m;\n      }\n    }\n    c = c->super;\n  }\n  MRB_METHOD_FROM_PROC(m, NULL);\n  return m;                  /* no method */\n}\n\nMRB_API mrb_method_t\nmrb_method_search(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    mrb_name_error(mrb, mid, \"undefined method '%n' for class %C\", mid, c);\n  }\n  return m;\n}\n\n#define ONSTACK_ALLOC_MAX 32\n\nstatic mrb_sym\nprepare_name_common(mrb_state *mrb, mrb_sym sym, const char *prefix, const char *suffix)\n{\n  char onstack[ONSTACK_ALLOC_MAX];\n  mrb_int sym_len;\n  const char *sym_str = mrb_sym_name_len(mrb, sym, &sym_len);\n  size_t prefix_len = prefix ? strlen(prefix) : 0;\n  size_t suffix_len = suffix ? strlen(suffix) : 0;\n  size_t name_len = sym_len + prefix_len + suffix_len;\n  char *buf = name_len > sizeof(onstack) ? (char *)mrb_alloca(mrb, name_len) : onstack;\n  char *p = buf;\n\n  if (prefix_len > 0) {\n    memcpy(p, prefix, prefix_len);\n    p += prefix_len;\n  }\n\n  memcpy(p, sym_str, sym_len);\n  p += sym_len;\n\n  if (suffix_len > 0) {\n    memcpy(p, suffix, suffix_len);\n    p += suffix_len;\n  }\n\n  return mrb_intern(mrb, buf, name_len);\n}\n\nstatic mrb_value\nprepare_ivar_name(mrb_state *mrb, mrb_sym sym)\n{\n  sym = prepare_name_common(mrb, sym, \"@\", NULL);\n  mrb_iv_name_sym_check(mrb, sym);\n  return mrb_symbol_value(sym);\n}\n\nstatic mrb_sym\nprepare_writer_name(mrb_state *mrb, mrb_sym sym)\n{\n  return prepare_name_common(mrb, sym, NULL, \"=\");\n}\n\nstatic mrb_value\nmod_attr_define(mrb_state *mrb, mrb_value mod, mrb_value (*accessor)(mrb_state *, mrb_value), mrb_sym (*access_name)(mrb_state *, mrb_sym))\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  const mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name;\n    mrb_sym method;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n    name = prepare_ivar_name(mrb, method);\n    if (access_name) {\n      method = access_name(mrb, method);\n    }\n\n    p = mrb_proc_new_cfunc_with_env(mrb, accessor, 1, &name);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nattr_reader(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  return mrb_iv_get(mrb, obj, to_sym(mrb, name));\n}\n\nstatic mrb_value\nmrb_mod_attr_reader(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_reader, NULL);\n}\n\nstatic mrb_value\nattr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val = mrb_get_arg1(mrb);\n\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_attr_writer(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_writer, prepare_writer_name);\n}\n\nstatic mrb_value\nmrb_instance_alloc(mrb_state *mrb, mrb_value cv)\n{\n  struct RClass *c = mrb_class_ptr(cv);\n  struct RObject *o;\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n\n  if (c->tt == MRB_TT_SCLASS)\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't create instance of singleton class\");\n\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  if (ttype <= MRB_TT_CPTR) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't create instance of %v\", cv);\n  }\n  o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);\n  return mrb_obj_value(o);\n}\n\n/*\n *  call-seq:\n *     class.new(args, ...)    ->  obj\n *\n *  Creates a new object of <i>class</i>'s class, then\n *  invokes that object's <code>initialize</code> method,\n *  passing it <i>args</i>. This is the method that ends\n *  up getting called whenever an object is constructed using\n *  `.new`.\n *\n */\n\nmrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_bob_init)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_obj_new(mrb_state *mrb, struct RClass *c, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value obj;\n  mrb_sym mid;\n\n  obj = mrb_instance_alloc(mrb, mrb_obj_value(c));\n  mid = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, mid, mrb_bob_init)) {\n    mrb_funcall_argv(mrb, obj, mid, argc, argv);\n  }\n  return obj;\n}\n\nstatic mrb_value\nmrb_class_initialize(mrb_state *mrb, mrb_value c)\n{\n  mrb_value a, b;\n\n  mrb_get_args(mrb, \"|C&\", &a, &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &c, c, mrb_class_ptr(c));\n  }\n  return c;\n}\n\nstatic mrb_value\nmrb_class_new_class(mrb_state *mrb, mrb_value cv)\n{\n  mrb_int n;\n  mrb_value super, blk;\n  mrb_value new_class;\n  mrb_sym mid;\n\n  n = mrb_get_args(mrb, \"|C&\", &super, &blk);\n  if (n == 0) {\n    super = mrb_obj_value(mrb->object_class);\n  }\n  new_class = mrb_obj_value(mrb_class_new(mrb, mrb_class_ptr(super)));\n  mid = MRB_SYM(initialize);\n  if (mrb_func_basic_p(mrb, new_class, mid, mrb_class_initialize)) {\n    mrb_class_initialize(mrb, new_class);\n  }\n  else {\n    mrb_funcall_with_block(mrb, new_class, mid, n, &super, blk);\n  }\n  mrb_class_inherited(mrb, mrb_class_ptr(super), mrb_class_ptr(new_class));\n  return new_class;\n}\n\nstatic mrb_value\nmrb_class_superclass(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c;\n\n  c = mrb_class_ptr(klass);\n  c = find_origin(c)->super;\n  while (c && c->tt == MRB_TT_ICLASS) {\n    c = find_origin(c)->super;\n  }\n  if (!c) return mrb_nil_value();\n  return mrb_obj_value(c);\n}\n\nstatic mrb_value\nmrb_bob_init(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n\n/* 15.3.1.3.1  */\n/* 15.3.1.3.10 */\n/* 15.3.1.3.11 */\n/*\n *  call-seq:\n *     obj == other        -> true or false\n *     obj.equal?(other)   -> true or false\n *     obj.eql?(other)     -> true or false\n *\n *  Equality---At the <code>Object</code> level, <code>==</code> returns\n *  <code>true</code> only if <i>obj</i> and <i>other</i> are the\n *  same object. Typically, this method is overridden in descendant\n *  classes to provide class-specific meaning.\n *\n *  Unlike <code>==</code>, the <code>equal?</code> method should never be\n *  overridden by subclasses: it is used to determine object identity\n *  (that is, <code>a.equal?(b)</code> iff <code>a</code> is the same\n *  object as <code>b</code>).\n *\n *  The <code>eql?</code> method returns <code>true</code> if\n *  <i>obj</i> and <i>anObject</i> have the same value. Used by\n *  <code>Hash</code> to test members for equality.  For objects of\n *  class <code>Object</code>, <code>eql?</code> is synonymous with\n *  <code>==</code>. Subclasses normally continue this tradition, but\n *  there are exceptions. <code>Numeric</code> types, for example,\n *  perform type conversion across <code>==</code>, but not across\n *  <code>eql?</code>, so:\n *\n *     1 == 1.0     #=> true\n *     1.eql? 1.0   #=> false\n */\nmrb_value\nmrb_obj_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg = mrb_get_arg1(mrb);\n\n  return mrb_bool_value(mrb_obj_equal(mrb, self, arg));\n}\n\nMRB_API mrb_bool\nmrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\nMRB_API mrb_bool\nmrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid)\n{\n  return mrb_obj_respond_to(mrb, mrb_class(mrb, obj), mid);\n}\n\nMRB_API mrb_value\nmrb_class_path(mrb_state *mrb, struct RClass *c)\n{\n  mrb_value path;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  path = mrb_obj_iv_get(mrb, (struct RObject*)c, nsym);\n  if (mrb_nil_p(path)) {\n    /* no name (yet) */\n    return mrb_class_find_path(mrb, c);\n  }\n  else if (mrb_symbol_p(path)) {\n    /* toplevel class/module */\n    return mrb_sym_str(mrb, mrb_symbol(path));\n  }\n  return mrb_str_dup(mrb, path);\n}\n\nMRB_API struct RClass*\nmrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}\n\nMRB_API const char*\nmrb_class_name(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value name;\n\n  if (c == NULL) return NULL;\n  name = class_name_str(mrb, c);\n  return RSTRING_PTR(name);\n}\n\nMRB_API const char*\nmrb_obj_classname(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_name(mrb, mrb_obj_class(mrb, obj));\n}\n\n/*!\n * Ensures a class can be derived from super.\n *\n * \\param super a reference to an object.\n * \\exception TypeError if \\a super is not a Class or \\a super is a singleton class.\n */\nstatic void\nmrb_check_inheritable(mrb_state *mrb, struct RClass *super)\n{\n  if (super->tt != MRB_TT_CLASS) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%C given)\", super);\n  }\n  if (super->tt == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of singleton class\");\n  }\n  if (super == mrb->class_class) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of Class\");\n  }\n}\n\n/*!\n * Creates a new class.\n * \\param super     a class from which the new class derives.\n * \\exception TypeError \\a super is not inheritable.\n * \\exception TypeError \\a super is the Class class.\n */\nMRB_API struct RClass*\nmrb_class_new(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  if (super) {\n    mrb_check_inheritable(mrb, super);\n  }\n  c = boot_defclass(mrb, super);\n  if (super) {\n    MRB_SET_INSTANCE_TT(c, MRB_INSTANCE_TT(super));\n  }\n  make_metaclass(mrb, c);\n\n  return c;\n}\n\n/*!\n * Creates a new module.\n */\nMRB_API struct RClass*\nmrb_module_new(mrb_state *mrb)\n{\n  struct RClass *m = MRB_OBJ_ALLOC(mrb, MRB_TT_MODULE, mrb->module_class);\n  boot_initmod(mrb, m);\n  return m;\n}\n\n/*\n *  call-seq:\n *     obj.class    => class\n *\n *  Returns the class of <i>obj</i>, now preferred over\n *  <code>Object#type</code>, as an object's type in Ruby is only\n *  loosely tied to that object's class. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Integer\n *     self.class   #=> Object\n */\n\nMRB_API struct RClass*\nmrb_obj_class(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_real(mrb_class(mrb, obj));\n}\n\nMRB_API void\nmrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  if (a == b) return;\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  if (!MRB_METHOD_CFUNC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    if (MRB_PROC_ENV_P(p)) {\n      MRB_PROC_ENV(p)->mid = b;\n    }\n    else if (p->color != MRB_GC_RED) {\n      struct RClass *tc = MRB_PROC_TARGET_CLASS(p);\n      struct REnv *e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n\n      e->mid = b;\n      if (tc) {\n        e->c = tc;\n        mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n      }\n      p->e.env = e;\n      p->flags |= MRB_PROC_ENVSET;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n    }\n  }\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\n/*!\n * Defines an alias of a method.\n * \\param mrb    the mruby state\n * \\param klass  the class which the original method belongs to\n * \\param name1  a new name for the method\n * \\param name2  the original name of the method\n */\nMRB_API void\nmrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2)\n{\n  mrb_alias_method(mrb, klass, mrb_intern_cstr(mrb, name1), mrb_intern_cstr(mrb, name2));\n}\n\nMRB_API void\nmrb_define_alias_id(mrb_state *mrb, struct RClass *klass, mrb_sym a, mrb_sym b)\n{\n  mrb_alias_method(mrb, klass, a, b);\n}\n\n/*\n * call-seq:\n *   mod.to_s   -> string\n *\n * Return a string representing this module or class. For basic\n * classes and modules, this is the name. For singletons, we\n * show information on the thing we're attached to as well.\n */\n\nmrb_value\nmrb_mod_to_s(mrb_state *mrb, mrb_value klass)\n{\n  if (mrb_sclass_p(klass)) {\n    mrb_value v = mrb_iv_get(mrb, klass, MRB_SYM(__attached__));\n    mrb_value str = mrb_str_new_lit(mrb, \"#<Class:\");\n\n    if (class_ptr_p(v)) {\n      mrb_str_cat_str(mrb, str, mrb_inspect(mrb, v));\n    }\n    else {\n      mrb_str_cat_str(mrb, str, mrb_any_to_s(mrb, v));\n    }\n    return mrb_str_cat_lit(mrb, str, \">\");\n  }\n  else {\n    return class_name_str(mrb, mrb_class_ptr(klass));\n  }\n}\n\nvoid mrb_method_added(mrb_state *mrb, struct RClass *c, mrb_sym mid);\n\nstatic mrb_value\nmrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  mrb_method_added(mrb, c, new_name);\n  return mod;\n}\n\nstatic void\nundef_method(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  mrb_method_t m;\n\n  MRB_METHOD_FROM_PROC(m, NULL);\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\nMRB_API void\nmrb_undef_method_id(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  if (!mrb_obj_respond_to(mrb, c, a)) {\n    mrb_name_error(mrb, a, \"undefined method '%n' for class '%C'\", a, c);\n  }\n  undef_method(mrb, c, a);\n}\n\nMRB_API void\nmrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API void\nmrb_undef_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name)\n{\n  mrb_undef_method_id(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_undef_class_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  mrb_undef_method(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}\n\nstatic mrb_value\nmrb_mod_undef(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_int argc;\n  const mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    mrb_undef_method_id(mrb, c, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mrb_nil_value();\n}\n\nstatic void\ncheck_const_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  mrb_int len;\n  const char *name = mrb_sym_name_len(mrb, id, &len);\n  if (!mrb_const_name_p(mrb, name, len)) {\n    mrb_name_error(mrb, id, \"wrong constant name %n\", id);\n  }\n}\n\nstatic mrb_value\nmrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  if (inherit) {\n    return mrb_bool_value(mrb_const_defined(mrb, mod, id));\n  }\n  return mrb_bool_value(mrb_const_defined_at(mrb, mod, id));\n}\n\nstatic mrb_value\nmrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}\n\nstatic mrb_value\nmrb_mod_const_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value path = mrb_get_arg1(mrb);\n  mrb_sym id;\n  char *ptr;\n  mrb_int off, end, len;\n\n  if (mrb_symbol_p(path)) {\n    /* const get with symbol */\n    id = mrb_symbol(path);\n    return mrb_const_get_sym(mrb, mod, id);\n  }\n\n  /* const get with class path string */\n  mrb_ensure_string_type(mrb, path);\n  ptr = RSTRING_PTR(path);\n  len = RSTRING_LEN(path);\n  off = 0;\n\n  while (off < len) {\n    end = mrb_str_index_lit(mrb, path, \"::\", off);\n    end = (end == -1) ? len : end;\n    id = mrb_intern(mrb, ptr+off, end-off);\n    mod = mrb_const_get_sym(mrb, mod, id);\n    if (end == len)\n      off = end;\n    else {\n      off = end + 2;\n      if (off == len) {         /* trailing \"::\" */\n        mrb_name_error(mrb, id, \"wrong constant name '%v'\", path);\n      }\n    }\n  }\n\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_const_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value value;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_const_name_sym(mrb, id);\n  mrb_const_set(mrb, mod, id, value);\n  return value;\n}\n\nstatic mrb_value\nmrb_mod_remove_const(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_const_name_sym(mrb, id);\n  val = mrb_iv_remove(mrb, mod, id);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, id, \"constant %n not defined\", id);\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_const_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb->c->ci->mid = 0;\n\n  if (mrb_class_real(mrb_class_ptr(mod)) != mrb->object_class) {\n    mrb_name_error(mrb, sym, \"uninitialized constant %v::%n\", mod, sym);\n  }\n  else {\n    mrb_name_error(mrb, sym, \"uninitialized constant %n\", sym);\n  }\n  /* not reached */\n  return mrb_nil_value();\n}\n\n/* 15.2.2.4.34 */\n/*\n *  call-seq:\n *     mod.method_defined?(symbol)    -> true or false\n *\n *  Returns +true+ if the named method is defined by\n *  _mod_ (or its included modules and, if _mod_ is a class,\n *  its ancestors). Public and protected methods are matched.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       include A\n *       def method3()  end\n *     end\n *\n *     A.method_defined? :method1    #=> true\n *     C.method_defined? \"method1\"   #=> true\n *     C.method_defined? \"method2\"   #=> true\n *     C.method_defined? \"method3\"   #=> true\n *     C.method_defined? \"method4\"   #=> false\n */\n\nstatic mrb_value\nmrb_mod_method_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  return mrb_bool_value(mrb_obj_respond_to(mrb, mrb_class_ptr(mod), id));\n}\n\nvoid\nmrb_method_added(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mrb_sym added;\n  mrb_value recv = mrb_obj_value(c);\n\n  if (c->tt == MRB_TT_SCLASS) {\n    added = MRB_SYM(singleton_method_added);\n    recv = mrb_iv_get(mrb, recv, MRB_SYM(__attached__));\n  }\n  else {\n    added = MRB_SYM(method_added);\n  }\n  mrb_funcall_id(mrb, recv, added, 1, mrb_symbol_value(mid));\n}\n\nmrb_value\nmrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\nmod_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb_class_ptr(self));\n}\n\nstatic mrb_value\ntop_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb->object_class);\n}\n\nstatic mrb_value\nmrb_mod_eqq(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_bool eqq;\n\n  eqq = mrb_obj_is_kind_of(mrb, obj, mrb_class_ptr(mod));\n\n  return mrb_bool_value(eqq);\n}\n\nstatic mrb_value\nmrb_mod_dup(mrb_state *mrb, mrb_value self)\n{\n  mrb_value mod = mrb_obj_clone(mrb, self);\n  MRB_UNSET_FROZEN_FLAG(mrb_obj_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_module_function(mrb_state *mrb, mrb_value mod)\n{\n  const mrb_value *argv;\n  mrb_int argc, i;\n  mrb_sym mid;\n  mrb_method_t m;\n  struct RClass *rclass;\n  int ai;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  if (argc == 0) {\n    /* set MODFUNC SCOPE if implemented */\n    return mod;\n  }\n\n  /* set PRIVATE method visibility if implemented */\n  /* mrb_mod_dummy_visibility(mrb, mod); */\n\n  for (i=0; i<argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_SYMBOL);\n\n    mid = mrb_symbol(argv[i]);\n    rclass = mrb_class_ptr(mod);\n    m = mrb_method_search(mrb, rclass, mid);\n\n    prepare_singleton_class(mrb, (struct RBasic*)rclass);\n    ai = mrb_gc_arena_save(mrb);\n    mrb_define_method_raw(mrb, rclass->c, mid, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n\n  return mod;\n}\n\nstatic struct RClass*\nmrb_singleton_class_clone(mrb_state *mrb, mrb_value obj)\n{\n  struct RClass *klass = mrb_basic_ptr(obj)->c;\n\n  if (klass->tt != MRB_TT_SCLASS)\n    return klass;\n  else {\n    /* copy singleton(unnamed) class */\n    struct RClass *clone = (struct RClass*)mrb_obj_alloc(mrb, klass->tt, mrb->class_class);\n\n    switch (mrb_type(obj)) {\n    case MRB_TT_CLASS:\n    case MRB_TT_SCLASS:\n      break;\n    default:\n      clone->c = mrb_singleton_class_clone(mrb, mrb_obj_value(klass));\n      break;\n    }\n    clone->super = klass->super;\n    if (klass->iv) {\n      mrb_iv_copy(mrb, mrb_obj_value(clone), mrb_obj_value(klass));\n      mrb_obj_iv_set(mrb, (struct RObject*)clone, MRB_SYM(__attached__), obj);\n    }\n    if (klass->mt) {\n      clone->mt = mt_copy(mrb, klass->mt);\n    }\n    else {\n      clone->mt = mt_new(mrb);\n    }\n    clone->tt = MRB_TT_SCLASS;\n    return clone;\n  }\n}\n\nstatic void\ncopy_class(mrb_state *mrb, mrb_value dst, mrb_value src)\n{\n  struct RClass *dc = mrb_class_ptr(dst);\n  struct RClass *sc = mrb_class_ptr(src);\n  /* if the origin is not the same as the class, then the origin and\n     the current class need to be copied */\n  if (sc->flags & MRB_FL_CLASS_IS_PREPENDED) {\n    struct RClass *c0 = sc->super;\n    struct RClass *c1 = dc;\n\n    /* copy prepended iclasses */\n    while (!(c0->flags & MRB_FL_CLASS_IS_ORIGIN)) {\n      c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n      c1 = c1->super;\n      c0 = c0->super;\n    }\n    c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n    c1->super->flags |= MRB_FL_CLASS_IS_ORIGIN;\n  }\n  if (sc->mt) {\n    dc->mt = mt_copy(mrb, sc->mt);\n  }\n  else {\n    dc->mt = mt_new(mrb);\n  }\n  dc->super = sc->super;\n  MRB_SET_INSTANCE_TT(dc, MRB_INSTANCE_TT(sc));\n}\n\n/* 15.3.1.3.16 */\nstatic mrb_value\nmrb_obj_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value orig = mrb_get_arg1(mrb);\n\n  if (mrb_obj_equal(mrb, self, orig)) return self;\n  if ((mrb_type(self) != mrb_type(orig)) || (mrb_obj_class(mrb, self) != mrb_obj_class(mrb, orig))) {\n      mrb_raise(mrb, E_TYPE_ERROR, \"initialize_copy should take same class object\");\n  }\n  return self;\n}\n\nstatic void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, MRB_SYM(__classname__));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  if (!mrb_func_basic_p(mrb, dest, MRB_SYM(initialize_copy), mrb_obj_init_copy)) {\n    mrb_funcall_id(mrb, dest, MRB_SYM(initialize_copy), 1, obj);\n  }\n}\n\n/* 15.3.1.3.8  */\n/*\n *  call-seq:\n *     obj.clone -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference. Copies\n *  the frozen state of <i>obj</i>. See also the discussion\n *  under <code>Object#dup</code>.\n *\n *     class Klass\n *        attr_accessor :str\n *     end\n *     s1 = Klass.new      #=> #<Klass:0x401b3a38>\n *     s1.str = \"Hello\"    #=> \"Hello\"\n *     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n *     s2.str[1,4] = \"i\"   #=> \"i\"\n *     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n *     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n *\n *  Some Class(True False Nil Symbol Integer Float) Object  cannot clone.\n */\nMRB_API mrb_value\nmrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    return self;\n  }\n  if (mrb_sclass_p(self)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FL_OBJ_IS_FROZEN;\n\n  return clone;\n}\n\n/* 15.3.1.3.9  */\n/*\n *  call-seq:\n *     obj.dup -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference.\n *  <code>dup</code> copies the frozen state of <i>obj</i>. See also\n *  the discussion under <code>Object#clone</code>. In general,\n *  <code>clone</code> and <code>dup</code> may have different semantics\n *  in descendant classes. While <code>clone</code> is used to duplicate\n *  an object, including its internal state, <code>dup</code> typically\n *  uses the class of the descendant object to create the new instance.\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n */\n\nMRB_API mrb_value\nmrb_obj_dup(mrb_state *mrb, mrb_value obj)\n{\n  struct RBasic *p;\n  mrb_value dup;\n\n  if (mrb_immediate_p(obj)) {\n    return obj;\n  }\n  if (mrb_sclass_p(obj)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't dup singleton class\");\n  }\n  p = mrb_obj_alloc(mrb, mrb_type(obj), mrb_obj_class(mrb, obj));\n  dup = mrb_obj_value(p);\n  init_copy(mrb, dup, obj);\n\n  return dup;\n}\n\n/* implementation of __id__ */\nmrb_value mrb_obj_id_m(mrb_state *mrb, mrb_value self);\n/* implementation of instance_eval */\nmrb_value mrb_obj_instance_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\ninspect_main(mrb_state *mrb, mrb_value mod)\n{\n  return mrb_str_new_lit(mrb, \"main\");\n}\n\nstatic const mrb_code new_iseq[] = {\n  OP_ENTER, 0x0, 0x10, 0x3,  // OP_ENTER     0:0:1:0:0:1:1\n  OP_LOADSELF, 4,            // OP_LOADSELF  R4\n  OP_SEND, 4, 0, 0,          // OP_SEND      R4  :allocate  n=0\n  OP_MOVE, 0, 4,             // OP_MOVE      R0  R4\n  OP_MOVE, 4, 3,             // OP_MOVE      R4  R3 (&)\n  OP_MOVE, 3, 2,             // OP_MOVE      R3  R2 (**)\n  OP_MOVE, 2, 1,             // OP_MOVE      R2  R1 (*)\n  OP_SSENDB, 1, 1, 255,      // OP_SSENDB    R1  :initialize n=*|nk=*\n  OP_RETURN, 0               // OP_RETURN    R0\n};\n\nMRB_PRESYM_DEFINE_VAR_AND_INITER(new_syms, 2, MRB_SYM(allocate), MRB_SYM(initialize))\n\nstatic const mrb_irep new_irep = {\n  4, 5, 0, MRB_IREP_STATIC,\n  new_iseq, NULL, new_syms, NULL, NULL, NULL,\n  sizeof(new_iseq), 0, 2, 0, 0,\n};\n\nstatic const struct RProc new_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &new_irep }, NULL, { NULL }\n};\n\nstatic void\ninit_class_new(mrb_state *mrb, struct RClass *cls)\n{\n  mrb_method_t m;\n\n  MRB_PRESYM_INIT_SYMBOLS(mrb, new_syms);\n  MRB_METHOD_FROM_PROC(m, &new_proc);\n  mrb_define_method_raw(mrb, cls, MRB_SYM(new), m);\n}\n\n/* implementation of #send method */\nmrb_value mrb_f_send(mrb_state *mrb, mrb_value self);\n\nvoid\nmrb_init_class(mrb_state *mrb)\n{\n  struct RClass *bob;           /* BasicObject */\n  struct RClass *obj;           /* Object */\n  struct RClass *mod;           /* Module */\n  struct RClass *cls;           /* Class */\n\n  /* boot class hierarchy */\n  bob = boot_defclass(mrb, 0);\n  obj = boot_defclass(mrb, bob); mrb->object_class = obj;\n  mod = boot_defclass(mrb, obj); mrb->module_class = mod;/* obj -> mod */\n  cls = boot_defclass(mrb, mod); mrb->class_class = cls; /* obj -> cls */\n  /* fix-up loose ends */\n  bob->c = obj->c = mod->c = cls->c = cls;\n  make_metaclass(mrb, bob);\n  make_metaclass(mrb, obj);\n  make_metaclass(mrb, mod);\n  make_metaclass(mrb, cls);\n\n  /* name basic classes */\n  mrb_define_const_id(mrb, bob, MRB_SYM(BasicObject), mrb_obj_value(bob));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Object),      mrb_obj_value(obj));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Module),      mrb_obj_value(mod));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Class),       mrb_obj_value(cls));\n\n  /* name each classes */\n  mrb_class_name_class(mrb, NULL, bob, MRB_SYM(BasicObject));\n  mrb_class_name_class(mrb, NULL, obj, MRB_SYM(Object)); /* 15.2.1 */\n  mrb_class_name_class(mrb, NULL, mod, MRB_SYM(Module)); /* 15.2.2 */\n  mrb_class_name_class(mrb, NULL, cls, MRB_SYM(Class));  /* 15.2.3 */\n\n  mrb->proc_class = mrb_define_class(mrb, \"Proc\", mrb->object_class);  /* 15.2.17 */\n  MRB_SET_INSTANCE_TT(mrb->proc_class, MRB_TT_PROC);\n\n  MRB_SET_INSTANCE_TT(cls, MRB_TT_CLASS);\n  mrb_define_method(mrb, bob, \"initialize\",              mrb_bob_init,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"!\",                       mrb_bob_not,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"==\",                      mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.1  */\n  mrb_define_method(mrb, bob, \"__id__\",                  mrb_obj_id_m,             MRB_ARGS_NONE()); /* 15.3.1.3.4  */\n  mrb_define_method(mrb, bob, \"__send__\",                mrb_f_send,               MRB_ARGS_REQ(1)|MRB_ARGS_REST()|MRB_ARGS_BLOCK());  /* 15.3.1.3.5  */\n  mrb_define_method(mrb, bob, \"equal?\",                  mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.11 */\n  mrb_define_method(mrb, bob, \"instance_eval\",           mrb_obj_instance_eval,    MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());  /* 15.3.1.3.18 */\n  mrb_define_method(mrb, bob, \"singleton_method_added\",  mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, cls, \"new\",               mrb_class_new_class,      MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, cls, \"allocate\",                mrb_instance_alloc,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, cls, \"superclass\",              mrb_class_superclass,     MRB_ARGS_NONE()); /* 15.2.3.3.4 */\n  mrb_define_method(mrb, cls, \"initialize\",              mrb_class_initialize,     MRB_ARGS_OPT(1)); /* 15.2.3.3.1 */\n  mrb_define_method(mrb, cls, \"inherited\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  init_class_new(mrb, cls);\n\n  MRB_SET_INSTANCE_TT(mod, MRB_TT_MODULE);\n  mrb_define_method(mrb, mod, \"extend_object\",           mrb_mod_extend_object,    MRB_ARGS_REQ(1)); /* 15.2.2.4.25 */\n  mrb_define_method(mrb, mod, \"extended\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.26 */\n  mrb_define_method(mrb, mod, \"prepended\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"prepend_features\",        mrb_mod_prepend_features, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"include?\",                mrb_mod_include_p,        MRB_ARGS_REQ(1)); /* 15.2.2.4.28 */\n  mrb_define_method(mrb, mod, \"append_features\",         mrb_mod_append_features,  MRB_ARGS_REQ(1)); /* 15.2.2.4.10 */\n  mrb_define_method(mrb, mod, \"class_eval\",              mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.15 */\n  mrb_define_method(mrb, mod, \"included\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.29 */\n  mrb_define_method(mrb, mod, \"initialize\",              mrb_mod_initialize,       MRB_ARGS_NONE()); /* 15.2.2.4.31 */\n  mrb_define_method(mrb, mod, \"module_eval\",             mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.35 */\n  mrb_define_method(mrb, mod, \"module_function\",         mrb_mod_module_function,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, mod, \"private\",                 mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.36 */\n  mrb_define_method(mrb, mod, \"protected\",               mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.37 */\n  mrb_define_method(mrb, mod, \"public\",                  mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.38 */\n  mrb_define_method(mrb, mod, \"attr_reader\",             mrb_mod_attr_reader,      MRB_ARGS_ANY());  /* 15.2.2.4.13 */\n  mrb_define_method(mrb, mod, \"attr_writer\",             mrb_mod_attr_writer,      MRB_ARGS_ANY());  /* 15.2.2.4.14 */\n  mrb_define_method(mrb, mod, \"to_s\",                    mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"inspect\",                 mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"alias_method\",            mrb_mod_alias,            MRB_ARGS_ANY());  /* 15.2.2.4.8 */\n  mrb_define_method(mrb, mod, \"ancestors\",               mrb_mod_ancestors,        MRB_ARGS_NONE()); /* 15.2.2.4.9 */\n  mrb_define_method(mrb, mod, \"undef_method\",            mrb_mod_undef,            MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"const_defined?\",          mrb_mod_const_defined,    MRB_ARGS_ARG(1,1)); /* 15.2.2.4.20 */\n  mrb_define_method(mrb, mod, \"const_get\",               mrb_mod_const_get,        MRB_ARGS_REQ(1)); /* 15.2.2.4.21 */\n  mrb_define_method(mrb, mod, \"const_set\",               mrb_mod_const_set,        MRB_ARGS_REQ(2)); /* 15.2.2.4.23 */\n  mrb_define_method(mrb, mod, \"remove_const\",            mrb_mod_remove_const,     MRB_ARGS_REQ(1)); /* 15.2.2.4.40 */\n  mrb_define_method(mrb, mod, \"const_missing\",           mrb_mod_const_missing,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"method_defined?\",         mrb_mod_method_defined,   MRB_ARGS_REQ(1)); /* 15.2.2.4.34 */\n  mrb_define_method(mrb, mod, \"define_method\",           mod_define_method,        MRB_ARGS_ARG(1,1));\n  mrb_define_method(mrb, mod, \"===\",                     mrb_mod_eqq,              MRB_ARGS_REQ(1)); /* 15.2.2.4.7 */\n  mrb_define_method(mrb, mod, \"dup\",                     mrb_mod_dup,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"method_added\",            mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  mrb_undef_method(mrb, cls, \"append_features\");\n  mrb_undef_method(mrb, cls, \"prepend_features\");\n  mrb_undef_method(mrb, cls, \"extend_object\");\n  mrb_undef_method(mrb, cls, \"module_function\");\n\n  mrb->top_self = MRB_OBJ_ALLOC(mrb, MRB_TT_OBJECT, mrb->object_class);\n  mrb_define_singleton_method(mrb, mrb->top_self, \"inspect\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"to_s\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"define_method\", top_define_method, MRB_ARGS_ARG(1,1));\n}\n", "/*\n** proc.c - Proc class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/opcode.h>\n#include <mruby/data.h>\n#include <mruby/presym.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n\nstatic const mrb_code call_iseq[] = {\n  OP_CALL,\n};\n\nstatic const mrb_irep call_irep = {\n  0,                                   /* nlocals */\n  2,                                   /* nregs */\n  0,                                   /* clen */\n  MRB_ISEQ_NO_FREE | MRB_IREP_NO_FREE, /* flags */\n  call_iseq,                           /* iseq */\n  NULL,                                /* pool */\n  NULL,                                /* syms */\n  NULL,                                /* reps */\n  NULL,                                /* lv */\n  NULL,                                /* debug_info */\n  1,                                   /* ilen */\n  0,                                   /* plen */\n  0,                                   /* slen */\n  1,                                   /* rlen */\n  0,                                   /* refcnt */\n};\n\nstatic const struct RProc call_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &call_irep }, NULL, { NULL }\n};\n\nstruct RProc*\nmrb_proc_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  if (ci) {\n    struct RClass *tc = NULL;\n\n    if (ci->proc) {\n      if (ci->proc->color != MRB_GC_RED) {\n        tc = MRB_PROC_TARGET_CLASS(ci->proc);\n      }\n      else {\n        tc = mrb_vm_ci_target_class(ci);\n        if (tc && tc->tt == MRB_TT_ICLASS) {\n          tc = tc->c;\n        }\n      }\n    }\n    if (tc == NULL) {\n      tc = mrb_vm_ci_target_class(ci);\n    }\n    p->upper = ci->proc;\n    p->e.target_class = tc;\n  }\n  p->body.irep = irep;\n  if (irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)irep);\n  }\n\n  return p;\n}\n\nstruct REnv*\nmrb_env_new(mrb_state *mrb, struct mrb_context *c, mrb_callinfo *ci, int nstacks, mrb_value *stack, struct RClass *tc)\n{\n  struct REnv *e;\n  mrb_int bidx = 1;\n  int n = ci->n;\n  int nk = ci->nk;\n\n  e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n  e->c = tc;\n  MRB_ENV_SET_LEN(e, nstacks);\n  bidx += (n == 15) ? 1 : n;\n  bidx += (nk == 15) ? 1 : (2*nk);\n  MRB_ENV_SET_BIDX(e, bidx);\n  e->mid = ci->mid;\n  e->stack = stack;\n  e->cxt = c;\n\n  return e;\n}\n\nstatic void\nclosure_setup(mrb_state *mrb, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  const struct RProc *up = p->upper;\n  struct REnv *e = NULL;\n\n  if (ci && (e = mrb_vm_ci_env(ci)) != NULL) {\n    /* do nothing, because e is assigned already */\n  }\n  else if (up) {\n    struct RClass *tc = ci->u.target_class;\n\n    e = mrb_env_new(mrb, mrb->c, ci, up->body.irep->nlocals, ci->stack, tc);\n    ci->u.env = e;\n    if (MRB_PROC_ENV_P(up) && MRB_PROC_ENV(up)->cxt == NULL) {\n      e->mid = MRB_PROC_ENV(up)->mid;\n    }\n  }\n  if (e) {\n    p->e.env = e;\n    p->flags |= MRB_PROC_ENVSET;\n    mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  }\n}\n\nstruct RProc*\nmrb_closure_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p = mrb_proc_new(mrb, irep);\n\n  closure_setup(mrb, p);\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc(mrb_state *mrb, mrb_func_t func)\n{\n  struct RProc *p;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  p->body.func = func;\n  p->flags |= MRB_PROC_CFUNC_FL;\n  p->upper = 0;\n  p->e.target_class = 0;\n\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p = mrb_proc_new_cfunc(mrb, func);\n  struct REnv *e;\n  int i;\n\n  p->e.env = e = mrb_env_new(mrb, mrb->c, mrb->c->ci, 0, NULL, NULL);\n  p->flags |= MRB_PROC_ENVSET;\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  MRB_ENV_CLOSE(e);\n\n  e->stack = (mrb_value*)mrb_malloc(mrb, sizeof(mrb_value) * argc);\n  MRB_ENV_SET_LEN(e, argc);\n\n  if (argv) {\n    for (i = 0; i < argc; ++i) {\n      e->stack[i] = argv[i];\n    }\n  }\n  else {\n    for (i = 0; i < argc; ++i) {\n      SET_NIL_VALUE(e->stack[i]);\n    }\n  }\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals)\n{\n  return mrb_proc_new_cfunc_with_env(mrb, func, nlocals, NULL);\n}\n\nMRB_API mrb_value\nmrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)\n{\n  const struct RProc *p = mrb->c->ci->proc;\n  struct REnv *e;\n\n  if (!p || !MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from non-cfunc proc\");\n  }\n  e = MRB_PROC_ENV(p);\n  if (!e) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from cfunc Proc without REnv\");\n  }\n  if (idx < 0 || MRB_ENV_LEN(e) <= idx) {\n    mrb_raisef(mrb, E_INDEX_ERROR, \"Env index out of range: %i (expected: 0 <= index < %i)\",\n               idx, MRB_ENV_LEN(e));\n  }\n\n  return e->stack[idx];\n}\n\nvoid\nmrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}\n\nstatic mrb_value\nmrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}\n\nstatic mrb_value\nmrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}\n\n/* 15.2.17.4.2 */\nstatic mrb_value\nproc_arity(mrb_state *mrb, mrb_value self)\n{\n  return mrb_int_value(mrb, mrb_proc_arity(mrb_proc_ptr(self)));\n}\n\n/* 15.3.1.2.6  */\n/* 15.3.1.3.27 */\n/*\n * call-seq:\n *   lambda { |...| block }  -> a_proc\n *\n * Equivalent to <code>Proc.new</code>, except the resulting Proc objects\n * check the number of parameters passed when called.\n */\nstatic mrb_value\nproc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(mrb, p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}\n\nmrb_int\nmrb_proc_arity(const struct RProc *p)\n{\n  const mrb_irep *irep;\n  const mrb_code *pc;\n  mrb_aspec aspec;\n  int ma, op, ra, pa, arity;\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    /* TODO cfunc aspec not implemented yet */\n    return -1;\n  }\n\n  irep = p->body.irep;\n  if (!irep) {\n    return 0;\n  }\n\n  pc = irep->iseq;\n  /* arity is depend on OP_ENTER */\n  if (*pc != OP_ENTER) {\n    return 0;\n  }\n\n  aspec = PEEK_W(pc+1);\n  ma = MRB_ASPEC_REQ(aspec);\n  op = MRB_ASPEC_OPT(aspec);\n  ra = MRB_ASPEC_REST(aspec);\n  pa = MRB_ASPEC_POST(aspec);\n  arity = ra || (MRB_PROC_STRICT_P(p) && op) ? -(ma + pa + 1) : ma + pa;\n\n  return arity;\n}\n\nmrb_value\nmrb_proc_local_variables(mrb_state *mrb, const struct RProc *proc)\n{\n  const mrb_irep *irep;\n  mrb_value vars;\n  size_t i;\n\n  if (proc == NULL || MRB_PROC_CFUNC_P(proc)) {\n    return mrb_ary_new(mrb);\n  }\n  vars = mrb_hash_new(mrb);\n  while (proc) {\n    if (MRB_PROC_CFUNC_P(proc)) break;\n    irep = proc->body.irep;\n    if (irep->lv) {\n      for (i = 0; i + 1 < irep->nlocals; ++i) {\n        if (irep->lv[i]) {\n          mrb_sym sym = irep->lv[i];\n          const char *name = mrb_sym_name(mrb, sym);\n          switch (name[0]) {\n          case '*': case '&':\n            break;\n          default:\n            mrb_hash_set(mrb, vars, mrb_symbol_value(sym), mrb_true_value());\n            break;\n          }\n        }\n      }\n    }\n    if (MRB_PROC_SCOPE_P(proc)) break;\n    proc = proc->upper;\n  }\n\n  return mrb_hash_keys(mrb, vars);\n}\n\nconst struct RProc *\nmrb_proc_get_caller(mrb_state *mrb, struct REnv **envp)\n{\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = (c->ci > c->cibase) ? c->ci - 1 : c->cibase;\n  const struct RProc *proc = ci->proc;\n\n  if (!proc || MRB_PROC_CFUNC_P(proc)) {\n    if (envp) *envp = NULL;\n  }\n  else {\n    struct RClass *tc = MRB_PROC_TARGET_CLASS(proc);\n    struct REnv *e = mrb_vm_ci_env(ci);\n\n    if (e == NULL) {\n      int nstacks = proc->body.irep->nlocals;\n      e = mrb_env_new(mrb, c, ci, nstacks, ci->stack, tc);\n      ci->u.env = e;\n    }\n    else if (tc) {\n      e->c = tc;\n      mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n    }\n    if (envp) *envp = e;\n  }\n\n  return proc;\n}\n\n#define IREP_LVAR_MERGE_DEFAULT  50\n#define IREP_LVAR_MERGE_MINIMUM   8\n#define IREP_LVAR_MERGE_MAXIMUM 240\n\n#ifdef MRB_IREP_LVAR_MERGE_LIMIT\n# define IREP_LVAR_MERGE_LIMIT \\\n  ((MRB_IREP_LVAR_MERGE_LIMIT) < IREP_LVAR_MERGE_MINIMUM ? IREP_LVAR_MERGE_MINIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT) > IREP_LVAR_MERGE_MAXIMUM ? IREP_LVAR_MERGE_MAXIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT))\n#else\n# define IREP_LVAR_MERGE_LIMIT IREP_LVAR_MERGE_DEFAULT\n#endif\n\nvoid\nmrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, const mrb_sym *lv, const mrb_value *stack)\n{\n  mrb_assert(!(irep->flags & MRB_IREP_NO_FREE));\n\n  if ((irep->nlocals + num) > IREP_LVAR_MERGE_LIMIT) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"too many local variables for binding (mruby limitation)\");\n  }\n\n  if (!lv) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"unavailable local variable names\");\n  }\n\n  irep->lv = (mrb_sym*)mrb_realloc(mrb, (mrb_sym*)irep->lv, sizeof(mrb_sym) * (irep->nlocals + num));\n  env->stack = (mrb_value*)mrb_realloc(mrb, env->stack, sizeof(mrb_value) * (irep->nlocals + 1 /* self */ + num));\n\n  mrb_sym *destlv = (mrb_sym*)irep->lv + irep->nlocals - 1 /* self */;\n  mrb_value *destst = env->stack + irep->nlocals;\n  memmove(destlv, lv, sizeof(mrb_sym) * num);\n  if (stack) {\n    memmove(destst, stack, sizeof(mrb_value) * num);\n    for (int i = 0; i < num; i++) {\n      if (!mrb_immediate_p(stack[i])) {\n        mrb_field_write_barrier(mrb, (struct RBasic*)env, (struct RBasic*)mrb_obj_ptr(stack[i]));\n      }\n    }\n  }\n  else {\n    for (int i = num; i > 0; i--, destst++) {\n      *destst = mrb_nil_value();\n    }\n  }\n  irep->nlocals += num;\n  irep->nregs = irep->nlocals;\n  MRB_ENV_SET_LEN(env, irep->nlocals);\n}\n\nvoid\nmrb_init_proc(mrb_state *mrb)\n{\n  mrb_method_t m;\n\n  mrb_define_class_method(mrb, mrb->proc_class, \"new\", mrb_proc_s_new, MRB_ARGS_NONE()|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, mrb->proc_class, \"initialize_copy\", mrb_proc_init_copy, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mrb->proc_class, \"arity\", proc_arity, MRB_ARGS_NONE());\n\n  MRB_METHOD_FROM_PROC(m, &call_proc);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_SYM(call), m);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_OPSYM(aref), m);\n\n  mrb_define_class_method(mrb, mrb->kernel_module, \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.2.6  */\n  mrb_define_method(mrb, mrb->kernel_module,       \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.3.27 */\n}\n"], "filenames": ["include/mruby/proc.h", "src/class.c", "src/proc.c"], "buggy_code_start_loc": [95, 2572, 204], "buggy_code_end_loc": [96, 2573, 285], "fixing_code_start_loc": [95, 2572, 204], "fixing_code_end_loc": [96, 2573, 285], "type": "CWE-476", "message": "mruby is vulnerable to NULL Pointer Dereference", "other": {"cve": {"id": "CVE-2021-4110", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-15T05:15:08.323", "lastModified": "2021-12-15T22:15:36.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mruby is vulnerable to NULL Pointer Dereference"}, {"lang": "es", "value": "mruby es vulnerable a una Desreferencia de Puntero NULL"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1", "matchCriteriaId": "CD20F80E-4513-4565-9668-0D5EA105A14B"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/f5e10c5a79a17939af763b1dcf5232ce47e24a34", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4ce5dc47-2512-4c87-8609-453adc8cad20", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/f5e10c5a79a17939af763b1dcf5232ce47e24a34"}}