{"buggy_code": ["// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n/*\n * bcm.c - Broadcast Manager to filter/send (cyclic) CAN content\n *\n * Copyright (c) 2002-2017 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/list.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uio.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/can/bcm.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/net_namespace.h>\n\n/*\n * To send multiple CAN frame content within TX_SETUP or to filter\n * CAN messages with multiplex index within RX_SETUP, the number of\n * different filters is limited to 256 due to the one byte index value.\n */\n#define MAX_NFRAMES 256\n\n/* limit timers to 400 days for sending/timeouts */\n#define BCM_TIMER_SEC_MAX (400 * 24 * 60 * 60)\n\n/* use of last_frames[index].flags */\n#define RX_RECV    0x40 /* received data for this element */\n#define RX_THR     0x80 /* element not been sent due to throttle feature */\n#define BCM_CAN_FLAGS_MASK 0x3F /* to clean private flags after usage */\n\n/* get best masking value for can_rx_register() for a given single can_id */\n#define REGMASK(id) ((id & CAN_EFF_FLAG) ? \\\n\t\t     (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \\\n\t\t     (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))\n\nMODULE_DESCRIPTION(\"PF_CAN broadcast manager protocol\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <oliver.hartkopp@volkswagen.de>\");\nMODULE_ALIAS(\"can-proto-2\");\n\n#define BCM_MIN_NAMELEN CAN_REQUIRED_SIZE(struct sockaddr_can, can_ifindex)\n\n/*\n * easy access to the first 64 bit of can(fd)_frame payload. cp->data is\n * 64 bit aligned so the offset has to be multiples of 8 which is ensured\n * by the only callers in bcm_rx_cmp_to_index() bcm_rx_handler().\n */\nstatic inline u64 get_u64(const struct canfd_frame *cp, int offset)\n{\n\treturn *(u64 *)(cp->data + offset);\n}\n\nstruct bcm_op {\n\tstruct list_head list;\n\tint ifindex;\n\tcanid_t can_id;\n\tu32 flags;\n\tunsigned long frames_abs, frames_filtered;\n\tstruct bcm_timeval ival1, ival2;\n\tstruct hrtimer timer, thrtimer;\n\tktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;\n\tint rx_ifindex;\n\tint cfsiz;\n\tu32 count;\n\tu32 nframes;\n\tu32 currframe;\n\t/* void pointers to arrays of struct can[fd]_frame */\n\tvoid *frames;\n\tvoid *last_frames;\n\tstruct canfd_frame sframe;\n\tstruct canfd_frame last_sframe;\n\tstruct sock *sk;\n\tstruct net_device *rx_reg_dev;\n};\n\nstruct bcm_sock {\n\tstruct sock sk;\n\tint bound;\n\tint ifindex;\n\tstruct list_head notifier;\n\tstruct list_head rx_ops;\n\tstruct list_head tx_ops;\n\tunsigned long dropped_usr_msgs;\n\tstruct proc_dir_entry *bcm_proc_read;\n\tchar procname [32]; /* inode number in decimal with \\0 */\n};\n\nstatic LIST_HEAD(bcm_notifier_list);\nstatic DEFINE_SPINLOCK(bcm_notifier_lock);\nstatic struct bcm_sock *bcm_busy_notifier;\n\nstatic inline struct bcm_sock *bcm_sk(const struct sock *sk)\n{\n\treturn (struct bcm_sock *)sk;\n}\n\nstatic inline ktime_t bcm_timeval_to_ktime(struct bcm_timeval tv)\n{\n\treturn ktime_set(tv.tv_sec, tv.tv_usec * NSEC_PER_USEC);\n}\n\n/* check limitations for timeval provided by user */\nstatic bool bcm_is_invalid_tv(struct bcm_msg_head *msg_head)\n{\n\tif ((msg_head->ival1.tv_sec < 0) ||\n\t    (msg_head->ival1.tv_sec > BCM_TIMER_SEC_MAX) ||\n\t    (msg_head->ival1.tv_usec < 0) ||\n\t    (msg_head->ival1.tv_usec >= USEC_PER_SEC) ||\n\t    (msg_head->ival2.tv_sec < 0) ||\n\t    (msg_head->ival2.tv_sec > BCM_TIMER_SEC_MAX) ||\n\t    (msg_head->ival2.tv_usec < 0) ||\n\t    (msg_head->ival2.tv_usec >= USEC_PER_SEC))\n\t\treturn true;\n\n\treturn false;\n}\n\n#define CFSIZ(flags) ((flags & CAN_FD_FRAME) ? CANFD_MTU : CAN_MTU)\n#define OPSIZ sizeof(struct bcm_op)\n#define MHSIZ sizeof(struct bcm_msg_head)\n\n/*\n * procfs functions\n */\n#if IS_ENABLED(CONFIG_PROC_FS)\nstatic char *bcm_proc_getifname(struct net *net, char *result, int ifindex)\n{\n\tstruct net_device *dev;\n\n\tif (!ifindex)\n\t\treturn \"any\";\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\tstrcpy(result, dev->name);\n\telse\n\t\tstrcpy(result, \"???\");\n\trcu_read_unlock();\n\n\treturn result;\n}\n\nstatic int bcm_proc_show(struct seq_file *m, void *v)\n{\n\tchar ifname[IFNAMSIZ];\n\tstruct net *net = m->private;\n\tstruct sock *sk = (struct sock *)PDE_DATA(m->file->f_inode);\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\n\tseq_printf(m, \">>> socket %pK\", sk->sk_socket);\n\tseq_printf(m, \" / sk %pK\", sk);\n\tseq_printf(m, \" / bo %pK\", bo);\n\tseq_printf(m, \" / dropped %lu\", bo->dropped_usr_msgs);\n\tseq_printf(m, \" / bound %s\", bcm_proc_getifname(net, ifname, bo->ifindex));\n\tseq_printf(m, \" <<<\\n\");\n\n\tlist_for_each_entry(op, &bo->rx_ops, list) {\n\n\t\tunsigned long reduction;\n\n\t\t/* print only active entries & prevent division by zero */\n\t\tif (!op->frames_abs)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"rx_op: %03X %-5s \", op->can_id,\n\t\t\t   bcm_proc_getifname(net, ifname, op->ifindex));\n\n\t\tif (op->flags & CAN_FD_FRAME)\n\t\t\tseq_printf(m, \"(%u)\", op->nframes);\n\t\telse\n\t\t\tseq_printf(m, \"[%u]\", op->nframes);\n\n\t\tseq_printf(m, \"%c \", (op->flags & RX_CHECK_DLC) ? 'd' : ' ');\n\n\t\tif (op->kt_ival1)\n\t\t\tseq_printf(m, \"timeo=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival1));\n\n\t\tif (op->kt_ival2)\n\t\t\tseq_printf(m, \"thr=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival2));\n\n\t\tseq_printf(m, \"# recv %ld (%ld) => reduction: \",\n\t\t\t   op->frames_filtered, op->frames_abs);\n\n\t\treduction = 100 - (op->frames_filtered * 100) / op->frames_abs;\n\n\t\tseq_printf(m, \"%s%ld%%\\n\",\n\t\t\t   (reduction == 100) ? \"near \" : \"\", reduction);\n\t}\n\n\tlist_for_each_entry(op, &bo->tx_ops, list) {\n\n\t\tseq_printf(m, \"tx_op: %03X %s \", op->can_id,\n\t\t\t   bcm_proc_getifname(net, ifname, op->ifindex));\n\n\t\tif (op->flags & CAN_FD_FRAME)\n\t\t\tseq_printf(m, \"(%u) \", op->nframes);\n\t\telse\n\t\t\tseq_printf(m, \"[%u] \", op->nframes);\n\n\t\tif (op->kt_ival1)\n\t\t\tseq_printf(m, \"t1=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival1));\n\n\t\tif (op->kt_ival2)\n\t\t\tseq_printf(m, \"t2=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival2));\n\n\t\tseq_printf(m, \"# sent %ld\\n\", op->frames_abs);\n\t}\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n#endif /* CONFIG_PROC_FS */\n\n/*\n * bcm_can_tx - send the (next) CAN frame to the appropriate CAN interface\n *              of the given bcm tx op\n */\nstatic void bcm_can_tx(struct bcm_op *op)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * op->currframe;\n\n\t/* no target device? => exit */\n\tif (!op->ifindex)\n\t\treturn;\n\n\tdev = dev_get_by_index(sock_net(op->sk), op->ifindex);\n\tif (!dev) {\n\t\t/* RFC: should this bcm_op remove itself here? */\n\t\treturn;\n\t}\n\n\tskb = alloc_skb(op->cfsiz + sizeof(struct can_skb_priv), gfp_any());\n\tif (!skb)\n\t\tgoto out;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, cf, op->cfsiz);\n\n\t/* send with loopback */\n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, op->sk);\n\tcan_send(skb, 1);\n\n\t/* update statistics */\n\top->currframe++;\n\top->frames_abs++;\n\n\t/* reached last frame? */\n\tif (op->currframe >= op->nframes)\n\t\top->currframe = 0;\nout:\n\tdev_put(dev);\n}\n\n/*\n * bcm_send_to_user - send a BCM message to the userspace\n *                    (consisting of bcm_msg_head + x CAN frames)\n */\nstatic void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,\n\t\t\t     struct canfd_frame *frames, int has_timestamp)\n{\n\tstruct sk_buff *skb;\n\tstruct canfd_frame *firstframe;\n\tstruct sockaddr_can *addr;\n\tstruct sock *sk = op->sk;\n\tunsigned int datalen = head->nframes * op->cfsiz;\n\tint err;\n\n\tskb = alloc_skb(sizeof(*head) + datalen, gfp_any());\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, head, sizeof(*head));\n\n\tif (head->nframes) {\n\t\t/* CAN frames starting here */\n\t\tfirstframe = (struct canfd_frame *)skb_tail_pointer(skb);\n\n\t\tskb_put_data(skb, frames, datalen);\n\n\t\t/*\n\t\t * the BCM uses the flags-element of the canfd_frame\n\t\t * structure for internal purposes. This is only\n\t\t * relevant for updates that are generated by the\n\t\t * BCM, where nframes is 1\n\t\t */\n\t\tif (head->nframes == 1)\n\t\t\tfirstframe->flags &= BCM_CAN_FLAGS_MASK;\n\t}\n\n\tif (has_timestamp) {\n\t\t/* restore rx timestamp */\n\t\tskb->tstamp = op->rx_stamp;\n\t}\n\n\t/*\n\t *  Put the datagram to the queue so that bcm_recvmsg() can\n\t *  get it from there.  We need to pass the interface index to\n\t *  bcm_recvmsg().  We pass a whole struct sockaddr_can in skb->cb\n\t *  containing the interface index.\n\t */\n\n\tsock_skb_cb_check_size(sizeof(struct sockaddr_can));\n\taddr = (struct sockaddr_can *)skb->cb;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = op->rx_ifindex;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err < 0) {\n\t\tstruct bcm_sock *bo = bcm_sk(sk);\n\n\t\tkfree_skb(skb);\n\t\t/* don't care about overflows in this statistic */\n\t\tbo->dropped_usr_msgs++;\n\t}\n}\n\nstatic bool bcm_tx_set_expiry(struct bcm_op *op, struct hrtimer *hrt)\n{\n\tktime_t ival;\n\n\tif (op->kt_ival1 && op->count)\n\t\tival = op->kt_ival1;\n\telse if (op->kt_ival2)\n\t\tival = op->kt_ival2;\n\telse\n\t\treturn false;\n\n\thrtimer_set_expires(hrt, ktime_add(ktime_get(), ival));\n\treturn true;\n}\n\nstatic void bcm_tx_start_timer(struct bcm_op *op)\n{\n\tif (bcm_tx_set_expiry(op, &op->timer))\n\t\thrtimer_start_expires(&op->timer, HRTIMER_MODE_ABS_SOFT);\n}\n\n/* bcm_tx_timeout_handler - performs cyclic CAN frame transmissions */\nstatic enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\tif (op->kt_ival1 && (op->count > 0)) {\n\t\top->count--;\n\t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n\n\t\t\t/* create notification to user */\n\t\t\tmemset(&msg_head, 0, sizeof(msg_head));\n\t\t\tmsg_head.opcode  = TX_EXPIRED;\n\t\t\tmsg_head.flags   = op->flags;\n\t\t\tmsg_head.count   = op->count;\n\t\t\tmsg_head.ival1   = op->ival1;\n\t\t\tmsg_head.ival2   = op->ival2;\n\t\t\tmsg_head.can_id  = op->can_id;\n\t\t\tmsg_head.nframes = 0;\n\n\t\t\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\t\t}\n\t\tbcm_can_tx(op);\n\n\t} else if (op->kt_ival2) {\n\t\tbcm_can_tx(op);\n\t}\n\n\treturn bcm_tx_set_expiry(op, &op->timer) ?\n\t\tHRTIMER_RESTART : HRTIMER_NORESTART;\n}\n\n/*\n * bcm_rx_changed - create a RX_CHANGED notification due to changed content\n */\nstatic void bcm_rx_changed(struct bcm_op *op, struct canfd_frame *data)\n{\n\tstruct bcm_msg_head head;\n\n\t/* update statistics */\n\top->frames_filtered++;\n\n\t/* prevent statistics overflow */\n\tif (op->frames_filtered > ULONG_MAX/100)\n\t\top->frames_filtered = op->frames_abs = 0;\n\n\t/* this element is not throttled anymore */\n\tdata->flags &= (BCM_CAN_FLAGS_MASK|RX_RECV);\n\n\tmemset(&head, 0, sizeof(head));\n\thead.opcode  = RX_CHANGED;\n\thead.flags   = op->flags;\n\thead.count   = op->count;\n\thead.ival1   = op->ival1;\n\thead.ival2   = op->ival2;\n\thead.can_id  = op->can_id;\n\thead.nframes = 1;\n\n\tbcm_send_to_user(op, &head, data, 1);\n}\n\n/*\n * bcm_rx_update_and_send - process a detected relevant receive content change\n *                          1. update the last received data\n *                          2. send a notification to the user (if possible)\n */\nstatic void bcm_rx_update_and_send(struct bcm_op *op,\n\t\t\t\t   struct canfd_frame *lastdata,\n\t\t\t\t   const struct canfd_frame *rxdata)\n{\n\tmemcpy(lastdata, rxdata, op->cfsiz);\n\n\t/* mark as used and throttled by default */\n\tlastdata->flags |= (RX_RECV|RX_THR);\n\n\t/* throttling mode inactive ? */\n\tif (!op->kt_ival2) {\n\t\t/* send RX_CHANGED to the user immediately */\n\t\tbcm_rx_changed(op, lastdata);\n\t\treturn;\n\t}\n\n\t/* with active throttling timer we are just done here */\n\tif (hrtimer_active(&op->thrtimer))\n\t\treturn;\n\n\t/* first reception with enabled throttling mode */\n\tif (!op->kt_lastmsg)\n\t\tgoto rx_changed_settime;\n\n\t/* got a second frame inside a potential throttle period? */\n\tif (ktime_us_delta(ktime_get(), op->kt_lastmsg) <\n\t    ktime_to_us(op->kt_ival2)) {\n\t\t/* do not send the saved data - only start throttle timer */\n\t\thrtimer_start(&op->thrtimer,\n\t\t\t      ktime_add(op->kt_lastmsg, op->kt_ival2),\n\t\t\t      HRTIMER_MODE_ABS_SOFT);\n\t\treturn;\n\t}\n\n\t/* the gap was that big, that throttling was not needed here */\nrx_changed_settime:\n\tbcm_rx_changed(op, lastdata);\n\top->kt_lastmsg = ktime_get();\n}\n\n/*\n * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly\n *                       received data stored in op->last_frames[]\n */\nstatic void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,\n\t\t\t\tconst struct canfd_frame *rxdata)\n{\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * index;\n\tstruct canfd_frame *lcf = op->last_frames + op->cfsiz * index;\n\tint i;\n\n\t/*\n\t * no one uses the MSBs of flags for comparison,\n\t * so we use it here to detect the first time of reception\n\t */\n\n\tif (!(lcf->flags & RX_RECV)) {\n\t\t/* received data for the first time => send update to user */\n\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\treturn;\n\t}\n\n\t/* do a real check in CAN frame data section */\n\tfor (i = 0; i < rxdata->len; i += 8) {\n\t\tif ((get_u64(cf, i) & get_u64(rxdata, i)) !=\n\t\t    (get_u64(cf, i) & get_u64(lcf, i))) {\n\t\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (op->flags & RX_CHECK_DLC) {\n\t\t/* do a real check in CAN frame length */\n\t\tif (rxdata->len != lcf->len) {\n\t\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * bcm_rx_starttimer - enable timeout monitoring for CAN frame reception\n */\nstatic void bcm_rx_starttimer(struct bcm_op *op)\n{\n\tif (op->flags & RX_NO_AUTOTIMER)\n\t\treturn;\n\n\tif (op->kt_ival1)\n\t\thrtimer_start(&op->timer, op->kt_ival1, HRTIMER_MODE_REL_SOFT);\n}\n\n/* bcm_rx_timeout_handler - when the (cyclic) CAN frame reception timed out */\nstatic enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\t/* if user wants to be informed, when cyclic CAN-Messages come back */\n\tif ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {\n\t\t/* clear received CAN frames to indicate 'nothing received' */\n\t\tmemset(op->last_frames, 0, op->nframes * op->cfsiz);\n\t}\n\n\t/* create notification to user */\n\tmemset(&msg_head, 0, sizeof(msg_head));\n\tmsg_head.opcode  = RX_TIMEOUT;\n\tmsg_head.flags   = op->flags;\n\tmsg_head.count   = op->count;\n\tmsg_head.ival1   = op->ival1;\n\tmsg_head.ival2   = op->ival2;\n\tmsg_head.can_id  = op->can_id;\n\tmsg_head.nframes = 0;\n\n\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\n\treturn HRTIMER_NORESTART;\n}\n\n/*\n * bcm_rx_do_flush - helper for bcm_rx_thr_flush\n */\nstatic inline int bcm_rx_do_flush(struct bcm_op *op, unsigned int index)\n{\n\tstruct canfd_frame *lcf = op->last_frames + op->cfsiz * index;\n\n\tif ((op->last_frames) && (lcf->flags & RX_THR)) {\n\t\tbcm_rx_changed(op, lcf);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * bcm_rx_thr_flush - Check for throttled data and send it to the userspace\n */\nstatic int bcm_rx_thr_flush(struct bcm_op *op)\n{\n\tint updated = 0;\n\n\tif (op->nframes > 1) {\n\t\tunsigned int i;\n\n\t\t/* for MUX filter we start at index 1 */\n\t\tfor (i = 1; i < op->nframes; i++)\n\t\t\tupdated += bcm_rx_do_flush(op, i);\n\n\t} else {\n\t\t/* for RX_FILTER_ID and simple filter */\n\t\tupdated += bcm_rx_do_flush(op, 0);\n\t}\n\n\treturn updated;\n}\n\n/*\n * bcm_rx_thr_handler - the time for blocked content updates is over now:\n *                      Check for throttled data and send it to the userspace\n */\nstatic enum hrtimer_restart bcm_rx_thr_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, thrtimer);\n\n\tif (bcm_rx_thr_flush(op)) {\n\t\thrtimer_forward(hrtimer, ktime_get(), op->kt_ival2);\n\t\treturn HRTIMER_RESTART;\n\t} else {\n\t\t/* rearm throttle handling */\n\t\top->kt_lastmsg = 0;\n\t\treturn HRTIMER_NORESTART;\n\t}\n}\n\n/*\n * bcm_rx_handler - handle a CAN frame reception\n */\nstatic void bcm_rx_handler(struct sk_buff *skb, void *data)\n{\n\tstruct bcm_op *op = (struct bcm_op *)data;\n\tconst struct canfd_frame *rxframe = (struct canfd_frame *)skb->data;\n\tunsigned int i;\n\n\tif (op->can_id != rxframe->can_id)\n\t\treturn;\n\n\t/* make sure to handle the correct frame type (CAN / CAN FD) */\n\tif (skb->len != op->cfsiz)\n\t\treturn;\n\n\t/* disable timeout */\n\thrtimer_cancel(&op->timer);\n\n\t/* save rx timestamp */\n\top->rx_stamp = skb->tstamp;\n\t/* save originator for recvfrom() */\n\top->rx_ifindex = skb->dev->ifindex;\n\t/* update statistics */\n\top->frames_abs++;\n\n\tif (op->flags & RX_RTR_FRAME) {\n\t\t/* send reply for RTR-request (placed in op->frames[0]) */\n\t\tbcm_can_tx(op);\n\t\treturn;\n\t}\n\n\tif (op->flags & RX_FILTER_ID) {\n\t\t/* the easiest case */\n\t\tbcm_rx_update_and_send(op, op->last_frames, rxframe);\n\t\tgoto rx_starttimer;\n\t}\n\n\tif (op->nframes == 1) {\n\t\t/* simple compare with index 0 */\n\t\tbcm_rx_cmp_to_index(op, 0, rxframe);\n\t\tgoto rx_starttimer;\n\t}\n\n\tif (op->nframes > 1) {\n\t\t/*\n\t\t * multiplex compare\n\t\t *\n\t\t * find the first multiplex mask that fits.\n\t\t * Remark: The MUX-mask is stored in index 0 - but only the\n\t\t * first 64 bits of the frame data[] are relevant (CAN FD)\n\t\t */\n\n\t\tfor (i = 1; i < op->nframes; i++) {\n\t\t\tif ((get_u64(op->frames, 0) & get_u64(rxframe, 0)) ==\n\t\t\t    (get_u64(op->frames, 0) &\n\t\t\t     get_u64(op->frames + op->cfsiz * i, 0))) {\n\t\t\t\tbcm_rx_cmp_to_index(op, i, rxframe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nrx_starttimer:\n\tbcm_rx_starttimer(op);\n}\n\n/*\n * helpers for bcm_op handling: find & delete bcm [rx|tx] op elements\n */\nstatic struct bcm_op *bcm_find_op(struct list_head *ops,\n\t\t\t\t  struct bcm_msg_head *mh, int ifindex)\n{\n\tstruct bcm_op *op;\n\n\tlist_for_each_entry(op, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}\n\nstatic void bcm_remove_op(struct bcm_op *op)\n{\n\thrtimer_cancel(&op->timer);\n\thrtimer_cancel(&op->thrtimer);\n\n\tif ((op->frames) && (op->frames != &op->sframe))\n\t\tkfree(op->frames);\n\n\tif ((op->last_frames) && (op->last_frames != &op->last_sframe))\n\t\tkfree(op->last_frames);\n\n\tkfree(op);\n}\n\nstatic void bcm_rx_unreg(struct net_device *dev, struct bcm_op *op)\n{\n\tif (op->rx_reg_dev == dev) {\n\t\tcan_rx_unregister(dev_net(dev), dev, op->can_id,\n\t\t\t\t  REGMASK(op->can_id), bcm_rx_handler, op);\n\n\t\t/* mark as removed subscription */\n\t\top->rx_reg_dev = NULL;\n\t} else\n\t\tprintk(KERN_ERR \"can-bcm: bcm_rx_unreg: registered device \"\n\t\t       \"mismatch %p %p\\n\", op->rx_reg_dev, dev);\n}\n\n/*\n * bcm_delete_rx_op - find and remove a rx op (returns number of removed ops)\n */\nstatic int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\n\t\t\t/*\n\t\t\t * Don't care if we're bound or not (due to netdev\n\t\t\t * problems) can_rx_unregister() is always a save\n\t\t\t * thing to do here.\n\t\t\t */\n\t\t\tif (op->ifindex) {\n\t\t\t\t/*\n\t\t\t\t * Only remove subscriptions that had not\n\t\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t\t * in bcm_notifier()\n\t\t\t\t */\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; /* done */\n\t\t}\n\t}\n\n\treturn 0; /* not found */\n}\n\n/*\n * bcm_delete_tx_op - find and remove a tx op (returns number of removed ops)\n */\nstatic int bcm_delete_tx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; /* done */\n\t\t}\n\t}\n\n\treturn 0; /* not found */\n}\n\n/*\n * bcm_read_op - read out a bcm_op and send it to the user (for bcm_sendmsg)\n */\nstatic int bcm_read_op(struct list_head *ops, struct bcm_msg_head *msg_head,\n\t\t       int ifindex)\n{\n\tstruct bcm_op *op = bcm_find_op(ops, msg_head, ifindex);\n\n\tif (!op)\n\t\treturn -EINVAL;\n\n\t/* put current values into msg_head */\n\tmsg_head->flags   = op->flags;\n\tmsg_head->count   = op->count;\n\tmsg_head->ival1   = op->ival1;\n\tmsg_head->ival2   = op->ival2;\n\tmsg_head->nframes = op->nframes;\n\n\tbcm_send_to_user(op, msg_head, op->frames, 0);\n\n\treturn MHSIZ;\n}\n\n/*\n * bcm_tx_setup - create or update a bcm tx op (for bcm_sendmsg)\n */\nstatic int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n\t\t\tint ifindex, struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\tstruct canfd_frame *cf;\n\tunsigned int i;\n\tint err;\n\n\t/* we need a real device to send frames */\n\tif (!ifindex)\n\t\treturn -ENODEV;\n\n\t/* check nframes boundaries - we need at least one CAN frame */\n\tif (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)\n\t\treturn -EINVAL;\n\n\t/* check timeval limitations */\n\tif ((msg_head->flags & SETTIMER) && bcm_is_invalid_tv(msg_head))\n\t\treturn -EINVAL;\n\n\t/* check the given can_id */\n\top = bcm_find_op(&bo->tx_ops, msg_head, ifindex);\n\tif (op) {\n\t\t/* update existing BCM operation */\n\n\t\t/*\n\t\t * Do we need more space for the CAN frames than currently\n\t\t * allocated? -> This is a _really_ unusual use-case and\n\t\t * therefore (complexity / locking) it is not supported.\n\t\t */\n\t\tif (msg_head->nframes > op->nframes)\n\t\t\treturn -E2BIG;\n\n\t\t/* update CAN frames content */\n\t\tfor (i = 0; i < msg_head->nframes; i++) {\n\n\t\t\tcf = op->frames + op->cfsiz * i;\n\t\t\terr = memcpy_from_msg((u8 *)cf, msg, op->cfsiz);\n\n\t\t\tif (op->flags & CAN_FD_FRAME) {\n\t\t\t\tif (cf->len > 64)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (cf->len > 8)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tif (msg_head->flags & TX_CP_CAN_ID) {\n\t\t\t\t/* copy can_id into frame */\n\t\t\t\tcf->can_id = msg_head->can_id;\n\t\t\t}\n\t\t}\n\t\top->flags = msg_head->flags;\n\n\t} else {\n\t\t/* insert new BCM operation for the given can_id */\n\n\t\top = kzalloc(OPSIZ, GFP_KERNEL);\n\t\tif (!op)\n\t\t\treturn -ENOMEM;\n\n\t\top->can_id = msg_head->can_id;\n\t\top->cfsiz = CFSIZ(msg_head->flags);\n\t\top->flags = msg_head->flags;\n\n\t\t/* create array for CAN frames and copy the data */\n\t\tif (msg_head->nframes > 1) {\n\t\t\top->frames = kmalloc_array(msg_head->nframes,\n\t\t\t\t\t\t   op->cfsiz,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!op->frames) {\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\top->frames = &op->sframe;\n\n\t\tfor (i = 0; i < msg_head->nframes; i++) {\n\n\t\t\tcf = op->frames + op->cfsiz * i;\n\t\t\terr = memcpy_from_msg((u8 *)cf, msg, op->cfsiz);\n\n\t\t\tif (op->flags & CAN_FD_FRAME) {\n\t\t\t\tif (cf->len > 64)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (cf->len > 8)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (err < 0) {\n\t\t\t\tif (op->frames != &op->sframe)\n\t\t\t\t\tkfree(op->frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (msg_head->flags & TX_CP_CAN_ID) {\n\t\t\t\t/* copy can_id into frame */\n\t\t\t\tcf->can_id = msg_head->can_id;\n\t\t\t}\n\t\t}\n\n\t\t/* tx_ops never compare with previous received messages */\n\t\top->last_frames = NULL;\n\n\t\t/* bcm_can_tx / bcm_tx_timeout_handler needs this */\n\t\top->sk = sk;\n\t\top->ifindex = ifindex;\n\n\t\t/* initialize uninitialized (kzalloc) structure */\n\t\thrtimer_init(&op->timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->timer.function = bcm_tx_timeout_handler;\n\n\t\t/* currently unused in tx_ops */\n\t\thrtimer_init(&op->thrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\n\t\t/* add this bcm_op to the list of the tx_ops */\n\t\tlist_add(&op->list, &bo->tx_ops);\n\n\t} /* if ((op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex))) */\n\n\tif (op->nframes != msg_head->nframes) {\n\t\top->nframes   = msg_head->nframes;\n\t\t/* start multiple frame transmission with index 0 */\n\t\top->currframe = 0;\n\t}\n\n\t/* check flags */\n\n\tif (op->flags & TX_RESET_MULTI_IDX) {\n\t\t/* start multiple frame transmission with index 0 */\n\t\top->currframe = 0;\n\t}\n\n\tif (op->flags & SETTIMER) {\n\t\t/* set timer values */\n\t\top->count = msg_head->count;\n\t\top->ival1 = msg_head->ival1;\n\t\top->ival2 = msg_head->ival2;\n\t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n\t\top->kt_ival2 = bcm_timeval_to_ktime(msg_head->ival2);\n\n\t\t/* disable an active timer due to zero values? */\n\t\tif (!op->kt_ival1 && !op->kt_ival2)\n\t\t\thrtimer_cancel(&op->timer);\n\t}\n\n\tif (op->flags & STARTTIMER) {\n\t\thrtimer_cancel(&op->timer);\n\t\t/* spec: send CAN frame when starting timer */\n\t\top->flags |= TX_ANNOUNCE;\n\t}\n\n\tif (op->flags & TX_ANNOUNCE) {\n\t\tbcm_can_tx(op);\n\t\tif (op->count)\n\t\t\top->count--;\n\t}\n\n\tif (op->flags & STARTTIMER)\n\t\tbcm_tx_start_timer(op);\n\n\treturn msg_head->nframes * op->cfsiz + MHSIZ;\n}\n\n/*\n * bcm_rx_setup - create or update a bcm rx op (for bcm_sendmsg)\n */\nstatic int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n\t\t\tint ifindex, struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\tint do_rx_register;\n\tint err = 0;\n\n\tif ((msg_head->flags & RX_FILTER_ID) || (!(msg_head->nframes))) {\n\t\t/* be robust against wrong usage ... */\n\t\tmsg_head->flags |= RX_FILTER_ID;\n\t\t/* ignore trailing garbage */\n\t\tmsg_head->nframes = 0;\n\t}\n\n\t/* the first element contains the mux-mask => MAX_NFRAMES + 1  */\n\tif (msg_head->nframes > MAX_NFRAMES + 1)\n\t\treturn -EINVAL;\n\n\tif ((msg_head->flags & RX_RTR_FRAME) &&\n\t    ((msg_head->nframes != 1) ||\n\t     (!(msg_head->can_id & CAN_RTR_FLAG))))\n\t\treturn -EINVAL;\n\n\t/* check timeval limitations */\n\tif ((msg_head->flags & SETTIMER) && bcm_is_invalid_tv(msg_head))\n\t\treturn -EINVAL;\n\n\t/* check the given can_id */\n\top = bcm_find_op(&bo->rx_ops, msg_head, ifindex);\n\tif (op) {\n\t\t/* update existing BCM operation */\n\n\t\t/*\n\t\t * Do we need more space for the CAN frames than currently\n\t\t * allocated? -> This is a _really_ unusual use-case and\n\t\t * therefore (complexity / locking) it is not supported.\n\t\t */\n\t\tif (msg_head->nframes > op->nframes)\n\t\t\treturn -E2BIG;\n\n\t\tif (msg_head->nframes) {\n\t\t\t/* update CAN frames content */\n\t\t\terr = memcpy_from_msg(op->frames, msg,\n\t\t\t\t\t      msg_head->nframes * op->cfsiz);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t/* clear last_frames to indicate 'nothing received' */\n\t\t\tmemset(op->last_frames, 0, msg_head->nframes * op->cfsiz);\n\t\t}\n\n\t\top->nframes = msg_head->nframes;\n\t\top->flags = msg_head->flags;\n\n\t\t/* Only an update -> do not call can_rx_register() */\n\t\tdo_rx_register = 0;\n\n\t} else {\n\t\t/* insert new BCM operation for the given can_id */\n\t\top = kzalloc(OPSIZ, GFP_KERNEL);\n\t\tif (!op)\n\t\t\treturn -ENOMEM;\n\n\t\top->can_id = msg_head->can_id;\n\t\top->nframes = msg_head->nframes;\n\t\top->cfsiz = CFSIZ(msg_head->flags);\n\t\top->flags = msg_head->flags;\n\n\t\tif (msg_head->nframes > 1) {\n\t\t\t/* create array for CAN frames and copy the data */\n\t\t\top->frames = kmalloc_array(msg_head->nframes,\n\t\t\t\t\t\t   op->cfsiz,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!op->frames) {\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* create and init array for received CAN frames */\n\t\t\top->last_frames = kcalloc(msg_head->nframes,\n\t\t\t\t\t\t  op->cfsiz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!op->last_frames) {\n\t\t\t\tkfree(op->frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t} else {\n\t\t\top->frames = &op->sframe;\n\t\t\top->last_frames = &op->last_sframe;\n\t\t}\n\n\t\tif (msg_head->nframes) {\n\t\t\terr = memcpy_from_msg(op->frames, msg,\n\t\t\t\t\t      msg_head->nframes * op->cfsiz);\n\t\t\tif (err < 0) {\n\t\t\t\tif (op->frames != &op->sframe)\n\t\t\t\t\tkfree(op->frames);\n\t\t\t\tif (op->last_frames != &op->last_sframe)\n\t\t\t\t\tkfree(op->last_frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* bcm_can_tx / bcm_tx_timeout_handler needs this */\n\t\top->sk = sk;\n\t\top->ifindex = ifindex;\n\n\t\t/* ifindex for timeout events w/o previous frame reception */\n\t\top->rx_ifindex = ifindex;\n\n\t\t/* initialize uninitialized (kzalloc) structure */\n\t\thrtimer_init(&op->timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->timer.function = bcm_rx_timeout_handler;\n\n\t\thrtimer_init(&op->thrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->thrtimer.function = bcm_rx_thr_handler;\n\n\t\t/* add this bcm_op to the list of the rx_ops */\n\t\tlist_add(&op->list, &bo->rx_ops);\n\n\t\t/* call can_rx_register() */\n\t\tdo_rx_register = 1;\n\n\t} /* if ((op = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex))) */\n\n\t/* check flags */\n\n\tif (op->flags & RX_RTR_FRAME) {\n\t\tstruct canfd_frame *frame0 = op->frames;\n\n\t\t/* no timers in RTR-mode */\n\t\thrtimer_cancel(&op->thrtimer);\n\t\thrtimer_cancel(&op->timer);\n\n\t\t/*\n\t\t * funny feature in RX(!)_SETUP only for RTR-mode:\n\t\t * copy can_id into frame BUT without RTR-flag to\n\t\t * prevent a full-load-loopback-test ... ;-]\n\t\t */\n\t\tif ((op->flags & TX_CP_CAN_ID) ||\n\t\t    (frame0->can_id == op->can_id))\n\t\t\tframe0->can_id = op->can_id & ~CAN_RTR_FLAG;\n\n\t} else {\n\t\tif (op->flags & SETTIMER) {\n\n\t\t\t/* set timer value */\n\t\t\top->ival1 = msg_head->ival1;\n\t\t\top->ival2 = msg_head->ival2;\n\t\t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n\t\t\top->kt_ival2 = bcm_timeval_to_ktime(msg_head->ival2);\n\n\t\t\t/* disable an active timer due to zero value? */\n\t\t\tif (!op->kt_ival1)\n\t\t\t\thrtimer_cancel(&op->timer);\n\n\t\t\t/*\n\t\t\t * In any case cancel the throttle timer, flush\n\t\t\t * potentially blocked msgs and reset throttle handling\n\t\t\t */\n\t\t\top->kt_lastmsg = 0;\n\t\t\thrtimer_cancel(&op->thrtimer);\n\t\t\tbcm_rx_thr_flush(op);\n\t\t}\n\n\t\tif ((op->flags & STARTTIMER) && op->kt_ival1)\n\t\t\thrtimer_start(&op->timer, op->kt_ival1,\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t}\n\n\t/* now we can register for can_ids, if we added a new bcm_op */\n\tif (do_rx_register) {\n\t\tif (ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\t\tif (dev) {\n\t\t\t\terr = can_rx_register(sock_net(sk), dev,\n\t\t\t\t\t\t      op->can_id,\n\t\t\t\t\t\t      REGMASK(op->can_id),\n\t\t\t\t\t\t      bcm_rx_handler, op,\n\t\t\t\t\t\t      \"bcm\", sk);\n\n\t\t\t\top->rx_reg_dev = dev;\n\t\t\t\tdev_put(dev);\n\t\t\t}\n\n\t\t} else\n\t\t\terr = can_rx_register(sock_net(sk), NULL, op->can_id,\n\t\t\t\t\t      REGMASK(op->can_id),\n\t\t\t\t\t      bcm_rx_handler, op, \"bcm\", sk);\n\t\tif (err) {\n\t\t\t/* this bcm rx op is broken -> remove it */\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn msg_head->nframes * op->cfsiz + MHSIZ;\n}\n\n/*\n * bcm_tx_send - send a single CAN frame to the CAN interface (for bcm_sendmsg)\n */\nstatic int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk,\n\t\t       int cfsiz)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tint err;\n\n\t/* we need a real device to send frames */\n\tif (!ifindex)\n\t\treturn -ENODEV;\n\n\tskb = alloc_skb(cfsiz + sizeof(struct can_skb_priv), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcan_skb_reserve(skb);\n\n\terr = memcpy_from_msg(skb_put(skb, cfsiz), msg, cfsiz);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\tif (!dev) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, sk);\n\terr = can_send(skb, 1); /* send with loopback */\n\tdev_put(dev);\n\n\tif (err)\n\t\treturn err;\n\n\treturn cfsiz + MHSIZ;\n}\n\n/*\n * bcm_sendmsg - process BCM commands (opcodes) from the userspace\n */\nstatic int bcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tint ifindex = bo->ifindex; /* default ifindex for this bcm_op */\n\tstruct bcm_msg_head msg_head;\n\tint cfsiz;\n\tint ret; /* read bytes or error codes as return value */\n\n\tif (!bo->bound)\n\t\treturn -ENOTCONN;\n\n\t/* check for valid message length from userspace */\n\tif (size < MHSIZ)\n\t\treturn -EINVAL;\n\n\t/* read message head information */\n\tret = memcpy_from_msg((u8 *)&msg_head, msg, MHSIZ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfsiz = CFSIZ(msg_head.flags);\n\tif ((size - MHSIZ) % cfsiz)\n\t\treturn -EINVAL;\n\n\t/* check for alternative ifindex for this bcm_op */\n\n\tif (!ifindex && msg->msg_name) {\n\t\t/* no bound device as default => check msg_name */\n\t\tDECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);\n\n\t\tif (msg->msg_namelen < BCM_MIN_NAMELEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (addr->can_family != AF_CAN)\n\t\t\treturn -EINVAL;\n\n\t\t/* ifindex from sendto() */\n\t\tifindex = addr->can_ifindex;\n\n\t\tif (ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\t\tif (!dev)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\t\tdev_put(dev);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (msg_head.opcode) {\n\n\tcase TX_SETUP:\n\t\tret = bcm_tx_setup(&msg_head, msg, ifindex, sk);\n\t\tbreak;\n\n\tcase RX_SETUP:\n\t\tret = bcm_rx_setup(&msg_head, msg, ifindex, sk);\n\t\tbreak;\n\n\tcase TX_DELETE:\n\t\tif (bcm_delete_tx_op(&bo->tx_ops, &msg_head, ifindex))\n\t\t\tret = MHSIZ;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase RX_DELETE:\n\t\tif (bcm_delete_rx_op(&bo->rx_ops, &msg_head, ifindex))\n\t\t\tret = MHSIZ;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase TX_READ:\n\t\t/* reuse msg_head for the reply to TX_READ */\n\t\tmsg_head.opcode  = TX_STATUS;\n\t\tret = bcm_read_op(&bo->tx_ops, &msg_head, ifindex);\n\t\tbreak;\n\n\tcase RX_READ:\n\t\t/* reuse msg_head for the reply to RX_READ */\n\t\tmsg_head.opcode  = RX_STATUS;\n\t\tret = bcm_read_op(&bo->rx_ops, &msg_head, ifindex);\n\t\tbreak;\n\n\tcase TX_SEND:\n\t\t/* we need exactly one CAN frame behind the msg head */\n\t\tif ((msg_head.nframes != 1) || (size != cfsiz + MHSIZ))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = bcm_tx_send(msg, ifindex, sk, cfsiz);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\n/*\n * notification handler for netdevice status changes\n */\nstatic void bcm_notify(struct bcm_sock *bo, unsigned long msg,\n\t\t       struct net_device *dev)\n{\n\tstruct sock *sk = &bo->sk;\n\tstruct bcm_op *op;\n\tint notify_enodev = 0;\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\treturn;\n\n\tswitch (msg) {\n\n\tcase NETDEV_UNREGISTER:\n\t\tlock_sock(sk);\n\n\t\t/* remove device specific receive entries */\n\t\tlist_for_each_entry(op, &bo->rx_ops, list)\n\t\t\tif (op->rx_reg_dev == dev)\n\t\t\t\tbcm_rx_unreg(dev, op);\n\n\t\t/* remove device reference, if this is our bound device */\n\t\tif (bo->bound && bo->ifindex == dev->ifindex) {\n\t\t\tbo->bound   = 0;\n\t\t\tbo->ifindex = 0;\n\t\t\tnotify_enodev = 1;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\tif (notify_enodev) {\n\t\t\tsk->sk_err = ENODEV;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tif (bo->bound && bo->ifindex == dev->ifindex) {\n\t\t\tsk->sk_err = ENETDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n}\n\nstatic int bcm_notifier(struct notifier_block *nb, unsigned long msg,\n\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev->type != ARPHRD_CAN)\n\t\treturn NOTIFY_DONE;\n\tif (msg != NETDEV_UNREGISTER && msg != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\tif (unlikely(bcm_busy_notifier)) /* Check for reentrant bug. */\n\t\treturn NOTIFY_DONE;\n\n\tspin_lock(&bcm_notifier_lock);\n\tlist_for_each_entry(bcm_busy_notifier, &bcm_notifier_list, notifier) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tbcm_notify(bcm_busy_notifier, msg, dev);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tbcm_busy_notifier = NULL;\n\tspin_unlock(&bcm_notifier_lock);\n\treturn NOTIFY_DONE;\n}\n\n/*\n * initial settings for all BCM sockets to be set at socket creation time\n */\nstatic int bcm_init(struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\n\tbo->bound            = 0;\n\tbo->ifindex          = 0;\n\tbo->dropped_usr_msgs = 0;\n\tbo->bcm_proc_read    = NULL;\n\n\tINIT_LIST_HEAD(&bo->tx_ops);\n\tINIT_LIST_HEAD(&bo->rx_ops);\n\n\t/* set notifier */\n\tspin_lock(&bcm_notifier_lock);\n\tlist_add_tail(&bo->notifier, &bcm_notifier_list);\n\tspin_unlock(&bcm_notifier_lock);\n\n\treturn 0;\n}\n\n/*\n * standard socket functions\n */\nstatic int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\n\t/* remove bcm_ops, timer, rx_unregister(), etc. */\n\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\n\tlock_sock(sk);\n\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\t/*\n\t\t * Don't care if we're bound or not (due to netdev problems)\n\t\t * can_rx_unregister() is always a save thing to do here.\n\t\t */\n\t\tif (op->ifindex) {\n\t\t\t/*\n\t\t\t * Only remove subscriptions that had not\n\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t * in bcm_notifier()\n\t\t\t */\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\tbcm_remove_op(op);\n\t}\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* remove procfs entry */\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif /* CONFIG_PROC_FS */\n\n\t/* remove device reference */\n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,\n\t\t       int flags)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ret = 0;\n\n\tif (len < BCM_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (bo->bound) {\n\t\tret = -EISCONN;\n\t\tgoto fail;\n\t}\n\n\t/* bind a device to this socket */\n\tif (addr->can_ifindex) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index(net, addr->can_ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\tdev_put(dev);\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbo->ifindex = dev->ifindex;\n\t\tdev_put(dev);\n\n\t} else {\n\t\t/* no interface reference for ifindex = 0 ('any' CAN device) */\n\t\tbo->ifindex = 0;\n\t}\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir) {\n\t\t/* unique socket address as filename */\n\t\tsprintf(bo->procname, \"%lu\", sock_i_ino(sk));\n\t\tbo->bcm_proc_read = proc_create_net_single(bo->procname, 0644,\n\t\t\t\t\t\t     net->can.bcmproc_dir,\n\t\t\t\t\t\t     bcm_proc_show, sk);\n\t\tif (!bo->bcm_proc_read) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n#endif /* CONFIG_PROC_FS */\n\n\tbo->bound = 1;\n\nfail:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int bcm_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tint noblock;\n\tint err;\n\n\tnoblock =  flags & MSG_DONTWAIT;\n\tflags   &= ~MSG_DONTWAIT;\n\tskb = skb_recv_datagram(sk, flags, noblock, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tif (skb->len < size)\n\t\tsize = skb->len;\n\n\terr = memcpy_to_msg(msg, skb->data, size);\n\tif (err < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\treturn err;\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (msg->msg_name) {\n\t\t__sockaddr_check_size(BCM_MIN_NAMELEN);\n\t\tmsg->msg_namelen = BCM_MIN_NAMELEN;\n\t\tmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn size;\n}\n\nstatic int bcm_sock_no_ioctlcmd(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t/* no ioctls for socket layer -> hand it down to NIC layer */\n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct proto_ops bcm_ops = {\n\t.family        = PF_CAN,\n\t.release       = bcm_release,\n\t.bind          = sock_no_bind,\n\t.connect       = bcm_connect,\n\t.socketpair    = sock_no_socketpair,\n\t.accept        = sock_no_accept,\n\t.getname       = sock_no_getname,\n\t.poll          = datagram_poll,\n\t.ioctl         = bcm_sock_no_ioctlcmd,\n\t.gettstamp     = sock_gettstamp,\n\t.listen        = sock_no_listen,\n\t.shutdown      = sock_no_shutdown,\n\t.sendmsg       = bcm_sendmsg,\n\t.recvmsg       = bcm_recvmsg,\n\t.mmap          = sock_no_mmap,\n\t.sendpage      = sock_no_sendpage,\n};\n\nstatic struct proto bcm_proto __read_mostly = {\n\t.name       = \"CAN_BCM\",\n\t.owner      = THIS_MODULE,\n\t.obj_size   = sizeof(struct bcm_sock),\n\t.init       = bcm_init,\n};\n\nstatic const struct can_proto bcm_can_proto = {\n\t.type       = SOCK_DGRAM,\n\t.protocol   = CAN_BCM,\n\t.ops        = &bcm_ops,\n\t.prot       = &bcm_proto,\n};\n\nstatic int canbcm_pernet_init(struct net *net)\n{\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* create /proc/net/can-bcm directory */\n\tnet->can.bcmproc_dir = proc_net_mkdir(net, \"can-bcm\", net->proc_net);\n#endif /* CONFIG_PROC_FS */\n\n\treturn 0;\n}\n\nstatic void canbcm_pernet_exit(struct net *net)\n{\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* remove /proc/net/can-bcm directory */\n\tif (net->can.bcmproc_dir)\n\t\tremove_proc_entry(\"can-bcm\", net->proc_net);\n#endif /* CONFIG_PROC_FS */\n}\n\nstatic struct pernet_operations canbcm_pernet_ops __read_mostly = {\n\t.init = canbcm_pernet_init,\n\t.exit = canbcm_pernet_exit,\n};\n\nstatic struct notifier_block canbcm_notifier = {\n\t.notifier_call = bcm_notifier\n};\n\nstatic int __init bcm_module_init(void)\n{\n\tint err;\n\n\tpr_info(\"can: broadcast manager protocol\\n\");\n\n\terr = can_proto_register(&bcm_can_proto);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"can: registration of bcm protocol failed\\n\");\n\t\treturn err;\n\t}\n\n\tregister_pernet_subsys(&canbcm_pernet_ops);\n\tregister_netdevice_notifier(&canbcm_notifier);\n\treturn 0;\n}\n\nstatic void __exit bcm_module_exit(void)\n{\n\tcan_proto_unregister(&bcm_can_proto);\n\tunregister_netdevice_notifier(&canbcm_notifier);\n\tunregister_pernet_subsys(&canbcm_pernet_ops);\n}\n\nmodule_init(bcm_module_init);\nmodule_exit(bcm_module_exit);\n"], "fixing_code": ["// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n/*\n * bcm.c - Broadcast Manager to filter/send (cyclic) CAN content\n *\n * Copyright (c) 2002-2017 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/list.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uio.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/can.h>\n#include <linux/can/core.h>\n#include <linux/can/skb.h>\n#include <linux/can/bcm.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/net_namespace.h>\n\n/*\n * To send multiple CAN frame content within TX_SETUP or to filter\n * CAN messages with multiplex index within RX_SETUP, the number of\n * different filters is limited to 256 due to the one byte index value.\n */\n#define MAX_NFRAMES 256\n\n/* limit timers to 400 days for sending/timeouts */\n#define BCM_TIMER_SEC_MAX (400 * 24 * 60 * 60)\n\n/* use of last_frames[index].flags */\n#define RX_RECV    0x40 /* received data for this element */\n#define RX_THR     0x80 /* element not been sent due to throttle feature */\n#define BCM_CAN_FLAGS_MASK 0x3F /* to clean private flags after usage */\n\n/* get best masking value for can_rx_register() for a given single can_id */\n#define REGMASK(id) ((id & CAN_EFF_FLAG) ? \\\n\t\t     (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \\\n\t\t     (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))\n\nMODULE_DESCRIPTION(\"PF_CAN broadcast manager protocol\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <oliver.hartkopp@volkswagen.de>\");\nMODULE_ALIAS(\"can-proto-2\");\n\n#define BCM_MIN_NAMELEN CAN_REQUIRED_SIZE(struct sockaddr_can, can_ifindex)\n\n/*\n * easy access to the first 64 bit of can(fd)_frame payload. cp->data is\n * 64 bit aligned so the offset has to be multiples of 8 which is ensured\n * by the only callers in bcm_rx_cmp_to_index() bcm_rx_handler().\n */\nstatic inline u64 get_u64(const struct canfd_frame *cp, int offset)\n{\n\treturn *(u64 *)(cp->data + offset);\n}\n\nstruct bcm_op {\n\tstruct list_head list;\n\tint ifindex;\n\tcanid_t can_id;\n\tu32 flags;\n\tunsigned long frames_abs, frames_filtered;\n\tstruct bcm_timeval ival1, ival2;\n\tstruct hrtimer timer, thrtimer;\n\tktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;\n\tint rx_ifindex;\n\tint cfsiz;\n\tu32 count;\n\tu32 nframes;\n\tu32 currframe;\n\t/* void pointers to arrays of struct can[fd]_frame */\n\tvoid *frames;\n\tvoid *last_frames;\n\tstruct canfd_frame sframe;\n\tstruct canfd_frame last_sframe;\n\tstruct sock *sk;\n\tstruct net_device *rx_reg_dev;\n};\n\nstruct bcm_sock {\n\tstruct sock sk;\n\tint bound;\n\tint ifindex;\n\tstruct list_head notifier;\n\tstruct list_head rx_ops;\n\tstruct list_head tx_ops;\n\tunsigned long dropped_usr_msgs;\n\tstruct proc_dir_entry *bcm_proc_read;\n\tchar procname [32]; /* inode number in decimal with \\0 */\n};\n\nstatic LIST_HEAD(bcm_notifier_list);\nstatic DEFINE_SPINLOCK(bcm_notifier_lock);\nstatic struct bcm_sock *bcm_busy_notifier;\n\nstatic inline struct bcm_sock *bcm_sk(const struct sock *sk)\n{\n\treturn (struct bcm_sock *)sk;\n}\n\nstatic inline ktime_t bcm_timeval_to_ktime(struct bcm_timeval tv)\n{\n\treturn ktime_set(tv.tv_sec, tv.tv_usec * NSEC_PER_USEC);\n}\n\n/* check limitations for timeval provided by user */\nstatic bool bcm_is_invalid_tv(struct bcm_msg_head *msg_head)\n{\n\tif ((msg_head->ival1.tv_sec < 0) ||\n\t    (msg_head->ival1.tv_sec > BCM_TIMER_SEC_MAX) ||\n\t    (msg_head->ival1.tv_usec < 0) ||\n\t    (msg_head->ival1.tv_usec >= USEC_PER_SEC) ||\n\t    (msg_head->ival2.tv_sec < 0) ||\n\t    (msg_head->ival2.tv_sec > BCM_TIMER_SEC_MAX) ||\n\t    (msg_head->ival2.tv_usec < 0) ||\n\t    (msg_head->ival2.tv_usec >= USEC_PER_SEC))\n\t\treturn true;\n\n\treturn false;\n}\n\n#define CFSIZ(flags) ((flags & CAN_FD_FRAME) ? CANFD_MTU : CAN_MTU)\n#define OPSIZ sizeof(struct bcm_op)\n#define MHSIZ sizeof(struct bcm_msg_head)\n\n/*\n * procfs functions\n */\n#if IS_ENABLED(CONFIG_PROC_FS)\nstatic char *bcm_proc_getifname(struct net *net, char *result, int ifindex)\n{\n\tstruct net_device *dev;\n\n\tif (!ifindex)\n\t\treturn \"any\";\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\tstrcpy(result, dev->name);\n\telse\n\t\tstrcpy(result, \"???\");\n\trcu_read_unlock();\n\n\treturn result;\n}\n\nstatic int bcm_proc_show(struct seq_file *m, void *v)\n{\n\tchar ifname[IFNAMSIZ];\n\tstruct net *net = m->private;\n\tstruct sock *sk = (struct sock *)PDE_DATA(m->file->f_inode);\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\n\tseq_printf(m, \">>> socket %pK\", sk->sk_socket);\n\tseq_printf(m, \" / sk %pK\", sk);\n\tseq_printf(m, \" / bo %pK\", bo);\n\tseq_printf(m, \" / dropped %lu\", bo->dropped_usr_msgs);\n\tseq_printf(m, \" / bound %s\", bcm_proc_getifname(net, ifname, bo->ifindex));\n\tseq_printf(m, \" <<<\\n\");\n\n\tlist_for_each_entry(op, &bo->rx_ops, list) {\n\n\t\tunsigned long reduction;\n\n\t\t/* print only active entries & prevent division by zero */\n\t\tif (!op->frames_abs)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"rx_op: %03X %-5s \", op->can_id,\n\t\t\t   bcm_proc_getifname(net, ifname, op->ifindex));\n\n\t\tif (op->flags & CAN_FD_FRAME)\n\t\t\tseq_printf(m, \"(%u)\", op->nframes);\n\t\telse\n\t\t\tseq_printf(m, \"[%u]\", op->nframes);\n\n\t\tseq_printf(m, \"%c \", (op->flags & RX_CHECK_DLC) ? 'd' : ' ');\n\n\t\tif (op->kt_ival1)\n\t\t\tseq_printf(m, \"timeo=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival1));\n\n\t\tif (op->kt_ival2)\n\t\t\tseq_printf(m, \"thr=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival2));\n\n\t\tseq_printf(m, \"# recv %ld (%ld) => reduction: \",\n\t\t\t   op->frames_filtered, op->frames_abs);\n\n\t\treduction = 100 - (op->frames_filtered * 100) / op->frames_abs;\n\n\t\tseq_printf(m, \"%s%ld%%\\n\",\n\t\t\t   (reduction == 100) ? \"near \" : \"\", reduction);\n\t}\n\n\tlist_for_each_entry(op, &bo->tx_ops, list) {\n\n\t\tseq_printf(m, \"tx_op: %03X %s \", op->can_id,\n\t\t\t   bcm_proc_getifname(net, ifname, op->ifindex));\n\n\t\tif (op->flags & CAN_FD_FRAME)\n\t\t\tseq_printf(m, \"(%u) \", op->nframes);\n\t\telse\n\t\t\tseq_printf(m, \"[%u] \", op->nframes);\n\n\t\tif (op->kt_ival1)\n\t\t\tseq_printf(m, \"t1=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival1));\n\n\t\tif (op->kt_ival2)\n\t\t\tseq_printf(m, \"t2=%lld \",\n\t\t\t\t   (long long)ktime_to_us(op->kt_ival2));\n\n\t\tseq_printf(m, \"# sent %ld\\n\", op->frames_abs);\n\t}\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n#endif /* CONFIG_PROC_FS */\n\n/*\n * bcm_can_tx - send the (next) CAN frame to the appropriate CAN interface\n *              of the given bcm tx op\n */\nstatic void bcm_can_tx(struct bcm_op *op)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * op->currframe;\n\n\t/* no target device? => exit */\n\tif (!op->ifindex)\n\t\treturn;\n\n\tdev = dev_get_by_index(sock_net(op->sk), op->ifindex);\n\tif (!dev) {\n\t\t/* RFC: should this bcm_op remove itself here? */\n\t\treturn;\n\t}\n\n\tskb = alloc_skb(op->cfsiz + sizeof(struct can_skb_priv), gfp_any());\n\tif (!skb)\n\t\tgoto out;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, cf, op->cfsiz);\n\n\t/* send with loopback */\n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, op->sk);\n\tcan_send(skb, 1);\n\n\t/* update statistics */\n\top->currframe++;\n\top->frames_abs++;\n\n\t/* reached last frame? */\n\tif (op->currframe >= op->nframes)\n\t\top->currframe = 0;\nout:\n\tdev_put(dev);\n}\n\n/*\n * bcm_send_to_user - send a BCM message to the userspace\n *                    (consisting of bcm_msg_head + x CAN frames)\n */\nstatic void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,\n\t\t\t     struct canfd_frame *frames, int has_timestamp)\n{\n\tstruct sk_buff *skb;\n\tstruct canfd_frame *firstframe;\n\tstruct sockaddr_can *addr;\n\tstruct sock *sk = op->sk;\n\tunsigned int datalen = head->nframes * op->cfsiz;\n\tint err;\n\n\tskb = alloc_skb(sizeof(*head) + datalen, gfp_any());\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, head, sizeof(*head));\n\n\tif (head->nframes) {\n\t\t/* CAN frames starting here */\n\t\tfirstframe = (struct canfd_frame *)skb_tail_pointer(skb);\n\n\t\tskb_put_data(skb, frames, datalen);\n\n\t\t/*\n\t\t * the BCM uses the flags-element of the canfd_frame\n\t\t * structure for internal purposes. This is only\n\t\t * relevant for updates that are generated by the\n\t\t * BCM, where nframes is 1\n\t\t */\n\t\tif (head->nframes == 1)\n\t\t\tfirstframe->flags &= BCM_CAN_FLAGS_MASK;\n\t}\n\n\tif (has_timestamp) {\n\t\t/* restore rx timestamp */\n\t\tskb->tstamp = op->rx_stamp;\n\t}\n\n\t/*\n\t *  Put the datagram to the queue so that bcm_recvmsg() can\n\t *  get it from there.  We need to pass the interface index to\n\t *  bcm_recvmsg().  We pass a whole struct sockaddr_can in skb->cb\n\t *  containing the interface index.\n\t */\n\n\tsock_skb_cb_check_size(sizeof(struct sockaddr_can));\n\taddr = (struct sockaddr_can *)skb->cb;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = op->rx_ifindex;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err < 0) {\n\t\tstruct bcm_sock *bo = bcm_sk(sk);\n\n\t\tkfree_skb(skb);\n\t\t/* don't care about overflows in this statistic */\n\t\tbo->dropped_usr_msgs++;\n\t}\n}\n\nstatic bool bcm_tx_set_expiry(struct bcm_op *op, struct hrtimer *hrt)\n{\n\tktime_t ival;\n\n\tif (op->kt_ival1 && op->count)\n\t\tival = op->kt_ival1;\n\telse if (op->kt_ival2)\n\t\tival = op->kt_ival2;\n\telse\n\t\treturn false;\n\n\thrtimer_set_expires(hrt, ktime_add(ktime_get(), ival));\n\treturn true;\n}\n\nstatic void bcm_tx_start_timer(struct bcm_op *op)\n{\n\tif (bcm_tx_set_expiry(op, &op->timer))\n\t\thrtimer_start_expires(&op->timer, HRTIMER_MODE_ABS_SOFT);\n}\n\n/* bcm_tx_timeout_handler - performs cyclic CAN frame transmissions */\nstatic enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\tif (op->kt_ival1 && (op->count > 0)) {\n\t\top->count--;\n\t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n\n\t\t\t/* create notification to user */\n\t\t\tmemset(&msg_head, 0, sizeof(msg_head));\n\t\t\tmsg_head.opcode  = TX_EXPIRED;\n\t\t\tmsg_head.flags   = op->flags;\n\t\t\tmsg_head.count   = op->count;\n\t\t\tmsg_head.ival1   = op->ival1;\n\t\t\tmsg_head.ival2   = op->ival2;\n\t\t\tmsg_head.can_id  = op->can_id;\n\t\t\tmsg_head.nframes = 0;\n\n\t\t\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\t\t}\n\t\tbcm_can_tx(op);\n\n\t} else if (op->kt_ival2) {\n\t\tbcm_can_tx(op);\n\t}\n\n\treturn bcm_tx_set_expiry(op, &op->timer) ?\n\t\tHRTIMER_RESTART : HRTIMER_NORESTART;\n}\n\n/*\n * bcm_rx_changed - create a RX_CHANGED notification due to changed content\n */\nstatic void bcm_rx_changed(struct bcm_op *op, struct canfd_frame *data)\n{\n\tstruct bcm_msg_head head;\n\n\t/* update statistics */\n\top->frames_filtered++;\n\n\t/* prevent statistics overflow */\n\tif (op->frames_filtered > ULONG_MAX/100)\n\t\top->frames_filtered = op->frames_abs = 0;\n\n\t/* this element is not throttled anymore */\n\tdata->flags &= (BCM_CAN_FLAGS_MASK|RX_RECV);\n\n\tmemset(&head, 0, sizeof(head));\n\thead.opcode  = RX_CHANGED;\n\thead.flags   = op->flags;\n\thead.count   = op->count;\n\thead.ival1   = op->ival1;\n\thead.ival2   = op->ival2;\n\thead.can_id  = op->can_id;\n\thead.nframes = 1;\n\n\tbcm_send_to_user(op, &head, data, 1);\n}\n\n/*\n * bcm_rx_update_and_send - process a detected relevant receive content change\n *                          1. update the last received data\n *                          2. send a notification to the user (if possible)\n */\nstatic void bcm_rx_update_and_send(struct bcm_op *op,\n\t\t\t\t   struct canfd_frame *lastdata,\n\t\t\t\t   const struct canfd_frame *rxdata)\n{\n\tmemcpy(lastdata, rxdata, op->cfsiz);\n\n\t/* mark as used and throttled by default */\n\tlastdata->flags |= (RX_RECV|RX_THR);\n\n\t/* throttling mode inactive ? */\n\tif (!op->kt_ival2) {\n\t\t/* send RX_CHANGED to the user immediately */\n\t\tbcm_rx_changed(op, lastdata);\n\t\treturn;\n\t}\n\n\t/* with active throttling timer we are just done here */\n\tif (hrtimer_active(&op->thrtimer))\n\t\treturn;\n\n\t/* first reception with enabled throttling mode */\n\tif (!op->kt_lastmsg)\n\t\tgoto rx_changed_settime;\n\n\t/* got a second frame inside a potential throttle period? */\n\tif (ktime_us_delta(ktime_get(), op->kt_lastmsg) <\n\t    ktime_to_us(op->kt_ival2)) {\n\t\t/* do not send the saved data - only start throttle timer */\n\t\thrtimer_start(&op->thrtimer,\n\t\t\t      ktime_add(op->kt_lastmsg, op->kt_ival2),\n\t\t\t      HRTIMER_MODE_ABS_SOFT);\n\t\treturn;\n\t}\n\n\t/* the gap was that big, that throttling was not needed here */\nrx_changed_settime:\n\tbcm_rx_changed(op, lastdata);\n\top->kt_lastmsg = ktime_get();\n}\n\n/*\n * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly\n *                       received data stored in op->last_frames[]\n */\nstatic void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,\n\t\t\t\tconst struct canfd_frame *rxdata)\n{\n\tstruct canfd_frame *cf = op->frames + op->cfsiz * index;\n\tstruct canfd_frame *lcf = op->last_frames + op->cfsiz * index;\n\tint i;\n\n\t/*\n\t * no one uses the MSBs of flags for comparison,\n\t * so we use it here to detect the first time of reception\n\t */\n\n\tif (!(lcf->flags & RX_RECV)) {\n\t\t/* received data for the first time => send update to user */\n\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\treturn;\n\t}\n\n\t/* do a real check in CAN frame data section */\n\tfor (i = 0; i < rxdata->len; i += 8) {\n\t\tif ((get_u64(cf, i) & get_u64(rxdata, i)) !=\n\t\t    (get_u64(cf, i) & get_u64(lcf, i))) {\n\t\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (op->flags & RX_CHECK_DLC) {\n\t\t/* do a real check in CAN frame length */\n\t\tif (rxdata->len != lcf->len) {\n\t\t\tbcm_rx_update_and_send(op, lcf, rxdata);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * bcm_rx_starttimer - enable timeout monitoring for CAN frame reception\n */\nstatic void bcm_rx_starttimer(struct bcm_op *op)\n{\n\tif (op->flags & RX_NO_AUTOTIMER)\n\t\treturn;\n\n\tif (op->kt_ival1)\n\t\thrtimer_start(&op->timer, op->kt_ival1, HRTIMER_MODE_REL_SOFT);\n}\n\n/* bcm_rx_timeout_handler - when the (cyclic) CAN frame reception timed out */\nstatic enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\t/* if user wants to be informed, when cyclic CAN-Messages come back */\n\tif ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {\n\t\t/* clear received CAN frames to indicate 'nothing received' */\n\t\tmemset(op->last_frames, 0, op->nframes * op->cfsiz);\n\t}\n\n\t/* create notification to user */\n\tmemset(&msg_head, 0, sizeof(msg_head));\n\tmsg_head.opcode  = RX_TIMEOUT;\n\tmsg_head.flags   = op->flags;\n\tmsg_head.count   = op->count;\n\tmsg_head.ival1   = op->ival1;\n\tmsg_head.ival2   = op->ival2;\n\tmsg_head.can_id  = op->can_id;\n\tmsg_head.nframes = 0;\n\n\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\n\treturn HRTIMER_NORESTART;\n}\n\n/*\n * bcm_rx_do_flush - helper for bcm_rx_thr_flush\n */\nstatic inline int bcm_rx_do_flush(struct bcm_op *op, unsigned int index)\n{\n\tstruct canfd_frame *lcf = op->last_frames + op->cfsiz * index;\n\n\tif ((op->last_frames) && (lcf->flags & RX_THR)) {\n\t\tbcm_rx_changed(op, lcf);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * bcm_rx_thr_flush - Check for throttled data and send it to the userspace\n */\nstatic int bcm_rx_thr_flush(struct bcm_op *op)\n{\n\tint updated = 0;\n\n\tif (op->nframes > 1) {\n\t\tunsigned int i;\n\n\t\t/* for MUX filter we start at index 1 */\n\t\tfor (i = 1; i < op->nframes; i++)\n\t\t\tupdated += bcm_rx_do_flush(op, i);\n\n\t} else {\n\t\t/* for RX_FILTER_ID and simple filter */\n\t\tupdated += bcm_rx_do_flush(op, 0);\n\t}\n\n\treturn updated;\n}\n\n/*\n * bcm_rx_thr_handler - the time for blocked content updates is over now:\n *                      Check for throttled data and send it to the userspace\n */\nstatic enum hrtimer_restart bcm_rx_thr_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, thrtimer);\n\n\tif (bcm_rx_thr_flush(op)) {\n\t\thrtimer_forward(hrtimer, ktime_get(), op->kt_ival2);\n\t\treturn HRTIMER_RESTART;\n\t} else {\n\t\t/* rearm throttle handling */\n\t\top->kt_lastmsg = 0;\n\t\treturn HRTIMER_NORESTART;\n\t}\n}\n\n/*\n * bcm_rx_handler - handle a CAN frame reception\n */\nstatic void bcm_rx_handler(struct sk_buff *skb, void *data)\n{\n\tstruct bcm_op *op = (struct bcm_op *)data;\n\tconst struct canfd_frame *rxframe = (struct canfd_frame *)skb->data;\n\tunsigned int i;\n\n\tif (op->can_id != rxframe->can_id)\n\t\treturn;\n\n\t/* make sure to handle the correct frame type (CAN / CAN FD) */\n\tif (skb->len != op->cfsiz)\n\t\treturn;\n\n\t/* disable timeout */\n\thrtimer_cancel(&op->timer);\n\n\t/* save rx timestamp */\n\top->rx_stamp = skb->tstamp;\n\t/* save originator for recvfrom() */\n\top->rx_ifindex = skb->dev->ifindex;\n\t/* update statistics */\n\top->frames_abs++;\n\n\tif (op->flags & RX_RTR_FRAME) {\n\t\t/* send reply for RTR-request (placed in op->frames[0]) */\n\t\tbcm_can_tx(op);\n\t\treturn;\n\t}\n\n\tif (op->flags & RX_FILTER_ID) {\n\t\t/* the easiest case */\n\t\tbcm_rx_update_and_send(op, op->last_frames, rxframe);\n\t\tgoto rx_starttimer;\n\t}\n\n\tif (op->nframes == 1) {\n\t\t/* simple compare with index 0 */\n\t\tbcm_rx_cmp_to_index(op, 0, rxframe);\n\t\tgoto rx_starttimer;\n\t}\n\n\tif (op->nframes > 1) {\n\t\t/*\n\t\t * multiplex compare\n\t\t *\n\t\t * find the first multiplex mask that fits.\n\t\t * Remark: The MUX-mask is stored in index 0 - but only the\n\t\t * first 64 bits of the frame data[] are relevant (CAN FD)\n\t\t */\n\n\t\tfor (i = 1; i < op->nframes; i++) {\n\t\t\tif ((get_u64(op->frames, 0) & get_u64(rxframe, 0)) ==\n\t\t\t    (get_u64(op->frames, 0) &\n\t\t\t     get_u64(op->frames + op->cfsiz * i, 0))) {\n\t\t\t\tbcm_rx_cmp_to_index(op, i, rxframe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nrx_starttimer:\n\tbcm_rx_starttimer(op);\n}\n\n/*\n * helpers for bcm_op handling: find & delete bcm [rx|tx] op elements\n */\nstatic struct bcm_op *bcm_find_op(struct list_head *ops,\n\t\t\t\t  struct bcm_msg_head *mh, int ifindex)\n{\n\tstruct bcm_op *op;\n\n\tlist_for_each_entry(op, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME))\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}\n\nstatic void bcm_remove_op(struct bcm_op *op)\n{\n\thrtimer_cancel(&op->timer);\n\thrtimer_cancel(&op->thrtimer);\n\n\tif ((op->frames) && (op->frames != &op->sframe))\n\t\tkfree(op->frames);\n\n\tif ((op->last_frames) && (op->last_frames != &op->last_sframe))\n\t\tkfree(op->last_frames);\n\n\tkfree(op);\n}\n\nstatic void bcm_rx_unreg(struct net_device *dev, struct bcm_op *op)\n{\n\tif (op->rx_reg_dev == dev) {\n\t\tcan_rx_unregister(dev_net(dev), dev, op->can_id,\n\t\t\t\t  REGMASK(op->can_id), bcm_rx_handler, op);\n\n\t\t/* mark as removed subscription */\n\t\top->rx_reg_dev = NULL;\n\t} else\n\t\tprintk(KERN_ERR \"can-bcm: bcm_rx_unreg: registered device \"\n\t\t       \"mismatch %p %p\\n\", op->rx_reg_dev, dev);\n}\n\n/*\n * bcm_delete_rx_op - find and remove a rx op (returns number of removed ops)\n */\nstatic int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\n\t\t\t/*\n\t\t\t * Don't care if we're bound or not (due to netdev\n\t\t\t * problems) can_rx_unregister() is always a save\n\t\t\t * thing to do here.\n\t\t\t */\n\t\t\tif (op->ifindex) {\n\t\t\t\t/*\n\t\t\t\t * Only remove subscriptions that had not\n\t\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t\t * in bcm_notifier()\n\t\t\t\t */\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; /* done */\n\t\t}\n\t}\n\n\treturn 0; /* not found */\n}\n\n/*\n * bcm_delete_tx_op - find and remove a tx op (returns number of removed ops)\n */\nstatic int bcm_delete_tx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; /* done */\n\t\t}\n\t}\n\n\treturn 0; /* not found */\n}\n\n/*\n * bcm_read_op - read out a bcm_op and send it to the user (for bcm_sendmsg)\n */\nstatic int bcm_read_op(struct list_head *ops, struct bcm_msg_head *msg_head,\n\t\t       int ifindex)\n{\n\tstruct bcm_op *op = bcm_find_op(ops, msg_head, ifindex);\n\n\tif (!op)\n\t\treturn -EINVAL;\n\n\t/* put current values into msg_head */\n\tmsg_head->flags   = op->flags;\n\tmsg_head->count   = op->count;\n\tmsg_head->ival1   = op->ival1;\n\tmsg_head->ival2   = op->ival2;\n\tmsg_head->nframes = op->nframes;\n\n\tbcm_send_to_user(op, msg_head, op->frames, 0);\n\n\treturn MHSIZ;\n}\n\n/*\n * bcm_tx_setup - create or update a bcm tx op (for bcm_sendmsg)\n */\nstatic int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n\t\t\tint ifindex, struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\tstruct canfd_frame *cf;\n\tunsigned int i;\n\tint err;\n\n\t/* we need a real device to send frames */\n\tif (!ifindex)\n\t\treturn -ENODEV;\n\n\t/* check nframes boundaries - we need at least one CAN frame */\n\tif (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)\n\t\treturn -EINVAL;\n\n\t/* check timeval limitations */\n\tif ((msg_head->flags & SETTIMER) && bcm_is_invalid_tv(msg_head))\n\t\treturn -EINVAL;\n\n\t/* check the given can_id */\n\top = bcm_find_op(&bo->tx_ops, msg_head, ifindex);\n\tif (op) {\n\t\t/* update existing BCM operation */\n\n\t\t/*\n\t\t * Do we need more space for the CAN frames than currently\n\t\t * allocated? -> This is a _really_ unusual use-case and\n\t\t * therefore (complexity / locking) it is not supported.\n\t\t */\n\t\tif (msg_head->nframes > op->nframes)\n\t\t\treturn -E2BIG;\n\n\t\t/* update CAN frames content */\n\t\tfor (i = 0; i < msg_head->nframes; i++) {\n\n\t\t\tcf = op->frames + op->cfsiz * i;\n\t\t\terr = memcpy_from_msg((u8 *)cf, msg, op->cfsiz);\n\n\t\t\tif (op->flags & CAN_FD_FRAME) {\n\t\t\t\tif (cf->len > 64)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (cf->len > 8)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tif (msg_head->flags & TX_CP_CAN_ID) {\n\t\t\t\t/* copy can_id into frame */\n\t\t\t\tcf->can_id = msg_head->can_id;\n\t\t\t}\n\t\t}\n\t\top->flags = msg_head->flags;\n\n\t} else {\n\t\t/* insert new BCM operation for the given can_id */\n\n\t\top = kzalloc(OPSIZ, GFP_KERNEL);\n\t\tif (!op)\n\t\t\treturn -ENOMEM;\n\n\t\top->can_id = msg_head->can_id;\n\t\top->cfsiz = CFSIZ(msg_head->flags);\n\t\top->flags = msg_head->flags;\n\n\t\t/* create array for CAN frames and copy the data */\n\t\tif (msg_head->nframes > 1) {\n\t\t\top->frames = kmalloc_array(msg_head->nframes,\n\t\t\t\t\t\t   op->cfsiz,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!op->frames) {\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\top->frames = &op->sframe;\n\n\t\tfor (i = 0; i < msg_head->nframes; i++) {\n\n\t\t\tcf = op->frames + op->cfsiz * i;\n\t\t\terr = memcpy_from_msg((u8 *)cf, msg, op->cfsiz);\n\n\t\t\tif (op->flags & CAN_FD_FRAME) {\n\t\t\t\tif (cf->len > 64)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (cf->len > 8)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t}\n\n\t\t\tif (err < 0) {\n\t\t\t\tif (op->frames != &op->sframe)\n\t\t\t\t\tkfree(op->frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (msg_head->flags & TX_CP_CAN_ID) {\n\t\t\t\t/* copy can_id into frame */\n\t\t\t\tcf->can_id = msg_head->can_id;\n\t\t\t}\n\t\t}\n\n\t\t/* tx_ops never compare with previous received messages */\n\t\top->last_frames = NULL;\n\n\t\t/* bcm_can_tx / bcm_tx_timeout_handler needs this */\n\t\top->sk = sk;\n\t\top->ifindex = ifindex;\n\n\t\t/* initialize uninitialized (kzalloc) structure */\n\t\thrtimer_init(&op->timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->timer.function = bcm_tx_timeout_handler;\n\n\t\t/* currently unused in tx_ops */\n\t\thrtimer_init(&op->thrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\n\t\t/* add this bcm_op to the list of the tx_ops */\n\t\tlist_add(&op->list, &bo->tx_ops);\n\n\t} /* if ((op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex))) */\n\n\tif (op->nframes != msg_head->nframes) {\n\t\top->nframes   = msg_head->nframes;\n\t\t/* start multiple frame transmission with index 0 */\n\t\top->currframe = 0;\n\t}\n\n\t/* check flags */\n\n\tif (op->flags & TX_RESET_MULTI_IDX) {\n\t\t/* start multiple frame transmission with index 0 */\n\t\top->currframe = 0;\n\t}\n\n\tif (op->flags & SETTIMER) {\n\t\t/* set timer values */\n\t\top->count = msg_head->count;\n\t\top->ival1 = msg_head->ival1;\n\t\top->ival2 = msg_head->ival2;\n\t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n\t\top->kt_ival2 = bcm_timeval_to_ktime(msg_head->ival2);\n\n\t\t/* disable an active timer due to zero values? */\n\t\tif (!op->kt_ival1 && !op->kt_ival2)\n\t\t\thrtimer_cancel(&op->timer);\n\t}\n\n\tif (op->flags & STARTTIMER) {\n\t\thrtimer_cancel(&op->timer);\n\t\t/* spec: send CAN frame when starting timer */\n\t\top->flags |= TX_ANNOUNCE;\n\t}\n\n\tif (op->flags & TX_ANNOUNCE) {\n\t\tbcm_can_tx(op);\n\t\tif (op->count)\n\t\t\top->count--;\n\t}\n\n\tif (op->flags & STARTTIMER)\n\t\tbcm_tx_start_timer(op);\n\n\treturn msg_head->nframes * op->cfsiz + MHSIZ;\n}\n\n/*\n * bcm_rx_setup - create or update a bcm rx op (for bcm_sendmsg)\n */\nstatic int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n\t\t\tint ifindex, struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct bcm_op *op;\n\tint do_rx_register;\n\tint err = 0;\n\n\tif ((msg_head->flags & RX_FILTER_ID) || (!(msg_head->nframes))) {\n\t\t/* be robust against wrong usage ... */\n\t\tmsg_head->flags |= RX_FILTER_ID;\n\t\t/* ignore trailing garbage */\n\t\tmsg_head->nframes = 0;\n\t}\n\n\t/* the first element contains the mux-mask => MAX_NFRAMES + 1  */\n\tif (msg_head->nframes > MAX_NFRAMES + 1)\n\t\treturn -EINVAL;\n\n\tif ((msg_head->flags & RX_RTR_FRAME) &&\n\t    ((msg_head->nframes != 1) ||\n\t     (!(msg_head->can_id & CAN_RTR_FLAG))))\n\t\treturn -EINVAL;\n\n\t/* check timeval limitations */\n\tif ((msg_head->flags & SETTIMER) && bcm_is_invalid_tv(msg_head))\n\t\treturn -EINVAL;\n\n\t/* check the given can_id */\n\top = bcm_find_op(&bo->rx_ops, msg_head, ifindex);\n\tif (op) {\n\t\t/* update existing BCM operation */\n\n\t\t/*\n\t\t * Do we need more space for the CAN frames than currently\n\t\t * allocated? -> This is a _really_ unusual use-case and\n\t\t * therefore (complexity / locking) it is not supported.\n\t\t */\n\t\tif (msg_head->nframes > op->nframes)\n\t\t\treturn -E2BIG;\n\n\t\tif (msg_head->nframes) {\n\t\t\t/* update CAN frames content */\n\t\t\terr = memcpy_from_msg(op->frames, msg,\n\t\t\t\t\t      msg_head->nframes * op->cfsiz);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t/* clear last_frames to indicate 'nothing received' */\n\t\t\tmemset(op->last_frames, 0, msg_head->nframes * op->cfsiz);\n\t\t}\n\n\t\top->nframes = msg_head->nframes;\n\t\top->flags = msg_head->flags;\n\n\t\t/* Only an update -> do not call can_rx_register() */\n\t\tdo_rx_register = 0;\n\n\t} else {\n\t\t/* insert new BCM operation for the given can_id */\n\t\top = kzalloc(OPSIZ, GFP_KERNEL);\n\t\tif (!op)\n\t\t\treturn -ENOMEM;\n\n\t\top->can_id = msg_head->can_id;\n\t\top->nframes = msg_head->nframes;\n\t\top->cfsiz = CFSIZ(msg_head->flags);\n\t\top->flags = msg_head->flags;\n\n\t\tif (msg_head->nframes > 1) {\n\t\t\t/* create array for CAN frames and copy the data */\n\t\t\top->frames = kmalloc_array(msg_head->nframes,\n\t\t\t\t\t\t   op->cfsiz,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!op->frames) {\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* create and init array for received CAN frames */\n\t\t\top->last_frames = kcalloc(msg_head->nframes,\n\t\t\t\t\t\t  op->cfsiz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!op->last_frames) {\n\t\t\t\tkfree(op->frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t} else {\n\t\t\top->frames = &op->sframe;\n\t\t\top->last_frames = &op->last_sframe;\n\t\t}\n\n\t\tif (msg_head->nframes) {\n\t\t\terr = memcpy_from_msg(op->frames, msg,\n\t\t\t\t\t      msg_head->nframes * op->cfsiz);\n\t\t\tif (err < 0) {\n\t\t\t\tif (op->frames != &op->sframe)\n\t\t\t\t\tkfree(op->frames);\n\t\t\t\tif (op->last_frames != &op->last_sframe)\n\t\t\t\t\tkfree(op->last_frames);\n\t\t\t\tkfree(op);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* bcm_can_tx / bcm_tx_timeout_handler needs this */\n\t\top->sk = sk;\n\t\top->ifindex = ifindex;\n\n\t\t/* ifindex for timeout events w/o previous frame reception */\n\t\top->rx_ifindex = ifindex;\n\n\t\t/* initialize uninitialized (kzalloc) structure */\n\t\thrtimer_init(&op->timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->timer.function = bcm_rx_timeout_handler;\n\n\t\thrtimer_init(&op->thrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_SOFT);\n\t\top->thrtimer.function = bcm_rx_thr_handler;\n\n\t\t/* add this bcm_op to the list of the rx_ops */\n\t\tlist_add(&op->list, &bo->rx_ops);\n\n\t\t/* call can_rx_register() */\n\t\tdo_rx_register = 1;\n\n\t} /* if ((op = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex))) */\n\n\t/* check flags */\n\n\tif (op->flags & RX_RTR_FRAME) {\n\t\tstruct canfd_frame *frame0 = op->frames;\n\n\t\t/* no timers in RTR-mode */\n\t\thrtimer_cancel(&op->thrtimer);\n\t\thrtimer_cancel(&op->timer);\n\n\t\t/*\n\t\t * funny feature in RX(!)_SETUP only for RTR-mode:\n\t\t * copy can_id into frame BUT without RTR-flag to\n\t\t * prevent a full-load-loopback-test ... ;-]\n\t\t */\n\t\tif ((op->flags & TX_CP_CAN_ID) ||\n\t\t    (frame0->can_id == op->can_id))\n\t\t\tframe0->can_id = op->can_id & ~CAN_RTR_FLAG;\n\n\t} else {\n\t\tif (op->flags & SETTIMER) {\n\n\t\t\t/* set timer value */\n\t\t\top->ival1 = msg_head->ival1;\n\t\t\top->ival2 = msg_head->ival2;\n\t\t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n\t\t\top->kt_ival2 = bcm_timeval_to_ktime(msg_head->ival2);\n\n\t\t\t/* disable an active timer due to zero value? */\n\t\t\tif (!op->kt_ival1)\n\t\t\t\thrtimer_cancel(&op->timer);\n\n\t\t\t/*\n\t\t\t * In any case cancel the throttle timer, flush\n\t\t\t * potentially blocked msgs and reset throttle handling\n\t\t\t */\n\t\t\top->kt_lastmsg = 0;\n\t\t\thrtimer_cancel(&op->thrtimer);\n\t\t\tbcm_rx_thr_flush(op);\n\t\t}\n\n\t\tif ((op->flags & STARTTIMER) && op->kt_ival1)\n\t\t\thrtimer_start(&op->timer, op->kt_ival1,\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t}\n\n\t/* now we can register for can_ids, if we added a new bcm_op */\n\tif (do_rx_register) {\n\t\tif (ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\t\tif (dev) {\n\t\t\t\terr = can_rx_register(sock_net(sk), dev,\n\t\t\t\t\t\t      op->can_id,\n\t\t\t\t\t\t      REGMASK(op->can_id),\n\t\t\t\t\t\t      bcm_rx_handler, op,\n\t\t\t\t\t\t      \"bcm\", sk);\n\n\t\t\t\top->rx_reg_dev = dev;\n\t\t\t\tdev_put(dev);\n\t\t\t}\n\n\t\t} else\n\t\t\terr = can_rx_register(sock_net(sk), NULL, op->can_id,\n\t\t\t\t\t      REGMASK(op->can_id),\n\t\t\t\t\t      bcm_rx_handler, op, \"bcm\", sk);\n\t\tif (err) {\n\t\t\t/* this bcm rx op is broken -> remove it */\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn msg_head->nframes * op->cfsiz + MHSIZ;\n}\n\n/*\n * bcm_tx_send - send a single CAN frame to the CAN interface (for bcm_sendmsg)\n */\nstatic int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk,\n\t\t       int cfsiz)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tint err;\n\n\t/* we need a real device to send frames */\n\tif (!ifindex)\n\t\treturn -ENODEV;\n\n\tskb = alloc_skb(cfsiz + sizeof(struct can_skb_priv), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcan_skb_reserve(skb);\n\n\terr = memcpy_from_msg(skb_put(skb, cfsiz), msg, cfsiz);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\tif (!dev) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\tskb->dev = dev;\n\tcan_skb_set_owner(skb, sk);\n\terr = can_send(skb, 1); /* send with loopback */\n\tdev_put(dev);\n\n\tif (err)\n\t\treturn err;\n\n\treturn cfsiz + MHSIZ;\n}\n\n/*\n * bcm_sendmsg - process BCM commands (opcodes) from the userspace\n */\nstatic int bcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tint ifindex = bo->ifindex; /* default ifindex for this bcm_op */\n\tstruct bcm_msg_head msg_head;\n\tint cfsiz;\n\tint ret; /* read bytes or error codes as return value */\n\n\tif (!bo->bound)\n\t\treturn -ENOTCONN;\n\n\t/* check for valid message length from userspace */\n\tif (size < MHSIZ)\n\t\treturn -EINVAL;\n\n\t/* read message head information */\n\tret = memcpy_from_msg((u8 *)&msg_head, msg, MHSIZ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfsiz = CFSIZ(msg_head.flags);\n\tif ((size - MHSIZ) % cfsiz)\n\t\treturn -EINVAL;\n\n\t/* check for alternative ifindex for this bcm_op */\n\n\tif (!ifindex && msg->msg_name) {\n\t\t/* no bound device as default => check msg_name */\n\t\tDECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);\n\n\t\tif (msg->msg_namelen < BCM_MIN_NAMELEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (addr->can_family != AF_CAN)\n\t\t\treturn -EINVAL;\n\n\t\t/* ifindex from sendto() */\n\t\tifindex = addr->can_ifindex;\n\n\t\tif (ifindex) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\t\tif (!dev)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\t\tdev_put(dev);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (msg_head.opcode) {\n\n\tcase TX_SETUP:\n\t\tret = bcm_tx_setup(&msg_head, msg, ifindex, sk);\n\t\tbreak;\n\n\tcase RX_SETUP:\n\t\tret = bcm_rx_setup(&msg_head, msg, ifindex, sk);\n\t\tbreak;\n\n\tcase TX_DELETE:\n\t\tif (bcm_delete_tx_op(&bo->tx_ops, &msg_head, ifindex))\n\t\t\tret = MHSIZ;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase RX_DELETE:\n\t\tif (bcm_delete_rx_op(&bo->rx_ops, &msg_head, ifindex))\n\t\t\tret = MHSIZ;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase TX_READ:\n\t\t/* reuse msg_head for the reply to TX_READ */\n\t\tmsg_head.opcode  = TX_STATUS;\n\t\tret = bcm_read_op(&bo->tx_ops, &msg_head, ifindex);\n\t\tbreak;\n\n\tcase RX_READ:\n\t\t/* reuse msg_head for the reply to RX_READ */\n\t\tmsg_head.opcode  = RX_STATUS;\n\t\tret = bcm_read_op(&bo->rx_ops, &msg_head, ifindex);\n\t\tbreak;\n\n\tcase TX_SEND:\n\t\t/* we need exactly one CAN frame behind the msg head */\n\t\tif ((msg_head.nframes != 1) || (size != cfsiz + MHSIZ))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = bcm_tx_send(msg, ifindex, sk, cfsiz);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\n/*\n * notification handler for netdevice status changes\n */\nstatic void bcm_notify(struct bcm_sock *bo, unsigned long msg,\n\t\t       struct net_device *dev)\n{\n\tstruct sock *sk = &bo->sk;\n\tstruct bcm_op *op;\n\tint notify_enodev = 0;\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\treturn;\n\n\tswitch (msg) {\n\n\tcase NETDEV_UNREGISTER:\n\t\tlock_sock(sk);\n\n\t\t/* remove device specific receive entries */\n\t\tlist_for_each_entry(op, &bo->rx_ops, list)\n\t\t\tif (op->rx_reg_dev == dev)\n\t\t\t\tbcm_rx_unreg(dev, op);\n\n\t\t/* remove device reference, if this is our bound device */\n\t\tif (bo->bound && bo->ifindex == dev->ifindex) {\n\t\t\tbo->bound   = 0;\n\t\t\tbo->ifindex = 0;\n\t\t\tnotify_enodev = 1;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\tif (notify_enodev) {\n\t\t\tsk->sk_err = ENODEV;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tif (bo->bound && bo->ifindex == dev->ifindex) {\n\t\t\tsk->sk_err = ENETDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n}\n\nstatic int bcm_notifier(struct notifier_block *nb, unsigned long msg,\n\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev->type != ARPHRD_CAN)\n\t\treturn NOTIFY_DONE;\n\tif (msg != NETDEV_UNREGISTER && msg != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\tif (unlikely(bcm_busy_notifier)) /* Check for reentrant bug. */\n\t\treturn NOTIFY_DONE;\n\n\tspin_lock(&bcm_notifier_lock);\n\tlist_for_each_entry(bcm_busy_notifier, &bcm_notifier_list, notifier) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tbcm_notify(bcm_busy_notifier, msg, dev);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tbcm_busy_notifier = NULL;\n\tspin_unlock(&bcm_notifier_lock);\n\treturn NOTIFY_DONE;\n}\n\n/*\n * initial settings for all BCM sockets to be set at socket creation time\n */\nstatic int bcm_init(struct sock *sk)\n{\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\n\tbo->bound            = 0;\n\tbo->ifindex          = 0;\n\tbo->dropped_usr_msgs = 0;\n\tbo->bcm_proc_read    = NULL;\n\n\tINIT_LIST_HEAD(&bo->tx_ops);\n\tINIT_LIST_HEAD(&bo->rx_ops);\n\n\t/* set notifier */\n\tspin_lock(&bcm_notifier_lock);\n\tlist_add_tail(&bo->notifier, &bcm_notifier_list);\n\tspin_unlock(&bcm_notifier_lock);\n\n\treturn 0;\n}\n\n/*\n * standard socket functions\n */\nstatic int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\n\t/* remove bcm_ops, timer, rx_unregister(), etc. */\n\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\n\tlock_sock(sk);\n\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\t/*\n\t\t * Don't care if we're bound or not (due to netdev problems)\n\t\t * can_rx_unregister() is always a save thing to do here.\n\t\t */\n\t\tif (op->ifindex) {\n\t\t\t/*\n\t\t\t * Only remove subscriptions that had not\n\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t * in bcm_notifier()\n\t\t\t */\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list)\n\t\tbcm_remove_op(op);\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* remove procfs entry */\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif /* CONFIG_PROC_FS */\n\n\t/* remove device reference */\n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,\n\t\t       int flags)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct bcm_sock *bo = bcm_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ret = 0;\n\n\tif (len < BCM_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (bo->bound) {\n\t\tret = -EISCONN;\n\t\tgoto fail;\n\t}\n\n\t/* bind a device to this socket */\n\tif (addr->can_ifindex) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index(net, addr->can_ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (dev->type != ARPHRD_CAN) {\n\t\t\tdev_put(dev);\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbo->ifindex = dev->ifindex;\n\t\tdev_put(dev);\n\n\t} else {\n\t\t/* no interface reference for ifindex = 0 ('any' CAN device) */\n\t\tbo->ifindex = 0;\n\t}\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir) {\n\t\t/* unique socket address as filename */\n\t\tsprintf(bo->procname, \"%lu\", sock_i_ino(sk));\n\t\tbo->bcm_proc_read = proc_create_net_single(bo->procname, 0644,\n\t\t\t\t\t\t     net->can.bcmproc_dir,\n\t\t\t\t\t\t     bcm_proc_show, sk);\n\t\tif (!bo->bcm_proc_read) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n#endif /* CONFIG_PROC_FS */\n\n\tbo->bound = 1;\n\nfail:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int bcm_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tint noblock;\n\tint err;\n\n\tnoblock =  flags & MSG_DONTWAIT;\n\tflags   &= ~MSG_DONTWAIT;\n\tskb = skb_recv_datagram(sk, flags, noblock, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tif (skb->len < size)\n\t\tsize = skb->len;\n\n\terr = memcpy_to_msg(msg, skb->data, size);\n\tif (err < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\treturn err;\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (msg->msg_name) {\n\t\t__sockaddr_check_size(BCM_MIN_NAMELEN);\n\t\tmsg->msg_namelen = BCM_MIN_NAMELEN;\n\t\tmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn size;\n}\n\nstatic int bcm_sock_no_ioctlcmd(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t/* no ioctls for socket layer -> hand it down to NIC layer */\n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct proto_ops bcm_ops = {\n\t.family        = PF_CAN,\n\t.release       = bcm_release,\n\t.bind          = sock_no_bind,\n\t.connect       = bcm_connect,\n\t.socketpair    = sock_no_socketpair,\n\t.accept        = sock_no_accept,\n\t.getname       = sock_no_getname,\n\t.poll          = datagram_poll,\n\t.ioctl         = bcm_sock_no_ioctlcmd,\n\t.gettstamp     = sock_gettstamp,\n\t.listen        = sock_no_listen,\n\t.shutdown      = sock_no_shutdown,\n\t.sendmsg       = bcm_sendmsg,\n\t.recvmsg       = bcm_recvmsg,\n\t.mmap          = sock_no_mmap,\n\t.sendpage      = sock_no_sendpage,\n};\n\nstatic struct proto bcm_proto __read_mostly = {\n\t.name       = \"CAN_BCM\",\n\t.owner      = THIS_MODULE,\n\t.obj_size   = sizeof(struct bcm_sock),\n\t.init       = bcm_init,\n};\n\nstatic const struct can_proto bcm_can_proto = {\n\t.type       = SOCK_DGRAM,\n\t.protocol   = CAN_BCM,\n\t.ops        = &bcm_ops,\n\t.prot       = &bcm_proto,\n};\n\nstatic int canbcm_pernet_init(struct net *net)\n{\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* create /proc/net/can-bcm directory */\n\tnet->can.bcmproc_dir = proc_net_mkdir(net, \"can-bcm\", net->proc_net);\n#endif /* CONFIG_PROC_FS */\n\n\treturn 0;\n}\n\nstatic void canbcm_pernet_exit(struct net *net)\n{\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* remove /proc/net/can-bcm directory */\n\tif (net->can.bcmproc_dir)\n\t\tremove_proc_entry(\"can-bcm\", net->proc_net);\n#endif /* CONFIG_PROC_FS */\n}\n\nstatic struct pernet_operations canbcm_pernet_ops __read_mostly = {\n\t.init = canbcm_pernet_init,\n\t.exit = canbcm_pernet_exit,\n};\n\nstatic struct notifier_block canbcm_notifier = {\n\t.notifier_call = bcm_notifier\n};\n\nstatic int __init bcm_module_init(void)\n{\n\tint err;\n\n\tpr_info(\"can: broadcast manager protocol\\n\");\n\n\terr = can_proto_register(&bcm_can_proto);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"can: registration of bcm protocol failed\\n\");\n\t\treturn err;\n\t}\n\n\tregister_pernet_subsys(&canbcm_pernet_ops);\n\tregister_netdevice_notifier(&canbcm_notifier);\n\treturn 0;\n}\n\nstatic void __exit bcm_module_exit(void)\n{\n\tcan_proto_unregister(&bcm_can_proto);\n\tunregister_netdevice_notifier(&canbcm_notifier);\n\tunregister_pernet_subsys(&canbcm_pernet_ops);\n}\n\nmodule_init(bcm_module_init);\nmodule_exit(bcm_module_exit);\n"], "filenames": ["net/can/bcm.c"], "buggy_code_start_loc": [787], "buggy_code_end_loc": [1538], "fixing_code_start_loc": [788], "fixing_code_end_loc": [1542], "type": "CWE-362", "message": ".A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root.", "other": {"cve": {"id": "CVE-2021-3609", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-03T19:15:08.173", "lastModified": "2023-05-16T22:39:09.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": ".A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root."}, {"lang": "es", "value": "Se ha encontrado un fallo en el protocolo de red CAN BCM en el kernel de Linux, donde un atacante local puede abusar de un fallo en el subsistema CAN para corromper la memoria, bloquear el sistema o escalar privilegios. Esta condici\u00f3n de carrera en el archivo net/can/bcm.c en el kernel de Linux permite una escalada de privilegios local a root"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.25", "versionEndExcluding": "5.13", "matchCriteriaId": "1DCA7CEB-754B-474C-BB29-B3C5A04996AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.13:rc1:*:*:*:*:*:*", "matchCriteriaId": "0CBAD0FC-C281-4666-AB2F-F8E6E1165DF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.13:rc2:*:*:*:*:*:*", "matchCriteriaId": "96AC23B2-D46A-49D9-8203-8E1BEDCA8532"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.13:rc3:*:*:*:*:*:*", "matchCriteriaId": "DA610E30-717C-4700-9F77-A3C9244F3BFD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.13:rc4:*:*:*:*:*:*", "matchCriteriaId": "1ECD33F5-85BE-430B-8F86-8D7BD560311D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.13:rc5:*:*:*:*:*:*", "matchCriteriaId": "CF351855-2437-4CF5-AD7C-BDFA51F27683"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.13:rc6:*:*:*:*:*:*", "matchCriteriaId": "25A855BA-2118-44F2-90EF-EBBB12AF51EF"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:3scale_api_management:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "C5434CC8-66E0-4378-AAB3-B2FECDDE61BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:build_of_quarkus:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "E9D25766-DC7B-44EF-8097-CC41D65CBFBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder_eus:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "445D0C8B-E07B-4F58-9F88-D5B244DAF41B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder_eus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "860EA789-CC44-409C-882D-4FC4CAB42912"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "B399239A-5211-4174-9A47-A71DBA786426"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder_for_power_little_endian_eus:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "0DEA6297-5FDB-473C-96EA-3A2506D149A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder_for_power_little_endian_eus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "CA736720-2D58-4E10-B40A-CF76586D6990"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder_for_power_little_endian_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "58D2C068-2FF0-4FAB-8317-3ABC6EF8B988"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.6:*:*:*:*:*:*:*", "matchCriteriaId": "6B62E762-2878-455A-93C9-A5DB430D7BB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.7:*:*:*:*:*:*:*", "matchCriteriaId": "14CF53D2-B585-4EA5-8F18-21BC9ECBB4B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.8:*:*:*:*:*:*:*", "matchCriteriaId": "91B493F0-5542-49F7-AAAE-E6CA6E468D7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6BBD7A51-0590-4DDF-8249-5AFA8D645CB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization_host:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB28F9AF-3D06-4532-B397-96D7E4792503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_aus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "7883DE07-470D-4160-9767-4F831B75B9A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "92BC9265-6959-4D37-BE5E-8C45E98992F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "831F0F47-3565-4763-B16F-C87B1FF2035E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "0E3F09B5-569F-4C58-9FCA-3C0953D107B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "8C9BD9AE-46FC-4609-8D99-A3CFE91D58D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus_s390x:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "F7E844B1-838D-435B-90E4-ED537EE0674C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "8EB6F417-25D0-4A28-B7BA-D21929EAA9E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "E5C80DB2-4A78-4EC9-B2A8-1E4D902C4834"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "983533DD-3970-4A37-9A9C-582BD48AA1E5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "5487EF77-D23A-4CC0-851C-E330B4485D8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_for_nfv:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "782C86CD-1B68-410A-A096-E5170AD24DA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_for_nfv_tus:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C5C134ED-8708-42B5-8138-AEA47ED9CBB6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_for_nfv_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "77C61DDC-81F3-4E2D-9CAA-17A256C85443"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_tus:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "5C3BAE34-5AFC-4EED-B6C0-5CC47CDFB416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "B92409A9-0D6B-4B7E-8847-1B63837D201F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "6897676D-53F9-45B3-B27F-7FF9A4C58D33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "E28F226A-CBC7-4A32-BE58-398FA5B42481"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DF2B9A2-8CA6-4EDF-9975-07265E363ED2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "7DA6A5AF-2EBE-4ED9-B312-DCD9D150D031"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "22D095ED-9247-4133-A133-73B7668565E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "B09ACF2D-D83F-4A86-8185-9569605D8EE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "AC10D919-57FD-4725-B8D2-39ECB476902F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "48C2E003-A71C-4D06-B8B3-F93160568182"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "3921C1CF-A16D-4727-99AD-03EFFA7C91CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "BC6DD887-9744-43EA-8B3C-44C6B6339590"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "89612649-BACF-4FAC-9BA4-324724FD93A6"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610c:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3D9B255-C1AF-42D1-BF9B-13642FBDC080"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h615c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "5921A877-18BF-43FE-915C-D226E140ACFC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h615c:-:*:*:*:*:*:*:*", "matchCriteriaId": "7296A1F2-D315-4FD5-8A73-65C480C855BE"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1971651", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/nrb547/kernel-exploitation/blob/main/cve-2021-3609/cve-2021-3609.md", "source": "secalert@redhat.com", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d5f9023fa61ee8b94f37a93f08e94b136cf1e463", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220419-0004/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/06/19/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d5f9023fa61ee8b94f37a93f08e94b136cf1e463"}}