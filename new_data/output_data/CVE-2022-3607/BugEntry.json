{"buggy_code": ["__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\nimport os\nimport tarfile\nimport zipfile\nfrom collections import defaultdict\n\nfrom flask import abort, jsonify, request\nfrom flask_babel import Locale\n\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.plugin import plugin_manager\nfrom octoprint.server.api import api\nfrom octoprint.server.util.flask import no_firstrun_access\nfrom octoprint.settings import settings\nfrom octoprint.util import yaml\n\n\n@api.route(\"/languages\", methods=[\"GET\"])\n@no_firstrun_access\n@Permissions.SETTINGS.require(403)\ndef getInstalledLanguagePacks():\n    translation_folder = settings().getBaseFolder(\"translations\", check_writable=False)\n    if not os.path.exists(translation_folder):\n        return jsonify(language_packs={\"_core\": []})\n\n    core_packs = []\n    plugin_packs = defaultdict(\n        lambda: {\"identifier\": None, \"display\": None, \"languages\": []}\n    )\n    for entry in os.scandir(translation_folder):\n        if not entry.is_dir():\n            continue\n\n        def load_meta(path, locale):\n            meta = {}\n\n            meta_path = os.path.join(path, \"meta.yaml\")\n            if os.path.isfile(meta_path):\n                try:\n                    meta = yaml.load_from_file(path=meta_path)\n                except Exception:\n                    logging.getLogger(__name__).exception(\"Could not load %s\", meta_path)\n                    pass\n                else:\n                    import datetime\n\n                    if \"last_update\" in meta and isinstance(\n                        meta[\"last_update\"], datetime.datetime\n                    ):\n                        meta[\"last_update\"] = (\n                            meta[\"last_update\"] - datetime.datetime(1970, 1, 1)\n                        ).total_seconds()\n\n            loc = Locale.parse(locale)\n            meta[\"locale\"] = locale\n            meta[\"locale_display\"] = loc.display_name\n            meta[\"locale_english\"] = loc.english_name\n            return meta\n\n        if entry.name == \"_plugins\":\n            for plugin_entry in os.scandir(entry.path):\n                if not plugin_entry.is_dir():\n                    continue\n\n                if plugin_entry.name not in plugin_manager().plugins:\n                    continue\n\n                plugin_info = plugin_manager().plugins[plugin_entry.name]\n\n                plugin_packs[plugin_entry.name][\"identifier\"] = plugin_entry.name\n                plugin_packs[plugin_entry.name][\"display\"] = plugin_info.name\n\n                for language_entry in os.scandir(plugin_entry.path):\n                    try:\n                        plugin_packs[plugin_entry.name][\"languages\"].append(\n                            load_meta(language_entry.path, language_entry.name)\n                        )\n                    except Exception:\n                        logging.getLogger(__name__).exception(\n                            \"Error while parsing metadata for language pack {} from {} for plugin {}\".format(\n                                language_entry.name,\n                                language_entry.path,\n                                plugin_entry.name,\n                            )\n                        )\n                        continue\n        else:\n            try:\n                core_packs.append(load_meta(entry.path, entry.name))\n            except ValueError:\n                logging.getLogger(__name__).exception(\n                    \"Core language pack {} doesn't appear to actually be one\".format(\n                        entry.name\n                    )\n                )\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    \"Error while parsing metadata for core language pack {} from {}\".format(\n                        entry.name, entry.path\n                    )\n                )\n\n    result = {\n        \"_core\": {\"identifier\": \"_core\", \"display\": \"Core\", \"languages\": core_packs}\n    }\n    result.update(plugin_packs)\n    return jsonify(language_packs=result)\n\n\n@api.route(\"/languages\", methods=[\"POST\"])\n@no_firstrun_access\n@Permissions.SETTINGS.require(403)\ndef uploadLanguagePack():\n    input_name = \"file\"\n    input_upload_path = (\n        input_name + \".\" + settings().get([\"server\", \"uploads\", \"pathSuffix\"])\n    )\n    input_upload_name = (\n        input_name + \".\" + settings().get([\"server\", \"uploads\", \"nameSuffix\"])\n    )\n    if input_upload_path not in request.values or input_upload_name not in request.values:\n        abort(400, description=\"No file included\")\n\n    upload_name = request.values[input_upload_name]\n    upload_path = request.values[input_upload_path]\n\n    exts = list(\n        filter(\n            lambda x: upload_name.lower().endswith(x), (\".zip\", \".tar.gz\", \".tgz\", \".tar\")\n        )\n    )\n    if not len(exts):\n        abort(\n            400,\n            description=\"File doesn't have a valid extension for a language pack archive\",\n        )\n\n    target_path = settings().getBaseFolder(\"translations\")\n\n    if tarfile.is_tarfile(upload_path):\n        _unpack_uploaded_tarball(upload_path, target_path)\n    elif zipfile.is_zipfile(upload_path):\n        _unpack_uploaded_zipfile(upload_path, target_path)\n    else:\n        abort(400, description=\"Neither zip file nor tarball included\")\n\n    return getInstalledLanguagePacks()\n\n\n@api.route(\"/languages/<string:locale>/<string:pack>\", methods=[\"DELETE\"])\n@no_firstrun_access\n@Permissions.SETTINGS.require(403)\ndef deleteInstalledLanguagePack(locale, pack):\n\n    if pack == \"_core\":\n        target_path = os.path.join(settings().getBaseFolder(\"translations\"), locale)\n    else:\n        target_path = os.path.join(\n            settings().getBaseFolder(\"translations\"), \"_plugins\", pack, locale\n        )\n\n    if os.path.isdir(target_path):\n        import shutil\n\n        shutil.rmtree(target_path)\n\n    return getInstalledLanguagePacks()\n\n\ndef _unpack_uploaded_zipfile(path, target):\n    with zipfile.ZipFile(path, \"r\") as zip:\n        # sanity check\n        map(_validate_archive_name, zip.namelist())\n\n        # unpack everything\n        zip.extractall(target)\n\n\ndef _unpack_uploaded_tarball(path, target):\n    with tarfile.open(path, \"r\") as tar:\n        # sanity check\n        map(_validate_archive_name, tar.getmembers())\n\n        # unpack everything\n        tar.extractall(target)\n\n\ndef _validate_archive_name(name):\n    if name.startswith(\"/\") or \"..\" in name:\n        raise InvalidLanguagePack(f\"Provided language pack contains invalid name {name}\")\n\n\nclass InvalidLanguagePack(Exception):\n    pass\n"], "fixing_code": ["__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\nimport os\nimport tarfile\nimport zipfile\nfrom collections import defaultdict\n\nfrom flask import abort, jsonify, request\nfrom flask_babel import Locale\n\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.plugin import plugin_manager\nfrom octoprint.server.api import api\nfrom octoprint.server.util.flask import no_firstrun_access\nfrom octoprint.settings import settings\nfrom octoprint.util import yaml\n\n\n@api.route(\"/languages\", methods=[\"GET\"])\n@no_firstrun_access\n@Permissions.SETTINGS.require(403)\ndef getInstalledLanguagePacks():\n    translation_folder = settings().getBaseFolder(\"translations\", check_writable=False)\n    if not os.path.exists(translation_folder):\n        return jsonify(language_packs={\"_core\": []})\n\n    core_packs = []\n    plugin_packs = defaultdict(\n        lambda: {\"identifier\": None, \"display\": None, \"languages\": []}\n    )\n    for entry in os.scandir(translation_folder):\n        if not entry.is_dir():\n            continue\n\n        def load_meta(path, locale):\n            meta = {}\n\n            meta_path = os.path.join(path, \"meta.yaml\")\n            if os.path.isfile(meta_path):\n                try:\n                    meta = yaml.load_from_file(path=meta_path)\n                except Exception:\n                    logging.getLogger(__name__).exception(\"Could not load %s\", meta_path)\n                    pass\n                else:\n                    import datetime\n\n                    if \"last_update\" in meta and isinstance(\n                        meta[\"last_update\"], datetime.datetime\n                    ):\n                        meta[\"last_update\"] = (\n                            meta[\"last_update\"] - datetime.datetime(1970, 1, 1)\n                        ).total_seconds()\n\n            loc = Locale.parse(locale)\n            meta[\"locale\"] = locale\n            meta[\"locale_display\"] = loc.display_name\n            meta[\"locale_english\"] = loc.english_name\n            return meta\n\n        if entry.name == \"_plugins\":\n            for plugin_entry in os.scandir(entry.path):\n                if not plugin_entry.is_dir():\n                    continue\n\n                if plugin_entry.name not in plugin_manager().plugins:\n                    continue\n\n                plugin_info = plugin_manager().plugins[plugin_entry.name]\n\n                plugin_packs[plugin_entry.name][\"identifier\"] = plugin_entry.name\n                plugin_packs[plugin_entry.name][\"display\"] = plugin_info.name\n\n                for language_entry in os.scandir(plugin_entry.path):\n                    try:\n                        plugin_packs[plugin_entry.name][\"languages\"].append(\n                            load_meta(language_entry.path, language_entry.name)\n                        )\n                    except Exception:\n                        logging.getLogger(__name__).exception(\n                            \"Error while parsing metadata for language pack {} from {} for plugin {}\".format(\n                                language_entry.name,\n                                language_entry.path,\n                                plugin_entry.name,\n                            )\n                        )\n                        continue\n        else:\n            try:\n                core_packs.append(load_meta(entry.path, entry.name))\n            except ValueError:\n                logging.getLogger(__name__).exception(\n                    \"Core language pack {} doesn't appear to actually be one\".format(\n                        entry.name\n                    )\n                )\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    \"Error while parsing metadata for core language pack {} from {}\".format(\n                        entry.name, entry.path\n                    )\n                )\n\n    result = {\n        \"_core\": {\"identifier\": \"_core\", \"display\": \"Core\", \"languages\": core_packs}\n    }\n    result.update(plugin_packs)\n    return jsonify(language_packs=result)\n\n\n@api.route(\"/languages\", methods=[\"POST\"])\n@no_firstrun_access\n@Permissions.SETTINGS.require(403)\ndef uploadLanguagePack():\n    input_name = \"file\"\n    input_upload_path = (\n        input_name + \".\" + settings().get([\"server\", \"uploads\", \"pathSuffix\"])\n    )\n    input_upload_name = (\n        input_name + \".\" + settings().get([\"server\", \"uploads\", \"nameSuffix\"])\n    )\n    if input_upload_path not in request.values or input_upload_name not in request.values:\n        abort(400, description=\"No file included\")\n\n    upload_name = request.values[input_upload_name]\n    upload_path = request.values[input_upload_path]\n\n    exts = list(\n        filter(\n            lambda x: upload_name.lower().endswith(x), (\".zip\", \".tar.gz\", \".tgz\", \".tar\")\n        )\n    )\n    if not len(exts):\n        abort(\n            400,\n            description=\"File doesn't have a valid extension for a language pack archive\",\n        )\n\n    target_path = settings().getBaseFolder(\"translations\")\n\n    if tarfile.is_tarfile(upload_path):\n        _unpack_uploaded_tarball(upload_path, target_path)\n    elif zipfile.is_zipfile(upload_path):\n        _unpack_uploaded_zipfile(upload_path, target_path)\n    else:\n        abort(400, description=\"Neither zip file nor tarball included\")\n\n    return getInstalledLanguagePacks()\n\n\n@api.route(\"/languages/<string:locale>/<string:pack>\", methods=[\"DELETE\"])\n@no_firstrun_access\n@Permissions.SETTINGS.require(403)\ndef deleteInstalledLanguagePack(locale, pack):\n\n    if pack == \"_core\":\n        target_path = os.path.join(settings().getBaseFolder(\"translations\"), locale)\n    else:\n        target_path = os.path.join(\n            settings().getBaseFolder(\"translations\"), \"_plugins\", pack, locale\n        )\n\n    if os.path.isdir(target_path):\n        import shutil\n\n        shutil.rmtree(target_path)\n\n    return getInstalledLanguagePacks()\n\n\ndef _unpack_uploaded_zipfile(path, target):\n    with zipfile.ZipFile(path, \"r\") as zip:\n        # sanity check\n        for info in zip.infolist():\n            _validate_zip_info(info, target)\n\n        # unpack everything\n        zip.extractall(target)\n\n\ndef _unpack_uploaded_tarball(path, target):\n    with tarfile.open(path, \"r\") as tar:\n        # sanity check\n        for info in tar.getmembers():\n            _validate_tar_info(info, target)\n\n        # unpack everything\n        tar.extractall(target)\n\n\ndef _validate_archive_name(name, target):\n    if not os.path.abspath(os.path.join(target, name)).startswith(target + os.path.sep):\n        raise InvalidLanguagePack(f\"Provided language pack contains invalid name {name}\")\n\n\ndef _validate_zip_info(info, target):\n    _validate_archive_name(info.filename, target)\n\n\ndef _validate_tar_info(info, target):\n    _validate_archive_name(info.name, target)\n    if not (info.isfile() or info.isdir()):\n        raise InvalidLanguagePack(\"Provided language pack contains invalid file type\")\n\n\nclass InvalidLanguagePack(Exception):\n    pass\n"], "filenames": ["src/octoprint/server/api/languages.py"], "buggy_code_start_loc": [177], "buggy_code_end_loc": [194], "fixing_code_start_loc": [177], "fixing_code_end_loc": [207], "type": "CWE-74", "message": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository octoprint/octoprint prior to 1.8.3.", "other": {"cve": {"id": "CVE-2022-3607", "sourceIdentifier": "security@huntr.dev", "published": "2022-10-19T13:15:08.840", "lastModified": "2022-10-20T19:33:53.910", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository octoprint/octoprint prior to 1.8.3."}, {"lang": "es", "value": "Un Fallo en el Saneo de Elementos Especiales en un Plano Diferente (Inyecci\u00f3n de Elementos Especiales) en el repositorio de GitHub octoprint/octoprint versiones anteriores a 1.8.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.5, "impactScore": 4.0}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.5, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-75"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octoprint:octoprint:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.3", "matchCriteriaId": "900F81F7-9FC4-44CE-ABD6-1E82DC120B4B"}]}]}], "references": [{"url": "https://github.com/octoprint/octoprint/commit/3cca3a43f3d085e9bbe5a5840c8255bb1b5d052e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2d1db3c9-93e8-4902-a55b-5ea53c22aa11", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octoprint/octoprint/commit/3cca3a43f3d085e9bbe5a5840c8255bb1b5d052e"}}